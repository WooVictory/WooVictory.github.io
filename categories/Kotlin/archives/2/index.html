
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Category: Kotlin - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/categories/Kotlin/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/08/Kotlin-isXXX-funcion-diff/"
                            aria-label=": [Kotlin] ixXXX() 함수들"
                        >
                            [Kotlin] ixXXX() 함수들
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-08T14:11:00+09:00">
	
		    Aug 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에서 제공되는 <strong>isEmpty, isNotEmpty, isBlank, isNotBlank, isNullOrBlank, isNullOrEmpty</strong> 함수의 차이점을 알아보려고 한다.</p>
<p>비교를 위해 사용할 문자열은 다음과 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emptyString = <span class="string">""</span></span><br><span class="line"><span class="keyword">val</span> blankString = <span class="string">" "</span></span><br><span class="line"><span class="keyword">val</span> blankNewLineString = <span class="string">" \n"</span></span><br><span class="line"><span class="keyword">val</span> withBlankString = <span class="string">" victory"</span></span><br><span class="line"><span class="keyword">val</span> nullString: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> standardString = <span class="string">"standard"</span></span><br></pre></td></tr></table></figure>
<h2 id="isempty">isEmpty</h2>
<ul>
<li>CharSequence가 아무 값도 포함하고 있지 않을 때, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isEmpty())</span><br><span class="line">    println(blankString.isEmpty())</span><br><span class="line">    println(blankNewLineString.isEmpty())</span><br><span class="line">    println(withBlankString.isEmpty())</span><br><span class="line">    println(nullString?.isEmpty())</span><br><span class="line">    println(standardString.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotempty">isNotEmpty</h2>
<ul>
<li>CharSequence가 어떠한 값을 포함하고 있을 때(공백 포함), true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotEmpty())</span><br><span class="line">    println(blankString.isNotEmpty())</span><br><span class="line">    println(blankNewLineString.isNotEmpty())</span><br><span class="line">    println(withBlankString.isNotEmpty())</span><br><span class="line">    println(nullString?.isNotEmpty())</span><br><span class="line">    println(standardString.isNotEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isblank">isBlank</h2>
<ul>
<li>CharSequence가 공백만을 가지고 있을 경우나 empty일 경우, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
<li>공백+개행문자 -&gt; 공백으로 판단한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isBlank())</span><br><span class="line">    println(blankString.isBlank())</span><br><span class="line">    println(blankNewLineString.isBlank())</span><br><span class="line">    println(withBlankString.isBlank())</span><br><span class="line">    println(nullString?.isBlank())</span><br><span class="line">    println(standardString.isBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotblank">isNotBlank</h2>
<ul>
<li>CharSequence가 empty 상황이 아니고, 값에 공백만 있지 않을 때 true를 반환한다.</li>
<li>즉, 아무 값도 없거나 공백만 있을 때는 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotBlank())</span><br><span class="line">    println(blankString.isNotBlank())</span><br><span class="line">    println(blankNewLineString.isNotBlank())</span><br><span class="line">    println(withBlankString.isNotBlank())</span><br><span class="line">    println(nullString?.isNotBlank())</span><br><span class="line">    println(standardString.isNotBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorempty">isNullOrEmpty</h2>
<ul>
<li>CharSequence가 비어있거나 null일 경우, true를 반환한다.</li>
<li>공백은 비어있는게 아니다. 그래서 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNullOrEmpty())</span><br><span class="line">    println(blankString.isNullOrEmpty())</span><br><span class="line">    println(blankNewLineString.isNullOrEmpty())</span><br><span class="line">    println(withBlankString.isNullOrEmpty())</span><br><span class="line">    println(nullString.isNullOrEmpty())</span><br><span class="line">    println(standardString.isNullOrEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorblank">isNullOrBlank</h2>
<ul>
<li>CharSequence가 null이거나 blank인 상황일 때, true를 반환한다.</li>
<li>공백+개행 -&gt; 비어있음(blank 상태)</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="summary">Summary</h2>
<p>어려운 내용은 아니지만, 헷갈리는 함수들이다. 그래서 사용할 때 자주 헷갈려서 정리를 했다. 주의해야 할 점은 다음과 같다.</p>
<ul>
<li>empty : 정말 아무 값도 가지지 않는 것을 말한다.
<ul>
<li>blank보다 empty가 작은 개념.</li>
</ul>
</li>
<li>blank : 공백만 있거나 정말 아무 값도 가지지 않는 것을 의미한다.
<ul>
<li>공백+개행문자도 공백으로 판단</li>
<li>blank가 더 큰 개념.</li>
</ul>
</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://thecommelier.tistory.com/16?category=718833#recentEntries" target="_blank" rel="noopener">[Android/Kotlin] isNotEmpty(), isNotBlank(), isNullOrEmpty(), isNullOrBlank() 차이점</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/08/Kotlin-isXXX-funcion-diff/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/04/Kotlin-inline/"
                            aria-label=": [Kotlin] inline, infix"
                        >
                            [Kotlin] inline, infix
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-04T14:59:31+09:00">
	
		    Aug 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>커니의 코틀린이라는 책을 참고하여 코틀린을 공부했다. inline이라는 개념이 나왔지만 간단하게만 설명이 되어있었고, 필자도 간단하게만 정리하고 넘어갔다. 그런데 다시 보니 무슨 개념인지 모르겠어서 정리하려고 한다.</p>
<h2 id="overview">OverView</h2>
<p>문서는 다음과 같이 설명되어있다.</p>
<blockquote>
<p>고차 함수를 사용하면 런타임 패널티가 있기 때문에 함수 구현 자체를 코드 내부에 넣음으로써 오버헤드를 없앨 수 있다.</p>
</blockquote>
<p>무슨 내용인지 잘 와닿지 않는다. 다음의 글을 보고 다시 생각해보자.</p>
<p><strong>일급 함수</strong></p>
<ul>
<li><strong>일급 함수</strong>는 스스로 객체로써 취급되는 함수로 다른 함수를 파라미터로 전달받고 반환할 수 있는 함수를 뜻한다.</li>
<li>코드를 통해서 확인해보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#123;a,b -&gt; a&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>위 함수는 두 개의 정수를 받아 하나의 정수값만을 출력하는 함수이다.</li>
<li>위와 같은 선언을 하게 된다면 Java에서 아래와 같은 코드로 변화을 하여 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(@NotNull Fuction2 body)</span></span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull(body, <span class="string">"body"</span>);</span><br><span class="line">    Object result = body.invoke(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 자동으로 컨버팅이 될 수 있기 때문에 아래와 같은 유동적인 방법도 사용이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printResult</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subtract</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a - b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    printResult(::sum)</span><br><span class="line">    printResult(::subtract)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드처럼 sum이나 subtract를 유동적으로 붙일 수 있다.</li>
</ul>
<h2 id="inline">inline</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        print(<span class="string">"문자열 출력!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드를 자바로 표현하면 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Function body)</span></span>&#123;</span><br><span class="line">    body.invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(System.out.println(<span class="string">"문자열 출력!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드와 같이 자바로 표현된다. 그리고 이 자바코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(<span class="keyword">new</span> Function()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>문제는 위의 sum이나 subtract처럼 조합하는 함수가 많아질수록 계속 N개만큼의 function 오브젝트가 생성된다. 이럴때 사용하게 되는 것이 <code>inline</code> 키워드이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        println(<span class="string">"문자열 출력"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>그리고 실제로 컴파일 시 doSomething()의 body()를 호출하는 부분에 저렇게 선언된 함수가 그대로 들어가게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body() 부분에 그대로 들어온다.</span></span><br><span class="line">System.out.println(<span class="string">"문자열 출력!"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 Fuction 인스턴스를 만들지 않고 callFunction 내부에 삽입되어 바로 선언되어지게 된다. 때문에 람다함수와 1급 함수가 호출된 곳에서 해당 함수를 가지게 된다.</li>
<li>하지만 inline 함수는 주의할 점이 있는데, <code>private</code> 키워드를 사용하여 함수를 정의할 수 없다. 대신 다른 접근 한정자인 <code>internal</code>을 사용해야 한다.</li>
</ul>
<h2 id="noinline">noinline</h2>
<ul>
<li>모든 람다함수에 inline을 쓰고싶지 않을 수 있다. 이 경우 아래와 같이 해당 람다 함수에 noinline 키워드를 추가해준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">callLambda</span><span class="params">(aLambda: ()</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> dontInlineLambda: () -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">    aLambda2: () -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="comment">// 실행.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>모든 함수를 <strong>inline</strong>을 사용하여 내부로 컨버팅 되어지길 원치않을 수 있다. 이 경우 위처럼 <strong>inline</strong>을 먼저 선언한 뒤 람다함수 중 사용하지 않을 함수에 <code>noinline</code> 키워드를 붙여준다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/kotlin-inline-noinline-%ED%95%9C%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1d54ff34151c" target="_blank" rel="noopener">[kotlin] inline, noinline 한번에 이해하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/04/Kotlin-inline/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/kotlin-chap3/"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            [커니의 Kotlin] Chap3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T21:52:08+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>해당 글은 <strong>커니의 코틀린</strong> 책을 구매하여 공부하고 작성한 글입니다.</p>
<h2 id="조건-확인-함수">조건 확인 함수</h2>
<p><strong>특정 값의 일치 여부 확인</strong></p>
<ol>
<li>check() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalStateException 예외를 발생시킨다.</li>
<li>require() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalArgumentException 예외를 발생시킨다.</li>
</ol>
<p>check(), require() 함수 모두 값을 확인하는 형태뿐만 아니라 조건이 일치하지 않았을 경우 수행할 작업을 함께 지정할 수 있는 형태의 함수를 지원한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(isPrepared: <span class="type">Boolean</span>, message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// isPrepared가 true가 아니면 IllegalStateException 발생.</span></span><br><span class="line">    check(isPrepared)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// message의 길이가 10 이상이 아니면 IllegalArgumentException 발생.</span></span><br><span class="line">    require(message.length&gt;<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkNotNull(), requireNotNull()</code> 함수를 사용해 특정 값의 널 여부를 확인하고 널이 아닌 값을 반환받을 수 있다. 이도 위의 함수처럼 <strong>단순히 값을 확인만 하는 형태와 함께 실행할 함수를 지정하는 형태를 지원한다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// message 값이 널이 아닐 때에만 해당 변수에 값이 할당된다.</span></span><br><span class="line">    <span class="keyword">val</span> msg = requireNotNull(message)</span><br><span class="line"></span><br><span class="line">    println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>명시적으로 실행 중단하기</strong></p>
<p>프로그램이 실행될 때, 호출될 가능성이 없는 영역이 있다. 하지만, 예기치 못한 이유로 이 영역이 실행되면 프로그램에 부작용이 발생하게 된다. 따라서 이 같은 영역에 진입하게 되는 경우 임의로 예외를 발생시킬 수 있다. <code>error()</code> 함수를 이용하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(isPrepared: <span class="type">Boolean</span>, message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPrepared가 fals일 경우</span></span><br><span class="line">    <span class="comment">// IllegalArgumentException: Not prepared yet! 예외가 발생한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!isPrepared)&#123;</span><br><span class="line">        error(<span class="string">"Not prepared yet!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다른 부분의 작업이 완료되어야 구현이 가능할 때, 보통 주석을 달아서 추가 작업이 필요하다고 표시하는 경우가 대부분이다. 하지만, 간혹 이런 주석을 확인하지 못하고 그냥 두면 버그가 발생하기도 한다. 이 문제를 해결하기 위해 코틀린에서는 <code>TODO()</code> 함수를 제공한다. 이를 통해서 <strong>NotImplementedError</strong>를 발생시켜 아직 이 부분이 완성되지 않았음을 알려준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 내부 구현이 아직 완료되지 않음.</span></span><br><span class="line">    <span class="comment">// 이 함수 호출 시 NotImplementedError가 발생.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TODO(<span class="string">"Stop is not implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="컬렉션-생성-함수">컬렉션 생성 함수</h2>
<p><strong>1. 배열</strong></p>
<p>특정 원소를 담고 있는 배열을 생성하기 위해서 <code>arrayOf()</code> 함수를 사용한다.<br>
빈 배열을 생성하고 싶은 경우 <code>emptyArray()</code> 함수를 사용한다.<br>
널 값을 포함할 수 있는 배열을 생성하고 싶은 경우, <code>arrayOfNulls()</code> 함수를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열을 포함하는 배열을 생성한다. 인자를 통해 타입 추론이 가능하다.</span></span><br><span class="line"><span class="keyword">val</span> cities = arrayOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 타입의 빈 배열을 생성한다. </span></span><br><span class="line"><span class="comment">// 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.</span></span><br><span class="line"><span class="keyword">val</span> emptyStringArray = emptyArray&lt;String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// size가 3이고 널 값을 포함할 수 있는 배열을 생성한다.</span></span><br><span class="line"><span class="comment">// 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.</span></span><br><span class="line"><span class="keyword">val</span> nullOfArray = arrayOfNulls&lt;String&gt;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>자바의 원시 타입을 포함하는 배열은 코틀린의 배열과 다른 타입으로 취급되므로, 위의 함수가 아닌 각 타입에 맞는 함수를 사용해야 한다. 아래에서 소개하는 것은 자바의 원시 타입을 포함하는 배열을 생성하는 함수들이다.</p>
<ul>
<li>booleanArrayOf() : BooleanArray 를 반환하며 자바의 boolean[] 배열과 호환된다.</li>
<li>byteArrayOf()</li>
<li>charArrayOf()</li>
<li>doubleArrayOf()</li>
<li>floatArrayOf()</li>
<li>intArrayOf()</li>
<li>longArrayOf()</li>
<li>shortArrayOf()</li>
</ul>
<p>결국 동일하기 때문에 나머지는 설명을 생략했다.</p>
<p><strong>2. 리스트</strong></p>
<ul>
<li><code>listOf()</code> : 포함하는 요소를 읽을 수만 있고 수정할 수 없는 읽기 전용 리스트를 생성할 수 있다. 다른 말로 immutable 하다고 한다.</li>
<li><code>listOfNotNull()</code> : 널 값은 무시하고 널이 아닌 값으로만 리스트를 구성할 수 있다. 인자로 전달된 모든 값이 널이라면 빈 리스트를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자가 null 값이므로 빈 리스트를 반환한다.</span></span><br><span class="line"><span class="keyword">val</span> countries = listOfNotNull(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 널 값인 인자는 무시하므로 Seoul, Tokyo만을 요소로 갖는 리스트가 생성된다.</span></span><br><span class="line"><span class="keyword">val</span> citiest = listOfNotNull(<span class="string">"Seoul"</span>, <span class="literal">null</span>, <span class="string">"Tokyo"</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>리스트에 포함된 요소를 수정할 수 있는 리스트는 <code>mutableListOf()</code> 함수를 사용하여 생성한다. 함수의 정의는 아래와 같다.</p>
<ul>
<li>fun <t> mutableListOf(vararg elements: T): MutableList<t>
<ul>
<li>인자로 받은 elements를 요소로 가지며 수정 가능한 리스트를 반환한다.</li>
</ul>
</t></t></li>
<li>fun <t> mutableListOf(): MutableList<t>
<ul>
<li>비어있는 수정 가능한 리스트를 반환한다.</li>
</ul>
</t></t></li>
</ul>
<p>또한, 자주 사용되는 ArrayList도 <code>arrayListOf()</code> 함수를 사용해 쉽게 생성할 수 있다.</p>
<p>이외에도 Map, Set(집합) 자료구조도 List와 비슷한 함수를 가지고 있다.<br>
읽기만 가능한 함수와 수정도 가능한 함수까지 이름만 다르고 동일한 형태를 취하기 때문에 설명은 생략하도록 하겠다.</p>
<ul>
<li>Map : Key, value 형태를 갖는다.</li>
<li>Set : 중복을 허용하지 않는 집합이며 순서가 없다.</li>
</ul>
<h2 id="스트림-함수">스트림 함수</h2>
<p>자바8 에서는 리스트나 맵과 같은 컬렉션에 포함된 자료를 쉽게 다룰 수 있도록 스트림 기능을 제공한다. 코틀린에서는 스트림 대신 유사한 역할을 하는 함수들을 표준 라이브러리에서 제공하며, 확장 함수 형태로 제공된다. 자바8의 스트림 기능을 사용하지 않지만, 편의상 <strong>스트림 함수</strong>라 칭하도록 하겠다.</p>
<p><strong>변환</strong></p>
<ul>
<li>map() : 함수는 컬렉션 내 인자를 다른 값이나 타입으로 변환할 때 사용한다.</li>
<li>mapIndexed() : 함수는 컬렉션 내 포함된 인자의 인덱스 값을 변환 함수 내에서 사용할 수 있다.</li>
<li>mapNotNull() : 함수는 컬렉션 내 인자를 변환함과 동시에, 변환한 값이 널 값인 경우 이를 무시한다.</li>
<li>flatMap() : 함수는 map() 함수와 달리 반환형이 Iterable이다. 따라서 하나의 인자에서 여러 개의 인자로 매핑이 필요한 경우에 사용한다.</li>
<li>groupBy() : 함수는 컬렉션 내 인자들을 지정한 기준에 따라 분류하며, 각 인자들의 리스트를 포함하는 맵 형태로 결과를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Russia"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시 이름을 대문자로 변환.</span></span><br><span class="line">    cities.map &#123; it -&gt;</span><br><span class="line">        it.toUpperCase()</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시의 이름을 받아서 길이로 변환.</span></span><br><span class="line">    cities.map &#123; it -&gt;</span><br><span class="line">        it.length</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(<span class="string">"length = <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapIndexed</span></span><br><span class="line">    cities.mapIndexed &#123; index, s -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$index</span> 번째 도시 =  <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapNotNull 길이가 5이하인 도시만 반환.</span></span><br><span class="line">    <span class="comment">// 아니면 null 반환해서 무시됨.</span></span><br><span class="line">    cities.mapNotNull &#123; it -&gt;</span><br><span class="line">        <span class="keyword">if</span> (it.length &lt;= <span class="number">5</span>) it <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap</span></span><br><span class="line">    <span class="comment">// flatMap 에서 각 인자를 끝으로 하는 새로운 범위를 반환하였으므로,</span></span><br><span class="line">    <span class="comment">// 이 범위에 해당하는 정수들이 새롭게 스트림에 추가된다.</span></span><br><span class="line">    <span class="keyword">val</span> numbers = <span class="number">1.</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">    numbers.flatMap &#123; number -&gt;</span><br><span class="line">        <span class="number">1.</span>.number</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// groupBy</span></span><br><span class="line">    cities.groupBy &#123; city -&gt;</span><br><span class="line">        <span class="keyword">if</span> (city.length &lt;= <span class="number">5</span>) <span class="string">"A"</span> <span class="keyword">else</span> <span class="string">"B"</span></span><br><span class="line">    &#125;.forEach &#123; key, cities -&gt;</span><br><span class="line">        println(<span class="string">"key= <span class="variable">$key</span>, cities= <span class="variable">$cities</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>내 생각에 자주 사용할 함수들은 map(), flatMap() 이라고 생각한다. 까먹더라도 이 두 함수는 꼭 기억하자!</strong></p>
<p><strong>필터</strong></p>
<ul>
<li>filter() : 컬렉션 내 인자들 중 주어진 조건과 일치하는 인자만 걸러주는 역할</li>
<li>take() : 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다.</li>
<li>takeLast() : take() 함수와 반대로 뒤에서부터 이 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다.</li>
<li>takeWhile() : 첫 번째 인자부터 시작하여 <strong>주어진 조건을 만족하는 인자까지를 포함하는 리스트를 반환</strong>한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap04</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 28/05/2019</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>,<span class="string">"spain"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. filter</span></span><br><span class="line">    cities.filter &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">5</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 2. take</span></span><br><span class="line">    cities.take(<span class="number">1</span>)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 3. takeLast</span></span><br><span class="line">    cities.takeLast(<span class="number">3</span>)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 4. takeWhile</span></span><br><span class="line">    <span class="comment">// spain도 문자열의 길이가 5이하지만, NewYork이 조건을 만족하지 않으므로</span></span><br><span class="line">    <span class="comment">// 이후의 인자들을 모두 무시한다.</span></span><br><span class="line">    cities.takeWhile &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">5</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// takeLastWhile</span></span><br><span class="line">    <span class="comment">// 리스트의 뒤에서부터 접근한다. 컬렉션 내 항목의 순서는 유지된다.</span></span><br><span class="line">    cities.takeLastWhile &#123; city -&gt;</span><br><span class="line">        city.length &lt; <span class="number">13</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line">spain</span><br><span class="line"></span><br><span class="line"><span class="comment">// take</span></span><br><span class="line">Seoul</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeLast</span></span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br><span class="line">spain</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeWhile</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeLastWhile</span></span><br><span class="line">spain</span><br></pre></td></tr></table></figure>
<p>drop() 함수라는 것이 존재하는데, 이는 take() 함수의 반대 역할을 한다. 조건을 만족하는 항목을 컬렉션에서 제외한 결과를 반환한다. take() 함수와 유사하게 dropLast(), dropWhile(), dropLastWhile() 함수를 지원한다. 사용 예제는 책을 참고하길 바란다.</p>
<p><strong>다른 종류의 함수</strong></p>
<ul>
<li>first() : 컬렉션 내 첫 번째 인자를 반환한다. 뿐만 아니라 조건을 만족하는 첫번째 인자를 반환할 수도 있다. 조건을 만족하는 인자가 없는 경우 <strong>NoSuchElementException</strong> 예외를 발생시킨다.</li>
<li>firstOrNull() : 예외 대신 널 값을 반환하도록 할 수 있다.</li>
<li>last() : 함수는 first() 함수와 반대 역할을 한다.</li>
<li>lastOfNull() : 함수도 지원한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>, <span class="string">"spain"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 첫 번째와 마지막 인자를 반환한다.</span></span><br><span class="line">    println(<span class="string">"first: <span class="subst">$&#123;cities.first()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"last: <span class="subst">$&#123;cities.last()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조건에 맞는 첫 번째, 마지막 인자를 반환한다.</span></span><br><span class="line">    println(<span class="string">"first 조건: <span class="subst">$&#123;cities.first &#123; city -&gt; city.length &gt; <span class="number">5</span> &#125;</span>&#125;"</span>)</span><br><span class="line">    println(<span class="string">"first 조건: <span class="subst">$&#123;cities.last &#123; city -&gt; city.length &gt; <span class="number">5</span> &#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 없을 경우 예외가 아닌 널 값을 반환한다.</span></span><br><span class="line">    <span class="comment">// 비어있는 도시가 있으면 찾은 첫 번째 도시를 반환하지만, 없기 때문에 예외 대신 널을 반환한다.</span></span><br><span class="line">    println(cities.firstOrNull &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;)</span><br><span class="line">    println(cities.lastOrNull &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>distinct()</code> : <strong>함수는 컬렉션 내 포함된 항목 중 중복된 항목을 걸러낸 결과를 반환한다. 이때 항목의 중복 여부는 equals()로 판단하며, distinctBy() 함수를 사용하면 비교에 사용할 키 값을 직접 설정할 수 있다.</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>, <span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시 목록 중 중복된 항목을 제거한다.</span></span><br><span class="line">    cities.distinct()</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 중복된 항목을 판단할 때, 도시 이름의 길이를 판단 기준으로 사용한다.</span></span><br><span class="line">    <span class="comment">// 즉, 문자열의 길이가 같은 경우 같은 항목으로 판단.</span></span><br><span class="line">    cities.distinctBy &#123; city -&gt;</span><br><span class="line">        city.length</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">// distinct</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line">NewYork</span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br><span class="line"></span><br><span class="line"><span class="comment">// distincBy</span></span><br><span class="line">Seoul</span><br><span class="line">NewYork</span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br></pre></td></tr></table></figure>
<p><strong>조합 및 합계</strong></p>
<ul>
<li><code>zip()</code> : 두 컬렉션 내의 자료들을 조합하여 새로운 자료를 만들 때 사용한다. 두 컬렉션 간 자료의 개수가 달라도 사용할 수 있으며, 이 경우에 반환되는 컬렉션의 자료 수는 조합에 사용하는 컬렉션 중 자료의 수가 더 적은 쪽을 따라간다.</li>
</ul>
<p>기본값으로는 조합된 결과를 Pair로 만들어주며, 원하는 경우 조합 규칙을 사용자가 정의하여 사용할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cityCodes = listOf(<span class="string">"SEO"</span>, <span class="string">"TOK"</span>, <span class="string">"MTV"</span>, <span class="string">"NYC"</span>)</span><br><span class="line">    <span class="keyword">val</span> cityNames = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 단순히 zip 함수를 호출.</span></span><br><span class="line">    cityCodes.zip(cityNames)</span><br><span class="line">            .forEach &#123; pair -&gt;</span><br><span class="line">                println(<span class="string">"<span class="subst">$&#123;pair.first&#125;</span> : <span class="subst">$&#123;pair.second&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 조합할 자료의 타입을 zip 함수를 통해 지정하면 해당 형태로 바꿔준다.</span></span><br><span class="line">    cityCodes.zip(cityNames) &#123; code, name -&gt; <span class="string">"<span class="variable">$code</span>(<span class="variable">$name</span>)"</span> &#125;</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">SEO : Seoul</span><br><span class="line">TOK : Tokyo</span><br><span class="line">MTV : Mountain View</span><br><span class="line"></span><br><span class="line">SEO(Seoul)</span><br><span class="line">TOK(Tokyo)</span><br><span class="line">MTV(Mountain View)</span><br></pre></td></tr></table></figure>
<ul>
<li>joinToString() : 함수는 컬렉션 내 자료를 문자열 형태로 변환함과 동시에, 이를 조합하여 하나의 문자열로 생성한다. 이는 컬렉션 내 자료를 직렬화할 때 매우 유용하다.</li>
</ul>
<p>인자 없이 함수를 호출하는 경우 기본 설정을 바탕으로 컬렉션 내 자료를 문자열로 변환하며, 몇 가지 인자를 함께 전달하면 자신이 원하는 형태로 출력 문자열을 구성할 수도 있다.</p>
<ul>
<li>count() : 함수는 컬렉션 내 포함된 자료의 개수를 반환하며, 별도의 조건식을 추가하면 해당 조건을 만족하는 자료의 개수를 반환하도록 할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"기본 joinToString = <span class="subst">$&#123;cities.joinToString()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"인자 포함 joinToString = <span class="subst">$&#123;cities.joinToString(separator = " | ")&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"기본 count = <span class="subst">$&#123;cities.count()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"인자 포함 count = <span class="subst">$&#123;cities.count &#123; cities -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        cities.length &lt;= <span class="number">5</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">기본 joinToString = Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">인자 포함 joinToString = Seoul | Tokyo | Mountain View | NYC | Singapore</span><br><span class="line">기본 count = <span class="number">5</span></span><br><span class="line">인자 포함 count = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>reduce()</code> : <strong>함수는 컬렉션 내 자료들을 모두 합쳐 하나의 값으로 만들어주는 역할을 한다.</strong> joinToString() 함수는 reduce() 함수의 일종이라고 볼 수 있다. 첫 번째 자료부터 조합을 시작하며, reduceRight() 함수는 동일한 작업을 컬렉션 내 마지막 자료부터 시작한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acc 에는 지금까지 조합된 결과가, s 에는 새로 조합할 자료가 들어간다.</span></span><br><span class="line">    println(<span class="string">"reduce 결과 = <span class="subst">$&#123;cities.reduce &#123; acc, s -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        "$acc, $s"</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 마지막 인자부터 조합한다.</span></span><br><span class="line">    println(<span class="string">"reduceRight 결과 = <span class="subst">$&#123;cities.reduceRight &#123; s, acc -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        "$s, $acc"</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">reduce 결과 = Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">reduceRight 결과 = Singapore, NYC, Mountain View, Tokyo, Seoul</span><br></pre></td></tr></table></figure>
<ul>
<li>fold() : 함수는 reduce() 함수와 거의 동일한 역할을 하나, 초기값을 지정할 수 있다. fold()도 컬렉션 내 마지막 인자부터 작업을 수행하는 foldRight() 함수를 지원한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * acc - 지금까지 조합된 결과가 들어간다.</span></span><br><span class="line"><span class="comment"> * s - 새로 조합할 자료가 들어간다.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(cities.fold(<span class="string">"초기값 지정"</span>) &#123; acc, s -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$acc</span>, <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    println(cities.foldRight(<span class="string">"마지막부터 간다."</span>)&#123; s, acc -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$acc</span>, <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">초기값 지정, Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">마지막부터 간다., Singapore, NYC, Mountain View, Tokyo, Seoul</span><br></pre></td></tr></table></figure>
<p><strong>기타 함수</strong></p>
<ul>
<li>any() : 함수는 컬렉션 내 단 하나의 자료라도 존재한다면 true를, 그렇지 않으면 false를 반환한다. 조건식을 전달할 경우, 해당 조건식을 만족하는 자료의 유무 여부를 반환한다.</li>
<li>none() : 함수는 any() 함수와 반대 작업을 수행하며, 컬렉션이 비어있는지 여부를 반환한다. 마찬가지로 조건식을 전달할 경우, 해당 조건식을 만족하는 자료가 하나도 존재하지 않는지 여부를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(cities.any()) </span><br><span class="line">    println(cities.any &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">1</span></span><br><span class="line">    &#125;) </span><br><span class="line"></span><br><span class="line">    println(cities.none()) </span><br><span class="line">    println(cities.none &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="comment">// 빈 문자열을 가진 도시가 존재하지 않는지 확인한다.</span></span><br><span class="line">    <span class="comment">// 존재하지 않으므로 true 반환.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>max(), min() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내에서 각각 최대값 및 최소값을 찾아 반환한다.</li>
<li>average() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내 자료들의 평균을 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"max =&gt; <span class="subst">$&#123;cities.max()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"min =&gt; <span class="subst">$&#123;cities.min()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"average =&gt; <span class="subst">$&#123;cities.average().toInt()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">max =&gt; <span class="number">8</span></span><br><span class="line">min =&gt; <span class="number">0</span></span><br><span class="line">average =&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="범위-지정-함수">범위 지정 함수</h2>
<p>개발을 하다 보면 특정 객체에 있는 함수를 연속해서 사용하거나 다른 함수의 인자로 전달하기 위해 변수를 선언하고 이를 다른 곳에서는 사용하지 않는 경우가 있다. 코틀린에서는 이런 경우 유용하게 사용할 수 있는 함수를 표준 라이브러리를 통해 제공한다.</p>
<p><strong>let() 함수</strong></p>
<p>let() 함수는 이 함수를 호출한 객체를 이어지는 함수 블록의 인자로 전달한다.</p>
<ul>
<li>정의 =&gt; fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R
<ul>
<li>이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 인자로 전달하며, block 함수의 결과를 반환한다.</li>
</ul>
</li>
<li><strong>불필요한 변수 선언을 방지</strong>할 수 있다.</li>
<li><strong>널 값이 아닌 경우를 체크한 후 특정 작업을 수행</strong>할 때 사용할 수 있다.</li>
<li>Nullable 객체를 다른 Nullable 객체로 변환하는 경우</li>
<li>단일 지역 변수의 범위를 제한하는 경우</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이를 통해 불필요한 변수 선언을 방지할 수 있다.</span></span><br><span class="line">TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">16</span>f, resources.displayMetrics).toInt().let&#123;</span><br><span class="line">    <span class="comment">// 계산된 값을 인자로 받아서 함수에 바로 대입한다.</span></span><br><span class="line">    setPadding(it,<span class="number">0</span>,it,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// message가 null이 아닐 때만 블록 안의 문장을 실행한다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">do</span><span class="params">(message: <span class="type">String</span>?)</span></span>&#123;</span><br><span class="line">    message?.let&#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nullable personal 객체를 nullable driversLicence 객체로 변경한다.</span></span><br><span class="line"><span class="keyword">val</span> driversLicence: Licence? = getNullablePerson?.let&#123;</span><br><span class="line">    licenceService.getDriversLicence(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단일 지역 변수의 범위를 제한한다.</span></span><br><span class="line"><span class="keyword">val</span> person: Person = getPerson()</span><br><span class="line">getPersonDao().let&#123; dao -&gt;</span><br><span class="line">    <span class="comment">// 변수 dao의 범위는 이 블록 안으로 제한된다.</span></span><br><span class="line">    dao.insert(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>apply() 함수</strong></p>
<p>이 함수를 호출하는 객체를 이어지는 함수 블록의 리시버(receiver)로 전달한다.</p>
<ul>
<li>정의 =&gt; fun <t> T.apply(block: T.() -&gt; Unit): T
<ul>
<li>이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 리시버로 전달하며, 함수를 호출한 객체를 반환한다.</li>
</ul>
</t></li>
<li>함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하므로, <strong>이 블록 내에서는 해당 객체 내의 프로퍼티나 함수를 직접 호출할 수 있다.</strong></li>
<li>따라서 객체 이름을 명시하지 않아도 되므로 <strong>코드를 간략</strong>하게 만들 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> perter = Person().apply&#123;</span><br><span class="line">    <span class="comment">// apply의 블록에서는 오직 프로퍼티만 사용한다.</span></span><br><span class="line">    name = <span class="string">"Perter"</span></span><br><span class="line">    age = <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>with() 함수</strong></p>
<p>인자로 받은 객체를 이어지는 함수 블록의 리시버로 전달한다.</p>
<ul>
<li>정의 =&gt; fun &lt;T,R&gt; with(receiver: T, block: T.() -&gt; R): R
<ul>
<li>인자로 받은 객체 receiver를 이어지는 함수형 인자 block의 리시버로 전달하며, block 결과를 반환한다.</li>
</ul>
</li>
<li>함수에서 사용할 객체를 매개변수를 통해서 받는다.</li>
<li>Non-nullable(Null이 될 수 없는) 객체에 이 함수를 사용한다.</li>
<li>그리고 결과가 필요하지 않은 경우에 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person: Person = getPerson()</span><br><span class="line">with(person)&#123;</span><br><span class="line">    println(name)</span><br><span class="line">    println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manipulateView</span><span class="params">(messageView: <span class="type">TextView</span>)</span></span>&#123;</span><br><span class="line">    with(messageView)&#123;</span><br><span class="line">        text = <span class="string">"Hello"</span></span><br><span class="line">        gravity = Gravity.CENTER</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>run() 함수</strong></p>
<p>인자가 없는 익명 함수처럼 사용하는 형태와 객체에서 호출하는 형태를 제공한다.</p>
<ul>
<li>정의 =&gt; fun <r> run(block: () -&gt; R): R
<ul>
<li>함수형 인자 block을 호출하고 그 결과를 반환한다.</li>
</ul>
</r></li>
<li>정의 =&gt; fun&lt;T,R&gt; run(block: T(). -&gt; R): R
<ul>
<li>이 함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하고 그 결과를 반환한다.</li>
</ul>
</li>
</ul>
<p>run() 함수를 인자가 없는 익명 함수처럼 사용하는 경우, 복잡한 계산을 위해 여러 임시 변수가 필요할 때 유용하게 사용할 수 있다. run() 함수 내부에서 선언되는 변수들은 블록 외부에 노출되지 않으므로 변수 선언 영역을 확실히 분리할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> padding = run&#123;</span><br><span class="line">    <span class="comment">// 이 블록 내부에서 선언하는 값들은 외부에 노출되지 않는다.</span></span><br><span class="line">    <span class="keyword">val</span> defaultPadding = TypedValue.applyDimension(...)</span><br><span class="line">    <span class="keyword">val</span> extraPadding = TypedValue.applyDimension(...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 계산된 값을 반환한다.</span></span><br><span class="line">    defaultPadding+extraPadding</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체에서 run() 함수를 호출하는 경우 with() 함수와 유사한 목적으로 사용할 수 있다. 단, run() 함수는 안전한 호출을 사용할 수 있으므로 널 값일 수 있는 객체의 속성이나 함수에 연속적으로 접근해야 할 때 유용하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAge</span><span class="params">(person: <span class="type">Person</span>?)</span></span>&#123;</span><br><span class="line">    <span class="comment">// person을 수신 객체로 변환하여 age 값을 사용.</span></span><br><span class="line">    person?.run&#123;</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@limgyumin/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%98-apply-with-let-also-run-%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-4a517292df29" target="_blank" rel="noopener">코틀린 의 apply, with, let, also, run 은 언제 사용하는가?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/kotlin-chap3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/What-is-Kotlin-Object/"
                            aria-label=": [Kotlin] Object"
                        >
                            [Kotlin] Object
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T00:25:51+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에는 static 개념이 없다. 사실 개념이 없다기 보다는 static keyword가 없기 때문에 Java의 static 개념을 코틀린에서 표현할 수 없다. 그래서 이를 어떻게 표현하는지 중점적으로 살펴보겠다.</p>
<ul>
<li>싱글톤을 정의하는 방법</li>
<li>동반 객체 companion object를 이용한 팩토리 메소드 구현</li>
<li>익명 클래스 선언</li>
</ul>
<p>위의 3가지를 <strong>object</strong> keyword를 이용해 표현한다.</p>
<h2 id="싱글톤">싱글톤</h2>
<p>코틀린에서는 object를 이용하여 클래스를 정의함과 동시에 객체를 생성할 수 있다. 말 그대로 싱글톤을 쉽게 구현할 수 있다. 이해하기 쉽게 간단한 예제를 만들었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPreference</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SharedPreference INSTACNE=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedPreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTACNE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTACNE = SharedPreference();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 자바에서 사용할 수 있는 간단한 싱글톤 패턴 구현 코드이다. 그럼 이제 코틀린에서 object를 사용해 바꿔보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreference&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    SharedPreference.init(applicationContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 object로 선언하면 클래스 선언과 동시에 객체가 생성된다. 따라서 객체 이름을 통해 property나 메소드에 접근할 수 있다.</p>
<p>object 클래스는 가장 바깥 클래스로 선언될 수도 있고, 내부에 중첩된 클래스 형태로 선언될 수도 있다. 하지만, 어떤 방식으로 선언되었던 간에 존재하는 object는 단일 객체만 존재한다.</p>
<h2 id="companion-object">companion object</h2>
<p>코틀린에서는 static을 지원하지 않는 대신 <code>top-level function</code>을 통해 같은 효과를 낼 수 있다. 단, top-level function은 class 내부에 선언된 private property에는 접근할 수 없는 제한을 받는다.</p>
<p>이를 해결하기 위해서 <code>companion object</code>라는 개념이 존재한다. 클래스의 인스턴스 생성과 상관없이 호출해야 하지만 class의 내부 정보에 접근할 수 있는 함수가 필요할 때 companion obejct를 class 내부에 선언한다. <strong>Java로 따지면 class 내부에 static 함수를 넣는다고 생각하면 된다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion obejct call!!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    A.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 A 클래스 내부에서 선언된 companion object는 호출할 때 클래스 이름으로 바로 호출할 수 있다. (Java의 static 함수와 동일한 형태이다.)</p>
<p>또한, <code>companion object</code>는 외부 클래스의 private property에도 접근이 가능하기 때문에, factory method를 만들 때 적합하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId: <span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> subscribingUser = User.newSubscribingUser(<span class="string">"jhsw0375@gmail.com"</span>)</span><br><span class="line">    <span class="keyword">val</span> facebookUser = User.newFacebookUser(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    println(subscribingUser.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 User 클래스는 <strong>private constructor</strong>를 가지기 때문에 외부에서 생성할 수 없다. 따라서 외부에서는 companion으로 제공되는 factory method를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</p>
<h2 id="companion-object의-사용">companion object의 사용</h2>
<p>companion object는 클래스 내부에 정의된 일반 객체이다. 따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object에 이름 명명</li>
<li>companion object 내부에 확장 함수나 property 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: Person = ... 생략.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    person = Person.Loader.fromJSON(<span class="string">"&#123;name: 'kim'&#125;"</span>)</span><br><span class="line">    person = Person.fromJSON(<span class="string">"&#123;name: 'lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>companion object에 이름을 붙일 수 있으며, 이름을 통해서 호출할 수도 있고 그냥 호출할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: JSONFactory&#123;</span><br><span class="line">        <span class="keyword">override</span> fromJSON(jsonText: String): Person = ... 생략</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> loadFromText<span class="type">&lt;T&gt;</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T&#123;</span><br><span class="line">    ... 생략.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    loadFromText(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 companion object가 특정 interface를 구현할 수도 있고, 이 interface를 넘겨줄 때는 외부 class 이름을 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"clicked!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">    clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 익명 클래스는 singleton이 아니다. 따라서 호출시 매번 객체가 생성된다는 점과 익명 클래스 내에서는 외부 클래스의 변수에 접근하여 값을 수정할 수도 있다.</p>
<h2 id="sharedpreferences-예제">SharedPreferences 예제</h2>
<p>Android에서는 간단한 값을 저장하기 위해서 <code>SharedPreferences</code>를 사용한다. 프로그램 어디서나 이 객체를 사용할 수 있어야 하기 때문에 일반적으로 <strong>Singleton</strong>을 이용해 구현하곤 한다. 자바에서는 싱글톤을 손쉽게 구현할 수 있다. 마찬가지로 코틀린에서도 object 개념을 사용해서 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreferenceManager&#123;</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> PREF_TOKEN = <span class="string">"token"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span>&#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 확장 함수를 사용한다. 따라서 edit(), apply() 함수를 호출할 필요가 없다. 모든 작업을 이 함수 하나로 대체할 수 있다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(operation: (<span class="type">SharedPreferences</span>.<span class="type">Editor</span>)</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> editor = edit()</span><br><span class="line">        operation(edit)</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> token: String</span><br><span class="line">        <span class="keyword">get</span>() = preferences.getString(PREF_TOKEN,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = preferences.edit&#123;</span><br><span class="line">            it.putString(PREF_TOKEN, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>간단하게 토큰을 저장하는 예제이다. 저장해서 확인해보는 과정까지 거친 코드이므로 잘 동작한다. 확장 함수를 만들어서 이를 통해 edit(), apply() 함수를 직접 호출할 필요가 없다. 작성한 함수만 사용하면 되기 때문이다.</p>
<p>또한, 여러 개의 함수를 만들 필요 없이 하나의 함수만 사용하면 되고 저장할 값이 필요하다면 token 처럼 만들어서 사용자 지정 get,set을 사용하여 값을 가져오고 저장하는 과정을 거치면 된다.</p>
<p>이 클래스를 만들기 위해서 처음에 어떻게 잘 짤 수 있을까를 먼저 고민해보았다. 그런데 바보 같은 생각이라는 걸 깨달았다. 처음부터 잘 짤 수는 없는 것이다. 완벽한 코드는 없으면 코드를 짜면서 공부를 하면서 수정하면 되는 것이다.</p>
<p>그러니 처음부터 완벽한 코드를 짜려고 애쓰지 않도록 마음 먹었다. 리팩토링을 하면 나의 코드를 더 발전시켜 나갈 수 있으니 말이다. 오늘은 여기까지!</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://lomza.totem-soft.com/tutorial-how-to-use-sharedpreferences-in-kotlin/" target="_blank" rel="noopener">[Tutorial] How to use SharedPreferences in Kotlin</a></li>
<li><a href="https://tourspace.tistory.com/109" target="_blank" rel="noopener">[Kotlin] 코틀린 object</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/What-is-Kotlin-Object/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/07/kotlin-chap2/"
                            aria-label=": [커니의 Kotlin] Chap2"
                        >
                            [커니의 Kotlin] Chap2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-07T17:15:30+09:00">
	
		    May 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="코틀린의-특징"># 코틀린의 특징</h2>
<h2 id="클래스"># 클래스</h2>
<p><strong>1. 데이터 클래스</strong></p>
<ul>
<li>자료를 저장하는 클래스를 만드는 과정을 단순하게 해준다.</li>
<li>자료를 구성하는 프로퍼티만 선언하면 컴파일러가 equlas(), hashcode(), toString(), copy() 함수를 자동으로 생성해준다.</li>
<li>코틀린에서 <code>==</code>는 자바의 equals() 메소드와 같은 동작을 한다. 즉, 값을 비교한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 주 생성자에서 데이터 클래스에 포함되는 프로퍼티를 함께 선언한다. </span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lee = Person(<span class="string">"lee"</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">val</span> park = Person(<span class="string">"park"</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="keyword">val</span> lim = Person(<span class="string">"lee"</span>,<span class="number">26</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 한정 클래스</strong></p>
<ul>
<li>한정 클래스(seald class)는 enum 클래스를 확장한 개념이다.</li>
<li>이를 상속하는 클래스는 한정 클래스로 정의되는 여러 종류 중 하나로 취급된다.</li>
<li>한정 클래스를 상속하는 클래스는 일반적으로 클래스 내에 중첩하여 선언한다. 외부에 선언할 수도 있다.</li>
<li>한정 클래스로 정의된 클래스의 종류에 따라 다른 작업을 처리해야 할 때 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileApp</span></span>(<span class="keyword">val</span> os: String)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Android</span></span>(os: String, <span class="keyword">val</span> packageName: String) : MobileApp(os)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iOS</span></span>(os: String, <span class="keyword">val</span> bundleId: String) : MobileApp(os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whoAmI</span><span class="params">(app: <span class="type">MobileApp</span>)</span></span> = <span class="keyword">when</span>(app)&#123;</span><br><span class="line">    <span class="keyword">is</span> MobileApp.Android -&gt; println(<span class="string">"<span class="subst">$&#123;app.os&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">is</span> MobileApp.iOS -&gt; println(<span class="string">"<span class="subst">$&#123;app.os&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// 모든 경우를 처리했으므로 else를 쓰지 않아도 된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>한정 클래스에 새로운 클래스를 추가했고, 한정 클래스를 상속한 클래스의 종류에 따라 다른 동작을 처리해야 한다고 가정해보자. 새로 추가된 유형인 <strong>WindowsMobile</strong> 클래스를 처리하지 않으면 컴파일 에러가 발생하므로 새로운 유형에 대한 처리가 누락되는 것을 방지할 수 있다. <strong>따라서 동작을 처리하는 것의 누락을 방지할 수 있다는 이점을 가지고 있다.</strong></p>
<p><strong>3. 프로퍼티의 사용자 getter/setter</strong></p>
<ul>
<li>프로퍼티에는 내부에 저장된 필드의 값을 가져오거나 설정할 수 있도록 getter/setter를 내부적으로 구현하고 있다. 이는 단순히 필드의 값을 반환하거나 설정하도록 구현되어 있다.</li>
<li>사용자 지정 getter/setter의 구현을 원하는대로 변경할 수 있으며, 특정 객체의 값에 따른 다양한 정보를 속성 형태로 제공할 때 유용.</li>
<li>get(), set(value) 사용.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나이에 따른 성인 여부를 속성 형태로 제공하는 예시.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> adult : <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age&gt;=<span class="number">19</span></span><br><span class="line">    <span class="comment">// 19세 이상이면 성인으로 간주한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용자 지정 setter를 사용하면 프로퍼티 내 필드에 설정되는 값을 제어할 수 있으나, <strong>읽고 쓰기가 모두 가능한 프로퍼티(var)에서만 사용할 수 있다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> adult : <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age&gt;=<span class="number">19</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value)&#123;</span><br><span class="line">            field = value.subString(<span class="number">0.</span><span class="number">.9</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 사용자 지정 setter를 사용해 인자로 들어온 문자열의 앞 10자리만 필드에 저장한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="함수"># 함수</h2>
<p><strong>1. 명명된 인자</strong></p>
<ul>
<li>명명된 인자(named parameter)를 사용함으로써 함수를 호출할 때 매개변수의 순서와 상관없이 인자를 전달할 수 있다.</li>
<li>또한, 매개변수의 수가 많아지더라도 각 인자에 어떤 값이 전달되는지 쉽게 구분할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">drawCircle</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, radius: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    drawCircle(x = <span class="number">10</span>,y = <span class="number">5</span>,radius = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 순서를 바꿔도 명명된 인자를 통해서 순서를 바꿔도 동일하게 호출할 수 있다.</span></span><br><span class="line">    drawCircle(y = <span class="number">5</span>,x = <span class="number">10</span>,radius = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인자 중 일부에만 사용할 수도 있다.</span></span><br><span class="line">    drawCircle(<span class="number">10</span>,<span class="number">5</span>,radius = <span class="number">25</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 매개변수</strong></p>
<ul>
<li>함수의 매개변수에 기본값을 지정할 수 있으며, 이때 지정하는 값을 기본 매개변수라고 한다.</li>
<li>유용하게 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 반지름의 기본값으로 25를 갖는다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">drawCircle</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, radius:<span class="type">Int</span> = <span class="number">25</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 반지름을 지정하지 않았으므로 원의 반지름은 기본 값인 25로 지정된다.</span></span><br><span class="line">    drawCircle(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 단일 표현식 표기</strong></p>
<ul>
<li>Unit 타입을 제외한 타입을 반환하는 함수라면 함수의 내용을 단일 표현식을 사용하여 정의할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본 형태.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단일 표현식.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반환 타입도 생략 가능.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure>
<p><strong>3. 확장 함수</strong></p>
<ul>
<li>확장 함수를 사용하여 상속 없이 기존 클래스에 새로운 함수를 추가할 수 있다.</li>
<li>확장 함수를 추가할 대상 클래스는 리시버 타입(receiver type)이라 부르며, 이 리시버 타입 뒤에 점(.)을 찍고 그 뒤에 원하는 함수의 형태를 적는 방식으로 정의한다.</li>
<li>확장 함수 구현부에서는 this를 사용하여 클래스의 인스턴스에 접근할 수 있으며 이를 리시버 객체(receiver object)라 부른다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> foo = <span class="string">"Foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> foobar = foo.withBar()</span><br><span class="line">    println(foobar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 클래스에 withPostfix() 함수 추가.</span></span><br><span class="line"><span class="comment">// this를 사용하여 인스턴스에 접근할 수 있다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">withPostfix</span><span class="params">(postFix: <span class="type">String</span>)</span></span> : String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$this</span><span class="variable">$postFix</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this를 사용하여 인스턴스에 접근할 수 있으므로, 앞에서 정의한 확장 함수를 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">withBar</span><span class="params">()</span></span> = <span class="keyword">this</span>.withPostfix(<span class="string">"Bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">FooBar</span><br></pre></td></tr></table></figure>
<ul>
<li>확장 함수를 호출하는 모습이 클래스 내 정의된 함수의 경우와 똑같다 할지라도, 이는 클래스 외부에 정의하는 함수이다.</li>
<li>리시버 객체에서는 클래스 내 public으로 정의된 프로퍼티나 함수에만 접근할 수 있다.</li>
<li><strong>확장 함수는 리시버 타입에 직접 추가되는 함수가 아니다. 리시버 타입과 확장 함수의 인자를 인자로 받는 새로운 함수를 만들고, 확장 함수를 호출하면 이 새로운 함수가 호출되는 형태이다.</strong></li>
</ul>
<p><strong>4. 연산자 오버로딩</strong></p>
<ul>
<li>사용자 정의 타입에 한해 연산자 오버로딩을 지원한다.</li>
<li>각 연산자별로 사전 정의된 함수를 재정의하는 방식으로 연산자 오버로딩을 사용할 수 있다.</li>
<li><code>operator</code> 키워드를 사용하며, 기존의 연산자를 재정의하는 것만 허용된다.</li>
<li>연산자 재정의는 방법이 동일하기 때문에 사용자가 원하는 형태를 직접 구현하면 된다. 아래에 단항 연산자를 기준으로 예를 들어보겠다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volume</span></span>(<span class="keyword">var</span> left: <span class="built_in">Int</span>, <span class="keyword">var</span> right: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 단항 연산자 '-'를 재정의한다.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span>: Volume&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = -<span class="keyword">this</span>.left</span><br><span class="line">        <span class="keyword">this</span>.right = -<span class="keyword">this</span>.right</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> voulme = Volume(<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Volume 클래스 내 left, right 값이 반전되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> v1 = -volume</span><br></pre></td></tr></table></figure>
<p>주의할 점은 <strong>비교 연산자</strong>의 경우에는 다른 연산자와 달리 각 연산자가 모두 동일한 함수에 할당된다. 따라서 해당 함수가 반환하는 값의 크기에 따라 해당 연산자의 참, 거짓 여부를 판단한다. <strong>comparTo 함수의 반환형은 항상 Int 어야 한다.</strong></p>
<h2 id="람다-표현식"># 람다 표현식</h2>
<ul>
<li>람다 표현식을 통해 훨씬 간편하고 직관적인 문법을 사용할 수 있다.</li>
<li>특히 익명 클래스를 간결하게 표현할 때 유용하게 사용할 수 있다.</li>
<li>중괄호를 사용하여 앞뒤를 묶어준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식을 사용한 리스너 선언.</span></span><br><span class="line">button.setOnClickListener(&#123;v: View -&gt; doSomething()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인자 타입 생략 가능.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething()&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>람다 표현식에서 하나의 메소드만 호출한다면 <strong>멤버 참조</strong>를 이용해 더 간략하게 표현할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(v: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething() 함수 하나만을 호출하고 있다.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething(v)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 멤버 참조를 사용해 doSomething() 함수에 바로 대입할 수 있다.</span></span><br><span class="line">button.setOnClickListener(::doSomething)</span><br></pre></td></tr></table></figure>
<p>코틀린에서는 프로퍼티도 멤버 참조를 지원한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 성인 여부를 표시하는 프로퍼티</span></span><br><span class="line">    <span class="keyword">val</span> adult = age&gt;<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAdults</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 필터링 조건을 람다 표현식을 사용해 대입.</span></span><br><span class="line">    people.filter(&#123;people -&gt; people.adult&#125;)</span><br><span class="line">        .forEach&#123; println(<span class="string">"Name= <span class="subst">$&#123;it.name&#125;</span>) &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 멤버 참조를 사용해 adult 프로퍼티를 바로 대입한다.</span></span><br><span class="line"><span class="string">    people.filter(Person::adult)</span></span><br><span class="line"><span class="string">        .forEach&#123; println("</span>Name= $&#123;it.name&#125;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>람다 표현식의 유용한 기능</strong></p>
<ul>
<li>함수가 단 하나의 함수 타입 매개변수를 가질 경우, 인자 대입을 위한 괄호를 생략하고 바로 람다 표현식을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setOnClickListener의 마지막 인자로 함수 타입을 대입한다.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다른 인자가 없으므로, 괄호 없이 바로 외부에 람다 표현식을 사용할 수 있다.</span></span><br><span class="line">button.setOnClickListener &#123; v -&gt; doSomething() &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>또한, 람다 표현식 내 매개변수의 개수가 하나인 경우 매개 변수 선언을 생략할 수 있으며, 참조가 필요한 경우 it을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener&#123; doSomething(it) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여러 개의 매개 변수를 갖는 람다 표현식에서 사용하지 않는 매개변수는 이름 대신 _를 사용하여 사용하지 않는 매개변수라는 것을 명시할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dialog = AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dialog 매개 변수를 사용하지 않아 _로 표시</span></span><br><span class="line">    .setNegativeButton(<span class="string">"Cancel"</span>) &#123;_, which -&gt; doCancel(which)&#125;</span><br><span class="line">    .create()</span><br></pre></td></tr></table></figure>
<p><strong>인라인 함수</strong></p>
<ul>
<li>람다 표현식을 사용하면, 함수를 인자로 넘길 수 있는 고차 함수(higher-order function)에 들어갈 함수형 인자를 쉽게 표현할 수 있다.</li>
<li>인라인 함수를 사용하면 함수의 매개변수로 받는 함수형 인자의 본체를 해당 인자가 사용되는 부분에 그대로 대입하므로 성능 하락을 방지할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자로 받은 함수를 내부에서 실행하는 함수.</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    println(<span class="string">"onPreExecute()"</span>)</span><br><span class="line">    body()</span><br><span class="line">    println(<span class="string">"onPostExecute()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인라인 함수 호출.</span></span><br><span class="line">doSomething&#123; println(<span class="string">"do Something()"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>인라인 함수는 컴파일 과정에서 아래와 같이 변환된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"onPreExecute()"</span>)</span><br><span class="line"><span class="comment">// 인자로 전달된 함수 본체의 내용이 그대로 복사된 것을 확인할 수 있다.</span></span><br><span class="line">println(<span class="string">"do Something()"</span>)</span><br><span class="line">println(<span class="string">"onPostExecute()"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="여타-특징"># 여타 특징</h2>
<p><strong>타입 별칭</strong></p>
<ul>
<li>복잡한 구조로 구성된 타입을 간략하게 표현할 수 있다.</li>
<li><code>typealias</code>를 사용한다.</li>
<li>클래스나 함수와 마찬가지로 타입을 인자로 받을 수도 있으며, 함수형 타입에도 타입 별칭을 지정할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;Person&gt;을 PeopleList라는 이름을 갖는 타입 별칭으로 선언.</span></span><br><span class="line">typealias PeopleList = List&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(people: <span class="type">PeopleList</span>)</span></span>&#123;</span><br><span class="line">    people.forEach&#123;</span><br><span class="line">        <span class="comment">// 메시지 전송.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입 별칭을 사용해 새롭게 선언한다고 해서 이 타입에 해당하는 새로운 클래스가 생성되는 것은 아니다. <strong>타입 별칭으로 선언된 타입은 컴파일 시점에 모두 원래 타입으로 변환되므로 실행 시점의 부하가 없다는 장점이 있다.</strong></p>
<p><strong>분해 선언</strong></p>
<ul>
<li>각 프로퍼티가 가진 자료의 값을 한번에 여러 개의 값(val) 혹은 변수(var)에 할당할 수 있다. 이 기능을 분해 선언이라고 부른다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: Strig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = Person(<span class="string">"Lee"</span>,<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사람 객체에 포함된 필드의 값을 한번에 여러 값에 할당한다.</span></span><br><span class="line"><span class="keyword">val</span> (ageOfPerson, nameOfPerson) = person</span><br></pre></td></tr></table></figure>
<p>분해 선언은 프로퍼티가 가진 자료의 값을 어떻게 전달할까? 이를 알아보기 위해 해당 코드가 어떻게 컴파일되는지 아래에서 알아보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ageOfPerson: <span class="built_in">Int</span> = person.component1()</span><br><span class="line"><span class="keyword">val</span> nameOfPerson: String = person.component2()</span><br></pre></td></tr></table></figure>
<p>이처럼 분해 선언을 사용하면 내부적으로 각 값에 component1(), component2() 함수의 반환값을 할당한다. 프로퍼티의 수가 늘어나면 3,4, … 와 같이 함수 뒤의 숫자가 증가하는 형태, 즉 componentN() 형태의 함수를 추가로 사용하게 된다.</p>
<p>분해 선언을 사용하려면 클래스에 프로퍼티의 수만큼 componentN() 함수가 있어야 하며, 이 함수들을 포함하고 있는 클래스에만 분해 선언을 사용할 수 있다. 아래는 분해 선언을 기본으로 제공하는 클래스들이다.</p>
<ul>
<li>data class로 선언된 클래스</li>
<li>kotlin.Pair</li>
<li>kotlin.Triple</li>
<li>kotlin.collections.Map.Entry</li>
</ul>
<p>특히, 맵 자료구조를 사용할 때 유용하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cities: Map&lt;String, String&gt; = ... <span class="comment">// 도시 정보를 저장하고 있는 맵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 맵 내 각 항목의 키와 값을 별도로 선언하여 사용한다.</span></span><br><span class="line"><span class="comment">// 따라서 keySet()과 같은 함수가 필요없어진다.</span></span><br><span class="line"><span class="keyword">for</span>((cityCode, name) <span class="keyword">in</span> cities)&#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$cityCode</span> = <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다 표현식 내 매개변수에서도 분해 선언을 사용할 수 있다.</span></span><br><span class="line">cities.forEach&#123; cityCode, name -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$cityCode</span> = <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>분해 선언을 지원하는 클래스를 제외한 개발자가 작성한 클래스에서 분해 선언을 사용하고 싶다면, <strong>해당 클래스 내에 별도로 componentN() 함수를 프로퍼티의 선언 순서 및 타입에 알맞게 추가해줘야 한다.</strong></p>
<p>componentN() 함수를 선언할 때는 앞에 operator를 붙여 줘야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="comment">// 첫 번째 프로퍼티의 값 반환.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = <span class="keyword">this</span>.age</span><br><span class="line">    <span class="comment">// 두 번째 프로퍼티의 값 반환.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = Person(<span class="string">"lee"</span>,<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 분해 선언 사용.</span></span><br><span class="line"><span class="keyword">val</span> (age,name) = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용하지 않는 변수 혹은 값은 _로 표시한다.</span></span><br><span class="line"><span class="comment">// 따라서 아래는 name 만 사용하는 경우이다.</span></span><br><span class="line"><span class="keyword">val</span> (_, name) = person</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/07/kotlin-chap2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/03/kotlin-chap1-2/"
                            aria-label=": [커니의 Kotlin] Chap1.2"
                        >
                            [커니의 Kotlin] Chap1.2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-03T20:47:16+09:00">
	
		    May 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>1부에 이어서 작성…</p>
<h2 id="특징들"># 특징들</h2>
<p><strong>생성자</strong></p>
<ul>
<li>생성자 부분은 자바와 비교했을 때 조금 다른 면이 있다.</li>
<li>다음은 기본 생성자의 정의이다.
<ul>
<li>init 블록을 사용해 기본 생성자를 대체한다.</li>
</ul>
</li>
<li>생성자에 인자가 필요한 경우 인자처럼 받을 수 있다.
<ul>
<li>이를 주 생성자라고 부른다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        <span class="comment">// 기본 생성자에서 수행할 작업.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(a : <span class="built_in">Int</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$a</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>생성자의 인자를 통해 클래스 내부의 프로퍼티에 값을 할당할 수 있다.</li>
<li>생성자의 인자를 통해 프로퍼티 선언을 대신한다. 따라서 추가로 프로퍼티 선언이 필요 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>생성자의 인자에서 프로퍼티 선언이 함께 이루어지고, 값 할당 또한 생성자 호출과 동시에 수행되므로 짧은 코드를 확인할 수 있다.</li>
<li>주 생성자 외에 다른 형태의 생성자가 필요한 경우 <code>constructor</code> 키워드를 사용해 선언할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a 값만 인자로 받는 추가 생성자.</span></span><br><span class="line">    <span class="comment">// 기본 생성자를 반드시 호출해야 한다.</span></span><br><span class="line">    <span class="keyword">constructor</span>(a: <span class="built_in">Int</span>) : <span class="keyword">this</span>(a,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 두 인자의 값을 모두 0으로 지정하는 생성자.</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.(상속과 this를 사용해서!)</li>
<li>추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다. 따라서 프로퍼티 선언이 필요한 경우 주 생성자에서 이를 처리해야 한다.</li>
<li>생성자 앞에 접근 제한자를 붙여 가시성을 변경할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(a: <span class="built_in">Int</span>) : <span class="keyword">this</span>(a,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(): <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>생성자는 중요한 개념이므로 추후 더 추가할 예정.</p>
<p><strong>함수</strong></p>
<ul>
<li>메소드를 함수로 표현한다.</li>
<li>void -&gt; Unit이며 반환 값이 없음을 의미한다.</li>
<li>또한, 반환 값이 없는 함수는 Unit을 생략할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: <span class="built_in">Unit</span>&#123;</span><br><span class="line">        <span class="comment">// Unit 생략 가능.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>상속 및 인터페이스 구현</strong></p>
<ul>
<li>클래스의 상속과 인터페이스 구현을 구분하지 않고 콜론(:)으로 통일한다.</li>
<li>클래스를 상속받는 경우 반드시 부모 클래스의 생성자를 호출해야 하며, 부모 클래스의 생성자는 super 키워드를 사용해 호출한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View&#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs)&#123;</span><br><span class="line">        <span class="comment">// 뷰 초기화</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자가 여럿일 경우 this 키워드를 사용해 자기 자신의 생성자를 호출할 수 있다.</span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context,<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs)&#123;</span><br><span class="line">        <span class="comment">// 뷰 초기화</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>오버라이드 시 어노테이션을 사용하지 않고 <strong>override 키워드</strong>를 사용한다.</li>
<li>open 키워드를 사용해 클래스 혹은 함수의 상속 여부를 결정할 수 있다.
<ul>
<li>open 키워드가 있으면 상속 가능.</li>
<li>open 키워드가 없으면 상속 불가능(Java의 final과 비슷)</li>
</ul>
</li>
</ul>
<p><strong>this</strong></p>
<ul>
<li>해당 키워드를 사용한 클래스 자신을 지칭할 때 사용한다.</li>
<li>해당 위치에서 가장 가까운 범위의 클래스를 의미한다. 따라서 클래스 내에서 다른 클래스나 인터페이스의 객체를 동적으로 생성하여 사용하는 경우 키워드를 사용하는 위치에 따라 this가 의미하는 클래스가 달라질 수 있다.</li>
<li>따라서 <code>this@{클래스이름}</code> 처럼 명확하게 표시해준다.</li>
</ul>
<p><strong>동반객체</strong></p>
<ul>
<li>동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있으면서 인스턴스 생성 없이 호출할 수 있는 함수를 작성할 수 있다.</li>
<li>어디서든 접근이 가능하다.</li>
<li>즉, 자바의 static 메소드, static 멤버와 같은 역할을 한다고 볼 수 있다.</li>
<li>왜냐하면 코틀린은 클래스 내에 정적 필드나 정적 함수를 둘 수 없다. 그러한 개념이 없기 때문이다. 대신에 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트를 정의할 수 있는데, 이를 동반 객체라고 한다.</li>
</ul>
<p><strong>싱글톤</strong></p>
<ul>
<li>단 하나의 인스턴스만 생성되도록 제약을 둔 패턴으로 코틀린에서 object를 사용해 <strong>간편</strong>하게 선언할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"aa call!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> aValue = Singleton.a</span><br><span class="line">Singleton.aa()</span><br></pre></td></tr></table></figure>
<p>코틀린에서의 특징만 살펴보도록 하겠다. 다 정리하기에는 시간이 오래 걸릴 듯 싶어서이다…<br>
시간이 생긴다면 정리하지 않은 특징도 추구하도록 하겠다. :)</p>
<p><strong>is 연산자</strong></p>
<ul>
<li>자료형을 확인하기 위해 사용한다.</li>
<li>자바의 instanceOf 연산자와 동일한 기능을 한다.</li>
<li>특정 타입이 아닌 경우를 확인하기 위해서는 <code>!is</code>로 확인하면 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Test</span><span class="params">(obj : <span class="type">Any</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Float</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>as 연산자</strong></p>
<ul>
<li>특정 변수를 원하는 자료형으로 변환하기 위한 연산자이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">porcessNumber</span><span class="params">(number: <span class="type">Number</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> foo : <span class="built_in">Int</span> = number <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>스마트 캐스트</strong></p>
<ul>
<li>자료형 추론이 가능할 경우 캐스팅 없이 해당하는 자료형으로 객체를 사용할 수 있도록 하는 기능이다.</li>
<li>값을 검사하는 시점과 사용하는 시점 사이에 값이 변하지 않았다는 것이 보장되는 경우에만 지원된다. 따라서 언제든지 값이 변할수 있는 <strong>var</strong>는 스마트 캐스트가 지원되지 않는다.</li>
</ul>
<p><strong>범위</strong></p>
<ul>
<li>특정 범위를 순회하거나 해당 범위 내에 특정 항목이 포함되어 있는지 확인할 때 사용한다.</li>
<li>… 연산자를 사용.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.</span></span><br><span class="line"><span class="keyword">val</span> myRange : IntRange = <span class="number">0.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> myRange)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스 순환을 위한 범위를 생성할 때는 <strong>until</strong> 함수를 사용하면 된다.</li>
<li>가장 마지막 값을 포함하지 않는다.</li>
<li>범위 내에 특정 항목이 있는지 확인할 때는 in 연산자를 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0&lt;=N&lt;10</span></span><br><span class="line"><span class="keyword">val</span> myRagne : IntRange = <span class="number">0</span> until <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0&lt;=N&lt;=10</span></span><br><span class="line"><span class="keyword">val</span> myRange2 : IntRange = <span class="number">0.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5가 myRange2 내에 포함되어 있는지 확인.</span></span><br><span class="line"><span class="keyword">val</span> foo : <span class="built_in">Boolean</span> = <span class="number">5</span> <span class="keyword">in</span> myRange2 <span class="comment">// true 반환</span></span><br><span class="line"><span class="comment">// 5가 myRange 내에 포함되지 않는지 확인.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Boolean</span> = <span class="number">5</span> !<span class="keyword">in</span> myRange <span class="comment">// false 반환</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>downTo()</code> 함수를 이용해 항목들의 순서가 반대로 정렬된 범위를 생성한다.</li>
<li>시작과 끝을 포함한다.</li>
<li>기본적으로 1씩 감소 시킨다.</li>
<li><code>step()</code> 함수를 사용하여 감소/증가 폭을 변경할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과 : 54321</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span> step <span class="number">2</span>)&#123; <span class="comment">// 2씩 감소시킨다.</span></span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과 : 531</span></span><br></pre></td></tr></table></figure>
<p><strong>예외</strong></p>
<ul>
<li>사용법은 자바와 동일하다. 하지만, 코틀린에서는 값을 반환할 수 있다.</li>
<li><code>checked exception</code>(뭐지? 검색해보자.)을 따로 검사하지 않는다. 즉, 대부분의 예외를 try-catch문으로 감싸 처리해야 했던 자바와 달리 코틀린에서는 이를 선택적으로 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readFromJson</span><span class="params">(fileName : <span class="type">String</span>)</span></span> : String&#123;</span><br><span class="line">    <span class="comment">// IOException을 발생시킬 수 있는 코드</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// try-catch문을 사용하지 않아도 된다.</span></span><br><span class="line">    <span class="keyword">val</span> json : String = readFromJson(<span class="string">"foo.json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="널안정성"># 널안정성</h2>
<p>코틀린은 컴파일 단계에서 발생하는 널 포인터 예외가 발생할 문제를 해결하기위해 모든 타입에 명시적으로 널 허용 여부를 함께 표기한다.<br>
코틀린의 중요한 특징 중 하나라고 생각한다.</p>
<p><strong>널 허용 여부 표기</strong></p>
<ul>
<li>널 값을 가질 수 있도록 하려면 명시적으로 타입 뒤에 ? 를 붙여주어야 한다.</li>
<li>널 값을 허용하지 않는 변수를 초기화하지 않거나, null을 대입하면 컴파일 오류를 발생시킨다.</li>
<li>함수의 파라미터나 반환 값에도 동일하게 적용된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> b : String = <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name : String <span class="comment">// 오류 : 값이 초기화 되지 않음.</span></span><br><span class="line"><span class="keyword">val</span> address : String = <span class="literal">null</span> <span class="comment">// 오류 : null을 허용하지 않는 변수에 null 대입 불가.</span></span><br></pre></td></tr></table></figure>
<p><strong>엘비스(?:) 연산자</strong></p>
<ul>
<li>널 값을 허용하지 않는 값 혹은 변수에 널 값을 반환할 수 있는 함수의 결과를 대입해야 하는 경우 엘비스 연산자를 이용해 편리하게 처리할 수 있다.</li>
<li>널 값을 대신하는 방법으로 <code>?:</code>를 사용한다.</li>
<li>널 여부를 확인하는 작업을 별도로 하지 않아도 되므로 자바에 비해서 간편하게 함수의 로직을 작성할 수 있다.</li>
<li>값 반환 대신 예외를 발생시킬 수도 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo ?: bar</span><br><span class="line"><span class="comment">// foo가 null이 아닐 경우에는 foo를 반환</span></span><br><span class="line"><span class="comment">// foo가 null일 경우에는 bar를 반환</span></span><br></pre></td></tr></table></figure>
<p><strong>안전한 호출(?.) 연산자</strong></p>
<ul>
<li>널 값 확인을 위해 자바에서 if문으로 검사하던 것을 간편화 할 수 있다.</li>
<li>간단한 로직의 경우 상관이 없지만 복잡해질수록 if문의 향연이 펼쳐질 수 있다.</li>
<li><strong>안전한 호출</strong> 연산자를 사용하여 널 값 확인과 값 접근/함수 호출을 한 번에 할 수 있다.</li>
<li>이 연산자를 사용하는 객체가 널 값이 아닌 경우에만 연산자 뒤의 문장을 수행한다. 널 값일 경우에는 뒤의 문장을 수행하지 않고 null 값을 반환한다.</li>
<li>따라서 널 값인 객체의 프로퍼티를 참조하거나 함수를 호출하는 일을 방지할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar가 null이 아닐 경우에만 해당 값인 baz를 대입. 그렇지 않은 경우 null을 foo에 대입</span></span><br><span class="line"><span class="keyword">val</span> foo = bar?.baz</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo가 null이 아닐 경우에만 bar() 함수 호출.</span></span><br><span class="line">foo?.bar()</span><br></pre></td></tr></table></figure>
<p><strong>as? 연산자</strong></p>
<ul>
<li>자바에서 지원되지 않는 자료형으로 변환을 시도할 가능성이 있는 부분을 try-catch 블록으로 감싸서 처리한다.</li>
<li>코틀린에서는 <code>as?</code> 연산자를 사용해 간편하게 해결할 수 있다.</li>
<li>자료형 변환이 실패할 경우 예외를 발생시키는 대신 널 값을 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo : String = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 자료형 변환에 실패하므로 bar로 null 값이 할당된다.</span></span><br><span class="line"><span class="comment">// 따라서 bar는 Int?를 통해 널 값을 허용하도록 선언한다.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Int</span>? = foo <span class="keyword">as</span>? <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>엘비스 연산자를 사용해 변환에 실패했을 때의 기본값을 지정할 수 있다.</li>
<li>변환된 값을 받은 자료형의 널 허용 여부를 수정할 필요가 없으므로 유연하게 대처할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자료형 변환에 실패하는 경우 기본 값을 0으로 지정.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Int</span> = foo <span class="keyword">as</span>? <span class="built_in">Int</span> ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>널 값이 아님을 명시하기 : 비 널 값 보증</strong></p>
<ul>
<li>널 값을 포함할 수 있는 타입을 널 값을 포함하지 않는 타입으로 변환하여 사용할 수 있다.</li>
<li>보증하려는 항목 뒤에 !!을 붙여 사용한다.</li>
<li>비 널 값 보증을 사용했지만 실제로 객체나 값에 널 값이 들어가 있을 경우 널 포인ㅌ 예외가 발생하므로 유의해서 사용해야 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 값 foo는 널 값을 포함할 수 있는 타입.</span></span><br><span class="line"><span class="keyword">val</span> foo : Foo? = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값 foo는 널 값을 포함하지 않음을 보증.</span></span><br><span class="line"><span class="keyword">val</span> nonNullFoo : Foo = foo!!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값 foo가 널 값이 아님을 보장하면서 bar() 함수 호출.</span></span><br><span class="line">foo!!.bar()</span><br></pre></td></tr></table></figure>
<p><strong>비 널 값 보증 사용 주의</strong></p>
<p>비 널 값 보증은 아래처럼 중첩해서 사용하는 것을 권장하지 않는다.<br>
contact.address와 address.line2 중 하나라도 널 값이라면 널 포인터 예외가 발생한다.<br>
하지만 에러 로그에서 라인만 알 수 있을 뿐, 어느 요소로 예외가 발생했는지 알 수 없다.<br>
따라서 비 널 값 보증은 중첩되는 호출 단계보다는 하나의 호출 단계에만 사용할 것을 권장한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> contact : Contact = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// address와 line2 모두 널 값이 아님을 보장.</span></span><br><span class="line"><span class="keyword">val</span> line : String = contact.address!!.line2!!</span><br></pre></td></tr></table></figure>
<p><strong>lateinit 키워드</strong></p>
<ul>
<li>초기화 없이 변수만 선언할 수 있다. (var에만 사용할 수 있다.)</li>
<li>즉, 초기화를 나중에 한다는 의미이다.</li>
<li>초기화를 하지 않은 채로 사용하려고 하면 널 포인터 예외가 발생하기 때문에 초기화 작업을 반드시 해야 한다.</li>
<li>초기화가 되었는지 확인하는 방법이 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity</span></span>()&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> api : Api</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// lateinit 키워드를 사용한 변수가 초기화 되었는지 확인한다.</span></span><br><span class="line">        <span class="keyword">if</span> (::api.isInitialized) &#123; </span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="주의">주의!</h2>
<p>코틀린에서는 값을 반환하는 구문들이 있다.<br>
for, while, when, try-catch, if 등등이 있다.<br>
이러한 구문들이 값을 반환한다는 특징을 알고 코드를 더 편리하게 짤 수 있으므로 알아두면 좋을 것 같다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/03/kotlin-chap1-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/12/kotlin-chap01/"
                            aria-label=": [커니의 Kotlin] Chap1.1"
                        >
                            [커니의 Kotlin] Chap1.1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-12T13:19:22+09:00">
	
		    Apr 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린을 공부하면 정리하는 포스팅.</p>
<h1 id="코틀린의-특징"># 코틀린의 특징</h1>
<p><strong>간결한 문법</strong></p>
<ul>
<li>문장 끝에 세미 콜론(;)을 넣지 않는다.</li>
<li>new 키워드를 사용하지 않고 객체를 생성한다.</li>
<li>타입 추론을 지원하므로 타입을 명시하지 않아도 된다.</li>
</ul>
<p><strong>널 안정성</strong></p>
<ul>
<li>널 값의 허용 여부를 명확히 구분하며 컴파일 단계에서 검사한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : String? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 널 값 허용.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b : String = <span class="string">"b"</span></span><br><span class="line"><span class="comment">// 널 값 허용하지 않음.</span></span><br></pre></td></tr></table></figure>
<p><strong>가변/불변 구분</strong></p>
<ul>
<li>val(값) : 값을 한번 할당하고 나면 그 후에 값을 변경할 수 없는 변수. 자바의 final 변수와 유사.</li>
<li>var(변수) : 할당된 값을 자유자재로 바꿀 수 있는 변수.</li>
<li>변수의 가변/불변과 유사하게 컬렉션 자료형에 대해서도 가변/불변 여부를 구분한다.
<ul>
<li>객체에 할당된 값이 아닌 컬렉션 내에 포함된 자료들을 추가,삭제할 수 있는지 여부를 구분한다.</li>
<li>불변의 경우 삽입,삭제,수정을 위한 함수가 없다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : String = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">val</span> b : String = <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"aa"</span> <span class="comment">// 가변이므로 가능.</span></span><br><span class="line">b = <span class="string">"bb"</span> <span class="comment">// 불변이므로 불가능.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> immutable : List&lt;String&gt; = listOf(<span class="string">"a"</span>,<span class="string">"b"</span>) <span class="comment">// 불변 리스트.</span></span><br><span class="line"><span class="keyword">val</span> mutable : MutableList&lt;String&gt; = mutableListOf(<span class="string">"a"</span>,<span class="string">"b"</span>) <span class="comment">// 가변 리스트.</span></span><br><span class="line"></span><br><span class="line">immutable.add(<span class="string">"c"</span>) <span class="comment">// add() 함수가 정의되어 있지 않음.</span></span><br><span class="line">mutable.add(<span class="string">"c"</span>) <span class="comment">// add()와 같은 자료를 수정할 수 있는 함수가 정의되어 있음.</span></span><br></pre></td></tr></table></figure>
<p><strong>람다표현식 지원</strong></p>
<ul>
<li>람다 표현식을 기본으로 제공.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener&#123;</span><br><span class="line">    Toast.makeText(it.context, <span class="string">"Click"</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>스트림API 지원</strong></p>
<ul>
<li>코틀린 표준 라이브러리를 통해 컬렉션 내 자료를 다루는 데 유용한 스트림 API를 지원한다.</li>
</ul>
<p><strong>완벽한 자바 호환성</strong></p>
<ul>
<li>자바에서 코틀린을 사용할 수 있고, 반대로 코틀린에서 자바 코드를 사용할 수 있다.</li>
</ul>
<h1 id="주요-문법"># 주요 문법</h1>
<p><strong>값 및 변수 선언</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : String = <span class="string">"a"</span> </span><br><span class="line"><span class="comment">// String 타입의 a 선언.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">"b"</span></span><br><span class="line"><span class="comment">// 타입을 명시하지 않아도 타입을 추론한다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c : String</span><br><span class="line"><span class="comment">// 선언 시 초기화를 하지 않으면 타입을 꼭 붙여야 한다.</span></span><br><span class="line">c = <span class="string">"c"</span></span><br><span class="line"><span class="comment">// 자료 할당.</span></span><br></pre></td></tr></table></figure>
<p><strong>함수 선언</strong></p>
<ul>
<li>Unit은 자바의 void와 유사하다. 반환 타입이 없음을 의미한다. 생략 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a : <span class="type">Int</span>, b : <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(str : <span class="type">String</span>)</span></span> : <span class="built_in">Unit</span>&#123;</span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unit 반환 타입을 생략한 경우.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">greet</span><span class="params">(str : <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>클래스 및 인터페이스 선언</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">V</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a : Stnig = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">C</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>조건문</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if-else</span></span><br><span class="line"><span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// when. 자바의 switch문과 같음.</span></span><br><span class="line"><span class="keyword">when</span>(count)&#123;</span><br><span class="line">    <span class="number">1</span> -&gt; println(<span class="string">"<span class="variable">$count</span> item"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">"else item"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>반복문</strong></p>
<ul>
<li>for-each만은 지원한다.</li>
<li>while, do-while문은 자바와 사용법이 똑같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> items = listOf(<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> items)&#123;</span><br><span class="line">    println(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="기본-자료형"># 기본 자료형</h1>
<ul>
<li>코틀린은 모든 타입을 객체로 표현.
<ul>
<li>원시 타입과 래퍼 클래스를 구분하지 않는다.</li>
</ul>
</li>
</ul>
<p>원시 타입을 모두 객체로 처리하면 비효율적일 수 있다.<br>
코틀린에서는 코드를 작성하는 시점에 원시 타입과 래퍼를 구분하지 않지만, 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환된다.</p>
<ul>
<li>값이나 변수의 타입으로 사용되는 경우 : 원시 타입으로 변환</li>
<li>컬렉션의 타입 인자로 사용되는 경우 : 래퍼로 변환</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a : <span class="built_in">Int</span> = ...</span><br><span class="line"><span class="keyword">var</span> b : List&lt;<span class="built_in">Int</span>&gt; = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// java에서는 아래와 같이 바뀐다.</span></span><br><span class="line"></span><br><span class="line">int a = ...</span><br><span class="line">List&lt;Integer&gt; b = ...</span><br></pre></td></tr></table></figure>
<p><strong>숫자</strong></p>
<ul>
<li>숫자를 표현하는 모든 자료형은 Number 클래스를 상속한다.</li>
<li>현재 숫자에 해당하는 문자를 반환하는 toChar() 함수를 추가로 제공한다.</li>
<li>Long 타입은 혼동 방지를 위해 대문자 리터럴 표기만 지원한다.</li>
</ul>
<p><strong>문자</strong></p>
<ul>
<li>자바에서는 문자에 해당하는 아스키 코드를 char에 숫자 형태로 대입할 수 있었지만, 코틀린에서는 문자만 대입할 수 있으며, 숫자를 대입할 경우 컴파일 에러가 발생한다.</li>
<li>toChar()를 사용해서 다른 자료형의 값을 문자 자료형에 대입한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> code : <span class="built_in">Int</span> = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// code에 해당하는 문자를 할당.</span></span><br><span class="line"><span class="keyword">val</span> ch : <span class="built_in">Char</span> = code.toChar()</span><br></pre></td></tr></table></figure>
<p><strong>논리</strong></p>
<ul>
<li>자바와 동일하게 사용하며, Boolean을 사용한다.</li>
</ul>
<p><strong>문자열</strong></p>
<ul>
<li>자바와 거의 동일하게 사용된다.</li>
<li>문자열의 특정 문자에 접근하기 위해 charAt() 대신 get() 혹은 대괄호([])와 인덱스를 사용해서 접근한다.</li>
<li>문자열 템플릿을 사용해 템플릿 문자열 내에 직접 인자를 대입한다.
<ul>
<li>인자로 값이나 변수 대신 표현식을 넣을 경우 표현식을 중괄호로 구분하면 된다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo : String = <span class="string">"Victory"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ch1 : <span class="built_in">Char</span> = foo.<span class="keyword">get</span>(<span class="number">0</span>) <span class="comment">// V</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> ch2 : <span class="built_in">Char</span> = foo[<span class="number">1</span>] <span class="comment">// i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 문자열 템플릿.</span></span><br><span class="line"><span class="keyword">val</span> length : <span class="built_in">Int</span> = <span class="number">300</span></span><br><span class="line"><span class="keyword">val</span> lengthText : String = <span class="string">"Length : <span class="variable">$length</span> meters"</span></span><br><span class="line"><span class="keyword">val</span> text : String = <span class="string">"Length : <span class="subst">$&#123;foo.lenght&#125;</span> !"</span></span><br></pre></td></tr></table></figure>
<p><strong>배열</strong></p>
<ul>
<li>배열은 타입 인자를 갖는 Array 클래스로 표현한다.</li>
<li>arrayOf()는 코틀린 표준 라이브러리에 포함되어 있으며, 입력받은 인자로 구성된 배열을 생성.</li>
<li>자바의 원시 타입은 코틀린 배열 클래스의 타입 인자로 사용할 수 없다.</li>
<li>자바 원시 타입을 인자로 갖는 배열을 표현하기 위해서 각 원시 타입에 대응하는 특수한 클래스를 제공한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> words : Array&lt;String&gt; = arrayOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원시 타입의 배열.</span></span><br><span class="line"><span class="keyword">val</span> intArr : IntArray = intArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 래퍼 타입 배열.</span></span><br><span class="line"><span class="keyword">val</span> IntArr : Array&lt;<span class="built_in">Int</span>&gt; = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>가변 인자에 배열을 전달하는 경우에 스프레드 연산자(*)를 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(varag args : <span class="type">String</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strArr : Array&lt;String&gt; = arrayOf(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">go(*strArr) <span class="comment">// 스프레드 연산자 사용.</span></span><br></pre></td></tr></table></figure>
<h1 id="컬렉션"># 컬렉션</h1>
<ul>
<li>JVM을 기반으로 하는 코틀린에서 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다.</li>
<li>이때, 타입 별칭을 사용해 컬렉션 내 다른 클래스와의 일관성을 유지한다.</li>
<li>컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분하며 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현되어 있다.</li>
</ul>
<p>Collection, List 인터페이스에는 자료를 조회하는 함수만 포함되어 있으므로 자료가 할당되면 수정이 불가능하다. 그 대신, 각 인터페이스를 상속한 MutableCollection, MutableList 인터페이스에 자료를 수정하는 함수가 포함되어 있다.</p>
<p>Set, Map도 동일한 규칙이 지정되며 아래 표와 같다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">자료구조</th>
<th style="text-align:center">자료 수정 불가</th>
<th style="text-align:center">자료 수정 가능</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:center">kotlin.collections.List</td>
<td style="text-align:center">kotlin.collections.MutableList</td>
</tr>
<tr>
<td style="text-align:left">Map</td>
<td style="text-align:center">kotlin.collections.Map</td>
<td style="text-align:center">kotlin.collections.MutableMap</td>
</tr>
<tr>
<td style="text-align:left">Set</td>
<td style="text-align:center">kotlin.collections.Set</td>
<td style="text-align:center">kotlin.collections.MutableSet</td>
</tr>
</tbody>
</table>
<ul>
<li>다음은 컬렉션을 쉽게 생성하는 함수를 나타낸다.</li>
<li>listOf, setOf, mapOf는 자료의 수정이 불가능하다.(불변)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">함수명</th>
<th style="text-align:center">자료 수정 가능 여부</th>
<th style="text-align:left">반환 타입(실제 타입)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">listOf()</td>
<td style="text-align:center">X</td>
<td style="text-align:left">kotlin.collections.List</td>
</tr>
<tr>
<td style="text-align:left">arrayListOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.ArrayList(java.util.ArrayList)</td>
</tr>
<tr>
<td style="text-align:left">SetOf()</td>
<td style="text-align:center">X</td>
<td style="text-align:left">kotlin.collections.Set</td>
</tr>
<tr>
<td style="text-align:left">hashSetOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.HashSet(java.util.HashSet)</td>
</tr>
<tr>
<td style="text-align:left">linkedSetOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.LinkedHashSet(java.util.LinkedHashSet)</td>
</tr>
<tr>
<td style="text-align:left">sortedSetOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.TreeSet(java.util.TreeSet)</td>
</tr>
<tr>
<td style="text-align:left">mapOf()</td>
<td style="text-align:center">X</td>
<td style="text-align:left">kotlin.collections.Map</td>
</tr>
<tr>
<td style="text-align:left">hashMapOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.HashMap(java.util.HashMap)</td>
</tr>
<tr>
<td style="text-align:left">linkedMapOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.HashMap(java.util.LinkedHashMap)</td>
</tr>
<tr>
<td style="text-align:left">sortedMapOf()</td>
<td style="text-align:center">O</td>
<td style="text-align:left">kotlin.collections.LinkedHashMap(java.util.SortedMap)</td>
</tr>
</tbody>
</table>
<ul>
<li>배열의 특정 원소에 접근하는 방법과 동일하게 컬렉션 내 항목에 접근할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> immutableList : List&lt;String&gt; = listOf(<span class="string">"a"</span>,<span class="string">"b"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get(0)과 동일.</span></span><br><span class="line"><span class="keyword">val</span> firstItem : String = immutableList[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 불변이므로 컴파일 에러 발생.</span></span><br><span class="line">immutableList[<span class="number">0</span>] = <span class="string">"c"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>맵은 숫자 대신 키 값을 넣어 항목에 접근할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> immutableMap : Map&lt;String, <span class="built_in">Int</span>&gt; = mapOf(Pair(<span class="string">"A"</span>,<span class="number">65</span>), Pair(<span class="string">"B"</span>,<span class="number">66</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 키 "A"에 해당하는 값 - get("A")와 동일</span></span><br><span class="line"><span class="keyword">val</span> code : <span class="built_in">Int</span> = immutableMap[<span class="string">"A"</span>]</span><br><span class="line"><span class="comment">// 불변이므로 값 할당시 컴파일 에러 발생.</span></span><br><span class="line">immutableMap[<span class="string">"C"</span>] = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> mutableMap : HashMap&lt;String, <span class="built_in">Int</span>&gt; = hashMapOf(Pair(<span class="string">"A"</span>,<span class="number">65</span>),Pair(<span class="string">"B"</span>,<span class="number">66</span>))</span><br><span class="line"><span class="comment">// 가변이므로 가능.</span></span><br><span class="line">mutableMap[<span class="string">"C"</span>] = <span class="number">67</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 조금 더 간단하게 Pair 표현</span></span><br><span class="line"><span class="keyword">val</span> map : Map&lt;String, <span class="built_in">Int</span>&gt; = mapOf(<span class="string">"A"</span> to <span class="number">65</span>, <span class="string">"B"</span> to <span class="number">66</span>)</span><br></pre></td></tr></table></figure>
<h1 id="클래스-및-인터페이스"># 클래스 및 인터페이스</h1>
<p><strong>클래스 및 인터페이스 선언</strong></p>
<ul>
<li>클래스 및 인터페이스를 선언하는 방식은 자바와 거의 유사하다.</li>
<li>접근 제한자를 지정하지 않는 경우 기본은 public이다.</li>
<li>선언된 내용이 없으면 클래스와 인터페이스는 몸체만 선언할 수 있다.</li>
<li>new를 사용하지 않고 인스턴스를 생성한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> // <span class="title">class</span> 몸체.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">D</span> // <span class="title">interface</span> 몸체.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new 키워드 사용 없이 인스턴스 생성.</span></span><br><span class="line"><span class="keyword">val</span> foo : Foo = Foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bar : Bar = Bar(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>추상 클래스는 자바와 동일한 선언 방법이지만, 인스턴스를 생성하는 형태가 다르다.</li>
<li>인터페이스를 선언하거나, 인터페이스의 인스턴스를 만드는 방법은 추상 클래스와 매우 유사하다.</li>
<li>추상 클래스에서는 인스턴스를 생성 시 생성자를 사용하지만, 생성자가 없는 인터페이스는 인스턴스 이름만 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 추상 클래스의 선언.</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 추상 클래스의 인스턴스 생성.</span></span><br><span class="line"><span class="comment">// object: [생성자] 형태로 선언.</span></span><br><span class="line"><span class="keyword">val</span> foo = <span class="keyword">object</span>: Foo()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 함수 구현.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인터페이스 선언.</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인터페이스의 인스턴스 생성.</span></span><br><span class="line"><span class="comment">// object: [인터페이스 이름] 형태로 선언.</span></span><br><span class="line"><span class="keyword">val</span> bar = <span class="keyword">object</span>: Bar&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">baz</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 함수 구현.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>프로퍼티</strong></p>
<ul>
<li>프로퍼티는 자료를 저장할 수 있는 필드와 이에 상응하는 getter/setter 메소드를 함께 제공하며, 자바의 필드와 유사한 형태로 선언한다.</li>
<li>클래스의 멤버로 사용하는 프로퍼티는 초기값을 명시적으로 지정해야 한다. 그렇지 않을 경우 컴파일 에러 발생.
<ul>
<li>단, 생성자에서 프로퍼티의 값을 할당한다면 선언 시 값을 할당하지 않아도 된다.</li>
</ul>
</li>
<li>프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당할 수 없는 경우에는 lateinit 키워드를 사용하여 프로퍼티의 값이 나중에 할당될 것임을 명시한다.</li>
<li>lateinit 키워드는 var 프로퍼티에만 사용 가능하다.
<ul>
<li>반드시 초기화 작업을 해야 한다.</li>
</ul>
</li>
<li>프로퍼티에 초기값을 할당하는 시점에서 해당 프로퍼티의 타입을 추론할 수 있다면 타입 선언 생략 가능.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name : String? = <span class="literal">null</span> <span class="comment">// 값을 읽을 수만 있는 val, getter만 있음.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> address : String? = <span class="literal">null</span> <span class="comment">// 값을 읽고 쓰는게 모두 가능한 var, getter/setter 모두 있음.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> gender : String? <span class="comment">// 선언 시점에 값을 할당하지 않아도 컴파일 에러가 발생하지 않음. </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lateinit 키워드를 사용했는데 초기화를 하지 않으면 Uninitialized PropertyAccessException 예외가 발생하한다. 컴파일 단계에서는 확인이 불가능하므로 <code>lateinit</code> 키워드를 사용할 경우 반드시 초기화 여부를 확인하는 것이 좋다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> name : String</span><br><span class="line"></span><br><span class="line"><span class="comment">// lateinit 키워드를 사용한 프로퍼티가 초기화 되었는지 확인할 수 있다.</span></span><br><span class="line"><span class="keyword">if</span>(::name.inInitialized)&#123;</span><br><span class="line">    println(<span class="string">"초기화 O"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    println(<span class="string">"초기화 X"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>접근 제한자</strong></p>
<ul>
<li>제한자가 없으면 public으로 간주한다.</li>
<li>internal 접근 제한자를 제공한다.
<ul>
<li>단순히 같은 패키지에 있으면 접근이 가능했던 자바의 패키지 단위 제한과 달리 internal 접근 제한자는 동일 모듈 내에 있는 클래스들로의 접근을 제한한다.</li>
<li>외부 모듈에서는 이 접근 제한자로 선언된 요소에 접근할 수 없다.</li>
</ul>
</li>
<li>제한하는 모듈의 범위
<ul>
<li>IntelliJ IDEA 모듈</li>
<li>Maven / Gradle 프로젝트</li>
<li>하나의 Ant 태스크 내에서 함께 컴파일 되는 파일들.</li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/12/kotlin-chap01/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Kotlin/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
