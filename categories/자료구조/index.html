
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Category: 자료구조 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/categories/자료구조/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/13/PriorityQueue/"
                            aria-label=": [자료구조] 우선순위 큐(Priority Queue)"
                        >
                            [자료구조] 우선순위 큐(Priority Queue)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-13T00:28:24+09:00">
	
		    May 13, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="우선순위-큐priority-queue">우선순위 큐(Priority Queue)</h3>
<p>일반적인 큐는 먼저 들어간 데이터가 먼저 나오는 구조이다. <strong>이런 큐의 특성과 달리 우선순위 큐(Priority Queue)는 들어간 순서에 상관없이 일정한 규칙에 따라 우선순위를 선정하고 우선순위가 가장 높은 데이터가 가장 먼저 나오게 된다.</strong> 대표적인 예로는 병원의 응급 환자를 생각할 수 있으며, 은행의 업무를 기다리는 상황과 달리 위급한 우선순위에 따라 먼저 처리된다.</p>
<h4 id="사용하기">사용하기</h4>
<ul>
<li>우선순위 큐도 Java에서 내부적으로 구현되어 있어 사용이 용이하다.</li>
<li>큐와 동일하게 add(), peek(), poll() 등의 메소드를 사용할 수 있다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(<span class="number">4</span>);</span><br><span class="line">        pq.add(<span class="number">19</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(pq.poll()); <span class="comment">// 1이 출력된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add() 대신 offer() 메소드를 사용해도 동일한 결과를 얻는다.</li>
</ul>
<h4 id="우선순위-변경하기">우선순위 변경하기</h4>
<ul>
<li>우선순위를 정하는 기준은 Java의 정렬 기준과 동일하다.</li>
<li>Java는 기본적으로 낮은 숫자부터 큰 숫자까지 오름차순으로 정렬하게 되는데, 만약 다른 오름차순으로 정렬하고 싶다면 Comparator 클래스나 Comparable 인터페이스를 이용해야 한다.</li>
<li>Ex) 객체의 어떤 값에 따라 우선순위를 정해 정렬해야 할때, 오름차순이 아닌 내림차순 정렬을 할때 등등</li>
<li>Integer는 Collections.reverseOrder()를 사용해 내림차순 정렬을 할 수 있다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        pq.add(<span class="number">4</span>);</span><br><span class="line">        pq.add(<span class="number">19</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(pq.poll()); <span class="comment">// 19가 출력된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="우선순위-큐-예제">우선순위 큐 예제</h4>
<ul>
<li>고양시에서 강남까지 가는 방법이 있다고 하자.</li>
<li>대중교통, 자가용, 도보, 자전거 총 4가지의 방법이 존재한다.
<ul>
<li>대중 교통 : 1시간 10분</li>
<li>자가용 : 45분</li>
<li>도보 : 6시간 40분</li>
<li>자전거 : 2시간 5분</li>
</ul>
</li>
<li>시간이 제일 적게 걸리는 순서로 정렬하면 -&gt; 자가용, 대중교통, 자전거, 도보 순이다.</li>
<li>우선순위 큐에 저장한 뒤, 데이터를 추출하면 위의 순서대로 추출된다.</li>
<li>하지만, 큐는 들어간 순으로 나온다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> programmers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 2020/05/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Vehicle&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"대중교통"</span>, <span class="number">70</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"자가용"</span>, <span class="number">45</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"오토바이"</span>, <span class="number">45</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"도보"</span>, <span class="number">400</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"자전거"</span>, <span class="number">125</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            System.out.println(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Vehicle</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        Vehicle(String name, <span class="keyword">int</span> time) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Vehicle&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", time="</span> + time +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Vehicle that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.time == that.time) <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(that.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.time - that.time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Vehicle&#123;name=<span class="string">'오토바이'</span>, time=<span class="number">45</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'자가용'</span>, time=<span class="number">45</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'대중교통'</span>, time=<span class="number">70</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'자전거'</span>, time=<span class="number">125</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'도보'</span>, time=<span class="number">400</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Vehicle 클래스를 만들었다. 그리고 자바에서 PriorityQueue를 사용하기 위해서는(객체인 경우) 우선순위 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현해야 한다.</li>
<li>compareTo 메소드를 오버라이드 하여 우선순위 조건을 설정하면 PriorityQueue가 우선순위가 높은 객체를 추출하게 된다.</li>
<li>시간이 작은 순서로 정렬해야 하기 때문에 오름차순 정렬을 한다.</li>
<li>다만, 시간이 같은 경우에는 이름의 사전순 정렬을 한다.(오름차순) name이 String이기 때문에 <code>this.name.compareTo(that.name)</code> 을 활용한다.</li>
<li>Int 형인 time 간의 연산에서 Integer.compareTo() 를 사용하지 않은 이유는 Integer와 int의 size가 메모리 차이 때문이다. int의 size가 훨씬 작아 연산시 적은 메모리를 사용한다는 점에서 서로의 값을 뺄셈하여 계산했다.</li>
<li>관련 내용은 해당 Repository에 있으니 확인하면 좋을 것 같다.</li>
</ul>
<h3 id="참고">참고</h3>
<ul>
<li><a href="https://siyoon210.tistory.com/117" target="_blank" rel="noopener">우선순위 큐 - Java에서 다루기</a></li>
<li><a href="https://pangsblog.tistory.com/23" target="_blank" rel="noopener">자바로 정리한 우선순위큐(PriorityQueue)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/13/PriorityQueue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/DataStructure-Graph/"
                            aria-label=": [자료구조] Graph"
                        >
                            [자료구조] Graph
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T11:07:43+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><a href="#%EC%A0%95%EC%A0%90%EA%B3%BC-%EA%B0%84%EC%84%A0%EC%9D%98-%EC%A7%91%ED%95%A8,-Graph">정점과 간선의 집함, Graph</a><br>
<a href="#%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC">그래프 관련 용어 정리</a></p>
<h2 id="정점과-간선의-집함-graph">정점과 간선의 집함, Graph</h2>
<p>그래프란 정점과 간선의 집합을 말한다.<br>
ex) 트리는 그래프. [싸이클이 허용되지 않는 그래프이다.]</p>
<h2 id="그래프-관련-용어-정리">그래프 관련 용어 정리</h2>
<ul>
<li>V(vertex) : 정점을 의미한다.</li>
<li>E(edge) : 간선을 의미한다.</li>
</ul>
<ol>
<li>Directed Graph(Digraph)<br>
말 그대로 정점과 간선의 연결관계에 있어서 <code>방향성</code>이 포함되어 있는 그래프를 말한다.</li>
</ol>
<img src="/img/digraph.png" width="400" height="200">
<center>V = {1,2,3,4,5,6}</center>
<center>E = {(1,4),(2,1),(3,4),(5,6)}</center>
<center>(u,v) = vertex u에서 vertex v로 가는 edge</center>
<ol start="2">
<li>Undirected Graph<br>
정점과 간선의 연결관계에 있어서 <code>방향성</code>이 없는 그래프를 말한다.</li>
</ol>
<img src="/img/undirected_graph.png" width="400" height="200">
<ol start="3">
<li>Degree<br>
Undirected Graph에서 각 정점(Vertex)에 연결된 Edge의 개수를 <strong>Degree</strong>라고 한다.<br>
Directed Graph에서는 간선에 <code>방향성</code>이 존재하기 때문에 Degree가 두 개로 나뉘게 된다.<br>
각 정점으로부터 나가는 간선의 개수를 <strong>Outdegree</strong>라고 하고, 들어오는 간선의 개수를 <strong>Indegree</strong>라고 한다.</li>
</ol>
<ol start="4">
<li>가중치 그래프(Weight Graph)<br>
가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프는 모든 간선의 가중치가 동일한 그래프이다.</li>
</ol>
<ol start="5">
<li>부분 그래프(Sub Graph)<br>
부분 집합과 유사한 개념으로 부분 그래프라는 것이 존재한다.<br>
부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</li>
</ol>
<h2 id="그래프를-구현하는-두-방법">그래프를 구현하는 두 방법</h2>
<p>[무슨 말일까…?ㅠ^ㅠ]</p>
<ol>
<li>
<p>인접 행렬(adjacent matrix)<br>
정방 행렬을 사용하는 방법이다.<br>
해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)으로 파악할 수 있다.<br>
Edge 개수와는 무관하게 V^2의 Space Complexity(공간 복잡도)를 갖는다.<br>
=&gt; Dense graph를 표현할 때 적절한 방법이다.</p>
</li>
<li>
<p>인접 리스트(adjacent list)<br>
연결 리스트를 사용하는 방법이다.<br>
vertex의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다.<br>
Space Complexity는 O(E + V)이다.<br>
=&gt; Sparse graph를 표현하는데 적당한 방법이다.</p>
</li>
</ol>
<p>[어려운 용어가 많이 나온다… 더 공부하자!!]</p>
<h2 id="그래프-탐색">그래프 탐색</h2>
<p>그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<p><strong>1. 깊이 우선 탐색(Depth First Search: DFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결된 정점이 없으면 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다.<br>
어떤 자료구조를 사용해야 할까? 바로 <code>Stack</code>이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><strong>2. 너비 우선 탐색(Breadth First Search: BFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서 자료구조로 <code>Queue</code>를 사용한다. 연락을 취한 정점의 순서를 기록하기 위한 것이다.<br>
우선, 탐색을 시작하는 정점을 Queue에 넣는다.(enqueue)<br>
그리고 dequeue를 하면서 dequeue를 하는 정점과 간선으로 연결된 정점들을 enqueue한다.<br>
즉, vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><code>BFS로 구한 경로는 최단 경로이다.</code></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/342?category=688193" target="_blank" rel="noopener">Graph라는 자료구조에 대해서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/DataStructure-Graph/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-HashTable/"
                            aria-label=": [자료구조] Hash"
                        >
                            [자료구조] Hash
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T23:17:04+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="hasttable">HastTable</h2>
<p><code>Hash(또는 HashMap)</code>은 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 인덱스를 이용한 빠른 검색 속도를 갖는다. 특정한 값을 searching하는데 데이터 고유의 <strong>인덱스</strong>로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다.<br>
[항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.]</p>
<p>그리고 데이터의 삽입과 삭제 시 기존 데이터를 밀어내거나 다시 채우는 작업이 필요없도록 <strong>특별한 알고리즘</strong>을 이용하여 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에 삽입 시 다른 데이터의 사이에 끼어들거나 삭제 시 다른 데이터로 채울 필요가 없으므로 추가적인 데이터의 이동이 없다.</p>
<p><strong>'특별한 알고리즘’이라는 것을 통해서 고유한 인덱스 값을 설정하는 것이 중요한 포인트이다.</strong><br>
앞서 언급한 특별한 알고리즘을 해시 메소드 또는 해시 함수라고 하고 이 메소드에 의해 반환되는 데이터의 <strong>고유한 숫자 값</strong>을 <strong>hashCode</strong>라고 한다.<br>
Java에서는 Object 클래스의 _hashCode()_라는 메소드를 이용하여 모든 객체의 hashcode 값을 쉽게 구할 수 있다.</p>
<p>hash 메소드를 구현하는 가장 간단한 방법은 <strong>나머지 연산자를 이용</strong>하는 것이다. <em>저장할 데이터의 값을 저장할 hash table의 크기로 나누고 나머지 연산 결과를 데이터의 인덱스로 사용하는 것이다.</em> 하지만 이렇게 하면 문제점이 발생한다.</p>
<p>만약 3의 배수로 이루어진 데이터 9개를 저장한다고 가정해보자.<br>
저장하려는 데이터 : 3,6,9,12,15,18,21,24,27<br>
hashcode 값 계산<br>
3 % 9 == 3<br>
6 % 9 == 6<br>
9 % 9 == 0<br>
12 % 9 == 3<br>
15 % 9 == 6<br>
18 % 9 == 0<br>
21 % 9 == 3<br>
24 % 9 == 6<br>
27 % 9 == 3</p>
<p>계산 결과 hashcode 값이 0,3,6으로 집중되고 있다. <em>이렇게 되면 같은 index로 접근하게 되는 value가 많아져 데이터를 저장할 수 없게 되는 충돌 현상이 발생한다.</em> 이를 <strong>Collision</strong>이라고 한다.</p>
<p>이런 충돌을 최소화 하기 위한 가장 간단한 방법은 나머지 연산의 값이 중복되지 않도록 테이블의 크기를 <code>소수(Prime number)</code>로 만드는 것이다. 위와 동일한 입장일 경우, 저장하려는 데이터의 크기가 9이므로 9보다 큰 소수인 11로 나머지 연산을 해보자.</p>
<p>hashcode 값 계산<br>
3 % 11 == 3<br>
6 % 11 == 6<br>
9 % 11 == 9<br>
12 % 11 == 1<br>
15 % 11 == 4<br>
18 % 11 == 7<br>
21 % 11 == 10<br>
24 % 11 == 2<br>
27 % 11 == 5</p>
<p>중복되는 값이 깨끗하게 사라진 것을 확인할 수 있다. 하지만 이 방법으로 모든 것이 해결된 것일까?? 위의 과정에서 데이터의 성질이 달라져 다른 값이 들어올 수 있게 된 경우는 어떨까?</p>
<p>예를 들어 26이라는 데이터를 추가적으로 저장해야 한다면 데이터의 크기는 10이 되고 10보다 큰 소수는 11로 나머지 연산자 방법을 수행해준다.</p>
<p>26 % 11 == 4</p>
<p>결과를 확인해보니 다시 중복이 발생하였다. 바로 <code>Collision</code>이 발생한 것이다. <em>Hash Table의 크기를 소수로 만드는 것은 충돌을 줄일 수는 있지만 원천적으로 해결해주지는 못한다.</em></p>
<p>충돌이 많아질수록 Searching에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다.<br>
<em>어설픈 해쉬 함수는 해시를 해시답게 사용하지 못하도록 한다. 좋은 해쉬 함수를 선택하는 것은 해쉬 테이블의 성능 향상에 필수적인 것이다.</em></p>
<p>두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.(Collision)<br>
따라서 해싱된 인덱스에 이미 다른 값이 들어가 있다면 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수적이며 그 방법들에 대해 알아보고자 한다.</p>
<p>기본적인 두 가지 방법을 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 응용한 방법들이다.</p>
<h2 id="open-address-방식개방-주소법">Open Address 방식(개방 주소법)</h2>
<p>해시 충돌이 발생하면 즉 삽입하려는 해시 버킷이 이미 사용 중인 경우, <code>다른</code> 해시 버킷에 해당 자료를 삽입하는 방식이다.</p>
<ul>
<li>버킷(bucket)이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다.</li>
</ul>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 Collision(충돌)이 발생하면 데이터를 저장할 장소. 즉 다른 해시 버킷을 찾아 헤맨다. 이 과정에서도 여러 방법들이 존재하는데 다음 3가지에 대해 간단하게 알아보자.</p>
<ol>
<li>
<p>Linear Probing<br>
순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다. Worst case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다.</p>
</li>
<li>
<p>Quadratic probing<br>
2차 함수를 이용해 탐색할 위치를 찾는다.</p>
</li>
<li>
<p>Double hashing probing</p>
</li>
</ol>
<p>하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두가지 방법에 비해 많은 연산량을 요구한다.</p>
<h2 id="seperate-chaining-방식분리-연결법">Seperate Chaining 방식(분리 연결법)</h2>
<p>참고로 Java 7에서는 Seperate Chaining 방식을 사용하여 HashMap을 구현하고 있다.</p>
<blockquote>
<p>Why?</p>
</blockquote>
<p>HashMap의 특성상 remove() 메소드가 빈번하게 일어날 수 있는데 데이터를 삭제할 때 OpenAddress 방식은 처리가 효율적이기 어렵다. 또한 저장된 Key-value 쌍의 개수가 일정 개수 이상 많아지면 보통 Seperate Chaining 방식에 비해 Open Address 방식이 느리다.</p>
<p><strong>연결 리스트를 사용하는 방식(LinkedList)</strong></p>
<p>각각의 버킷들을 연결리스트(Linked List)로 만들어 Collision이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다.</p>
<p>일반적으로 Open Address 방법은 Seperate Chaining 방식보다 느리다. Open Address의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면에 Seperate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 <strong>보조 해시 함수</strong>를 통해 조정할 수 있다면 Worst Case에 가까워지는 것을 줄일 수 있다.</p>
<p><a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">보조 해시 함수에 대한 글</a></p>
<p><strong>Tree를 사용하는 방식(Red-Black-Tree)</strong></p>
<p>기본적인 알고리즘은 Seperate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 여기서 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 <strong>하나의 버킷에 할당된 Key-Value 쌍의 개수</strong>이다.</p>
<p>트리는 기본적으로 메모리 사용량이 많고 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 연결 리스트의 성능 상의 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 연결 리스트를 사용한다.</p>
<blockquote>
<p>데이터가 적다는 것은 얼마나 적다는 것을 의미할까??</p>
</blockquote>
<p>앞에서 언급한 것처럼 기준은 하나의 버킷에 할당되는 Key-Value 쌍의 개수이다. 이 Key-Value 쌍의 개수가 6개, 8개를 기준으로 결정한다.</p>
<p>오잉…? 왜 기준이 2개인가?? 이는 아래에서 설명하겠다.</p>
<p>결론부터 말하자면 연결 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 <strong>소요되는 비용을 줄이기 위함</strong>이다.<br>
한 가지 상황을 가정해보자.<br>
해시 버킷에 6개의 Key-Value 쌍이 들어있다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료 구조를 연결 리스트에서 트리로 변경해야 한다. 그러다가 바로 하나의 값이 삭제된다면 다시 트리에서 연결 리스트로 자료구조를 변경해야 한다.</p>
<p>각각 자료구조로 넘어가는 기준이 1이라면 Switching 할 때 생기는 비용이 너무 많이 필요하게 되는 것이다. <strong>그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다.</strong><br>
따라서 데이터의 개수가 6개 -&gt; 7개로 증가했을 때는 연결 리스트의 자료구조를 취하고 있을 것이고<br>
8개 -&gt; 7개로 감소했을 때는 트리의 자료 구조를 취하고 있을 것이다.</p>
<ul>
<li>참고로 Java 8을 구현하는데 사용하는 트리는 RBT이다.</li>
</ul>
<p><strong>해시 버킷 동적 확장(Resize)</strong></p>
<p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능상 손실이 발생할 수도 있다. 그래서 HashMap은 Key-Value 쌍 데이터 개수가 <strong>일정 개수 이상</strong>이 되면 해시 버킷의 개수를 두배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.</p>
<blockquote>
<p>일정 개수 이상??</p>
</blockquote>
<p>해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor로 HashMap의 생성자에서 지정할 수도 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/332?category=688193" target="_blank" rel="noopener">hashcode와 HashMap에 대해서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-HashTable/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-RBT/"
                            aria-label=": [자료구조] Red-Black Tree"
                        >
                            [자료구조] Red-Black Tree
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T22:01:28+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식의 자료구조이다.</p>
<p>먼저 레드 블랙 트리를 알아보기 전에 BST가 무엇인지 한번 더 알고 넘어가자.</p>
<p>BST(Binary Search Tree)는 이진 탐색 트리이다.<br>
효율적인 탐색을 위해 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 <strong>저장 방법이 무엇일까</strong>를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>
<h2 id="red-black-tree">Red Black Tree</h2>
<p>결론부터 말하자면 <code>Red-Black-Tree</code>에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 Complete Binary Tree인 경우이다.</p>
<p></p><h5 id="1-red-black-tree의-정의">1. Red-Black-Tree의 정의</h5><p></p>
<p>Red-Black-Tree를 앞으로 RBT라고 부르도록 하겠다.<br>
RBT는 다음의 성질을 만족하는 BST이다.</p>
<ul>
<li>각 노드는 <code>Red</code> 혹은 <code>Black</code>라는 색깔을 갖는다.</li>
<li>Root node의 색깔을 Black이다.</li>
<li>각 leaf node(단말 노드)는 black이다.</li>
<li>어떤 노드의 색깔이 red라면 두 개의 children의 색깔은 모두 black이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black node들을 포함하고 있다. 이를 해당 노드의 <code>Black-Height</code>라고 한다. [노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수]</li>
</ul>
<p>[무슨 말일까…? 어렵다!]</p>
<p><strong>2. RBT의 특징</strong></p>
<ul>
<li>Binary Search Tree이므로 BST의 특징을 모두 갖는다.</li>
<li>Root node부터 leaf node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 <strong>balanced</strong> 상태라고 한다.</li>
<li>노드의 child가 없을 경우, child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL은 leaf node로 간주한다.</li>
</ul>
<p>RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 그렇다면 이를 어떻게 해결할 것인가??</p>
<h3 id="삽입">삽입</h3>
<p>우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 <code>Red</code>로 지정한다. Red로 지정하는 이유는 Black-Height의 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고 Black-Height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node 들의 Black-Height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2미만으로 유지된다.</p>
<h3 id="삭제">삭제</h3>
<p>삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation을 하고 노드의 색깔을 조정한다. &lt;지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-RBT/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Heap/"
                            aria-label=": [자료구조] Heap"
                        >
                            [자료구조] Heap
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T21:45:11+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#Heap">Heap</a></li>
</ul>
<h2 id="heap">Heap</h2>
<p>Heap 자료구조는 일종의 Tree의 형식을 하고 있으며, Tree 중에서도 <strong>배열</strong>에 기반한 Complete Binary Tree(완전 이진 트리)이다.</p>
<p>배열에 트리의 값을 넣어줄 때, 0번째는 건너뛰고 1부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다.</p>
<p>힙에는 최소 힙(min heap)과 최대 힙(max heap) 두 종류가 있다.</p>
<p><code>Max Heap</code>이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 Complete Binary Tree(완전 이진 트리)를 말한다.[Min Heap은 그 반대.]</p>
<p>Max Heap에서는 Root node에 있는 값이 제일 크므로 최대값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다. 그리고 Complete Binary Tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다.<br>
(즉, 배열의 장점 중 하나인 Random Access가 가능하다)<br>
Min Heap에서는 최소값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다.</p>
<p>Heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 Heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 <code>Heapify</code> 과정을 거쳐 Heap 구조를 유지한다. 이런 경우 결국에는 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있다.</p>
<p>[Heap 구조를 유지시키는 더 자세한 내용을 추가 예정.]</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Heap/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Tree/"
                            aria-label=": [자료구조] Tree 개념"
                        >
                            [자료구조] Tree 개념
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T16:59:05+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="tree">Tree</h2>
<p>트리는 스택이나 큐와 같은 선형 구조가 아닌 <strong>비선형 자료구조</strong>이다.<br>
트리는 계층적 관계를 표현하는 자료구조이며, 표현에 집중한다.<br>
무엇인가를 저장하고 꺼내야 한다는 사고를 벗어나 트리라는 자료구조를 보자.</p>
<p><strong>트리를 구성하고 있는 구성요소들</strong></p>
<ul>
<li>Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미</li>
<li>Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미</li>
<li>Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미</li>
<li>Terminal Node(=leaf Noed, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미</li>
<li>Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.</li>
</ul>
<p>트리의 속성 중 가장 중요한 것은 <strong>루트 노드를 제외한 모든 노드는 단 하나의 부모 노드만을 가진다</strong>는 것이다. 이 속성 때문에 트리는 다음의 성질을 만족한다.</p>
<ul>
<li>임의의 노드에서 다른 노드로 가는 경로(path)는 유일하다.</li>
<li>회로(cycle)가 존재하지 않는다.</li>
<li>모든 노드는 서로 연결되어 있다.</li>
<li>엣지를 하나 자르면 트리가 두 개로 분리된다.</li>
<li>엣지의 수(E) = 노드의 수(V) - 1</li>
</ul>
<h3 id="binary-tree이진-트리">Binary Tree(이진 트리)</h3>
<p>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나누어진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다.</p>
<p><strong>즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다.</strong> 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf Node에 다 달았을 때 정의가 만족되기 때문이다.</p>
<p>트리에서는 각 <strong>층 별</strong>로 숫자를 매겨서 이를 트리의 Level이라고 한다. 루트 노드부터 시작하고 루트 노드의 Level은 1이다. 그리고 트리의 최고 Level을 가리켜 해당 트리의 <code>height(높이)</code>라고 한다.</p>
<ol>
<li>완전 이진 트리(Complete Binary Tree)</li>
</ol>
<p>위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 <strong>완전 이진 트리</strong>라고 한다.</p>
<img src="/img/complete_binary_tree.png" width="400" height="200">
<ol start="2">
<li>포화 이진 트리(Full Binary Tree)</li>
</ol>
<p>모든 레벨에서 노드들이 꽉 채워진 이진트리를 말한다.(= 잎새 노드를 제외한 모든 노드가 자식 노드를 2개 가진다.)</p>
<img src="/img/full_binary_tree.png" width="400" height="200">
<p>포화 이진 트리의 노드 수가 n개라면 잎새노드의 수는 n/2를 올림한 숫자가 된다. 그리고 노드의 개수는 2^(k+1) - 1이 된다.</p>
<ol start="3">
<li>편향 이진 트리(skewed binary tree)</li>
</ol>
<p>모든 노드가 부모의 왼쪽 자식이기 때문에 왼편으로 편향되어 있거나 반대로 모든 노드가 부모의 오른쪽 자식으로 되어 오른쪽으로 편향되어 있는 이진트리를 말한다.</p>
<img src="/img/skewed_binary_tree.png" width="400" height="200">
<p>이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면 탐색, 삽입, 삭제, 메모리 성능 등 모든 면에서 배열에 비해 좋은 것이 없다.</p>
<h2 id="bstbinary-search-tree">BST(Binary Search Tree)</h2>
<p>효율적인 탐색을 위한 저장 방법이 무엇일까를 고민해야 한다.<br>
이진 탐색 트리는 이진 트리의 일종이다.<br>
단, 이진 탐색 트리에는 <strong>데이터를 저장하는 규칙이 있다.</strong><br>
그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떤 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떤 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>
<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다.<br>
사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다.<br>
이러한 이진 탐색 트리는 <strong>편항 트리</strong>가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생할 수 있기 때문이다.<br>
이럴 경우 성능에 영향을 미치게 되며, 탐색의 <code>Worst cost</code>가 발생하고 시간 복잡도는 O(n)이 된다.</p>
<p>배열보다 많은 메모리를 사용하여 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생했다.<br>
이를 해결하기 위해 <code>Rebalancing</code> 기법이 등장했다.</p>
<p>균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라고 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나는 추후에 살펴볼 Red-black-Tree 이다.</p>
<h2 id="이진-트리의-순회-방법">이진 트리의 순회 방법</h2>
<p>이진 트리의 순회 방법을 간단하게 정리하면 아래와 같다. 루트의 위치를 기준으로 이름을 기억하면 된다.</p>
<ol>
<li>전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리</li>
<li>중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리</li>
<li>후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Tree/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Diff-of-Array-LinkedList/"
                            aria-label=": [자료구조] Array vs LinkedList"
                        >
                            [자료구조] Array vs LinkedList
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T15:44:23+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>2019.03.20 일자 기준으로 공부했던 내용을 수정하려고 한다. 이유는 이렇게 정리해놨지만 머리에 기억으로 남지 않기 때문이다.</p>
<p>먼저, Array VS LinkedList를 비교해보겠다.</p>
<h2 id="array배열">Array(배열)</h2>
<ul>
<li>논리적 저장순서와 물리적 저장 순서가 일치한다.</li>
<li><code>인덱스</code>로 해당 원소에 접근이 가능하다.</li>
<li>인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.</li>
<li>즉, Random Access가 가능하다.</li>
<li>배열의 원소를 삭제할 경우 삭제한 원소보다 큰 인덱스를 가진 원소들을 옮겨줘야(Shift) 하기 때문에 시간 복잡도 O(n)이 걸린다.</li>
<li>삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1씩 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.</li>
<li>제한적인 크기를 갖는다.</li>
</ul>
<p>즉, 삭제 또는 삽입 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생해 O(n)의 시간복잡도를 갖는다.</p>
<h2 id="linkedlist">LinkedList</h2>
<ul>
<li>자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.</li>
<li>삽입과 삭제의 경우 LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다고 하는게 맞다. (아래에서 설명하겠다.)</li>
<li>원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회하여야 하므로 O(n)의 시간 복잡도를 갖는다.</li>
<li>트리의 근간이 되는 자료구조이다.</li>
</ul>
<p>LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다. 추가적으로 데이터를 삽입 / 삭제하기 위한 시간 복잡도까지 계산하면 결국 O(n)의 시간 복잡도를 갖는 셈이다.</p>
<p>하지만 위에서 경우에 따라서 다르다고 하지 않았는가?<br>
<strong>삽입의 경우</strong><br>
일단, <strong>LinkedList</strong>는 어느 곳에 삽입하던지 O(n)의 시간복잡도를 갖는다. (만약, 중간 삽입이 없다면 즉 맨 앞과 맨 뒤에만 삽입한다면 -&gt; 시간 복잡도 : O(1))</p>
<p><strong>삭제의 경우</strong><br>
삭제의 경우도 삽입과 마찬가지이다. 어느 곳에 삽입하던지 O(n)의 시간 복잡도를 갖는다. (만약, 중간 삭제가 없고 맨 앞과 뒤에서만 삭제한다면 -&gt; 시간 복잡도 : O(1))</p>
<h2 id="array-vs-linkedlist">Array VS LinkedList</h2>
<p><strong># 데이터 접근 속도</strong></p>
<p><strong>Array</strong>는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. 따라서 Random Access를 지원한다. <code>시간 복잡도 O(1)</code>로 빠르게 찾을 수 있다.</p>
<p><strong>LinkedList</strong>는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. <code>시간 복잡도 O(N)</code></p>
<p><strong># 데이터의 삽입 속도</strong></p>
<p>경우에 따라 다르다.<br>
만약 배열에 공간이 많이 남아있고 맨 끝에 삽입한다면 삽입 속도 역시 O(1)에 가능하다. 하지만 이런 경우는 발생하기 힘든 케이스이다.</p>
<p><strong>Array</strong>(배열)의 경우 데이터를 중간이나 맨 앞에 삽입할 경우 그 이후의 데이터를 한 칸씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을 경우 비효율적이다. 그렇기 때문에 <strong>LinkedList</strong>가 필요하게 되었다.</p>
<p><strong>LinkedList</strong>는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다.(만약, 중간 삽입이 없다면 O(1)의 시간복잡도를 갖는다.) 이유는 삽입할 위치를 찾고(O(N)) 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다.</p>
<p>또한 <strong>Array</strong>의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받지만 <strong>LinkedList</strong>는 그럴 필요가 없다. 추가할 때마다 동적으로 할당하는 것으로 알고 있다.</p>
<p><strong># 데이터의 삭제 속도</strong></p>
<p>이 부분도 경우에 따라 다르다.<br>
<strong>Array</strong>는 데이터 삭제의 경우 그 위치의 데이터를 삭제 후, 전체적으로 Shift 해줘야 한다. (O(N))</p>
<p><strong>LinkedList</strong>의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결구 O(N)의 시간 복잡도를 갖는다. 하지만 Array 보다 빠르게 삭제 연산을 수행한다.</p>
<p><strong># 메모리 할당</strong></p>
<ul>
<li>
<p><code>Array</code>에서 메모리는 Array가 선언되자 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다.</p>
</li>
<li>
<p><strong>Stack</strong> 영역에 메모리 할당이 이루어진다.</p>
</li>
<li>
<p><code>LinkedList</code>에서 메모리는 새로운 node가 추가될 때 runtime에 할당되어 진다. 이것은 동적 메모리 할당이라고 한다.</p>
</li>
<li>
<p><strong>Heap</strong> 영역에 메모리 할당이 이루어진다.</p>
</li>
</ul>
<p><strong># size</strong></p>
<p>Array의 size는 반드시 선언 시점에 지정되어있어야 한다.</p>
<p>LinkedList의 size는 다양할 수 있다. node들이 추가될 때 runtime 시점에서 LinkedList의 size가 커질 수 있기 때문이다.</p>
<h2 id="결론">결론</h2>
<ul>
<li>삽입과 삭제가 빈번하다면 <strong>LinkedList</strong>를 사용하는 것이 더 좋다.</li>
<li>데이터의 접근하는 게 중요하다면 <strong>Array</strong>를 사용하는 것이 좋다.</li>
</ul>
<p>전반적인 내용을 보면 Array보다 LinkedList(포괄적인 범위에서 List라고 하겠다.)의 사용이 훨씬 좋아보인다. 하지만 일반적인 알고리즘 문제를 풀 때는 List보다 Array가 훨씬 빠르고 좋다. 왜냐하면 대부분의 알고리즘 문제는 메모리 공간의 범위를 파악할 수 있도록 N의 크기가 주어지기 때문이다.</p>
<p>그래서 배열의 크기를 MAX로 초반에 잡을 수 있다면 훨씬 더 편리하고 List와는 다른 속도를 보인다. 왜냐하면 위에서 본 것처럼 List의 입력마다 메모리의 할당이 일어나고 삭제에서는 메모리 해제가 일어난다. 이런 작업은 시간복잡도에 포함되지는 않지만 <strong>시스템 콜</strong>(System Call)을 사용하는 구문은 <code>시간 소요</code>가 꽤 걸린다.</p>
<p>사용하려는 목적에 따라서 Array와 List를 구분해서 사용하면 된다.</p>
<p>자자, 위에서는 Array와 LinkedList의 차이점을 살펴보았다. 이번에는 ArrayList와 LinkedList의 차이를 살펴보겠다. 사실 위에서 본 것과 차이는 거의 없다고 생각한다. 이유는 ArrayList가 단지 내부적으로 Array(배열)를 사용하고 List 인터페이스를 구현했기 때문에 거의 똑같다고 생각한다. 그래도 한 번 살펴보자.</p>
<h3 id="arraylist-vs-linkedlist">ArrayList vs LinkedList</h3>
<p><strong>1. ArrayList</strong></p>
<ul>
<li>내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.</li>
<li>대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생</li>
<li>중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다.</li>
<li>반면 <strong>인덱스</strong>를 가지고 있어서 한 번에 참조가 가능해 데이터 검색에 유리하다.</li>
</ul>
<p><strong>ArrayList</strong>는 삽입과 삭제를 할 일이 없거나 배열의 끝에서만 하게 될 경우 유용하게 쓰일 수 있다. 원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다.</p>
<p><strong>2.LinkedList</strong></p>
<ul>
<li>데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.</li>
<li>ArrayList와 달리 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리하다.</li>
<li>반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다.</li>
</ul>
<p><strong>3. 데이터의 검색,삽입,삭제시 성능 비교</strong></p>
<blockquote>
<p>검색</p>
</blockquote>
<ul>
<li>ArrayList : 인덱스 기반이기 때문에 O(1)의 시간복잡도를 갖는다.</li>
<li>LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.</li>
</ul>
<blockquote>
<p>삽입,삭제</p>
</blockquote>
<ul>
<li>ArrayList : 삽입,삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간복잡도를 갖는다.</li>
<li>LinkedList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다. 하지만 이 부분도 경우에 따라 다르다.</li>
</ul>
<img src="/img/arraylist_linkedlist_diff.png" width="600" height="200">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@audrl1010/linked-list-%EC%99%80-array-%EC%B0%A8%EC%9D%B4%EC%A0%90-4ba873c2e5f5" target="_blank" rel="noopener">Linked List 와 Array</a></li>
<li><a href="https://makefortune2.tistory.com/191" target="_blank" rel="noopener">배열(Array)과 연결리스트(Linked List) 차이</a></li>
<li><a href="https://www.holaxprogramming.com/2014/02/12/java-list-interface/" target="_blank" rel="noopener">Java의 LinkedList와 ArrayList에 대한 비교</a></li>
<li><a href="https://manducku.tistory.com/33" target="_blank" rel="noopener">자료구조 List - ArrayList와 LinkedList 비교</a></li>
<li><a href="https://coding-factory.tistory.com/228?category=794828" target="_blank" rel="noopener">[Algorism] ArrayList와 LinkedList란 무엇인가?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Diff-of-Array-LinkedList/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-What-Is/"
                            aria-label=": [자료구조] 자료구조 개요"
                        >
                            [자료구조] 자료구조 개요
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T15:01:29+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="자료구조란">자료구조란?</h2>
<p>자료구조하면 무엇이 떠오르는가?</p>
<p>흔한 자료구조의 형태로 큐(Queue)나 스택(Stack) 혹은 연결 리스트, 트리 등을 떠올리거나 선택정렬, 삽입정렬 등의 정렬 알고리즘이 먼저 떠오른다.</p>
<p>사전적 의미를 살펴보면 다음과 같다. &quot;<code>자료(data)</code>의 집합을 의미하고 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 <code>효율적</code>으로 수행할 수 있도록 자료를 구분하여 표현한 것&quot;이라고 한다.</p>
<p>자료를 더 효율적으로 저장하고 관리하기 위해 사용하며 잘 선택된 자료구조는 <strong>실행 시간을 단축</strong>시켜주거나 <strong>메모리 용량의 절약</strong>을 이끌어 낼 수 있다.</p>
<p>자료 구조의 선택 기준은 아래와 같다.</p>
<ul>
<li>자료의 처리 시간</li>
<li>자료의 크기</li>
<li>자료의 활용 빈도</li>
<li>자료의 갱신 정도</li>
<li>프로그램의 용이성</li>
</ul>
<h2 id="자료구조의-특징">자료구조의 특징</h2>
<ol>
<li><strong>효율성</strong></li>
</ol>
<p>자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다.<br>
따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다.<br>
Ex)<br>
검색에 대한 알고리즘을 구현할 때, 데이터의 양이 만다면 순차 검색을 사용하는 것보다 이분 탐색(이분 검색)을 활용하는 것이 더 효율적일 것이다.<br>
왜냐하면 학생 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다.<br>
이에 반해, <strong>이분 탐색</strong>은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다.</p>
<ol start="2">
<li><strong>추상화</strong></li>
</ol>
<p>추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 시간을 더 쏟을 수 있다.<br>
알고리즘 자체에는 중점을 두지 않는다.</p>
<p>마찬가지로 자료구조 내부의 구현은 중요하지 않다.<br>
어떻게 구현했는지보다 어떻게 사용해야 하는지를 알고 있어야 한다.</p>
<p>Ex)<br>
Stack의 경우 나중에 들어간 것이 먼저 나오는 <code>LIFO(Last In First Out)</code>의 형태를 가지고 있다.</p>
<ul>
<li>push() 함수를 이용해 데이터를 삽입</li>
<li>pop() 함수를 이용해 데이터를 추출<br>
그 함수 내부 구현이 어떻게 되었는지는 크게 중요하지 않다. 사람마다 다른 코드를 작성할 것이고 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다.</li>
</ul>
<ol start="3">
<li><strong>재사용성</strong></li>
</ol>
<p>자료구조를 설계할 때 특정 프로그램에서만 동작하도록 설계 하지 않는다. 다양한 프로그램에서 동작할 수 있도록 <strong>범용성</strong> 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다.</p>
<h2 id="자료구조의-분류">자료구조의 분류</h2>
<p>자료구조는 크게 <strong>선형 자료구조</strong>와 <strong>비선형 자료구조</strong>로 나뉜다.</p>
<ol>
<li>선형 자료구조 : 데이터가 일렬로 나열되어 있는 즉, 선형인 것을 뜻한다.</li>
</ol>
<ul>
<li>배열</li>
<li>연결 리스트</li>
<li>스택</li>
<li>큐</li>
</ul>
<ol start="2">
<li>비선형 자료구조 : 선형이 아닌 특정한 형태를 띄고 있는 것을 뜻한다.</li>
</ol>
<ul>
<li>트리</li>
<li>그래프</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-What-Is/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/17/DataStructure/"
                            aria-label=": 자료구조 :: 자료구조?"
                        >
                            자료구조 :: 자료구조?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-17T01:07:37+09:00">
	
		    May 17, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>[2020.05.12]<br>
이 글은 굉장히 오래 전에 작성된 글입니다. 그래서 정리라기 보다는 내용을 한 곳에 썼다는 표현이 나을 것 같네요! 삭제하려고 했지만, 많은 내용을 담고 있어 레거시로 유지하려고 합니다. :) 이 페이지의 내용들이 여러 포스팅으로 나누어 작성되었으니 그 글을 참고하면 좋을 것 같습니다.</p>
<h1 id="자료구조란-무엇인가">자료구조란 무엇인가??</h1>
<p>자료구조 하면 무엇이 떠오를까요??? 흔한 자료구조의 형태로 <code>큐(Queue)</code>나 <code>스택(Stack)</code> 혹은 연결 리스트(Linked List), 트리(Tree) 등을 떠올리거나 선택정렬, 삽입 정렬 등등의 정렬 알고리즘 등이 먼저 떠오릅니다.</p>
<p>사전적인 의미는 <code>자료(data)</code>의 집합을 의미하며, 각 원소들이 <strong>논리적으로 정의된 규칙</strong>에 의해 나열되며 자료에 대한 처리를 <strong>효율적</strong>으로 수행할 수 있도록 자료를 구분하여 표현한 것이라고 한다.</p>
<p>목적은 명확하다. <code>자료</code>를 더 <strong>효율적으로 저장</strong>하고, 관리하기 위해 사용하며, 잘 선택된 자료구조는 <strong>실행시간을 단축</strong>시켜주거나 <strong>메모리 용량의 절약</strong>을 이끌어 낼 수 있다.</p>
<blockquote>
<p>자료구조의 선택 기준</p>
</blockquote>
<ul>
<li>자료의 처리 시간</li>
<li>자료의 크기</li>
<li>자료의 활용 빈도</li>
<li>자료의 갱신 정도</li>
<li>프로그램의 용이성</li>
</ul>
<p>자료의 처리를 보다 효율적으로 하기 위해서 위와 같은 사항을 고려하여 선택, 사용해야 한다.</p>
<h1 id="자료구조의-특징">자료구조의 특징</h1>
<ol>
<li>효율성</li>
</ol>
<p>자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다.<br>
Ex) 검색에 대한 알고리즘을 구현할 때, 데이터의 양이 많다면 순차 검색을 사용하는 것보다 이분 검색을 활용하는 것이 더 효율적일 것이다. 왜냐하면 학생이라는 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다. 이에 반해 이분 검색은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다.</p>
<ol start="2">
<li>추상화</li>
</ol>
<p>추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 더 시간을 쏟을 수 있다. 알고리즘 자체에는 중점을 두지 않는다.</p>
<p>마찬가지로 자료구조 내부의 구현은 중요하지 않다. 어떻게 구현했는지 보다 어떻게 사용해야 하는지를 알고 있어야 한다.<br>
Ex) Stack의 경우 먼저 들어간 것이 나중에 나오는 LIFO(Last In First Out)의 형태를 가지고 있다. 그리고 push() 함수를 이용해서 데이터를 삽입할 수 있고, pop() 함수를 이용해서 데이터를 추출할 수 있다. 그 함수 내부 구현이 어떻게 되었는지는 중요하지 않다. 사람마다 다른 코드를 작성할 것이고, 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다.</p>
<ol start="3">
<li>재사용성</li>
</ol>
<p>자료구조를 설계할 때 특정 프로그램에서만 동작하게 설계 하지는 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다.</p>
<h1 id="자료구조의-분류">자료구조의 분류</h1>
<p>자료구조는 크게 <strong>선형 자료구조</strong>와 <strong>비선형 자료구조</strong>로 나뉜다.</p>
<ol>
<li><code>선형 자료구조</code> : 데이터가 일렬로 나열되어 있는 것을 뜻한다.</li>
</ol>
<ul>
<li>배열(Array)</li>
<li>연결 리스트(Linked List)</li>
<li>스택(Stack)</li>
<li>큐(Queue)</li>
</ul>
<ol start="2">
<li><code>비선형 자료구조</code> : 특정한 형태를 띄고 있는 것을 뜻함</li>
</ol>
<ul>
<li>트리(Tree)</li>
<li>그래프(Graph)</li>
</ul>
<h1 id="array-vs-linked-list">Array vs Linked List</h1>
<blockquote>
<p>Array</p>
</blockquote>
<p>가장 기본적인 자료구조인 <code>Array</code> 자료구조는, <strong>논리적 저장 순서</strong>와 <strong>물리적 저장 순서</strong>가 <code>일치</code>한다. 따라서 <code>인덱스(index)</code>로 해당 원소에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 시간 복잡도 O(1)에 해당 원소로 접근할 수 있다. 즉 <strong>random access</strong>가 가능하다는 장점이 존재</p>
<p>하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약, 배열 중 어느 원소를 삭제했다고 했을 때, <strong>배열의 연속적인 특징이 깨지게 된다.</strong> 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 <code>shift</code>해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity와 worst case는 O(n)이 된다.<br>
삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1씩 <code>shift</code> 해줘야 하므로 이 경우도 시간 복잡도 O(n)을 갖게 된다.</p>
<blockquote>
<p>Linked List</p>
</blockquote>
<p>이 부분에 대한 문제점을 해결하기 위한 자료구조가 <code>Linked List</code>이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 시간 복잡도 O(1)만에 해결할 수 있다.<br>
하지만 <code>Linked List</code> 역시 한 가지 문제가 존재한다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 하는 과정에 있어서 <strong>첫 번째 원소부터 모두 확인</strong>해봐야 한다는 것이다. Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 시간 복잡도 O(n)의 시간이 추가적으로 발생하게 된다.</p>
<p>결국 <code>Linked List</code> 자료구조는 Search에도 O(n)의 시간 복잡도를 갖고, 삽입, 삭제에 대해서도 O(n)의 시간 복잡도를 갖는다. 그렇다고 해서 아주 쓸모 없는 자료구조는 아니기에, 우리가 아직 배우는 것이다. Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때, 그 유용성이 드러난다.</p>
<h1 id="stack-and-queue">Stack and Queue</h1>
<blockquote>
<p>Stack</p>
</blockquote>
<p><code>선형 자료구조</code>의 일종으로 <strong>Last In First Out(LIFO)</strong> 즉, 나중에 들어간 원소가 먼저 나온다. 이것이 Stack의 가장 큰 특징이다. 차곡 차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조이다.</p>
<blockquote>
<p>Queue</p>
</blockquote>
<p><code>선형 자료구조</code>의 일종으로 <strong>Fist In First Out(FIFO)</strong> 즉, 먼저 들어간 놈이 먼저 나온다. Stack과는 반대로 먼저 들어간 놈이 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다.</p>
<h1 id="tree">Tree</h1>
<p>트리는 스택이나 큐와 같은 선형 구조가 아닌 <strong>비선형 자료구조</strong>이다. 트리는 <code>계층적 관계</code>를 표현하는 자료구조이다. <code>트리</code>라는 자료구조는 표현에 집중한다.</p>
<blockquote>
<p>트리를 구성하고 있는 구성요소들 - 용어</p>
</blockquote>
<ul>
<li>Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미</li>
<li>Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미</li>
<li>Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미</li>
<li>Termianl Node( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미</li>
<li>Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.</li>
</ul>
<h2 id="binary-tree이진-트리">Binary Tree(이진 트리)</h2>
<p>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어 진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다. 즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다. 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않을 듯 하다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf node에 다 달았을 때, 정의가 만족되기 때문이다.</p>
<p>트리에서는 각 <strong>층별</strong>로 숫자를 매겨서 이를 트리의 <code>Level</code>이라고 하낟. 루트 노드부터 시작하고 루트 노드의 level은 9이다. 그리고 트리의 최고 level을 가리켜 해당 트리의 <code>height(높이)</code>라고 한다.</p>
<blockquote>
<p>완전 이진 트리(Complete Binary Tree)</p>
</blockquote>
<p><img src="/img/binary_tree.png" alt=""></p>
<p>그림과 같이 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워지고 자식이 2개이고 꽉 찬 트리르 완전 이진 트리라고 한다.<br>
완전 이진 트리의 노드 개수는 2^(level-1)이다.</p>
<blockquote>
<p>포화 이진 트리(Full Binary Tree)</p>
</blockquote>
<p>모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 한다.</p>
<p>Full Binary Tree와 Complete Binary Tree는 노드의 개수가 n일 때, i번째 노드에 대해서 parent(i) = i/2, left_child(i) = 2i, right_child(i) = 2i+1 의 index 값을 갖는다.</p>
<p><img src="/img/tree.png" alt=""></p>
<p>이러한 최악의 경우 한쪽으로 계속 쏠리게 되는 형태 또한 이진 트리이다. 이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면, 탐색, 삽입, 삭제, 메모리 성능 모든 면에서 배열에 비해 좋은 것이 없다.</p>
<ul>
<li>이진 트리의 순회 방법</li>
</ul>
<ol>
<li>전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리</li>
<li>중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리</li>
<li>후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트</li>
</ol>
<h2 id="bstbinary-search-tree">BST(Binary Search Tree)</h2>
<p>효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 <strong>데이터를 저장하는 규칙이 있다.</strong> 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떤 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떤 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다.</li>
</ul>
<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 Skewed Tree(편향 트리)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다.<br>
이럴 경우 성능에 영향을 미치게 되며, 탐색의 <strong>Worst Case</strong>가 되고 시간 복잡도는 O(n)이 된다.</p>
<p>배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 <code>Rebalancing</code> 기법이 등장했다. 균형을 잡기 위한 트리 구조의 재조정을 <code>Rebalancing</code>이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 긎 ㅜㅇ에서 하나가 뒤에서 살펴볼 <code>Red-black-Tree</code>이다.</p>
<h2 id="binary-heap">Binary Heap</h2>
<p>자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 <code>Complete Binary Tree</code>이다. 배열에 트리의 값을 넣어 줄 때, 0번째는 건너뛰고 1번 index 부터 루트 노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다.<br>
힙에는 <code>최대힙(max heap)</code>과 <code>최소힙(min heap)</code> 두 종류가 있다.</p>
<p><code>Max heap</code>이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 **Complete Binary Tree(완전 이진 트리)**를 말한다. [Min heap은 그 반대]</p>
<p>Max heap에서는 Root noed에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다. 그리고 complete binary tree 이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다 (즉, random access가 가능하다. Min heap에서는 최소값을 찾는데 소요되는 연산의 시간복잡도가 O(1)이다.) 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.</p>
<h2 id="red-black-tree">Red Black Tree</h2>
<p>RBT(Red-Black Tree)는 BST를 기반으로 하는 <strong>트리 형식의 자료구조</strong>이다. 결론부터 말하자면 Red-Black Tree에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, <strong>depth</strong>를 최소화하여 <code>시간 복잡도를 줄이는 것</code>이 핵심 아이디어이다. 동일한 노드의 개수일 때, <strong>depth</strong>가 최소가 되는 경우는 tree가 완전 이진 트리(complete binary tree)인 경우이다.</p>
<h3 id="red-black-tree의-정의">Red-Black Tree의 정의</h3>
<p>RBT는 다음의 성질을 만족하는 BST이다.</p>
<ol>
<li>각 노드는 <code>Red</code> or <code>Black</code>라는 색깔을 갖는다.</li>
<li>Root node의 색깔은 <code>Black</code>이다.</li>
<li>각 leaf node는 <code>black</code>이다.</li>
<li>어떤 노드의 색깔이 <code>red</code>라면 두 개의 children 의 색깔은 모두 black이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes들을 포함하고 있다. 이를 해당 노드의 <code>Black-Height</code>라고 한다.<br>
cf) Black-Height : 노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수</li>
</ol>
<h3 id="red-black-tree의-특징">Red-Black Tree의 특징</h3>
<ol>
<li>Binary Search Tree이므로 BST의 특징을 모두 갖는다.</li>
<li>Root node부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 <code>balanced</code> 상태라고 한다.</li>
<li>노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 leaf node로 간주한다.</li>
</ol>
<h3 id="삽입">삽입</h3>
<p>우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 RED로 지정한다. Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고, Black-Height가 위배되었다면 <strong>rotation</strong>을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 Black-height가 같아지게 되고 최소 경로와 최대 겨올의 크기 비율이 2미만으로 유지된다.</p>
<h3 id="삭제">삭제</h3>
<p>삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고 노드의 색깔을 조정한다. 지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.</p>
<h1 id="hashtable">HashTable</h1>
<p><code>hash</code>는 내부적으로 <strong>배열</strong>을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 Search하는데 데이터 고유의 <code>인덱스</code>로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다. (항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.) 하지만 문제는 이 인덱스로 저장되는 key 값이 불규칙하다는 것이다.</p>
<p>그래서 <strong>특별한 알고리즘을 이용하여</strong> 저장할 데이터와 <strong>고유한 숫자를 만들어 낸 뒤</strong> 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.</p>
<h2 id="hash-function">hash function</h2>
<p>'특별한 알고리즘’을 통해 고유한 인덱스 값을 설정하는 것이 중요하다. '특별한 알고리즘’을 <code>hash method</code>또는 <code>해시 함수(hash function)</code>라고 하고 이 메소드에 의해 반환된 데이터의 고유의 숫자 값을 <code>hashcode</code>라고 한다. 저장되는 값들의 key 값을 <code>hash function</code>을 통해서 <strong>작은 범위의 값들로</strong> 바꿔준다.</p>
<p>하지만 어설픈 <code>hash function</code>을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 <code>Collision</code>이라고 한다.</p>
<ul>
<li>Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.</li>
</ul>
<p>일반적으로 좋은 <code>hash function</code>는 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다. 하지만 좋은 해쉬 함수는 키의 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.</p>
<p><code>hash function</code>를 무조건 1:1로 만드는 것보다 <strong>Collision</strong>을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 hash function를 만들어봤자 그건 array와 다를바 없고 메모리를 너무 차지하게 된다.</p>
<p><strong>Collision</strong>이 많아질 수록 Search에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 hash function는 hash를 hash답게 사용하지 못하도록 한다. 좋은 hash function를 선택하는 것은 hash table의 성능 향상에 필수적인 것이다.</p>
<p>따라서 hashing된 인덱스에 이미 다른 값이 들어 있다면 세 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.</p>
<h2 id="resolve-confilct">Resolve Confilct</h2>
<ol>
<li>Open Address 방식(개방 주소법)</li>
</ol>
<p>해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용중인 경우) <strong>다른 해시 버킷에 해당 자료를 삽입하는 방식</strong>이다. 버킷이란 바구니와 같은 개념으로 <strong>데이터를 저장하기 위한 공간</strong>이라고 생각하면 된다. 다른 해시 버킷이란 어떤 해시 버킷인가???</p>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. <strong>Worst Case</strong>의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 방법이 존재하고, 3가지를 살펴보겠다.</p>
<ul>
<li>Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.</li>
<li>Quadratic probing : 2차 함수를 이용해 탐색할 위치를 찾는다.</li>
<li>Double hashing probing : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다.</li>
</ul>
<ol start="2">
<li>Seperate Chaining 방식(분리 연결법)</li>
</ol>
<p>일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 <code>Separate Chaining</code> 방식의 경우 해시 <strong>충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정</strong>할 수 있다면 <strong>Worst Case에 가까워 지는 빈도를 줄일 수 있다</strong>. Java 7에서는 Separate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.</p>
<ul>
<li>
<p>연결 리스트를 사용하는 방식(Linked List)<br>
각각의 버킷들을 연결 리스트로 만들어 <code>Collision</code>이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 <strong>오버헤드</strong>가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 바해 테이블의 확장을 늦출 수 있다.</p>
</li>
<li>
<p>Tree를 사용하는 방식<br>
기본적인 알고리즘은 <code>Separate Chaining</code> 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 <code>key-value</code> 쌍의 개수이다. 데이터의 개수가 적다면 Linked List를 사용하는 것이 맞다.<br>
Tree는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.</p>
</li>
</ul>
<p><strong>데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</strong><br>
앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6개, 8개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다.</p>
<p><strong>한 가지 상황을 가정해보자.</strong><br>
해시 버킷에 6개 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개에서 7개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.</p>
<ul>
<li>Open Address vs Separate Chaining</li>
</ul>
<p>일단 두 방식 모두 Worst Case 에서 O(M)이다. 하지만 <code>Open Address</code>방식은 연속된 공간에 데이터를 저장하기 때문에 <code>Separate Chaining</code>에 비해 <strong>캐시 효율이 높다</strong>. 따라서 데이터의 개수가 충분히 적다면 <code>Open Address</code> 방식이 <code>Separate Chaining</code> 보다 더 성능이 좋다.<br>
한 가지 차이점이 더 존재한다. Separate Chaining방식에 비해 Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 <strong>확장을 보다 늦출 수 있다.</strong></p>
<p><strong>보조 해시 함수</strong></p>
<p>보조 해시 함수의 목적은 <code>key</code>의 해시 값을 변형하여 <strong>해시 충돌 가능성을 줄이는 것</strong>이다. <code>Separate Chaining</code> 방식을 사용할 때 함께 사용되며 보조 해시 함수로 <strong>Worst Case</strong>에 가까워지는 경우를 줄일 수 있다.</p>
<ol start="3">
<li>해시 버킷 동적 확장(Resize)</li>
</ol>
<p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 <strong>HashMap</strong>은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.<br>
<code>일정 개수 이상</code> -&gt; 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. <strong>0.75</strong> -&gt; <strong>load factor</strong>라고 불린다.</p>
<h1 id="graph">Graph</h1>
<p><strong>Graph</strong> : 정점과 간선의 집합<br>
cf) 트리 또한 그래프이며, 그 중 사이클이 허용되지 않는 그래프를 말한다.</p>
<h2 id="그래프-관련-용어-정리">그래프 관련 용어 정리</h2>
<ol>
<li>
<p>Undirected Graph<br>
정점과 간선의 연결 관계에 있어서 방향성이 없는 그래프</p>
</li>
<li>
<p>Directed Graph(Diagraph)<br>
간선에 방향성이 포함되어 있는 그래프</p>
</li>
<li>
<p>Degree(차수)</p>
</li>
</ol>
<p>Undirected Graph에서 각 정점에 연결된 Edge의 개수를 말한다. Directed Graph에서는 간선에 방향성이 존재하기 때문에 Degree가 두 개로 나뉘게 된다.<br>
각 정점으로부터 나가는 간선의 개수를 <strong>OutDegree</strong>라 하고, 들어오는 간선의 개수를 <strong>Indegree</strong>이라 한다.</p>
<ol start="4">
<li>가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph)</li>
</ol>
<p><strong>가중치 그래프</strong>란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 <strong>비가중치 그래프</strong> 즉, 모든 간선의 가중치가 동일한 그래프도 존재한다. 부분 집합과 유사한 개념으로 부분 그래프라는 것이 있다. 부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</p>
<ol start="5">
<li>그래프를 구현하는 두 방법</li>
</ol>
<ul>
<li>
<p>인접 행렬(adjacent matrix) : 정방 행렬을 사용하는 방법<br>
해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)로 파악할 수 있다. Edge 개수와는 무관하게 V^2의 공간 복잡도를 갖는다. Dense graph를 표현할 때 적절한 방법이다.</p>
</li>
<li>
<p>인접 리스트(adjacent list) : 연결 리스트를 사용하는 방법</p>
</li>
</ul>
<p>vertex(정점)의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다. 공간 복잡도는 O(E+V)이다. <strong>Sparse graph</strong>를 표현하는데 적당한 방법</p>
<ol start="6">
<li>그래프 탐색</li>
</ol>
<p>그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<ul>
<li>깊이 우선 탐색(Depth First Search : DFS)</li>
</ul>
<p>그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 <strong>한 정점으로만 나아간다</strong>라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다.<br>
어떤 자료구조를 사용해야할까?? Stack이다.<br>
시간 복잡도 : O(V+E) … vertex개수+edge개수</p>
<ul>
<li>너비 우선 탐색(Breadth First Search : BFS)</li>
</ul>
<p>그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 <strong>모든 정점으로 나아간다</strong>. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서는 자료구조로 <code>Queue</code>를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 <code>Queue</code>에 넣는다.(enqueue) 그리고 <strong>dequeue</strong>를 하면서 정점과 간선으로 연결되어 있는 정점들을 <strong>enqueue</strong>한다. 즉 vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다.<br>
시간 복잡도 : O(V+E) … vertex개수 + edge 개수<br>
<strong>BFS로 구한 경로는 최단 경로</strong></p>
<ol start="7">
<li>Minimum Spanning Tree</li>
</ol>
<p>그래프 G의 spanning tree 중 edge weight의 합이 최소이 <code>spanning tree</code>를 말한다. 여기서 말하는 <code>spanning tree</code>란 그래프 G의 모든 vertex가 cycle이 없이 연결된 형태를 말한다.</p>
<ol start="8">
<li>Kruskal Algorithm</li>
</ol>
<p>초기화 작업으로 <strong>edge</strong> 없이 vertex들만으로 그래프를 구성한다. 그리고 weight가 제일 작은 edge부터 검토한다. 그러기 위해서는 edge Set을 non-decreasing으로 해야 한다. 그리고 가장 작은 weight에 해당하는 edge를 추가하는데 추가할 때 그래프에 cycle이 생기지 않는 경우에만 추가한다. spanning tree가 완성되면 모든 vertex들이 연결된 상태로 종료가 되고 완성될 수 없는 그래프에 대해서는 모든 edge에 대해 판단이 이루어지면 종료된다.</p>
<ul>
<li>
<p>어떻게 cycle 생성 여부를 판단하는가??<br>
graph의 각 vertex에 <strong>set-id</strong>라는 것을 추가적으로 부여한다. 그리고 초기화 과정에서 모두 1~n까지의 값으로 각각의 vertex들을 초기화한다. 여기서 0은 어떠한 edge와도 연결되지 않았음을 의미하게 된다. 그리고 연결할 때마다 <strong>set-id</strong>를 하나로 통일시키는데, 값이 동일한 <strong>set-id</strong>개수가 많은 <strong>set-id</strong> 값으로 통일시킨다.</p>
</li>
<li>
<p>Time Complexity(시간 복잡도)</p>
</li>
</ul>
<ol>
<li>
<p>Edge의 weight를 기준으로 sorting - O(E log E)</p>
</li>
<li>
<p>cycle 생성 여부를 검사하고 set-id를 통일 - O(E + V log V) =&gt; 전체 시간 복잡도 : O(E log E)</p>
</li>
<li>
<p>Prim Algorithm</p>
</li>
</ol>
<p>초기화 과정에서 한 개의 vertex로 이루어진 초기 그래프 A를 구성한다. 그리고 나서 그래프 A 내부에 있는 vertex로부터 외부에 있는 vertex 사이의 edge를 연결하는데 그 중 가장 작은 weight의 edge를 통해 연결되는 vertex를 추가한다. 어떤 vertex건 간에 상관없이 edge의 weight를 기준으로 연결하는 것이다. 이렇게 연결된 vertex(정점)는 그래프 A에 포함된다. 위 과정을 반복하고 모든 vertex들이 연결되면 종료한다.</p>
<p>Time Complexity(시간 복잡도)<br>
=&gt; 전체 시간 복잡도 : O(E log V)</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/17/DataStructure/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/03/20/DataStructure-Diff-of-Stack-Queue/"
                            aria-label=": [자료구조] Stack vs Queue"
                        >
                            [자료구조] Stack vs Queue
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-03-20T16:16:05+09:00">
	
		    Mar 20, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="stack">Stack</h2>
<ul>
<li>Last In First Out(LIFO)의 구조로 나중에 들어간 원소가 가장 먼저 나오는 자료구조이다.</li>
<li>반대로 제일 먼저 들어간 원소가 가장 늦게 나온다.</li>
<li>함수의 콜스택에 쓰이고 문자열을 역순으로 출력할 때, 연산자 후위표기법 등에 쓰인다.</li>
</ul>
<h2 id="queue">Queue</h2>
<ul>
<li>First In First Out(FIFO)의 구조로 먼저 들어간 원소가 먼저 나오는 구조를 갖는다.</li>
<li>컴퓨터 <strong>버퍼</strong>에서 주로 사용된다. 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼를 만들어 대기 시킨다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://jeong-pro.tistory.com/97" target="_blank" rel="noopener">스택, 큐, 덱(Stack, queue, deque)의 특징에 대해 설명해보세요!</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/03/20/DataStructure-Diff-of-Stack-Queue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
