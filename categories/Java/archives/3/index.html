
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Category: Java - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/categories/Java/archives/3/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-15/"
                            aria-label=": [Java] 15. 입력과 출력"
                        >
                            [Java] 15. 입력과 출력
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T10:51:33+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림">스트림</h1>
<hr>
<p><strong>자바에서는 파일이나 콘솔의 입출력을 직접 다루지 않고, 스트림(stream)이라는 흐름을 통해 다룹니다.</strong></p>
<p>스트림(stream)이란 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름을 의미합니다. 즉, 스트림은 운영체제에 의해 생성되는 가상의 연결고리를 의미하며, 중간 매개자 역할을 합니다.</p>
<img src="/img/stream.png" width="500" height="200">
<p>Java SE 8 버전부터 추가된 스트림 API는 앞서 설명한 스트림과는 전혀 다른 개념입니다. 스트림 API는 추후에 포스팅할 예정입니다. ^0^</p>
<h2 id="입출력-스트림">입출력 스트림</h2>
<p><strong>스트림은 한 방향으로만 통신할 수 있으므로, 입력과 출력을 동시에 처리할 수는 없습니다. 따라서 스트림은 사용 목적에 따라 입력 스트림과 출력 스트림으로 구분됩니다.</strong></p>
<p>자바에서는 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지를 통해 InputStream과 OutputStream 클래스를 별도로 제공하고 있습니다. 즉, 자바에서의 스트림 생성이란 이러한 스트림 클래스 타입의 인스턴스를 생성한다는 의미입니다.</p>
<p><strong>InputStream</strong> 클래스에는 read() 메소드가, <strong>OutputStream</strong> 클래스에는 write() 메소드가 각각 추상 메소드로 포함되어 있습니다. 사용자는 이 두 메소드를 상황에 맞게 적절히 구현해야만 입출력 스트림을 생성하여 사용할 수 있습니다.</p>
<img src="/img/stream_class.png" width="500" height="200">
<blockquote>
<p>read() 메소드는 해당 입력 스트림에서 더 이상 읽어들일 바이트가 없으면 -1을 반환해야 합니다. 그런데 반환 타입을 byte 타입으로 하면 0 ~ 255까지의 바이트 정보는 표현할 수 있지만 -1은 표현할 수 없게 됩니다. 따라서 InputStream의 read() 메소드는 반환 타입을 int형으로 선언하고 있습니다.</p>
</blockquote>
<h2 id="바이트-기반-스트림">바이트 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 자바에서는 아래와 같이 다양한 바이트 기반의 입출력 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:left">AudioInputStream</td>
<td style="text-align:center">AudioOutputStream</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<h2 id="보조-스트림">보조 스트림</h2>
<p>자바에서 제공하는 보조 스트림은 실제로 데이터를 주고 받을 수는 없지만, 다른 스트림의 기능을 향상시키거나 새로운 기능을 추가해 주는 스트림입니다. 자바에서는 아래와 같은 다양한 보조 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterInputStream</td>
<td style="text-align:center">FilterOutputStream</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center">입출력 스트림으로부터 자바의 기본 타입으로 데이터를 읽어올 수 있게함.</td>
</tr>
<tr>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center">데이터를 객체 단위로 읽거나, 읽어 들인 객체를 역직렬화시킴</td>
</tr>
<tr>
<td style="text-align:center">SequenceInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">두 개의 입력 스트림을 논리적으로 연결함.</td>
</tr>
<tr>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h2 id="문자-기반-스트림">문자 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 하지만 자바에서 가장 작은 타입인 char 형이 2바이트이므로, 1바이트씩 전송되는 바이트 기반 스트림으로는 원활한 처리가 힘든 경우가 있습니다.</p>
<p>따라서 자바에서는 바이트 기반 스트림뿐만 아니라 문자 기반의 스트림도 별도로 제공합니다. <strong>이러한 문자 기반 스트림은 기존의 바이트 기반 스트림에서 InputStream을 Reader로, OutputStream을 Writer로 변경하면 사용할 수 있습니다.</strong></p>
<p>다음은 다양한 문자 기반의 입출력 스트림을 보여주고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<p>지금까지 살펴본 바이트 기반의 스트림과 문자 기반의 스트림은 활용 방법이 거의 같습니다. 따라서 문자 기반의 보조 스트림도 다음과 같이 제공됩니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">FilterWriter</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintWriter</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h1 id="표준-입출력">표준 입출력</h1>
<hr>
<p>자바에서는 콘솔과 같은 입출력 장치를 위해 System이라는 표준 입출력 클래스를 정의하고 있습니다. java.lang 패키지에 포함되어 있는 System 클래스는 표준 입출력을 위해 다음과 같은 클래스 변수를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스 변수</th>
<th style="text-align:center">입출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://System.in" target="_blank" rel="noopener">System.in</a></td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">콘솔로부터 데이터를 입력받는다.</td>
</tr>
<tr>
<td style="text-align:center">System.out</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.</td>
</tr>
<tr>
<td style="text-align:center">System.err</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.(에러를 출력)</td>
</tr>
</tbody>
</table>
<p>표준 입출력 스트림은 자바가 자동으로 생성하므로, 개발자인 우리가 별도로 스트림을 생성하지 않아도 사용할 수 있습니다. &gt;__&lt;</p>
<h2 id="표준-입출력의-대상-변경">표준 입출력의 대상 변경</h2>
<p>앞서 살펴본 세 가지 입출력 스트림은 모두 콘솔과 같은 표준 입출력 장치를 대상으로 합니다. 하지만 이와 같은 스트림에 다음 System 메소드를 사용하면 스트림의 대상을 다른 입출력 장치로 변경할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static void setIn(InputStream in)</td>
<td style="text-align:center">입력 스트림의 대상을 전달된 입력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setOut(PrintStream out)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setErr(PrintStream err)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
</tbody>
</table>
<h2 id="randomaccessfile-클래스">RandomAccessFile 클래스</h2>
<p>앞서 살펴본 다양한 입출력 스트림을 이용하면 파일에 <strong>순차적으로</strong> 입출력 작업을 수행할 수 있습니다. 하지만 순차적인 접근이 아닌 임의의 지점에 접근하여 작업을 수행하고 싶다면, <strong>RandomAccessFile 클래스를 사용하면 됩니다.</strong> 이 클래스는 <code>파일</code>만을 대상으로 하며, 임의의 지점에서 입출력을 동시에 수행할 수 있습니다.</p>
<p>RandomAccessFile 클래스의 생성자에는 인수로 파일의 이름뿐만 아니라 파일 모드까지 함께 전달해야 합니다. 파일 모드란 파일의 사용 용도를 나타내는 문자열로, 자바에서 사용할 수 있는 대표적인 파일 모드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">파일 모드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">파일을 오로지 읽는 것만 가능한 모드로 개방함.</td>
</tr>
<tr>
<td style="text-align:center">“rw”</td>
<td style="text-align:center">파일을 읽고 쓰는 것이 모두 가능한 모드로 개방함. 만약 파일이 없으면 새로운 파일을 생성함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "rw" 모드로 "data.txt" 파일을 개방함.</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        System.out.println(file.getFilePointer()); </span><br><span class="line">        <span class="comment">// 0 : 파일 포인터의 현재 위치를 반환함.</span></span><br><span class="line">        file.writeInt(<span class="number">10</span>);<span class="comment">// 정수 10을 저장함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 4</span></span><br><span class="line">        file.seek(<span class="number">20</span>);                        </span><br><span class="line">        <span class="comment">// 파일 포인터의 위치를 20으로 이동시킴.</span></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getFilePointer() : 파일 포인터의 현재 위치를 확인할 수 있다.</li>
<li>seek() : 파일 포인터의 위치를 변경할 수 있다.</li>
</ul>
<h2 id="file-클래스">File 클래스</h2>
<p>앞서 살펴본 입출력 스트림을 사용하면 파일을 통한 입출력 작업을 수행할 수 있습니다. 하지만 파일의 제거나 디렉터리에 관한 작업 등은 입출력 스트림을 통해서는 수행할 수 없습니다.</p>
<p>자바는 이러한 입출력 작업 이외의 파일과 디렉터리에 관한 작업을 File 클래스를 통해 처리하도록 하고 있습니다. File 클래스에는 다음과 같은 다양한 메소드가 정의되어 있습니다.</p>
<img src="/img/file_class.png" width="800" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"D:\\data"</span>); <span class="comment">// 디렉토리 생성</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(dir, <span class="string">"data.txt"</span>); </span><br><span class="line">    <span class="comment">// 위에서 생성한 디렉토리에 파일 생성</span></span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">"파일이 존재하지 않습니다."</span>);</span><br><span class="line">        System.out(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.pirntln(file.getPath());</span><br><span class="line">    <span class="comment">// 파일의 경로 반환 : D:\data\data.txt</span></span><br><span class="line">    System.out.println(file.length());</span><br><span class="line">    <span class="comment">// 파일의 크기를 반환함</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">D:\data\data.txt</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-15/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/02/java-basic-14/"
                            aria-label=": [Java] 14. 예외 처리"
                        >
                            [Java] 14. 예외 처리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-02T11:02:54+09:00">
	
		    Sep 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="오류error와-예외exception">오류(error)와 예외(exception)</h1>
<hr>
<p>자바 프로그램을 작성할 때 자바 문법에 맞지 않게 코드를 작성하고 컴파일하려고 하면 자바 컴파일러는 문법 오류(syntax error)를 발생시킵니다. 또한, 자바 문법에는 맞게 작성되었다 하더라도 프로그램이 실행되면서 예상하지 못한 오류가 발생할 수 있습니다.<br>
이렇게 컴퓨터 시스템이 동작하는 도중에 예상하지 못한 사태가 발생하여 실행 중인 프로그램이 영향을 받는 것을 오류(error)와 예외(exception) 두 가지로 구분할 수 있습니다.</p>
<blockquote>
<p>코드를 작성하는 과정에서 예기치 못한 수많은 에러들이 발생합니다. 예를 들면 다음과 같습니다.<br>
<strong>컴파일 전에 알게 되는 에러도 있고, 작성할 때는 아무 문제 없다가 실행시키고 나서야 발생하는 에러들이 있습니다. 이것들을 제어할 수 있어야 좀 더 안전한 프로그램을 설계할 수 있습니다.</strong></p>
</blockquote>
<p><code>에러(error)? 예외(exception)?</code></p>
<p>컴파일 에러 - 컴파일 시에 발생하는 에러<br>
런타임 에러 - 실행 시에 발생하는 에러<br>
논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 에러</p>
<p>그럼 위에서 말하는 컴파일, 런타임은 무엇이면 컴파일 에러는 무엇일까요?? 공부를 하다보니 들어본 적은 있지만, 정확하게 무엇이라고 설명하기에는 부족한 부분들이 있어서 아래에 정리해봤습니다.</p>
<ul>
<li>컴파일 에러 : 주로 문법상의 오류가 많습니다. (빨간 줄이 나타나는 에러와 같은 경우입니다. 대부분의 IDE들이 빨간줄 표시로 잡아줍니다.) 컴파일 에러가 발생하는 경우는 주로 오타, 중괄호의 짝이 맞지 않는 경우, 중복된 변수명 등의 원인이 있을 수 있습니다.</li>
<li><code>RunTime</code> : 어떤 프로그램이 실행되는 동안의 Time을 의미하며, runtime error는 어떤 프로그램이 실행되는 동안 발생하는 에러입니다.</li>
<li>런타임 에러 : 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 경우, 대표적인 경우가 <strong>NullpointerException</strong></li>
<li><code>Compile Time</code> : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정이라고 하며, compile error는 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정에서 발생하는 에러입니다.</li>
</ul>
<p>즉, 컴파일 에러가 발생하지 않더라도 런타임 에러가 발생할 수 있습니다.</p>
<p><img src="/img/compile_runtime.png" alt=""></p>
<h2 id="오류error">오류(error)</h2>
<p>**오류(error)**는 시스템 레벨에서 프로그램에 심각한 문제를 야기하여 실행 중인 프로그램을 종료시킵니다. 이러한 오류는 개발자가 미리 예측하여 처리할 수 없는 것이 대부분이므로, 오류에 대한 처리는 할 수 없습니다.<br>
(ex. 메모리 부족, 스택 오버플로우와 같이 발생하면 복구할 수 없는.)</p>
<h2 id="예외exception">예외(exception)</h2>
<p>**예외(exception)**는 오류와 마찬가지로 실행 중인 프로그램을 비정상적으로 종료시키지만, 발생할 수 있는 상황을 미리 예측하여 처리할 수 있습니다. 따라서 개발자는 예외 처리(Exception handling)를 통해 예외 상황을 처리할 수 있도록 코드의 흐름을 바꿀 필요가 있습니다.<br>
(발생하더라도 수습될 수 있는, 비교적 덜 심각한. 그렇기에 프로그램의 비정상적인 종료를 사전에 예방할 수 있음.)</p>
<h1 id="예외처리exception-handling">예외처리(exception handling)</h1>
<hr>
<p>자바에서 예외 처리는 이 <strong>Exception을 Handling하는 것</strong>을 말합니다. 프로그램을 제작하는 과정에서 발생할 예외에 대해 미리 코드를 작성하는 것입니다.</p>
<p>if-else문으로 처리를 해야만 했던, C에서는 예외 처리를 위한 if문과 일반 if문을 구분하기 힘들었습니다. 이 문제를 해결하기 위해 <strong>Java</strong>에서는 예외 처리에 특화된 문법을 제공합니다.</p>
<p>그것이 바로 <strong>try-catch문입니다.</strong> 사용하는 방법과 코드에 대한 설명은 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 예외를 발생시킬 위험을 갖고 있는 코드(로직)</span></span><br><span class="line"><span class="comment">// 이 로직은 예외 상황과 관련있는 문장들도 고려해야 합니다.</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line"><span class="comment">// 예외가 발생했을 때 실행되는 로직</span></span><br><span class="line"><span class="comment">// Exception클래스는 모든 예외의 상위 클래스</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 예외 발생 여부와 상관없이 무조건 실행될 코드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 보면 예외를 발생시킬 위험을 갖고 있는 코드인 경우 <strong>try{ }</strong> 블록 안에 넣어둡니다. 그리고 <strong>catch</strong>를 통해 오류 메시지를 출력합니다. try안에 있는 코드를 실행하다가 오류가 발생하면 catch 구문으로 <strong>Jump</strong>합니다.</p>
<blockquote>
<p>Jump : 오류가 발생한 구문 다음의 코드는 실행되지 않는다.</p>
</blockquote>
<p>그러면 catch 메소드가 실행되게 되는데, 이 때 Exception이라는 클래스를 e로 인스턴스화하여 catch에 매개변수로 전달합니다. 그리고 Exception 이라는 클래스에 있던 getMessage라는 메소드를 호출하거나 다른 구문을 실행합니다.</p>
<p>다음은 예외가 발생했을 때 실행되는 로직의 예입니다.<br>
Sysetm.out.println(e.getMessage()); -&gt; 가장 간단한 예외 상황을 출력<br>
Sysetm.out.println(e.toString()); -&gt; 예외 상황에 대한 좀 더 자세한 정보를 출력<br>
e.printStackTrace(); -&gt; 예외 상황이 발생한 소스코드의 위치까지 출력</p>
<p>그리고 위의 코드처럼 catch 구문을 여러 개 두어서 다중 catch도 가능합니다.</p>
<p>catch 블록과 finally 블록은 선택적인 옵션으로 반드시 사용할 필요는 없습니다. 따라서 사용할 수 있는 모든 적합한 try 구문은 다음과 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">try</span> / <span class="keyword">catch</span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">try</span> / <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">try</span> / <span class="keyword">catch</span> / ... / <span class="keyword">finally</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>다른 제어문과 달리 예외 처리문은 중괄호를 생략할 수 없습니다.</p>
</blockquote>
<h2 id="예외처리-메커니즘">예외처리 메커니즘</h2>
<p>자바에서 예외 처리는 아래의 그림과 순서로 진행됩니다.</p>
<ol>
<li>try 블록에 도달한 프로그램의 제어는 try 블록 내의 코드를 실행합니다.<br>
이 때 만약 예외가 발생(throw)하지 않고, finally 블록이 존재하면 프로그램의 제어는 바로 finally 블록으로 이동합니다.</li>
<li>try 블로에서 예외가 발생하면 catch 구문으로 <strong>Jump</strong>하게 되고, catch 핸들러는 다음과 같은 순서로 적절한 catch 블록을 찾게 됩니다.
<ul>
<li>스택에서 try 블록과 가장 가까운 catch 블록부터 차례대로 검사합니다.</li>
<li>만약 적절한 catch 블록을 찾지 못하면, 바로 다음 바깥쪽 try 블록 다음에 위치한 catch 블록을 차례대로 검사합니다.</li>
<li>이러한 과정을 가장 바깥쪽의 try 블록까지 계속 검사하게 됩니다.</li>
<li>그래도 적절한 catch 블록을 찾지 못하면, 예외는 처리되지 못합니다.</li>
</ul>
</li>
<li>만약 적절한 catch 블록을 찾게 되면, throw 문의 피연산자는 예외 객체의 형식 매개변수로 전달됩니다.</li>
<li>모든 예외 처리가 끝나면 프로그램의 제어는 finally 블록으로 이동합니다.(finally 블록이 있다면)</li>
<li>finally 블록이 모두 처리되면, 프로그램의 제어는 예외 처리문 바로 다음으로 이동합니다.</li>
</ol>
<img src="/img/try_catch.png" width="500" height="200">
<p>만약 1번 try 블록에서 예외가 발생하지 않고, 바깥쪽 try 블록에서도 예외가 발생하지 않으면, 6번 finally 블록이 바로 실행될 것입니다.</p>
<p>하지만, 1번 try 블록에서 예외가 발생하면 2번과 3번 catch 블록에서 해당 예외를 처리할 수 있는지 검사하게 됩니다. 만약 적절한 catch 블록을 처리하지 못하면, 바깥쪽 4,5번 catch 블록도 차례대로 검사하게 됩니다.<br>
이 때 해당 예외를 처리할 수 있는 catch 블록을 찾게 되면, 해당 catch 블록을 실행한 후 6번의 finally 블록을 실행합니다. 하지만 모든 catch 블록이 해당 예외를 처리할 수 없으면, 예외는 처리되지 못한채 해당 프로그램을 강제 종료될 것입니다.</p>
<h1 id="exception-클래스">Exception 클래스</h1>
<hr>
<p>자바에서 모든 예외의 조상 클래스가 되는 Exception 클래스는 크게 다음과 같이 구분할 수 있습니다.</p>
<ol>
<li>RuntimeException 클래스</li>
<li>그 외의 Exception 클래스의 자식 클래스</li>
</ol>
<img src="/img/exception.png" width="500" height="200">
<p>RuntimeException 클래스를 상속받는 자식 클래스들은 주로 치명적인 예외 상황을 발생시키지 않는 예외들로 구성됩니다. 따라서 try / catch 문을 사용하기보다는 프로그램을 작성하면서 예외가 발생하지 않도록 주의를 기울이는 편이 좋습니다.</p>
<p>하지만 그 외의 Exception 클래스에 속하는 자식 클래스들은 치명적인 예외 상황을 발생시키므로, 반드시 try / catch문을 사용하여 예외를 처리해야만 합니다. 따라서 자바 컴파일러는 RuntimeException 클래스 이외의 Exception 클래스의 자식 클래스에 속하는 예외가 발생할 가능성이 있는 구문에는 반드시 예외를 처리하도록 강제하고 있습니다. 만약 이러한 예외가 발생할 가능성이 있는 구문을 처리하지 않았을 때는 컴파일 시 오류를 발생시킵니다.</p>
<p>다음 예제는 PrintStream 클래스의 write() 메소드를 사용하여 byte 타입 배열의 모든 요소를 출력하는 예제입니다. 하지만 write() 메소드에서 발생할 수 있는 IOException에 대한 예외를 처리하지 않았으므로, 컴파일 시 오류가 발생합니다.</p>
<p>따라서 try / catch문을 사용하여 IOException에 대한 예외 처리까지 해주어야만 컴파일 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] list = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.write(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="예외-처리의-계층-관계">예외 처리의 계층 관계</h2>
<p>자바에서는 예외가 발생하면, try 블록과 가장 가까운 catch 블록부터 순서대로 검사합니다. 따라서 여러 개의 catch 블록을 사용할 때는 Exception 클래스의 계층 관계에도 주의를 기울여야만 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.write(list);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 IOException이 발생하면, 자바는 첫 번째 catch 블록부터 순서대로 해당 예외를 처리할 수 있는지를 검사합니다. 그런데 IOException은 Exception 클래스의 자식 클래스이므로, 첫 번째 catch 블록에서도 IOException을 처리할 수 있습니다.<br>
따라서 IOException을 비롯한 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면, 언제나 첫 번째 catch 블록에서만 처리될 것입니다.<br>
즉, catch 블록의 순서를 위의 코드처럼 작성하면, 두 번째 catch 블록은 영원히 실행되지 않을 것입니다.</p>
<p>따라서, IOException만을 따로 처리하고자 한다면, 다음과 같이 catch 블록의 순서를 변경해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.write(list);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 변경하면 IOException이 발생하면, 첫 번째 catch 블록에서 해당 예외를 처리할 것입니다. 또한, IOException 이외의 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면 두 번째 catch 블록에서 처리될 것입니다. 이처럼 범위가 더 좁은 예외를 처리하는 catch 블록을 먼저 명시하고, 범위가 더 넓은 예외를 처리하는 catch 블록은 나중에 명시해야만 정상적으로 해당 예외를 처리할 수 있습니다.</p>
<h2 id="여러-예외-타입의-동시-처리">여러 예외 타입의 동시 처리</h2>
<p><strong>Java SE 7 부터는 ‘|’ 기호를 사용하여 하나의 catch 블록에서 여러 타입의 예외를 동시에 처리할 수 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.db.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 일반적으로 작성하던 catch 블록을 아래와 같이 동시에 처리할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.db.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만, 둘 이상의 예외 타입을 동시에 처리하는 catch 블록에서 매개변수로 전달받은 예외 객체는 묵시적으로 final 제어자를 가지게 됩니다. 따라서 catch 블록 내에서 해당 매개변수에는 어떠한 값도 대입할 수 없습니다.(상수화가 되었기 때문)</p>
<h2 id="throwable-클래스">Throwable 클래스</h2>
<p>자바에서 Throwable 클래스는 모든 예외의 조상이 되는 Exception 클래스와 모든 오류의 조상이 되는 Error 클래스의 부모 클래스입니다. Throwable 타입과 이 클래스를 상속받은 서브 타입만이 자바 가상 머신(JVM)이나 throw 키워드에 의해 던져질 수 있습니다.</p>
<p>이 클래스에는 예외나 오류에 관한 다양한 정보를 확인할 수 있는 다음과 같은 메소드가 포함되어 있습니다.</p>
<ul>
<li>String getMessage() : 해당 throwable 객체에 대한 자세한 내용을 문자열로 반환함</li>
<li>vodi printStackTree() : 해당 throwable 객체와 표준 오류 스트림(standard error stream)에서 해당 객체의 스택 트레이스를 출력함</li>
<li>String toString() : 해당 throwable 객체에 대한 간략한 내용을 문자열로 반환함</li>
</ul>
<p>다음 예제는 일부로 숫자를 0으로 나눠서 ArithmeticException 오류를 발생시키는 예제입니다. 이렇게 발생한 오류에 대해서 Throwable 메소드를 사용하여 발생한 오류에 대한 정보를 출력합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">현재 발생한 예외의 정보 : / by zero</span><br></pre></td></tr></table></figure>
<h2 id="자주-사용되는-예외-클래스">자주 사용되는 예외 클래스</h2>
<p>자바에서 자주 사용되는 예외 클래스는 다음의 표와 같습니다.</p>
<img src="/img/exception_class.png" width="500" height="200">
<h1 id="예외-발생-및-회피">예외 발생 및 회피</h1>
<hr>
<p>자바에서는 throw 키워드를 사용하여 강제로 예외를 발생시킬 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception e = <span class="keyword">new</span> Exeption(<span class="string">"메시지"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h2 id="예외-회피하기">예외 회피하기</h2>
<p>예외 처리에 대한 부분에서 가장 헷갈리는 부분이 <strong>throw와 throws</strong>입니다.</p>
<ul>
<li><strong>throw</strong>
<ul>
<li>예외를 발생시키는 것이고, 예외를 던지는 것입니다.</li>
<li>메소드 내에서 상위 블록으로 예외를 던지는 것</li>
<li>억지로 에러를 발생시킬 때도 사용되지만 현재 메소드의 에러를 처리한 후에 상위 메소드에 에러 정보를 줌으로써 상위 메소드에서도 에러가 발생한 것을 감지할 수 있습니다.</li>
<li>실제로 exception을 throw할 때 사용하는 키워드</li>
<li><strong>throw는 강제로 예외를 발생시키는 것</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlingException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"호출된 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handlingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main() 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">호출된 메소드에서 예외가 처리됨!</span><br></pre></td></tr></table></figure>
<p>Main 함수에서 handlingException() 함수를 호출하고 그 함수 안에서는 <strong>throw</strong> 키워드를 사용하여 예외를 발생시키고 있습니다. 이 예외를 발생시키는 문장을 try / catch로 감싸고 있기 때문에 발생한 예외는 catch 블록으로 <strong>Jump</strong>하게 되고 함수 내에서 예외를 처리하게 됩니다.</p>
<ul>
<li><strong>throws</strong>
<ul>
<li>메소드나 생성자를 수행할 때 발생하는 Exception을 선언할 때 사용하는 키워드</li>
<li>예외를 던지는 것</li>
<li>현재 메소드에서 상위 메소드로 예외를 던집니다.</li>
<li>다시 말해, <strong>에외를 자신이 직접 처리하지 않고, 자신을 호출한 메소드에세 책임을 전가하는 것입니다.</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlingException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handlingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main() 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main() 메소드에서 예외가 처리됨!</span><br></pre></td></tr></table></figure>
<p>위의 코드는 <strong>throws</strong>를 사용하여 handlingException() 함수에서 발생한 예외를 전가시키는 예제입니다. 메소드를 정의할 때 <strong>throws</strong> 키워드를 추가하여 이 메소드를 호출하는 곳에서 예외 처리를 하도록 전가시킬 수 있습니다.</p>
<p><strong>handlingException() throws Exception</strong> 라는 문장을 해석해보자면, handlingException()라는 함수가 Exception 예외를 던진다는 뜻이므로 handlingException() 함수를 사용하는 곳(혹은 호출하는 곳)으로 예외를 던집니다.</p>
<p>여기서는 Main 함수에서 handlingException() 함수를 호출하였고 handlingException() 함수는 이 함수를 호출한 곳으로 예외를 던지기 때문에 Main 함수에서 예외를 처리해주어야 합니다. 하지만, 예외가 발생할 수 있기 때문에 앞에서 배운 에외 처리를 통해서 함수를 호출하는 문장을 try 블록으로 감싸줍니다. 그러면 여기서 예외가 발생하면 아래의 catch 블록으로 빠지게 되고, 결국에는 Main 함수에서 예외를 처리하게 됩니다.</p>
<h2 id="사용자-정의-예외-클래스">사용자 정의 예외 클래스</h2>
<p>자바에서는 Exception 클래스를 상속받아 자신만의 새로운 예외 클래스를 정의하여 사용할 수 있습니다.<br>
사용자 정의 예외 클래스에는 생성자뿐 아니라 필드 및 메소드도 원하는 만큼 추가할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    MyException(String errMsg)&#123;</span><br><span class="line">        <span class="keyword">super</span>(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>요즘에는 위와 같이 Exception 클래스가 아닌 예외 처리를 강제하지 않는 RuntimeException 클래스를 상속받아 작성하는 경우가 많습니다.</p>
<h2 id="try-with-resources문">try-with-resources문</h2>
<p>Java SE 7 부터는 사용자 자원을 자동으로 해제해주는 try-with-resources 문을 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(파일을 열거나 자원을 할당하는 명령문)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 try 블록에 괄호 () 를 추가하여 파일을 열거나 자원을 할당하늠 명령문을 명시하면, 해당 try 블록이 끝나자마자 자동으로 파일을 닫거나 할당된 자원을 해제해줍니다.</p>
<p>다음은 파일에서 문자열을 한 줄 읽어오는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">            br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 Java SE 7 이전에서는 finally 블록을 사용하여 사용한 파일을 닫아줘야 했습니다. 하지만 try-with-resources 문을 사용하면 다음과 같이 자동으로 파일의 닫기를 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/02/java-basic-14/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/27/java-basic-13/"
                            aria-label=": [Java] 13. 제네릭"
                        >
                            [Java] 13. 제네릭
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-27T09:51:07+09:00">
	
		    Aug 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="제네릭generic">제네릭(Generic)</h1>
<hr>
<p>자바에서 제네릭(Generic)이란 데이터의 타입(data type)을 일반화(generalize)한다는 것을 의미합니다. <strong>제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다.</strong> 이렇게 컴파일 시에 미리 타입 검사(type check)를 수행하면 다음과 같은 장점을 가집니다.</p>
<ol>
<li>클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다.</li>
<li>반환값에 대한 타입 변환 및 검사에 들어가는 노력을 줄일 수 있습니다.</li>
</ol>
<p>JDK 1.5 이전에서는 여러 타입을 사용하는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object 타입을 사용했습니다. 하지만 이 경우에는 반환된 Object 객체를 다시 원하는 타입으로 타입 변환해야 하며, 이 때 오류가 발생할 가능성도 존재합니다.<br>
하지만, JDK 1.5부터 도입된 제네릭을 사용하면 컴파일 시에 미리 타입이 정해지므로, 타입 검사나 타입 변환과 같은 번거로운 작업을 생략할 수 있게 됩니다.</p>
<h1 id="제네릭의-선언-및-생성">제네릭의 선언 및 생성</h1>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;Integer&gt;();</span><br><span class="line">Person&lt;String&gt; person2 = <span class="keyword">new</span> Person&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>T</strong>를 타입 변수(type variable)이라고 하며, 임의의 참조형 타입을 의미합니다. 꼭 T뿐만 아니라 어떠한 문자를 사용해도 상관없으며, 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있습니다. 위의 코드처럼 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로도 사용할 수 있습니다.</p>
<p>T를 인스턴스화할 때, 꺽쇠 안에 있는 <strong>데이터 타입</strong>이 적용됩니다.</p>
<p>제네릭을 이용하여 클래스를 하나 정의하게 되면 클래스에서 정의한 변수에 대해 <strong>다양한 데이터 타입으로 인스턴스를 생성할 수 있습니다.</strong> 즉, 사용자 데이터 타입인 것입니다.</p>
<p>제네릭이 없는 상황의 코드에서는 코드의 중복이 발생할 수 있는데, 이 때 구현이 비슷한 두 클래스를 하나로 합칠 수가 있습니다. 변수의 데이터 타입을 지정하는 것은 그변수에 그 형식의 데이터 타입만 올 것이라는 것을 보장받을 수 있습니다. 그런데 Object로 처리를 하게 되면 어떠한 데이터도 들어올 수가 있습니다. 이것을 타입이 안전하지 않다라고 합니다.</p>
<blockquote>
<p>Javascript, Ruby on Rails 등에서는 타입 안전성에 대해서 free 합니다. 이런 언어를 typeless language라고 합니다.</p>
</blockquote>
<p>또한, <strong>제네릭으로는 참조형 데이터 타입만 올 수 있습니다.</strong> 기본 데이터 타입은 올 수 없습니다.(ex. int, char, double …) 하지만, <code>Wrapper class</code>를 사용해서 기본 데이터 타입을 객체처럼 만들어서 사용할 수 있습니다. 그런 클래스를 Wrapper class라고 합니다.</p>
<p>또한, Java SE 7부터 인스턴스 생성 시 타입을 추정할 수 있는 경우에는 다음과 같이 타입을 생략할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnimalList&lt;LandAnimal&gt; animalAnimalList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> LandAnimal());</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> cat());</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> dog());</span><br><span class="line">        <span class="comment">//animalAnimalList.add(new Sparrow()); 오류 발생</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;animalAnimalList.size();i++)&#123;</span><br><span class="line">           animalAnimalList.get(i).crying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        al.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.remove(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">육지 동물</span><br><span class="line">냐옹냐옹</span><br><span class="line">멍멍~~</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 cat과 dog 클래스는 LandAnimal 클래스를 상속받는 자식 클래스이므로, AnimalList<landanimal>에 추가할 수 있습니다. 하지만 Sparrow 클래스는 타입이 다르므로 추가할 수 없습니다.</landanimal></p>
<h1 id="제네릭의-제거-시기">제네릭의 제거 시기</h1>
<hr>
<p>자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환됩니다. 그리고서 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 됩니다. 이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서입니다.</p>
<h1 id="타입-변수의-제한">타입 변수의 제한</h1>
<hr>
<p>제네릭은 <strong>T</strong>와 같은 타입 변수(type variable)를 사용하여 타입을 제한합니다. 이 때, <code>extends</code> 키워드를 사용하면 타입 변수에 특정 타입만을 사용하도록 제한할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">예시</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WarmBlood</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">WarmBlood</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> &amp; <span class="title">WramBlood</span>&gt;</span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// implements 키워드를 사용해서는 안됨</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 클래스의 타입 변수에 제한을 걸어 놓으면 클래스 내부에서 사용된 모든 타입 변수에 제한이 걸립니다. 이 때에는 클래스가 아닌 인터페이스를 구현할 경우에도 implements 키워드가 아닌 extends 키워드를 사용해야만 합니다.</p>
<p>또한 클래스와 인터페이스를 동시에 상속받고 구현해야 한다면 마지막 코드처럼 <code>&amp;</code>기호를 사용하면 됩니다. 이 기호는 앰퍼센트라고 읽습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalList&lt;LandAnimal&gt; animalList1 = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 1</span></span><br><span class="line">        AnimalList&lt;cat&gt; animalList2 = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 2</span></span><br><span class="line">        AnimalList&lt;dog&gt; animalList = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// AnimalList&lt;Sparrow&gt; animalList3 = new AnimalList&lt;Sparrow&gt;(); 4</span></span><br><span class="line"></span><br><span class="line">        animalList1.add(<span class="keyword">new</span> LandAnimal());</span><br><span class="line">        animalList1.add(<span class="keyword">new</span> cat());</span><br><span class="line">        animalList1.add(<span class="keyword">new</span> dog());</span><br><span class="line">        <span class="comment">//animalAnimalList.add(new Sparrow());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;animalList1.size();i++)&#123;</span><br><span class="line">            animalList1.get(i).crying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span>&gt; </span>&#123;</span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        al.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.remove(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 타입 제한을 ’ AnimalList<t extends="" landanimal=""> ’ 걸게 되면 타입 변수에는 1번 처럼 LandAnimal 타입만 사용할 수 있도록 제한할 수 있습니다. 또한, 2,3번 처럼 LandAnimal을 상속한 자식 클래스까지도 사용할 수 있습니다. 하지만, 4번처럼 그 외의 클래스는 타입으로 사용할 수 없습니다.</t></p>
<p>만약 타입 변수를 제한하지 않는다면, 4번에서도 클래스를 정상적으로 사용할 수 있습니다.</p>
<h1 id="제네릭-메소드">제네릭 메소드</h1>
<hr>
<p>제네릭 메소드(generic method)란 메소드의 선언부에 타입 변수를 사용한 메소드를 의미합니다. 이 때 타입 변수의 선언은 메소드의 선언부에서 반환 타입 바로 앞에 위치합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>다음 코드에서 제네릭 클래스에서 정의된 타입 변수 T와 제네릭 메소드에서 사용된 타입 변수 T는 전혀 별개의 것임을 주의해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="와일드-카드의-사용">와일드 카드의 사용</h1>
<hr>
<p><code>와일드 카드(wild card)</code>란 이름에 제한을 두지 않음을 표현하는 데 사용되는 기호를 의미합니다. 자바의 제네릭에서는 물음표(?) 기호를 사용하여 이러한 와일드카드를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">문법</span><br><span class="line">&lt;?&gt; <span class="comment">// 타입 변수에 모든 타입을 사용할 수 있음</span></span><br><span class="line">&lt;? extends T&gt; <span class="comment">// T 타입과 T 타입을 상속받는 자식 클래스 타입만을 사용할 수 있음</span></span><br><span class="line">&lt;? <span class="keyword">super</span> T&gt; <span class="comment">// T 타입과 T 타입이 상속받은 조상 클래스 타입만을 사용할 수 있음</span></span><br></pre></td></tr></table></figure>
<p>다음은 클래스 메소드인 cryingAnimalList() 메소드의 매개변수의 타입을 와일드카드를 사용하여 제한하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalList&lt;cat&gt; catList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        catList.add(<span class="keyword">new</span> cat());</span><br><span class="line">        AnimalList&lt;dog&gt; dogList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        dogList.add(<span class="keyword">new</span> dog());</span><br><span class="line">        AnimalList&lt;Sparrow&gt; sparrowList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        AnimalList.cryingAnimalList(catList);</span><br><span class="line">        AnimalList.cryingAnimalList(dogList);</span><br><span class="line">        <span class="comment">//AnimalList.cryingAnimalList(sparrowList); 오류</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cryingAnimalList</span><span class="params">(AnimalList&lt;? extends LandAnimal&gt; al)</span> </span>&#123;</span><br><span class="line">        LandAnimal la = al.get(<span class="number">0</span>);</span><br><span class="line">        la.crying();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123; al.add(animal);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> al.get(index);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;<span class="keyword">return</span> al.remove(animal);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> al.size();&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">냐옹냐옹</span><br><span class="line">멍멍~~</span><br></pre></td></tr></table></figure>
<p>클래스 메소드인 cryingAniamlList() 메소드가 매개변수의 타입을 와일드카드를 사용하여 제한했습니다. 따라서 LandAnimal 타입과 그 타입을 상속받는 자식 클래스의 타입만 접근할 수 있기 때문에 4번은 오류가 발생하는 것입니다. 와일드카드를 사용한 타입 제한을 제거한다면 4번도 정상적으로 동작하게 됩니다.</p>
<h1 id="정리">정리</h1>
<hr>
<p>제네릭은 제한도 걸어놓을 수 있다고 합니다. 하지만, 지금은 이해가 가지 않네요… 조금 더 공부하다 보면 많은 내용을 알고 자료를 찾아가다 보면 이해가 되겠지요? ㅎㅎ</p>
<ul>
<li>상위 클래스를 만들어 준다. or 인터페이스를 만들어준다.</li>
<li>그리고 그 상위의 것에 extends 해준다. (상속과는 다르다)</li>
<li>just 부모가 누구냐만 밝혀주는 용도로 extends를 사용한다.</li>
<li>(인터페이스의 경우에도 extends를 사용한다. 따로 implements라는 표현을 사용하지 않는다.)</li>
<li>Tip &gt; super 부모를 제한하는 경우</li>
</ul>
<p>제네릭은 같은 기능을 하는 클래스를 여러 개 정의해야 한다는 불편함을 해소하면서 이것을 해소하기 위해 Object를 사용하게 되면 원하는 자료형에 대한 타입 변환을 해야 하고 또한, 안전성이 보장되지 않기 때문에 사용하는 것입니다.<br>
변수와 비슷한 개념인데도 값이 들어가는게 아니라 <strong>데이터 타입</strong>이 들어가는 것입니다.</p>
<blockquote>
<p>그렇다면 왜 제네릭을 알아야 하는가??</p>
</blockquote>
<p>앞으로 공부하게 될 컬렉션 프레임워크를 이애하기 위해 제네릭에 대한 이해가 필요합니다. <strong>Collection Framework</strong>에서 제네릭을 사용합니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/27/java-basic-13/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/21/java-basic-12/"
                            aria-label=": [Java] 12. API 클래스-2"
                        >
                            [Java] 12. API 클래스-2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-21T11:44:33+09:00">
	
		    Aug 21, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="wrapper-클래스">Wrapper 클래스</h1>
<hr>
<p>프로그램에 따라 기본 타입의 데이터를 <strong>객체</strong>로 취급해야 하는 경우가 있습니다. 예를 들어, 메소드의 인수로 객체 타입만이 요구된다면, 기본 타입의 데이터를 그대로 사용할 수는 없습니다. 이 때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 합니다.</p>
<p>이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 <code>래퍼 클래스(Wrapper class)</code>라고 합니다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공됩니다.</p>
<img src="/img/wrapper.png" width="500" height="200">
<blockquote>
<p>래퍼 클래스 중에서 Integer 클래스와 Character 클래스만이 자신의 기본 타입과 이름이 다름을 주의해야 합니다.</p>
</blockquote>
<h2 id="박싱과-언박싱">박싱과 언박싱</h2>
<p>래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있습니다.</p>
<img src="/img/boxing.png" width="500" height="200">
<p>위의 그림과 같이 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정을 <code>박싱(Boxing)</code>이라고 합니다. 반면 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정은 <code>언박싱(UnBoxing)</code>이라고 합니다.</p>
<h2 id="오토-박싱과-오토-언박싱">오토 박싱과 오토 언박싱</h2>
<p>JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해 줍니다. 이렇게 자동화된 박싱과 언박싱을 <code>오토 박싱(AutoBoxing)</code>과 <code>오토 언방식(AutonUnBoxing)</code>이라고 부릅니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 박싱</span></span><br><span class="line">        <span class="keyword">int</span> number1 = num1; <span class="comment">// 언박싱</span></span><br><span class="line">        System.out.println(number1);</span><br><span class="line"></span><br><span class="line">        Character ch = <span class="string">'X'</span>; <span class="comment">// Character ch = new Character('X'); :오토박싱</span></span><br><span class="line">        <span class="keyword">char</span> c = ch; <span class="comment">// char c = ch.charValue();         :오토 언박싱</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<p>위 예제에서 볼 수 있듯이 래퍼 클래스인 Integer 클래스와 Character 클래스에는 각각 언박싱을 위한 intValue() 메소드와 charValue() 메소드가 포함되어 있습니다.</p>
<p>또한, 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 Character 인스턴스를 생성할 수 있습니다.<br>
반대로 charValue() 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">7</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num2 = <span class="keyword">new</span> Integer(<span class="number">3</span>); <span class="comment">// 박싱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> int1 = num1.intValue();    <span class="comment">// 언박싱</span></span><br><span class="line">        <span class="keyword">int</span> int2 = num2.intValue();    <span class="comment">// 언박싱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer result1 = num1 + num2; <span class="comment">// 1번 : 10</span></span><br><span class="line">        Integer result2 = int1 - int2; <span class="comment">// 2번 : 4</span></span><br><span class="line">        <span class="keyword">int</span> result3 = num1 * int2;     <span class="comment">// 3번 : 21</span></span><br><span class="line"></span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>1번 : Integer 객체로 박싱된 객체들을 더하는 연산을 진행하고 있습니다. 하지만, 래퍼 클래스 타입의 객체들은 산술을 위해 정의된 클래스가 아니라고 했습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값을 참조할 수 있습니다. 따라서 산술 연산을 위해서 자바 컴파일러에 의해서 <strong>오토 언박싱</strong>되고, 산술 연산을 수행한 후의 결과 값인 10을 다시 <strong>오토 박싱</strong>하여 result1에 결과를 담게 됩니다.</p>
<p>2번 : 이미 언박싱 과정을 통해서 산술 연산이 가능해졌습니다. 따라서 두 값의 산술 연산을 진행한 후의 결과 값인 4를 <strong>오토 박싱</strong>하여 result2에 결과를 담게 됩니다.</p>
<p>3번 : 래퍼 클래스 타입의 객체와 기본형 타입인 int형 변수의 산술 연산입니다. 이를 위해서는 num1이 자동으로 오토 언박싱 되어서 산술 연산을 할 수 있도록 변환됩니다. 그리고 나서 산술 연산을 진행하고, 결과 값을 int형 변수인 result3에 담게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num2 = <span class="keyword">new</span> Integer(<span class="number">20</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(num1&lt;num2); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(num1 == num3); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(num1.equals(num3)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n1 = num1;</span><br><span class="line">        <span class="keyword">int</span> n3 = num3;</span><br><span class="line">        System.out.println(n1 == n3); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>래퍼 클래스의 비교 연산도 오토 언박싱을 통해 가능하지만, 인스턴스에 저장된 값의 동등 여부 판단은 1번 라인처럼 비교 연산자인 <strong>동등 연산자</strong>( == )를 사용해서는 안되며, 2번 라인처럼 <strong>equals</strong>() 메소드를 사용해야만 합니다.</p>
<p>래퍼 클래스도 객체이므로 동등 연산자(==)를 사용하게 되면, 두 인스턴스의 값을 비교하는 것이 아니라 <strong>두 인스턴스의 주소값을 비교하게 됩니다.</strong> 따라서 서로 다른 두 인스턴스를 동등 연산자로 비교하게 되면, 언제나 false 값을 반환하게 됩니다.<br>
<strong>그러므로 인스턴스에 저장된 값의 동등 여부를 정확히 판단하려면 equals() 메소드를 사용해야만 합니다.</strong></p>
<p>num1과 num2에 들어있는 래퍼 클래스 타입의 객체 즉, 인스턴스는 서로 다른 주소값을 가지고 있지만 그 주소에 들어있는 값은 동일합니다. 이를 int형 변수인 n1과 n2에 각각 오토 언박싱을 하고 동등 연산자를 통해 비교해보면 true 값을 반환하는 것을 확인할 수 있습니다.<br>
이유는 인스턴스를 오토 언박싱을 통해서 기본 타입으로 변환했기 때문에 동등 연산자를 통해 비교해보면 같은 값임을 확인할 수 있습니다.</p>
<h1 id="enum-클래스">Enum 클래스</h1>
<hr>
<p>C언어와 C++에서는 열거체를 사용할 수 있지만, JDK 1.5 이전의 자바에서는 열거체를 사용할 수 없었습니다. 하지만,JDK 1.5부터는 C언어의 열거체보다 더욱 향상된 성능의 열거체를 정의한 Enum 클래스를 사용할 수 있습니다.</p>
<p>이와 같은 자바의 열거체는 다음과 같은 장점을 가집니다.</p>
<ol>
<li>열거체를 비교할 때 실제 값 뿐만 아니라 타입까지도 체크합니다.</li>
<li>열거체의 상숫값이 재정의되더라도 다시 컴파일할 필요가 없습니다.</li>
</ol>
<h2 id="열거체의-정의-및-사용">열거체의 정의 및 사용</h2>
<p>자바에서는 enum 키워드를 사용하여 열거체를 정의할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 열거체이름&#123; 상수<span class="number">1</span>이름, 상수<span class="number">2</span>이름 ...&#125;</span><br><span class="line"><span class="keyword">enum</span> Rainbow&#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용 방법</span></span><br><span class="line">열거체이름.상수이름</span><br><span class="line">Rainbow.RED</span><br></pre></td></tr></table></figure>
<h2 id="열거체의-상숫값-정의-및-추가">열거체의 상숫값 정의 및 추가</h2>
<p>위와 같이 정의된 열거체의 첫 번째 상숫값은 0부터 설정되며, 그 다음은 바로 앞의 상숫값보다 1만큼 증가되며 설정됩니다.</p>
<p>또한, 불규칙한 값을 상숫값으로 설정하고 싶으면 상수의 이름 옆에 괄호 (())을 추가하고, 그 안에 원하는 상숫값을 명시할 수 있습니다. 하지만, 이 때에는 불규칙한 특정 값을 저장할 수 있는 인스턴스 변ㅅ와 생성자를 다음과 같이 추가해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"상수값 : "</span>+Rainbow.RED.getValue()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">"상수값 : "</span>+Rainbow2.RED.ordinal()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow &#123;</span><br><span class="line">        RED(<span class="number">3</span>), ORANGE(<span class="number">10</span>), YELLOW(<span class="number">11</span>), GREEN(<span class="number">23</span>), BLUE(<span class="number">4</span>), INDIGO(<span class="number">5</span>), VIOLET(<span class="number">17</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        Rainbow(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Type&#123;</span><br><span class="line">        WALKING, RUNNING, HIKING</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">상수값 : <span class="number">3</span></span><br><span class="line">상수값 : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>1을 보면 불규칙한 상숫값을 설정하고 이 불규칙한 특정 값을 저장할 수 있는 인스턴스 변수와 생성자를 추가함으로써 상수값에 접근할 수 있습니다. 또한 2번에서는 상수값을 지정하지 않으면 첫 번째 상수값은 0부터 설정되어 순서대로 설정되므로 이 값에 접근하기 위해서는 <code>ordinal()</code> 메소드를 통해 접근할 수 있습니다.</p>
<h2 id="javalangenum-클래스">java.lang.Enum 클래스</h2>
<p>Enum 클래스는 모든 자바 열거체의 공통된 조상 클래스입니다. Enum 클래스에는 열거체를 조작하기 위한 다양한 메소드가 포함되어 있습니다.</p>
<h2 id="values-메소드">values() 메소드</h2>
<p><code>values()</code> 메소드는 해당 열거체의 모든 상수를 저장한 배열을 생성하여 반환합니다. 이 메소드는 자바의 모든 열거체에 컴파일러가 자동으로 추가해 주는 메소드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rainbow2[] arr = Rainbow2.values();</span><br><span class="line">        <span class="keyword">for</span> (Rainbow2 rb : arr) &#123;</span><br><span class="line">            System.out.println(rb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow2 &#123;</span><br><span class="line">        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RED</span><br><span class="line">ORANGE</span><br><span class="line">YELLOW</span><br><span class="line">GREEN</span><br><span class="line">BLUE</span><br><span class="line">INDIGO</span><br></pre></td></tr></table></figure>
<h2 id="valueof-메소드">valueOf() 메소드</h2>
<p><code>valueOf()</code> 메소드는 전달된 문자열과 일치하는 해당 열거체의 상수를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Rainbow2.valueOf(<span class="string">"RED"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow2 &#123;</span><br><span class="line">        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RED</span><br></pre></td></tr></table></figure>
<h2 id="ordinal-메소드">ordinal() 메소드</h2>
<p><code>ordinal()</code> 메소드는 해당 열거체 상수가 열거체 정의에서 <strong>정의된 순서</strong> (0부터 시작)를 반환합니다. 이 때, 반환되는 값은 열거체 정의에서 해당 열거체 상수가 정의된 순서이며, 상수값 자체가 아님을 명심해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Rainbow &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Rainbow.YELLOW.ordinal();</span><br><span class="line">        System.out.println(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>다음 예제는 불규칙적인 상수값을 가지는 열거체에서 <code>ordinal()</code>메소드를 사용한 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Rainbow.YELLOW.ordinal());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Rainbow &#123;</span><br><span class="line">        RED(<span class="number">3</span>), ORANGE(<span class="number">10</span>), YELLOW(<span class="number">11</span>), GREEN(<span class="number">23</span>), BLUE(<span class="number">4</span>), INDIGO(<span class="number">5</span>), VIOLET(<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        Rainbow(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="대표적인-enum-메소드">대표적인 Enum 메소드</h2>
<img src="/img/enum.png" width="700" height="200">
<h1 id="arrays-클래스">Arrays 클래스</h1>
<hr>
<p>Arrays 클래스를 다루기 전에 먼저 살펴보아야 할 것은 java.util 패키지입니다.<br>
java.util 패키지에는 프로그램을 개발하는 데 사용할 수 있는 유용한 유틸리티 클래스가 다수 포함되어 있습니다. 실제로 java.lang 패키지 다음으로 가장 많이 사용되는 패키지가 java.util 패키지입니다. 하지만, import문을 사용하지 않아도 바로 사용할 수 있는 java.lang 패키지와는 달리 java.util 패키지는 import문으로 패키지를 불러오고 나서야 클래스 이름만으로 사용할 수 있습니다.</p>
<h2 id="javautilarrays-클래스">java.util.Arrays 클래스</h2>
<p>Arrays 클래스에는 배열을 다루기 위한 다양한 메소드가 포함되어 있습니다. Arrays 클래스의 모든 메소드는 <strong>클래스 메소드</strong> (static method)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이 클래스는 반드시 import문으로 java.util 패키지를 불러오고 나서 사용해야 합니다.</p>
<h2 id="binarysearch-메소드">binarySearch() 메소드</h2>
<p><code>binarySearch()</code> 메소드는 전달받은 배열에서 <strong>특정 객체의 위치를 이진 검색 알고리즘을 사용하여 검색한 후, 해당 위치를 반환합니다.</strong><br>
이 메소드는 이진 검색 알고리즘을 사용하므로, 매개변수로 전달되는 배열이 sort() 메소드 등을 사용하여 <strong>미리 정렬되어 있어야만 제대로 동작합니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, <span class="number">437</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">437</span></span><br></pre></td></tr></table></figure>
<h2 id="copyof-메소드">copyOf() 메소드</h2>
<p><code>copyOf()</code> 메소드는 전달받은 배열의 특정 길이만큼을 새로운 배열로 복사하여 반환합니다.</p>
<p>copyOf() 메소드는 첫 번째 매개변수로 원본 배열을 전달받고, 두 번째 매개변수로 원본 배열에서 새로운 배열로 복사할 요소의 개수를 전달받습니다. 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다.</p>
<p>이 때, 새로운 배열의 길이가 원본 배열보다 길면, 나머지 요소는 배열 요소의 타입에 맞게 기본값으로 채워지게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr1, <span class="number">3</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = Arrays.copyOf(arr1, <span class="number">10</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : arr3) &#123;</span><br><span class="line">            System.out.print(j + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>1번에서는 copyOf() 메소드를 사용하여 배열 arr1의 첫 번째 배열 요소부터 3개의 요소를 복사하여 배열 arr2에 대입하고 있습니다.<br>
2번에서는 배열 arr1에서 10개의 배열 요소를 복사하여 배열 arr3에 대입하려고 합니다. 하지만, 배열 arr1의 길이가 5밖에 되지 않으므로, 배열 arr3의 나머지 배열 요소에는 int형의 기본 값인 0이 채워지게 됩니다.</p>
<h2 id="copyofrange-메소드">copyOfRange() 메소드</h2>
<p><code>copyOfRange()</code> 메소드는 전달받은 배열의 특정 범위에 해당하는 요소만을 새로운 배열로 복사하여 반환합니다.</p>
<p>copyOfRange() 메소드는 첫 번째 매개변수로 복사의 대상이 될 원본 배열을 전달받습니다. 두 번째 매개변수로 원본 배열에서 복사할 시작 인덱스를 전달받고, 세 번째 매개변수로는 마지막으로 복사될 배열 요소의 다음 인덱스를 전달받습니다. <strong>즉, 세 번째 매개변수로 전달된 인덱스 바로 전까지의 배열 요소까지만 복사됩니다.</strong> 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOfRange(arr1, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"아래는 원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : arr1) &#123;</span><br><span class="line">            System.out.print(j + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">아래는 원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 배열이 복사되는 것을 확인할 수 있고, <strong>원본 배열이 변경되는 것이 아니라 원본 배열을 가지고 새로운 배열을 복사하는 것이기 때문에 원본 배열은 변경되지 않습니다.</strong></p>
<h2 id="fill-메소드">fill() 메소드</h2>
<p><code>fill()</code> 메소드는 전달받은 배열의 모든 요소를 특정 값으로 초기화해줍니다.</p>
<p>fill() 메소드는 첫 번째 매개변수로 초기화할 배열을 전달 받고, 두 번째 매개변수로 초기값을 전달받습니다. <strong>따라서 이 메소드는 전달받은 원본 배열의 값을 변경하게 됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"fill() 메소드 사용 후 원본 배열"</span>);</span><br><span class="line">        Arrays.fill(arr1, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">fill() 메소드 사용 후 원본 배열</span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="sort-메소드">sort() 메소드</h2>
<p><code>sort()</code> 메소드는 전달받은 배열의 모든 요소를 <strong>오름차순으로 정렬합니다.</strong></p>
<p>sort() 메소드는 매개변수로 정렬한 배열을 전달받으며, 따라서 이 메소드는 <strong>전달받은 원본 배열의 순서를 변경하게 됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"sort() 메소드 사용 후 원본 배열"</span>);</span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 배열</span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> </span><br><span class="line">sort() 메소드 사용 후 원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="대표적인-arrays-메소드">대표적인 Arrays 메소드</h2>
<p>Arrays 클래스의 메소드는 매우 다양하며, 그 중에서 많이 사용되는 메소드는 다음과 같습니다.</p>
<img src="/img/arrays.png" width="700" height="200">
<h1 id="calendar-클래스">Calendar 클래스</h1>
<hr>
<h2 id="자바에서의-날짜-및-시간-처리">자바에서의 날짜 및 시간 처리</h2>
<p>JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 간단한 처리만을 수행할 수 있었습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(deprecated) 있습니다.</p>
<p>JDk 1.1부터는 새롭게 제공되는 <strong>Calendar</strong> 클래스를 이용하여 날짜와 시간에 관한 처리를 수행하게 됩니다. 하지만 이러한 Calendar 클래스는 다음과 같은 문제점을 안고 있습니다.</p>
<ol>
<li>Calendar 인스턴스는 불변 객체가 아니라서 값이 수정될 수 있습니다.</li>
<li>윤초(leap second)와 같은 특별한 상황을 고려하지 않았습니다.</li>
<li>Calendar 클래스에서는 월(month)을 나타낼 때, 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.</li>
</ol>
<p>따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 <code>Joda-Time</code>이라는 라이브러를 함께 사용해왔습니다.</p>
<p>Java SE 8 버전에서는 이러한 Joda-Time 라이브러리르 발전시킨 새로운 날짜와 시간 API인 <code>java.time</code> 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 패키지를 포함하고 있습니다.</p>
<p>더 자세한 내용을 추후에 공부하겠습니다. :D</p>
<h2 id="javautilcalendar-클래스">java.util.Calendar 클래스</h2>
<p>Calendar 클래스는 자바에서 날짜와 시간에 관한 데이터를 손쉽게 처리할 수 있도록 제공하는 추상 클래스입니다. 이 클래스가 추상 클래스로 선언된 이유는 나라마다 사용하는 달력 체계가 조금씩 다를 수 있기 때문입니다.</p>
<p>이러한 Calendar 클래스에는 날짜와 시간을 처리하기 위한 다양한 필드와 메소드가 포함되어 있습니다. Calendar 클래스의 모든 필드는 클래스 변수(static variable)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다.</p>
<h2 id="javautilgregoriancalendar-클래스">java.util.GregorianCalendar 클래스</h2>
<p>현재 전 세계적으로 가장 많이 사용되는 달력은 1582년 교황 그레고리오 13세가 개혁한 그레고리오 달력입니다. Calendar 클래스는 추상 클래스이므로, 직접 인스턴스를 생성할 수 없습니다. GregorianCalendar 클래스는 이러한 Calendar 클래스를 상속받아 그레고리오 달력을 완전히 구현한 하위 클래스입니다.</p>
<h2 id="add-메소드">add() 메소드</h2>
<p><code>add()</code> 메소드는 전달된 Calendar 필드에서 일정 시간 만큼을 더하거나 빼줍니다. 즉, 특정 시간을 기준으로 일정 시간 전후의 날짜와 시간을 알 수 있습니다.</p>
<p>아래는 현재 시각에 1시간을 더하는 예제입니다.:)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time = Calendar.getInstance();</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line"></span><br><span class="line">        time.add(Calendar.HOUR, <span class="number">1</span>);</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">43</span> KST <span class="number">2018</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">13</span>:<span class="number">32</span>:<span class="number">43</span> KST <span class="number">2018</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Calendar 클래스에 메소드는 현재 시각을 기준으로 동작하기 때문에, 이 예제를 보고 따라하신다면 다른 결과값을 얻을 수 있습니다.</p>
</blockquote>
<h2 id="before와-after-메소드">before()와 after() 메소드</h2>
<p>두 시간상의 전후 관계만을 알고 싶을 경우에는 before()와 after() 메소드를 사용할 수 있습니다. <code>before()</code> 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 앞서는지를 판단하고, 결과를 true/false로 반환합니다. 반대로 <code>after()</code> 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 나중인지를 판단하고, 결과를 true/false로 판단합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time1 = Calendar.getInstance();</span><br><span class="line">        Calendar time2 = Calendar.getInstance();</span><br><span class="line">        Calendar time3 = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        time2.set(<span class="number">1994</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        time3.set(<span class="number">2020</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        System.out.println(time1.before(time2));</span><br><span class="line">        System.out.println(time1.before(time3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h2 id="get-메소드">get() 메소드</h2>
<p><code>get()</code> 메소드는 전달된 Calendar 필드에 저장된 값을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time = Calendar.getInstance();</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line"></span><br><span class="line">        System.out.println(time.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">        System.out.println(time.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(time.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(time.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        System.out.println(time.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(time.get(Calendar.SECOND));</span><br><span class="line">        System.out.println(time.get(Calendar.YEAR));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">12</span>:<span class="number">47</span>:<span class="number">34</span> KST <span class="number">2018</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<h2 id="roll-set-메소드">roll(), set() 메소드</h2>
<p><code>roll()</code> 메소드는 전달된 Calendar 필드에 일정 시간 만큼을 더하거나 빼줍니다. 하지만, add() 메소드와는 달리 다른 Calendar 필드에는 영향을 주지 않습니다. 즉, 계산 결과가 해당 필드의 최댓값이나 최솟값을 넘어가도 다른 필드에 영향을 주지 않습니다.</p>
<p><code>set()</code> 메소드는 전달된 Calendar 필드를 특정 값으로 설정합니다. 아래의 코드에서 add(), roll() , set() 메소드를 사용하는 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time1 = Calendar.getInstance();</span><br><span class="line">        Calendar time2 = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 같은 시간으로 설정</span></span><br><span class="line">        time1.set(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">50</span>);</span><br><span class="line">        time2.set(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        time1.add(Calendar.SECOND, <span class="number">15</span>);</span><br><span class="line">        time2.roll(Calendar.SECOND, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">"add() 메소드 호출 후 : "</span>+time1.getTime());</span><br><span class="line">        System.out.println(<span class="string">"roll() 메소드 호출 후 : "</span>+time2.getTime());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">add() 메소드 호출 후 : Wed Jul <span class="number">27</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">05</span> KST <span class="number">1994</span></span><br><span class="line">roll() 메소드 호출 후 : Wed Jul <span class="number">27</span> <span class="number">12</span>:<span class="number">34</span>:<span class="number">05</span> KST <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 add() 메소드를 사용하여 Calendar.SECOND를 15초 증가시키면 결과적으로 Calendar.MINUTE 필드가 1 증가하게 됩니다.<br>
하지만, roll() 메소드를 사용하여 Calendar.SECOND 필드를 15초 증가시키면 Calendar.MINUTE 필드에는 아무런 영향을 주지 않는 것을 확인할 수 있습니다.<br>
즉, Calendar.SECOND 필드만이 15초 증가하여 출력됩니다.</p>
<h2 id="대표적인-calendar-메소드">대표적인 Calendar 메소드</h2>
<img src="/img/calendar.png" width="700" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/21/java-basic-12/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/20/java-basic-11/"
                            aria-label=": [Java] 11. API 클래스-1"
                        >
                            [Java] 11. API 클래스-1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-20T10:14:45+09:00">
	
		    Aug 20, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="object-클래스">Object 클래스</h1>
<hr>
<p>java.lang 패키지 중에서도 가장 많이 사용되는 클래스는 바로 <strong>Object</strong> 클래스입니다. Object 클래스는 모든 자바 클래스의 최고 조상 클래스가 됩니다. 따라서 자바의 모든 클래스는 <strong>Object</strong> 클래스의 모든 메소드를 바로 사용할 수 있습니다.</p>
<h2 id="tostring메소드">toString()메소드</h2>
<p>toString() 메소드는 해당 인스턴스에 대한 정보를 <code>문자열</code>로 반환합니다. 이 때 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되며, 그 뒤로 16진수 해시 코드가 추가됩니다.<br>
16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값으로, 인스턴스마다 모두 다르게 반환됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">System.out.println(car1.toString());</span><br><span class="line">System.out.println(car2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">com.company.Car@<span class="number">60e53</span>b93</span><br><span class="line">com.company.Car@<span class="number">5e2</span>de80c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>자바에서 toString() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다.</p>
</blockquote>
<h2 id="equals-메소드">equals() 메소드</h2>
<p>equals() 메소드는 해당 인스턴스를 매개변수로 전달받은 참조 변수와 비교하여, 그 결과를 반환합니다. 이 때, 참조 변수가 가리키는 값을 비교하므로, 서로 다른 두 객체는 언제나 false를 반환하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">System.out.println(car1.equals(car2));</span><br><span class="line">car1 = car2; <span class="comment">// 두 참조 변수가 같은 주소를 가리킴 </span></span><br><span class="line">System.out.println(car1.equals(car2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>자바에서 equals() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다.</p>
</blockquote>
<h2 id="clone-메소드">clone() 메소드</h2>
<p>clone() 메소드는 해당 인스턴스를 복제하여, 새로운 인스턴스를 반환합니다. 하지만 Object 클래스의 clone() 메소드는 단지 필드의 값만을 복사하므로, 필드의 값이 배열이나 인스턴스이면 제대로 복제할 수 없습니다.<br>
따라서 이러한 경우에는 해당 클래스에서 clone() 메소드를 오버라이딩하여, 복제가 제대로 이루어지도록 재정의해야 합니다.</p>
<p>이러한 clone() 메소드는 데이터의 보호를 이유로 <strong>Cloneable</strong> 인터페이스를 구현한 클래스의 인스턴스만이 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car01 = <span class="keyword">new</span> Car(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        car01.setModelName(<span class="string">"아반떼"</span>);</span><br><span class="line">        car01.setOwners(<span class="string">"홍길동"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Car01 : "</span> + car01.getModelName() + <span class="string">", "</span> + car01.getOwners() + <span class="string">"\n"</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Car car02 = (Car) car01.clone(); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">        car02.setOwners(<span class="string">"이순신"</span>); <span class="comment">// 8</span></span><br><span class="line">        System.out.println(<span class="string">"Car01 : "</span> + car01.getModelName() + <span class="string">", "</span> + car01.getOwners()); <span class="comment">// 9</span></span><br><span class="line">        System.out.println(<span class="string">"Car02 : "</span> + car02.getModelName() + <span class="string">", "</span> + car02.getOwners()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; owners = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelName;</span><br><span class="line">    &#125;                    <span class="comment">// modelName의 값을 반환함</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125; <span class="comment">// modelName의 값을 설정함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">getOwners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.owners;</span><br><span class="line">    &#125;                      <span class="comment">// owners의 값을 반환함</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOwners</span><span class="params">(String ownerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.owners.add(ownerName);</span><br><span class="line">    &#125;   <span class="comment">// owners의 값을 추가함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Car clonedCar = (Car) <span class="keyword">super</span>.clone(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// clonedCar.owners = (ArrayList)owners.clone(); 3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clonedCar;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException ex) &#123; <span class="comment">// 4</span></span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Car01 : 아반떼, [홍길동]</span><br><span class="line"></span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 2번에서는 부모 클래스의 <strong>clone()</strong> 메소드를 호출하여 clone() 메소드를 오버라이딩하고 있습니다. 5번에서는 Car 클래스의 인스턴스인 <strong>car01</strong>을 생성하고, 7번에서는 오버라이딩한 clone() 메소드를 호출하여 복제를 수행하고 있습니다.</p>
<p>하지만, 2번처럼 clone() 메소드를 재정의하면, 필드의 값이 1번처럼 인스턴스일 때는 제대로 된 복제를 수행할 수 없습니다.<br>
8번에서는 복제된 인스턴스인 <strong>car02</strong>의 owners 필드에 새로운 값을 하나 추가합니다. 하지만 9번의 실행 결과를 보면, 7번에서의 결과와는 달리 원본 인스턴스인 <strong>car01</strong>의 owners 필드에도 새로운 값이 추가되었음을 확인할 수 있습니다.<br>
이처럼 단순히 부모 클래스의 clone() 메소드를 호출하여 clone() 메소드를 재정의하면, 배열이나 인스턴스인 필드는 복제되는 것이 아닌 해당 배열이나 인스턴스를 가리키는 주소값만이 복제되는 것입니다.</p>
<p>따라서 정확한 복제를 위해서는 3번처럼 배열이나 인스턴스인 필드에 대해서는 별도로 clone() 메소드를 구현하여 호출해야 합니다.<br>
3번의 주석을 해제하고 결과를 보면 다음과 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car01 : 아반떼, [홍길동]</span><br><span class="line"></span><br><span class="line">Car02 : 아반떼, [홍길동]</span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br></pre></td></tr></table></figure>
<h2 id="object-클래스의-메소드">Object 클래스의 메소드</h2>
<img src="/img/object.png" width="600" height="200">
<h1 id="string-클래스">String 클래스</h1>
<hr>
<p>자바에서는 문자열을 위한 <strong>String</strong>이라는 클래스를 별도로 제공합니다. String 클래스에는 문자열과 관련된 작업을 할 때 유용하게 사용할 수 있는 다양한 메소드가 포함되어 있습니다. 이러한 String 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<p>String 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 이러한 객체를 자바에서는 <code>불변 객체(immutable object)</code>라고 합니다. 즉, 자바에서 덧셈(+) 연산자를 이용하여 문자열 결합을 수행하면, 기존 문자열의 내용이 변경되는 것이 아니라 내용이 합쳐진 새로운 String 인스턴스가 생성되는 것입니다.</p>
<h2 id="charat-메소드">charAt() 메소드</h2>
<p><code>charAt()</code> 메소드는 해당 문자열의 특정 인덱스에 해당하는 문자를 반환합니다. 만약 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면, <strong>IndexOutOfBoundsException</strong> 오류가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            System.out.print(str.charAt(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"charAt() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">J a v a </span><br><span class="line">charAt() 메소드 호출 후 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="comparto-메소드">comparTo() 메소드</h2>
<p>compareTo() 메소드는 해당 문자열을 인수로 전달된 문자열과 사전 편찬 순으로 비교합니다. <strong>이 메소드는 문자열을 비교할 때 대소문자를 구분하여 비교합니다.</strong> 만약 두 문자열이 같다면 0을 반환하며, 해당 문자열인 인수로 전달된 문자열보다 작으면 음수를, 크면 양수를 반환합니다.</p>
<p>만약 문자열을 비교할 때 대소문자를 구분하지 않기를 원하면, <strong>compareToIgnoreCase()</strong> 메소드를 사용하면 됩니다.</p>
<p>쉽게 말해서 다음과 같은 문자열이 있다고 생각해봅시다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"abcf"</span>)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"abbb"</span>)); <span class="comment">// 2 </span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"Abcd"</span>)); <span class="comment">// 3</span></span><br><span class="line">System.out.println(str.compareToIgnoreCase(<span class="string">"ABCD"</span>)); <span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="string">"compareTo() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">원본 문자열 : abcd</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">compareTo() 메소드 호출 후 문자열 : abcd</span><br></pre></td></tr></table></figure>
<p>1 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abcf&quot;보다 사전순으로 먼저 존재하고, 이를 작다고 표현하며 음수를 반환합니다.<br>
2 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abbb&quot;보다 사전순으로 뒤에 존재하고, 이를 크다고 표현하며 양수를 반환합니다.<br>
3 -&gt; 사전 순으로 대문자가 먼저 존재하고, 소문자가 존재하는 것으로 파악됩니다.<br>
4 -&gt; compareToIgnoreCase() 메소드를 사용함으로써 대소문자를 구분하지 않고 비교합니다.</p>
<h2 id="concat-메소드">concat() 메소드</h2>
<p><code>concat()</code> 메소드는 해당 문자열의 뒤에 인수로 전달된 문자열을 추가한 새로운 문자열을 반환합니다. 만약 인수로 전달된 문자열의 길이가 0이면, 해당 문자열을 그대로 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line">System.out.println(str.concat(<span class="string">"수업"</span>));</span><br><span class="line">System.out.println(<span class="string">"concat() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">Java수업</span><br><span class="line">concat() 메소드 호출 후 원본 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="indexof-메소드">indexOf() 메소드</h2>
<p><code>indexOf()</code> 메소드는 해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환합니다. 만약 해당 문자열에 전달된 문자나 문자열이 포함되어 있지 않으면 -1을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Oracle Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'o'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'a'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"Java"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"indexOf() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Oracle Java</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">indexOf() 메소드 호출 후 원본 문자열 : Oracle Java</span><br></pre></td></tr></table></figure>
<p><strong>위의 예제처럼 indexOf() 메소드는 문자나 문자열을 찾을 때 대소문자를 구분합니다.</strong></p>
<h2 id="trim-메소드">trim() 메소드</h2>
<p><code>trim()</code> 메소드는 해당 문자열의 맨 앞과 맨 뒤에 포함된 모든 공백 문자를 제거해줍니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"  Java   "</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">System.out.println(str + <span class="string">'|'</span>);</span><br><span class="line">System.out.println(str.trim() + <span class="string">'|'</span>);</span><br><span class="line">System.out.println(<span class="string">"trim() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 :   Java   </span><br><span class="line">  Java   |</span><br><span class="line">Java|</span><br><span class="line">trim() 메소드 호출 후 원본 문자열 :   Java</span><br></pre></td></tr></table></figure>
<h2 id="tolowercase-touppercase-메소드">toLowerCase(), toUpperCase() 메소드</h2>
<ul>
<li>toLowerCase() : 해당 문자열의 모든 문자를 소문자로 변환시켜 줍니다.</li>
<li>toUpperCase() : 해당 문자열의 모든 문자를 대문자로 변환시켜 줍니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">원본 문자열 : Java</span><br><span class="line">java</span><br><span class="line">JAVA</span><br><span class="line">trim() 메소드 호출 후 원본 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="대표적인-string-메소드">대표적인 String 메소드</h2>
<img src="/img/string1.png" width="700" height="200">
<img src="/img/string2.png" width="700" height="200">
<h1 id="stringbuffer-클래스">StringBuffer 클래스</h1>
<hr>
<p>String 클래스의 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 하지만, <code>StringBuffer</code> 클래스의 인스턴스는 그 값을 변경할 수도 있고, 추가할 수도 있습니다.</p>
<p>이를 위해 <code>StringBuffer</code> 클래스는 내부적으로 버퍼(Buffer)라고 하는 독립적인 공간을 가집니다. 버퍼 크기의 기본값은 16개의 문자를 저장할 수 있는 크기이며, 생성자를 통해 그 크기를 별도로 설정할 수 있습니다. 하지만, 인스턴스 생성 시 사용자가 설정한 크기보다 언제나 16개의 문자를 더 저장할 수 있도록 여유 있는 크기로 생성됩니다.(즉, 두배씩 증가한다는 말입니다. 16-&gt;32-&gt;64 …)</p>
<p>덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성합니다. 따라서 문자열을 많이 결합하면 결합할수록 공간의 낭비뿐만 아니라 속도 또한 매우 느려지게 됩니다.</p>
<p>하지만, <strong>StringBuffer</strong> 인스턴스를 사용하면 문자열을 바로 추가할 수 있으므로, 공간의 낭비도 없으며 속도도 매우 빨라집니다. 이러한 StringBuffer 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<blockquote>
<p>짚고 넘어가기~</p>
</blockquote>
<p>String 클래스를 이용해서 객체를 생성하면, 그 인스턴스는 읽을 수만 있고 값을 변경할 수는 없습니다. 이를 코드를 통해서 확인해보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"이승우"</span>);</span><br><span class="line">System.out.println(str1.hashCode());</span><br><span class="line">str1 = <span class="string">"정지현"</span>;</span><br><span class="line">System.out.println(str1.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span>번 : <span class="number">50664843</span></span><br><span class="line"><span class="number">2</span>번 : <span class="number">50879257</span></span><br></pre></td></tr></table></figure>
<p>위의 개념대로라면 str1의 값은 읽기만 가능하고, 변경할 수는 없습니다. 하지만, 위의 코드는 정상적으로 실행됩니다. 그렇다면 값을 읽을 수만 있고 변경할 수는 없다는 것은 무슨 뜻일까요??</p>
<p>처음에 str1은 문자열이 &quot;이승우&quot;이고, <strong>50664843</strong>라는 주소를 가지고 있는 인스턴스를 참조하고 있습니다. 이 공간에 있는 값은 읽을 수만 있고 변경할 수는 없습니다. <code>str1 = &quot;정지현&quot;;</code>을 통해서 값을 변경하려고 한다면, 새로운 공간을 할당하고 그 공간에 문자열을 집어넣습니다. 그 결과로 str1은 문자열이 &quot;정지현&quot;이고, <strong>50879257</strong>라는 주소를ㄹ 가지고 있는 인스턴스를 참조하게 됩니다. 따라서 원래의 공간에 있는 값은 변경되지 않고, str1이 참조하고 있는 공간이 바뀌는 것입니다.</p>
<p>정리하면, String 클래스의 값을 변경한다는 것은 str1 인스턴스가 새롭게 생성되고, 이렇게 생성된 인스턴스의 공간은 str1이 참조하게 되는 것입니다. 그리고 그 전의 인스턴스는 공간을 차지하면서, 누구도 참조하지 않게 되고 이로 인해서 공간의 낭비는 발생하게 되고, 속도도 느려지는 것입니다.</p>
<h2 id="불변클래스와-가변-클래스">불변클래스와 가변 클래스</h2>
<p>String 클래스와 같이 인스턴스가 한 번 생성되면 그 값을 변경할 수 없는 클래스를 <strong>불변 클래스(immutable class)</strong> 라고 합니다.<br>
반대로 StringBuffer 클래스와 같이 자유롭게 인스턴스의 값을 변경할 수 있는 클래스를 **가변 클래스(mutable class)**라고 합니다.<br>
String 클래스와 같은 불변 클래스는 StringBuffer 클래스의 append()나 insert() 메소드와 같이 값을 변경하는 set 메소드를 포함하지 않습니다.</p>
<p>이렇게 불편하기만 할 것 같은 불변 클래스를 사용하는 이유는 멀티 스레드 환경에서 객체가 변화되는 상황이라면 불변 인스턴스를 사용하는 것이 좀 더 신뢰할 수 있는 코드를 작성할 수 있기 때문입니다.<br>
즉, 하나의 객체에 접근하면서 각각의 객체가 서로 영향을 주어서는 안되는 경우에 불변 인스턴스를 사용하면 값이 변하지 않는다는 점이 보장됩니다.</p>
<h2 id="append-메소드">append() 메소드</h2>
<p><code>append()</code>메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가합니다. 이 메소드는 String 클래스의 concat() 메소드와 같은 결과를 반환하지만, <strong>내부적인 처리 속도가 훨씬 빠릅니다.</strong></p>
<p>이유는 String 클래스의 concat() 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가하지만, 원본 문자열에 추가하는 것이 아니라 문자열을 추가한 새로운 인스턴스를 생성하는 것이고, <strong>append()</strong> 메소드는 원본 문자열에 인수로 전달된 문자열을 추가하는 것이기 때문에 처리 속도가 빠른 것입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">        System.out.println(str.append(<span class="string">"수업"</span>));</span><br><span class="line">        System.out.println(<span class="string">"append() 메소드 호출 한 후 문자열 : "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">Java수업</span><br><span class="line">append() 메소드 호출 한 후 문자열 : Java수업</span><br></pre></td></tr></table></figure>
<h2 id="capacity-메소드">capacity() 메소드</h2>
<p><code>capacity()</code> 메소드는 StringBuffer 인스턴스의 현재 버퍼 크기를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer str1 = <span class="keyword">new</span> StringBuffer(<span class="string">"Java"</span>);</span><br><span class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(str1.capacity());</span><br><span class="line">        System.out.println(str2.capacity());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 길이가 4인 문자열로 StringBuffer 인스턴스를 생성하면, 기본적으로 생성되는 여유 버퍼 크기인 16에 문자의 길이인 4를 더한 총 20개의 문자를 저장할 수 있는 버퍼가 생성되는 것을 확인할 수 있습니다.</p>
<h2 id="delete-메소드">delete() 메소드</h2>
<p><code>delete()</code> 메소드는 전달된 인덱스에 해당하는 부분 문자열을 해당 문자열에서 제거합니다. 또한, deleteCharAt() 메소드를 사용하면 특정 위치의 문자 한 개만을 제거할 수도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java Oracle"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line">        System.out.println(str.delete(<span class="number">4</span>, <span class="number">8</span>)); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(str.deleteCharAt(<span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">"deleteCharAt() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java Oracle</span><br><span class="line">Javacle</span><br><span class="line">Jvacle</span><br><span class="line">deleteCharAt() 메소드 호출 후 원본 문자열 : Jvacle</span><br></pre></td></tr></table></figure>
<p>1번에서는 delete() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치의 문자부터 8보다 하나 적은 7인 위치의 문자까지를 삭제하고 있습니다. 이처럼 delete() 메소드는 첫 번째 매개변수로 전달된 인덱스부터 두 번째 매개변수로 전달된 인덱스 바로 앞의 문자까지를 삭제하는 메소드입니다.</p>
<h2 id="insert-메소드">insert() 메소드</h2>
<p><code>insert()</code> 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 지정된 인덱스 위치에 추가합니다. 이 때, 전달된 인덱스가 해당 문자열의 길이와 같으면, append() 메소드와 같은 결과를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java 만세!!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">        System.out.println(str.insert(<span class="number">5</span>, <span class="string">"Script "</span>));</span><br><span class="line">        System.out.println(<span class="string">"insert() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java 만세!!</span><br><span class="line">Java Script 만세!!</span><br><span class="line">insert() 메소드 호출 후 문자열 : Java Script 만세!!</span><br></pre></td></tr></table></figure>
<p>insert() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치부터 두 번째 매개변수로 전달된 문자열을 추가하고 있습니다. 이처럼 내가 원하는 위치에 문자열을 추가할 때 사용할 수 있는 메소드입니다.</p>
<h2 id="대표적인-stringbuffer-메소드">대표적인 StringBuffer 메소드</h2>
<img src="/img/stringbuffer.png" width="800" height="200">
<h1 id="math-클래스">Math 클래스</h1>
<hr>
<p><code>Math</code> 클래스는 수학에서 자주 사용하는 상수들과 함수들을 미리 구현해 놓은 클래스입니다. Math 클래스의 모든 메소드는 <strong>클래스 메소드</strong> <strong>(static method)</strong> 이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이러한 Math 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<h2 id="mathe와-mathpi">Math.E와 Math.PI</h2>
<p>다음은 Math 클래스에 정의되어 있는 클래스 필드입니다.</p>
<ol>
<li>Math.E : 오일러의 수라 불리며, 자연로그(natural logarithms)의 밑(base) 값으로 약 2.718을 의미합니다.</li>
<li>Math.PI : 원의 원주를 지름으로 나눈 비율(원주율) 값으로 약 3.14159를 의미합니다.</li>
</ol>
<h2 id="random-메소드">random() 메소드</h2>
<p><code>random()</code> 메소드는 0.0이상 1.0 미만의 범위에서 임의의 double 형 값을 하나 생성하여 반환합니다. 이 메소드는 내부적으로 java.util 패키지의 Random 클래스를 사용한 의사 난수 발생기(pseudorandom generator)를 사용하여 임의의 수를 생성합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(random.nextInt(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바에서는 Math 클래스의 random() 메소드 뿐만 아니라 java.util 패키지에 포함된 Random 클래스의 nextInt() 메소드를 사용해도 난수를 생성할 수 있습니다. nextInt() 메소드는 매개변수로 범위를 지정해 줄 수 있습니다.</p>
<p>만약 특정 범위에 속하는 난수를 생성하려면, 다음과 같이 난수 생성 범위를 조절할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)); <span class="comment">//1</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)+<span class="number">1</span>); <span class="comment">//2</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)+<span class="number">3</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>만약 특정 범위에 속하는 난수를 생성하려면, 위와 같이 난수 생성 범위를 조절할 수 있습니다.<br>
기본적으로 0부터 곱해지는 수의 바로 앞 수까지가 난수 생성 범위로 지정됩니다.</p>
<p>1 -&gt; 0~5<br>
2 -&gt; 1~6<br>
3 -&gt; 3~8</p>
<h2 id="abs-메소드">abs() 메소드</h2>
<p><code>abs()</code> 메소드는 전달된 값이 음수이면 그 값의 절대값을 반환하며, 전달된 값이 양수이면 전달된 값을 그대로 출력합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">System.out.println(Math.abs(-<span class="number">123123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">123123</span></span><br></pre></td></tr></table></figure>
<h2 id="floor-ceil-round-메소드">floor(), ceil(), round() 메소드</h2>
<ul>
<li>floor() : <strong>인수로 전달받은 값과 같거나 작은 수 중에서 가장 큰 정수를 반환합니다.</strong></li>
<li>ceil() : <strong>반대로 인수로 전달받은 값과 같거나 큰 수 중에서 가장 작은 정수를 반환합니다.</strong></li>
<li>round() : <strong>전달받은 실수를 소수점 첫째 자리애서 반올림한 정수를 반환합니다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.ceil(<span class="number">10.9</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">10.0</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">9.9</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.println(Math.floor(<span class="number">9.9</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">10.9</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">10.1</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.println(Math.round(<span class="number">10.34457</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">10.49</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">10.61</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">11.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="max-min-메소드">max(), min() 메소드</h2>
<p>max() 메소드는 전달된 두 값을 비교하여 그 중에서 큰 값을 반환하며, min() 메소드는 그 중에서 작은 값을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.max(<span class="number">3.14</span>, <span class="number">3.141</span>));</span><br><span class="line">System.out.println(Math.max(<span class="number">3.14</span>, <span class="number">3.14159</span>)); </span><br><span class="line">System.out.println(Math.min(<span class="number">3.14</span>, <span class="number">3.14159</span>)); </span><br><span class="line">System.out.println(Math.max(-<span class="number">10</span>, -<span class="number">11</span>));      </span><br><span class="line">System.out.println(Math.min(-<span class="number">10</span>, -<span class="number">11</span>));      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3.141</span></span><br><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">-<span class="number">10</span></span><br><span class="line">-<span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="pow-sqrt-메소드">pow(), sqrt() 메소드</h2>
<p>pow() 메소드는 전달된 두 개의 double형을 가지고 제곱 연산을 수행합니다.<br>
예를 들어, pow(a,b)는 a의 b승, 즉 a^b를 반환하게 됩니다.</p>
<p>반대로 sqrt() 메소드는 전달된 double형 값의 제곱근을 반화합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="keyword">int</span>)(Math.pow(<span class="number">5</span>,<span class="number">2</span>)));</span><br><span class="line">System.out.println((<span class="keyword">int</span>)(Math.sqrt(<span class="number">25</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="삼각함수와-관련된-메소드">삼각함수와 관련된 메소드</h2>
<p>자바에서는 삼각 함수와 관련된 다양한 연산을 간편하게 수행할 수 있도록 많은 삼각 함수를 제공하고 있습니다.</p>
<ul>
<li>sin() : 전달된 double형 값의 사인 값을 반환합니다.</li>
<li>cos() : 전달된 double형 값의 코사인 값을 반환합니다.</li>
<li>tan() : 전달된 double형 값의 탄젠트 값을 반환합니다.</li>
</ul>
<p>이 외에도 Math 클래스에서 제공하는 삼각 함수와 관련된 메소드는 다음과 같습니다.<br>
-asin(), acos(), atan(), atan2(), sinh(), cosh(), tanh()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.sin(Math.toRadians(<span class="number">30</span>)));</span><br><span class="line">System.out.println(Math.sin(Math.PI / <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(Math.tan(Math.toRadians(<span class="number">45</span>)));</span><br><span class="line">System.out.println(Math.tan(Math.PI / <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(Math.cos(Math.toRadians(<span class="number">60</span>)));</span><br><span class="line">System.out.println(Math.cos(Math.PI / <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0.49999999999999994</span></span><br><span class="line"><span class="number">0.49999999999999994</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br><span class="line"><span class="number">0.5000000000000001</span></span><br><span class="line"><span class="number">0.5000000000000001</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 자바의 삼각 함수에 관한 메소드는 정확한 값을 나타내지 못합니다. 그 이유는 컴퓨터가 실수를 나타내는데 사용하는 부동 소수점 방식의 한계로 모든 언어에서 공통으로 발생하는 문제입니다.</p>
<h2 id="대표적인-math-메소드">대표적인 Math 메소드</h2>
<img src="/img/math1.png" width="700" height="200">
<img src="/img/math2.png" width="700" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/20/java-basic-11/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/19/java-basic-10/"
                            aria-label=": [Java] 10. 다형성"
                        >
                            [Java] 10. 다형성
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-19T16:02:01+09:00">
	
		    Aug 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="다형성"># 다형성</h1>
<ul>
<li>하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미한다.</li>
<li>부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 해 구현한다.</li>
<li><strong>여러 가지 형태를 가질 수 있는 능력</strong>을 의미한다. 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 구현한다.</li>
</ul>
<h2 id="참조-변수의-다형성"># 참조 변수의 다형성</h2>
<ul>
<li>부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 한다.</li>
<li>참조 변수가 사용할 수 있는 멤버의 개수 &lt;= 실제 인스턴스의 멤버의 개수</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTV</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goSleep</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goSchool</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parent p = <span class="keyword">new</span> Parent(); <span class="comment">// 1</span></span><br><span class="line">        Parent pc = <span class="keyword">new</span> Child(); <span class="comment">// 2</span></span><br><span class="line">        Child c = <span class="keyword">new</span> Child(); <span class="comment">// 3</span></span><br><span class="line">        Child cp = <span class="keyword">new</span> Parent(): <span class="comment">// 4 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>참조변수 a = new 인스턴스타입()</code></p>
<p>특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있다.<br>
참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문이다.</p>
<p>부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있다.<br>
참조 변수가 사용할 수 있는 멤버가 실제 인스턴스의 멤버 개수보다 적기 때문입니다.</p>
<p>하지만 반대의 경우, 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다.</p>
<blockquote>
<p>클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 된다.</p>
</blockquote>
<ol>
<li>기본적으로는 참조 변수와 인스턴스의 타입이 일치하는 걸 많이 사용한다.</li>
<li>참조 변수보다 인스턴스 타입의 멤버가 범위가 더 넓어야 한다.</li>
</ol>
<p><code>Parent p = new Child();</code><br>
참조 변수 : 부모, 인스턴스 타입 : 자식 -&gt; 가능, 부모의 멤버만 참조가 가능.<br>
<code>Child d = new Parent();</code><br>
참조 변수 : 자식, 인스턴스 타입 : 부모 -&gt; 불가능, 참조 변수의 멤버를 모두 충족하지 못한다.</p>
<h2 id="참조-변수의-타입-변환"># 참조 변수의 타입 변환</h2>
<p>참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있다.</p>
<ol>
<li>서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있다.</li>
<li>자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있다.</li>
<li>부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.</li>
</ol>
<p>참조 변수의 타입 변환도 기본 타입의 변환과 마찬가지로 <code>타입 캐스트 연산자 ()</code>를 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(변환할 타입의 클래스 이름) 변환할 참조 변수</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Parent pa1 = <span class="keyword">null</span>;</span><br><span class="line">Child ch = <span class="keyword">new</span> Child();</span><br><span class="line">Parent pa2 = <span class="keyword">new</span> Parent();</span><br><span class="line">Brother bro = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">pa1 = ch; <span class="comment">// 1</span></span><br><span class="line">bro = (Brother)pa2; <span class="comment">// 2</span></span><br><span class="line">bro = (Brother)ch; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>1 : pa1 = (Parent)ch; 와 같으며 자식 클래스 -&gt; 부모 클래스 타입으로의 변환이므로 타입 변환을 생략할 수 있다.<br>
2 : 타입 변환을 생략할 수 없다. (부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.)<br>
3 : 이 문장은 두 클래스 간의 직접적인 상속 관계가 아니므로 오류 발생.</p>
<blockquote>
<p>짚고 넘어가야 할 부분!</p>
</blockquote>
<ol>
<li>자식 -&gt; 부모(Up-casting) : 형 변환 생략 가능<br>
자식이 부모의 모든 걸 상속 받았으므로 자식이 더 범위가 넓다고 판단하여 손실이 없다고 판단하고 형 변환 생략이 가능하다.</li>
<li>부모 -&gt;자식(Down-casting) : 형 변환 생략 불가능</li>
</ol>
<p><code>TV2 t = new TV2();</code>와 <code>TV2 t = new CaptionTV();</code>의 차이점을 알아보자. 사실 <code>TV2 t = new CaptionTV();</code>는 다음을 줄인 것이다.<br>
<code>TV2 t = (TV2)new CaptionTV();</code> 업 캐스팅이므로 형 변환이 생략되어있던 것이다. 이걸 또 풀어 쓰면 다음과 같다.</p>
<ol>
<li><code>CaptionTV c = new CaptionTV();</code></li>
<li><code>TV2 t = (TV2)c</code><br>
역시 업 캐스팅이므로 TV2는 생략이 가능하다.</li>
</ol>
<p>그렇다면 차이점이 무엇일까???</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> power;</span><br><span class="line">    <span class="keyword">int</span> channel;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUp</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelDown</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptionTV</span> <span class="keyword">extends</span> <span class="title">TV2</span> </span>&#123;</span><br><span class="line">    String text;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">caption</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV2 t = <span class="keyword">new</span> TV2();</span><br><span class="line">        TV2 t2 = <span class="keyword">new</span> CaptionTV();</span><br><span class="line">        System.out.println(((CaptionTV) t2).text); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// t는 TV2 인스턴스여서 TV2의 멤버만 가지고 있으므로 CaptionTV 타입을 커버할 수가 없다.</span></span><br><span class="line">        <span class="comment">// 컴파일 시에는 올바른 형변환으로 보지만 런타임에서 체크 해보면 부모가 자식을 커버할 수 없는 원리와 같다.</span></span><br><span class="line">        <span class="comment">// CaptionTV c = (CaptionTV)t;</span></span><br><span class="line">        <span class="comment">// System.out.println(c.text);</span></span><br><span class="line">        <span class="comment">// t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅 해서 일단 CaptionTV 멤버를 들고는 있는데</span></span><br><span class="line">        <span class="comment">// 접근만 못할 뿐이라 CaptionTV 타입을 커버할 수 있다.</span></span><br><span class="line">        CaptionTV c2 = (CaptionTV)t2; <span class="comment">// 2</span></span><br><span class="line">        System.out.println(c2.text); <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅해서 일단 CaptionTV 멤버를 들고 있다. 그래서 접근하기 위해서는 1번과 같이 t2를 CaptionTV2로 다운 캐스팅 한 후에 접근해야 한다.</p>
<p>2번과 그 아래 코드는 1번에서 캐스팅 하고 text에 접근하는 과정을 풀어서 나타낸 것이다.</p>
<ol>
<li>
<p><code>TV2 t = new TV2();</code></p>
<ul>
<li>부모 참조 타입에 부모 인스턴스이면</li>
<li><code>Caption c = (CaptionTV)t</code> -&gt; 불가능</li>
<li>자식의 참조 타입으로 변환하지 못한다.</li>
<li>컴파일에서 에러가 발생하지는 않지만, 런타임에 에러가 발생한다.</li>
</ul>
</li>
<li>
<p><code>TV2 t = new CaptionTV();</code></p>
<ul>
<li>부모 참조 타입에서 자식 인스턴스이면</li>
<li><code>CaptionTV c = (CaptionTV)t</code> -&gt; 가능</li>
<li>자식의 참조 타입으로 변환 가능하다.</li>
</ul>
</li>
</ol>
<p><strong>instanceof 연산자</strong></p>
<ul>
<li>런타임에 참조 변수가 실제 참조하고 있는 인스턴스의 타입을 확인하기 위해 사용한다.</li>
<li><code>참조 변수 instanceof 클래스이름</code>
<ul>
<li>true : 참조 변수 = 실제 참조하고 있는 인스턴스 타입일 때 반환</li>
<li>false : 참조 변수 != 실제 참조하고 있는 인스턴스 타입이 아닐 때 반환</li>
<li>참조 변수가 null을 가리키고 있으면 false 반환.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parent pa1 = <span class="keyword">new</span> Parent();</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Parent);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Child);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Brother);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Parent child = <span class="keyword">new</span> Child();</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Parent);</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Child);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h1 id="다형성에-대해-더"># 다형성에 대해 더</h1>
<p>이후에 추가적으로 더 좋은 글을 참고하여 덧붙이게 되었다.</p>
<p><strong>다형성?</strong></p>
<ul>
<li><strong>여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함을 구현하는데 사용한다.</strong></li>
<li>구체적으로는 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하는 것이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        obj.x();</span><br><span class="line">        <span class="comment">// obj.y(); 이 녀석으로 인해 컴파일 에러</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class B를 obj로 인스턴스화하는데 데이터 타입은 A<br>
그 말은 실질적으로 class B를 담고 있지만 A인 것!!<br>
즉, class A에는 메소드 y()가 정의되어 있지 않다.<br>
그래서 obj.y()는 컴파일 에러가 발생한다.</p>
<ul>
<li>어떤 클래스를 인스턴스화 시킬 때, 변수를 담는 데이터 타입은 그 클래스가 될 수도 있고, 그 클래스의 부모 클래스가 될 수도 있다.</li>
<li>그럼 도대체 왜 이렇게 객체를 생성하는가 의문이 들기 시작한다. 다음 코드를 보자.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(obj.x());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">B.x</span><br></pre></td></tr></table></figure>
<p>A obj = new B();<br>
위의 코드는 class B를 인스턴스화 한 obj이지만 class A의 행세를 한다.<br>
그 뜻은 class A에 속해 있는 메소드만 호출할 수 있다는 것이다.<br>
즉, class B에만 속해 있는 메소드는 호출할 수 없다.<br>
class B에서 class A에 속해있던 메소드를 오버라이딩했다면 그 오버라이딩한 결과가 호출된다.</p>
<p>하지만 아직도 왜 이런 코드를 작성하는지 모르는 건 마찬가지이다…ㅜ<br>
아래의 코드를 하나 더 살펴보도록 하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        A obj2 = <span class="keyword">new</span> B2();</span><br><span class="line">        System.out.println(obj.x());</span><br><span class="line">        System.out.println(obj2.x());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="comment">// 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B2.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">B.x</span><br><span class="line">B2.x</span><br></pre></td></tr></table></figure>
<p>obj, obj2 둘은 각각 B, B2 클래스를 통해 형성된 것이지만 부모 행세를 하고 있다. 따라서 자식 클래스에서 정의된 메소드를 호출할 수 없고 오버라이딩한 부분에 대해서만 호출한다.<br>
즉 각각의 자식 클래스에서 오버라이딩한 부분이 실행된다.</p>
<p>서로 다른 객체가 동일한 데이터 타입으로 존재하면서 각각의 클래스에 정의되어 있는 메소드를 호출할 때 각자가 정의한 대로 호출합니다.</p>
<ul>
<li>이쯤 되면 이러한 의문을 가질 수 있습니다.</li>
<li>같은 데이터 타입을 갖게 되면 장점이 있을까?</li>
<li>맞다. 데이터 타입이 같으면 메소드를 실행시키기가 편리해진다.</li>
</ul>
<img src="/img/kklkl.png" width="600" height="200">
<p>위의 코드처럼 호출하는 메소드를 만들어두면 하나의 데이터 타입을 대상으로 여러가지를 호출할 수 있다.</p>
<p><strong>다형성과 인터페이스</strong></p>
<p>어떤 클래스가 어떤 인터페이스를 구현하고 있다면 그 클래스로부터 인스턴스화 되는 인스턴스의 데이터 타입은 구현하고 있는 인터페이스로 인스턴스화 될 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphism</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        I obj = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I2</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        D objD = <span class="keyword">new</span> D();</span><br><span class="line">        I2 objI2 = <span class="keyword">new</span> D();</span><br><span class="line">        I3 objI3 = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">        System.out.println(objD.A());</span><br><span class="line">        <span class="comment">// class D가 정의한 모든 멤버를 호출할 수 있습니다.</span></span><br><span class="line">        System.out.println(objD.B());</span><br><span class="line">        <span class="comment">// class D가 정의한 모든 멤버를 호출할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(objI2.A());</span><br><span class="line">        <span class="comment">// interface I2의 데이터 타입이므로 A() 메소드 호출 가능</span></span><br><span class="line">        <span class="comment">// System.out.println(objI2.B());</span></span><br><span class="line">        <span class="comment">// interafce I2의 데이터 타입이므로 B() 메소드가 존재하지 않아 호출 불가능</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(objI3.A());</span></span><br><span class="line">        <span class="comment">// interface I3의 데이터 타입이므로 A() 메소드가 존재하지 않아 호출 불가능</span></span><br><span class="line">        System.out.println(objI3.B());</span><br><span class="line">        <span class="comment">// interface I3의 데이터 타입이므로 호출 가능</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스가 갖고 있는 모든 메소드를 호출해야 한다면(모든 기능을 사용해야 한다면) 데이터 타입을 그 클래스로 지정해줘야 하지만, <strong>특정한 인터페이스에 해당하는 기능만을 사용한다고 하면 데이터 타입으로 그 기능이 속해 있는 인터페이스를 데이터 타입으로 지정하면 된다. 나머지 기능을 마치 존재하지 않는 것처럼 할 수 있다.</strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/19/java-basic-10/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/17/java-basic-9/"
                            aria-label=": [Java] 9. 상속"
                        >
                            [Java] 9. 상속
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-17T10:38:44+09:00">
	
		    Aug 17, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="상속"># 상속</h1>
<ul>
<li>기존의 클래스에 기능을 추가하거나 메소드를 재정의하여 새로운 클래스를 정의하는 것을 의미한다.</li>
<li>캡슐화, 추상화와 더불어 객체지향 프로그래밍의 특징 중 하나이다.</li>
<li><strong>extends</strong> 키워드를 사용한다.</li>
<li>단일 상속만을 지원한다.</li>
</ul>
<p>상속을 통해 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다. 즉, 기존의 객체를 그대로 유지하면서 어떤 기능을 추가하는 방법이다.</p>
<p>기존의 객체가 갖고 있는 메소드들을 그대로 사용할 수 있다. 이때 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스(base class)라고도 한다. 그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스(child class) 또는 하위 클래스(sub class), 파생 클래스(derived class)라고도 한다.</p>
<h2 id="상속의-장점">상속의 장점</h2>
<ol>
<li>기존에 작성된 클래스를 <strong>재활용</strong>할 수 있다.</li>
<li>자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다.</li>
<li>클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다.</li>
</ol>
<p><strong>1. 자식 클래스(child class)</strong></p>
<ul>
<li>부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 자식 클래스 이름 <span class="keyword">extends</span> 부모 클래스 이름</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<img src="/img/child_class.png" width="500" height="200">
<center><b>부모 클래스와 자식 클래스 간의 포함 관계</b></center>
<p>부모 클래스는 자식 클래스에 포함된 것으로 볼 수 있다.<br>
따라서, 부모 클래스에 새로운 필드를 하나 추가하면 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작한다.</p>
<p>자식 클래스에는 부모 클래스의 필드와 메소드만이 상속된다.<br>
생성자와 초기화 블록은 상속되지 않는다. 또한, 부모 클래스의 접근 제어자가 private나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근할 수 없다.</p>
<p>private로 선언된 멤버는 자식 클래스에서 접근할 수 없다.<br>
(같은 패키지이건, 다른 패키지이건)<br>
default로 선언된 멤버는 자식 클래스에서 접근 할 수 있다. (같은 패키지에 한해서만) 다른 패키지의 자식 클래스에서는 접근을 할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">10</span>; <span class="comment">// private 필드</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num2 = <span class="number">20</span>; <span class="comment">// public 필드</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num3 = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num1); <span class="comment">// 1 </span></span><br><span class="line">        System.out.println(num2); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(num3); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 부모 클래스의 private 멤버는 자식 클래스에서 접근할 수 없으므로 오류 발생.<br>
2 : 부모 클래스의 public 멤버는 자식 클래스에서 접근 가능.<br>
3 : 자식 클래스에서 자신만의 필드 혹은 메소드를 선언하여 사용할 수 있으므로 가능.</p>
<h1 id="object-클래스"># Object 클래스</h1>
<ul>
<li>Object 클래스는 모든 클래스의 부모 클래스이다.</li>
<li>모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 된다.</li>
<li>toString(), clone()과 같은 메소드 등등.</li>
</ul>
<h1 id="super"># super</h1>
<ul>
<li>super : 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수이다.</li>
</ul>
<p>인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 사용해서 구분했었다. 이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 <code>super</code> 키워드를 사용하여 구별할 수 있다.</p>
<p>this와 마찬가지로 super 참조 변수는 인스턴스 메소드에서만 사용할 수 있다. 클래스 메소드에서는 사용할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.a);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">결과</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>위의 예제에서 int형 변수 a는 자식 클래스인 Child와 부모 클래스인 Parent에 선언되어 있습니다. 따라서 지역 변수와 this 참조 변수는 자식 클래스에서 대입된 값을 출력하며, super 참조 변수만이 부모 클래스에서 대입된 값을 출력하게 됩니다.</p>
<h1 id="super"># super()</h1>
<ul>
<li>this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, <code>super()</code> 메소드는 부모 클래스의 생성자를 호출할 때 사용된다.</li>
</ul>
<p>자식 클래스의 인스턴스를 생성하면 이 인스턴스에는 자식 클래스의 고유 멤버뿐 아니라 부모 클래스의 모든 멤버가 포함되어 있다. 따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야 한다.</p>
<p>이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 <strong>Object</strong> 클래스의 생성자까지 거슬러 올라가며 수행된다.</p>
<p>자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 <code>super()</code>를 추가하여 부모 클래스의 멤버를 초기화할 수 있도록 해준다.</p>
<p>하지만 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야, <strong>자동으로 기본 생성자를 추가해준다.</strong> 아래처럼 부모 클래스에 매개변수를 가지는 생성자를 하나라도 선언했다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 부모 클래스의 매개변수가 있는 생성자</span></span><br><span class="line">    Parent(<span class="keyword">int</span> n)&#123; </span><br><span class="line">        <span class="keyword">this</span>.a = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 super()를 사용해 부모 클래스의 기본 생성자를 호출하면 오류가 발생한다. 이유는 부모 클래스에 기본 생성자가 없기 때문이다. 매개변수를 가진 생성자를 선언해야 할 경우는 기본 생성자까지 명시적으로 선언하는 것이 좋다.</p>
<p>혹은 아래의 2번처럼 <code>super(20);</code> super() 메소드를 호출할 때 부모 클래스의 매개변수가 있는 생성자를 호출하는 것도 하나의 방법이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 부모 클래스의 매개변수가 있는 생성자</span></span><br><span class="line">    Parent(<span class="keyword">int</span> n)&#123; </span><br><span class="line">        <span class="keyword">this</span>.a = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        a  = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">20</span>); <span class="comment">// 2</span></span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래는 super() 메소드가 어떻게 호출되는지를 보여주는 예제이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Parent() &#123; </span><br><span class="line">        a = <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    Parent(<span class="keyword">int</span> n) &#123; </span><br><span class="line">        a = n; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child() &#123;</span><br><span class="line">    <span class="comment">// 하위 클래스에서는 반드시 상위 클래스의 생성자가 호출되어야 합니다.</span></span><br><span class="line">    <span class="comment">// super(40); 1번</span></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child ch = <span class="keyword">new</span> Child();</span><br><span class="line">        ch.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바 컴파일러는 주석 처리된 1번 라인에 자동으로 <code>super();</code>를 삽입할 것이다. 따라서 변수 a는 10으로 초기화된다.</p>
<p>1번 라인의 주석을 해제하고 실행하면 부모 클래스 Parent 클래스는 두 번째 생성자에 의해 초기화되고 변수 a는 40으로 초기화된다.</p>
<p>추가적으로 인스턴스 변수(여기서 int b)의 초기화는 인스턴스 변수가 선언된 클래스의 <strong>생성자</strong>를 통해서 진행하는 것이 가장 좋은 모델이 될 수 있다. 상위 클래스의 인스턴스 변수는 상위 클래스의 생성자 내에서 초기화가 진행되어야 하고, 하위 클래스에서는 상위 클래스의 인스턴스 변수를 초기화하는데 필요한 데이터를 <strong>키워드 super</strong>를 통해서 전달만 하는 것이 합리적이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/17/java-basic-9/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/13/java-basic-8/"
                            aria-label=": [Java] 8. 클래스 멤버"
                        >
                            [Java] 8. 클래스 멤버
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-13T16:01:59+09:00">
	
		    Aug 13, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바에서는 변수가 3 종류로 나누어지고 각각 다른 메모리에 올라간다. 메소드도 클래스 메소드와 인스턴스 메소드로 분류할 수 있다.</p>
<h1 id="필드의-구분"># 필드의 구분</h1>
<ul>
<li>클래스의 <code>필드(field)</code>란 클래스에 포함된 <strong>변수</strong>를 의미한다.</li>
<li>클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분된다.</li>
</ul>
<ol>
<li>클래스 변수(static variable)</li>
<li>인스턴스 변수(instance variable)</li>
<li>지역 변수(local variable)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cv; <span class="comment">// 클래스 변수</span></span><br><span class="line">    String iv; <span class="comment">// 인스턴스 변수</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lv = <span class="number">10</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 변수와 인스턴스 변수는 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화 된다.</li>
<li>지역 변수는 사용하기 전에 초기화하지 않으면, 자바 컴파일러가 오류를 발생시킨다. 따라서 지역 변수는 반드시 초기화 해야 한다.</li>
</ul>
<p><strong>1. 클래스 변수</strong></p>
<ul>
<li>멤버 변수라고도 한다.</li>
<li>모든 인스턴스에게 적용될 수 있는 변수이며, <strong>메모리 공간에 하나만 존재하고 모든 인스턴스가 공유하는 변수</strong>이다.(공유 변수)</li>
<li>인스턴스를 생성하지 않고도 바로 사용할 수 있다.</li>
<li>클래스 영역에 위치하며 static으로 선언된다.</li>
<li>어디서나 접근할 수 있도록 하기 위해 public 제어자를 추가한다.</li>
<li>참조의 용도로만 사용되는 공유 변수는 <code>static final</code>로 선언한다.</li>
</ul>
<p>static 변수(즉, 클래스 변수, 멤버 변수, 공유 변수)는 인스턴스가 생성되기 전에 메모리 공간에 할당되어 초기화까지 완료된다.<br>
int 타입 변수는 0으로 초기화된다.<br>
String 타입 변수는 null로 초기화된다.<br>
<strong>JVM에 의해 클래스가 메모리에 올라가는 순간에 초기화된다.</strong></p>
<p>static 변수에는 무거운 즉, 용량이 큰 변수를 선언하면 메모리의 비효율을 발생시킨다. 프로그램이 실행되면서 static area(= 메소드 영역)에 변수가 생성되기 때문이다. 이 영역에 생성되는 변수는 프로그램이 종료될 때까지 할당된 메모리를 점유하고 있게 된다. 이로 인해 무거운 즉, 용량이 큰 변수를 선언하지 않도록 주의해야 한다.</p>
<p><strong>2. 인스턴스 변수</strong></p>
<ul>
<li>클래스 내부에 선언된다.</li>
<li>클래스 영역에 위치하며 static 키워드를 갖지 않는다.</li>
<li>인스턴스마다 다른 값을 갖는 변수.</li>
<li>인스턴스가 <strong>new</strong> 키워드를 통해 생성되어야 생성된다. 즉, 인스턴스가 생성되었을 때 인스턴스 변수에 접근할 수 있다.</li>
<li>자바 메모리 구조 중 Heap 영역에 생성된다. 삭제하지 않아도 GC에 의해 메모리가 회수된다.</li>
</ul>
<p><strong>3. 지역 변수</strong></p>
<ul>
<li>메소드 내에 선언되고 메소드 내에서만 사용 가능하다.</li>
<li>메소드가 종료되면 지역 변수는 소멸된다.</li>
<li>초기화하지 않으면 기본값이 설정되지 않기 때문에 명시적으로 초기화를 해줘야 한다.</li>
</ul>
<p><strong>예제</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>; <span class="comment">// 클래스 변수</span></span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">20</span>; <span class="comment">// 인스턴스 변수</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localVar = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">"지역 변수 참조 : "</span>+localVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Field field1 = <span class="keyword">new</span> Field();</span><br><span class="line">        Field field2 = <span class="keyword">new</span> Field();</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 참조 : "</span>+Field.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field1의 클래스 변수 참조 : "</span>+field1.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 클래스 변수 참조 : "</span>+field2.classVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        field1.classVar = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"클래스 참조 변수의 값 변경 후"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 참조 : "</span>+Field.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field1의 클래스 변수 참조 : "</span>+field1.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 클래스 변수 참조 : "</span>+field2.classVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"field1의 인스턴스 변수 참조 : "</span>+field1.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 인스턴스 변수 참조 : "</span>+field2.instanceVar);</span><br><span class="line"></span><br><span class="line">        field1.instanceVar = <span class="number">200</span>;</span><br><span class="line">        field2.instanceVar = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"인스턴스 참조 변수의 값 변경 후"</span>);</span><br><span class="line">        System.out.println(field1.instanceVar);</span><br><span class="line">        System.out.println(field2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">지역 변수 참조 : <span class="number">30</span></span><br><span class="line"></span><br><span class="line">클래스 변수 참조 : <span class="number">10</span></span><br><span class="line">field1의 클래스 변수 참조 : <span class="number">10</span></span><br><span class="line">field2의 클래스 변수 참조 : <span class="number">10</span></span><br><span class="line"></span><br><span class="line">클래스 참조 변수의 값 변경 후</span><br><span class="line">클래스 변수 참조 : <span class="number">100</span></span><br><span class="line">field1의 클래스 변수 참조 : <span class="number">100</span></span><br><span class="line">field2의 클래스 변수 참조 : <span class="number">100</span></span><br><span class="line"></span><br><span class="line">field1의 인스턴스 변수 참조 : <span class="number">20</span></span><br><span class="line">field2의 인스턴스 변수 참조 : <span class="number">20</span></span><br><span class="line"></span><br><span class="line">인스턴스 참조 변수의 값 변경 후</span><br><span class="line">field1의 인스턴스 변수 참조 : <span class="number">200</span></span><br><span class="line">field2의 인스턴스 변수 참조 : <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 변수는 해당 클래스의 모든 인스턴스 변수가 같은 값을 공유한다.</li>
<li>인스턴스 변수는 인스턴스마다 별도의 고유한 값을 갖는다.</li>
</ul>
<p>선언된 위치에 따라 구분되는 변수는 생성 및 소멸 시기, 저장되는 메모리 공간과 사용 방법까지도 서로 다르다.</p>
<img src="/img/static_local.png" width="650" height="200">
<h1 id="메소드의-구분"># 메소드의 구분</h1>
<ul>
<li>클래스 메소드(static method)</li>
<li>인스턴스 메소드(instance method)</li>
</ul>
<p><strong>1. 클래스 메소드(static 메소드)</strong></p>
<ul>
<li>static 키워드를 갖는 메소드를 의미한다.</li>
<li>인스턴스를 생성하지 않아도 static 메소드에 접근하여 호출할 수 있다.</li>
<li>효율적으로 메모리와 시간을 컨트롤할 수 있다.</li>
<li><strong>클래스 메소드는 인스턴스 변수를 사용하지 않고 전달된 매개변수만으로 동작하는 메소드이다.</strong></li>
<li>클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다. 이유는 인스턴스 변수는 인스턴스가 생성될 때 사용할 수 있도록 메모리에 할당되기 때문이다.</li>
</ul>
<p>클래스는 메소드보다 먼저 존재한다. 클래스는 컴파일 과정에서 이미 메모리에 올라가게 된다. 그리고 클래스를 기반으로 인스턴스를 생성하게 된다.</p>
<p>인스턴스 멤버는 인스턴스가 생성되면 사용할 수 있도록 메모리에 올라가게 된다. 클래스 메소드는 인스턴스 생성과 관계 없이 접근할 수 있다. 생성되지 않은 인스턴스는 메모리에 없다. 클래스 메소드가 메모리에 없는 인스턴스 변수에 접근하기 때문에 오류가 발생한다. 이러한 이유로 <strong>클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다.</strong></p>
<p><strong>메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려해볼만 합니다. 메소드 호출 시간이 짧아지므로 성능이 향상됩니다.</strong></p>
<p><strong>예제</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123; <span class="comment">// 인스턴스 메소드</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 클래스 메소드</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Method.add(<span class="number">10</span>, <span class="number">100</span>));</span><br><span class="line">        Method method = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(method.add());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<h1 id="필드의-초기화"># 필드의 초기화</h1>
<ul>
<li>필드를 초기화하지 않으면 변수 타입에 맞는 초기값으로 자동 초기화된다.</li>
<li>하지만 지역 변수와 마찬가지로 적절한 값으로 초기화한 후에 사용하는 것이 좋다.</li>
</ul>
<p>필드 초기화 방법</p>
<ol>
<li>명시적 초기화
<ul>
<li>지역 변수를 초기화하는 방법과 마찬가지로 필드를 선언과 동시에 초기화하는 방법이다.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>생성자를 이용한 초기화
<ul>
<li>객체의 생성과 동시에 필드를 초기화하는 방법이다. 따라서 이 방법은 인스턴스를 생성할 때까지는 필드를 초기화할 수 없다.</li>
</ul>
</li>
<li>초기화 블록을 이용한 초기화
<ul>
<li>클래스 필드의 초기화만을 담당하는 중괄호({})로 둘러싸인 블록을 의미한다. 초기화 블록은 생성자보다 먼저 호출되며, static 키워드의 유무에 따라 구분할 수 있다.
<ul>
<li>static 키워드 X : 인스턴스 초기화 블록</li>
<li>static 키워드 O : 클래스 초기화 블록</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>초기화 블록에는 다양한 명령문 및 제어문을 사용할 수 있으므로, 복잡한 초기화를 해야할 경우 유용하게 사용된다.</p>
<ul>
<li>인스턴스 초기화 블록</li>
</ul>
<p>단순히 중괄호만을 사용하여 정의 가능.<br>
생성자와 마찬가지로 인스턴스가 생성될 때 실행된다.<br>
하지만 인스턴스 초기화 블록이 생성자보다 먼저 실행된다.<br>
차이가 거의 없어 잘 사용되지 않는다.<br>
다만 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있다.(사용해본 적이 없다.)</p>
<ul>
<li>클래스 초기화 블록</li>
</ul>
<p><code>static</code> 키워드를 초기화 블록 앞에 정의한다.<br>
<strong>클래스가 처음으로 메모리에 로딩될 때 단 한 번만 실행된다.</strong><br>
생성자나 인스턴스 초기화 블록으로 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar;</span><br><span class="line">    <span class="keyword">int</span> instanceVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인스턴스 초기화 블록</span></span><br><span class="line">    &#123;</span><br><span class="line">        classVar = <span class="number">11</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클래스 초기화 블록 </span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        classVar = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">        instanceVar = <span class="number">20</span>; <span class="comment">// 2 : 오류 발생</span></span><br><span class="line">    &#125;</span><br><span class="line">    Method()&#123;</span><br><span class="line">        classVar = <span class="number">100</span>; <span class="comment">// 3 </span></span><br><span class="line">        <span class="keyword">this</span>.instanceVar = <span class="number">200</span>; <span class="comment">// 4 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method m = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(Method.classVar);</span><br><span class="line">        System.out.println(m.classVar);</span><br><span class="line">        System.out.println(m.instanceVar);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">결과 </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>1 : 클래스 초기화 블록을 이용한 클래스 변수의 초기화는 수행된다.<br>
2 : 클래스 초기화 블록을 이용한 인스턴스 변수의 초기화는 에러가 발생한다.<br>
3 : 생성자를 이용한 클래스 변수의 초기화는 수행된다.<br>
4 : 생성자를 이용한 인스턴스 변수의 초기화는 수행된다.</p>
<p>정리하면, 클래스 변수는 클래스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다. 그리고 인스턴스 변수는 인스턴스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다.</p>
<p>클래스 초기화 블록이 먼저 실행되고 그 다음으로는 인스턴스 초기화 블록이 실행된다. 가장 나중에는 생성자가 실행된다. 이 경우 위의 3가지 방법을 모두 이용해 초기화를 한다면 비효율적이다.</p>
<p>왜냐하면 어차피 제일 나중에 생성자를 위한 초기화가 반영되기 때문이다. 그래서 초기화할 때는 용도나 상황에 맞게 적절하게 사용하는 것이 중요하다.</p>
<p><strong>필드의 초기화 순서 예시</strong></p>
<ol>
<li>클래스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블록</li>
<li>인스턴스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블록 -&gt; 생성자</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitBlack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클래스를 참조할 때 실행된다. </span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        classVar = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        instanceVar = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InitBlack()&#123;</span><br><span class="line">        instanceVar = <span class="number">30</span>;</span><br><span class="line">        classVar = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 : "</span>+InitBlack.classVar);</span><br><span class="line">        InitBlack initBlack = <span class="keyword">new</span> InitBlack();</span><br><span class="line">        System.out.println(<span class="string">"인스턴스 변수 : "</span>+initBlack.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 - 생성자를 이용한 초기화한 후"</span>);</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 : "</span>+InitBlack.classVar);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">클래스 변수 : <span class="number">20</span></span><br><span class="line">인스턴스 변수 : <span class="number">30</span></span><br><span class="line">클래스 변수 - 생성자를 이용한 초기화한 후</span><br><span class="line">클래스 변수 : <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>같은 필드를 여러 번 초기화하면 제일 마지막으로 초기화한 값만 남게된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/13/java-basic-8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/12/java-basic-7/"
                            aria-label=": [Java] 7. 제어자"
                        >
                            [Java] 7. 제어자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-12T17:14:53+09:00">
	
		    Aug 12, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><strong>제어자</strong>는 클래스와 멤버 선언 시 사용해 부가적인 의미를 부여하는 키워드.
<ul>
<li>접근 제어자 : 두 개 이상 사용 불가.</li>
<li>기타 제어자 : 여러 개 함께 사용 가능.</li>
</ul>
</li>
</ul>
<h1 id="접근-제어자"># 접근 제어자</h1>
<ul>
<li>정보 은닉을 위해 접근 제어자 기능을 제공한다.
<ul>
<li><strong>정보 은닉</strong> : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념.</li>
</ul>
</li>
<li>클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정해 정보 은닉을 구체화할 수 있다.</li>
</ul>
<p>자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다.</p>
<ol>
<li>private</li>
<li>public</li>
<li>default</li>
<li>protected</li>
</ol>
<p><strong>1. private</strong></p>
<p><strong>private 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없다.</li>
<li>자바 프로그램은 private 멤버에 직접 접근할 수 없으며,<br>
해당 객체의 <strong>public 메소드</strong>를 통해서만 접근할 수 있다.<br>
따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는데 사용된다.</li>
</ul>
<img src="/img/private.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">"이승우"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>private 멤버는 해당 멤버를 선언한 클래스에서만 접근할 수 있다.</li>
<li>다른 클래스에서 Person 클래스의 name에 접근하고자 할 때는 2와 같이 Person 클래스에 <strong>public</strong>으로 메소드를 선언하여 private로 선언된 name에 접근할 수 있다.</li>
<li>1과 같이 메소드를 private로 선언하게 된다면, 다른 클래스에서 Person 클래스의 name에 접근할 수 없다.</li>
</ul>
<p><strong>2. public</strong></p>
<p><strong>public 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.</li>
<li>자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다. public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행한다.</li>
</ul>
<img src="/img/public.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EveryWhere</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String var = <span class="string">"누구든지 허용"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. default(package-private)</strong></p>
<ul>
<li>클래스 및 클래스 멤버의 접근 제어 기본값으로 <strong>default 접근 제어자</strong>를 사용한다.</li>
<li>접근 제어자가 지정되지 않으면 default 접근 제어자를 자동으로 갖는다.</li>
</ul>
<p>default 접근 제어를 가지는 멤버는</p>
<ul>
<li>같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있습니다.</li>
<li>상속 관계에 있더라도 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<img src="/img/default.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지만 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamePackage</span></span>&#123;</span><br><span class="line">    String sameVar = <span class="string">"같은 패키지는 허용"</span>; <span class="comment">// default 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">같은 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    String var = <span class="string">"다른 패키지는 접근 불가"</span>; <span class="comment">// 1 : default 필드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SamePackage sp = <span class="keyword">new</span> SamePackage();</span><br><span class="line">        System.out.println(sp.sameVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1에서 var 변수는 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<p><strong>4. protected</strong></p>
<p>자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축한다. 여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다.</p>
<p><strong>protected 멤버는</strong></p>
<ul>
<li>부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됩니다.</li>
<li>상속 관계에 있을 경우 다른 패키지에서도 접근 가능.</li>
<li>상속 관계가 아닌 경우 다른 패키지에서 접근 불가능.</li>
</ul>
<p>클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다.</p>
<ol>
<li>이 멤버를 선언한 클래스의 멤버</li>
<li>이 멤버를 선언한 클래스가 속한 패키지의 멤버</li>
<li>이 멤버를 선언한 클래스를 상속받은 자식 클래스(child class)의 멤버</li>
</ol>
<img src="/img/protected.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지는 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String sameVar = <span class="string">"다른 패키지에 속하는 자식 클래스까지 허용"</span>;</span><br><span class="line">    <span class="comment">// protected 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">다른 패키지에 속하는 자식 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test.other;</span><br><span class="line"><span class="keyword">import</span> test.SameClass;</span><br><span class="line"><span class="comment">// test 패키지의 SameClass 클래스를 불러들여 포함시킴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SameClass sameClass = <span class="keyword">new</span> SameClass();</span><br><span class="line">        System.out.println(sameClass.sameVar);</span><br><span class="line">        <span class="comment">// 다른 패키지에 속하는 자식 클래스까지 허용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="접근-제어자의-접근-범위"># 접근 제어자의 접근 범위</h2>
<p>자바에서 접근 제어자의 접근 범위가 보다 많은 제어자부터 적은 제어자 순으로 나열하면 다음과 같다.<br>
자바에서는 클래스나 멤버를 선언할 때, 접근을 허용할 범위에 맞는 접근 제어자를 선택하는 것이 매우 중요하다.</p>
<p>public -&gt; protected -&gt; default -&gt; private</p>
<img src="/img/range.png" width="600" height="200">
<h1 id="기타-제어자"># 기타 제어자</h1>
<p>기타 제어자의 종류로는 다음과 같습니다.</p>
<ol>
<li>final 제어자</li>
<li>static 제어자</li>
<li>abstract 제어자</li>
</ol>
<p><strong>1.final</strong></p>
<ul>
<li><strong>final 제어자</strong>는 '변경할 수 없다’는 의미로 사용된다.</li>
<li>즉, 필드나 지역 변수에 사용하면 값을 변경할 수 없는 <code>상수(constant)</code>가 된다.</li>
<li>클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없다.</li>
<li>메소드에 사용하면 오버라이딩을 통한 재정의를 할 수 없다.</li>
<li>자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드, 필드, 지역 변수</li>
</ul>
</li>
</ul>
<p>?? 어디지??<br>
<code>메소드 오버라이딩</code>이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다.</p>
<p>자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속받을 수 있습니다. 이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 <strong>재정의</strong>하여 사용할 수도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> VAR; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> MAX_NUM = <span class="number">10.2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : Car 클래스는 <strong>상속을 통해 서브 클래스를 생성할 수 없다.</strong><br>
2 : VAR 필드는 <strong>상수화</strong>되어 값을 변경할 수 없다.<br>
3 : 이 메소드는 오버라이딩을 통해 재정의할 수 없다.<br>
4 : 이 지역 변수는 상수화되어 값을 변경할 수 없다.</p>
<p><strong>2.static</strong></p>
<ul>
<li>변수에 static 제어자를 사용하면 클래스 변수가 된다.</li>
<li>메소드에 static 제어자를 사용하면 클래스 메소드가 된다.</li>
<li>특징
<ol>
<li>프로그램 시작시 최초에 단 한 번만 생성되고 초기화 된다.</li>
<li>인스턴스를 생성하지 않고도 바로 사용할 수 있다.</li>
<li>해당 클래스의 모든 인스턴스가 공유한다.</li>
</ol>
</li>
<li>자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같습니다.
<ul>
<li>메소드, 필드, 초기화 블록</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">static</span>&#123; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 클래스 필드(static 변수) - Car 클래스의 인스턴스들이 공유한다.<br>
2 : static 초기화 블록으로 보통 클래스 필드의 초기화를 진행<br>
3 : 클래스 메소드(static 메소드)</p>
<p><strong>3.abstract</strong></p>
<ul>
<li>abstract 제어자는 '추상적인’이라는 의미로 사용된다.</li>
<li>선언부만 있고 구현부가 없는 메소드를 <strong>추상 메소드</strong>라 하며, 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>하나 이상의 추상 메소드를 포함하고 있는 추상 클래스도 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 추상 클래스<br>
2 : 추상 메소드</p>
<h2 id="제어자의-조합"># 제어자의 조합</h2>
<ul>
<li>접근 제어자와 기타 제어자를 한 대상에 사용할 수 있다.</li>
<li>모든 경우가 가능한 것은 아니며 대상에 따라 조금 다르다.</li>
</ul>
<img src="/img/combination_2.png" width="500" height="200">
<ol>
<li>
<p>클래스에서 final과 abstract는 함께 사용할 수 없다.<br>
<strong>final</strong> 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, <strong>abstract</strong> 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용할 수 있으므로, 상반된 이 두 제어자는 클래스에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 static과 abstract는 함께 사용할 수 없다.<br>
<strong>abstract</strong> 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, <strong>static</strong> 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private과 abstract는 함께 사용할 수 없다.<br>
: <strong>abstract</strong> 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, <strong>private</strong> 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private와 final은 함께 사용할 필요가 없다.<br>
메소드에 사용된 <strong>final</strong> 제어자와 <strong>private</strong> 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없게 된다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있습니다.</p>
</li>
</ol>
<blockquote>
<p>private 제어자를 사용한 메소드에는 자식 클래스가 접근할 수 없으므로 메소드 오버라이딩을 통한 재정의를 할 수 없다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/12/java-basic-7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/10/java-basic-6/"
                            aria-label=": [Java] 6. 메소드와 생성자"
                        >
                            [Java] 6. 메소드와 생성자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-10T15:31:15+09:00">
	
		    Aug 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="메소드"># 메소드</h1>
<ul>
<li>클래스의 멤버 중 기능을 표현하는 <strong>메소드</strong></li>
<li>특정 작업을 수행하기 위한 명령문의 집합</li>
<li>중복되는 코드의 작성을 피할 수 있다.</li>
<li>모듈화로 인해 가독성이 좋아진다.</li>
<li>유지보수 또한 쉽다.</li>
</ul>
<blockquote>
<p>메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다.</p>
</blockquote>
<p><strong>메소드의 정의 및 호출</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSpeed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accelerationTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accelerate</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">int</span> second)</span></span>&#123; <span class="comment">// 선언부</span></span><br><span class="line">        System.out.println(second + <span class="string">"초간 속도를 시속 "</span> + speed + <span class="string">"(으)로 가속함!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();<span class="comment">// 객체 생성</span></span><br><span class="line">    myCar.acceleratea(<span class="number">60</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 메소드 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>메소드 시그니처</strong>란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킨다.<br>
만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면 이 두 메소드의 시그니처는 같다고 할 수 있다.</li>
<li>메소드를 호출할 때 멤버 참조 연산자(.)를 사용하여 호출한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 객체참조변수이름.메소드이름(); <span class="comment">// 매개변수가 없는 메소드의 호출</span></span><br><span class="line"><span class="number">2</span>. 객체참조변수이름.메소드이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...); <span class="comment">// 매개변수가 있는 메소드의 호출</span></span><br></pre></td></tr></table></figure>
<h1 id="생성자"># 생성자</h1>
<p>클래스로부터 객체를 생성하면 해당 객체는 즉시 메모리에 생성된다.<br>
하지만 이 객체는 모든 인스턴스 변수가 초기화되지 않은 상태이다.<br>
클래스 변수와 인스턴스 변수를 별도로 초기화하지 않으면 타입에 맞는 값으로 자동 초기화된다.</p>
<p>사용자가 원하는 값으로 인스턴스 변수를 초기화하려면 일반적인 초기화 방식으로는 할 수 없다. private 변수도 있기 때문이다.<br>
따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 <strong>public</strong> 메소드가 필요하다.</p>
<p>초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 한다.</p>
<p>자바에서 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 <code>생성자(constructor)</code>라는 메소드를 제공한다. <strong>생성자의 이름은 해당 클래스의 이름과 같아야 한다.</strong></p>
<ol>
<li><strong>생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.</strong></li>
<li>생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.</li>
<li>객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, <strong>메소드 오버로딩</strong>이 가능하다.</li>
<li>생성자는 인스턴스 생성 시 딱 한번 호출되는 메소드이다.</li>
<li>return문도 정의되어 있지 않다.</li>
</ol>
<p><strong>생성자의 선언</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 클래스이름()&#123; ... &#125; <span class="comment">// 매개변수가 없는 생성자 선언</span></span><br><span class="line"><span class="number">2</span>. 클래스이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...)&#123; ... &#125; <span class="comment">// 매개변수가 있는 생성자 선언</span></span><br></pre></td></tr></table></figure>
<p><strong>생성자의 호출</strong></p>
<ul>
<li><strong>new</strong> 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 생성자</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 객체 생성 및 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="기본-생성자">기본 생성자</h2>
<p>모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다. 하지만, <strong>특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다.</strong> 자바 컴파일러가 <code>기본 생성자(default constructor)</code>를 기본적으로 제공해주기 때문이다.</p>
<ul>
<li>기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다.</li>
<li>자바 컴파일러가 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 기본 생성자를 추가한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">기본생성자 : 클래스이름()&#123;&#125; </span><br><span class="line">예시 : Car()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다. 다음 코드는 Car 클래스에 생성자를 정의하지 않고, 기본 생성자를 호출하는 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(); <span class="comment">// 기본 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 Car 클래스의 객체인 myCar는 기본 생성자를 호출하여 생성된다. Car 클래스에 기본 생성자가 존재하지 않는다. 기본 생성자가 없을 경우 자바 컴파일러가 컴파일 시 자동으로 생성해준다.</p>
<p>기본 생성자는 아무 동작도 하지 않는다. 따라서 인스턴스 변수를 클래스 필드에서 바로 초기화할 수 있다. <strong>인스턴스 변수의 초기화는 생성자를 사용하거나 클래스 필드에서 수행할 수 있다.</strong></p>
<p>만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않는다. 따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생한다. 이 경우에는 기본 생성자를 직접 추가해줘야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 2. 객체 생성 및 생성자의 호출</span></span><br><span class="line">        Car yourCar = <span class="keyword">new</span> Car(); <span class="comment">// 3. 기본 생성자의 호출 -&gt; 오류 발생</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 갖는 생성자를 정의하고 있다. 따라서 자바 컴파일러는 Car 클래스에 기본 생성자를 추가하지 않는다.</li>
<li>3번에서 기본 생성자를 호출하여 인스턴스를 생성하려고 한다. 자바 컴파일러가 오류를 발생시킨다. 오류를 발생을 없애기 위해서는 Car 클래스에 기본 생성자를 추가하면 된다.</li>
</ul>
<h1 id="this와-this"># this와 this()</h1>
<ul>
<li>this 참조 변수 : <strong>인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수이다.</strong> this 참조 변수는 해당 인스턴스의 주소를 가리키고 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 <strong>인스턴스 변수 앞에 this 키워드를 붙여 구분해야 한다.</strong></p>
<p>자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다. this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다. 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다.</p>
<ul>
<li>this() 메소드 : <strong>this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용한다.</strong> this() 메소드에 인수를 전달하면 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해줍니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"소나타"</span>;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Car()&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">33</span>,<span class="string">"그랜져"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">    System.out.println(myCar.getModel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 가지는 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근한다.</li>
<li>또한, 매개변수를 가지지 않은 기본 생성자는 내부에서 this() 메소드를 사용하여 매개 변수를 가진 생성자를 호출한다.</li>
<li>이처럼 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있다.</li>
</ul>
<blockquote>
<p>단, 한 생성자에서 다른 생성자를 호출할 때는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있습니다.</p>
</blockquote>
<h1 id="메소드-오버로딩"># 메소드 오버로딩</h1>
<ul>
<li>핵심은 <code>메소드 시그니처</code>
<ul>
<li>메소드 시그니처 : 메소드의 선언부에 명시되는 매개변수의 리스트를 말한다.</li>
<li>두 메소드의 매개변수의 개수와 타입, 그 순서까지 모두 같다면 두 메소드의 시그니처는 같다고 할 수 있다.</li>
</ul>
</li>
<li><strong>메소드 오버로딩</strong>은 같은 이름의 메소드를 매개변수의 개수와 타입을 다르게하여(중복) 정의하는 것이다.</li>
</ul>
<p><strong>즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이다.</strong></p>
<p>메소드 오버로딩을 통해 메소드에 사용되는 이름을 절약할 수 있다.<br>
또한, 메소드를 호출할 때 전달할 매개변수의 타입이나 개수에 대해 신경 쓰지 않아도 된다. <strong>메소드 오버로딩은 OOP의 특징 중 하나인 다형성의 한 예다.</strong></p>
<ul>
<li>메소드 오버로딩의 대표적인 예 : <code>println()</code>
<ul>
<li>전달받은 매개변수의 타입에 따라 다양한 원형 중 적절한 원형을 호출한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">메소드 원형</span><br><span class="line"><span class="number">1</span>. println()</span><br><span class="line"><span class="number">2</span>. println(<span class="keyword">boolean</span> x)</span><br><span class="line"><span class="number">3</span>. println(<span class="keyword">char</span> x)</span><br><span class="line"><span class="number">4</span>. println(<span class="keyword">char</span>[] x)</span><br><span class="line"><span class="number">5</span>. println(<span class="keyword">double</span> x)</span><br><span class="line"><span class="number">6</span>. println(<span class="keyword">float</span> x)</span><br><span class="line"><span class="number">7</span>. println(<span class="keyword">int</span> x)</span><br><span class="line"><span class="number">8</span>. println(<span class="keyword">long</span> x)</span><br><span class="line"><span class="number">9</span>. println(Object x)</span><br><span class="line"><span class="number">10</span>. println(String x)</span><br></pre></td></tr></table></figure>
<p><strong>메소드 오버로딩의 조건</strong></p>
<ol>
<li>메소드의 이름이 같아야 한다.</li>
<li>메소드의 시그니처 즉, 매개변수의 개수와 타입이 달라야 한다.</li>
</ol>
<ul>
<li><strong>메소드 오버로딩은 반환 타입과는 관계가 없다.</strong></li>
<li><strong>메소드의 시그니처는 같은데 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않는다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 전달받은 숫자 그대로 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1)</span></span>&#123; </span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 두 정수의 곱 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1*num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 정수와 실수의 합 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    test.display(<span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 2</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">3.14</span>); <span class="comment">// 3</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="string">'a'</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 사용자가 오버로딩된 함수를 호출하면 같은 메소드 시그니처를 갖는 메소드를 찾아서 호출한다.</li>
</ul>
<p>4번에서 문제가 발생한다. 자바에서 char형 데이터는 int형 뿐만 아니라 double형으로도 타입 변환될 수 있기 때문이다.</p>
<p>이 호출은 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출해야 할 지 불명확하다. 자바에서는 오버로딩한 메소드의 이러한 모호한 호출을 허용하지 않으며, 위와 같은 경우에는 <strong>더 작은 표현 범위를 가지는 int형으로 자동 타입 변환된다.</strong></p>
<p>4번 라인의 display() 메소드 호출은 영문 소문자 'a’의 아스키 코드값이 97이므로, int형으로 자동 타입 변환되어 두 수의 곱이 출력된다.</p>
<h1 id="재귀-호출"># 재귀 호출</h1>
<ul>
<li><code>재귀 호출(recursive call)</code>이란 메소드 내부에서 해당 메소드가 또 다시 호출되는 것을 의미한다.</li>
<li><strong>메소드 내에 재귀 호출을 중단하도록 조건이 변경된 명령문을 반드시 포함해야 한다.</strong></li>
</ul>
<p><strong>재귀 호출의 개념</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        result+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재귀 호출을 사용하지 않고 반복문으로 만든 메소드이다.</li>
<li>규칙</li>
</ul>
<ol>
<li>1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다.</li>
<li>1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다.</li>
<li>1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다.</li>
<li>1부터 1까지의 합은 그냥 1입니다.</li>
</ol>
<p>위의 알고리즘을 의사코드(psedo code)로 작성하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">시작</span><br><span class="line">    <span class="number">1</span>. n이 <span class="number">1</span>이 아니면, n과 <span class="number">1</span>부터 (n-<span class="number">1</span>)까지의 합을 더한 값을 반환함</span><br><span class="line">    <span class="number">2</span>. n이 <span class="number">1</span>이면, 그냥 <span class="number">1</span>을 반환함</span><br><span class="line">끝</span><br></pre></td></tr></table></figure>
<blockquote>
<p>의사 코드(psedo code)란 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드를 말한다.</p>
</blockquote>
<p>의사 코드로 작성하고 바로 코드로 옮겨서 재귀 호출을 구현한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursiveSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">// n이 1이면, 그냥 1을 반환</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n+recursiveSum(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 문이 존재하지 않으면, 이 프로그램은 실행 직후 <code>스택 오버플로우(stack overflow)</code>에 의해 종료될 것이다. 따라서 if문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.</p>
<blockquote>
<p>스택 오버플로우는 메모리 구조 중 스택 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/10/java-basic-6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/archives/2/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/archives/4/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 3 of 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
