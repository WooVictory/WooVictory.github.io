
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Category: Java - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/categories/Java/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/26/Java-Singleton-Pattern/"
                            aria-label=": 6일차 [Java] Singleton"
                        >
                            6일차 [Java] Singleton
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-26T12:52:38+09:00">
	
		    Jan 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>싱글톤 패턴을 사용함에 있어서 효율적인 holder에 의한 방식을 사용해서 구현했는데, 이 방법이 나오기까지 전의 방법들을 까먹어서 설명하기 힘들었다. 그래서 다시 상기하고자 간단하게 정리를 하려고 한다.</p>
<p>이전에 정리한 <a href="https://woovictory.github.io/2019/01/04/Android-What-is-Singleton-Pattern/">싱글톤 패턴</a>에 관한 글이 궁금하다면 참고하면 좋겠다.</p>
<h2 id="1-eager-initialization이른-초기화-방식">1. Eager initialization(이른 초기화 방식)</h2>
<p>Singleton의 가장 기본적인 Eager initialization 방식이다. 먼저, 클래스 내에 전역 변수로 instance 변수를 생성하고 private static을 사용하여 인스턴스화에 상관없이 접근이 가능하면서 동시에 private 접근 제어 키워드를 사용해 <code>EageInitialization.instance</code>로 바로 접근 할 수 없도록 한다.</p>
<p>또, 생성자에도 pirvate 접근 제어 키워드를 붙여 다른 클래스에서 new EageInitialization(); 방식으로 새로운 인스턴스를 생성하는 것을 방지한다. 오로지 정적 메소드인 getInstance() 메소드를 이용해서 인스턴스를 접근하도록 하여 유일무이한 동일 인스턴스를 사용하는 기본 싱글톤 원칙을 지키게 한다.</p>
<p>이른 초기화 방식은 싱글톤 객체를 미리 생성해 놓는 방식이다. 항상 싱글톤 객체가 필요하거나 객체 생성 비용이 크게 들어가지 않는 경우에 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitialization</span></span>&#123;</span><br><span class="line">    <span class="comment">// private static으로 선언(전역 변수)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerInitialization instance = <span class="keyword">new</span> EagerInitialization();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private한 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitialization</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitialization <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>장점 : static으로 생성된 변수에 싱글톤 객체를 선언했기 때문에 클래스 로더에 의해 클래스가 로딩될 때 싱글톤 객체가 생성된다. 또 클래스 로더에 의해 클래스가 최초 로딩될 때 객체가 생성됨으로 Thread-safe하다.</li>
<li>단점 : 싱글톤 객체 사용 유무와 관계 없이 클래스가 로딩되는 시점에 항상 싱글톤 객체가 생성되고, 메모리를 잡고 있기 때문에 비효율적이다.</li>
</ul>
<h2 id="2-lazy-initialization늦은-초기화-방식">2. Lazy initialization(늦은 초기화 방식)</h2>
<p>Eager initialization(이른 초기화 방식)과 정반대로 클래스가 로딩되는 시점이 아닌 클래스의 인스턴스가 사용되는 시점에서 싱글톤 인스턴스를 생성한다. 즉, 사용 시점까지 싱글톤 객체 생성을 미루기 때문에 사용하기 전까지 메모리를 점유하지 않는다. <code>getInstacne()</code> 메소드 안에서 instance가 null인 경우에만 new LazyInitialization()으로 싱글톤 객체를 할당한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitialization</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitialization instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitialization</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitialization <span class="title">getInstanc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            intance = <span class="keyword">new</span> LazyInitialization();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>장점 : 싱글톤 객체가 필요할 때 인스턴스를 얻을 수 있다. Eager initialization 방식의 단점을 보완한 수 있다.(메모리 누수!)</li>
<li>단점 : 만약 multi-thread 환경에서 어려 곳에서 동시에 getInstance() 메소드를 호출할 경우 인스턴스가 두 번 생성될 여지가 있다. 즉, multi-thread 환경에서는 싱글톤 철학이 깨질 수 있는 위험이 있다.</li>
</ul>
<h2 id="3-thread-safe-lazy-initializtion스레드-안전-늦은-초기화">3. Thread safe Lazy initializtion(스레드 안전 늦은 초기화)</h2>
<p>Lazy initializtion 방식에서는 multi-thread 환경에서 thread-safe 하지 않다는 단점을 보완하기 위해서 멀티 스레드에서 스레드들이 동시 접근하는 동시성을 <code>synchronized</code> 키워드를 이용해 해결한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ThreadSafeLazyInitialization&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeLazyInitialization intance;</span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeLazyInitialization</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ThreadSafeLazyInitialization <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            intance = <span class="keyword">new</span> ThreadSafeLazyInitialization();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>장점 : 위에서 언급한 듯이 Lazy initialization 방식에서 thread-safe 하지 않은 점을 보완한다.</li>
<li>단점 : synchronized 키워드를 사용할 경우 자바 내부적으로 해당 영역이나 메소드를 lock, unlock 처리하기 때문에 많은 cost가 발생한다. 대략 100배 정도 비효율적이라고 한다. 따라서 많은 thread들이 getInstance()를 호출하게 되면 프로그램 전반적인 성능 저하가 발생한다.</li>
</ul>
<h2 id="3-1-thread-safe-lazy-initialization-double-checked-locking-기법">3-1. Thread safe Lazy initialization + Double-checked locking 기법</h2>
<p>위에서 Thread safe Lazy initialization을 보았다. 많은 스레드들이 동시에 synchronized 처리된 메소드를 접근하면 성능저하가 발생된다고 했다. 이를 좀 더 완화하기 위해서 Double-checked locking 기법을 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeLazyInitialization</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadSafeLazyInitialization instance;</span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeLazyInitialization</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeLazyInitialization <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Double-checked locking</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeLazyInitialization.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ThreadSafeLazyInitialization();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>첫 번째 if문에서 instance가 null인 경우 synchronized 블록에 접근하고 한 번 더 if문으로 instance가 null인지 유무를 체크한다. 2번 모두 다 instance가 null인 경우에 new를 통해 인스턴스화 시킨다. 그 후에 instance가 null이 아니기 때문에 synchronized 블록을 타지 않는다. 이런 DCL 기법을 통해 성능 저하를 보완할 수 있다.</li>
</ul>
<h2 id="4-initialization-on-demand-holder-idiomholder에-의한-초기화">4. Initialization on demand holder idiom(holder에 의한 초기화)</h2>
<p>이 방법은 클래스 안에 클래스(Holder)를 두어 JVM의 Class Loader 매커니즘과 Class가 로드되는 시점을 이용한 방법이다. Lazy initialization 방식을 가져가면서 Thread간 동기화 문제를 동시에 해결할 수 있다.</p>
<p>로직은 InitializationOnDemandHolderIdiom 클래스에는 SingleTonHolder 클래스의 변수가 없기 때문에 InitializationOnDemandHolderIdiom 로딩시 SingleTonHolder 클래스를 초기화하지 않는다.</p>
<p>중첩 클래스(static으로 선언됨.) SingleTonHolder는 getInstance 메소드가 호출되기 전에는 참조되지 않으며, 최초로 getInstance() 메소드가 호출될 때  SingleTonHolder.instance를 참조하는 순간 클래스 로더에 의해 Class가 로딩되며 초기화되며, 싱글톤 객체를 생성하여 리턴한다.</p>
<p>또한, SingleTonHolder 안에 선언된 instance가 static이기 때문에 클래스 로딩 시점에 한 번만 호출된다. 그리고 final을 사용하기 때문에 다시 값이 할당되지 않도록 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationOnDemandHolderIdiom</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InitializationOnDemandHolderIdiom instante;</span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InitializationOnDemandHolderIdiom</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InitializationOnDemandHolderIdiom INSTANCE = <span class="keyword">new</span> InitializationOnDemandHolderIdiom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InitializationOnDemandHolderIdiom <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>현재까지 가장 많이 사용되는 방법으로 알려져 있다. 그만큼 지금까지 나온 방법 중 가장 효율적인 방법이라고 한다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://limkydev.tistory.com/67" target="_blank" rel="noopener">[Design_Pattern] Singleton(싱글톤)의 고도화</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/26/Java-Singleton-Pattern/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/04/Java-What-is-Marker-interface/"
                            aria-label=": [Java] 마커인터페이스"
                        >
                            [Java] 마커인터페이스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-04T15:35:44+09:00">
	
		    Jan 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>직렬화할 때 사용하는 방법 중에 Serializable과 Parcelable 두 개가 있다.<br>
그 중에서 Serializable을 공부하던 중 이것이 마커 인터페이스라고 부르는 것을 보았다.<br>
그래서 생긴 의문은 도대체 <strong>마커 인터페이스</strong>는 무엇인가</p>
<h2 id="마커-인터페이스">마커 인터페이스</h2>
<p>자바의 마커 인터페이스는 일반적인 인터페이스와 동일하지만 사실상 아무 메소드도 선언하지 않은 인터페이스를 말한다. 예를 들면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomethingObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>얼핏 보기엔 난해한 코드이다. 인터페이스만 있고 메소드가 없으니 어디에다 쓸지도 난해하다. 자바로 코딩을 하다보면 저런 인터페이스가 종종 있다. 자바의 대표적인 마커 인터페이스로는 위에서 언급한 <strong>Serializable, Cloneable</strong>과 흔히 알지는 못하지만 Spring에서 event 리스너를 사용한다면 종종 보이는 <strong>EventListener</strong>라는 인터페이스도 있다.</p>
<p>뭔가 대단한 것처럼 보일수도 있지만 실질적으로는 간단하다. 대부분의 경우에는 <strong>단순한 타입 체크</strong>라고 할 수 있다. 자바의 대표적인 마커 인터페이스인 Serializable를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>메소드가 한개도 선언되어 있지 않다. Serializable 인터페이스 같은 경우에는 직렬화를 할 수 있다는 뜻이다. 즉, 이 인터페이스를 구현하지 않은 클래스의 경우에는 직렬화를 하지 못한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializableTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">  File f= <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">  ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">  objectOutputStream.writeObject(<span class="keyword">new</span> SomeObject(<span class="string">"wonwoo"</span>, <span class="string">"test@test.com"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">  <span class="comment">//생성자 및 기타 메서드 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드를 실행하면 아래와 같은 에러가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.NotSerializableException: me.wonwoo.SomeObject</span><br></pre></td></tr></table></figure>
<p>이는 직렬화를 할 수 있는 Serializable을 구현하지 않았기 때문이다. 그렇다면 직렬화를 할 수 있도록 Serializable 인터페이스를 구현해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>간단하게 구현할 수 있다. 인터페이스의 메소드도 없으니 구현할 메소드도 필요 없다. 그냥 선언만 해주면 된다. 그럼 위에서 사용했던 <code>writeObject()</code> 메소드 안을 들여다 보자. writeObject() 메소드 안에는 writeObject0()가 존재한다. 이 메소드 맨 아래에 보면 다음과 같은 코드가 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">  writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">  writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">  writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">  writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">      cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>이 코드에는 if문이 꽤 있다. 보면 String은 Serializable을 구현했으니 되고 배열도 Serializable 할 수 있고 Enum도 Serializable를 구현했으니 되고 다음으로는 Serializable가 되어있는지 체크하는 부분이다. 만약 Serializable가 없다면 에러로 처리한다. 위에서 보았듯이 간단하게 Serializable가 선언되었는지 안되어 있는지 <strong>체크 정도만</strong>한다. 실질적으로 뭘 하는 건 아니다. 그래서 <strong>마커 인터페이스</strong>라고 부른다.</p>
<p>마커 인터페이스는 어노테이션으로도 대체 가능하다. 만약 @SomeAnnotation이라는 어노테이션이 있다면 아래와 같이 가져와서 체크하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SomeAnnotation someAnnotation = someObject.getClass().getAnnotation(SomeAnnotation.class);</span><br></pre></td></tr></table></figure>
<p>그럼 마커 인터페이스와 마커 어노테이션의 차이를 살펴보자.<br>
마커 인터페이스 같은 경우에는 <strong>컴파일 시점</strong>에 발견할 수 있다는 큰 장점이 있다. 그리고 또한 적용 범위를 좀 더 세밀하게 지정할 수 있다.</p>
<p>만약 어노텡션 자료형을 선언할 때 target에 <strong>ElementType.TYPE</strong>라고 지정해서 사용한다고 하면 <strong>ElementType.TYPE</strong>은 클래스 뿐만 아니라 인터페이스에도 적용 가능하다. 그런데 특정한 인터페이스를 구현한 클래스에만 적용할 수 있어야 하는 마커가 필요하다고 가정해보자.</p>
<p>마커 인터페이스를 쓴다면 그 특정 인터페이스를 상속하도록 선언만 하면 된다. 그럼 마커를 상속한 모든 자료형은 자동으로 그 특정 인터페이스의 하위 자료형이 된다.</p>
<p>그렇다면 마커 어노테이션의 장점은 뭘까? 마커 어노테이션은 <strong>유연하게 확장이 가능</strong>하다. 어노테이션을 만들어 사용한 뒤에도 계속적으로 더 많은 정보를 추가할 수 있는 것이 큰 장점이다.</p>
<p>예를 들어, 어떤 어노테이션을 만들고 배포를 한 뒤에 뭔가 더 정보를 추가하고 싶다면 새로 추가된 요소들에 대해 <code>default</code> 값을 갖게 하면 하위 호환성도 지킬 수 있으면 처음에는 마커 어노테이션으로 시자갷ㅆ다가 나중에는 기능이 많은 어노테이션으로 진화 가능하다.</p>
<p>하지만 인터페이스 경우에는 메소드를 만드는 순간 하위 호환성이 깨지므로 마커 어노테이션처럼 지속적인 진화는 불가능하다.</p>
<p>마커 어노테이션과 마커 인터페이스 중 둘 중 어느게 낫다고 할 수 없다. 각각의 쓰임새가 다르기 때문이다. 위에서 언급했듯이 새로운 메소드가 없이 자료형을 정의하고 싶다면 마커 인터페이스를 이용해야 하고 클래스나 인터페이스 이외의 마커를 달아야 하고 앞으로도 더 많은 추가 정보가 있다고 생각하면 마커 어노테이션을 사용하면 된다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://wonwoo.ml/index.php/post/1389" target="_blank" rel="noopener">자바의 마커 인터페이스</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/04/Java-What-is-Marker-interface/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/04/Java-What-is-Reflection/"
                            aria-label=": [Java] Reflection"
                        >
                            [Java] Reflection
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-04T15:14:43+09:00">
	
		    Jan 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 개념을 공부하던 중 <strong>직렬화</strong>라는 개념에 대해서 공부를 했다. 직렬화란 메모리에 올라가 있는 정보를 byte 단위의 코드로 나열하는 것이다. 이를 통해서 객체와 같은 정보를 전달할 수 있게 하는 것이다.</p>
<p>직렬화를 가능하게 하는 방법 중에는 Serializable과 Parcelable을 구현하는 2가지 방법이 존재한다. 그 중 Serializable은 구현은 상당히 쉬우나 속도가 느리다는 단점이 있다.</p>
<p>속도가 느린 이유는 내부적으로 Reflection을 사용하기 때문에 필요없는 쓰레기 객체들을 만들어내고 이를 제거하기 위해 GC가 동작해서 비용이 발생하게 된다.</p>
<p>그렇다면 여기서 말하는 <code>Reflection</code>은 무엇일까??</p>
<h2 id="reflection">Reflection</h2>
<p>객체를 통해 클래스의 정보를 분석해 내는 프로그래밍 기법을 말한다.<br>
리플렉션은 구체적인 클래스 타입을 알지 못해도 컴파일된 바이트 코드를 통해 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API를 말한다. 이게 무슨 의미일까?</p>
<blockquote>
<p>구체적인 클래스 타입을 알지 못하면 메소드를 실행할 수 없나?</p>
</blockquote>
<p>아래 코드를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Do anything.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object car = <span class="keyword">new</span> Car();</span><br><span class="line">        car.drive(); <span class="comment">// 컴파일 에러</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에 코드 블록에서 컴파일 에러가 나는 이유는 모든 클래스의 조상 클래스인 Object라는 타입으로 Car 클래스의 인스턴스를 담을 수는 있지만 사용 가능한 메소드는 Object의 메소드와 변수들 뿐이기 때문이다.  그러니까 car 인스턴스의 메소드는 사용하지 못하는 것이다.</p>
<p>이런 식으로 구체적인 타입의 클래스를 모를 때 사용하는게 리플렉션이다. 그렇다면 또 의문이 생긴다. 역시 의문을 가지는 것은 아주 좋다.</p>
<blockquote>
<p>내가 만드는 프로그램의 코드 흐름인데, 내가 사용할 클래스의 타입과 이름을 모르는 경우가 있을까?</p>
</blockquote>
<p>그렇다. 일반적으로는 만나기 힘든 경우이다. 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르는 경우가 있다. 내가 지금 작성하는 코드가 나중에 어떤 기능이 추가되어서 어떻게 필요에 따라 사용될지 모르는 경우 같은 것이다. 이럴 때는 실행할 시점, 그러니까 런타임에 지금 실행되고 있는 클래스를 가져와서 실행을 해야 되는 것이다.</p>
<p>즉, 설계할 때는 사용될 클래스가 어떤 타입인지 모르지만 리플렉션을 이용해서 코드를 일단 작성하고 실행 시점에 확인해서 활용할 수 있도록 하는 메커니즘이다.</p>
<p>그렇다면 어떻게 이게 가능한 것일까??</p>
<p>자바 클래스 파일은 바이트 코드로 컴파일 되어 <strong>static</strong>한 영역에 위치하게 된다. 때문에 클래스 이름만 알고 있다면 언제든, 이 영역을 뒤져서 클래스에 대한 정보를 가져올 수 있는 것이다. 아래는 가져올 수 있는 정보들이다.</p>
<ul>
<li>ClassName</li>
<li>Clas Modifiers(public, private, synchronized 등)</li>
<li>Package Info</li>
<li>Superclass</li>
<li>Implemented Interfaces</li>
<li>Constructors</li>
<li>MethodsFields</li>
<li>Annotations</li>
</ul>
<h2 id="간단한-예제">간단한 예제</h2>
<p>String 클래스의 풀패스를 통해 String이 가지고 있는 모든 메소드를 출력하는 간단한 예제이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Method m[] = c.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.length; i++)</span><br><span class="line">        System.out.println(m[i].toString());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    System.err.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>리플렉션을 사용하기 위한 3가지 스텝</strong></p>
<ol>
<li>클래스 Class 객체를 얻는다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">Class c2 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c3 = Integer.Type;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>getDeclaredMethods()와 같은 메소드를 호출하여 클래스 내에 정의된 메소드를 모두 가져올 수 있다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] m = c1.getDeclaredMethods();</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>리플렉션 API를 사용하여 정보를 조작 및 얻기.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">Method m[] = c.getDeclaredMethods();</span><br><span class="line">System.out.println(m[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure>
<p>첫번째 메소드의 이름을 출력하게 된다.</p>
<h2 id="사용해보기">사용해보기</h2>
<p><strong>instanceof 연산자 모의실험 해보기</strong></p>
<p>클래스 정보를 얻고 나면 클래스 객체에 대한 정보도 얻을 수 있다. Class.isInstance 메소드는 instanceof 연산자를 시뮬레이팅 할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = cls.isInstance(<span class="number">3</span>);</span><br><span class="line">Log.e(TAG, <span class="string">"b1="</span>+b1);<span class="comment">//b1=false</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = cls.isInstance(<span class="string">"Test"</span>);</span><br><span class="line">Log.e(TAG, <span class="string">"b2="</span>+b2);<span class="comment">//b2=true</span></span><br></pre></td></tr></table></figure>
<p>b1에는 String 클래스인 cls가 3과 같은 타입이 아님을 알려주고 b2에는 String 클래스인 cls가 Test와 같은 타입임을 알려준다.</p>
<p><strong>클래스의 메소드 찾기</strong></p>
<p>리플렉션의 가장 기본적이고 가장 주용한 사용범 중 하나가 바로 클래스에 정의된 메소드를 찾는 것이다. 메소드를 찾는 것 뿐만 아니라 메소드가 가지고 있는 파라미터 타입, Exception 타입, 반환 타입 등을 알아낼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Method methods[] = cls.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">        Method m = methods[i];</span><br><span class="line">        Log.e(TAG, <span class="string">"메소드 이름 = "</span> + m.getName());</span><br><span class="line">        Log.e(TAG, <span class="string">"정의된 클래스이름 = "</span> + m.getDeclaringClass());</span><br><span class="line"> </span><br><span class="line">        Class pvec[] = m.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pvec.length; j++) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"인자 #"</span> + j + <span class="string">" "</span> + pvec[j]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Class evec[] = m.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; evec.length; j++) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"익셉션 #"</span> + j + <span class="string">" "</span> + evec[j]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Log.e(TAG,<span class="string">"return type = "</span> + m.getReturnType());</span><br><span class="line">        Log.e(TAG,<span class="string">"-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>생성자 정보 얻기</strong></p>
<p>메소드를 찾는 방법과 비슷하다. 참고로 생성자는 반환 타입이 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Constructor ctorlist[] = cls.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ctorlist.length; i++) &#123;</span><br><span class="line">        Constructor ct = ctorlist[i];</span><br><span class="line">        Log.e(TAG,<span class="string">"생성자 이름 = "</span> + ct.getName());</span><br><span class="line">        Log.e(TAG,<span class="string">"정의된 클래스이름 = "</span> + ct.getDeclaringClass());</span><br><span class="line">        Class pvec[] = ct.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pvec.length; j++)&#123;</span><br><span class="line">            Log.e(TAG,<span class="string">"param #"</span> + j + <span class="string">" "</span> + pvec[j]);<span class="comment">//생성자 파라미터</span></span><br><span class="line">        &#125;</span><br><span class="line">        Class evec[] = ct.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; evec.length; j++)&#123;</span><br><span class="line">            Log.e(TAG,<span class="string">"exc #"</span> + j + <span class="string">" "</span> + evec[j]);<span class="comment">//익셉션 타입</span></span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG,<span class="string">"-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br></pre></td></tr></table></figure>
<p><strong>클래스 필드 찾기</strong></p>
<p>클래스에 정의된 데이터 필드 또한 찾는게 가능하다. 접근 제어자(modifier)를 알 수 있다. 그리고 <strong>private</strong> 필드도 찾을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Field fieldlist[] = cls.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fieldlist.length; i++) &#123;</span><br><span class="line">        Field fld = fieldlist[i];</span><br><span class="line">        Log.e(TAG,<span class="string">"필드명 = "</span> + fld.getName());</span><br><span class="line">        Log.e(TAG,<span class="string">"정의된클래스 = "</span> + fld.getDeclaringClass());</span><br><span class="line">        Log.e(TAG,<span class="string">"필드타입 = "</span> + fld.getType());</span><br><span class="line">        <span class="keyword">int</span> mod = fld.getModifiers();</span><br><span class="line">        Log.e(TAG,<span class="string">"접근제어자 = "</span> + Modifier.toString(mod));</span><br><span class="line">        Log.e(TAG,<span class="string">"-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>메소드 이름으로 실행하기</strong></p>
<p>메소드 이름으로 특정 메소드를 실행하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    String data = <span class="string">"Hello World"</span>;<span class="comment">//테스트용 데이터</span></span><br><span class="line">    Method lengthMethod = cls.getMethod(<span class="string">"length"</span>);<span class="comment">//length()메소드를 찾는다.</span></span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>) lengthMethod.invoke(data);<span class="comment">//data.length() 수행</span></span><br><span class="line">    Log.e(TAG, <span class="string">"length="</span> + length); <span class="comment">//length=11 출력</span></span><br><span class="line"> </span><br><span class="line">    Method substringMethod = cls.getMethod(<span class="string">"substring"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="comment">//두개의 int타입이 있는 substring메소드를 가져옵니다.</span></span><br><span class="line">    String subStr = (String) substringMethod.invoke(data,<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//data.substring(0,5)와 같은 효과</span></span><br><span class="line">    Log.e(TAG,<span class="string">"subStr="</span>+subStr);<span class="comment">//Hello 출력</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자 그러면 의문이 생긴다. 앞에서 private한 메소드도 찾았는데 실행은 못시킬까??</p>
<p>결론부터 말하자면 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = A.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"Hello I am Private method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">//메소드가 private하여 a.show() 찾을 수가 없음</span></span><br><span class="line">    Method showMethod = a.getClass().getDeclaredMethod(<span class="string">"show"</span>);</span><br><span class="line">    showMethod.setAccessible(<span class="keyword">true</span>); <span class="comment">//접근 가능!</span></span><br><span class="line">    showMethod.invoke(a);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 A라는 클래스에서 private한 메소드인 show()를 선언하면 다른 클래스에서는 이 클래스로 만든 인스턴스로는 show() 메소드에 접근이 불가능하다. 하지만 <strong>리플렉션</strong>은 이를 가능하게 해준다.</p>
<p><strong>getMethod() 메소드는 public한 메소드를 가지고 오며, getDeclaredMethod()는 private한 메소드를 포함한 클래스에 선언된 모든 메소드를 가지고 온다.</strong> setAccessible을 true로 설정하여 private한 메소드에 접근할 수 있다.</p>
<p><strong>리플렉션으로 오브젝트 생성하기</strong></p>
<p>리플렉션으로 오브젝트를 생성하는 예는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = Person.class.getSimpleName();</span><br><span class="line"> </span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayMyName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.e(TAG,String.format(<span class="string">"Hello! My name is %s and I'm %d years old"</span>,name, age) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class personClass = Class.forName(<span class="string">"com.charlezz.reflection.Person"</span>);</span><br><span class="line">    Constructor personConstructor = personClass.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Person person = (Person) personConstructor.newInstance(<span class="string">"Charles"</span>,<span class="number">20</span>);</span><br><span class="line">    person.sayMyName();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Hello! My name is Charles and I'm 20 years old 출력</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Constructor.newInstance를 이용하여 new 생성자와 같이 객체를 생성할 수 있다.</p>
<p><strong>필드의 값 변경하기</strong></p>
<p>필드의 값 또한 리플렉션을 이용한다면 변경시킬 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Class cls = Class.forName(<span class="string">"com.charlezz.reflection.Person"</span>);</span><br><span class="line">    Field ageField = cls.getField(<span class="string">"age"</span>);</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Charles"</span>, <span class="number">20</span>);</span><br><span class="line">    Log.e(TAG,<span class="string">"person.age = "</span> + person.age);<span class="comment">//person.age = 20</span></span><br><span class="line">    ageField.setInt(person, <span class="number">10</span>);</span><br><span class="line">    Log.e(TAG,<span class="string">"person.age = "</span> + person.age);<span class="comment">//person.age = 10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG,e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set~~() 메소드를 이용하여 필드의 값을 변경시킬 수 있다.</p>
<p><strong>결론</strong></p>
<p>실제로 리플렉션은 비용이 큰 작업이므로 신중하게 사용해야 한다. 나는 안드로이드 애플리케이션 개발을 하면서 리플렉션을 사용해 본 적은 없지만 이렇게 개념적인 부분을 알게 되어서 너무 좋았다. 참고할 자료들이 많아서 개념을 잘 잡을 수 있었다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://brunch.co.kr/@kd4/8" target="_blank" rel="noopener">자바의 리플렉션</a></li>
<li><a href="https://www.charlezz.com/?p=756" target="_blank" rel="noopener">안드로이드와 Java의 Reflection</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/04/Java-What-is-Reflection/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Java-Type-of-Error/"
                            aria-label=": [Java] RunTime Error vs Compile Error"
                        >
                            [Java] RunTime Error vs Compile Error
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T10:58:48+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바를 공부하며 항상 등장하는 말은 컴파일과 런타임이다. 하지만 두 용어에 대한 개념이 확실하지 않아 이번 기회에 정리하고 넘어가겠다.</p>
<ul>
<li><strong>Run time</strong> : 어떤 프로그램이 실행되는 동안의 Time을 말하며, 이와 대조되는 개념으로는 Compile time, Link time 등이 있다.</li>
<li><strong>Runtime Error</strong> : 어떤 프로그램이 실행되는 동안에 발생하는 에러를 말한다.
<ul>
<li>문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 경우가 있다.</li>
<li>ex) NullPointerException</li>
</ul>
</li>
<li><strong>Complie time</strong> : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정을 말한다.</li>
<li><strong>Compile Error</strong> : 주로 문법상의 오류가 많다.(빨간 줄이 나타나는 경우 컴파일 에러이다. 대부분의 IDE들이 빨간줄 표시로 잡아준다.)
<ul>
<li>컴파일 에러가 발생하는 경우는 주로 오타, 중괄호의 짝이 맞지 않는 경우, 중복된 변수명 등이 원인이 될 수 있다.</li>
</ul>
</li>
</ul>
<p>프로그램이 컴파일이 에러 없이 완료되더라도 해당 프로그램 실행 시에 에러가 없을 것을 보장할 수 없다.<br>
<strong>즉, 컴파일 에러가 발생하지 않더라도 런타임 에러가 발생할 수 있다.</strong></p>
<img src="/img/compile_runtime.png" width="700" height="300">
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Java-Type-of-Error/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/31/Java-static-concept/"
                            aria-label=": [Java] Static"
                        >
                            [Java] Static
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-31T11:52:46+09:00">
	
		    Dec 31, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>Static</code>이라는 키워드는 보통 변수나 메소드 앞에서 사용한다.</p>
<h2 id="non-static-멤버와-static-멤버의-차이">non-static 멤버와 static 멤버의 차이</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSample</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">// non-static 필드</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;...&#125; <span class="comment">// non-static 메소드</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m; <span class="comment">// static 필드</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// static 메소드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>non-static 멤버</strong></p>
<ul>
<li>공간적 특성 : 멤버는 객체마다 별도로 존재한다.
<ul>
<li><strong>인스턴스 멤버</strong>라고 부른다.</li>
</ul>
</li>
<li>시간적 특성 : 객체 생성 시에 멤버가 생성된다.
<ul>
<li>객체가 생성될 때 멤버도 생성된다.</li>
<li>객체 생성 후 멤버 사용이 가능하다.</li>
<li>객체가 사라지면 멤버도 사라진다.</li>
</ul>
</li>
<li>공유의 특성 : <strong>공유되지 않는다.</strong>
<ul>
<li>멤버는 객체 내에 각각의 고유한 공간을 유지한다.</li>
</ul>
</li>
</ul>
<p><strong>static 멤버</strong></p>
<ul>
<li>공간적 특성 : 멤버는 클래스당 하나가 생성된다.
<ul>
<li>멤버는 객체 내부가 아닌 별도의 공간에 생성된다.</li>
<li><strong>클래스 멤버</strong>라고 부른다.</li>
</ul>
</li>
<li>시간적 특성 : <code>클래스 로딩 시에 멤버가 생성된다.</code>
<ul>
<li>객체가 생기기 전에 이미 생성된다.</li>
<li>객체가 생기기 전에도 사용이 가능하다.(즉, 객체를 생성하지 않고도 static 멤버를 사용할 수 있다.)</li>
<li>객체가 사라져도 static 멤버는 사라지지 않는다.</li>
<li>멤버는 프로그램이 종료될 때 사라진다.</li>
</ul>
</li>
<li>공유의 특성 : <strong>동일한 클래스의 모든 객체들에 의해 공유된다.</strong></li>
</ul>
<h2 id="static-변수">Static 변수</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseLee</span></span>&#123;</span><br><span class="line">    String lastName = <span class="string">"이"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HousePark pey = <span class="keyword">new</span> HouseLee();</span><br><span class="line">        HousePark pes = <span class="keyword">new</span> HouseLee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 이씨 집안을 나타내는 클래스가 있다. 위의 클래스는 객체를 생성할 때 마다 객체 변수인 lastName을 저장하기 위한 메모리를 별도로 할당한다. 하지만, 이 경우 HouseLee 클래스의 lastName은 어떤 객체이던지 동일한 값인 &quot;이&quot;이어야 할 것이다. 이렇게 항상 값이 변하지 않는 경우라면 <code>static</code>을 사용하여 메모리의 낭비를 줄일 수 있는 이점을 가지고 있다.</p>
<p>다음은 static 변수를 이용해서 위의 코드를 바꾼 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseLee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String lastName = <span class="string">"이"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HousePark pey = <span class="keyword">new</span> HouseLee();</span><br><span class="line">        HousePark pes = <span class="keyword">new</span> HouseLee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 lastName 변수에 static 키워드를 붙이면 자바는 메모리 할당을 딱 한번만 하게 되어 메모리 사용에 이점을 가지게 된다.</p>
<p>만약 HouseLee 클래스의 lastName 값이 변경되지 않기를 바란다면 <strong>final</strong> 키워드를 사용하면 된다. final 키워드는 한 번 값이 설정되면 그 값을 변경하지 못하게 한다. (상수처럼) 이를 변경하려고 하면 예외가 발생한다.</p>
<p>static을 사용하는 또 한가지 이유로 <strong>공유의 개념</strong>을 들 수 있다. static으로 선언된 변수는 같은 클래스의 객체들이 하나의 static 변수를 두고 공유한다.</p>
<p>즉, static으로 설정하면 같은 곳의 메모리 주소만을 바라보기 때문에 static 변수의 값을 공유하게 되는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter c1 = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter c2 = <span class="keyword">new</span> Counter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위의 코드를 살펴보자. c1,c2 객체 생성 시 count 값을 1씩 증가시키더라도 c1과 c2의 count는 각각 별도의 메모리 공간을 가리키고 있기 때문에 2가 아닌 <code>1 1</code>이 나오게 되는 것이다.</p>
<p>그렇다면 static 변수를 이용해서 이를 해결해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter c1 = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter c2 = <span class="keyword">new</span> Counter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>count라는 변수는 static으로 선언되어 객체들이 static 변수를 공유하게 된다. 따라서 증가된 결과값이 나오게 된다.</p>
<p>보통 변수의 static 키워드는 프로그래밍 시 메모리의 효율보다는 두번째처럼 공유하기 위한 용도로 훨씬 많이 사용하게 된다.</p>
<h2 id="static-method">static method</h2>
<p>static이라는 키워드가 메소드 앞에 붙으면 이 메소드는 <code>static 메소드</code>가 된다. 그럼 아래의 코드를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Counter() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter c1 = <span class="keyword">new</span> Counter();</span><br><span class="line">        Counter c2 = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        System.out.println(Counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 메소드에서 getCount() 메소드는 <code>Counter.getCount()</code> 와 같이 인스턴스를 만들지 않고 클래스를 통해 호출할 수 있다.(접근할 수 있다.)</p>
<p>getCount() 메소드는 static 메소드이고 이와 같은 static 멤버는 클래스당 하나만 존재하기 때문에 클래스 이름으로 바로 접근할 수 있다.<br>
<code>클래스명.static멤버</code></p>
<p><strong>주의</strong>해야 할 점은 <code>non-static 멤버는 클래스명.non-static멤버</code> 방식으로 접근할 수 없다.</p>
<p>static 메소드 안에서는 인스턴스 변수 접근이 불가능하다. 위의 코드는 static 변수이기 때문에 static 메소드 안에서 접근이 가능한 것이다.</p>
<p>보통 static method는 유틸리티성 메소드를 작성할 때 많이 사용된다고 한다. 예를 들어, 오늘의 날짜 구하기, 숫자에 콤마 추가하기 등의 메소드를 작성할 때에는 클래스 메소드를 사용하는 것이 유리하다.</p>
<p>또한, static 메소드는 오직 static 멤버만 접근할 수 있다.<br>
static 메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없다.</p>
<ul>
<li>static 멤버들만 사용이 가능하다.</li>
<li>그러나 인스턴스 메소드는 static 멤버들을 모두 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; n = x; &#125; <span class="comment">// 정상</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; n = x; &#125; <span class="comment">// 정상</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; n = x; &#125; <span class="comment">// 컴파일 오류. static 메서드는 non-static 필드 사용 불가</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; f1(<span class="number">3</span>); &#125; <span class="comment">// 컴파일 오류. static 메서드는 non-static 메서드 사용 불가</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; m = x; &#125; <span class="comment">// 정상. static 메서드는 static 필드 사용 가능</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; s3(<span class="number">3</span>); &#125; <span class="comment">// 정상. static 메서드는 static 메서드 호출 가능</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>마지막으로 static 메소드에서는 this 키워드를 사용할 수 없다.</p>
<ul>
<li>this는 호출 당시 실행 중인 객체를 가리키는 레퍼런스이다.</li>
<li>따라서 객체가 생성되지 않은 상황에서 클래스 이름을 이용하여 호출이 가능한 static 메소드는 this를 사용할 수 없다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticAndThis</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">this</span>.n = x;&#125; <span class="comment">// 정상</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">this</span>.m = x;&#125; <span class="comment">// non-static 메소드에서 static 멤버 접근 가능</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">this</span>.n = x;&#125;</span><br><span class="line">    <span class="comment">// 컴파일 오류. static 메소드에서는 this 사용 불가.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>주의</code></strong></p>
<ul>
<li>실제 static 멤버의 생성 시점은 JVM(자바 가상 기계)에 따라 다르다.</li>
<li>그러나 일반적으로 static 멤버가 포함된 클래스가 로딩하는 시점에 static 멤버가 생성된다고 볼 수 있다.</li>
<li>JVM은 많은 경우 처음부터 필요한 대부분의 클래스를 로딩하기 때문에 static 멤버의 생성 시점은 JVM이 시작되는 시점이라고 할 수 있다.</li>
</ul>
<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p>디자인 패턴 중 하나인 <strong>싱글톤</strong>에 대해서 알아보자. 우리는 지금 static이라는 키워드에 대해서 알고 있기 때문에 어렵지 않게 접근할 수 있다.</p>
<p><code>Singleton</code>은 단 하나의 객체만을 생성하게 강제하는 패턴이다. 즉 클래스를 통해 생성할 수 있는 객체는 <strong>Only One</strong>. 즉, 한 개만 되도록 만드는 것이 싱글톤이다.</p>
<p>다음의 예를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같은 코드를 작성하면 컴파일 에러가 발생한다. 왜냐하면 Singleton 클래스의 생성자에 <strong>private</strong> 키워드로 외부 클래스에서 Singleton 클래스의 생성자로의 접근을 막았기 때문이다. 이렇게 생성자를 private으로 만들어 버리면 외부 클래스에서 Singleton 클래스를 <code>new</code>를 이용하여 생성할 수 없게 된다.</p>
<p><code>new</code>를 이용하여 무수히 많은 객체를 생성한다면 싱글톤의 정의에 어긋난다. 그래서 일단 new로 객체를 생성할 수 없도록 private 접근 제어자를 이용해서 막은 것이다.</p>
<p>다음 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 이제 getInstance라는 static 메소드를 이용하여 Singleton 객체를 돌려받을 수 있다. 하지만 getInstance를 호출할 때마다 새로운 객체가 생성되게 된다. 하지만 그렇다면 싱글톤 패턴이 아니다. 어떻게 해야할까??</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton one;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(one==<span class="keyword">null</span>) &#123;</span><br><span class="line">            one = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton1 = Singleton.getInstance();</span><br><span class="line">        Singleton singleton2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>Singleton 클래스에 one이라는 static 변수를 두고 getInstance 메소드에서 one 값이 null인 경우에만 객체를 생성하도록 하여 one 객체가 단 한번만 만들어지도록 했다.</p>
<p><strong><code>getInstance의 동작원리</code></strong></p>
<p>최초 getInstance가 호출되면 one이 null이므로 <code>new</code>에 의해서 객체가 생성이 된다. 이렇게 한번 생성이 되면 one은 static 변수이기 때문에 모든 객체가 공유한다. 따라서 객체가 생성된 이후로는 null이 아니게 된다. 그런 후에 다시 getInstance 메소드가 호출되면 이제 one은 null이 아니므로 이미 만들어진 싱글톤 객체인 one을 항상 리턴하게 된다.</p>
<p>main 메소드에서 getInstance를 두번 호출하여 각각 얻은 객체가 같은 객체인지 확인해보았다. 결과는 역시 &quot;true&quot;가 나온다.</p>
<p>싱글톤 패턴은 static에 대한 이해를 하고 있다면 어렵지 않은 패턴 중 하나이다.</p>
<blockquote>
<p>위의 예제로 든 싱글톤은 Thread Safe 하지는 않다. 쓰레드 환경에서 안전한 싱글톤을 만드는 방법은 추후에 공부해보자.</p>
</blockquote>
<h1 id="참고">참고</h1>
<ul>
<li><a href="https://wikidocs.net/228" target="_blank" rel="noopener">정적 변수와 메소드</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/08/04/java-static.html" target="_blank" rel="noopener">java static 멤버와 static 메소드</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/31/Java-static-concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/20/Java-iterator/"
                            aria-label=": Java :: iterator"
                        >
                            Java :: iterator
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-20T22:31:40+09:00">
	
		    Dec 20, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#iterator">iterator</a></li>
</ul>
<h1 id="iterator">iterator</h1>
<p>iterator는 자바의 컬렉션 프레임워크에서 컬렉션에 저장되어 있는 요소들을 읽어오는 방법을 표준화 하였는데 그 중 하나가 <strong>iterator</strong>입니다. 쉽게 말하면 컬렉션으로부터 정보를 얻어내는 인터페이스입니다. 또한, iterator는 인터페이스이며 그 구성은 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Iterator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> hasNext()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>boolean hasNext()</strong> : 읽어 올 요소가 남아있는지 확인하는 메소드로 읽어 올 요소가 남아 있으면 true, 없으면 false를 반환합니다.</li>
<li><strong>Object next()</strong> : 읽어 올 요소가 있으면 다음 요소를 가져옵니다.</li>
<li><strong>void remove()</strong> : next()로 읽어 온 요소를 삭제합니다. 그러므로 next()를 호출한 다음에 remove()를 호출해야 합니다.</li>
</ul>
<blockquote>
<p>그렇다면 우리가 사용하는 컬렉션 프레임워크에서는 어떻게 사용하면 될까요??</p>
</blockquote>
<p>이 질문에 대한 답은 간단합니다. 예를 들어, List, set과 같은 인터페이스를 구현하는 컬렉션은 iterator()가 컬렉션의 특징에 맞게 설계가 되어 있기 때문에 쉽게 사용할 수 있습니다.</p>
<h2 id="iterator와-listsize-사용법">Iterator와 list.size() 사용법</h2>
<ul>
<li>Iterator 사용법</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>list.size 사용법</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="결론">결론</h2>
<p>iteraotr는 자동으로 index를 관리해주기 때문에 사용함에 있어서 편리함을 가져다 주지만, Iterator는 객체를 만들어서 사용하기 때문에 list의 size를 가져와서 계산하는 것보다 속도가 느립니다. <strong>그러므로, list의 size를 받아와서 사용하는 것이 더 좋습니다. (속도면에서 빠릅니다.)</strong></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/20/Java-iterator/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/05/java-basic-19/"
                            aria-label=": [Java] 19. java.time"
                        >
                            [Java] 19. java.time
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-05T20:36:36+09:00">
	
		    Sep 05, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="자바에서의-날짜-및-시간-처리">자바에서의 날짜 및 시간 처리</h1>
<hr>
<p>JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 처리를 수행했습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(<code>deprecated</code>)있습니다.</p>
<p>JDK 1.1부터 새롭게 제공된 Calendar 클래스는 날짜와 시간에 대한 정보를 손쉽게 얻을 수 있었습니다. 하지만 Calendar 클래스는 다음과 같은 <strong>문제점</strong>을 가지고 있습니다.</p>
<ol>
<li>Calendar 인스턴스는 불변 객체(immutable object)가 아니라서 값이 수정될 수 있습니다.</li>
<li>윤초(leap second)와 같은 특별한 상황을 고려하지 않습니다.</li>
<li>Calendar 클래스에서는 월(month)을 나타낼 때 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.</li>
</ol>
<p>따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러리를 함께 사용해 왔습니다.</p>
<p>버전에서는 이러한 Joda-Time 라이브러리를 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 하위 패키지를 포함하고 있습니다.</p>
<h2 id="javatime-패키지">java.time 패키지</h2>
<p>Java SE 8부터 제공되는 <code>java.time 패키지</code>에는 자바에서 날짜와 시간을 다루는 데 사용되는 필수 클래스들이 포함되어 있습니다. 또한, 다음과 같은 다양한 기능을 하는 하위 패키지를 포함하고 있습니다.</p>
<ol>
<li>java.time.chrono : ISO-8601에 정의된 표준 달력 이외의 달력 시스템을 사용할 때 필요한 클래스들</li>
<li>java.time.format : 날짜와 시간에 대한 데이터를 구문 분석하고 형식화하는데 사용되는 클래스들</li>
<li>java.time.temporal : 날짜와 시간에 대한 데이터를 연산하는 데 사용되는 보조 클래스들</li>
<li>java.time.zone : 타임 존(time-zone)과 관련된 클래스들</li>
</ol>
<p><strong>java.time 패키지는 기존에 사용되는 Calendar 클래스의 단점을 보완하였습니다. 따라서 해당 패키지에 속하는 모든 클래스의 인스턴스는 불변 객체(immutable object)로 생성됩니다. 따라서, 값을 수정할 수 없습니다.<br>
즉, java.time 패키지에 포함되는 클래스의 메소드들은 모두 새로운 객체를 생성하여 반환하고 있습니다.</strong></p>
<h2 id="javatime-패키지의-구성-클래스">java.time 패키지의 구성 클래스</h2>
<p>기존의 Calendar 클래스는 날짜와 시간을 한 번에 표현했지만, java.time 패키지에서는 별도로 구분하여 처리합니다. LocalData 클래스는 날짜를 표현할 때 사용하며, LocalTime 클래스는 시간을 표현할 때 사용합니다.<br>
또한, 기존의 Caledar 클래스처럼 날짜와 시간을 한 번에 표현하고 싶을 때는 LocalDateTime 클래스를 사용합니다.</p>
<p>ZonedDateTime 클래스는 특정 타임 존(time-zone)에 해당하는 날짜와 시간을 다루는 데 사용합니다. 또한, 기존의 Date 클래스와 비슷한 용도로 사용되는 Instant 클래스가 있습니다. Instant 클래스는 특정 시점의 날짜와 시간을 나노초(nanosecond) 단위로 표현하는 타임스탬프(time-stamp)를 다루는 데 사용됩니다.</p>
<p>Period 클래스(단어가 의미하듯이 '기간’이라는 뜻을 가지고 있음)는 두 날짜 사이의 차이를 표현하는 데 사용되며, Duration 클래스는 두 시각 사이의 차이를 표현하는 데 사용됩니다.</p>
<h1 id="localdate와-localtime">LocalDate와 LocalTime</h1>
<hr>
<p>LocalData 클래스는 날짜를 표현하는 데 사용되며, LocalTime 클래스는 시간을 표현하는 데 사용됩니다. java.time 패키지에 포함된 대부분의 클래스들은 이 두 클래스를 확장한 것이 많으므로, 우선 이 두 클래스를 먼저 이해하고 알고 있어야 합니다. :)</p>
<h2 id="날짜와-시간-객체의-생성">날짜와 시간 객체의 생성</h2>
<p>LocalData와 LocalTime 클래스는 객체를 생성하기 위해 now()와 of() 메소드라는 클래스 메소드를 제공합니다.</p>
<p>now() 메소드는 현재 날짜와 시간을 이용하여 새로운 객체를 생성하여 반환합니다. 하지만 of() 메소드는 전달된 인수를 가지고 특정 날짜와 시간을 표현하는 새로운 객체를 생성하여 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now(); <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(today+<span class="string">" 와 "</span>+present);</span><br><span class="line"></span><br><span class="line">        LocalDate birthday = LocalDate.of(<span class="number">1994</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        LocalTime birthTime = LocalTime.of(<span class="number">02</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">11</span>);</span><br><span class="line">        System.out.println(birthday+<span class="string">", "</span>+birthTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">05</span> 와 <span class="number">21</span>:<span class="number">22</span>:<span class="number">06.640</span></span><br><span class="line"><span class="number">1994</span>-<span class="number">06</span>-<span class="number">27</span>, <span class="number">02</span>:<span class="number">00</span>:<span class="number">00.000000011</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>of() 메소드는 위의 예제에서 사용된 메소드 시그니처 이외에도 다양한 형태로 오버로딩되어 제공됩니다.</p>
</blockquote>
<h2 id="날짜와-시간-객체에-접근하기">날짜와 시간 객체에 접근하기</h2>
<p>LocalDate와 LocalTime 클래스는 특정 필드의 값을 가져오기 위해서 다음과 같이 다양한 getter 메소드를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 날짜 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getYear()</td>
<td style="text-align:center">해당 날짜 객체의 연도(YEAR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">Month getMonth()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 Month 열거체를 이용하여 반환함.(즉, SEPTEMBER과 같은 형식으로 반환)</td>
</tr>
<tr>
<td style="text-align:center">int getMonthValue()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 반환함. (숫자로 1~12까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfMonth()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_MONTH) 필드의 값을 반환함. (숫자로 1~31까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfYear()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_YEAR) 필드의 값을 반환함. (숫자로 1~365까지를 반환함.[윤년이면 366])</td>
</tr>
<tr>
<td style="text-align:center">DayOfWeek getDayOfWeek()</td>
<td style="text-align:center">해당 날짜 객체의 요일(DAY_OF_WEEK) 필드의 값을 DayOfWeek 열거체를 이용하여 반환함.</td>
</tr>
</tbody>
</table>
<p>기존의 Calendar 클래스에서는 1월을 0으로 표현하여 월의 범위가 0~11이었으며, 요일은 일요일부터 1로 표현했습니다.<br>
하지만 java.time 패키지에서 1월을 1로 표현하여 월의 범위가 1~12가 되었으며, 요일은 월요일부터 1로 표현하도록 변경되었습니다.</p>
<blockquote>
<p>Calendar 클래스와 java.time 패키지의 클래스를 같이 사용할 때에는 특히 위와 같은 차이점에 주의해야 합니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"이번달은 "</span>+today.getMonthValue()+<span class="string">"월입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은"</span>+today.getDayOfWeek()+<span class="string">"입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은 1년 중 "</span>+today.get(ChronoField.DAY_OF_YEAR)+<span class="string">"일째 날입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">이번달은 <span class="number">9</span>월입니다.</span><br><span class="line">오늘은WEDNESDAY입니다.</span><br><span class="line">오늘은 <span class="number">1</span>년 중 <span class="number">248</span>일째 날입니다.</span><br></pre></td></tr></table></figure>
<p>LocalTime 클래스에서 제공하는 대표적인 getter 메소드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 시간 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getHour()</td>
<td style="text-align:center">해당 시간 객체의 시(HOUR_OF_DAY) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getMinute()</td>
<td style="text-align:center">해당 시간 객체의 분(MINUTE_OF_HOUR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getSecond()</td>
<td style="text-align:center">해당 시간 객체의 초(SECOND_OF_MINUTE) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getNano()</td>
<td style="text-align:center">해당 시간 객체의 나노초(NANO_OF_SECOND) 필드의 값을 반환함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.getHour() + <span class="string">"시 "</span> + present.getMinute() + <span class="string">"분입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">0</span>시 <span class="number">18</span>분입니다.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LocalDate와 LocalTime 클래스는 모두 현재 시간을 기준으로 하기 때문에 이 글을 보고 참고하시는 분들은 저와 다른 결과를 볼 수 있습니다. 다른 것이 당연한 것이니 당황해 하지 마시길…ㅎㅎ</p>
</blockquote>
<h2 id="temporalfield-인터페이스">TemporalField 인터페이스</h2>
<p>TemporalField 인터페이스는 월(month-of-year)과 시(hour-of-day)와 같이 날짜와 시간과 관련된 필드를 정의해 놓은 인터페이스입니다. 이 인터페이스를 구현하여 날짜와 시간을 나타낼 때 사용하는 열거체가 바로 ChronoField입니다.<br>
java.time 패키지를 구성하는 클래스의 메소드에서는 이 열거체를 이용하여 날짜와 시간을 처리하고 있스빈다.</p>
<p>ChronoField 열거체에 정의된 대표적인 열거체 상수는 다음 표와 같습니다.</p>
<img src="/img/chronoField.png" width="700" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.of(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        String ampm;</span><br><span class="line"></span><br><span class="line">        System.out.println(present.get(ChronoField.AMPM_OF_DAY));</span><br><span class="line">        <span class="comment">// 0 : 오전, 1 : 오후</span></span><br><span class="line">        <span class="keyword">if</span> (present.get(ChronoField.AMPM_OF_DAY) == <span class="number">0</span>) &#123;</span><br><span class="line">            ampm = <span class="string">"오전"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ampm = <span class="string">"오후"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"지금은 "</span> + ampm + <span class="string">" "</span> + present.get(ChronoField.HOUR_OF_AMPM) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">지금은 오후 <span class="number">1</span>시입니다.</span><br></pre></td></tr></table></figure>
<p>위의 결과에서 보듯이 'present.get(ChronoField.AMPM_OF_DAY)'는 오전은 0을 오후는 1을 반환하고 있습니다.</p>
<h2 id="날짜와-시간-객체의-필드값-변경">날짜와 시간 객체의 필드값 변경</h2>
<p>LocalDate와 LocalTime 클래스는 날짜와 시간 객체에 접근하여 특정 필드의 값을 변경하기 위해서 <code>with()</code> 메소드를 사용합니다. with() 메소드를 사용하면 값이 변경될 필드를 사용자가 직접 명시할 수 있습니다.<br>
또한, 특정 필드의 값을 변경하기 위해 미리 정의되어 제공되는 다양한 with() 메소드를 사용할 수도 있습니다.</p>
<p><strong>LocalDate 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localdate.png" width="700" height="300"></p>
<p><strong>LocalTime 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localtime.png" width="700" height="300"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalDate otherDay = today.withYear(<span class="number">1994</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+otherDay.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+present.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.withHour(<span class="number">16</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+otherTime.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">올해는 <span class="number">1994</span>년입니다.</span><br><span class="line"></span><br><span class="line">현재 시각은 <span class="number">0</span>시 입니다.</span><br><span class="line">현재 시각은 <span class="number">16</span>시 입니다.</span><br></pre></td></tr></table></figure>
<p>with() 메소드 이외에도 특정 필드의 값을 더하거나 뺄 수 있는 다양한 plus()와 minus() 메소드도 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.get(ChronoField.HOUR_OF_DAY) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + otherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime anotherTime = present.minus(<span class="number">6</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + anotherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">1</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">3</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">19</span>시입니다.</span><br></pre></td></tr></table></figure>
<h2 id="날짜와-시간-객체의-비교">날짜와 시간 객체의 비교</h2>
<p>LocalDate와 LocalTime 클래스에도 객체를 비교할 수 있는 compareTo() 메소드가 오버라이딩 되어 있습니다. 하지만 더욱 편리하게 날짜와 시간 객체를 서로 비교할 수 있도록 다음과 같은 메소드를 제공합니다.</p>
<ol>
<li>isEqual() 메소드 : equals() 메소드와는 달리 <strong>오직 날짜만을 비교함.</strong>(LocalDate 클래스에서만 제공)</li>
<li>isBefore() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 앞선 시간인지를 비교함.</li>
<li>isAfter() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 늦은 시간인지를 비교함.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        LocalDate otherDay = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line">        LocalDate otherDay2 = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(today.compareTo(otherDay));</span><br><span class="line">        <span class="comment">// today와 otherDay의 year 간의 차이를 반환</span></span><br><span class="line">        System.out.println(today.isBefore(otherDay));</span><br><span class="line">        System.out.println(today.isAfter(otherDay));</span><br><span class="line">        System.out.println(today.isEqual(otherDay));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(otherDay.isEqual(otherDay2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/05/java-basic-19/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/04/java-basic-18/"
                            aria-label=": [Java] 18. 스트림API"
                        >
                            [Java] 18. 스트림API
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-04T12:06:54+09:00">
	
		    Sep 04, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림api">스트림API</h1>
<hr>
<p>Java SE 8부터 추가된 스트림 API는 앞서 입력과 출력 수업에서 살펴본 스트림과는 전혀 다른 개념입니다. 자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용하는데, 이렇게 저장된 데이터에 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 새로운 코드를 작성해야 합니다.</p>
<p>하지만 이렇게 작성된 코드는 길이가 너무 길고 가독성도 떨어지며, 코드의 재사용이 거의 불가능합니다. 즉, 데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했습니다.</p>
<p><strong>이러한 문제점을 극복하기 위해서 Java SE 8부터 스트림(stream) API를 도입합니다. 스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다. 따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 됩니다.</strong></p>
<h2 id="스트림-api의-특징">스트림 API의 특징</h2>
<ol>
<li>스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복(internal iteration)을 통해 작업을 수행합니다.</li>
<li>스트림은 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있습니다.</li>
<li>스트림은 원본 데이터를 변경하지 않습니다.</li>
<li>스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화합니다.</li>
<li>스트림은 parallelStream() 메소드를 통한 손쉬운 병렬 처리를 지원합니다.</li>
</ol>
<h2 id="스트림-api의-동작-흐름">스트림 API의 동작 흐름</h2>
<p>스트림 APi는 다음과 같이 세 가지 단계에 걸쳐서 동작합니다.</p>
<ol>
<li>스트림의 생성</li>
<li>스트림의 중개 연산(스트림의 변환)</li>
<li>스트림의 최종 연산(스트림의 사용)</li>
</ol>
<img src="/img/stream2.png" width="800" height="300">
<h1 id="스트림의-생성">스트림의 생성</h1>
<hr>
<p>스트림 API는 다음과 같은 다양한 데이터 소스에서 생성해서 사용할 수 있습니다.</p>
<ol>
<li>컬렉션</li>
<li>배열</li>
<li>가변 매개변수</li>
<li>지정된 범위의 연속된 정수</li>
<li>특정 타입의 난수들</li>
<li>람다 표현식</li>
<li>파일</li>
<li>빈 스트림</li>
</ol>
<h2 id="컬렉션">컬렉션</h2>
<p>자바에서 제공하는 모든 컬렉션의 최고 상위 조상인 Collection 인터페이스에는 stream() 메소드가 정의되어 있습니다. 따라서 Collection 인터페이스를 구현한 모든 List와 Set 컬렉션 클래스에서도 stream() 메소드로 스트림을 생성할 수 있습니다. 또한, parallelStream() 메소드를 사용하면 병렬 처리가 가능한 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// stream.forEach(System.out::println); 한 번 더 호출하면 에러가 발생</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Stream 클래스의 forEach() 메소드는 해당 스트림의 요소를 하나씩 소모해가며 순차적으로 요소에 접근하는 메소드입니다. 따라서 같은 스트림으로는 forEach() 메소드를 한 번밖에 호출할 수 없습니다. 단, 원본 데이터의 요소를 소모하는 것은 아니므로, 같은 데이터에서 또 다른 스트림을 생성하여 forEach() 메소드를 호출하는 것은 가능합니다.</p>
<h2 id="배열">배열</h2>
<p>배열에 관한 스트림을 생성하기 위해 Arrays 클래스에는 다양한 형태의 stream() 메소드가 클래스 메소드로 정의되어 있습니다. 또한, 기본 타입인 int, long, double 형을 저장할 수 있는 배열에 관한 스트림이 별도로 정의되어 있습니다.<br>
이러한 스트림은 java.util.stream 패키지의 IntStream, LongStream, DoubleStream 인터페이스로 각각 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열에서 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(arr);</span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열의 특정 부분만을 이용한 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">둘 셋</span><br></pre></td></tr></table></figure>
<p>Arryas 클래스의 stream() 메소드는 전체 배열뿐만 아니라 배열의 특정 부분만을 이용하여 스트림을 생성할 수도 있습니다.</p>
<h2 id="가변-매개변수">가변 매개변수</h2>
<p>Stream 클래스의 <code>of()</code> 메소드를 사용하면 가변 매개변수를 전달받아 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Double&gt; stream = Stream.of(<span class="number">4.2</span>, <span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4.2</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">1.9</span></span><br></pre></td></tr></table></figure>
<h2 id="지정된-범위의-연속된-정수">지정된 범위의 연속된 정수</h2>
<p>지정된 범위의 연속된 정수를 스트림으로 생성하기 위해 IntStream이나 LongStream 인터페이스에는 range()와 rangeClosed() 메소드가 정의되어 있습니다.</p>
<ul>
<li>range() : 명시된 시작 정수를 포함하지만, 명시된 마지막 정수는 포함하지 않는 스트림을 생성합니다.</li>
<li>rangeClosed() : 명시된 시작 정수뿐만 아니라 명시된 마지막 정수까지도 포함하는 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="특정-타입의-난수들">특정 타입의 난수들</h2>
<p>특정 타입의 난수로 이루어진 스트림을 생성하기 위해 Random 클래스에는 ints(), longs(), doubles()와 같은 메소드가 정의되어 있습니다.</p>
<p>이 메소드들은 매개변수로 스트림의 크기를 long 타입으로 전달받을 수 있습니다. 이 메소드들은 만약 매개 변수를 전달받지 않으면 크기가 정해지지 않은 무한 스트림을 반환합니다. 이때에는 limit() 메소드를 사용하여 따로 스트림의 크기를 제한해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream = <span class="keyword">new</span> Random().ints().limit(<span class="number">10</span>);</span><br><span class="line">        intStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">-<span class="number">306452731</span></span><br><span class="line"><span class="number">1589863803</span></span><br><span class="line">-<span class="number">2033593764</span></span><br><span class="line">-<span class="number">686440616</span></span><br><span class="line">-<span class="number">938628166</span></span><br><span class="line"><span class="number">2106259183</span></span><br><span class="line"><span class="number">700874167</span></span><br><span class="line">-<span class="number">1006255911</span></span><br><span class="line">-<span class="number">181498589</span></span><br><span class="line"><span class="number">1937399570</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 처음에 ints() 메소드에 크기를 지정해주지 않아서 무한 스트림을 반환하지만, 뒤에 limit() 메소드를 이용하여 크기를 10으로 제한했습니다.</p>
<h2 id="람다-표현식">람다 표현식</h2>
<p>람다 표현식을 매개변수로 전달받아 해당 람다 표현식에 의해 반환되는 값을 요소로 하는 무한 스트림을 생성하기 위해 Stream 클래스에는 iterate()와 generate() 메소드가 정의되어 있습니다.</p>
<ul>
<li>iterate() : 시드(seed)로 명시된 값을 람다 표현식에 사용하여 반환된 값을 다시 시드로 사용하는 방식으로 무한 스트림을 생성합니다.</li>
<li>generate() : 매개변수가 없는 람다 표현식을 사용하여 반환된 값으로 무한 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = Stream.iterate(<span class="number">2</span>, n-&gt;n+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2,4,6,8,10, ...</span></span><br></pre></td></tr></table></figure>
<h2 id="파일">파일</h2>
<p>파일의 한 행(line)을 요소로 하는 스트림을 생성하기 위해 java.nio.file.Files 클래스에는 lines() 메소드가 정의되어 있습니다. 또한, java.io.BufferedReader 클래스의 lines() 메소드를 사용하면 파일뿐만 아니라 다른 입력으로부터도 데이터를 행(line) 단위로 읽어 올 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String&lt;String&gt; stream = File.lines(Path path);</span><br></pre></td></tr></table></figure>
<h2 id="빈-스트림">빈 스트림</h2>
<p>아무 요소도 가지지 않는 빈 스트림은 Stream 클래스의 empty() 메소드를 사용하여 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 스트림 생성</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Object&gt; stream = Stream.empty();</span><br><span class="line">        System.out.println(stream.count());</span><br><span class="line">        <span class="comment">// 스트림의 요소의 총 개수를 출력</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="스트림의-중개-연산">스트림의 중개 연산</h1>
<hr>
<p><strong>스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됩니다. 이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있습니다.</strong><br>
또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 지연(lazy) 연산을 통해 성능을 최적화할 수 있습니다.</p>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림 필터링 : filter(), distinct()</li>
<li>스트림 변환 : map(), flatMap()</li>
<li>스트림 제한 : limit(), skip()</li>
<li>스트림 정렬 : sorted()</li>
<li>스트림 연산 결과 확인 : peek()</li>
</ol>
<h2 id="스트림-필터링">스트림 필터링</h2>
<p><code>filter()</code> 메소드는 해당 스트림에서 주어진 조건(predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환합니다.<br>
또한, <code>distinct()</code> 메소드는 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환합니다. distinct() 메소드는 내부적으로 Object 클래스의 equals() 메소드를 사용하여 요소의 중복을 비교합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream1 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream intStream2 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 스트림에서 중복된 요소 제거</span></span><br><span class="line">        intStream1.distinct().forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 스트림에서 홀수만 골라냄</span></span><br><span class="line">        intStream2.filter(k-&gt;k%<span class="number">2</span> != <span class="number">0</span>).forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-변환">스트림 변환</h2>
<p><code>map()</code> 메소드는 해당 스트림의 요소들을 주어진 함수에 인수로 전달하여, 그 반환값들로 이루어진 새로운 스트림을 반환합니다. 만약 해당 스트림의 요소가 배열이라면, <code>flatMap()</code> 메소드를 사용하여 각 배열의 각 요소의 반환값을 하나로 합친 새로운 스트림을 얻을 수 있습니다.</p>
<p>다음 코드는 문자열로 이루어진 스트림을 map() 메소드를 이용하여 각 문자열의 길이로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"JAVASCRIPT"</span>);</span><br><span class="line">        stringStream.map(e-&gt;e.length()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>다음은 여러 문자열이 저장된 배열을 각 문자열에 포함된 단어로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"I study hard"</span>, <span class="string">"You study JAVA"</span>, <span class="string">"I am hungry"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream.flatMap(s-&gt;Stream.of(s.split(<span class="string">" "</span>))).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">I</span><br><span class="line">study</span><br><span class="line">hard</span><br><span class="line">You</span><br><span class="line">study</span><br><span class="line">JAVA</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">hungry</span><br></pre></td></tr></table></figure>
<h2 id="스트림-제한">스트림 제한</h2>
<p><code>limit()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소만으로 이루어진 새로운 스트림을 반환합니다.<br>
<code>skip()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소를 제외한 나머지 요소만으로 이루어진 새로운 스트림을 반환합니다.</p>
<blockquote>
<p>그리고 두 메소드의 들어가는 매개변수의 인덱스는 포함하지 않고 바로 직전 인덱스까지만 해당됩니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream3 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 4개의 요소를 제외 : 0,1,2,3 제외한 나머지 요소 출력</span></span><br><span class="line">        stream1.skip(<span class="number">4</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 5개의 요소 출력 : 0,1,2,3,4</span></span><br><span class="line">        stream2.limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stream3.skip(<span class="number">3</span>).limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-정렬">스트림 정렬</h2>
<p><code>sorted()</code> 메소드는 해당 스트림을 주어진 비교자(comparator)를 이용하여 정렬합니다. 이때 비교자를 전달하지 않으면 기본적으로 사전 편찬 순(natural order)으로 정렬하게 되고, 비교자를 전달하면 사전 편찬 순의 역순으로 정렬하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        stream1.sorted().forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        stream2.sorted(Comparator.reverseOrder()).forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">CSS HTML JAVA JAVASCRIPT </span><br><span class="line">JAVASCRIPT JAVA HTML CSS</span><br></pre></td></tr></table></figure>
<h2 id="스트림-연산-결과-확인">스트림 연산 결과 확인</h2>
<p><code>peek()</code> 메소드는 결과 스트림으로부터 요소를 소모하여 추가로 명시된 동작을 수행합니다. 이 메소드는 원본 스트림에서 요소를 소모하지 않으므로, 주로 연산과 연산 사이에 결과를 확인하고 싶을 때 사용합니다. 따라서 개발자가 디버깅 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        stream.peek(s -&gt; System.out.println(<span class="string">"원본 스트림 : "</span> + s))</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"skip(2) 실행 후 : "</span> + s))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"limit(5) 실행 후 : "</span> + s))</span><br><span class="line">                .sorted()</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"sorted() 실행 후 : "</span> + s))</span><br><span class="line">                .forEach(n -&gt; System.out.println(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 스트림 : <span class="number">7</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">1</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">3</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>위의 코드는 다음과 같은 결과를 보여줍니다. 현재 지금 저는 스트림 API에 대한 개념이 적은 상태입니다. 그리고 위의 peek()이라는 메소드의 동작 상태가 이해가 가지 않네요… 이렇게 정리해놓고 나중에 다시 공부할 때 조금 더 찾아보게 된다면 아마 이해가 가지 않을까요?ㅎㅎ</p>
</blockquote>
<p>위의 예제에서 첫 번째 요소인 7과 두 번째 요소인 5는 skip() 메소드에 의해 삭제되므로, 원본 스트림에서만 나타납니다. 하지만 세 번째 요소인 5는 skip() 메소드와 limit() 메소드가 실행된 후에도 존재하므로, 모두 나타납니다. 이렇게 peek() 메소드는 스트림의 각 요소가 해당 중개 연산 후에 어떻게 변화하는지를 보여줍니다.</p>
<h2 id="대표적인-중개-연산-메소드">대표적인 중개 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_method.png" width="800" height="300">
<h1 id="스트림의-최종-연산">스트림의 최종 연산</h1>
<hr>
<p><strong>스트림 API에서 중개 연산을 통해 변환된 스트림은 마지막으로 최종 연산을 통해 각 요소를 소모하여 결과를 표시합니다. 즉, 지연(lazy)되었던 모든 중개 연산들이 최종 연산 시에 모두 수행되는 것입니다. 이렇게 최종 연산 시에 모든 요소를 소모한 해당 스트림은 더는 사용할 수 없게 됩니다.</strong></p>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>요소의 출력 : forEach()</li>
<li>요소의 소모 : reduce()</li>
<li>요소의 검색 : findFirst(), findAny()</li>
<li>요소의 검사 : anyMatch(), allMatch(), noneMatch()</li>
<li>요소의 통계 : count(), min(), max()</li>
<li>요소의 연산 : sum(), average()</li>
<li>요소의 수집 : collect()</li>
</ol>
<h2 id="요소의-출력">요소의 출력</h2>
<p>위에서 중개 연산과 관련된 메소드를 사용하면서 자주 사용했던 <code>forEach()</code> 메소드는 스트림의 각 요소를 소모하여 명시된 동작을 수행합니다. 반환 타입이 void이므로 보통 스트림의 모든 요소를 출력하는 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"셋"</span>,<span class="string">"하나"</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">셋</span><br><span class="line">하나</span><br></pre></td></tr></table></figure>
<h2 id="요소의-소모">요소의 소모</h2>
<p>스트림의 최종 연산은 모든 스트림의 각 요소를 소모하여 연산을 수행하게 됩니다. 하지만  <code>reduce()</code> 메소드는 첫 번째와 두 번째 요소를 가지고 연산을 수행한 뒤, 그 결과와 세 번째 요소를 가지고 또 다시 연산을 수행합니다. 이런 식으로 해당 스트림의 모든 요소를 소모하여 연산을 수행하고, 그 결과를 반환하게 됩니다.<br>
또한, 인수로 초기값을 전달하면 초기값과 해당 스트림의 첫 번째 요소와 연산을 시작하며, 그 결과와 두 번째 요소를 가지고 계속해서 연산을 수행하게 됩니다.</p>
<p>다음 예제는 스트림의 각 문자열 요소를 “++” 기호로 연결하여 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; result1 = stream1.reduce((s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        result1.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        String result2 = stream2.reduce(<span class="string">"시작"</span>, (s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷++둘++셋++하나</span><br><span class="line">시작++넷++둘++셋++하나</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 인수로 초기값을 전달하는 reduce() 메소드의 반환 타입은 Optional<t>가 아닌 T 타입입니다. 그 이유는 비어 있는 스트림과 reduce 연산을 할 경우 전달받은 초기값을 그대로 반환해야 하기 때문입니다.</t></p>
<blockquote>
<p>Optional 클래스에 관한 내용은 아래에서 확인할 수 있습니다.</p>
</blockquote>
<h2 id="요소의-검색">요소의 검색</h2>
<p><code>findFirst()</code>와 <code>findAny()</code> 메소드는 해당 스트림에서 첫 번째 요소를 참조하는 Optional 객체를 반환합니다. 두 메소드 모두 비어있는 스트림에서 비어있는 Optional 객체를 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 정렬한 후, 첫 번째에 위치한 요소를 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        OptionalInt result1 = stream1.sorted().findFirst();</span><br><span class="line">        System.out.println(<span class="string">"findFirst() 메소드의 결과 : "</span>+result1.getAsInt());</span><br><span class="line"></span><br><span class="line">        OptionalInt result2 = stream2.sorted().findAny();</span><br><span class="line">        System.out.println(<span class="string">"findAny() 메소드의 결과 : "</span>+result2.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">findFirst() 메소드의 결과 : <span class="number">1</span></span><br><span class="line">findAny() 메소드의 결과 : <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-검사">요소의 검사</h2>
<p>해당 스트림의 요소 중에서 특정 조건을 만족하는 요소가 있는지, 아니면 모두 만족하거나 모두 만족하지 않는지를 다음 메소드를 사용하여 확인할 수 있습니다.</p>
<ol>
<li>anyMatch() : 해당 스트림의 일부 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>allMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>noneMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족하지 않은 경우에 true를 반환함.</li>
</ol>
<p>세 메소드 모두 인수로 <strong>Predicate</strong> 객체를 전달받으며, 요소의 검사 결과는 boolean값으로 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 검사하여 80보다 큰 값을 가지는 요소가 하나라도 존재하는지를 검사하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// stream1의 요소 중 어느 하나라도 80보다 크면 true 반환</span></span><br><span class="line">        System.out.println(stream1.anyMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">        <span class="comment">// stream2의 요소 중 모든 요소가 80보다 크면 treu 반환 </span></span><br><span class="line">        System.out.println(stream2.allMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-통계-연산">요소의 통계, 연산</h2>
<blockquote>
<p>통계</p>
</blockquote>
<ul>
<li>count() : 해당 스트림의 요소의 총 개수를 long 타입의 값으로 반환합니다.</li>
<li>max(), min() : 해당 스트림의 요소 중에서 가장 큰 값과 가장 작은 값을 가지는 요소를 참조하는 Optional 객체를 얻을 수 있습니다. <strong>원하는 Int값을 얻기 위해서는 getAsInt() 메소드를 사용하면 Int 값을 얻을 수 있습니다.</strong></li>
</ul>
<blockquote>
<p>연산</p>
</blockquote>
<p><strong>IntStream이나 DoubleStream과 같은 기본 타입 스트림에는 해당 스트림의 모든 요소에 대해 합과 평균을 구할 수 있는 sum()과 average() 메소드가 각각 정의되어 있습니다. 이때 average() 메소드는 각 기본 타입으로 래핑된 Optional 객체를 반환하므로, Int값을 얻기 위해서는 getAsInt() 메소드를 사용해서 얻을 수 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        DoubleStream stream3 = DoubleStream.of(<span class="number">30.3</span>, <span class="number">90.9</span>, <span class="number">70.7</span>, <span class="number">10.1</span>);</span><br><span class="line">        IntStream stream4 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"count() 메소드 호출 : "</span>+stream1.count());</span><br><span class="line">        System.out.println(<span class="string">"min() 메소드 호출 : "</span>+stream2.min().getAsInt());</span><br><span class="line">        <span class="comment">//System.out.println(stream2.max().getAsInt());</span></span><br><span class="line">        System.out.println(<span class="string">"average() 메소드 호출 : "</span>+stream3.average().getAsDouble());</span><br><span class="line">        System.out.println(<span class="string">"sum() 메소드 호출 : "</span>+stream4.sum());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">count() 메소드 호출 : <span class="number">4</span></span><br><span class="line">min() 메소드 호출 : <span class="number">10</span></span><br><span class="line">average() 메소드 호출 : <span class="number">50.5</span></span><br><span class="line">sum() 메소드 호출 : <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-수집">요소의 수집</h2>
<p><code>collect()</code> 메소드는 인수로 전달되는 Collectors 객체에 구현된 방법대로 스트림의 요소를 수집합니다. 또한, Collectors 클래스에는 미리 정의된 다양한 방법이 클래스 메소드로 정의되어 있습니다. 이 외에도 사용자가 직접 Collector 인터페이스를 구현하여 자신만의 수집 방법을 정의할 수도 있습니다.</p>
<p>스트림 요소의 수집 용도별 사용할 수 있는 Collectors 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림을 배열이나 컬렉션으로 변환 : toArray(), toCollection(), toList(), toSet(), toMap()</li>
<li>요소의 통계와 연산 메소드와 같은 동작을 수행 : counting(), maxBy(), minBy(), summingInt(), averagingInt() 등</li>
<li>요소의 소모와 같은 동작을 수행 : reducing(), joining()</li>
<li>요소의 그룹화와 분할 : groupingBy(), partitioningBy()</li>
</ol>
<p>다음 예제는 collect() 메소드를 이용하여 해당 스트림을 리스트로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"하나"</span>,<span class="string">"셋"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">하나</span><br><span class="line">셋</span><br></pre></td></tr></table></figure>
<p>다음 예제는 Collectors 클래스의 partitioningBy() 메소드를 이용하여 해당 스트림의 각 요소별 글자 수에 따라 홀수와 짝수로 나누어 저장하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"PHP"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, List&lt;String&gt;&gt; partition = stream.collect(Collectors.partitioningBy(s-&gt;(s.length() % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 홀수인 List</span></span><br><span class="line">        List&lt;String&gt; oddList = partition.get(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(oddList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 짝수인 Lists</span></span><br><span class="line">        List&lt;String&gt; evenList = partition.get(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(evenList);</span><br><span class="line"></span><br><span class="line">        System.out.println(partition);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">[CSS, PHP]</span><br><span class="line">[HTML, JAVA]</span><br><span class="line">&#123;<span class="keyword">false</span>=[CSS, PHP], <span class="keyword">true</span>=[HTML, JAVA]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="대표적인-최종-연산-메소드">대표적인 최종 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_final_method.png" width="800" height="300">
<h1 id="optional-클래스">Optional 클래스</h1>
<hr>
<p>Optional<t> 클래스는 Integer나 Double 클래스처럼 ‘T’ 타입의 객체를 포장해 주는 래퍼(Wrapper class)입니다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있습니다.</t></p>
<p><strong>이러한 Optional 객체를 사용하면 예상치 못한 NullPointerException 예외를 제공되는 메소드로 간단히 회피할 수 있습니다. 즉, 복잡한 조건문 없이도 널(null) 값으로 인해 발생하는 예외를 처리할 수 있게 됩니다.</strong></p>
<h2 id="optional-객체의-생성">Optional 객체의 생성</h2>
<p>of() 메소드나 ofNullable() 메소드를 사용하여 Optional 객체를 생성할 수 있습니다.</p>
<p>of() 메소드는 null이 아닌 명시된 값을 가지는 Optional 객체를 반환합니다. 만약 of() 메소드를 통해 생성된 Optional 객체에 null이 저장되면 <strong>NullPointerException</strong> 예외가 발생합니다.</p>
<p>따라서 만약 참조 변수의 값이 만에 하나 null이 될 가능성이 있다면, ofNullable() 메소드를 사용하여 Optional 객체를 생성하는 것이 좋습니다.<br>
ofNullable() 메소드는 명시된 값이 null이 아니면 명시된 값을 가지는 Optional 객체를 반환하며, 명시된 값이 null이면 비어있는 Optional 객체를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line">        Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">        System.out.println(opt2);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt.get());</span><br><span class="line">        <span class="comment">//System.out.println(opt2.get()); 에러발생</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">Optional[자바 공부 중]</span><br><span class="line">Optional.empty</span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<h2 id="optional-객체에-접근">Optional 객체에 접근</h2>
<p>get() 메소드를 사용하면 Optional 객체에 저장된 값에 접근할 수 있습니다. 만약 Optional 객체에 저장된 값이 null이면, <code>NoSuchElementException</code> 예외가 발생합니다. <strong>따라서 get() 메소드를 호출하기 전에 isPresent() 메소드를 사용하여 Optional 객체에 저장된 값이 null인지 아닌지를 먼저 확인한 후 호출하는 것이 좋습니다.</strong></p>
<p>다음 예제는 isPresent() 메소드를 이용하여 좀 더 안전하게 Optional 객체에 저장된 값에 접근하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt.isPresent())&#123;</span><br><span class="line">            System.out.println(opt.get());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"opt 객체는 null입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<p>또한, 아래와 같은 메소드를 사용하여 null 대신에 대체할 값을 지정할 수도 있습니다.</p>
<ol>
<li>orElse() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 값을 반환함.</li>
<li>orElseGet() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결과값을 반환함.</li>
<li>orElseThrow() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 예외를 발생시킴</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.empty(); <span class="comment">// Optional를 null로 초기화함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(opt.orElse(<span class="string">"빈 Optional 객체"</span>));</span><br><span class="line">        System.out.println(opt.orElseGet(String::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">빈 Optional 객체</span><br></pre></td></tr></table></figure>
<blockquote>
<p>empty() 메소드는 Optional 객체를 null로 초기화해줍니다.</p>
</blockquote>
<h2 id="기본-타입의-optional-클래스">기본 타입의 Optional 클래스</h2>
<p>자바에서는 IntStream 클래스와 같이 기본 타입 스트림을 위한 별도의 Optional 클래스를 제공하고 있습니다.</p>
<ol>
<li>OptionalInt 클래스</li>
<li>OptionalLong 클래스</li>
<li>OptionalDouble 클래스</li>
</ol>
<p>이러한 클래스는 반환 타입이 Optional<t> 타입이 아니라 해당 기본 타입이라는 사실만 제외하면 거의 모든 면에서 비슷합니다.</t></p>
<p>또한, Optional 객체에서 get() 메소드를 사용하여 저장된 값에 접근할 수 있는 것처럼 클래스별로 저장된 값에 접근할 수 있는 다음과 같은 메소드를 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스</th>
<th style="text-align:center">저장된 값에 접근하는 메소드</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Optional<t></t></td>
<td style="text-align:center">T get()</td>
</tr>
<tr>
<td style="text-align:center">OptionalInt</td>
<td style="text-align:center">int getAsInt()</td>
</tr>
<tr>
<td style="text-align:center">OptionalLong</td>
<td style="text-align:center">long getAsLong()</td>
</tr>
<tr>
<td style="text-align:center">OptionalDouble</td>
<td style="text-align:center">double getAsDouble()</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        OptionalInt result = stream.findFirst();</span><br><span class="line">        </span><br><span class="line">        System.out.println(result.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="optional-메소드">Optional 메소드</h2>
<img src="/img/optional_method.png" width="800" height="300">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/04/java-basic-18/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-17/"
                            aria-label=": [Java] 17. 람다표현식"
                        >
                            [Java] 17. 람다표현식
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T17:06:06+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="람다-표현식">람다 표현식</h1>
<hr>
<p><strong>람다 표현식(lambda expression)이란 간단히 말해서 메소드를 하나의 식으로 표현한 것을 말합니다.</strong> 기존의 메소드는 아래와 같이 작성합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>람다 표현식으로 위의 코드를 표현하면 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 메소드를 람다 표현식으로 표혀하면, 클래스를 작성하고 객체를 생성하지 않아도 메소드를 사용할 수 있습니다.</p>
<p>그런데 자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다. 따라서 자바에서 람다 표현식은 익명 클래스와 같다고 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 클래스</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 람다 표현식은 메소드의 매개변수로 전달될 수도 있으며, 메소드의 결과값으로 반환될 수도 있습니다. 따라서 람다 표현식을 사용하면, 기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높여줍니다. Java SE 8부터는 이러한 람다 표현식을 사용하여 자바에서도 함수형 프로그래밍을 할 수 있게 되었습니다.</p>
<h2 id="람다-표현식-작성">람다 표현식 작성</h2>
<p>화살표( -&gt; ) 기호를 사용하여 람다 표현식을 작성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(매개변수 목록) -&gt; &#123; 함수 몸체 &#125;</span><br></pre></td></tr></table></figure>
<p>자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다.</p>
<ol>
<li>매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다.</li>
<li>매개변수가 하나인 경우에는 괄호 () 를 생략할 수 있습니다.</li>
<li>함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호 {} 를 생략할 수 있습니다. (이 때, 세미콜론(;)은 붙이지 않음)</li>
<li>함수의 몸체가 하나의 return문으로만 이루어진 경우에는 중괄호 {} 를 생략할 수 없습니다.</li>
<li>return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결과값이 됩니다.(이때 세미콜론(;)은 붙이지 않음)</li>
</ol>
<p>다음은 전통적인 방식의 스레드 생성과 람다 표현식을 사용한 스레드의 생성을 비교하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"전통적인 방식의 일회용 스레드 생성"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"람다 표현식을 사용한 일회용 스레드 생성"</span>)</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">전통적인 방식의 일회용 스레드 생성</span><br><span class="line">람다 표현식을 사용한 일회용 스레드 생성</span><br></pre></td></tr></table></figure>
<blockquote>
<p>람다 표현식을 사용하면 불피요한 코드를 줄일 수 있으며, 코드의 가독성이 훨씬 좋아집니다.</p>
</blockquote>
<h2 id="함수형-인터페이스functional-interface">함수형 인터페이스(functional interface)</h2>
<p>람다 표현식을 사용할 때는 람다 표현식을 저장하기 위한 참조 변수의 타입을 결정해야만 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">참조변수의타입 참조변수의이름 = 람다 표현식</span><br></pre></td></tr></table></figure>
<p><strong>위의 문법처럼 람다 표현식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입을 함수형 인터페이스라고 부릅니다.</strong></p>
<p>함수형 인터페이스는 추상 클래스와는 달리 단 하나의 추상 메소드만을 가져야 합니다. 또한, 다음과 같은 어노테이션(annotation)을 사용하여 함수형 인터페이스임을 명시할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 어노테이션을 인터페이스의 선언 앞에 붙이면, 컴파일러는 해당 인터페이스를 함수형 인터페이스로 인식합니다. 자바 컴파일러는 이렇게 명시된 함수형 인터페이스에 두 개 이상의 메소드가 선언되면 오류를 발생시킵니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span> </span>&#123; <span class="comment">// 함수형 인터페이스의 선언</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Calc minNum = (x, y) -&gt; x &lt; y ? x : y; <span class="comment">// 추상 메소드의 구현</span></span><br><span class="line">        System.out.println(minNum.min(<span class="number">3</span>, <span class="number">4</span>));  <span class="comment">// 함수형 인터페이스의 사용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>자바는 java.util.function 패키지를 통해 여러 상황에서 사용할 수 있는 다양한 함수형 인터페이스를 미리 정의하여 재공합니다.</p>
<h1 id="메소드-참조">메소드 참조</h1>
<hr>
<p>메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있도록 해줍니다.</p>
<p>메소드 참조를 사용하면 불필요한 매개변수를 제거하고 다음과 같이 ‘::’ 기호를 사용하여 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">클래스이름::메소드이름</span><br><span class="line">또는</span><br><span class="line">참조변수이름::메소드이름</span><br></pre></td></tr></table></figure>
<p>다음 코드는 두 개의 값을 전달받아 제곱 연산을 수행하는 Math 클래스의 클래스 메소드인 pow() 메소드를 호출하는 람다 표현식입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base, exponent) -&gt; Math.pow(base, exponent);</span><br><span class="line"><span class="comment">// 위의 식은 단순히 Math 클래스의 pow() 메소드로 인수를</span></span><br><span class="line"><span class="comment">// 전달하는 역할만 하므로, 메소드 참조를 사용해 다음과 같이 표현 가능</span></span><br><span class="line">Math::pow;</span><br></pre></td></tr></table></figure>
<p>또한, 특정 인스턴스의 메소드를 참조할 때에도 참조 변수의 이름을 통해 메소드 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass;</span><br><span class="line">Function&lt;String, Boolean&gt; func = (a) -&gt; obj.equals(a); <span class="comment">// 람다 표현식</span></span><br><span class="line">Function&lt;String, Boolean&gt; func = obj::equals(a);       <span class="comment">// 메소드 참조</span></span><br></pre></td></tr></table></figure>
<p>다음 코드는 람다 표현식과 메소드 참조를 비교하는 코드입니다. 아래의 코드에서 차이를 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DoubleUnaryOperator oper;</span><br><span class="line"></span><br><span class="line">oper = (n) -&gt; Math.abs(n); <span class="comment">// 람다 표현식</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">oper = Math::abs; <span class="comment">// 메소드 참조</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>DoubleUnaryOperator 인터페이스는 한 개의 double 형 매개변수를 전달받아 한 개의 double 형 값을 반환하는 java.util.function 패키지에서 제공하는 함수형 인터페이스입니다.</p>
</blockquote>
<h2 id="생성자-참조">생성자 참조</h2>
<p>생성자를 호출하는 람다 표현식도 앞서 살펴본 메소드 참조를 이용할 수 있습니다. 즉, 단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 단순히 Object 클래스의 인스턴스를 생성하고 반환하기만 하므로, 생성자 참조를 사용하여 다음처럼 간단하게 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>이때, 해당 생성자가 존재하지 않으면 컴파일 시 오류가 발생합니다. 또한, 배열을 생성할 때에도 다음과 같이 생성자 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func1 = a -&gt; <span class="keyword">new</span> <span class="keyword">double</span>[a];</span><br><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func2 = <span class="keyword">double</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 생성자 참조</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-17/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-16/"
                            aria-label=": [Java] 16. 스레드"
                        >
                            [Java] 16. 스레드
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T12:48:43+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="프로세스process란">프로세스(process)란?</h1>
<hr>
<p><strong>프로세스란 단순히 실행 중인 프로그램이라고 할 수 있습니다. 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다. 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.</strong></p>
<h1 id="스레드thread란">스레드(thread)란?</h1>
<hr>
<p>스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.</p>
<h2 id="스레드의-생성과-실행">스레드의 생성과 실행</h2>
<p>자바에서 스레드를 생성하는 방법에는 다음과 같은 두 가지 방법이 있습니다.</p>
<ol>
<li>Runnable 인터페이스를 구현하는 방법</li>
<li>Thread 클래스를 상속받는 방법</li>
</ol>
<p>두 방법 모두 스레드를 통해 작업하고 싶은 내용을 run()이라는 메소드에 작성하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadWithClass thread1 = <span class="keyword">new</span> ThreadWithClass();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// Runnable을 구현한 클래스는 Thread가 없기 때문에 Thread 타입으로 객체를 만들고 구현한 클래스를</span></span><br><span class="line">        <span class="comment">// 생성자에 매개변수로 넣는다.</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread 클래스를 상속받아 Thread 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithClass</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread를 상속받아 구현 : "</span>+getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위의 결과를 보면, 생성된 스레드가 서로 번갈아가며 실행되고 있는 것을 확인할 수 있습니다. 스레드의 실행은 어떤 것이 먼저 실행되는 것인지 정해져 있지 않습니다. 그리고 Thread의 실행은 start()라는 메소드를 호출함으로써 실행시킬 수 있습니다.</p>
<p>Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없으므로, 일반적으로 Runnable 인터페이스를 구현하는 방법으로 스레드를 생성합니다.</p>
<blockquote>
<p>Runnable 인터페이스는 몸체가 없는 메소드인 run() 메소드 단 하나만을 가지는 간단한 인터페이스입니다.</p>
</blockquote>
<h2 id="스레드-우선순위">스레드 우선순위</h2>
<p>자바에서 각 스레드는 <code>우선순위(priority)</code>에 관한 자신만의 필드를 가지고 있습니다. 이러한 우선순위에 따라 특정 스레드가 더 많은 시간 동안 작업을 할 수 있도록 설정할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">필드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int MAX_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최대 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int MIN_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최소 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int NORM_PRIORITY</td>
<td style="text-align:center">스레드가 생성될 때 가지는 기본 우선순위를 명시함.</td>
</tr>
</tbody>
</table>
<p>getPriority()와 setPriority() 메소드를 통해 스레드의 우선순위를 반환하거나 변경할 수 있습니다. 스레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, <strong>숫자가 높을수록 우선순위 또한 높아집니다.</strong></p>
<p><strong>하지만 스레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐입니다. 우선순위가 10인 스레드가 우선순위가 1인 스레드보다 10배 더 빨리 수행되는 것이 아닙니다. 단지 우선순위가 10인 스레드는 우선순위가 1인 스레드보다 좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐입니다.</strong></p>
<p>그리고 스레드의 우선순위는 해당 스레드를 생성한 스레드의 우선순위를 상속받게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">      </span><br><span class="line">        thread2.setPriority(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 1 : thread-1의 우선순위를 10으로 변경함</span></span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 2 : thread-0 실행</span></span><br><span class="line">        thread2.start(); <span class="comment">// 3 : thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getPriority());</span><br><span class="line">        System.out.println(thread2.getPriority());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>main() 메소드를 실행하는 스레드의 우선순위는 언제나 5이므로, main() 메소드 내에서 생성된 스레드는 Thread-0의 우선순위는 5로 설정되는 것을 확인할 수 있습니다.</p>
<p>위의 코드에서 2번 라인에서 Thread-0이 먼저 실행되고, 3번 라인에서 Thread-1이 나중에 실행됩니다. 따라서 만약 1번 라인이 존재하지 않는다면, Thread-0이 먼저 실행되고, Thread-1이 나중에 실행될 것입니다. 하지만 1번 라인에서 Thread-1의 우선순위를 10으로 변경했기 때문에, Thread-1이 나중에 실행되었더라도 우선순위가 Thread-0보다 높아서 먼저 실행되는 것입니다.</p>
<h1 id="멀티-스레드multi-thread">멀티 스레드(multi thread)</h1>
<hr>
<p>스레드와 관련된 내용은 운영체제(OS)와 연관된 내용입니다. 그래서 여기에서는 간단하게 알아보고 추후에 운영체제 공부를 할 때 자세하게 포스팅하겠습니다. :)</p>
<p>일반적으로 하나의 프로세스는 하나의 스레드를 가지고 작업을 수행하게 됩니다. 하지만 멀티 스레드(multi trhead)란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다.<br>
또한, 멀티 프로세스(multi process)는 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미합니다.</p>
<p>멀티 스레드와 멀티 프로세스 모두 여러 흐름을 동시에 수행한다는 공통점을 가지고 있습니다. 멀티 프로세스는 각 프로세스가 독립적인 메모리를 가지고 별도로 실행되지만, <strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유한다는 점이 다릅니다.</strong></p>
<p><strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적습니다. 또한, 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아집니다.</strong></p>
<h2 id="문맥-교환context-switching">문맥 교환(context switching)</h2>
<p>컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어(core) 수와 같습니다. 만약 CPU의 코어 수보다 더 많은 스레드가 실행되면, 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행하게 됩니다.</p>
<p>이 때, 각 스레드가 서로 교체될 때 스레드 간의 <code>문맥 교환(context switching)</code>이라는 것이 발생합니다. <strong>문맥 교환이란 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업을 가리킵니다.</strong></p>
<p><strong>이러한 문맥 교환에 걸리는 시간이 커지면 커질수록, 멀티 스레딩의 효율은 저하됩니다. 오히여 많은 양의 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있습니다. 따라서 많은 수의 스레드를 실행하는 것이 언제나 좋은 성능을 보이는 것은 아니라는 점을 유의해야 합니다.</strong></p>
<h2 id="스레드-그룹thread-group">스레드 그룹(thread group)</h2>
<p><code>스레드 그룹(thread group)이란 서로 관련이 있는 스레드를 하나의 그룹으로 묶어 다루기 위한 장치입니다.</code> 자바에서는 스레드 그룹을 다루기 위해 ThreadGroup라는 클래스를 제공합니다.</p>
<p>이러한 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이렇게 포함된 스레드 그룹은 트리 형태로 연결됩니다. 이 때, 스레드는 자신이 포함된 스레드나 그 하위 그룹에는 접근할 수 있지만 다른 그룹에는 접근할 수 없습니다.<br>
<strong>이렇게 스레드 그룹은 스레드가 접근할 수 있는 범위를 제한하는 보안상으로도 중요한 역할을 하고 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.start(); <span class="comment">// thread-0 실행</span></span><br><span class="line">        System.out.println(thread0.getThreadGroup());</span><br><span class="line"></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"MyThread"</span>);</span><br><span class="line">        <span class="comment">// MyThread라는 스레드 그룹 생성</span></span><br><span class="line">        threadGroup.setMaxPriority(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 해당 스레드 그룹의 최대 우선순위를 7로 설정함</span></span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// 스레드를 생성할 때 포함될 스레드 그룹을 전달할 수 있다.</span></span><br><span class="line">        thread1.start(); <span class="comment">// thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getThreadGroup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">java.lang.ThreadGroup[name=MyThread,maxpri=<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 main() 메소드에서 생성된 스레드의 기본 스레드 그룹의 이름은 <strong>main</strong>이 되며, 최대 우선순위는 10으로 자동 설정됩니다.</p>
<h2 id="데몬-스레드deamon-thread">데몬 스레드(deamon thread)</h2>
<p><strong>데몬 스레드(deamo thread)란 다른 일반 스레드의 작업을 돕는 보조적인 역할을 하는 스레드를 가리킵니다. 따라서 데몬 스레드는 일반 스레드가 모두 종료되면 더는 할 일이 없으므로, 데몬 스레드 역시 자동으로 종료됩니다.</strong></p>
<p>데몬 스레드의 생성 방법과 실행 방법은 모두 일반 스레드와 같습니다. 단, 실행하기 전에 <code>setDaemon()</code> 메소드를 호출하여 데몬 스레드로 설정하기만 하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 데몬 스레드로 설정</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 데몬 스레드는 일정 시간마다 자동으로 수행되는 저장 및 화면 갱신 등에 이용되고 있습니다.</p>
<h2 id="가비지-컬렉터garbage-collector">가비지 컬렉터(garbage collector)</h2>
<blockquote>
<p>가비지 컬렉터는 자바에서 중요한 개념으로 알고 있습니다. 이 부분에 대한 심화된 내용은 별도의 포스트에서 소개할 예정이고, 이번에는 간단하게 알고 넘어가도록 하겠습니다.</p>
</blockquote>
<p><strong>데몬 스레드를 이용하는 가장 대표적인 예로 가비지 컬렉터(garbage collector)를 들 수 있습니다. 가비지 컬렉터(garbage collector)란 프로그래머가 동적으로 할당한 메모리 중 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제해 주는 데몬 스레드입니다.</strong></p>
<p>자바에서는 프로그래머가 메모리에 직접 접근하지 못하게 하는 대신에 가비지 컬렉터가 자동으로 메모리를 관리해 줍니다. 이러한 가비지 컬렉터를 이용하면 프로그래밍을 하기가 훨씬 쉬워지며, 메모리에 관련된 버그가 발생할 확률도 낮아집니다.</p>
<p>보통 가비지 컬렉터가 동작하는 동안에는 프로세서가 일시적으로 중지되므로, 필연적으로 성능의 저하가 발생합니다. 하지만 요즘에는 가비지 컬렉터의 성능이 많이 향상되어, 새롭게 만들어지는 대부분의 프로그래밍 언어에서 가비지 컬렉터를 제공하고 있습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-16/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/categories/Java/archives/3/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
