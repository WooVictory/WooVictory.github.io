
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Category: Android - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/categories/Android/archives/4/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/10/Android-MVVM/"
                            aria-label=": [Android] MVVM Part.2"
                        >
                            [Android] MVVM Part.2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-10T15:51:20+09:00">
	
		    Jun 10, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.1</a></li>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.2</a></li>
</ol>
<p>MVVM에 대한 이해가 부족해 보충하고자 조금 더 공부하며 정리를 하고자 한다.</p>
<p>안드로이드 개발을 처음 시작한다면 하나의 액티비티에 모든 코드를 넣어서 개발을 할 것이다. 이렇게 되면 시간이 지날수록 액티비티는 무거워지고 많은 일을 담당하게 될 것이다. 그로 인해 수정이나 유지보수하기가 힘들어진다. 이처럼 비구조적이고 유지보수가 어려운 코드를 스파게티 코드라고 하는데, 나의 첫 프로젝트도 기가 막힌 스파게티 코드였다.</p>
<p>스파게티 코드를 줄이고 이쁜 코드를 만들기 위해 디자인 패턴 공부의 필요성을 느끼게 되었다. 수업 시간에 들은 디자인 패턴을 잘 숙지해둘 걸 하는 후회가 밀려온다. 기억이 잘 나지 않기 때문이다…ㅜ</p>
<p>아무튼 디자인 패턴은 차근차근 공부하기로 하고 MVVM에 대한 글을 쓰면서 내가 알고 있는 개념도 정리하려고 두 번째 글을 쓰게 되었다. 첫 번째 글은 MVP와 MVVM의 차이에 대한 설명과 어떤 점이 좋은지에 대해 간략하게 설명하고 있다.</p>
<h2 id="mvvm-패턴">MVVM 패턴</h2>
<p>액티비티에 기능을 붙이다보면 액티비티가 무거워지거나 혹은 종속성이 너무 강해 테스트가 힘들고 유지보수가 어려워진다. 이러한 고민을 해결하기 위해 Architecture 패턴이 등장했고 그 중 하나가 이번에 살펴볼 MVVM이다. MVVM은 View - ViewModel - Model을 이용해 각각의 역할을 분리하여 가독성과 재사용성을 높인 Architecture 패턴이다.</p>
<p><strong>MVC와 MVV 차이점</strong></p>
<p>기존 MVC(Model - View - Controller) 구조에서는 액티비티가 컨트롤러의 역할을 했으며, 뷰와 연결되어 사용자와 상호작용도 하고 모델과 연결되어 데이터도 처리했다. 즉, 뷰와 모델 사이에서 중재자 역할을 했다.</p>
<p>MVVM에서는 뷰에서 뷰모델로, 뷰모델에서 모델로 작업을 처리하며, 뷰에서 모델을 직접 참조하지 않는다. 대신 뷰에서 뷰모델을 관찰하여 데이터의 변경 사항을 감지한다.</p>
<img src="/img/mvc_mvvm_diff.png" width="600" height="200">
<p>예를 들어보자. 유저가 목록에 새로운 아이템을 추가했다.</p>
<p>MVC에서는 컨트롤러가 유저의 클릭 액션을 확인하고, 모델에 데이터를 갱신하도록 요청한다. 그리고 뷰에도 화면을 업데이트하라고 요청을 해야 한다. 이 경우 액티비티가 해야 할 일이 너무 많다. 까닥하면 DB만 갱신되고 화면은 갱신되지 않는 경우도 있다.</p>
<p>MVVM에서도 뷰가 유저의 클릭 액션을 확인하지만, 뷰에서 곧바로 DB에 접근하지 않는다. 말 그대로 뷰이기 때문에 UI를 갱신하는 역할에 충실하다. 대신 뷰모델을 참조하고, 뷰모델에서는 다시 모델에서 정리된 데이터를 참조한다. 또, 뷰는 뷰모델은 <strong>관찰(Observe)</strong> 한다. DB에 새로운 아이템을 추가한 후에 화면을 업데이트 하라고 직접 명령하지 않아도 된다. 뷰에서는 이미 뷰모델을 관찰하고 있기 때문에 데이터의 변화를 알아차리고 자동으로 화면을 갱신한다.</p>
<p><strong>MVVM의 장점</strong></p>
<ol>
<li><strong>뷰가 데이터를 실시간으로 관찰한다.</strong></li>
</ol>
<p>LiveData 즉, Observer 패턴을 이용하기 때문에 데이터베이스를 관찰하고 자동으로 UI를 갱신한다. 직접 뷰를 바꿔주는 번거로움도 없으며 데이터와 불일치할 확률이 줄어든다.</p>
<ol start="2">
<li><strong>생명주기로부터 안전하다. 메모리 누수 방지!</strong></li>
</ol>
<p>AAC의 뷰모델을 통해 데이터를 참조하기 때문에 액티비티/프래그먼트의 생명주기를 따르지 않는다. 즉, 액티비티/프래그먼트의 생명주기 동안 계속 살아있고, onDestroy()가 호출될 때 사라지게 된다.</p>
<p>화면 회전과 같이 액티비티가 파괴된 후에 재구성되어도 뷰모델이 데이터를 홀드하고 있기 때문에 영향을 받지 않는다. 또한, 뷰가 활성화되어있을 경우에만 작동하기 때문에 불필요한 메모리 사용을 줄일 수 있다.</p>
<ol start="3">
<li><strong>역할 분리!</strong></li>
</ol>
<p>UI, 비즈니스 로직, 모델이 기능별로 모듈화 되어 있어서 역할 별로 분리가 되어있다. 이로 인해서 테스트 코드를 작성하는게 한결 수월해진다. 이처럼 모듈화가 잘 되어 있다면 다음과 같은 상황에서 수정이 쉽다.</p>
<ul>
<li>내장 DB를 통째로 바꾸고 싶다고 할 때, 뷰나 다른 코드에 깊게 종속되어 있지 않기 때문에 DB만 교체하면 된다.</li>
<li>뷰모델과 뷰는 1:N 관계를 갖기 때문에 뷰모델에 하나의 메소드를 구현하고 A 액티비티나 B 액티비티, 여러 뷰에서 호출해 사용하기 때문에 재사용이 가능하다.</li>
</ul>
<h2 id="aac">AAC</h2>
<p>구글은 Android Architecture Component 이하 AAC를 제공한다. AAC는 앱 구조를 더 튼튼하고 테스트에 용이하고, 유지보수성이 뛰어나게 만들도록 도와주는 라이브러리의 모음이다. 조금 더 모듈화된 코딩을 돕기 위해 Databinding, LiveData, ViewModel 등의 유용한 라이브러리를 제공하며, 이러한 라이브러리를 사용해 MVVM 패턴을 조금 더 쉽게 구성할 수 있다.</p>
<img src="/img/mvvm_detail.png" width="600" height="200">
<p>위의 이미지에서 MVVM의 구성 요소로 역할을 나눠보자.</p>
<ul>
<li>View : 초록색(UI)</li>
<li>ViewModel: 파란색</li>
<li>Model : 노란색(Repository), Room Database</li>
</ul>
<p><strong>View</strong></p>
<ul>
<li>UI를 담당하는 액티비티, 프래그먼트를 의미한다.</li>
<li>화면에 무엇을 그릴지 결정하고 사용자와 상호작용한다.</li>
<li>보통 데이터의 변화를 감지하기 위한 옵저버를 가지고 있다.</li>
</ul>
<p><strong>ViewModel</strong></p>
<ul>
<li>UI를 위한 데이터를 가지고 있으며, 구성이 변경되어도 살아남는다.(ex. 화면 회전, 언어 변경 등)</li>
<li>AsyncTask는 액티비티나 프래그먼트의 생명 주기에서 자유로울 수 없지만, 뷰모델은 뷰와 분리되어 있기 때문에 액티비티가 Destory 되었다가 다시 Create 되어도 종료되지 않고 데이터를 여전히 유지하고 있다.</li>
</ul>
<p><strong>LiveData</strong></p>
<ul>
<li>관찰(Observable)이 가능한 데이터 홀더 클래스이다.</li>
<li>뷰에서 뷰모델의 Live Data를 관찰하게 되면 데이터가 변경될 때 내부적으로 자동으로 알려주게 된다.</li>
<li>또한, Live Data는 액티비티나 프래그먼트의 생명 주기를 인지한다. 즉, 액티비티가 활성화되어 있을 때에만 UI 변경 등의 기능을 동작하게 되고, Destory된 상태에서는 동작하지 않기 때문에 Memory Leak의 발생을 줄여준다.</li>
</ul>
<p><strong>Repository</strong></p>
<ul>
<li>뷰 모델과 상호작용하기 위해 잘 정리된 데이터 API를 들고 있는 클래스이다.</li>
<li>앱에 필요한 데이터, 즉 내장 데이터베이스나 외부 웹 서버 등에서 데이터를 가져온다.</li>
<li>따라서 뷰모델은 DB나 서버에 직접 접근하지 않고, Repository에 접근하는 것으로 앱의 데이터를 관리한다.</li>
</ul>
<h2 id="결론">결론</h2>
<p>MVVM에 대해 처음에는 이해하기가 너무 어려웠다. 왜냐하면 간단한 기능을 가진 앱을 만들더라도 많은 클래스가 필요하고, 프로젝트의 패키지 구조가 복잡해지기 때문이다.</p>
<p>또한, 인터넷 상에 존재하는 대부분의 MVVM 예제는 DI가 적용된 것들이 많다. MVVM도 처음에 어려운데 DI까지 함께 한다면 정말 머리가 깨질 수도 있다.</p>
<p>그래서 나는 Koin을 사용한 MVVM 예제를 찾았고 이를 많이 참고했다. Dagger2에 비해서 접근하기가 훨씬 쉬우며, 사용법도 간단해서 금방 배울 수 있다고 생각한다.</p>
<p>아래는 내가 공부하면서 참고했던 Sample 프로젝트의 출처이다.</p>
<ul>
<li>
<ol>
<li><a href="https://deque.tistory.com/108" target="_blank" rel="noopener">Android Kotlin MVVM패턴으로 간단한 검색 앱 만들기 - 1. BaseView, BaseViewModel을 작성하여 MVVM의 토대 만들기</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="https://kaidroid.me/post/android-mvvm-viewmodel-livedata-databinding/" target="_blank" rel="noopener">Android MVVM 패턴, ViewModel, LiveData, Databinding을 이용해 간단한 Toy App 만들기</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="https://black-jin0427.tistory.com/138" target="_blank" rel="noopener">[Android, MVVM] ViewModel, LiveData, DataBinding, Koin 을 사용한 MVVM</a></li>
</ol>
</li>
</ul>
<p>그래도 위의 프로젝트를 참고해서 구조를 익히고 따라해서 만들고 직접 간단하게라도 적용해본다면 MVVM에 대한 이해가 될 것이라고 생각한다. 나도 위의 3 프로젝트를 직접 따라해보면서 코딩해봤고, 혼자서 분석도 해봤다.</p>
<p>그래서 지금 진행 중인 프로젝트에 MVVM을 적용하고 있다. 아직 어려운 부분이 좀 많지만 그때 그때 구글링을 통해서 해결하고 있다. 이런 해결 과정도 정리해놓으면 좋을 것 같다. 아무튼, 모두 화이팅!(나도!)</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://blog.yena.io/studynote/2019/03/16/Android-MVVM-AAC-1.html" target="_blank" rel="noopener">[Android] MVVM &amp; 안드로이드 아키텍쳐 컴포넌트 시작하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/10/Android-MVVM/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/09/What-is-MVVM/"
                            aria-label=": [Android] MVVM Part.1"
                        >
                            [Android] MVVM Part.1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-09T22:37:20+09:00">
	
		    Jun 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.1</a></li>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.2</a></li>
</ol>
<ul>
<li>LiveData</li>
<li>ViewModel</li>
<li>Databinding<br>
선수 지식 필요.</li>
</ul>
<p>Architecture 패턴에는 일반적으로 사용하는 MVC, MVP, MVVM이 있다. 이러한 Architecture 적용으로 얻는 이점은 안정적인 서비스 개발을 할 수 있으며 유지 보수를 빠르게 할 수 있다는 것이다.</p>
<p>먼저, MVP Architecture부터 살펴보자.</p>
<h2 id="1-mvp">1. MVP</h2>
<img src="/img/mvp_android.png" width="600" height="200">
<ul>
<li>Presenter : View에서 요청한 정보를 Model로부터 가공해서 View로 전달하는 부분</li>
</ul>
<p>Model과 View는 MVC와 동일하지만 사용자 입력을 View에서 받는다. 그리고 Model과 View는 각각 Presenter와 상호 작용을 하게 된다. 항상 Presenter를 거쳐 동작하는 셈이다.</p>
<p>그러므로 View와 Model은 서로를 알 필요가 전혀 없다. Presenter만 알면 된다. 그래서 MVC의 단점인 View와 Model의 의존성이 없어지게 된다.</p>
<p><code>정리하자면</code></p>
<ol>
<li>View로 사용자의 입력이 들어온다.</li>
<li>View는 Presenter에 작업 요청을 한다.</li>
<li>Presenter에서 필요한 데이터를 Model에 요청한다.</li>
<li>Model은 Presenter에 필요한 데이터를 응답한다.</li>
<li>Presenter는 View에 데이터를 응답한다.</li>
<li>View는 Presenter로부터 받은 데이터로 화면에 보여주게 된다.</li>
</ol>
<p>View에서 비즈니스 로직을 분리하는 부분은 성공적이다. Model 역시 분할되어 있어서 적용하기 쉽다. 하지만, View와 Presenter의 1:1 관계를 유지하는 덕분에 몇 가지 단점이 생긴다.</p>
<ul>
<li>중복 코드 발생한다.</li>
<li>View에 대한 의존성이 강해진다.</li>
</ul>
<p><strong>중복 코드?</strong></p>
<p>간단한 예를 들어보겠다.<br>
로그인과 로그아웃은 어떠한 화면에서도 호출될 수 있다. 기획상으로 가능하다면 말이다.<br>
A/B/C/D 4개의 화면이 있고, 언제든 로그인만 호출할 수 있다. 대부분은 로그인 Acitivity로 이동시키고 이를 구현하면 된다.</p>
<p>반대로 로그아웃이다. 단순하게 로그아웃한다고 생각해보자. 로그아웃 역시 A/B/C/D 화면에서 언제든 접근할 수 있다.</p>
<p><strong>MVP에서는?</strong></p>
<p>로그인, 로그아웃을 처리하는 비즈니스 로직은 A/B/C/D 화면에 종속적인 Presenter 4개에서 모두 호출하게 된다. 모델에서 실제 로그인, 로그아웃 처리 로직이 있는 부분은 가져다가 사용하는 것이다.</p>
<p>여기서 <strong>공통 코드</strong>가 발생하게 된다.</p>
<p><strong>공통 코드?</strong></p>
<p>MVP에서 발생하는 공통 코드를 어떻게 해결할 수 있을까?</p>
<ul>
<li>Presenter도 상속을 받아서 공통 코드를 해결</li>
<li>별도의 공통 로직을 가지는 새로운 클래스를 생성</li>
<li>Presenter 분리?</li>
</ul>
<p>위와 같은 공통 코드를 관리할 수는 있다.</p>
<p><strong>MVVM은 View Model 분리의 시작</strong></p>
<p>위에서 적은 Presenter를 분리하면 MVVM이 된다. <strong>View에 대한 모델을 분리하였기 때문에 ViewModel이다.</strong></p>
<p>즉,ViewModel은 View에 대한 모델 분리가 있어야 한다. View에서 사용하는 중복적인 Presenter의 코드가 발생하면 이를 ViewModel 하나로 분리해주는게 가장 이상적이다.</p>
<p>MVP의 기본 개념인 View와 Presenter의 1:1 관계 유지에서 벗어나기 위해서는 MVVM이 가장 좋은 해결책으로 보인다. 조금 더 이쁜 코드를 만들기 위해서는 최소한 View에 대한 Model은 정의해주어야 한다. 그렇게 해야 아래와 같은 처리가 가능해진다.</p>
<ul>
<li>View에 대한 종속성을 줄인다.
<ul>
<li>종속성을 줄이기 위해 ReactiveX, Databinding 등을 이용할 수 있다.</li>
</ul>
</li>
<li>View에 대한 Model 정의가 명확해야 한다.
<ul>
<li>이 ViewModel은 언제든 View에서 가져다 쓰기만 하면 되고, 불필요한 경우 해당 ViewModel만 버릴 수 있어야 한다.</li>
</ul>
</li>
<li>ViewModel에 대한 테스트가 가능해진다.
<ul>
<li>View에 대한 테스트와 완전하게 분리 가능하여 비즈니스 로직이 아닌 각각의 ViewModel 테스트가 가능해진다.</li>
</ul>
</li>
</ul>
<p><strong>MVVM의 ViewModel이란?</strong></p>
<p>MVVM은 고민을 많이 해야 하는 구조이다.</p>
<ul>
<li>ViewModel 분리가 필요할까?</li>
<li>분리했을 때 얻는 이점은?</li>
<li>종속성은?
<ul>
<li>ReactiveX, DataBinding 등을 이용해 해결할 수 있다.</li>
</ul>
</li>
<li>테스트 코드는?
<ul>
<li>테스트 코드는 유용해야 한다.</li>
</ul>
</li>
</ul>
<p>View에 대한 모델을 모두 분리한다면? 다음과 같이 구성할 수 있을 것이다.</p>
<ul>
<li>LoginViewModel : 로그인만 하는 모델</li>
<li>LogoutViewModel : 로그아웃만 하는 모델</li>
<li>UserInfoViewModel : 사용자 정보만을 가져와 가공한다.</li>
</ul>
<p>여기까지 MVP와 MVVM에 대해 차이점과 ViewModel에 대해 조금 알아봤다. 이제는 MVVM을 알아보도록 하자.</p>
<h2 id="2-mvvm">2. MVVM</h2>
<img src="/img/mvvm_android.png" width="600" height="200">
<p>Presenter 대신에 ViewModel이 존재한다.</p>
<ul>
<li>ViewModel : View를 표현하기 위해 만들어진 View를 위한 Model</li>
</ul>
<p>MVVM에서는 두 가지 디자인 패턴을 사용한다. <strong>Command 패턴</strong>과 <strong>Data binding</strong>이다. 이 두 가지 디자인 패턴을 사용함으로써 View와 ViewModel은 의존성이 완전히 사라지게 된다.</p>
<p>View에서 입력이 들어오고 Command 패턴을 통해서 ViewModel에 명령을 내리게 되고 Data binding으로 인해 ViewModel의 값이 변화하면 바로 View의 정보가 바뀌게 된다.</p>
<p><code>정리하자면</code></p>
<ol>
<li>View에 입력이 들어오면 Command 패턴으로 ViewModel에 명령을 한다.</li>
<li>ViewModel은 필요한 데이터를 Model에 요청한다.</li>
<li>Model은 ViewModel에 필요한 데이터를 응답한다.</li>
<li>ViewModel은 응답 받은 데이터를 가공해서 저장한다.</li>
<li>View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신된다.</li>
</ol>
<p><strong>왜 MVVM을 사용할까?</strong></p>
<p>전통적인 UI 개발에서 개발자는 윈도우, 사용자 컨트롤, 페이지를 사용해서 View를 만들곤 했다. 그리고 모든 논리 로직이 들어간 코드(핸들링, 초기화 그리고 데이터 모델 등)를 뷰 클래스에 정의한다. 이러한 방법은 뷰 클래스의 크기를 늘리고 UI와 데이터 그리고 비즈니스 사이의 <code>매우 강한 의존성</code>을 형성한다.</p>
<p>이와 같은 상황에서 여러 개발자들은 동시에 같은 뷰에서 작업하기 힘들어 질 것이다. 즉, 협업하는 상황에서 같은 화면을 함께 개발하지 못하고 서로 다른 화면을 개발해야 하는 비효율적인 상황이 발생할 것이다. 또한, 다른 개발자가 코드를 바꾸면 다른 부분을 망가뜨릴 위험도 존재한다.</p>
<p><strong>이처럼 모든 코드들이 한 클래스에 있는 것은 유지보수 그리고 테스트를 하는데 있어서 좋지 않다.</strong></p>
<ol>
<li>뷰(UI)</li>
<li>모델(UI 상에 보여지고 있는 데이터)</li>
<li>글루 코드(핸들링과 바인딩 그리고 비즈니스 로직)</li>
</ol>
<ul>
<li>글루 코드 : 서로 다른 코드를 접착시키는 코드</li>
<li>비즈니스 로직 : 데이터의 처리가 이루어지는 부분</li>
</ul>
<p>MVVM에서 글루 코드는 뷰 모델이다. 그래서 애플리케이션의 구조를 더욱 간단하고 유지가능할 수 있게 만들기 위해서는 <strong>관심사의 분리</strong>에 집중해야 한다.</p>
<p>만약, 뷰 모델에서의 프로퍼티 값이 변하게 되면 데이터 바인딩과 노티피케이션을 통해 자동으로 새로운 값을 알려준다. 만약 사용자가 저장하기 버튼을 클릭하는 액션을 뷰에서 취했을 때, 뷰모델은 요청된 명령을 실행한다. 이 과정에서 뷰모델은 모델의 데이터를 수정하고 뷰는 데이터를 수정하지 않는다. 뷰는 모델의 존재를 모른다. 반면 뷰 모델과 모델은 뷰를 인식하지 않는다. 모델은 뷰와 뷰 모델의 존재를 모른다.</p>
<p><strong>MVVM에 대해</strong></p>
<p>MVVM 패턴을 지켜 개발된 앱은 아래의 특징을 갖는다.</p>
<ol>
<li>관심사의 분리 - 하나의 소프트웨어를 최대한 기능적으로 작은 단위로 나눈다</li>
<li>테스트가 쉬워지고 큰 프로젝트도 상대적으로 관리하기 좋다.</li>
<li>SOLID 원칙을 지향한다.</li>
<li>앱이 구조적으로 약한 결합의 컴포넌트로 나눠진다.</li>
</ol>
<p>대체적으로 위와 같은 장점에 대해서 이야기를 하지만 결국 가장 큰 목적은 <strong>유지보수가 쉽고 테스트가 용이한 코드를 만드는 것이다.</strong></p>
<img src="/img/mvvm.png" width="600" height="200">
<p>View는 ViewModel에게 클릭 이벤트, 필요한 데이터 요청 등을 명시적으로 하고 ViewModel이 notify할 때까지 기다리게 된다.</p>
<p>동일하게 ViewModel은 Model을 통해 데이터를 요청하고 기다리게 된다. 각각의 컴포넌트간 참조를 갖지 않고 <strong>단방향(View -&gt; ViewModel -&gt; Model)의 의존성만을 갖게 된다.</strong></p>
<p><strong>정리</strong></p>
<ol>
<li>뷰, 뷰모델, 모델 이 셋은 서로의 존재를 몰라야 한다.<br>
-&gt; 서로 간의 의존성을 최대한 제거함으로써 유지보수가 쉽고 테스트 가능한 코드가 된다.</li>
<li>뷰에서 액션을 받으면 뷰모델에서 비즈니스 로직을 실행한다.</li>
<li>뷰 모델은 모델의 데이터를 수정한다.</li>
<li>뷰 모델은 데이터 바인딩과 노티피케이션을 통해 뷰를 수정한다.</li>
<li>뷰와 뷰 모델은 n:m의 관계이다.</li>
<li>오직 뷰모델만이 모델에 접근할 수 있고 뷰는 모델에 접근하지 못한다.</li>
</ol>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="https://black-jin0427.tistory.com/133" target="_blank" rel="noopener">[번역] MVVM 디자인 패턴의 기본 이해</a></li>
<li><a href="https://magi82.github.io/android-mvc-mvp-mvvm/" target="_blank" rel="noopener">MVC, MVP, MVVM 비교</a></li>
<li><a href="https://thdev.tech/androiddev/2017/03/12/Android-MVVM-Architecture-intro/" target="_blank" rel="noopener">Android MVVM 어떻게 구현하는게 좋을까?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/09/What-is-MVVM/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/05/Android-Glide/"
                            aria-label=": [Android] Glide 삽질 과정"
                        >
                            [Android] Glide 삽질 과정
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-05T16:28:28+09:00">
	
		    Jun 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 앱에서 이미지를 보여주는 화면이 많다. 서버로부터 받은 url 이미지를 보여줘야 할 때도 있고, local에 저장해뒀다가 보여줘야 하는 경우도 있다. 오늘 이야기할 내용은 Glide를 사용해서 <strong>SVG</strong> 이미지를 화면에 보여주는 과정에서 내가 겪은 삽집을 풀도록 하겠다.</p>
<p>먼저, SVG 이미지가 무엇인지 알아보자.</p>
<h2 id="svg-vs-png">SVG VS PNG</h2>
<p>SVG는 <strong>Scalable Vector Graphics</strong>의 약자이다.<br>
JPEG, PNG처럼 그래픽 포맷 중 하나이다. SVG는 벡터 기반으로 리사이징이 되어도 깨지지 않는다는 장점을 가지고 있다. 즉, 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다.</p>
<p><strong>장점</strong></p>
<ol>
<li>특정 사이즈에 구애받지 않는다.</li>
</ol>
<p>즉, 위에서 언급했듯이 어느 해상도에서든 pixelate 되지 않는다. SVG는 어떤 사이즈로든 그 모습 그대로 유지된다. 그렇기 때문에 사이즈별로 아이콘을 모두 생성해서 개발자에게 넘겨줄 필요가 없다. SVG 파일 하나로 모든 해상도를 대응할 수 있다.</p>
<ol start="2">
<li>작은 파일 사이즈</li>
</ol>
<p>비트맵 이미지(PNG, JPEG) 같은 경우 파일 크기를 결정하는 주요 요소는 <strong>해상도</strong>이다. 예를 들어 5000x5000 픽셀 이미지는 항상 500x500보다 파일 사이즈가 크다.<br>
반면, SVG 그래픽 같은 경우 파일의 크기를 결정하는 주요 요소는 바로 <strong>복잡도</strong>이다. Path가 비교적 적은 간단한 이미지는 PNG, JPEG 보다 파일 사이즈가 적을 수도 있지만 이미지를 구성하는 요소의 복잡도(레이어가 많다든지 특정 효과가 많다드지)에 따라서 파일 사이즈가 커진다. 하지만, 이런 용량 문제는 SVG Optimizing이라는 것을 하게 되면 어느 정도 해결이 된다. 작은 파일 사이즈로 인해 로딩 시간도 줄어든다는 장점 또한 있다.</p>
<h2 id="bitmap과-svg-구성요소">Bitmap과 SVG 구성요소</h2>
<ul>
<li>비트맵 그래픽 : Raster Graphics(픽셀 기반)</li>
</ul>
<p>대표적인 포맷은 JPEG, PNG이다. 이들은 픽셀로 구성되어 있다. 예를 들어, 2x2 픽셀인 비트맵 이미지는 총 4px로 구성되어 있다. 개개인에 대한 픽셀들은 자유자재로 바꿀 수가 없고 움직일 수도 없다. 그렇기 때문에 100% 이상으로 이미지를 확대하면 Pixelate가 된다.</p>
<ul>
<li>SVG 그래픽 : 벡터 기반</li>
</ul>
<p>픽셀로 구성되어 있지 않고 작업하고 있는 그래픽에 대한 정보로 구성되어 있다. 그렇기 때문에 어떤 사이즈로든 자유자재로 늘어나는 것이 가능하다. 이러한 이유로 인해 코드로 쉽게 적용된 스타일을 수정할 수 있다. 예를 들어 동그라미의 보더 값을 6에서 8로 바꾼다던지 색상을 그레이에서 블랙으로 바꾼다던지 또는 사이즈를 변경한다던지 등이다.</p>
<p>위와 같은 장점이 있기 때문에 현재 진행하고 있는 프로젝트에서 PNG보다는 SVG를 채택해서 사용하려고 노력 중이다.</p>
<p>디자이너가 주는 이미지는 일러스트로 그리거나 어떤 작업을 거친 후에 주는 것이 많다. 이러한 이미지들은 대부분 용량이 크다.</p>
<p>용량이 큰 이미지를 내가 사용하는 imageView에 그냥 세팅을 해서 보여준다면 OOM(Out Of Memory)를 겪게 될 것이다. 이미지의 용량이 커서 사용하고 있는 메모리에 로드할 수 없기 때문이다.</p>
<p>이 문제를 해결하는 방법은 여러 가지가 있는데, 그 중에 나는 편리하게 처리하기 위해서 Glide 라이브러리르 사용했다. 이미지 로드를 하기 위한 라이브러리는 이외에도 Picasso, Fresco 등이 있다. 나는 이 중 Glide가 사용 경험도 있고 편해서 선택을 했다.</p>
<p>이미지 로딩 라이브러리 중 Picasso와 Glide 비교에 관한 글이다. <a href="https://woovictory.github.io/2019/01/03/Android-ImageLoadingLibrary/">[안드로이드] Image Loading Library</a></p>
<h2 id="glide">Glide</h2>
<p>이미지 로딩 라이브러리 중 하나로써 Glide는 많은 개발자들이 사용한다. 이유는 사용법이 간편하고 다양한 기능을 지원하기 때문이다.</p>
<p>기본 사용법은 다음과 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setImageBackground</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Glide.with(context)</span><br><span class="line">        .load(R.drawable.image_error)</span><br><span class="line">        .into(imageView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 내가 원하는 svg 이미지를 glide를 통해 적용해보려고 한다. 나는 png나 svg나 어차피 이미지이기 때문에 똑같은 방식으로 적용하면 될 것이라고 생각했다.</p>
<img src="/img/68.jpeg" width="500" height="200">
<p>인생은 쉽지 않다. 쉽게 될 것이라고 생각했던 것은 큰 오산이었다… 그래서 구글의 힘을 빌려보기로 했다.<br>
<strong>android glide load svg</strong>로 검색한 결과 다음과 같이 스택 오버플로우에 많은 질문이 있는 것을 알 수 있었다. 역시 쉬운 것은 없다.</p>
<img src="/img/glide_svg_load.png" width="700" height="200">
<p>열심히 구글링을 하던 중 괜찮아 보이는 방법을 찾았다.</p>
<ol>
<li>라이브러리 사용</li>
</ol>
<ul>
<li><a href="https://github.com/corouteam/GlideToVectorYou" target="_blank" rel="noopener">GlideToVectorYou</a> 라는 라이브러리이며 SVG 이미지를 쉽게 로드할 수 있다.</li>
<li>구현부분을 자세히 보면 구글의 샘플 코드를 확인할 수 있다.</li>
<li>단점 : with() 함수의 인자로 <code>activity</code> 밖에 넘기지 못한다.</li>
</ul>
<ol start="2">
<li>구글의 샘플 코드 사용(구 버전)</li>
</ol>
<ul>
<li>스택 오버플로우의 답변 내용을 보면 구글의 샘플 코드를 확인하라는 말을 자주 볼 수 있다.</li>
<li>그래서 링크를 타고 들어가봤는데, 대략 4년 전에 사용되었던 방식이 있다.</li>
<li>단점 : 구 버전이므로 현재 버전에서는 Deprecated된 함수들이 대부분이다.</li>
</ul>
<ol start="3">
<li>구글의 샘플 코드 사용(최신 버전)</li>
</ol>
<ul>
<li>구 버전 뿐 아니라 최신 버전에 맞게 사용할 수 있는 샘플 코드를 제공하고 있다.</li>
<li><a href="https://github.com/bumptech/glide/tree/master/samples/svg/src/main/java/com/bumptech/glide/samples" target="_blank" rel="noopener">SVG Sample</a></li>
</ul>
<p>자, ‘이런게 삽질이라고?’ 라고 생각하시는 분들이 있을 수 있다.<br>
하지만, 내가 겪은 과정은 삽질이라고 표현할 수 있다.<br>
이유는 처음에 SVG 이미지를 그냥 로드할 수 없다는 걸 알게되었다는 점과 이를 로드하기 위해서 어떤 방식이 있는지 찾아보는 과정, 그리고 실제로 동작하는지 확인해보기 위해서 많은 시간을 들였다.</p>
<p>구글의 샘플 코드를 보고 가장 먼저 의문이 드는 것은 <code>GlideApp</code>이다. 이게 뭘까? 직접 쳐봐도 뜨지도 않는다. 그럼 구글은 이 뜨지도 않는걸로 어떻게 해결한 것일까??</p>
<p>해결 방법은 의외로 간단하다. build.gradle(Module:app)에 아래와 같은 의존성을 추가하면 된다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// glide</span><br><span class="line">implementation 'com.github.bumptech.glide:glide:4.8.0'</span><br><span class="line">implementation 'com.github.bumptech.glide:annotations:4.8.0'</span><br><span class="line">annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'</span><br><span class="line">kapt 'com.github.bumptech.glide:compiler:4.8.0'</span><br></pre></td></tr></table></figure>
<p>버전은 4.8.0으로 했다. 최신 버전으로 했었는데, 변경하는 과정에서 Crash가 발생해서 4.8.0으로 하는 것이니 사용할 때는 최신 버전으로 해도 무방할 것 같다.</p>
<p>그리고 Clean Project -&gt; Rebuild Project 를 하면 GlideApp이 생기는 걸 확인할 수 있다. 다음에 AppGlideModule을 상속받는 MyAppGlideModule 클래스를 생성하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyGlideModule</span> : <span class="type">AppGlideModule</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerComponents</span><span class="params">(context: <span class="type">Context</span>, glide: <span class="type">Glide</span>, registry: <span class="type">Registry</span>)</span></span> &#123;</span><br><span class="line">        registry</span><br><span class="line">            .register(SVG::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">PictureDrawable::class.java</span>, <span class="type">SvgDrawableTranscoder</span></span>())</span><br><span class="line">            .append(InputStream::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">SVG::class.java</span>, <span class="type">SvgDecoder</span></span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isManifestParsingEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SVG 클래스를 위해서 아래와 같은 의존성을 하나 더 추가해줘야 한다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation 'com.caverock:androidsvg:1.2.1'</span><br></pre></td></tr></table></figure>
<p>그리고 여기서 사용되는 클래스들은 다음과 같다.</p>
<ul>
<li><a href="https://github.com/bumptech/glide/blob/master/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDecoder.java" target="_blank" rel="noopener">SvgDecoder</a></li>
<li><a href="https://github.com/bumptech/glide/blob/master/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgDrawableTranscoder.java" target="_blank" rel="noopener">SvgDrawableTranscoder</a></li>
<li><a href="https://github.com/bumptech/glide/blob/master/samples/svg/src/main/java/com/bumptech/glide/samples/svg/SvgSoftwareLayerSetter.java" target="_blank" rel="noopener">SvgSoftwareLayerSetter</a></li>
</ul>
<p><strong>1.SvgDecoder</strong></p>
<p>link를 통해서 읽은 inputStream을 SVG 내부 표현으로 디코딩을 한다는 의미이다.<br>
정확하지는 않지만 link 즉, url을 통해 읽어들인 다음 inputStream에 담고 이를 통해 SVG로 만든다. 만들 때는 <code>androidsvg</code> 라이브러리를 사용한다.</p>
<p><strong>2. SvgDrawableTranscoder</strong></p>
<p>1번에서 만든 SVG를 안드로이드에서 사용할 수 있는 <code>PictureDrawable</code>로 변환한다. 이는 Drawable 클래스를 상속받고 있기 때문에 이렇게 변환된 데이터를 안드로이드에서 사용할 수 있다.</p>
<p><strong>3. SvgSoftwareLayerSetter</strong></p>
<p>3번은 필수가 아닌 선택이다. 하지만, 필수적으로 사용해야 될 것 같다. 왜냐하면 리스너를 구현한 것이기 때문에 이를 통해서 내가 로드하려는 이미지가 성공적으로 로드되었는지, 실패했는지를 확인할 수 있다.</p>
<p>이를 통해서 내가 로드하려는 SVG 이미지가 성공적으로 로드되었는지, 로드되지 않고 실패했다면 어떤 원인인지 파악할 수 있어 디버깅하는데 더 수월하다.</p>
<p>여기까지 내가 삽질했던 과정을 설명했다. 사용되는 클래스에 대한 정확한 파악은 하지 못했지만, 어떻게 동작하는지는 이해가 되었다. 나의 이해를 바탕으로 작성한 글이기 때문에 사실과 다른 부분도 존재할 것이다. 이 부분에 대한 이견이 있다면 알려주시면 감사할 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://brunch.co.kr/@dailyhotel/20" target="_blank" rel="noopener">왜 SVG로 갈아탔는가?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/05/Android-Glide/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy2/"
                            aria-label=": [Android] 백그라운드 실행 정책 Oreo"
                        >
                            [Android] 백그라운드 실행 정책 Oreo
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T17:58:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>안드로이드 Oreo(8.0)</code> 버전에서 등장한 백그라운드 실행 제한을 확인해보도록 하겠다. 안드로이드에서 백그라운드 실행은 상용 서비스에서 많이 사용되는 부분이기도 하고 꼭 알아야 하는 부분이라서 공부하면서 정리하려고 한다.</p>
<h2 id="1-oreo-버전-백그라운드-제한-개요">1. Oreo 버전 백그라운드 제한 개요</h2>
<p>앱이 백그라운드에서 실행될 때마다 디바이스의 리소스(예:RAM, 배터리)를 사용한다. 이는 사용자들에게 좋지 못한 경험을 제공한다. 예를 들어 백그라운드 작업으로 인해 디바이스의 배터리 수명이 저하되거나 비디오 시청, 게임, 카메라 사용과 같은 사용자의 디바이스 성능 저하가 발생할 수 있다.</p>
<p>동시에 실행되는 앱이 많은 수록 시스템에 많은 부하가 걸린다. 추가적인 앱이나 서비스가 백그라운드에서 실행 중이면 시스템에 추가적인 부하가 걸리고 사용자 환경이 나빠질 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 <strong>Android Oreo</strong> 버전에서는 사용자가 앱과 직접적으로 상호작용하지 않을 때 이 앱이 수행할 수 있는 작업을 제한한다. 두 가지 방식으로 제한된다.(여기서는 <code>백그라운드 서비스 제한</code>만 살펴보도록 하겠다.)</p>
<ol>
<li>
<p><strong>백그라운드 서비스 제한</strong> : 앱이 유휴 상태인 경우 백그라운드 서비스의 사용이 제한된다. 이 기능은 사용자에게 잘 보이는 포그라운드 서비스에는 적용되지 않는다.</p>
</li>
<li>
<p><strong>브로드캐스트 제한</strong> : 제한된 예외의 경우, 앱이 암시적 브로드캐스트에 등록하기 위해 자체 매니페스트를 사용할 수 없다. 그렇지만 앱이 런타임에 브로드캐스트에 등록할 수 있으며, 특정 앱을 대상으로 하는 명시적 브로드캐스트에 등록하기 위해 매니페스트를 사용할 수 있다.</p>
</li>
</ol>
<ul>
<li>
<p>기본적으로 이와 같은 제한은 Oreo 버전을 대상으로 하는 앱에만 적용된다. 하지만, 안드로이드 개발자라면 모든 버전을 고려해서 개발해야 하기 때문에 피할 수 없는 부분임이 분명하다. 그렇기 때문에 반드시 알고 넘어가야 한다.</p>
</li>
<li>
<p>추가적으로 이전에 살펴본 Service는 백그라운드에서 동작하는 컴포넌트이다. 하지만, Oreo 처럼 백그라운드 작업을 제한하게 된다면 우리가 원하는 작업을 수월하게 진행할 수 없다. 이 부분을 어떻게 해결할 수 있는지 고민해야 할 필요가 있다.</p>
</li>
</ul>
<p>대부분의 경우, 앱은 <strong>JobScheduler</strong> 작업을 사용해 이 제한을 해결할 수 있다. JobScheduler를 통해 앱이 실행되지 않을 때 작업을 수행하면서도, 사용자 환경에 영향을 미치지 않는 방식으로 이러한 작업을 예약할 수 있는 여지를 제공할 수 있다. 하지만, JobScheduler 역시 제한이 걸리는 점이 존재한다. 이 부분은 <strong>WorkManager</strong> 부분에서 공부하면서 살펴보자.</p>
<h2 id="2-백그라운드-실행-변화">2. 백그라운드 실행 변화</h2>
<p>앞선 포스팅에서 확인한 내용을 한번 더 정리하고 넘어가려 한다. 그리고 위에서 설명한 것처럼 사용자의 디바이스 배터리 수명을 개선하고 더 좋은 사용자 경험을 제공하기 위해 안드로이드는 몇가지 백그라운드 정책들을 변화시켜왔다.</p>
<ul>
<li>도즈모드와 앱 대기상태(Doze And App Standby) : 화면이 꺼지고 충전 상태가 아니며 대기 상태일 때 애플리케이션의 행동을 제한한다.</li>
<li>백그라운드 상태에서 위치 서비스 제약 : 백그라운드 상태에 있는 앱이 사용자의 현재위치를 검색할 수 있는 빈도를 제한한다.</li>
<li>백그라운드 서비스 제약 : 보이지 않는 CPU/Network 사용과 실행중인 백그라운드 서비스들을 제한한다.</li>
<li>가장 최근에는 사용자가 사용하지 않는 앱에서 사용할 수 있는 기기 리소스를 제한할 수 있는 <a href="https://developer.android.com/about/versions/pie/power#buckets" target="_blank" rel="noopener">앱 대기 버킷(App Standby Buckets)</a>과 앱이 좋지 않는 행동을 보이는 경우 백그라운드에서 시스템 리소스에 대한 앱의 접근을 제한하도록 사용자에게 경고하는 <a href="https://developer.android.com/topic/performance/background-optimization#bg-restrict" target="_blank" rel="noopener">앱 제한(App Restrictions)</a>과 <a href="https://developer.android.com/about/versions/pie/power#battery-saver" target="_blank" rel="noopener">배터리 절약 개선(Battery Saver improvements)</a> 정책이 추가되었다.</li>
</ul>
<h2 id="3-oreo-버전-백그라운드-실행-제한">3. Oreo 버전 백그라운드 실행 제한.</h2>
<p>위에서 언급한 것처럼 백그라운드에서 실행 중인 서비스가 디바이스의 리소스를 사용할 수 있으며, 그 결과로 사용자 경험이 악화될 가능성이 있다. 이러한 문제를 줄이기 위해 Oreo 버전부터 시스템은 여러가지 제한을 서비스에 적용한다.</p>
<p>먼저, 이를 이해하기 전에 애플리케이션이 <strong>Foreground</strong>인지 <strong>Background</strong>인지 명확하게 파악해야 한다. 아래와 같은 경우 애플리케이션이 Foreground에 있는 것으로 간주한다.</p>
<ul>
<li>액티비티가 시작되거나 일지 중지되거나 상관없이 액티비티가 가시적일 경우.</li>
<li>Foreground Service가 있는 경우.</li>
<li>Foreground 애플리케이션이 서비스를 갖는 애플리케이션에 바인딩하거나 콘텐츠 프로바이더를 사용하여 앱에 연결할 때.<br>
예를 들어 다른 앱이나 시스템이 아래의 내용에 바인딩하면 애플리케이션이 Foreground에 있는 것이다.
<ul>
<li>IME</li>
<li>Wallpaper Service</li>
<li>Notification listener</li>
<li>Voice 또는 text 서비스</li>
<li>자동차에서 스트리밍을 듣는 음악 앱(Android Auto일 때)</li>
</ul>
</li>
</ul>
<p>위의 조건들을 만족하지 못한다면 애플리케이션이 Background에 있는 것으로 간주된다.</p>
<blockquote>
<p><strong>바인드된 서비스는 영향을 받지 않는다.</strong></p>
</blockquote>
<ul>
<li>이러한 규칙은 바인드된 서비스에는 어떠한 영향도 미치지 않는다. 앱이 바인드된 서비스를 정의하는 경우, 해당 앱이 Foreground에 있는 없든 간에 다른 구성요소들이 이 서비스에 바인드할 수 있다.</li>
</ul>
<p>앱이 Foreground에 있는 동안에는 이 앱이 Foreground 및 Background 서비스를 자유롭게 생성하고 실행할 수 있다. 앱이 백그라운드로 이동하더라도 몇 분 동안은 앱이 서비스를 생성하고 사용하는 것이 여전히 허용된다. 이 기간이 끝나게 되면 앱이 유휴 상태로 간주된다. 이때 마치 앱이 서비스의 <code>Service.stopSelf()</code> 메소드를 호출한 것처럼 시스템이 앱의 백그라운드 서비스를 중지시킨다.</p>
<p>어떠한 상황에서는 백그라운드 앱이 몇 분 동안 임시 허용 목록이란 곳에 들어가기도 한다. 앱이 허용 목록에 있는 동안에는 제한 없이 서비스를 시작할 수 있으며 백그라운드 서비스도 실행이 허용된다. 사용자에게 보이는 다음과 같은 작업을 앱이 처리하는 경우에 앱이 허용 목록에 들어간다.</p>
<ul>
<li>우선순위가 높은 Firebase Cloud Messaging(FCM) 메시지 처리</li>
<li>SMS/MMS 메시지와 같은 브로드캐스트 수신</li>
<li>알림에서 <code>PendingIntent</code> 실행</li>
</ul>
<p>많은 경우 앱이 백그라운드 서비스를 <strong>JobScheduler</strong> 작업으로 대체할 수 있다. Android 8.0 이전에는 Foreground 서비스를 생성하는 일반적인 방법은 Background 서비스를 생성한 후 이 서비스를 Foreground 서비스로 승격시키는 것이었다.</p>
<p>Android 8.0에서는 좀 복잡하며 시스템은 백그라운드 앱이 Background 서비스를 생성하는 것을 허용하지 않는다. 이 때문에 Android 8.0에서는 새 서비스를 Foreground에서 시작하는 새로운 메소드 <code>Context.startForegroundService()</code>를 소개한다.</p>
<p>시스템이 서비스를 생성한 후, 앱은 5초 이내에 해당 서비스의 <strong>startForeground()</strong> 메소드를 호출하여 새 서비스의 알림을 사용자에게 표시해야 한다. 앱이 이 시간 내에 <strong>startForeground()</strong> 를 호출하지 않으면 시스템이 서비스를 중단하고 앱을 ANR로 선언하게 된다.</p>
<h2 id="5-사례와-해결-방법">5. 사례와 해결 방법</h2>
<p>백그라운드 실행 제한으로 인해 원하는 작업을 하는게 조금 어려워졌다. 개발자는 백그라운드 실행을 구현하기 위해 사용할 도구를 결정하려면 원하는 것을 명확하게 이해하고 어떤 제한 사항을 가지고 있어야 한다.</p>
<p>공식 문서에 나와있는 <strong>Guide to background Processing</strong>을 참고해서 알아보도록 하자.</p>
<p><strong>개요</strong><br>
안드로이드 앱은 UI 처리, 사용자와 상호작용, LifeCycle 이벤트 수신 등을 담당하는 Main Thread가 존재한다. Main Thread에서 너무 많은 작업이 발생하면 앱이 끊기거나 느려져서 사용자 경험이 좋지 않다. 즉, 사용자가 불편함을 느낄 수 있다.</p>
<p>비트맵 디코딩, 디스크 접근 또는 네트워크 요청 수행과 같은 시간이 오래 걸리는 실행 및 작업을 별도의 백그라운드 스레드에서 수행해야 한다. 일반적으로 몇 밀리초 이상 걸리는 것은 모두 백그라운드 스레드에 위임해야 한다. 이러한 작업 중 일부는 사용자가 앱을 활발하게 사용하는 동안 수행되어야 한다. 백그라운드 스레드에서 작업을 실행하고 앱을 사용하는 동안 기본 UI 스레드에서 작업을 실행하는 방법 그리고 두 스레드 간 통신 방법에 대해서는 다른 글을 참고하면 좋다.</p>
<p>애플리케이션은 또한 사용자가 백엔드 서버와 정기적으로 동기화하거나 앱 내에서 새로운 컨텐츠를 가져오는 등 앱을 사용하지 않을 때에도 실행해야 하는 일부 작업이 필요할 수 있다. 또한 애플리케이션은 사용자가 앱과 상호작용을 완료한 후에도 서비스가 즉시 실행되도록 요구할 수 있다. 이와 같은 경우를 해결하기 위해서 <strong>백그라운드 처리에 대한 고민이 필요하다.</strong></p>
<p><strong>백그라운드 처리의 과제</strong></p>
<p>백그라운드 작업은 RAM 및 배터리와 같은 기기의 제한된 리소스를 소비한다. 올바르게 사용하지 않을 경우 사용자에게 좋지 않은 경험을 제공할 수 있다.</p>
<p>안드로이드는 배터리를 극대화하고 좋은 앱 동작을 위해 앱 또는 Foreground Service Notification이 사용자에게 보이지 않을 때 백그라운드 작업을 제한한다.</p>
<p>다음은 위에서 언급한 버전별 백그라운드 정책의 변화를 보여준다.</p>
<ul>
<li>Android 6.0 : Doze 모드와 App Standby(앱 대기) 기능
<ul>
<li>도즈 모드는 화면이 꺼져 있고 기기가 정지해 있을 때 앱 동작을 제한한다.</li>
<li>앱 대기에서는 사용하지 않는 애플리케이션을 네트워크 접근, 작업 및 동기화를 제한하는 특수 상태로 전환한다.</li>
</ul>
</li>
<li>Android 7.0 : 암시적 브로드캐스트 리시버를 제한하고 개선된 도즈모드를 제공한다.</li>
<li>Android 8.0 : 백그라운드에서 위치를 파악하거나 캐시된 Wake lock을 해제하는 등 추가적인 백그라운도 동작 제한이 있다.</li>
<li>Android 9.0 : 앱 이용 패턴에 따라 자원에 대한 앱 요청이 동적으로 우선되는 App Standby Buckets를 소개했다.</li>
</ul>
<p>결국 내가 해야 할 작업을 정확히 이해하고 백그라운드 작업을 버전별 정책에 맞도록 개발하는 것이 중요하다.</p>
<p><strong>작업에 맞는 적합한 방법을 선택하자.</strong></p>
<p>아래의 예시를 확인해보고 생각해보자.</p>
<ul>
<li><strong>작업이 연기될 수 있거나 당장 일어날 필요가 있는가?</strong> 예를 들어, 사용자가 버튼을 클릭하는 것에 대응하여 네트워크에서 데이터를 가져와야 하는 경우 이 작업은 즉시 수행되어야 한다. 그러나 서버에 로그를 업로드하려면 앱의 성능이나 사용자 기대에 영향을 미치지 않고 작업을 연기할 수 있다.</li>
<li><strong>작업이 시스템에 상태에 따라 달라지는가?</strong> 장치에 전원 연결, 인터넷 연결 등과 같은 특정 조건을 충족할 때만 작업을 실행하기를 원할 수 있다. 예를 들어, 사용자의 앱은 주기적으로 저장된 데이터를 압축해야 할 수 있다. 사용자에게 영향을 주지 않도록 하려면 장치가 충전되고 유휴 상태일 때만 이 작업을 수행하기를 원할 것이다.</li>
<li><strong>작업이 정확한 시간에 실행되어야 하는가?</strong> 일정 관리 앱의 경우, 사용자가 특정 시간에 발생할 이벤트에 대해서 미리 알림을 설정하도록 할 수 있다. 사용자는 정확한 시간에 알림을 볼 수 있을 것으로 예상한다. 다른 경우, 앱은 작업이 실행될 때 정확하게 신경을 쓰지 않을 수 있다. 앱에는 &quot;작업 A가 먼저 실행되야 하고, 그 다음에 작업 B가 실행되어야 하며 다음에는 작업 C가 실행되어야 한다.&quot;와 같은 일반적인 요구 사항이 있을 수 있다. 하지만, 특정 시간에 실행되기 위해서는 작업이 필요하지 않다.</li>
</ul>
<img src="/img/android_background_way.png" width="600" height="300">
<ol>
<li>WorkManager</li>
</ol>
<p>모든 OS 백그라운드 실행 제한을 고려하여 백그라운드 실행에 권장되는 솔루션이다. 장치 또는 애플리케이션이 재시작되더라도, 작업이 연기될 수 있거나 작업이 실행될 것으로 예상되는 경우 <code>WorkManager</code>를 사용할 수 있다.</p>
<p>작업 조건(네트워크 가용성, 배터 등)이 만족될 때, 지연 가능한 백그라운드 작업을 멋지게 실행할 수 있다.</p>
<p>장점으로는 작업(일회성 또는 반복성)을 예약하거나 작업을 결합(체이닝)할 수 있다. 또한 장치가 유휴상태이거나 충전 중일 때 특정 이벤트를 트리거하거나 콘텐츠 프로바이더가 변경될 때 실행하는 것과 같은 실행 제한 조건을 적용할 수 있다.</p>
<p>한 가지 예로 로그를 압축하여 서버에 업로드 해야 하는 경우라면 두 가지 작업 요청을 만들어 수행할 수 있다.</p>
<ol>
<li>파일을 압축한다. -&gt; 이 단계에서 장치가 충전 중이어야 한다는 제한 조건을 추가할 수 있다.</li>
<li>서버에 업로드 한다. -&gt; 이 요청의 경우 네트워크가 사용 가능할 때만 작업이 실행되도록 네트워크 연결 제한 조건을 추가해야 한다.</li>
</ol>
<p>두 작업을 모두 큐에 넣은 뒤 WorkManager와 함께 필요한 리소스가 충족할 때 작업을 수행하도록 할 수 있다. 또 다른 장점으로는 전원 관리 기능을 존중하는 것이다. WorkManager는 제약 조건이 충족되며, Doze가 해제된다면 주어진 작업을 실행할 것이다.</p>
<p>자세한 내용은 다음 포스팅에서 정리할 예정이다.</p>
<ol start="2">
<li>Foreground Service</li>
</ol>
<p>앱에서 음악, 비디오 재생 또는 탐색과 같이 앱을 종료하거나 화면을 꺼도 지연되지 않고 사용자가 시작한 작업을 완료해야 하는 경우 Foreground Service를 사용해야 한다. Foreground Service를 사용한다는 것은 중요한 일을 하고 있으므로 죽여서는 안된다는 것을 시스템에 알린다. 그리고 Notification Bar에 띄워서 Foreground Service가 수행 중임을 표시해야 한다.</p>
<ol start="3">
<li>Alarm Manager</li>
</ol>
<p>정확한 시간에 작업을 실행해야 하고 사용자와 상호 작용이 포함되며 지연될 수 없는 경우 사용하면 된다. Alarm Manager는 사용자가 지정한 시간에 필요한 경우 사용자의 앱을 실행한다.</p>
<p>그러나 작업이 정확한 시간에 실행될 필요가 없다면 WorkManager가 더 나은 방법이다. WorkManager는 시스템 자원의 균형을 더 잘 맞출 수 있다. 예를 들어, 매 시간마다 작업을 실행해야 하지만 특정 시간에 작업을 실행할 필요가 없는 경우, WorkManager를 사용하여 반복 작업을 설정하면 된다.</p>
<p>또한, 알람이 발생하면 작업을 짧은 시간내에 끝내야 한다. 네트워크에 접근하지 못할 수도 있다.(도즈모드나 앱 대기 버킷 때문에) 네트워크가 필요하거나 시간이 오래 걸리는 작업을 수행하려면 위에서 언급한 WorkManager를 사용해야 한다. 알람이 울릴 때마다 장치는 저전력 모드를 벗어나 부분적 wake-lock을 유지하므로 시간이 지남에 따라 배터리 수명에 상당한 영향을 줄 수 있다.</p>
<ol start="4">
<li>Download Manager</li>
</ol>
<p>사용자가 앱을 통해서 시간이 오래 걸리는 Http 다운로드를 수행하고 있다면 Download Manager를 사용하면 된다. 클라이언트는 URI를 앱 프로세스 외부에 있을 수 있는 특정 대상 파일로 다운로드하도록 요청할 수 있다. Download Manager는 백그라운드에서 다운로드를 수행하여 Http 상호 작용을 관리하고 실패 후 또는 연결 변경 및 시스템 재부팅 전반에 걸쳐 다운로드를 재시도 한다.</p>
<p>요약하면 아래와 같다.</p>
<img src="/img/android_background_ways.png" width="600" height="300">
<p>파일을 다운로드 할 때 다운로드 매니저를 사용하면 될 것으로 예상이된다. 하지만, 다운로드 같은 경우 백그라운드에서 동작하고 시간이 오래 걸릴 수도 있기 때문에 백그라운드 정책에 위반될 상황이 생길 수도 있을 것 같다. 하지만, 다운로드 매니저가 내부적으로 어떻게 구현되어있는지 모르기 때문에 아직 확신할 수 없다. 관련 내용을 조금 더 찾아봐야 할 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=868" target="_blank" rel="noopener">새로운 안드로이드 백그라운드 실행 정책</a></li>
<li><a href="https://developer.android.com/guide/background/" target="_blank" rel="noopener">Guide to background processing - 공식 문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy/"
                            aria-label=": [Android] 버전별 백그라운드 정책"
                        >
                            [Android] 버전별 백그라운드 정책
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T11:49:28+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>백그라운드 작업이 필요한데, 그 전에 구글에서 제한하고 있는 백그라운드 작업에 대해서 알아보려고 한다.</p>
<h2 id="1-버전별-백그라운드-정책-변천사">1. 버전별 백그라운드 정책 변천사</h2>
<p>안드로이드는 큰 업데이트마다 배터리를 관리하기 위한 여러 기능들을 포함해왔다. 아래의 내용을 확인해보자.</p>
<ul>
<li>롤리팝 5.0 : Job Scheduler의 등장. 작업을 미루거나 스케쥴링 할 수 있도록 함.</li>
<li>마시멜로우 6.0 : <a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes#behavior-power" target="_blank" rel="noopener">도즈 모드 및 앱 대기모드</a> 등장.
<ul>
<li>디바이스 또는 앱이 장시간 사용중이 아닐 때 즉, 화면이 꺼지고 충전중이 아닐 때, 네트워크의 접근을 제한하고 백그라운드 작업을 유예하기 시작.</li>
</ul>
</li>
<li>누가 7.0 : <a href="https://developer.android.com/about/versions/nougat/android-7.0-changes#doze" target="_blank" rel="noopener">개선된 도즈모드</a>
<ul>
<li>화면이 꺼지고 움직이지 않을 때 도즈모드의 하위 제약 조건이 적용되기 시작.</li>
</ul>
</li>
<li>오레오 8.0 : 백그라운드 제약
<ul>
<li>백그라운드 서비스와 위치 갱신을 제약하기 시작.</li>
</ul>
</li>
<li>파이 9.0 : 앱 대기 버킷, 배터리 세이버 개선.</li>
</ul>
<p>Oreo 버전 이상을 대상으로 업데이트 할 때 아래의 체크리스트를 확인하여 백그라운드 작업을 설정할 수 있다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">현재 사용하고 있는 방법</th>
<th style="text-align:left">오레오 이상에서 사용해야 하는 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JobScheduler</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Firebase JobDispatcher</td>
<td style="text-align:left">Firebase JobDispatcher</td>
</tr>
<tr>
<td style="text-align:left">Background Service</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Foreground Service</td>
<td style="text-align:left">Foreground Service와 해당 서비스를 종료해야 할 액션(stopService)</td>
</tr>
</tbody>
</table>
<p>WorkManager 라이브러리가 현재는 Alpha 단계이기 때문에 위의 방법들로 개발해야 하지만 정식 버전이 출시된다면 거의 모든 경우를 <code>WorkManager</code>로 해결할 수 있을 것 같다. 기대해보자~</p>
<h2 id="2-올바른-앱을-만드는-전략">2. 올바른 앱을 만드는 전략</h2>
<ul>
<li>백그라운드에서 수행하는 작업은 지연 가능할만한 작업들로 만든다.</li>
<li>Foreground Service를 사용할 때는 노티피케이션을 반드시 제공하여 사용자가 서비스를 중지할 수 있도록 한다.</li>
<li>알람, 네트워크 및 FCM 메시지와 같은 OS 기반의 작업에서는 이와 관련된 전원 관리 제한사항에 대한 문서 내용을 확인해보자.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=737" target="_blank" rel="noopener">안드로이드 버전별 백그라운드 정책</a></li>
<li><a href="https://developer.android.com/about/versions/oreo/background?hl=ko" target="_blank" rel="noopener">백그라운드 실행 제한 - 공식문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/What-is-Service/"
                            aria-label=": [안드로이드] Service"
                        >
                            [안드로이드] Service
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T10:31:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-service란">1. Service란?</h2>
<p><strong>Service</strong>는 안드로이드 Application을 구성하는 4대 컴포넌트 중 하나이다. Activity처럼 사용자와 상호 작용을 하는 컴포넌트는 아니다. 때문에 UI가 존재하지 않으며 <strong>Background</strong>에서 동작하는 컴포넌트이다.</p>
<p>Service가 실행되고 있는 상태라면 안드로이드 OS에서는 해당 Process를 왠만하면 죽이지 않도록 방지하고 관리하게 된다. 그렇기 때문에 메모리 부족이나, 특별한 경우를 제외하고는 Background 동작을 수행하도록 설계되었다.</p>
<img src="/img/android_service.png" width="600" height="300">
<h2 id="2-service는-왜-필요할까">2. Service는 왜 필요할까?</h2>
<p>'Android Application을 구성하기 위해서 Service는 왜 필요할까?'라고 생각을 할 수 있다. 그 이유는 Activity 즉, 사용자가 보고 있는 화면이 종료된 상태에서도 동작하기 위해서 만들어졌고, 개발자는 구현을 해야 한다.</p>
<p>예를 들어서 Mp3 플레이어 같은 기능을 활용하는 경우가 될 수 있다. Mp3 플레이어는 화면이 종료된 상태에서도 계속 노래를 재생해야 하기 때문에 Background에서도 동작하도록 만들어야 한다. 따라서 <strong>Service</strong>를 사용해 구현하면 된다.</p>
<ul>
<li>파일 다운로드 같은 경우에도 사용할 수 있다.</li>
<li>애플리케이션이 실행 중이지 않을 때도 작업해야 하는 경우에도 사용할 수 있다.(애플리케이션이 실행 중일 때만 작업해야 하는 경우 <strong>스레드</strong> 사용을 권장한다.)</li>
</ul>
<p><strong><code>주의</code></strong><br>
Service가 Background에서 동작을 수행하는 컴포넌트라고 해서 Main Thread에서 실행되는 것이라고 생각하지 않을 수도 있다. 명심해야 할 점은 Android 4대 컴포넌트들은 모두 Main Thread에서 실행된다.</p>
<p>따라서 CPU 자원을 많이 소모하거나 네트워크 통신과 같은 시간이 오래 걸리는 작업은 별도의 Thread를 만들어서 처리해야 한다. 이 부분은 아래에서 ANR과 함께 설명하겠다.</p>
<h2 id="3-service-사용-방법">3. Service 사용 방법</h2>
<p>2가지 방법이 있으면 <code>startService()</code>와 <code>bindService()</code>이다.</p>
<ol>
<li><strong>startService() - 시작 타입의 서비스</strong></li>
</ol>
<ul>
<li>서비스를 상속받는 클래스를 작성하며, 정적 리시버와 유사하게 매니페스트 파일에 등록한다.</li>
<li>한 번 시작되면 백그라운드에서 무한정 실행된다.</li>
<li>작업을 완료하면 서비스가 종료된다.</li>
<li>간단한 작업들만 수행한다.</li>
<li>호출한 곳에 결과값을 반환하지 않고 계속해서 서비스한다.(음악 재생, 파일 다운로드 등)</li>
<li>하나의 프로세스 안에서 동작하며, 패키지내 컴포넌트들과 유기적으로 통신하는 역할을 한다.</li>
<li>생명 주기 : onCreate() -&gt; onStartCommand() -&gt; 실행 -&gt; onDestroy() -&gt; stopService()</li>
</ul>
<img src="/img/android_startService.png" width="600" height="300">
<ol start="2">
<li><strong>bindService() - 연결 타입의 서비스</strong></li>
</ol>
<ul>
<li>클라이언트 - 서버와 같이 동작하며 호출자(액티비티)에서 서비스에게 어떤 것을 요청하고 서비스는 요청을 처리한 후 결과값을 반환한다. (서비스가 서버의 역할을 수행.)</li>
<li>액티비티가 사라지면 서비스도 자동적으로 destroy되면서 없어진다.</li>
<li>하나의 서비스가 다수의 액티비티와 연결될 수 있다.</li>
<li>프로세스 내에서 다른 컴포넌트들과 서로 유기적으로 통신을 하며 <strong>또한, 어플 내의 기능을 외부에 제공하는 경우에 많이 사용된다. 즉, 다른 프로세스들 간에서도 Data 공유 및 통신이 유기적으로 가능하다.</strong></li>
<li>생명 주기 : onCreate() -&gt; onBind() -&gt; 실행 -&gt; onUnbind() -&gt; onDestory() -&gt; stopService()</li>
</ul>
<img src="/img/android_bindService.png" width="600" height="300">
<ol start="3">
<li><strong>intentService</strong></li>
</ol>
<ul>
<li>내부적으로 handlerThread가 동작하는 서비스</li>
<li>루퍼가 message Queue에 들어온 요청에 대해 순차적으로 처리한다.</li>
<li>Queue가 비게 되면 자동으로 서비스가 종료된다.</li>
<li>동시에 처리하는게 아니므로 성능은 조금 떨어지지만 순차적 실행이 보장된다.</li>
</ul>
<h2 id="4-service-사용시-주의사항">4. Service 사용시 주의사항.</h2>
<p>Android는 Linux 기반의 프로그램이다. 프레임워크 단에는 Linux로 구현되어 있다. 메모리 관리 또한 Linux 정책을 따르며 Linux Kernel에 의해서 관리된다.</p>
<img src="/img/android_linux_kernel.png" width="600" height="300">
<p>결국 여러 프로세스들을 커널에서 관리한다고 짐작할 수 있다.<br>
또한 하나의 프로세스 안에는 애플리케이션, 안드로이드 4대 컴포넌트, 스레드 등을 구성하고 있다. 즉, 4대 컴포넌트의 운명 또한 리눅스 커널에 달려있다는 걸 의미한다.</p>
<p>만약, 메모리 부족이나 과부하 등과 같은 현상이 발생했을 때 리눅스 커널이 프로세스를 강제로 종료시킬 수 있다.</p>
<img src="/img/android_process.png" width="600" height="300">
<p>여기서 주의해야 할 점이 있다. 바로 모든 컴포넌트들이 <strong>Main Thread</strong> 안에서 실행된다는 점이다. 안드로이드에서 Main Thread는 UI 작업을 처리하는 Thread이다. 따라서 Main Thread에서는 네트워크 작업이나 시간이 오래 걸리는 작업을 하게 되면 앱의 반응성이 낮아질 수 있다. 사용자의 불편함을 방지하고나 시스템이 <code>ANR</code> 상태로 전환시킬 수 있다.</p>
<p>Service 역시 Main Thread에서 동작하기 때문에 시간이 오래 걸리는 작업을 할 경우에는 별도의 작업 Thread를 만들어서 동작을 처리해야 한다. 그리고 작업 결과를 UI Thread에 반영하기 위해서 쓰레드 간 통신 방법을 이용해 반영해야 한다.</p>
<p>쓰레드간 통신 방법은 다음의 글을 참고하면 보면 될 것 같다.<br>
<strong><a href="https://woovictory.github.io/2019/01/07/Android-For-Interview-4/">쓰레드간 통신 방법</a></strong></p>
<p><strong>추가적인 내용들은 빠른 시일 내에 공부해서 포스팅할 예정이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://limkydev.tistory.com/43" target="_blank" rel="noopener">[Android] 서비스(Service) 전반적인 개념</a></li>
<li><a href="https://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-Service-%EC%82%AC%EC%9A%A9%EB%B2%95" target="_blank" rel="noopener">안드로이드/Android Service 사용법</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/What-is-Service/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/What-is-WorkManager/"
                            aria-label=": [Android] Work Manager"
                        >
                            [Android] Work Manager
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T10:29:10+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에 공부할 내용은 <strong>WorkManager</strong>이다.<br>
백그라운드를 다루는 안드로이드의 새 버전들의 출시로 인해, 백그라운드 다루기는 이전보다 더 복잡해져다. 그래서 구글은 <code>JetPack</code>의 일부로 이러한 백그라운드 작버을 도와주기 위해 WorkManager를 출시했다.</p>
<p>먼저, 왜 만들어지게 되었고, 왜 필요한지를 알 필요가 있다고 생각한다. 사용하는 것도 중요하지만 내가 왜 사용하는지 <strong>이유</strong>를 알고 쓰는게 더 중요하기 때문이다.</p>
<p>아래와 같은 3개의 구성으로 나누도록 하겠다.</p>
<ol>
<li>메모리</li>
<li>현재 존재하는 백그라운드 처리 방법</li>
<li>WorkManager</li>
</ol>
<h2 id="1-메모리">1. 메모리</h2>
<p>안드로이드 커널은 리눅스 커널을 기반으로 해서 만들어졌다. 안드로이드 커널과 모든 리눅스 커널들의 가장 큰 차이점은 <code>스왑 공간(Swap Space)</code>가 없다는 것이다.</p>
<p>리눅스의 스왑공간은 램이 꽉 찼을 때 사용된다. 시스템은 더 많은 메모리 리소스를 필요로 하지만 램이 꽉 찼을 때, 메모리 상의 비활성 페이지를 <strong>스왑 공간</strong>으로 이동시킨다. 스왑공간은 램의 용량이 작은 디바이스에 도움이 되긴 하지만, 램의 용량을 늘리는 것을 대체할 수는 없다. 스왑공간은 램보다 Access time이 훨씬 느린 하드 드라이브에 위치하기 때문이다.</p>
<p>안드로이드에서는 스왑공간 같은 개념이 없다. 시스템의 메모리가 다 소진되었을 때, OOM 킬러를 이용해 프로레스스 강제 종료시켜버린다. OOM 킬러는 <strong>Visible 상태</strong>와 <strong>소모된 메모리의 양</strong>에 기반하여 프로세스를 정리하여 여유 메모리를 확보한다.</p>
<p>모든 프로세스는 액티비티 매니저가 부여한 자신의 <code>oom_adj</code> 점수를 가지고 있다. 이 점수는 애플리케이션의 상태(Foreground, Background, Background Service 등등)의 조합이다. 아래는 모든 <code>oom_adj</code> 값을 보여준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Define the oom_adj values for the classes of processes that can be</span><br><span class="line"># killed by the kernel.  These are used in ActivityManagerService.</span><br><span class="line">    setprop ro.FOREGROUND_APP_ADJ 0</span><br><span class="line">    setprop ro.VISIBLE_APP_ADJ 1</span><br><span class="line">    setprop ro.SECONDARY_SERVER_ADJ 2</span><br><span class="line">    setprop ro.BACKUP_APP_ADJ 2</span><br><span class="line">    setprop ro.HOME_APP_ADJ 4</span><br><span class="line">    setprop ro.HIDDEN_APP_MIN_ADJ 7</span><br><span class="line">    setprop ro.CONTENT_PROVIDER_ADJ 14</span><br><span class="line">    setprop ro.EMPTY_APP_ADJ 15</span><br></pre></td></tr></table></figure>
<p>프로세스의 <code>oom_adj</code>의 값이 클수록 커널의 OOM 킬러에게 정리당하기 쉽다. OOM 킬러는 현재 사용 가능한 여유메모리 크기와 <code>oom_adj</code> 임계값을 기반으로 구성한 규칙을 사용한다. 즉, OOM 킬러의 조건은 아래와 같다.</p>
<p><strong>여유 메모리 공간의 크기가 X보다 작을 때, oom_adj 값이 Y보다 큰 프로세스를 정리하라!</strong></p>
<p>즉, 앱이 메모리를 적게 소비할수록 프로세스가 정리되지 않고 중요한 내용을 다룰 기회가 더 많아진다는 것이다. 두번째로 중요한 내용은 애플리케이션의 상태에 대해 이해하는 것이다. 그래서 앱이 백그라운드에 진입했을 때에도 뭔가를 지속적으로 하고 싶다면 <strong>서비스</strong> 컴포넌트를 사용해야 한다.</p>
<ul>
<li>서비스는 UI를 제공하지 않고, 백그라운드에서 오래 걸리는 동작을 수행할 수 있도록 하는 4대 컴포넌트 중 하나이다.</li>
<li>서비스를 사용해야 했던 이유는 아래와 같다.
<ol>
<li>시스템에게 이 프로세스가 오래 걸리는 작업이 있음을 알려주고, 그에 맞는 <strong>oom_adj</strong> 점수를 얻도록 하기 위함이다.</li>
<li>안드로이드 애플리케이션의 4대 컴포넌트 중 하나이다.</li>
<li>서비스를 별개의 프로세스에서 실행시킬 수 있다.</li>
</ol>
</li>
</ul>
<p>사용했을 때의 이점이 있기 때문에 좋아 보인다. 하지만, 서비스 사용의 단점이 있다.</p>
<ol>
<li>프로세스가 계속 실행되고 있는 것이므로 배터리를 엄청나게 소모한다.</li>
<li>마시멜로우 버전부터 도즈 모드(Doze)가 도입되었다.</li>
<li>누가 버전에서 더 발전되었고 오레오 버전에서 더욱 강화되었다.</li>
</ol>
<p>도즈 모드는 사용자가 디바이스의 스크린을 끄고 나면 네트워크 통신, Sync, GPS, 알람, 와이파이 스캔 등을 비활성화 시켜버린다. 사용자가 스크린을 켜거나 디바이스를 충전기에 연결할 때까지 유지된다. 그리고 중요하지 않은 일을 수행하는 앱의 개수를 줄임으로써 디바이스의 배터리를 절약하도록 한다.</p>
<p>또한, 오레오 버전으로 타게팅된 앱이 백그라운드 서비스 생성을 허가받지 않은 채로 <code>startService()</code> 메소드를 호출하려고 하면 백그라운드 서비스 제한이 있어서 <code>IllegalStateException</code> 예외를 던진다.</p>
<p>'그럼 오레오 버전으로 타게팅 하지 않으면 되잖아?'라고 생각할 수 있다. 구글의 정책을 살펴보도록 하자.</p>
<ul>
<li>2018년 8월 : 새로 출시되는 앱들은 반드시 API 26(Oreo 8.0) 이상</li>
<li>2018년 11월 : 기존 앱들도 API 26(Oreo 8.0) 이상.</li>
<li>2019년 이후 : 매년 targetSdkVersion 요구사항이 향상될 것이다. 안드로이드가 매년 새로운 버전을 낼 때마다, 모든 앱들은 해당 API 레벨 이상을 타겟팅 해야 한다.</li>
</ul>
<p><strong>이를 통해 알 수 있는 것은 백그라운드 작업을 위해 더 이상 서비스를 사용하지 않게 될 것이라는 것이다.</strong></p>
<h2 id="2-현재-존재하는-백그라운드-처리-방법">2. 현재 존재하는 백그라운드 처리 방법</h2>
<p><strong>AlarmManager와 BroadcastReceiver 사용</strong></p>
<p>지정한 타이밍에 시스템에서 알림이 오고 여기에 맞춰 백그라운드 작업을 수행할 수 있었다. 하지만, 킷캣(K, API 19) 버전에서는 알림이 미뤄지거나 한 번에 몰아서 오는 등 정확한 실행을 보장하지 않게 된다.</p>
<p><code>BroadcastReceiver</code>를 통해서 기기의 부팅, 네트워크 연결 등의 디바이스 이벤트를 시스템으로부터 전파받아서 특정 작업을 수행해왔는데 누가(N, API 24)버전에서 특정 인텐트에 대한 동작이 제한되고, 오레오(O, API 26)버전에서 암시적 브로드캐스트 리시버 등록을 차단하는 등 제한이 추가되고 있다.</p>
<p>그래서 대안책이 <strong>Job</strong>을 사용하는 것이다.</p>
<p><strong>JobScheduler 사용</strong></p>
<p>롤리팝(L, API 21) 버전에서 <code>JobScheduler</code>를 제공한다. 부정확해진 Alarm Manager의 대안이기도 했고, 결국 백그라운드 작업을 배제할 수 없었기 때문이다. 하지만, API 2에서 사용할 수 있다는 제약으로 인해 API 21 이전과 이후 버전을 나누어 <code>AlarmManager</code>와 <code>JobScheduler</code>를 각각 사용해서 구현해야 하는 번거로운 문제가 생겼다.</p>
<p><strong>JobDispatcher 사용</strong></p>
<p>이후에 구글은 Firebase JobDispatcher를 제공하기 시작했다. JobDispatcher는 진저브레드(G, API 9) 버전 이상을 지원한다. 그리고 내부적으로 <code>AlarmManager</code>와 <code>JobScheduler</code>를 선택해준다. 이를 통해서 개발자가 하는 일은 한 가지로 줄었으나, 구글 플레이 서비스에 의존하게 되어 아마존/주욱 제조사 디바이스에서는 기능을 사용할 수 없다. 결국, 구글 플레이 서비스를 지원하지 않는 디바이스에서는 <code>AlarmManager</code>와 <code>JobScheduler</code>를 각각 사용해서 구현해야 한다.</p>
<p><strong>JobIntentService 사용</strong></p>
<p>다른 대안으로 <code>JobIntentService</code>를 사용하는 방법이 있다. 하지만, 정확한 시간에 작업이 수행되지 않기 때문에 오레오에서 Job을 빨리 수행하는데는 도움이 되지 않는다.</p>
<p><strong>Android-Job(Evernote) 라이브러리(Third party library) 사용</strong></p>
<p>이는 자동으로 안드로이브 버전에 따라 <code>AlarmManager</code>, <code>JobScheduler</code>, <code>JobDispatcher</code>들 중 어떤 것을 사용할지 결정해주는 라이브러리이다. WorkManager를 제외하고 생각한다면 가장 좋은 라이브러리라고 평가받고 있다.</p>
<p>하지만, Evernote가 새로운 가이드 안을 발표했다. 안드로이드 버전에 따라 백그라운드 API가 수시로 변경되어서 버전별로 분기가 필요하고 복잡한 API 사용이 힘들었을텐데 앞으로 Evernote는 Android Job 라이브러리를 배포하여 개발자들에게 편의를 제공해왔지만 더 이상 지원하지 않고 <code>WorkManager</code> 사용을 권장한다는 내용이다.</p>
<p>결국, 현재 실행 중인 안드로이드 버전에 따라서 백그라운드 서비스 API를 다르게 호출시키고 관리해야 한다. 디바이스의 안드로이드 버전과 구글 플레이 서비스 여부에 따라 백그라운드 서비스를 지원하기 까다롭다. 그래서 Google I/O에서 <code>WorkManager</code>라는 해결책을 제공해주었다.</p>
<h2 id="3-workmanager">3. WorkManager</h2>
<p>2018년 Google I/O에서는 안드로이드의 백그라운드 작업을 도와줄 WorkManager가 공개되었다.<br>
WorkManager는 Android JetPack의 아키텍처의 구성 요소이다.</p>
<p>WorkManager는 다음과 같은 특징을 갖는다.</p>
<img src="/img/workmanager_feature.png" width="600" height="300">
<ul>
<li>실행이 보장된다. 또한 제약 조건을 가지고 실행할 수 있다. 예를 들어, 네트워크 연결시에만 처리되는 작업을 추가하면 네트워크가 연결되면 반드시 실행된다.</li>
<li>장치의 상태를 존중한다. 도즈 모드에 진입하면 일을 처리하기 위해 기기를 깨우거나 하지 않는다.</li>
<li>실행 중인가, 대기 중인가, 완료되었는가 등의 상태 조회가 가능하다.</li>
<li>작업 A의 결과에 따라 B 또는 C를 선택하여 처리하고 D를 이어서 처리하는 등의 작업 연결 처리가 가능하다.(체이닝)</li>
<li>첫 번째 특징과 비슷하며 기회주의적이다. 즉, 어떤 제한 조건이 충족되었을 때 즉시 실행된다.</li>
</ul>
<p>WorkManager는 내부적으로 아래의 그림과 같이 동작한다.</p>
<img src="/img/WorkManager_run.png" width="600" height="300">
<p>API의 버전에 맞게 <code>AlarmManager</code>와 <code>JobScheduler</code>를 사용하고 개발자가 Firebase JobDispatcher 의존성을 추가했다면(즉, 구글 플레이 서비스 사용이 가능하다면)<code>JobDispatcher</code>를 적극 사용한다.</p>
<p>개발자는 WorkManager를 사용함으로써 상황에 맞는 고민이나 별도의 구현 없이 앱의 종료나 기기의 재부팅된 경우에도 항상 장치에 맞는 가장 적합한 방법을 사용하여 백그라운드 작업을 처리할 수 있게 된다.</p>
<p><code>그러나 WorkManager가 항상 최선은 아니다.</code></p>
<p>앱의 종료 여부와 상관없이 수행되어야 하는 작업, 즉 앱의 프로세스 수명과 별도로 살아남기 위한 작업에 사용하는 것을 추천한다.</p>
<p>예를 들어 이미지를 서버에 업로드해야 하거나, 데이터를 분석하고 이를 데이터베이스에 저장해야 하는 작업에는 <strong>WorkManager</strong>를 사용하는 것이 좋다.</p>
<p>그러나 사용자가 현재 보고 있는 UI를 빠르게 변경해야 하는 작업이나 물건 구입 과정에서의 결제 진행 등 즉시 처리해야 하는 작업은 WorkManager를 사용하지 않는 것이 좋다.</p>
<img src="/img/when_to_use_workmanager.png" width="600" height="300">
<p>WorkManager의 작업은 반드시 실행되지만 그 처리가 상황에 따라 지연되거나 도중에 중단될 경우 다시 실행될 수 있다는 것을 꼭 기억해야 한다.</p>
<p>적절한 상황에서는 WorkManager는 AlarmManager나 JobScheduler, JobDispatcher를 대체하는 훌륭한 백그라운드 작업 처리 방법이다.</p>
<p>다음에는 WorkManager를 사용해보는 시간을 갖도록 하겠다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://duzi077.tistory.com/222" target="_blank" rel="noopener">WorkManager로 안드로이드 하위 버전부터 오레오 버전까지 백그라운드 작업 통합</a></li>
<li><a href="http://dktfrmaster.blogspot.com/2018/06/workmanager.html" target="_blank" rel="noopener">[안드로이드] WorkManager에 관하여</a></li>
<li><a href="https://medium.com/@limgyumin/%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC%EB%B2%95-workmanager-f625e07b384c" target="_blank" rel="noopener">새로운 안드로이드 백그라운드 작업 처리법 : WorkManager</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/What-is-WorkManager/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/How-to-initialize-of-viewModel/"
                            aria-label=": [안드로이드] ViewModel 초기화 - 1"
                        >
                            [안드로이드] ViewModel 초기화 - 1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T00:45:47+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 주제는 Android Architecture Components 중 하나인 <code>ViewModel</code>이다. 해당</p>
<p>안드로이드 앱 개발을 하다보면 겪는 문제 중 하나는 생명주기와 관련된 것이다. 그 중에서 액티비티와 프래그먼트의 생명주기는 많은 상태와 여러 가지 케이스에 따른 복잡함으로 예전부터 지금까지도 우리에게 까다로운 존재임이 분명하다.</p>
<p>예를 들면, 런타임에 화면 방향이 전환되거나 언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우를 다루려면 세심한 처리가 필요하다. 이러한 변경이 일어나는 경우, 안드로이드는 실행 중인 액티비티를 종료하고 메모리에서 제거한 후 다시 생성하기 때문에 이 과정에서 액티비티에 종속된 UI 데이터를 유지하는 것은 손이 많이 가는 작업이다.</p>
<h2 id="화면-회전에-대한-해결책">화면 회전에 대한 해결책</h2>
<p>액티비티가 종료되기 직전 호출되는 <code>onSaveInstanceState()</code> 콜백에서 액티비티의 상태 또는 데이터를 저장할 수 있지만 <strong>직렬화할 수 없는 객체는 저장할 수 없다.</strong> 왜냐하면 이 방법은 애초에 많은 양의 데이터를 저장하기 위해 디자인되지 않았기 때문이다.</p>
<p>이번에 공부하면서 처음 본 방법이 또 있다. <strong>유보된 프래그먼트(Retained Fragment)를 사용하는 방법</strong>이다. UI가 없는 워크(헤드리스) 프래그먼트 개념을 도입해 이곳에서 UI에 필요한 데이터를 관리하고 프래그먼트를 setRetainInstance(true)로 설정함으로써 액티비티 재생성시, 프래그먼트를 메모리에 유지(즉, 소멸시키지 않고 유보)시키는 것이다.</p>
<p>이때 프래그먼트는 액티비티에서 분리(onDetach)된 후 새로운 액티비티로 다시 호스팅(onAttach)될 뿐 소멸과 생성을 반복하지 않는다. 하지만, 프래그먼트 도입은 또 다른 **엣지 케이스(일정한 범위를 넘었을 때, 발생하는 문제)**를 다뤄야 한다는 점에서 새로운 고난의 장을 여는 것을 의미하기도 한다. 그리고 이곳이 데이터를 보관하기에 적합한 곳인가? 혹은 오버 엔지니어링이 아닐까?라는 논쟁의 여지가 존재했다.</p>
<p>프래그먼트 이슈에 지친 개발자들은 프래그먼트 없이 개발하기와 같은 방법론에 매료될 정도로, 프래그먼트는 혼란스러움을 대표했다.</p>
<h2 id="viewmodel로-해결하기">ViewModel로 해결하기.</h2>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/How-to-initialize-of-viewModel/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/02/What-is-ViewModel/"
                            aria-label=": [안드로이드] ViewModel"
                        >
                            [안드로이드] ViewModel
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-02T18:34:38+09:00">
	
		    May 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="viewmodel"># ViewModel</h2>
<p><strong>ViewModel</strong> 클래스는 라이프 사이클을 고려하여 UI 관련된 데이터를 저장하고 관리하기 위해 설계되었다. 화면 전환과 같이 설정이 변경되는 상황에서도 data가 계속 남아있을 수 있도록 해준다.</p>
<p>안드로이드 프레임워크는 Activity, Fragment와 같은 UI 컨트롤러의 라이프사이클(즉, 생명주기)을 관리한다. 프레임워크는 사용자의 특정한 동작이나 완전히 예상치 못한 장치의 이벤트에 대한 응답으로 UI 컨트롤러를 파괴(Destroy)하고 재생성(re-create)하는 것을 결정하기도 한다.(액티비티가 종료되고 재생성되는 경우가 해당된다.)</p>
<p>시스템이 UI 컨트롤러를 파괴, 재생성하면 그 안에 저장해두었던 UI 관련 데이터들은 모두 사라진다. 예를 들어, 앱에는 사용자의 목록과 같은 데이터가 포함되어 있을 수 있다. 갑자기 설정이 변경되어 Activity가 재 생성될 때, 새로운 Activity 인스턴스는 사용자의 목록을 다시 불러와야 한다.</p>
<p>단순한 데이터를 다룰 때에는 Activity의 <code>onSaveInstanceState()</code> 함수를 이용해 Bundle 객체에 저장하고 <code>onCreate()</code> 함수에서 Bundle 객체에 저장된 데이터를 불러올 수 있다. 하지만, 이 경우에는 bitmap과 리스트 형식의 많은 양의 데이터가 아닌 직렬화, 역직렬화가 가능한 작은 데이터에 적합하다.<br>
즉, 잠재적으로 데이터의 양이 많다면 적절한 방법이 아니다.</p>
<p>또 다른 문제는 UI 컨트롤러가 자주 비동기 호출을 만들어서 반환하는데 다소 시간이 걸릴 수 있다는 것이다. 잠재적인 메모리 누수를 피하기 위해 UI 컨트롤러는 Destroy 된 후에 시스템이 instance를 정리하기 전에 비동기 호출을 관리할 필요가 있다.<br>
이런 관리 작업은 엄청난 유지보수를 필요로 하고, 상태 변화로 인해 객체를 재생성하는 경우, 이미 만들어진 객체를 다시 호출해야 하므로 리소스가 낭비된다.</p>
<p>Activity, Fragment와 같은 UI 컨트롤러는 사용자에게 UI 데이터를 보여주고, 사용자 액션에 반응하고, 권한 요청과 같은 OS의 요청을 처리하는 용도로 사용된다.</p>
<p>데이터베이스나 네트워크로부터 데이터를 불러오는 동작은 UI 컨트롤러에서 수행하면 클래스의 크기가 커지게 된다. 따라서 UI 컨트롤러에 과도한 책임이 할당되면 클래스가 단일화되어 테스트가 매우 어려워질 수 있다.</p>
<p>그래서 <code>ViewModel</code>을 사용함으로써 UI 컨트롤러의 로직으로부터 UI 로직과 데이터 소유권을 분리할 수 있는 매우 효과적인 방법이다.</p>
<h2 id="viewmodel-예시"># ViewModel 예시.</h2>
<p>Google의 Android Architecture Components(이하 AAC)에서 UI 컨트롤러들을 위한 헬퍼 클래스인 <code>ViewModel</code>을 제공한다.<br>
ViewModel 객체는 자동으로 화면 회전 같은 상태 변화동안 자동으로 유지되고 새로운 액티비티 또는 프래그먼트에서도 데이터를 즉시 사용할 수 있다.</p>
<p><strong>MainViewModel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; userList;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers()&#123;</span><br><span class="line">        <span class="keyword">if</span>(userList == <span class="keyword">null</span>)&#123;</span><br><span class="line">            userList = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch userList.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainActivity</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MainViewModel viewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(MainViewModel.class);</span><br><span class="line">        viewModel.getUsers().observe(<span class="keyword">this</span>, userList -&gt;&#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 액티비티가 재생성이 된다면 처음 만들어진 <code>MainViewModel</code> 인스턴스를 받게 된다. 이 인스턴스를 호출한 액티비티 또는 프래그먼트가 destroy 되어 메모리 해제가 되기 전까지 데이터를 유지하고 있어서 데이터를 보관하고 있다가 화면 회전 같은 상태 변화가 발생해도 데이터를 유지하게 된다.</p>
<p>안드로이드 프레임워크는 내부적으로 class, ViewModel의 Map을 관리하므로 이미 존재하는 ViewModel의 레퍼런스를 가져올 때마다 그 인스턴스를 반환하게 된다.</p>
<p>ViewModel을 소유한 액티비티가 종료되면 프레임워크는 자동으로 ViewModel 객체의 onCleared() 메소드를 호출할 것이다. 그렇다면 우리는 이 함수를 오버라이드하여 리소스를 해제하면 된다.</p>
<p>ViewModel 인스턴스는 뷰나 <code>LifecycleOwners</code>의 특정 인스턴스보다 오래 유지되도록 설계되었다. 이런 설계는 ViewModel 인스턴스가 뷰나 Lifecycle 인스턴스를 모르기 때문에 ViewModel에 대해 더 쉽게 테스트를 작성할 수 있게 해준다.</p>
<p>ViewModel 인스턴스는 <strong>LiveData</strong> 인스턴스와 같은 <code>LifecycleObservers</code>를 포함할 수 있다. 하지만, LiveData와 같은 라이프사이클 기반의 Observable 클래스의 변화를 관찰해서는 안된다. 만약, ViewModel이 시스템 서비스를 찾는 등의 이유로 Application Context가 필요하다면, <code>AndroidViewModel</code> 클래스를 상속받아서 생성자에서 Application 객체를 받도록 구현할 수 있다.</p>
<ul>
<li>주의 : ViewModel 인스턴스는 반드시 뷰, Lifecycle, Activity 참조를 가지고 있는 어떤 클래스도 참조를 유지하면 안된다. 이유는 메모리 누수가 발생할 수 있기 때문이다.</li>
</ul>
<h2 id="viewmodel-생명주기"># ViewModel 생명주기.</h2>
<p>ViewModel의 생명주기는 <code>ViewModelProvider</code>에 전달된 Lifecycle에 생명주기 범위가 지정된다.<br>
즉, 주어진 액티비티가 살아있는 동안 ViewModel 객체는 메모리에 계속 남아있는다.<br>
액티비티의 경우에는 finish될 때, 프래그먼트의 경우에는 액티비티로부터 detached될 때까지이다.</p>
<img src="/img/viewmodel-lifecycle.png" width="600" height="200">
<p>위의 그림에서 ViewModel의 스코프를 확인할 수 있다. 그림은 Activity가 화면 회전되었을 때의 생명주기를 나타낸다. 화면이 회전해도 상태 변경이 되는 상황에서도 살아 있음을 보여준다. Fragment의 기본 생명주기에 따른 ViewModel의 생존시간도 동일하다.</p>
<p>일반적으로 ViewModel 인스턴스를 Activity의 시작점인 onCreate()에서 요청할 것이다. onCreate() 함수는 상황에 따라 여러 번 호출될 수 있지만, ViewModel 객체는 최초 요청부터 Activity가 소멸될 때까지 메모리에 유지된다.</p>
<h2 id="의문점"># 의문점?!</h2>
<p><strong>A 액티비티에서 ViewModel 객체를 생성하면 scope는 A 액티비티의 생명주기를 따르낟. 만약, B 액티비티에서 ViewModel에 저장된 값을 재사용하고 싶다면??</strong></p>
<p>B 액티비티에서 ViewModelProviders로 객체를 다시 구해오면 A 액티비티에서 만든 객체가 아닌 새로운 객체를 만들어낸다.</p>
<p><a href="https://stackoverflow.com/questions/49364550/android-livedata-how-to-reuse-the-same-viewmodel-on-different-activities" target="_blank" rel="noopener">how to reuse the same ViewModel on different activites</a></p>
<p>위의 글을 보면 싱글톤 팩토리로 동작하는 custom ViewModel Factory를 전달하여 다른 액티비티에서도 동일한 ViewModel 인스턴스를 받을 수 있는 방법이 있다.<br>
하지만, 다른 액티비티의 생명주기에서 ViewModel 객체를 유지하는 것은 안티패턴이다.</p>
<p>RxJava와 다르게 생명주기에 따라 데이터를 보관/관리 해주는 LiveData의 장점을 버리는 방식이라고 생각된다.</p>
<p>따라서 ViewModel의 객체를 유지시키는 것이 아닌 DataSource나 Repository를 싱글톤으로 유지하는 것이 더 추천되는 방식이다.<br>
<a href="https://stackoverflow.com/questions/49364550/android-livedata-how-to-reuse-the-same-viewmodel-on-different-activities/49365126#49365126" target="_blank" rel="noopener">https://stackoverflow.com/questions/49364550/</a></p>
<img src="/img/viewmodel-viewModel_reuse.png" width="600" height="200">
<p>ViewModel의 객체를 유지시키는 방식이 아닌 Other data layers(data source, data source를 관리하는 Repository)를 싱글톤 객체로 만들어 데이터를 유지시켜 다른 Activity들에서 새로운 ViewModel 객체를 만들어 Repository를 통해 보관중이 데이터를 가져오는 방식이다.</p>
<h2 id="fragment-간-데이터-공유"># Fragment 간 데이터 공유.</h2>
<p>하나의 액티비티 안에서 2개 이상의 프래그먼트 간에 데이터를 주고 받는 구조는 흔한 경우다. 이럴 때는 프래그먼트의 scope를 사용하는 것이 아닌 프래그먼트들을 감싸고 있는 액티비티의 scope를 전달하면 된다.</p>
<p>즉, 프래그먼트들이 액티비티 scope의 ViewModel을 서로 공유하도록 구현하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewModelProvider</code>를 얻을 때, 두 프래그먼트 모두 <strong>getActivity()</strong> 메소드를 이요하고 있다. 같은 Activity를 이용하여 같은 ViewModel 객체를 요청하므로 동일한 객체가 얻어진다.</p>
<p>이 접근 방법은 다음과 같은 이점이 존재한다.</p>
<ul>
<li>Activity가 각 Fragment간 데이터 전달 시에 추가적인 작업을 할 필요가 없다.</li>
<li>각 Fragment는 ViewModel 외에 다른 객체나 상태에 대해 더 알 필요가 없다. 그러므로 다른 Fragment가 사라지더라도 정상적으로 동작할 것이다.</li>
<li>각 Fragment는 다른 Fragment의 라이프사이클을 신경쓰지 않고, 자신의 라이프사이클 대로 작업을 수행할 수 있다.</li>
</ul>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="https://duzi077.tistory.com/196" target="_blank" rel="noopener">Android Architecture Components ViewModel이란?</a></li>
<li><a href="http://dktfrmaster.blogspot.com/2018/02/viewmodel.html" target="_blank" rel="noopener">[안드로이드] Architecture Component 1 - ViewModel 공식문서 번역</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/02/What-is-ViewModel/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/30/What-is-LiveData/"
                            aria-label=": [안드로이드] LiveData"
                        >
                            [안드로이드] LiveData
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-30T10:55:52+09:00">
	
		    Apr 30, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>MVVM을 이해하기 위해 알아보는 <code>LiveData</code><br>
추후 더 자세한 내용을 정리할 예정.</p>
<h2 id="livedata란"># LiveData란?</h2>
<p>직역하면 살아있는 데이터? 이렇게 생각할 수 있다. LiveData는 LifeCycle을 알고 있는 DataType이라고 생각하면 좋다. 이처럼 LifeCycle을 알고 있으면 필요할 때 변경하고 필요하지 않을 때 변경하지 않을 수 있다.</p>
<p>또한, LiveData는 Observer 패턴을 따른다. 즉 데이터의 변경이 일어났을 때 콜백으로 받아 처리할 수 있다. 이렇게 데이터의 변경이 일어날때마다 콜백을 실행하는데 LifeCycle을 알고 있기 때문에 필요하지 않을 때는 콜백이 실행되지 않는다.</p>
<p>예를 들어 Activity에 선언되어 있는 LiveData의 경우 Activity가 Start, Resume 상태일 때는 콜백을 실행하지만 다른 액티비티로 넘어가 있는 onStop 등의 상태일 때는 실행되지 않는다.</p>
<img src="/img/livedata_android.png" width="600" height="200">
<ul>
<li>postValue : 간단히 데이터가 변경된다.</li>
</ul>
<p>이렇듯 onStart, onResume의 상태일 때 A와 B를 받는 옵저버 콜백은 실행되지만 onStop일 때 C와 D일 때는 실행되지 않고(옵저버 되지 않음) 다시 액티비티가 실행되면 가장 최신의 데이터인 D를 실행한다.(옵저버 됨) 이렇듯 LiveData를 사용하면 RxJava나 Interface Callback을 사용할 때 보다 더 깔끔하게 처리할 수 있다.</p>
<h2 id="간단한-예제"># 간단한 예제</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> : <span class="type">ViewModel</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MutableLiveData란 변경할 수 있는 LiveData 형이다.</span></span><br><span class="line">    <span class="comment">// 일반적인 LiveData형은 변경할 수 없고 오로지 데이터의 변경값만을 소비하는데 반해</span></span><br><span class="line">    <span class="comment">// MutableLiveData는 데이터를 UI Thread와 Background Thread에서 선택적으로 바꿀 수 있다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _post = MutableLiveData&lt;User&gt;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// _post로 선언된 MutableLiveData를 post를 통해 발행한다.</span></span><br><span class="line">    <span class="comment">// 이렇듯 ViewModel에서만 _post를 변경할 수 있기 때문에 보안에 더 좋다.</span></span><br><span class="line">    <span class="keyword">val</span> post : LiveData&lt;User&gt;</span><br><span class="line">        <span class="keyword">get</span>() = _post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같은 데이터를 Activity에서 받으려면</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostActivity</span></span>() : AppCompatActivity()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState : <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 위의 ViewModel에서 post LiveData를 Observe한다.</span></span><br><span class="line">        <span class="comment">// 첫 번째 인자는 UI이며 해당 인자로 어떤 UI Thread를 사용할 지 결정한다.</span></span><br><span class="line">        <span class="comment">// 두 번째는 Observe 콜백이다.</span></span><br><span class="line">        postViewModel.post.observe(<span class="keyword">this</span>,</span><br><span class="line">            Oberserver&#123;</span><br><span class="line">                post -&gt; postTitle.text = post?.title</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LiveData 콜백을 실행하는 방법은 아래처럼 두 가지가 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MutableLiveData에ㅓ setValue, postValue 실행 하는 경우</span></span><br><span class="line"></span><br><span class="line">post.setValue(post) <span class="comment">// UI Thread 즉, Main Thread에서 실행</span></span><br><span class="line">post.postValue(post) <span class="comment">// Background Thread에서 실행</span></span><br></pre></td></tr></table></figure>
<p>사실 LiveData를 더 잘쓰려면 <strong>데이터바인딩</strong>과 함께 사용해야 좋은 효과를 낼 수 있다. 왜냐하면 위에서처럼 Observe 패턴을 이용해서 UI를 직접 변경해줄 필요 없이 xml 상에서 깔끔하게 처리할 수 있다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">....</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;viewModel.post.title&#125;/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>이처럼 아주 깔끔하게 선언할 수 있다 이제 title이 변경되는대로 TextView UI는 알아서 변경이 된다.</p>
<p>그렇다면 LiveData Observer UI(Activity, Fragment)가 사라진다면? 더 이상 새로운 데이터를 발행하지 않는다. rx로 따지면 Dispose가 필요없다. 즉, 데이터를 더 이상 발행하지 않기 때문에 알아서 구독을 해지하는 것으로 생각이 든다.</p>
<h2 id="livedata-변형하기"># LiveData 변형하기</h2>
<p>간단하게 살펴보고 추후에 자세하게 살펴보도록 하겠다.</p>
<p><strong>Map</strong></p>
<ul>
<li>LiveData의 변경을 다른 LiveData에게 알려주는 메소드.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userLiveData : LiveData&lt;User&gt; = ...</span><br><span class="line"><span class="keyword">val</span> userNameLiveDat = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">$&#123;user.firstName&#125;</span>, <span class="subst">$&#123;user.lastName&#125;</span>"</span> <span class="comment">// String을 리턴한다.</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>UserLiveData의 변경사항을 Observe해서 map 함수를 통해서 원하는 값으로 변경한 뒤 String을 리턴한다. 즉, 새로운 LiveData를 리턴하는게 아니라 데이터만 변경한다.</p>
<p><strong>SwitchMap</strong></p>
<ul>
<li>LiveData의 변경사항을 받아서 다른 LiveData를 발행한다. 일반적으로 RoomDatabase를 LiveData로 쓸 때 많이 사용된다고 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userIdLiveData : MutableLiveData = ...</span><br><span class="line"><span class="keyword">val</span> userLiveData : LiveData = Transformations.switchMap(userIdLiveData, id -&gt; </span><br><span class="line">    repository.getUserById(id)) <span class="comment">// LiveData를 리턴한다.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setUserId</span><span class="params">(userId : <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userIdLiveData.setValue(userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SwitchMap은 데이터의 인자값에 따라 다른 LiveData를 발행한다. repository.getUserById(id)는 RooDatabase에서 ID 값에 따라 유저값을 가져오며 return 값이 LiveData이다. 즉, 인자 값에 따라서 다른 데이터 소스(LiveData)를 보낼 수 있다.</p>
<p><strong>MediatorLiveData</strong></p>
<ul>
<li>여러 데이터 소스를 한 곳에서 Observe할 때 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> liveData1:LiveData = ...</span><br><span class="line"><span class="keyword">val</span> liveData2: LiveData = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> liveDataMerger:MediatorLiveData = new MediatorLiveData&lt;&gt;()</span><br><span class="line"> liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value))</span><br><span class="line"> liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value))</span><br></pre></td></tr></table></figure>
<p>예를 들어 Fragment별로 LiveData<error>가 있고 이걸 Activity 한 곳에서 Crashlytics에 기록한다거나 Toast 메시지를 띄울 때 Fragment의 LiveData를 Activity의 MediatorLiveData를 통해 사용할 수 있다.</error></p>
<p>LiveData는 많은 기능이 있는 것 같다. 하지만 혼자 쓰기 보다는 DataBinding, ViewModel과 함께 MVVM 패턴에서 사용될 때 효과가 더욱 두드러질 것 같다는 생각이 든다.</p>
<p>LiveData와 관련된 자세한 내용을 추후에 공부해서 올릴 예정이다.<br>
앞으로도 열심히하길~</p>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/jetpack-android-livedata-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-ed49a6f17de3" target="_blank" rel="noopener">Jetpack Android — LiveData 알아보기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/30/What-is-LiveData/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Android/archives/3/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/categories/Android/archives/5/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 4 of 8</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
