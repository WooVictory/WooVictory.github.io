
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>[Kotlin in Action] Chap5. 람다 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"articleBody":"람다 식 | 람다\n기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.\n\n람다 식과 멤버 참조\n람다는 자바 8에 도입되어 자바에서도 비로소 람다를 사용할 수 있게 되었다.\n람다 소개: 코드 블록을 함수 인자로 넘기기\n[자바에서 익명 클래스를 통해 버튼 클릭 리스너 구현]\n1234567/* 자바 */button.setOnClickListener(new OnClickListener() &#123;    @Override    public void onClick(View view) &#123;        /* 클릭시 동작 */    &#125;&#125;);\n[람다로 리스너 구현]\n1button.setOnClickListener &#123; /* 클릭시 동작 */&#125;\n\n두 구현은 동일한 동작이지만 람다를 이용한 경우 코드가 훨씬 간결하고 읽기 쉬워진다.\n\n람다와 컬렉션\n[컬렉션에서 가장 큰 값 찾기: 직접 구현]\n12345678910111213141516fun findTheOldest(people: List&lt;Person&gt;) &#123;    var maxAge = 0    var theOldest: Person? = null       for (person in people) &#123;        if (person.age &gt; maxAge) &#123;            maxAge = person.age            theOldest = person        &#125;    &#125;    println(theOldest)&#125;val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))findTheOldest(people)// 결과: Person(name=Bob, age=31)\n[컬렉션에서 가장 큰 값 찾기: 람다 이용]\n123456val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))println(people.maxBy &#123; it.age &#125;) // 나이 프로퍼티를 비교해서 가장 큰 원소 찾기// 결과: Person(name=Bob, age=31)println(people.maxBy(Person::age)) // 나이 프로퍼티를 비교해서 가장 큰 원소 찾기// 결과: Person(name=Bob, age=31\n\n자바 컬렉션에 대해 (자바 8 이전, 람다 지원 전) 수행하던 대부분의 불편했던 작업들은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선이 가능하다. 이렇게 개선된 후에는 코드가 한결 짧아지고 더 이해하기 쉬워졌다.\n\n람다 식의 문법\n12&#123; x: Int, y: Int -&gt; x + y &#125;//    파라미터     -&gt;   본문\n\n람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다.\n\n추가로 람다를 따로 선언해서 변수에 저장도 가능하다. 그렇다곤 해도 보통은 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.\n\n\n\n123val sum = &#123; x: Int, y: Int -&gt; x + y&#125; // 람다식 변수에 저장println(sum(1, 2)) // 변수에 저장된 람다식 호출// 결과: 3\n\n심지어는 람다식을 직접 호출도 가능하다.\n\n12&#123; println(42) &#125;()//  결과: 42\n굳이 이렇게 쓰는 것보다는 가독성 때문에라도 람다 본문을 직접 실행하는 편이 낫다.\n123// 인자로 받은 람다를 실행해주는 라이브러리 함수인 run을 사용하여 람다 본문 실행run &#123; println(42) &#125;// 결과: 42\n\n코틀린 람다 식은 항상 중괄호로 둘러싸여있다.\n인자 목록 주변에 괄호가 없다.\n화살표(-&gt;)를 통해 인자 목록과 람다 본문을 구분한다.\n\n람다식 사용 예제\n123456789101112val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))// 인자가 한 개고 타입 추론 가능하면 디폴트 이름인 it 사용 가능println(people.maxBy &#123; it. age &#125;)people.maxBy(&#123; p: Person -&gt; p.age&#125;)// 람다가 마지막 인자면, 괄호 밖에 위치 가능people.maxBy() &#123; p: Person -&gt; p.age&#125;// 람다가 마지막 인자고, 괄호 뒤에 람다를 썼을 경우 괄호 생략 가능people.maxBy &#123; p: Person -&gt; p.age&#125;\n\n간단한 경우라면 괄호 없이 람다식만으로 명시해도 나쁘지 않을 것으로 생각되지만 웬만하면 괄호를 사용하여 해당 람다식이 메소드에 포함된 람다식이라는 것을 확실히 하는 것이 가독성에 더 좋을 것 같다.\n\n이름 붙인 인자를 사용해 람다 넘기기\n1234567val people = listOf(Person(\"이몽룡\", 29), Person(\"성춘향\", 31))val names = people.joinToString(seprator = \" \", transform = &#123; p: Person -&gt; p.name &#125;)println(names)// 결과: 이몽룡 성춘향// 괄호 밖으로 처리val names = people.joinToString(\" \") &#123; p: Person -&gt; p.name&#125;\n\n개인적인 생각이지만 이 예제를 보니 개인적인 프로젝트에서 특정 메소드에 대한 완벽한 이해가 있고 람다식을 사용하는 곳도 완벽한 이해가 있는 경우에는 람다식을 괄호 밖으로 빼서 표현하는 것이 코드도 간결하고 보기도 더 좋지만 협업을 하는 상황이라면 누구라도 코드를 이해하기 쉽도록 괄호를 사용하여 일반적인 메소드 호출을 이용하여 람다식을 표현하는 것이 더 좋을 것으로 생각된다.\n\n람다 파라미터 타입 제거하기\n123456people.maxBy &#123; p: Person -&gt; p.age &#125; // 파라미터 타입 명시people.maxBy &#123; p -&gt; p.age &#125; // 파라미터 타입 생략 (컴파일러가 추론)// 변수에 람다식 담는 경우 컴파일러가 타입 추론 불가val getAge = &#123; p: Person -&gt; p.age &#125;people.maxBy(getAge)\n\n컴파일러는 람다 파라미터의 타입도 추론 할 수 있다.\npeople은 Person을 담은 컬렉션이므로 컴파일러는 Person 객체가 파라미터로 들어올 것을 추론할 수 있다.\n\n컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있으나 이번 장에서는 다루지 않는다.\n\n\n단, 람다식을 변수에 담는 경우 파라미터의 타입을 추론할 문맥이 존재하지 않으므로 파라미터를 명시해야만 한다.\n\n디폴트 파라미터 이름 it 사용하기\n1people.maxBy &#123; it.age &#125;\n\nit는 자동 생성된 파라미터 이름이다.\n람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it를 사용할 수 있다.\n\n\n람다 내에 람다가 중첩되는 경우나 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에는 파라미터를 명시적으로 선언하는 것이 가독성에 더 좋다.\n\n본문이 여러줄로 이뤄진 람다식\n1234val sum = &#123; x: Int, y: Int -&gt;     println(\"Computing the sum of $x and $y...\")    x + y&#125;\n\n본문이 여러줄로 이루어진 경우 맨 마지막에 있는 식이 람다식의 결과값이 된다.\n\n현재 영역에 있는 변수에 접근\n12345678910fun printMessageWithPrefix(messages: Collection&lt;String&gt;, prefix: String) &#123;    messages.forEach &#123;        println(\"$prefix $it\") // 람다 내부에서 함수의 \"prefix\" 변수 사용    &#125;&#125;// &gt;&gt;&gt; val errors = listOf(\"403 Forbidden\", \"404 Not Found\")// &gt;&gt;&gt; printMessagesWithPrefix(errors, \"Error:\")// 결과: Error: 403 Forbidden//      Error: 404 Not Found\n\n람다를 함수 안에서 정의하면 함수의 파라미터에 접근이 가능하다.\n뿐만 아니라 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.\n\n1234567891011121314151617fun printProblemCounts(response: Collection&lt;String&gt;) &#123;    var clientErrors = 0 // 람다 외부에 로컬 변수 선언    var serverErrors = 0 // 람다 외부에 로컬 변수 선언        response.forEach &#123;        if (it.startsWith(\"4\")) &#123;            clientErrors++ // 람다 내부에서 외부의 로컬 변수 값 변경        &#125; else if (it.startsWith(\"5\")) &#123;            serverErrors++ // 람다 내부에서 외부의 로컬 변수 값 변경        &#125;    &#125;    println(\"$ClientErrors client errors, $serverErrors server errors\")&#125;// &gt;&gt;&gt; val responses = listOf(\"200 OK\", \"418 I'm a teapot\", \"500 Internal Server Error\"// &gt;&gt;&gt; printProblemCounts(responses)// 결과: 1 client errors, 1 server errors\n\n람다 내부에서는 final 변수가 아닌 변수에 접근이 가능하다.\n람다 내부에서 람다 외부의 변수 변경도 가능하다.\n\n람다 내부에서 사용하는 람다 외부 변수를 람다가 포획한 변수라고 부른다. (위 예제들의 prefix, clientErrors, serverErrors)\n\n\n\n\n람다를 실행 시점에 표현하는 데이터 구조는 람다에서 시작하는 모든 참조가 포함된 닫힌(closed) 객체 그래프를 람다 코드와 함께 저장해야 한다. 그런 데이터 구조를 클로저(closure) 라고 부른다. 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야 하고, 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다. 그래서 람다를 클로저라고 부르기도 한다.\n\nTODO 무슨 말인지 이해가 가지 않는다… 코틀린 스터디 팀원들에게 물어보고 내용을 추가하도록 하자…!\n로컬 변수의 생명주기와 함수의 생명주기가 다른 경우\n(예를 들면, 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장하는 경우가 있다.)\n\n포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.\n\nfinal 변수인 경우: 람다 코드를 변수 값과 함께 저장하여 함수가 끝난 뒤에도 포획한 변수에 접근이 가능하다.\nfinal 변수가 아닌 경우: 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.\n코틀린에서도 자바와 같이 약간의 꼼수(?)로 변경 가능한 변수를 포획하게 된다.\n\n\n\n12345678// 실제 코드var counter = 0val inc = &#123; counter++ &#125;// 내부 동작을 보여주는 코드class Ref&lt;T&gt;(var value: T)val counter = Ref(0)val inc = &#123; counter.value++ &#125;\n\nRef 라는 클래스로 래핑하여 해당 클래스를 final 하게 선언하고 그 내부에 멤버 변수에 counter 값을 저장한다.\n그 이후 람다식에서는 클래스의 변수값에 접근하여 변경 가능한 변수를 포획한다.\n\n람다를 이벤트 핸들러 등 비동기 실행 코드로 활용하는 경우\n12345fun tryToCountButtonClicks(button: Button): Int &#123;    var clicks = 0    button.onClick &#123; clicks++ &#125;    return clicks&#125;\n\n람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다는 점을 인지해 유의하여 사용해야 한다.\n위 예시 코드에서 해당 함수는 항상 0을 반환한다.\n\nonCiick 핸들러는 버튼이 클릭될 때마다 clicks 변수를 증가시키지만 그 때에는 함수 호출이 종료된 이후이기 때문이다.\n즉, 해당 clicks 변수를 확인할 수 있도록 클래스의 프로퍼티나 전역 프로퍼티 등의 위치로 빼서 나중에 해당 변수를 확인할 수 있도록 해야 한다.\n\n\n\n멤버 참조\n이미 선언된 함수를 값으로 사용해야 할 때 멤버 참조 :: 를 사용하면 된다.\n123456789101112131415161718192021// 모두 같은 동작people.maxBy(Person::age) // 멤버 참조people.maxBy &#123; p -&gt; p.age &#125;people.maxBy &#123; it.age &#125;fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult // 확잠 함수도 동일하게 멤버 참조를 사용할 수 있음fun salute() = println(\"Salute!\")run(::salute) // 최상위 함수 참조// 결과: Salute!// sendEmail 함수에게 작업 위임val action = &#123; person: Person, message: String -&gt; sendEmail(person, message) &#125;// 람다 대신 멤버 참조 사용val nextAction = ::sendEmail// 생성자 참조data class Person(val name: String, val age: Int)val createPerson = ::Person // 생성자 참조 저장val p = createPerson(\"Alice\", 29) // 생성자 참조를 이용해 인스턴스 생성\n\n멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.\n:: 는 클래스 이름과 참조하려는 멤버(프로퍼티나 메소드) 이름 사이에 위치한다.\n멤버 참조 뒤에는 괄호를 넣으면 안된다. (메소드여도!!)\n멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.\n최상위 함수, 최상위 프로퍼티 참조도 가능하다.\n\n클래스 이름을 생략하고 :: 로 참조를 바로 시작하면 된다.\n\n\n생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.\n\n:: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.\n\n\n\n바운드 멤버 참조 (1.1부터 사용 가능)\n1234567891011// 1.0 멤버 참조val p = Person(\"Dmistry\", 34)val personAgeFunction = Person::ageprintln(personAgeFunction(p))// 결과: 34// 1.1 바운드 멤버 참조val p = Person(\"Dmistry\", 34)val ageFunction = p::age // p에 엮인 멤버 참조println(ageFunction())// 결과: 34\n\nTODO 바운드 멤버 참조는 한 인스턴스에 대해서만 동작이 될 것으로 생각이 드는데 이걸 사용할만한 곳이 있을까? 하는 의문이 든다.\n\n컬렉션 함수형 API\n필수적인 함수: filter와 map\nfilter 함수\n12345678val list = listOf(1, 2, 3, 4)println(list.filter &#123; it % 2 == 0 &#125;) // 짝수만 filtering// 결과: [2, 4]val personList = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterList = personList.filter &#123; it.age &gt; 30 &#125;println(filterList)// 결과: [Person(name=Bob, age=31)]\n\n컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 true인 원소를 모은다.\n만족하는 원소들을 모아 새로운 컬렉션으로 반환한다.\n\nmap 함수\n12345678910111213val list = listOf(1, 2, 3, 4)println(list.map &#123; it * it &#125;) // 자기자신을 곱함// 결과: [1, 4, 9, 16]val personList = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val mapList = personList.map &#123; it.age &#125; // 나이만으로 컬렉션을 만듦println(mapList)// 결과: [31, 29]// 멤버 참조 사용val memberRefMapList = personList.map(Person::name)println(memberRefMapList)// 결과: [Bob, Alice]\n\n주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.\n\nfilter + map 조합\n123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterAndMap = list.filter &#123; it.age &gt; 30 &#125;.map &#123; it.name &#125;// 결과: [Bob]\n\n연쇄로 호출하여 사용도 가능하다.\n\nmaxBy + filter 조합\n123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterAndMaxBy = list.filter &#123; it.age == list.maxBy(Person::age)!!.age&#125;// 결과: [Person(name=Bob, age=31)]\n\n위 코드의 단점은 filter가 이터레이션하기 때문에 maxby 함수가 컬렉션 수 만큼 호출되며 처리된다는 것이다.\n개선해보면…\n\n123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val maxAge = list.maxBy(Person::age)!!.ageval filterAndMaxBy = list.filter &#123; it.age == maxAge &#125;\n\n이터레이션 된다는 것을 항상 기억하고 불필요한 작업을 반복하지 않도록 유의해야 한다.\n\n컬렉션 맵에서의 filter, map\n123456789101112131415val numbers = mapOf(0 to \"zero\", 1 to \"one\", 2 to \"two\", 3 to \"three\", 4 to \"four\")val filterValuesMap = numbers.filterValues &#123; it == \"zero\"&#125;val mapValuesMap = numbers.mapValues &#123; it.value.toUpperCase() &#125;println(filterValuesMap)println(mapValuesMap)val filterKeysMap = numbers.filterKeys &#123; it == 1 &#125;val mapKeysMap = numbers.mapKeys &#123; it.key % 2 &#125;println(filterKeysMap)println(mapKeysMap)// 결과: filterValuesMap = &#123;0=zero&#125;//      mapValuesMap = &#123;0=ZERO, 1=ONE, 2=TWO, 3=THREE, 4=FOUR&#125;//      filterKeysMap = &#123;1=one&#125;//      mapKeysMap = &#123;0=four, 1=three&#125;\n\n맵에서의 filter와 map은 별도의 API가 존재한다.\n맵의 filterValues, filterKeys 의 it 는 각각 value와 key를 가르킨다.\n\n컬렉션에 술어 사용: all, any, count, find\n12345678910111213val list = listOf(Person(\"Alice\", 27), Person(\"Bob\", 31), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))// 술어 선언val canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= 27 &#125;println(\"all: $&#123;list.all(canBeInClub27)&#125;\")println(\"any: $&#123;list.any(canBeInClub27)&#125;\")println(\"count: $&#123;list.count(canBeInClub27)&#125;\")println(\"find: $&#123;list.find(canBeInClub27)&#125;\")// 결과: all: false//      any: true//      count: 3//      find: Person(name=Alice, age=27)\n\nall: 컬렉션의 모든 원소가 조건을 만족하는지 판단\nany: 컬렉션의 모든 원소 중 하나라도 조건을 만족하는지 판단\ncount: 조건을 만족하는 원소의 갯수를 반환\nfind: 조건을 만족하는 첫 번째 원소를 반환, 만족하는 원소가 없을 경우 null을 반환\n\n\n함수형 API 사용시 고려할 점\n\n\n함수형 API count 와 컬렉션에 포함된 함수 size() 의 차이?\ncount의 경우 조건을 만족하는 원소의 개수만 추적할 뿐 원소를 따로 저장하지 않는다.\nsize()의 경우 만족하는 원소를 가진 객체를 생성 시키게 된다.\n위 예제 코드의 결과에서 보듯이 all과 any는 서로 부정으로 대응한다. 하지만 가독성을 이유로 any 대신 !all 이나 all 대신 !any는 사용하지 않는 것이 좋다.\n\ngroupBy\n12345678910val list = listOf(Person(\"Alice\", 27), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))println(\"groupBy: $&#123;list.groupBy &#123; it.age &#125;&#125;\")// 결과: groupBy: &#123;27=[Person(name=Alice, age=27), Person(name=WooVictory, age=27)], //              25=[Person(name=hzoou, age=25)], //              28=[Person(name=txxbro, age=28), Person(name=iyj, age=28)]&#125;val strs = listOf(\"12\", \"345\", \"11\", \"456\")println(strs.groupBy &#123; it.length &#125;)// 결과: &#123;2=[12, 11], 3=[345, 456]&#125;\n\ngroupBy: 리스트를 특정 기준에 맞춰 맵으로 변경하여 반환\n\nflatMap과 flatten: 중첩된 컬렉션 안의 원소 처리\n1234567891011121314151617val strings = listOf(\"abc\", \"def\")println(strings.flatMap &#123; it.toList() &#125;)//결과: [a, b, c, d, e, f]data class Book(val title: String, val authors: List&lt;String&gt;)val books = listOf(Book(\"책1\", listOf(\"작가1\")),                 Book(\"책2\", listOf(\"작가2\", \"작가3\")),                  Book(\"책3\", listOf(\"작가4\", \"작가1\")))println(\"toSet(): $&#123;books.flatMap &#123; it.authors &#125;.toSet()&#125;\")println(\"기본: $&#123;books.flatMap &#123; it.authors &#125;&#125;\")// 결과: toSet(): [작가1, 작가2, 작가3, 작가4]//      기본: [작가1, 작가2, 작가3, 작가4, 작가1]println(\"flatten(): $&#123;books.map &#123; it.authors &#125;.flatten()&#125;\")// 결과: flatten(): [작가1, 작가2, 작가3, 작가4, 작가1]\n\nflatMap: 인자로 주어진 람다를 컬렉션의 모든 객체에 적용(매핑)하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 모은다(flatten). 즉, 리스트의 리스트가 있을 때 중첩된 리스트의 원소를 한 리스트로 모을 때 사용한다.\ntoSet(): 컬렉션의 중복을 제거리\nflatten(): 변환할 내용 없이 펼치기만 하는 경우 사용\n\n\n책에서 다루지 않은 이외에도 많은 컬렉션 API가 존재한다.\n이외의 API 는 Kotlin Collection Reference 를 참고하자.\n\n지연 계산(lazy) 컬렉션 연산\n콜렉션의 연산자(e.g. map, filter)는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.\n시퀀스(sequence)를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.\n1poeple.map(Person::name).filter &#123; it.startsWith(\"A\") &#125;\n\nmap과 filter는 둘 다 리스트를 반환한다. 즉 위 코드에서 연쇄 호출로 인해 리스트를 2개 만들어졌다.\n\n123people.asSequence() // 원본 컬렉션을 시퀀스로 변환    .map(Person::name).filter &#123; it.startsWith(\"A\")&#125;    .toList() // 결과 시퀀스를 다시 리스트로 변환\n\n시퀀스의 원소는 필요할 때 비로소 계산되기 때문에 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해 효율적으로 계산을 수행할 수 있다.\nasSequence(): 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.\ntoList(): 시퀀스를 리슷트로 바꿀 때 사용한다.\n\n\n리스트 대신에 시퀀스를 쓰는 것이 더 낫지 않은가?\n\n\n“항상 그렇지는 않다.”\n인덱스를 사용해 접근하는 등 다른 API 메소드를 사용하기 위해서는 리스트로 변환해야 한다.\n\n시퀀스 연산 실행: 중간 연산과 최종 연산\n중간 연산과 최종 연산은 p225의 그림 5.7을 참고하자.\n\n중간 연산: 다른 시퀀스를 반환하며 최초 시퀀스의 원소를 변환하는 방법을 알고 있다.\n\n항상 지연 계산된다. 즉, 최종 연산을 하지 않으면 계속 지연이 되어 결과를 반환하지 않는다.\n\n\n최종 연산: 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자, 객체이다.\n\n즉시 계산의 수행 순서와 지연 계산의 수행 순서\n12345678910111213141516171819202122232425// eagerlylistOf(1, 2, 3, 4).map &#123; println(\"eagerly map($it)\"); it * it &#125;                .filter &#123; println(\"eagerly filter($it)\"); it % 2 == 0 &#125;// 결과: eagerly map(1)//      eagerly map(2)//      eagerly map(3)//      eagerly map(4)//      eagerly filter(1)//      eagerly filter(4)//      eagerly filter(9)//      eagerly filter(16)// lazylistOf(1, 2, 3, 4).asSequence()                .map &#123; println(\"lazy map($it)\"); it * it&#125;                .filter &#123; println(\"lazy filter($it)\"); it % 2 == 0 &#125;                .toList()//결과: lazy map(1)//     lazy filter(1)//     lazy map(2)//     lazy filter(4)//     lazy map(3)//     lazy filter(9)//     lazy map(4)//     lazy filter(16)\n\n즉시 계산의 경우 모든 원소에 대해 먼저 map을 끝낸 후 이후 filter를 수행하게 된다.\n시퀀스(지연 계산)의 경우 각 원소에 대해 순차적으로 적용이 된다.\np226의 그림 5.8을 참고하자.\n\nmap과 filter 호출 순서에 따른 성능 차이의 발생\n1234567val list = listOf(Person(\"Alice\", 27), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))list.asSequence().map(Person::name) // map 먼저 실행    .filter &#123; it.length &lt; 4 &#125;.toList()list.asSequence().filter &#123; it.length &lt; 4 &#125; // filter 먼저 실행    .map(Person::name).toList()\n\np227의 그림 5.9를 참고하자.\n\nfilter 보다 map을 호출할 경우 map은 모든 원소를 변환하므로 더 많은 이터레이션이 발생하게 된다.\n\n\n\n\n자바 스트림과 코틀린 시퀀스 비교\n\n자바 8의 스트림과 코틀린의 시퀀스는 개념적으로 같다. 다만, 자바 8일 경우 코틀린 컬렉션과 시퀀스에서 제공하지 않는 스트림 연산(map과 filter)을 여러 CPU에서 병렬적으로 실행하는 기능이 존재한다. 그렇기 때문에 자바 버전에 따라서 시퀀스와 스트림 중에 적절한 것을 사용하면 된다.\n자바 8에 대해서는 다른 개발자의 블로그의 글인 자바 8 스트림 이란? 을 참고하자.\n시퀀스 만들기\n1234567891011//                  첫번째 인자: 초기값 / 두번째 인자: 다음 값 생성 로직val numbers = generateSequence(0) &#123; it + 1 &#125; // 시퀀스 생성val numbersTo100 = numbers.takeWhile &#123; it &lt;= 100 &#125; // while loop 시퀀스 생성println(numbersTo100.sum()) // 위의 모든 시퀀스는 sum의 결과를 계산할 때 수행된다.// 결과: 5050// File의 확장함수 선언fun File.isInsideHiddenDirectory() = generateSequence(this) &#123; it.parentFile &#125;.any &#123; it.isHidden &#125;val file = File(\"/Users/svtk/.HiddenDir/a.txt\")println(file.isInsideHiddenDirectory())// 결과: true\n\ngenerateSequence: 이전의 원소를 인자로 받아 다음 원소를 계산하는 시퀀스를 만드는 함수\n최종 연산인 sum() 을 호출 하기 전에는 계산되지 않다가 최종 연산이 호출될 때에 계산이 수행된다.\n\n자바 함수형 인터페이스 활용\n함수형 인터페이스\n추상 메소드가 단 하나 있는 인터페이스를 함수형 인터페이스 또는 SAM(단일 추상 메소드, Single Abstract method) 인터페이스라고 한다.\n12345678910// java 8 이전 익명클래스로 표현button.setOnClickListener(new OnClickListener() &#123;    @Override    public void onClick(View v) &#123;        /* TODO */    &#125;&#125;)// java 8 이후 함수형 인터페이스를 람다로 표현button.setOnClickListener &#123;view -&gt; /* TODO */&#125;\n\n자바에서는 함수형 인터페이스 즉, SAM 인터페이스인 경우 자바 8버전 이후 람다를 이용하여 더 간결하게 표현할 수 있다. (코틀린도 너무나 당연하게 사용 가능하다.)\n\n자바 메소드에 람다를 인자로 전달\n12// java 함수형 인터페이스를 인자로 전달void postponeComputation(int delay, Runnable computation);\n123456789// 위의 자바 코드에 코틀린에서 람다를 전달하여 호출postponeComputation(1000) &#123; println(42) &#125; // 함수형 인터페이스에 람다를 전달// 객체 식을 전달postponeComputation(1000, object: Runnable &#123;    override fun run() &#123;        println(42)    &#125;&#125;)\n\n컴파일러는 자동으로 람다를 Runnable 인스턴스(Runnable을 구현한 익명 클래스 인스턴스)로 변환하여 전달한다.\nRunnable을 구현하는 무명 객체를 명시적으로 만들어서 사용하는 것도 가능하다.\n\n\n람다를 넘길 때와 무명 객체를 생성하여 넘길 때의 차이점?\n\n\n무명 객체를 생성하여 넘기는 경우, 메소드를 호출할 때마다 새로운 인스턴스가 생성된다.\n생성된 Runnable 인스턴스는 단 하나만 생성되며 메소드 호출 시 반복 사용된다.\n단, 람다 내에서 람다 외부의 변수를 포획하는 경우에는 무명 객체처럼 새로운 인스턴스가 생성된다.\n\n\nJava 8 언어 기능과 Jack을 활성화 방법\n\n\napp 단 build.gradle 내에 compileOptions 를 통해 지정해준다.\n\n\n코틀린 컴파일 시 자바 8 바이트 코드생성 방법\n\njvm-target 1.8 이라고 kotlinc 호출할 때 커맨드라인에서 옵션 설정을 지정\n메이븐이나 그래들 프로젝트 설정에 명시\n\nSAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경\n컴파일러가 자동으로 람다를 함수형 인터페이스 익명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용한다.\n1234567891011val listener = OnClickListener &#123; view -&gt;     val text = when (view.id) &#123;        R.id.button1 -&gt; \"First button\"        R.id.button2 -&gt; \"Second button\"        else -&gt; \"Unknown button\"    &#125;    toast(text)&#125;button1.setOnClickListener(listener)button2.setOnClickListener(listener)\n\n람다와 리스너 등록/해제\n\n\n람다는 코드 블럭이기 때문에 this 가 없다. 즉, 객체처럼 익명 클래스의 인스턴스를 참조할 수 없다.\n람다 내에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가르킨다. 주의하자.\n리스너를 가르키고 싶다면 람다가 아닌 무명 객체를 사용해야 한다.\n무명 객체 내에서 this는 객체 인스턴스 자신을 가르킨다.\n\n수신 객체 지정 람다: with와 apply\n자바의 람다에는 없는, 코틀린 람다만의 독특한 기능인 수신 객체 지정 람다는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다.\nwith 함수\nwith 함수는 파라미터가 2개인 메소드로 첫 번째 인자는 객체를 두 번째 인자는 람다를 받는다.\n\n첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.\n\n12345678910fun alphabet(): String &#123;    val sb = StringBuilder()    return with(sb) &#123;        for (letter in 'A'..'Z') &#123;            this.append(letter) // this를 통해 수신 객체에 접근        &#125;        append(\"\\nNow I know alphabet!\") // this 없이 수신 객체의 메소드 호출        this.toString() // 람다에서 값 반환    &#125;&#125;\n\n수신 객체 지정 람다는 확장 함수와 비슷한 동작을 정의하는 한 방법이다.\n&lt;T, R&gt; with(receiver: T, block: T.() ‐&gt; R): block 함수의 수신 객체는 T\n\napply 함수\napply 함수는 with 함수와 동일한 동작이지만 항상 자신에게 전달된 객체(수신 객체)를 반환한다.\n123456fun alphabet() = StringBuilder().apply &#123;    for (letter in 'A'..'Z') &#123;        append(letter)    &#125;    append(\"\\nNow I know the alphabet!\")&#125;.toString()\n\nfun &lt;T&gt; T.apply(block: T.() ‐&gt; Unit): T: apply 함수는 확장 함수로 정의되어 있다.\n객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화 해야 하는 경우 유용하다.\n\napply를 이용해 TextView 만들면서 초기화 하기\n123456fun createViewWithCustomAttributes(context: Context) =    TextView(context).apply &#123;        text = \"Sample Text\" // this 생략하여 TextView의 프로퍼티 사용        textSize = 20.0         setPadding(10, 0, 0, 0) // this 생략하여 TextView의 멤버 함수 사용    &#125;\nbuildString 함수\nbuildString 함수는 StringBuilder 객체를 만들어 toString()을 호출해주는 작업을 해준다.\n123456fun alphabet() = buidlString &#123;    for (letter in 'A'..'Z') &#123;        append(letter)    &#125;    append(\"\\nNow I know the alphabet!\")&#125;\n참고\n\nKotlin In Action\n탤로우 월드#Kotlin\n\n","dateCreated":"2020-04-02T15:27:53+09:00","dateModified":"2020-08-05T15:42:01+09:00","datePublished":"2020-04-02T15:27:53+09:00","description":"람다 식 | 람다\n기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.","headline":"[Kotlin in Action] Chap5. 람다","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"},"publisher":{"@type":"Organization","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg","logo":{"@type":"ImageObject","url":"Victory.jpeg"}},"url":"https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/","keywords":"Android, Kotlin, 코틀린, 프로그래밍 언어, Kotlin in Action"}</script>
    <meta name="description" content="람다 식 | 람다 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.">
<meta name="keywords" content="Android,Kotlin,코틀린,프로그래밍 언어,Kotlin in Action">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Kotlin in Action] Chap5. 람다">
<meta property="og:url" content="https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="람다 식 | 람다 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://woovictory.github.io/img/compileOptions.png">
<meta property="og:updated_time" content="2020-08-05T06:42:01.154Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Kotlin in Action] Chap5. 람다">
<meta name="twitter:description" content="람다 식 | 람다 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.">
<meta name="twitter:image" content="https://woovictory.github.io/img/compileOptions.png">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Kotlin in Action] Chap5. 람다
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-04-02T15:27:53+09:00">
	
		    Apr 02, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/Kotlin-in-Action/">Kotlin in Action</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h3 id="람다-식-람다">람다 식 | 람다</h3>
<p>기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.</p>
<a id="more"></a>
<h4 id="람다-식과-멤버-참조">람다 식과 멤버 참조</h4>
<p>람다는 자바 8에 도입되어 자바에서도 비로소 람다를 사용할 수 있게 되었다.</p>
<h5 id="람다-소개-코드-블록을-함수-인자로-넘기기">람다 소개: 코드 블록을 함수 인자로 넘기기</h5>
<p><strong>[자바에서 익명 클래스를 통해 버튼 클릭 리스너 구현]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 자바 */</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 클릭시 동작 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>[람다로 리스너 구현]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123; <span class="comment">/* 클릭시 동작 */</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>두 구현은 동일한 동작이지만 람다를 이용한 경우 코드가 훨씬 간결하고 읽기 쉬워진다.</li>
</ul>
<h5 id="람다와-컬렉션">람다와 컬렉션</h5>
<p><strong>[컬렉션에서 가장 큰 값 찾기: 직접 구현]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findTheOldest</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxAge = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> theOldest: Person? = <span class="literal">null</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (person <span class="keyword">in</span> people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.age &gt; maxAge) &#123;</span><br><span class="line">            maxAge = person.age</span><br><span class="line">            theOldest = person</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(theOldest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line">findTheOldest(people)</span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31)</span></span><br></pre></td></tr></table></figure>
<p><strong>[컬렉션에서 가장 큰 값 찾기: 람다 이용]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line">println(people.maxBy &#123; it.age &#125;) <span class="comment">// 나이 프로퍼티를 비교해서 가장 큰 원소 찾기</span></span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31)</span></span><br><span class="line"></span><br><span class="line">println(people.maxBy(Person::age)) <span class="comment">// 나이 프로퍼티를 비교해서 가장 큰 원소 찾기</span></span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31</span></span><br></pre></td></tr></table></figure>
<ul>
<li>자바 컬렉션에 대해 (자바 8 이전, 람다 지원 전) 수행하던 대부분의 불편했던 작업들은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선이 가능하다. 이렇게 개선된 후에는 코드가 한결 짧아지고 더 이해하기 쉬워졌다.</li>
</ul>
<h5 id="람다-식의-문법">람다 식의 문법</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="comment">//    파라미터     -&gt;   본문</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다는 <strong>값처럼</strong> 여기저기 전달할 수 있는 동작의 모음이다.
<ul>
<li>추가로 람다를 따로 선언해서 변수에 저장도 가능하다. 그렇다곤 해도 보통은 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// 람다식 변수에 저장</span></span><br><span class="line">println(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 변수에 저장된 람다식 호출</span></span><br><span class="line"><span class="comment">// 결과: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>심지어는 람다식을 직접 호출도 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; println(<span class="number">42</span>) &#125;()</span><br><span class="line"><span class="comment">//  결과: 42</span></span><br></pre></td></tr></table></figure>
<p>굳이 이렇게 쓰는 것보다는 가독성 때문에라도 람다 본문을 직접 실행하는 편이 낫다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자로 받은 람다를 실행해주는 라이브러리 함수인 run을 사용하여 람다 본문 실행</span></span><br><span class="line">run &#123; println(<span class="number">42</span>) &#125;</span><br><span class="line"><span class="comment">// 결과: 42</span></span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린 람다 식은 <strong>항상 중괄호</strong>로 둘러싸여있다.</li>
<li>인자 목록 주변에 괄호가 없다.</li>
<li>화살표(-&gt;)를 통해 인자 목록과 람다 본문을 구분한다.</li>
</ul>
<p><strong>람다식 사용 예제</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인자가 한 개고 타입 추론 가능하면 디폴트 이름인 it 사용 가능</span></span><br><span class="line">println(people.maxBy &#123; it. age &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">people.maxBy(&#123; p: Person -&gt; p.age&#125;)</span><br><span class="line"><span class="comment">// 람다가 마지막 인자면, 괄호 밖에 위치 가능</span></span><br><span class="line">people.maxBy() &#123; p: Person -&gt; p.age&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다가 마지막 인자고, 괄호 뒤에 람다를 썼을 경우 괄호 생략 가능</span></span><br><span class="line">people.maxBy &#123; p: Person -&gt; p.age&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>간단한 경우라면 괄호 없이 람다식만으로 명시해도 나쁘지 않을 것으로 생각되지만 웬만하면 괄호를 사용하여 해당 람다식이 메소드에 포함된 람다식이라는 것을 확실히 하는 것이 가독성에 더 좋을 것 같다.</p>
</blockquote>
<p><strong>이름 붙인 인자를 사용해 람다 넘기기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"이몽룡"</span>, <span class="number">29</span>), Person(<span class="string">"성춘향"</span>, <span class="number">31</span>))</span><br><span class="line"><span class="keyword">val</span> names = people.joinToString(seprator = <span class="string">" "</span>, transform = &#123; p: Person -&gt; p.name &#125;)</span><br><span class="line">println(names)</span><br><span class="line"><span class="comment">// 결과: 이몽룡 성춘향</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 괄호 밖으로 처리</span></span><br><span class="line"><span class="keyword">val</span> names = people.joinToString(<span class="string">" "</span>) &#123; p: Person -&gt; p.name&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>개인적인 생각이지만 이 예제를 보니 개인적인 프로젝트에서 특정 메소드에 대한 완벽한 이해가 있고 람다식을 사용하는 곳도 완벽한 이해가 있는 경우에는 람다식을 괄호 밖으로 빼서 표현하는 것이 코드도 간결하고 보기도 더 좋지만 <strong>협업을 하는 상황</strong>이라면 누구라도 코드를 이해하기 쉽도록 괄호를 사용하여 일반적인 메소드 호출을 이용하여 람다식을 표현하는 것이 더 좋을 것으로 생각된다.</p>
</blockquote>
<p><strong>람다 파라미터 타입 제거하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p: Person -&gt; p.age &#125; <span class="comment">// 파라미터 타입 명시</span></span><br><span class="line">people.maxBy &#123; p -&gt; p.age &#125; <span class="comment">// 파라미터 타입 생략 (컴파일러가 추론)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 람다식 담는 경우 컴파일러가 타입 추론 불가</span></span><br><span class="line"><span class="keyword">val</span> getAge = &#123; p: Person -&gt; p.age &#125;</span><br><span class="line">people.maxBy(getAge)</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 람다 파라미터의 타입도 <strong>추론</strong> 할 수 있다.</li>
<li>people은 Person을 담은 컬렉션이므로 컴파일러는 Person 객체가 파라미터로 들어올 것을 추론할 수 있다.
<ul>
<li><s>컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있으나 이번 장에서는 다루지 않는다.</s></li>
</ul>
</li>
<li>단, 람다식을 변수에 담는 경우 파라미터의 타입을 추론할 문맥이 존재하지 않으므로 파라미터를 명시해야만 한다.</li>
</ul>
<p><strong>디폴트 파라미터 이름 it 사용하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; it.age &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>it</code>는 자동 생성된 파라미터 이름이다.</li>
<li>람다의 파라미터가 <strong>하나</strong>뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 <code>it</code>를 사용할 수 있다.</li>
</ul>
<blockquote>
<p>람다 내에 람다가 중첩되는 경우나 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에는 파라미터를 명시적으로 선언하는 것이 가독성에 더 좋다.</p>
</blockquote>
<p><strong>본문이 여러줄로 이뤄진 람다식</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; </span><br><span class="line">    println(<span class="string">"Computing the sum of <span class="variable">$x</span> and <span class="variable">$y</span>..."</span>)</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>본문이 여러줄로 이루어진 경우 <strong>맨 마지막에 있는 식</strong>이 람다식의 결과값이 된다.</li>
</ul>
<h5 id="현재-영역에-있는-변수에-접근">현재 영역에 있는 변수에 접근</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMessageWithPrefix</span><span class="params">(messages: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;, prefix: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    messages.forEach &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$prefix</span> <span class="variable">$it</span>"</span>) <span class="comment">// 람다 내부에서 함수의 "prefix" 변수 사용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; val errors = listOf("403 Forbidden", "404 Not Found")</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; printMessagesWithPrefix(errors, "Error:")</span></span><br><span class="line"><span class="comment">// 결과: Error: 403 Forbidden</span></span><br><span class="line"><span class="comment">//      Error: 404 Not Found</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다를 함수 안에서 정의하면 함수의 파라미터에 접근이 가능하다.</li>
<li>뿐만 아니라 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProblemCounts</span><span class="params">(response: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clientErrors = <span class="number">0</span> <span class="comment">// 람다 외부에 로컬 변수 선언</span></span><br><span class="line">    <span class="keyword">var</span> serverErrors = <span class="number">0</span> <span class="comment">// 람다 외부에 로컬 변수 선언</span></span><br><span class="line">    </span><br><span class="line">    response.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.startsWith(<span class="string">"4"</span>)) &#123;</span><br><span class="line">            clientErrors++ <span class="comment">// 람다 내부에서 외부의 로컬 변수 값 변경</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.startsWith(<span class="string">"5"</span>)) &#123;</span><br><span class="line">            serverErrors++ <span class="comment">// 람다 내부에서 외부의 로컬 변수 값 변경</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"<span class="variable">$ClientErrors</span> client errors, <span class="variable">$serverErrors</span> server errors"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error"</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; printProblemCounts(responses)</span></span><br><span class="line"><span class="comment">// 결과: 1 client errors, 1 server errors</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다 내부에서는 <code>final</code> 변수가 아닌 변수에 접근이 가능하다.</li>
<li>람다 내부에서 람다 외부의 변수 변경도 가능하다.
<ul>
<li>람다 내부에서 사용하는 람다 외부 변수를 <code>람다가 포획한 변수</code>라고 부른다. (위 예제들의 prefix, clientErrors, serverErrors)</li>
</ul>
</li>
</ul>
<blockquote>
<p>람다를 실행 시점에 표현하는 데이터 구조는 람다에서 시작하는 모든 참조가 포함된 닫힌(closed) 객체 그래프를 람다 코드와 함께 저장해야 한다. 그런 데이터 구조를 <strong>클로저(closure)</strong> 라고 부른다. 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야 하고, 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다. 그래서 람다를 클로저라고 부르기도 한다.</p>
</blockquote>
<p>TODO 무슨 말인지 이해가 가지 않는다… 코틀린 스터디 팀원들에게 물어보고 내용을 추가하도록 하자…!</p>
<p><strong>로컬 변수의 생명주기와 함수의 생명주기가 다른 경우</strong></p>
<p>(예를 들면, 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장하는 경우가 있다.)</p>
<ul>
<li>포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.
<ul>
<li><code>final</code> 변수인 경우: 람다 코드를 변수 값과 함께 저장하여 함수가 끝난 뒤에도 포획한 변수에 접근이 가능하다.</li>
<li><code>final</code> 변수가 아닌 경우: 변수를 특별한 <strong>래퍼</strong>로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.</li>
<li>코틀린에서도 자바와 같이 약간의 꼼수(?)로 변경 가능한 변수를 포획하게 된다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실제 코드</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> inc = &#123; counter++ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 내부 동작을 보여주는 코드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ref</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> value: T)</span><br><span class="line"><span class="keyword">val</span> counter = Ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> inc = &#123; counter.value++ &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Ref</code> 라는 클래스로 래핑하여 해당 클래스를 <code>final</code> 하게 선언하고 그 내부에 멤버 변수에 counter 값을 저장한다.</li>
<li>그 이후 람다식에서는 클래스의 변수값에 접근하여 변경 가능한 변수를 포획한다.</li>
</ul>
<p><strong>람다를 이벤트 핸들러 등 비동기 실행 코드로 활용하는 경우</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryToCountButtonClicks</span><span class="params">(button: <span class="type">Button</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clicks = <span class="number">0</span></span><br><span class="line">    button.onClick &#123; clicks++ &#125;</span><br><span class="line">    <span class="keyword">return</span> clicks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다는 점을 인지해 유의하여 사용해야 한다.</li>
<li>위 예시 코드에서 해당 함수는 항상 0을 반환한다.
<ul>
<li>onCiick 핸들러는 버튼이 클릭될 때마다 clicks 변수를 증가시키지만 그 때에는 함수 호출이 종료된 이후이기 때문이다.</li>
<li>즉, 해당 clicks 변수를 확인할 수 있도록 <strong>클래스의 프로퍼티</strong>나 전역 프로퍼티 등의 위치로 빼서 나중에 해당 변수를 확인할 수 있도록 해야 한다.</li>
</ul>
</li>
</ul>
<h5 id="멤버-참조">멤버 참조</h5>
<p><strong>이미 선언된 함수를 값으로 사용해야 할 때 멤버 참조 <code>::</code> 를 사용하면 된다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모두 같은 동작</span></span><br><span class="line">people.maxBy(Person::age) <span class="comment">// 멤버 참조</span></span><br><span class="line">people.maxBy &#123; p -&gt; p.age &#125;</span><br><span class="line">people.maxBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">isAdult</span><span class="params">()</span></span> = age &gt;= <span class="number">21</span></span><br><span class="line"><span class="keyword">val</span> predicate = Person::isAdult <span class="comment">// 확잠 함수도 동일하게 멤버 참조를 사용할 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">salute</span><span class="params">()</span></span> = println(<span class="string">"Salute!"</span>)</span><br><span class="line">run(::salute) <span class="comment">// 최상위 함수 참조</span></span><br><span class="line"><span class="comment">// 결과: Salute!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendEmail 함수에게 작업 위임</span></span><br><span class="line"><span class="keyword">val</span> action = &#123; person: Person, message: String -&gt; sendEmail(person, message) &#125;</span><br><span class="line"><span class="comment">// 람다 대신 멤버 참조 사용</span></span><br><span class="line"><span class="keyword">val</span> nextAction = ::sendEmail</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 참조</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">val</span> createPerson = ::Person <span class="comment">// 생성자 참조 저장</span></span><br><span class="line"><span class="keyword">val</span> p = createPerson(<span class="string">"Alice"</span>, <span class="number">29</span>) <span class="comment">// 생성자 참조를 이용해 인스턴스 생성</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>멤버 참조</strong>는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.</li>
<li><code>::</code> 는 클래스 이름과 참조하려는 멤버(프로퍼티나 메소드) 이름 사이에 위치한다.</li>
<li><strong>멤버 참조</strong> 뒤에는 괄호를 넣으면 안된다. (메소드여도!!)</li>
<li><strong>멤버 참조</strong>는 그 멤버를 호출하는 람다와 같은 타입이다.</li>
<li>최상위 함수, 최상위 프로퍼티 참조도 가능하다.
<ul>
<li>클래스 이름을 생략하고 <code>::</code> 로 참조를 바로 시작하면 된다.</li>
</ul>
</li>
<li><strong>생성자 참조</strong>를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.
<ul>
<li><code>::</code> 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.</li>
</ul>
</li>
</ul>
<p><strong>바운드 멤버 참조 (1.1부터 사용 가능)</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.0 멤버 참조</span></span><br><span class="line"><span class="keyword">val</span> p = Person(<span class="string">"Dmistry"</span>, <span class="number">34</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunction = Person::age</span><br><span class="line">println(personAgeFunction(p))</span><br><span class="line"><span class="comment">// 결과: 34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 바운드 멤버 참조</span></span><br><span class="line"><span class="keyword">val</span> p = Person(<span class="string">"Dmistry"</span>, <span class="number">34</span>)</span><br><span class="line"><span class="keyword">val</span> ageFunction = p::age <span class="comment">// p에 엮인 멤버 참조</span></span><br><span class="line">println(ageFunction())</span><br><span class="line"><span class="comment">// 결과: 34</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>TODO 바운드 멤버 참조는 한 인스턴스에 대해서만 동작이 될 것으로 생각이 드는데 이걸 사용할만한 곳이 있을까? 하는 의문이 든다.</p>
</blockquote>
<h4 id="컬렉션-함수형-api">컬렉션 함수형 API</h4>
<h5 id="필수적인-함수-filter와-map">필수적인 함수: filter와 map</h5>
<p><strong>filter 함수</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;) <span class="comment">// 짝수만 filtering</span></span><br><span class="line"><span class="comment">// 결과: [2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> personList = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterList = personList.filter &#123; it.age &gt; <span class="number">30</span> &#125;</span><br><span class="line">println(filterList)</span><br><span class="line"><span class="comment">// 결과: [Person(name=Bob, age=31)]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 <strong>true</strong>인 원소를 모은다.</li>
<li>만족하는 원소들을 모아 <strong>새로운 컬렉션</strong>으로 반환한다.</li>
</ul>
<p><strong>map 함수</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(list.map &#123; it * it &#125;) <span class="comment">// 자기자신을 곱함</span></span><br><span class="line"><span class="comment">// 결과: [1, 4, 9, 16]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> personList = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> mapList = personList.map &#123; it.age &#125; <span class="comment">// 나이만으로 컬렉션을 만듦</span></span><br><span class="line">println(mapList)</span><br><span class="line"><span class="comment">// 결과: [31, 29]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 멤버 참조 사용</span></span><br><span class="line"><span class="keyword">val</span> memberRefMapList = personList.map(Person::name)</span><br><span class="line">println(memberRefMapList)</span><br><span class="line"><span class="comment">// 결과: [Bob, Alice]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>주어진 람다를 컬렉션의 각 원소에 <strong>적용한 결과</strong>를 모아서 <strong>새 컬렉션</strong>을 만든다.</li>
</ul>
<p><strong>filter + map 조합</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterAndMap = list.filter &#123; it.age &gt; <span class="number">30</span> &#125;.map &#123; it.name &#125;</span><br><span class="line"><span class="comment">// 결과: [Bob]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>연쇄로 호출하여 사용도 가능하다.</li>
</ul>
<p><strong>maxBy + filter 조합</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterAndMaxBy = list.filter &#123; it.age == list.maxBy(Person::age)!!.age&#125;</span><br><span class="line"><span class="comment">// 결과: [Person(name=Bob, age=31)]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드의 단점은 filter가 이터레이션하기 때문에 maxby 함수가 컬렉션 수 만큼 호출되며 처리된다는 것이다.</li>
<li>개선해보면…</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> maxAge = list.maxBy(Person::age)!!.age</span><br><span class="line"><span class="keyword">val</span> filterAndMaxBy = list.filter &#123; it.age == maxAge &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이터레이션 된다는 것을 항상 기억하고 불필요한 작업을 반복하지 않도록 유의해야 한다.</li>
</ul>
<p><strong>컬렉션 맵에서의 filter, map</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mapOf(<span class="number">0</span> to <span class="string">"zero"</span>, <span class="number">1</span> to <span class="string">"one"</span>, <span class="number">2</span> to <span class="string">"two"</span>, <span class="number">3</span> to <span class="string">"three"</span>, <span class="number">4</span> to <span class="string">"four"</span>)</span><br><span class="line"><span class="keyword">val</span> filterValuesMap = numbers.filterValues &#123; it == <span class="string">"zero"</span>&#125;</span><br><span class="line"><span class="keyword">val</span> mapValuesMap = numbers.mapValues &#123; it.value.toUpperCase() &#125;</span><br><span class="line">println(filterValuesMap)</span><br><span class="line">println(mapValuesMap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filterKeysMap = numbers.filterKeys &#123; it == <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">val</span> mapKeysMap = numbers.mapKeys &#123; it.key % <span class="number">2</span> &#125;</span><br><span class="line">println(filterKeysMap)</span><br><span class="line">println(mapKeysMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: filterValuesMap = &#123;0=zero&#125;</span></span><br><span class="line"><span class="comment">//      mapValuesMap = &#123;0=ZERO, 1=ONE, 2=TWO, 3=THREE, 4=FOUR&#125;</span></span><br><span class="line"><span class="comment">//      filterKeysMap = &#123;1=one&#125;</span></span><br><span class="line"><span class="comment">//      mapKeysMap = &#123;0=four, 1=three&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>맵에서의 filter와 map은 별도의 API가 존재한다.</li>
<li>맵의 <code>filterValues</code>, <code>filterKeys</code> 의 <code>it</code> 는 각각 value와 key를 가르킨다.</li>
</ul>
<h5 id="컬렉션에-술어-사용-all-any-count-find">컬렉션에 술어 사용: all, any, count, find</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 술어 선언</span></span><br><span class="line"><span class="keyword">val</span> canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= <span class="number">27</span> &#125;</span><br><span class="line">println(<span class="string">"all: <span class="subst">$&#123;list.all(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"any: <span class="subst">$&#123;list.any(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"count: <span class="subst">$&#123;list.count(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"find: <span class="subst">$&#123;list.find(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: all: false</span></span><br><span class="line"><span class="comment">//      any: true</span></span><br><span class="line"><span class="comment">//      count: 3</span></span><br><span class="line"><span class="comment">//      find: Person(name=Alice, age=27)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>all</code>: 컬렉션의 모든 원소가 조건을 만족하는지 판단</li>
<li><code>any</code>: 컬렉션의 모든 원소 중 하나라도 조건을 만족하는지 판단</li>
<li><code>count</code>: 조건을 만족하는 원소의 갯수를 반환</li>
<li><code>find</code>: 조건을 만족하는 첫 번째 원소를 반환, 만족하는 원소가 없을 경우 <strong>null</strong>을 반환</li>
</ul>
<blockquote>
<p>함수형 API 사용시 고려할 점</p>
</blockquote>
<ul>
<li>함수형 API <code>count</code> 와 컬렉션에 포함된 함수 <code>size()</code> 의 차이?</li>
<li><code>count</code>의 경우 조건을 만족하는 원소의 개수만 추적할 뿐 원소를 따로 저장하지 않는다.</li>
<li><code>size()</code>의 경우 만족하는 원소를 가진 객체를 생성 시키게 된다.</li>
<li>위 예제 코드의 결과에서 보듯이 all과 any는 서로 부정으로 대응한다. 하지만 가독성을 이유로 <code>any</code> 대신 <code>!all</code> 이나 <code>all</code> 대신 <code>!any</code>는 사용하지 않는 것이 좋다.</li>
</ul>
<h5 id="groupby">groupBy</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line">println(<span class="string">"groupBy: <span class="subst">$&#123;list.groupBy &#123; it.age &#125;</span>&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: groupBy: &#123;27=[Person(name=Alice, age=27), Person(name=WooVictory, age=27)], </span></span><br><span class="line"><span class="comment">//              25=[Person(name=hzoou, age=25)], </span></span><br><span class="line"><span class="comment">//              28=[Person(name=txxbro, age=28), Person(name=iyj, age=28)]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strs = listOf(<span class="string">"12"</span>, <span class="string">"345"</span>, <span class="string">"11"</span>, <span class="string">"456"</span>)</span><br><span class="line">println(strs.groupBy &#123; it.length &#125;)</span><br><span class="line"><span class="comment">// 결과: &#123;2=[12, 11], 3=[345, 456]&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>groupBy: 리스트를 특정 기준에 맞춰 맵으로 변경하여 반환</li>
</ul>
<h5 id="flatmap과-flatten-중첩된-컬렉션-안의-원소-처리">flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"abc"</span>, <span class="string">"def"</span>)</span><br><span class="line">println(strings.flatMap &#123; it.toList() &#125;)</span><br><span class="line"><span class="comment">//결과: [a, b, c, d, e, f]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> authors: List&lt;String&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> books = listOf(Book(<span class="string">"책1"</span>, listOf(<span class="string">"작가1"</span>)),</span><br><span class="line">                 Book(<span class="string">"책2"</span>, listOf(<span class="string">"작가2"</span>, <span class="string">"작가3"</span>)), </span><br><span class="line">                 Book(<span class="string">"책3"</span>, listOf(<span class="string">"작가4"</span>, <span class="string">"작가1"</span>)))</span><br><span class="line"></span><br><span class="line">println(<span class="string">"toSet(): <span class="subst">$&#123;books.flatMap &#123; it.authors &#125;</span>.toSet()&#125;"</span>)</span><br><span class="line">println(<span class="string">"기본: <span class="subst">$&#123;books.flatMap &#123; it.authors &#125;</span>&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: toSet(): [작가1, 작가2, 작가3, 작가4]</span></span><br><span class="line"><span class="comment">//      기본: [작가1, 작가2, 작가3, 작가4, 작가1]</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"flatten(): <span class="subst">$&#123;books.map &#123; it.authors &#125;</span>.flatten()&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: flatten(): [작가1, 작가2, 작가3, 작가4, 작가1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>flatMap</code>: 인자로 주어진 람다를 컬렉션의 모든 객체에 적용(매핑)하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 모은다(flatten). <strong>즉, 리스트의 리스트가 있을 때 중첩된 리스트의 원소를 한 리스트로 모을 때 사용한다.</strong></li>
<li><code>toSet()</code>: 컬렉션의 중복을 제거리</li>
<li><code>flatten()</code>: 변환할 내용 없이 펼치기만 하는 경우 사용</li>
</ul>
<blockquote>
<p>책에서 다루지 않은 이외에도 많은 컬렉션 API가 존재한다.<br>
이외의 API 는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" target="_blank" rel="noopener">Kotlin Collection Reference</a> 를 참고하자.</p>
</blockquote>
<h5 id="지연-계산lazy-컬렉션-연산">지연 계산(lazy) 컬렉션 연산</h5>
<p>콜렉션의 연산자(e.g. map, filter)는 결과 컬렉션을 <strong>즉시</strong> 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.</p>
<p><code>시퀀스(sequence)</code>를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poeple.map(Person::name).filter &#123; it.startsWith(<span class="string">"A"</span>) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>map</code>과 <code>filter</code>는 둘 다 리스트를 반환한다. 즉 위 코드에서 연쇄 호출로 인해 리스트를 2개 만들어졌다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence() <span class="comment">// 원본 컬렉션을 시퀀스로 변환</span></span><br><span class="line">    .map(Person::name).filter &#123; it.startsWith(<span class="string">"A"</span>)&#125;</span><br><span class="line">    .toList() <span class="comment">// 결과 시퀀스를 다시 리스트로 변환</span></span><br></pre></td></tr></table></figure>
<ul>
<li>시퀀스의 원소는 필요할 때 비로소 계산되기 때문에 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해 효율적으로 계산을 수행할 수 있다.</li>
<li><code>asSequence()</code>: 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.</li>
<li><code>toList()</code>: 시퀀스를 리슷트로 바꿀 때 사용한다.</li>
</ul>
<blockquote>
<p>리스트 대신에 시퀀스를 쓰는 것이 더 낫지 않은가?</p>
</blockquote>
<ul>
<li>“항상 그렇지는 않다.”</li>
<li>인덱스를 사용해 접근하는 등 다른 API 메소드를 사용하기 위해서는 리스트로 변환해야 한다.</li>
</ul>
<h5 id="시퀀스-연산-실행-중간-연산과-최종-연산">시퀀스 연산 실행: 중간 연산과 최종 연산</h5>
<p>중간 연산과 최종 연산은 p225의 그림 5.7을 참고하자.</p>
<ul>
<li>중간 연산: 다른 시퀀스를 반환하며 최초 시퀀스의 원소를 변환하는 방법을 알고 있다.
<ul>
<li><strong>항상 지연 계산된다.</strong> 즉, 최종 연산을 하지 않으면 계속 지연이 되어 결과를 반환하지 않는다.</li>
</ul>
</li>
<li>최종 연산: 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자, 객체이다.</li>
</ul>
<p><strong>즉시 계산의 수행 순서와 지연 계산의 수행 순서</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eagerly</span></span><br><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).map &#123; println(<span class="string">"eagerly map(<span class="variable">$it</span>)"</span>); it * it &#125;</span><br><span class="line">                .filter &#123; println(<span class="string">"eagerly filter(<span class="variable">$it</span>)"</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// 결과: eagerly map(1)</span></span><br><span class="line"><span class="comment">//      eagerly map(2)</span></span><br><span class="line"><span class="comment">//      eagerly map(3)</span></span><br><span class="line"><span class="comment">//      eagerly map(4)</span></span><br><span class="line"><span class="comment">//      eagerly filter(1)</span></span><br><span class="line"><span class="comment">//      eagerly filter(4)</span></span><br><span class="line"><span class="comment">//      eagerly filter(9)</span></span><br><span class="line"><span class="comment">//      eagerly filter(16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy</span></span><br><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asSequence()</span><br><span class="line">                .map &#123; println(<span class="string">"lazy map(<span class="variable">$it</span>)"</span>); it * it&#125;</span><br><span class="line">                .filter &#123; println(<span class="string">"lazy filter(<span class="variable">$it</span>)"</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">                .toList()</span><br><span class="line"><span class="comment">//결과: lazy map(1)</span></span><br><span class="line"><span class="comment">//     lazy filter(1)</span></span><br><span class="line"><span class="comment">//     lazy map(2)</span></span><br><span class="line"><span class="comment">//     lazy filter(4)</span></span><br><span class="line"><span class="comment">//     lazy map(3)</span></span><br><span class="line"><span class="comment">//     lazy filter(9)</span></span><br><span class="line"><span class="comment">//     lazy map(4)</span></span><br><span class="line"><span class="comment">//     lazy filter(16)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>즉시 계산의 경우 <strong>모든 원소</strong>에 대해 먼저 map을 끝낸 후 이후 filter를 수행하게 된다.</li>
<li>시퀀스(지연 계산)의 경우 <strong>각 원소</strong>에 대해 순차적으로 적용이 된다.</li>
<li>p226의 그림 5.8을 참고하자.</li>
</ul>
<p><strong>map과 filter 호출 순서에 따른 성능 차이의 발생</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line">list.asSequence().map(Person::name) <span class="comment">// map 먼저 실행</span></span><br><span class="line">    .filter &#123; it.length &lt; <span class="number">4</span> &#125;.toList()</span><br><span class="line"></span><br><span class="line">list.asSequence().filter &#123; it.length &lt; <span class="number">4</span> &#125; <span class="comment">// filter 먼저 실행</span></span><br><span class="line">    .map(Person::name).toList()</span><br></pre></td></tr></table></figure>
<ul>
<li>p227의 그림 5.9를 참고하자.
<ul>
<li>filter 보다 map을 호출할 경우 map은 모든 원소를 변환하므로 더 많은 이터레이션이 발생하게 된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>자바 스트림과 코틀린 시퀀스 비교</strong></p>
</blockquote>
<p>자바 8의 스트림과 코틀린의 시퀀스는 개념적으로 같다. 다만, 자바 8일 경우 코틀린 컬렉션과 시퀀스에서 제공하지 않는 <strong>스트림 연산(map과 filter)을 여러 CPU에서 병렬적으로 실행하는 기능</strong>이 존재한다. 그렇기 때문에 자바 버전에 따라서 시퀀스와 스트림 중에 적절한 것을 사용하면 된다.<br>
자바 8에 대해서는 다른 개발자의 블로그의 글인 <a href="https://12bme.tistory.com/461" target="_blank" rel="noopener">자바 8 스트림 이란?</a> 을 참고하자.</p>
<h5 id="시퀀스-만들기">시퀀스 만들기</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                  첫번째 인자: 초기값 / 두번째 인자: 다음 값 생성 로직</span></span><br><span class="line"><span class="keyword">val</span> numbers = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125; <span class="comment">// 시퀀스 생성</span></span><br><span class="line"><span class="keyword">val</span> numbersTo100 = numbers.takeWhile &#123; it &lt;= <span class="number">100</span> &#125; <span class="comment">// while loop 시퀀스 생성</span></span><br><span class="line">println(numbersTo100.sum()) <span class="comment">// 위의 모든 시퀀스는 sum의 결과를 계산할 때 수행된다.</span></span><br><span class="line"><span class="comment">// 결과: 5050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File의 확장함수 선언</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">isInsideHiddenDirectory</span><span class="params">()</span></span> = generateSequence(<span class="keyword">this</span>) &#123; it.parentFile &#125;.any &#123; it.isHidden &#125;</span><br><span class="line"><span class="keyword">val</span> file = File(<span class="string">"/Users/svtk/.HiddenDir/a.txt"</span>)</span><br><span class="line">println(file.isInsideHiddenDirectory())</span><br><span class="line"><span class="comment">// 결과: true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>generateSequence</code>: 이전의 원소를 인자로 받아 다음 원소를 계산하는 시퀀스를 만드는 함수</li>
<li>최종 연산인 <code>sum()</code> 을 호출 하기 전에는 계산되지 않다가 최종 연산이 호출될 때에 계산이 수행된다.</li>
</ul>
<h4 id="자바-함수형-인터페이스-활용">자바 함수형 인터페이스 활용</h4>
<h5 id="함수형-인터페이스">함수형 인터페이스</h5>
<p>추상 메소드가 단 하나 있는 인터페이스를 <strong>함수형 인터페이스</strong> 또는 <strong>SAM(단일 추상 메소드, Single Abstract method) 인터페이스</strong>라고 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 8 이전 익명클래스로 표현</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* TODO */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 8 이후 함수형 인터페이스를 람다로 표현</span></span><br><span class="line">button.setOnClickListener &#123;view -&gt; <span class="comment">/* TODO */</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바에서는 함수형 인터페이스 즉, SAM 인터페이스인 경우 자바 8버전 이후 람다를 이용하여 더 간결하게 표현할 수 있다. (코틀린도 너무나 당연하게 사용 가능하다.)</li>
</ul>
<h5 id="자바-메소드에-람다를-인자로-전달">자바 메소드에 람다를 인자로 전달</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 함수형 인터페이스를 인자로 전달</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postponeComputation</span><span class="params">(<span class="keyword">int</span> delay, Runnable computation)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 위의 자바 코드에 코틀린에서 람다를 전달하여 호출</span></span><br><span class="line">postponeComputation(<span class="number">1000</span>) &#123; println(<span class="number">42</span>) &#125; <span class="comment">// 함수형 인터페이스에 람다를 전달</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 식을 전달</span></span><br><span class="line">postponeComputation(<span class="number">1000</span>, <span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 자동으로 람다를 Runnable 인스턴스(Runnable을 구현한 익명 클래스 인스턴스)로 변환하여 전달한다.</li>
<li>Runnable을 구현하는 무명 객체를 명시적으로 만들어서 사용하는 것도 가능하다.</li>
</ul>
<blockquote>
<p>람다를 넘길 때와 무명 객체를 생성하여 넘길 때의 차이점?</p>
</blockquote>
<ul>
<li>무명 객체를 생성하여 넘기는 경우, 메소드를 호출할 때마다 새로운 인스턴스가 생성된다.</li>
<li>생성된 Runnable 인스턴스는 단 하나만 생성되며 메소드 호출 시 반복 사용된다.</li>
<li>단, 람다 내에서 람다 외부의 변수를 포획하는 경우에는 무명 객체처럼 새로운 인스턴스가 생성된다.</li>
</ul>
<blockquote>
<p>Java 8 언어 기능과 Jack을 활성화 방법</p>
</blockquote>
<ul>
<li>app 단 build.gradle 내에 <strong>compileOptions</strong> 를 통해 지정해준다.<br>
<img src="/img/compileOptions.png" width="500" height="200"></li>
</ul>
<p>코틀린 컴파일 시 자바 8 바이트 코드생성 방법</p>
<ul>
<li>jvm-target 1.8 이라고 kotlinc 호출할 때 커맨드라인에서 옵션 설정을 지정</li>
<li>메이븐이나 그래들 프로젝트 설정에 명시</li>
</ul>
<h5 id="sam-생성자-람다를-함수형-인터페이스로-명시적으로-변경">SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경</h5>
<p>컴파일러가 자동으로 람다를 함수형 인터페이스 익명 클래스로 바꾸지 못하는 경우 <code>SAM 생성자</code>를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = OnClickListener &#123; view -&gt; </span><br><span class="line">    <span class="keyword">val</span> text = <span class="keyword">when</span> (view.id) &#123;</span><br><span class="line">        R.id.button1 -&gt; <span class="string">"First button"</span></span><br><span class="line">        R.id.button2 -&gt; <span class="string">"Second button"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">"Unknown button"</span></span><br><span class="line">    &#125;</span><br><span class="line">    toast(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button1.setOnClickListener(listener)</span><br><span class="line">button2.setOnClickListener(listener)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>람다와 리스너 등록/해제</p>
</blockquote>
<ul>
<li>람다는 코드 블럭이기 때문에 <code>this</code> 가 없다. 즉, 객체처럼 익명 클래스의 인스턴스를 참조할 수 없다.</li>
<li>람다 내에서 <code>this</code>는 그 람다를 둘러싼 클래스의 인스턴스를 가르킨다. 주의하자.</li>
<li>리스너를 가르키고 싶다면 람다가 아닌 <strong>무명 객체</strong>를 사용해야 한다.</li>
<li>무명 객체 내에서 <code>this</code>는 객체 인스턴스 자신을 가르킨다.</li>
</ul>
<h4 id="수신-객체-지정-람다-with와-apply">수신 객체 지정 람다: with와 apply</h4>
<p>자바의 람다에는 없는, 코틀린 람다만의 독특한 기능인 <code>수신 객체 지정 람다</code>는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다.</p>
<h5 id="with-함수">with 함수</h5>
<p><code>with</code> 함수는 파라미터가 2개인 메소드로 첫 번째 인자는 객체를 두 번째 인자는 람다를 받는다.</p>
<ul>
<li>첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(sb) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter) <span class="comment">// this를 통해 수신 객체에 접근</span></span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nNow I know alphabet!"</span>) <span class="comment">// this 없이 수신 객체의 메소드 호출</span></span><br><span class="line">        <span class="keyword">this</span>.toString() <span class="comment">// 람다에서 값 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>수신 객체 지정 람다는 확장 함수와 비슷한 동작을 정의하는 한 방법이다.</li>
<li><code>&lt;T, R&gt; with(receiver: T, block: T.() ‐&gt; R)</code>: block 함수의 수신 객체는 T</li>
</ul>
<h5 id="apply-함수">apply 함수</h5>
<p><code>apply</code> 함수는 <code>with</code> 함수와 동일한 동작이지만 항상 자신에게 전달된 객체(수신 객체)를 반환한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = StringBuilder().apply &#123;</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nNow I know the alphabet!"</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fun &lt;T&gt; T.apply(block: T.() ‐&gt; Unit): T</code>: apply 함수는 확장 함수로 정의되어 있다.</li>
<li>객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화 해야 하는 경우 유용하다.</li>
</ul>
<p><strong>apply를 이용해 TextView 만들면서 초기화 하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createViewWithCustomAttributes</span><span class="params">(context: <span class="type">Context</span>)</span></span> =</span><br><span class="line">    TextView(context).apply &#123;</span><br><span class="line">        text = <span class="string">"Sample Text"</span> <span class="comment">// this 생략하여 TextView의 프로퍼티 사용</span></span><br><span class="line">        textSize = <span class="number">20.0</span> </span><br><span class="line">        setPadding(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// this 생략하여 TextView의 멤버 함수 사용</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="buildstring-함수">buildString 함수</h5>
<p><code>buildString</code> 함수는 StringBuilder 객체를 만들어 toString()을 호출해주는 작업을 해준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = buidlString &#123;</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nNow I know the alphabet!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li><a href="https://taehyungk.github.io/tag/#Kotlin" target="_blank" rel="noopener">탤로우 월드#Kotlin</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Android/">Android</a> <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin/">Kotlin</a> <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin-in-Action/">Kotlin in Action</a> <a class="tag tag--primary tag--small t-link" href="/tags/코틀린/">코틀린</a> <a class="tag tag--primary tag--small t-link" href="/tags/프로그래밍-언어/">프로그래밍 언어</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/02/KotlinInAction-Chap6/"
                    data-tooltip="[Kotlin in Action] Chap6. 코틀린 타입 시스템"
                    aria-label="PREVIOUS: [Kotlin in Action] Chap6. 코틀린 타입 시스템"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/01/KotlinInAction-Chap4/"
                    data-tooltip="[Kotlin in action] Chap4. 클래스와 인터페이스"
                    aria-label="NEXT: [Kotlin in action] Chap4. 클래스와 인터페이스"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/02/KotlinInAction-Chap6/"
                    data-tooltip="[Kotlin in Action] Chap6. 코틀린 타입 시스템"
                    aria-label="PREVIOUS: [Kotlin in Action] Chap6. 코틀린 타입 시스템"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/01/KotlinInAction-Chap4/"
                    data-tooltip="[Kotlin in action] Chap4. 클래스와 인터페이스"
                    aria-label="NEXT: [Kotlin in action] Chap4. 클래스와 인터페이스"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    
        <script>
          var disqus_config = function() {
            this.page.url = 'https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/';
              
            this.page.identifier = '2020/04/02/KotlinInAction-Chap5/';
              
          };
          (function() {
            var d = document, s = d.createElement('script');
            var disqus_shortname = 'https-woovictory-github-io';
            s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
    




    </body>
</html>
