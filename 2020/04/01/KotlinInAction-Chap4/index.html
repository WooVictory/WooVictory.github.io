<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>[Kotlin in action] Chap4. 클래스와 인터페이스 | VictoryWoo</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="Android,Kotlin,코틀린,프로그래밍 언어,Kotlin in Action" />
    
    <meta name="description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용  4.1.1 코틀린 인터페이스  인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.  12345678910interface Clickable&amp;#123;  fun onClick()">
<meta name="keywords" content="Android,Kotlin,코틀린,프로그래밍 언어,Kotlin in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="[Kotlin in action] Chap4. 클래스와 인터페이스">
<meta property="og:url" content="https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용  4.1.1 코틀린 인터페이스  인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.  12345678910interface Clickable&amp;#123;  fun onClick()">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-05-12T15:17:07.923Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Kotlin in action] Chap4. 클래스와 인터페이스">
<meta name="twitter:description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용  4.1.1 코틀린 인터페이스  인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.  12345678910interface Clickable&amp;#123;  fun onClick()">
    

    

    
        <link rel="icon" href="/css/images/victorywoo.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" type="text/css" href="">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theeluwin/NotoSansKR-Hestia@master/stylesheets/NotoSansKR-Hestia.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css">
    
    
    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125410253-1', 'auto');
ga('send', 'pageview');

</script>
    
    


</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">VictoryWoo&#39;s Blog</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Kotlin/">Kotlin</a>
    </h1>
</div>

                        <div class="main-body-content">
                            
                            <article id="post-KotlinInAction-Chap4" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        [Kotlin in action] Chap4. 클래스와 인터페이스
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2020/04/01/KotlinInAction-Chap4/" class="article-date">
            <time datetime="2020-04-01T11:26:32.000Z" itemprop="datePublished">2020-04-01</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>, <a class="tag-link" href="/tags/Kotlin/">Kotlin</a>, <a class="tag-link" href="/tags/Kotlin-in-Action/">Kotlin in Action</a>, <a class="tag-link" href="/tags/코틀린/">코틀린</a>, <a class="tag-link" href="/tags/프로그래밍-언어/">프로그래밍 언어</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="목차">목차</h2>
<ul>
<li>클래스와 인터페이스</li>
<li>뻔하지 않은 생성자와 프로퍼티</li>
<li>데이터 클래스</li>
<li>클래스 위임</li>
<li>object 키워드 사용</li>
</ul>
<h3 id="411-코틀린-인터페이스">4.1.1 코틀린 인터페이스</h3>
<ul>
<li>인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"Show~"</span>) <span class="comment">// 디폴트 구현. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">Clickable &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = println(<span class="string">"Hi~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button().onClick()</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 이름 뒤에 콜론(:)을 붙여 인터페이스와 클래스 이름을 적는 것으로 상속과 인터페이스 구현을 모두 처리한다.
<ul>
<li>자바 : extends, implements</li>
</ul>
</li>
<li>자바와 마찬가지로 다중 구현은 허용되지만, 다중 상속은 불가능하다.</li>
<li>@Override 어노테이션과 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 한다는 뜻이다. 다만, override 변경자는 코틀린에서 꼭 표시해야 한다.</li>
<li>디폴트 구현을 제공할 수 있으며, 특별한 키워드를 붙이지 않고 메소드 본문을 적어주면 된다.
<ul>
<li>이 경우, Clickable을 구현하는 하위 클래스에서 showOff를 새롭게 정의할 수도 있고, 정의를 생략해서 디폴트 구현을 사용할 수도 있다.</li>
</ul>
</li>
<li>아래 코드를 함께 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setFocus</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm Focus"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이제 한 클래스에서 Clickable, Focusable  두 인터페이스를 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현이 들어있다.</li>
<li>결론은 어느 쪽의 showOff() 메소드도 호출되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 아래와 같은 컴파일 오류가 발생한다.</li>
</ul>
<blockquote>
<p>The class ‘Button’ must override public open fun showOff()</p>
<p>because it inherits many implementations of it.</p>
</blockquote>
<ul>
<li>코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 강제한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable</span>, <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br><span class="line">    <span class="keyword">super</span>&lt;Focusable&gt;.showOff()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>즉, 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 존재하는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다.</li>
<li>자바와 달리 상위 타입의 이름을 꺽쇠 괄호(&lt;&gt;) 사이에 넣어서 super를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.</li>
</ul>
<h3 id="412-open-final-abstract-변경자">4.1.2 open, final, abstract 변경자</h3>
<ul>
<li>자바에서는 기본적으로 상위 클래스에 대해 하위 클래스에서 상속하는 걸 막지 않는다. 막기 위해서는 final을 붙여 상속을 할 수 없게 한다.</li>
<li>기본적으로 상속이 가능하면 편리하지만, 문제가 생기는 경우도 있다.</li>
<li><code>취약한 기반 클래스</code> 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 존재한다.</li>
<li>즉, 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 <strong>취약</strong>하다.</li>
<li>이런 점을 보완하기 위해 코틀린에서는 클래스와 메소드는 기본적으로 <strong>final</strong>이다.</li>
<li>클래스의 상속을 허용하려면 클래스 앞에 <strong>open</strong> 변경자를 붙여야 한다.</li>
<li>오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 붙일 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RichButton</span> : <span class="type">Clickable&#123;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> </span><br><span class="line">  <span class="comment">// 오버라이드한 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 막을 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RichButton 클래스는 다른 클래스가 상속할 수 있다.(open)</li>
<li>disable() : final이며, 오버라이드 할 수 없다.</li>
<li>animate() : oepn으로 오버라이드 가능.</li>
<li>onClick() : 상위 클래스에서 선언된 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.</li>
</ul>
<ul>
<li>abstract로 선언한 추상 클래스는 인스턴스화 할 수 없으며, 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야 하는게 보통이다.</li>
<li>추상 멤버는 항상 열려 있기 때문에 open 변경자를 명시할 필요가 없다.</li>
</ul>
<p>Todo 표 추가</p>
<h3 id="413-가시성-변경자">4.1.3 가시성 변경자</h3>
<ul>
<li>코틀린의 기본 가시성은 자바와 다르며, 아무 변경자도 없는 경우 public이다.</li>
<li>자바의 기본 가시성인 package private이 없다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.</li>
<li>코틀린은 <code>internal</code>이라는 새로운 가시성을 도입했다.
<ul>
<li>이는 모듈 내부에서만 볼 수 있음을 뜻한다.</li>
<li>모듈 : 한 번에 한꺼번에 컴파일되는 파일들을 의미한다.</li>
<li>모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.</li>
</ul>
</li>
<li>코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다.</li>
</ul>
<blockquote>
<p>? 모듈에 대해 생각해볼 필요가 있어 보인다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>변경자</th>
<th>클래스멤버</th>
<th>최상위 선언</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>모든 곳에서 볼 수 있다.</td>
<td>모든 곳에서 볼 수 있다.</td>
</tr>
<tr>
<td>internal</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
</tr>
<tr>
<td>protected</td>
<td>하위 클래스에서만 볼 수 있다.</td>
<td>적용할 수 없음.</td>
</tr>
<tr>
<td>private</td>
<td>같은 클래스 안에서만 볼 수 있다.</td>
<td>같은 파일 안에서만 볼 수 있다.</td>
</tr>
</tbody>
</table>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span>: <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">"Hey~"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">wishper</span><span class="params">()</span></span> = println(<span class="string">"Let's talk!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">giveSpeech</span><span class="params">()</span></span>&#123;</span><br><span class="line">  yell()</span><br><span class="line">  </span><br><span class="line">  whisper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>public 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출함</p>
<ul>
<li>Public 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다.</li>
<li>이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다.</li>
<li>이는 일반적인 규칙에 해당한다.</li>
</ul>
</li>
<li>
<p>yell은 private이라 접근이 불가능.</p>
</li>
<li>
<p>whisper는 상속 관계에서 하위 클래스만 접근이 가능. 따라서 불가능.</p>
</li>
<li>
<p>컴파일 오류를 없애기 위해서는 TalkativeButton을 public으로 바꾸거나 giveSpeech 확장 함수의 가시성을 internal로 바꾸면 된다.</p>
</li>
<li>
<p><strong>자바와 달리 코틀린에서의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.</strong></p>
</li>
<li>
<p><strong>클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다는 사실을 알아야 한다.</strong></p>
</li>
</ul>
<blockquote>
<p>코틀린의 가시성 변경자와 자바</p>
</blockquote>
<p>코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트 코드 안에서도 그대로 유지된다.</p>
<p>유일한 예외는 private이며, 자바에서는 클래스를 private으로 만들 수 없으므로 코틀린은 내부적으로 private 클래스는 package private으로 컴파일한다.</p>
<p>internal은 자바에서 딱 맞는 가시성이 없다. package private과는 다르다. 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어있을 수도 있다. 따라서 internal은 자바 바이트 코드에서 public이 된다.</p>
<p>코틀린과 자바 선언에 차이가 존재하기 때문에 다음과 같은 접근이 가능하다.</p>
<ul>
<li>다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근 가능.</li>
<li>protected로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서 접근 가능.</li>
</ul>
<h3 id="414-내부-클래스와-중첩된-클래스">4.1.4 내부 클래스와 중첩된 클래스</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span>: <span class="type">Serializable</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State = ButtonState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ButtonState</span>: <span class="type">State&#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 내부 클래스</span></span><br><span class="line">  inner ButtonState: State&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서 ButtonState는 중첩 클래스에 해당되며 아무런 변경자가 붙지 않으면 자바의 static 중첩 클래스와 같다. 따라서 바깥쪽 클래스에 대한 참조가 없고, 이로 인해서 직렬화가 가능하다.</li>
<li>이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하고 싶으면 <code>inner</code> 변경자를 붙이면 된다. 이렇게 되면 <strong>NoSerializableException: Button</strong> 이라는 예외가 발생한다.
<ul>
<li>왜 Button을 직렬화할 수 없을까?</li>
<li>내부 클래스는 바깥쪽 클래스에 대한 참조를 포함한다. 그 참조로 인해 직렬화할 수 없다. Button 클래스가 직렬화할 수 있는 상태가 아니기 때문에 결론적으로 ButtonState도 직렬화할 수 없는 것이다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 알고 넘어가기~</p>
</blockquote>
<ul>
<li>내부 클래스 : 바깥쪽 클래스에 대한 참조를 갖는다.</li>
<li>중첩 클래스 : 바깥쪽 클래스에 대한 참조를 갖지 않는다.</li>
</ul>
<table>
<thead>
<tr>
<th>클래스 B안에 정의된 클래스 A</th>
<th>자바에서는</th>
<th>코틀린에서는</th>
</tr>
</thead>
<tbody>
<tr>
<td>중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음)</td>
<td>Static class A</td>
<td>class A</td>
</tr>
<tr>
<td>내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)</td>
<td>class A</td>
<td>inner class A</td>
</tr>
</tbody>
</table>
<h3 id="415-sealed-class">4.1.5 Sealed Class</h3>
<ul>
<li>
<p>기존에는 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 그래서 새로운 클래스에 대한 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 버그가 발생할 가능성이 높다.</p>
</li>
<li>
<p>해법을 제공한다. 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.</p>
</li>
<li>
<p>sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.</p>
</li>
<li>
<p>Sealed 클래스는 자동으로 open이다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">	<span class="keyword">when</span>(e)&#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Num -&gt; e.value</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>When 식이 모든 하위 클래스를 검사하므로 else 분기가 없어도 된다.</li>
<li>클래스 외부에 sealed 클래스 자신을 상속한 클래스를 둘 수 없다.</li>
<li>나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가하면 when 식이 컴파일되지 않는다. 따라서 식을 고쳐야 한다는 사실을 파악하기 쉽다.</li>
<li>내부적으로 Expr 클래스는 private 생성자를 갖는다. 그 생성자는 클래스 내부에서만 호출할 수 있다.</li>
</ul>
<h2 id="뻔하지-않은-생성자와-프로퍼티">[뻔하지 않은 생성자와 프로퍼티]</h2>
<ul>
<li>주 생성자 : 클래스를 초기화할 때, 주로 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다.</li>
<li>부 생성자 : 클래스 본문 안에서 정의한다.</li>
</ul>
<h3 id="421-클래스-초기화-주-생성자와-초기화-블록">4.2.1 클래스 초기화 : 주 생성자와 초기화 블록</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<ul>
<li>중괄호도 없고 괄호 사이에 val만 존재한다.</li>
<li>이처럼 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드는 <strong>주 생성자</strong>라 부른다.</li>
<li>주 생성자는 생성자 파라미터를 정의하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  init&#123;</span><br><span class="line">    nickname = _nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Constructor : 주 생성자나 부 생성자 정의를 할 때 사용되며, 주 생성자의 경우 어노테이션이나 가시성 변경자가 없으면 생략해도 된다.</li>
<li>Init : 초기화 블록으로 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다.</li>
<li>초기화 블록은 주 생성자와 함께 쓰인다. 이유는 주 생성자가 제한적이기 때문에 별도의 코드를 포함할 수 없기 때문!</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname = _nickname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 초기화 블록 없이 프로퍼티 선언에 초기화를 포함시킬 수 있다.</li>
<li>그렇다면 더 간단하게 할 수 있을까? 아래의 코드를 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> lee = User(<span class="string">"VictoryWoo"</span>) <span class="comment">// new 없이 바로 생성자 호출!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.</li>
<li>함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwitterUser</span></span>(name: String) : User(name)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>상위 클래스 초기화를 위해서 클래스 뒤에 괄호 안에 생성자로 인자를 넘긴다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Click</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadioButton</span>: <span class="type">Button</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> : <span class="type">Click</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Button : 별도의 생성자를 정의하지 않아 컴파일러가 자동으로 아무 일도 하지 않는 인자 없는 디폴트 생성자를 만든다.</li>
<li>RadioButton : Button 클래스를 상속했기 때문에 Button의 생성자를 호출해야 한다.</li>
<li>CustomView : Click이 인터페이스이므로 이름만 명시.</li>
</ul>
<h3 id="422-부-생성자">4.2.2 부 생성자</h3>
<ul>
<li>코틀린의 디폴트 값 + 이름 있는 인자를 사용해 생성자가 여럿 있는 경우 처리가 가능하다.</li>
<li><strong>인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말고 대신 파라미터의 디폴트 값을 생성자 시그니처에 명시하라.</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 디폴트 값을 넘겨 같은 클래스의 다른 생성자 호출. </span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context, WOO_STYLE)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)</span><br><span class="line">  	: <span class="keyword">super</span>(context, attr)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyButton에서는 super()를 통해 상위 클래스의 생성자를 호출함으로써 객체 생성을 위임한다.</li>
<li>클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다.</li>
</ul>
<blockquote>
<p>프로퍼티란?</p>
</blockquote>
<ul>
<li>
<p>코틀린은 프로퍼티를 언어의 기본 기능으로 제공.</p>
</li>
<li>
<p>이는 필드와 접근자를 통칭하는 것이다.</p>
</li>
<li>
<p>즉, 데이터를 저장하고 get, set이 가능함을 의미한다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린의 기본 가시성은 public이기 때문에 getter, setter도 동일하게 가져간다. 그런데, 필드에 저장된 데이터의 가시성은 public이 아니다. <strong>생성자에 선언된 데이터는 private이 된다.</strong></li>
</ul>
<p><code>Q. 외부에서 Person 객체를 생성한 뒤, name, isMarried에 접근이 가능할까??</code></p>
<p>— 고민의 시간 —</p>
<ul>
<li><strong>[반면, 일반 클래스 필드에 넣은 데이터는 private으로 지정해주지 않을 경우 public이 된다.]</strong> 라고 하는데 확인해 본 결과 필드에 넣은 데이터 또한 private으로 선언되며, getter가 public으로 지정된다.</li>
<li><strong>선언된 데이터가 private이 된다는 것은 자바 코드로 변환했을 때, 필드의 선언이 private이 되며 getter, setter는 public인 상태가 된다는 것을 의미한다.</strong> 만약, 생성자의 프로퍼티를 private으로 지정한다면 getter, setter도 private이 되어 접근이 불가능하다. (위의 질문에 대한 답이 된다.)</li>
</ul>
<p><strong>[생성자 파라미터의 val, var의 차이]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>1번의 경우 자바 코드로 변환되면 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.09.35](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.09.35.png)</p>
<ul>
<li>생성자에 있는 name은 프로퍼티가 되며, 외부에서도 접근이 가능하다.</li>
</ul>
<p>2번의 경우 자바 코드로 변환시 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.10.03](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.10.03.png)</p>
<ul>
<li>이 경우 name은 생성자에서 프로퍼티를 초기화하는 역할만을 하고, 사용할 수 없다. 따라서 클래스의 생성자 외 다른 메소드에서 사용할 수 없다. (프로퍼티가 아니기 때문)</li>
</ul>
<p><strong>[주의할 점]</strong></p>
<p>위에서 설명했지만, 한번 더 짚고 넘어간다.</p>
<p>디컴파일한 자바 코드를 보면 필드가 private으로 되어 있는 것을 볼 수 있다.</p>
<p>이렇다고 하더라도 코틀린의 프로퍼티가 private은 아니다. 여기서 우리는 <strong>필드와 프로퍼티를 다르게 인식할 줄 알아야 한다.</strong> 자바는 기본적으로 필드로 다루고, 코틀린은 프로퍼티(필드+접근자)를 기본으로 다루는 언어이기 때문에 약간의 차이가 존재한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">setName</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>필드인 name 자체만 보면 private 키워드가 붙어있으므로 private이 맞지만, 프로퍼티 전체를 보면 다르다. getter/setter로 접근이 모두 가능하기 때문에 프로퍼티는 private하다고 볼 수 없다.</p>
<p>위의 코드에서 name 프로퍼티가 private이기 위해서는 아래와 같이 수정해야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(@NotNull String name)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter/setter가 없어 프로퍼티는 private이라고 볼 수 있다.</p>
<ul>
<li><a href="https://wooooooak.github.io/kotlin/2019/05/24/property/" target="_blank" rel="noopener">참고</a></li>
</ul>
<h3 id="423-인터페이스에-선언된-프로퍼티-구현">4.2.3 인터페이스에 선언된 프로퍼티 구현</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인터페이스에 추상 프로퍼티 선언이 있고, 상태를 저장하기 위해서는 해당 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다.</li>
<li>아래는 각기 다른 방식으로 이를 구현한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String): User</span><br><span class="line"><span class="comment">// 주 생성자에 있는 프로퍼티</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribingUser</span></span>(<span class="keyword">val</span> email: String): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: String</span><br><span class="line">  	<span class="keyword">get</span>() = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 커스텀 게터</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> accountId: <span class="built_in">Int</span>): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname = getFacebookNam(accountId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 프로퍼티 초기화 식</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SubscribingUser</strong> : nickname은 매번 호출될 때마다 substringBefore()를 호출해 새로운 값을 계산하는 커스텀 getter를 사용한다.</li>
<li><strong>FacebookUser</strong> : nickname은 객체 초기화 시 계산한 데이터를 저장했다가 불러오는 방식을 이용한다.</li>
</ul>
<h3 id="424-게터와-세터에서-뒷받침하는-필드-접근">4.2.4 게터와 세터에서 뒷받침하는 필드 접근</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">"unspecified"</span></span><br><span class="line">        <span class="keyword">set</span>(value: String) &#123;</span><br><span class="line">            println(<span class="string">"""</span></span><br><span class="line"><span class="string">                Address was changed for <span class="variable">$name</span>:</span></span><br><span class="line"><span class="string">                "<span class="variable">$field</span>" -&gt; "<span class="variable">$value</span>"."""</span>.trimIndent())</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"Alice"</span>)</span><br><span class="line">    user.address = <span class="string">"Elsenheimerstrasse 47, 80687 Muenchen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setter 접근자의 본문에서 field를 통해 뒷받침하는 필드에 접근할 수 있다.(<strong>address</strong>)</li>
<li>getter는 field 값을 읽을 수만 있고, setter는 field 값을 읽거나 쓸 수 있다.</li>
</ul>
<h3 id="425-접근자의-가시성-변경">4.2.5 접근자의 가시성 변경</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addWord</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        counter += word.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lengthCounter = LengthCounter()</span><br><span class="line">    lengthCounter.addWord(<span class="string">"Hi!"</span>)</span><br><span class="line">    println(lengthCounter.counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>기본 가시성을 가지는 getter를 컴파일러가 생성하게 냅두고 setter의 가시성을 private으로 지정하여 외부 코드에서 단어 길이의 합을 마음대로 바꾸지 못하게 하였다.</li>
</ul>
<h2 id="컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임">[컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임]</h2>
<h3 id="431-모든-클래스가-정의해야-하는-메소드">4.3.1 모든 클래스가 정의해야 하는 메소드</h3>
<p>자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다.</p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>자바는 == 를 원시 타입과 참조 타입을 비교할 때 사용한다.</p>
<p>원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교하고, 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다. 따라서 자바에서 두 객체의 동등성을 알려면 equals()를 호출해야 한다.</p>
<p><strong>코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다.</strong> ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 따라서 클래스가 equals()를 오버라이드하면 == 을 통해 안전하게 클래스의 인스턴스를 비교할 수 있다.</p>
<p>참조 비교를위해서는. === 연산자를 사용할 수 있다.</p>
<p>=== 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 ==와 같다.</p>
<h3 id="432-data-class">4.3.2 data class</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>class 앞에 data를 붙이면 자동으로 toString(), copy(), equals(), hashCode()를 포함한다.</li>
<li>이를 데이터 클래스라고 부르며 주로 데이터를 저장하는 역할을 한다.</li>
<li>주의할 점은 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니다.</li>
</ul>
<p><strong>[copy() 메소드]</strong></p>
<ul>
<li>데이터 클래스의 프로퍼티가 모두 val일 필요는 없다. var여도 된다. 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어 불변 클래스로 만들라고 권장한다.</li>
<li>불변의 장점 : 다중 스레드에서 동기화를 고려하지 않아도 됨.</li>
<li>Copy() : 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해준다.</li>
<li>객체를 메모리 상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다.</li>
</ul>
<h3 id="433-클래스-위임-by">4.3.3 클래스 위임 : by</h3>
<ul>
<li>인터페이스를 구현할 때, by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingCollection</span>&lt;<span class="type">T</span>&gt;</span>(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러가 전달 메소드를 자동으로 생성하며, 자동 생성한 코드의 구현은 책에 실린 코드와 비슷하다.</li>
<li>Collection의 구현을 innerList에게 위임한다.</li>
<li>메소드 중 일부의 동작을 변경하고 싶을 때는 메소드를 오버라이드 하면 컴파일러가 오버라이드한 메소드를 쓴다.</li>
</ul>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()</span><br><span class="line">) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectsAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(c: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded += c.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cset = CountingSet&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    cset.addAll(listOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;cset.objectsAdded&#125;</span> objects were added, <span class="subst">$&#123;cset.size&#125;</span> remain"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>add, addAll을 오버라이드해서 count를 증가시키고 MutableCollection 인터페이스의 나머지 메소드는 내부 컨테이너인 innerSet에게 위임한다.</p>
</li>
<li>
<p>CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 생기지 않는다. CountingSet 코드는 위임 대상 내부 클래스인 MutableCollection의 API를 활용하므로 API를 변경하지 않는 한 CountingSet 코드가 계속 잘 작동할 것임을 확신할 수 있다.</p>
<p>-&gt; <strong>CountingSet의 생성자 파라미터에 존재하는 innerSet 프로퍼티에게 MutableCollection의 구현을 위임했기 때문에 CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 없다. innerSet이 MutableCollection에 의존 관계를 가지고 있다.</strong></p>
</li>
</ul>
<h2 id="object-키워드-클래스-선언과-인스턴스-생성">object 키워드 : 클래스 선언과 인스턴스 생성</h2>
<h3 id="441-객체-선언-싱글톤">4.4.1 객체 선언 : 싱글톤</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll&#123;</span><br><span class="line">  <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">calculateSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(person <span class="keyword">in</span> allEmployees)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object를 통해 기본적으로 싱글톤 기능을 언어 레벨에서 제공한다.</li>
<li>객체 선언 = 클래스 선언 + 그 클래스에 속한 단일 인스턴스의 선언</li>
<li>생성자는 쓸 수 없다. 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문에 생성자 정의가 필요없다.</li>
<li>object 선언도 클래스나 인터페이스 상속이 가능하다.</li>
<li>클래스 안에 object 선언도 가능하다. 이 객체도 인스턴스는 단 하나뿐이다. (바깥쪽 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 따로 하나씩 생기는 것이 아니다.)</li>
</ul>
<h3 id="442-동반-객체">4.4.2 동반 객체</h3>
<ul>
<li>kotlin에서는 static 개념이 존재하지 않는다.</li>
<li>패키지 수준의 최상위 함수가 정적 메소드 역할을 대신할 수 있다.  객체 선언은 정적 필드를 대신할 수도 있다.</li>
<li>최상위 함수를 권장하지만, 클래스에 비공개 멤버를 포함하면 이 멤버에 접근할 수 없다.</li>
<li>그래서 클래스의 인스턴스와 관계 없이 호출해야 하지만, 클래스 내부 정보에 접근해야 할 때 companion object를 사용하면 된다.</li>
<li>companion object는 외부 클래스의 private한 멤버 접근이 가능하기 때문에 팩토리 메소드를 만들 때 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"Companion object called"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    A.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>호출할 때, 클래스 이름으로 바로 호출이 가능하다.</li>
<li>이름을 따로 지정하지 않아도 되며, 사용 예를 보면 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.</li>
<li>즉, 자바의 static 함수 호출과 동일하다.</li>
</ul>
<p>Ex)</p>
<p><strong>부 생성자가 여럿 있는 클래스</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(email: String)&#123;</span><br><span class="line">    nickname = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(accountId: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    nickname = getFacebookName(accountId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>팩토리 메소드로 부 생성자 대신하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId:<span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> user = User.newSubscribinUser(<span class="string">"Victory@gmail.com"</span>)</span><br><span class="line">  println(user.nickname)</span><br><span class="line">  <span class="comment">// Victory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User는 private constructor를 가지기 때문에 외부에서 생성하지 못한다. 따라서 외부에서는 companion object로 제공되는 팩토리 메소드를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</li>
</ul>
<h3 id="433-동반-객체를-일반-객체처럼-사용">4.3.3 동반 객체를 일반 객체처럼 사용</h3>
<p>동반 객체 = 클래스 안에 정의된 일반 객체</p>
<p>따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object 이름 명명 가능.</li>
<li>companion object 내부에 확장 함수와 프로퍼티 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  Person.Loader.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">  Person.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 두 방법 모두 제대로 fromJson을 호출할 수 있다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : JSONFactory&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Person(<span class="string">"Lee"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">loadFromJSON</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    loadFromJSON(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 companion object가 특정 인터페이스를 구현할 수도 있고, <strong>동반 객체가 구현한 JSONFactory 인터페이스를 넘길 때 Person 클래스(외부 클래스)의 이름을 사용한다.</strong></p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다.</p>
<p>그런 경우 <code>@JvmStatic</code> 어노테이션을 코틀린 멤버에 붙이면 된다.</p>
<p>정적 필드가 필요하다면 <code>@JvmField</code> 어노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다.</p>
<p>이는 10장에서 더 자세히 알아보자!</p>
<p>동반 객체를 이용해 외부에서 확장 함수를 정의할 수 있다고 했다. 아래 코드를 통해서 확인해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.Companion.<span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person&#123;</span><br><span class="line">  <span class="comment">// 확장 함수 정의.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person.fromJSON(<span class="string">"json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>마치 동반 객체 안에 fromJSON을 정의한 것처럼 함수를 호출할 수 있다.</li>
<li>동반 객체에 대한 확장 함수를 정의하기 위해서는 원래 클래스에 동반 객체를 꼭 선언해야 한다.(비어있어도 괜찮다.)</li>
</ul>
<h3 id="444-무명-클래스">4.4.4 무명 클래스</h3>
<ul>
<li>무명 객체를 정의할 때도 object 키워드를 쓴다.</li>
<li>무명 객체는 자바의 무명 내부 클래스를 대신한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span> : ClickListener&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Clicked Listener!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Clicked!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  setClickAction(listener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object 선언과 달리 익명 클래스는 싱글톤이 아니다. 따라서 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.</li>
<li>또한, 무명 객체 즉, 익명 클래스 안에서 함수에 정의된 로컬 변수를 사용할 수도 있다.
<ul>
<li>자바와 조금 다른 점이다. 자바는 익명 클래스에서 접근 시 무조건 final이어야 한다.</li>
</ul>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li>Made by <a href="https://github.com/WooVictory" target="_blank" rel="noopener">Me</a></li>
</ul>

        </div>
        
        <footer class="article-footer">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
            



    <a data-url="https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/" data-id="ckca58jr301bzm5pqa4vp0oq0" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://www.facebook.com/WooVictory" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/WooVictory" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="linkedin" href="https://www.linkedin.com/in/seungwoo-lee-590844177" target="_blank" rel="noopener">
                        <i class="icon fa fa-linkedin"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2020/04/02/KotlinInAction-Chap5/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            [Kotlin in Action] Chap5. 람다
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2020/04/01/KotlinInAction-Chap3/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">[Kotlin in action] Chap3. 함수 정의와 호출</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
        
            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">78</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Book/">Book</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Book/CleanCode/">CleanCode</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design-Pattern/">Design Pattern</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ETC/">ETC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Inno-SOPT/">Inno_SOPT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">39</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operation-System/">Operation System</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/RxJava/">RxJava</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">51</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/BOJ/">BOJ</a><span class="category-list-count">49</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/Programmers/">Programmers</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/개발-상식/">개발 상식</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/네트워크/">네트워크</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/데이터베이스/">데이터베이스</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/삼성-기출/">삼성 기출</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/알고리즘/">알고리즘</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/자료구조/">자료구조</a><span class="category-list-count">10</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2020/07/06/Android-koin-1/" class="title">[Android] Koin</a></p>
                            <p class="item-date"><time datetime="2020-07-06T03:27:54.000Z" itemprop="datePublished">2020-07-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Java/">Java</a></p>
                            <p class="item-title"><a href="/2020/07/05/Java-binding/" class="title">[Java] 동적바인딩 vs 정적바인딩</a></p>
                            <p class="item-date"><time datetime="2020-07-05T14:34:50.000Z" itemprop="datePublished">2020-07-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2020/07/05/What-is-DI/" class="title">[Android] Dependency Injection</a></p>
                            <p class="item-date"><time datetime="2020-07-05T13:08:42.000Z" itemprop="datePublished">2020-07-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2020/07/05/Kotlin-Collection-Filter-Map/" class="title">[Kotlin] filter, map 호출 순서에 따른 성능 차이</a></p>
                            <p class="item-date"><time datetime="2020-07-05T07:50:52.000Z" itemprop="datePublished">2020-07-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2020/07/05/Kotlin-Sequence/" class="title">[Kotlin] Sequence</a></p>
                            <p class="item-date"><time datetime="2020-07-05T05:53:05.000Z" itemprop="datePublished">2020-07-05</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
        
    </div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2020 VictoryWoo</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
