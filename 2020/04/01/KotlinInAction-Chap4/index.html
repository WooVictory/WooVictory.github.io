
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>[Kotlin in action] Chap4. 클래스와 인터페이스 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"articleBody":"목차\n\n클래스와 인터페이스\n뻔하지 않은 생성자와 프로퍼티\n데이터 클래스\n클래스 위임\nobject 키워드 사용\n\n\n4.1.1 코틀린 인터페이스\n\n인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.\n\n12345678910interface Clickable&#123;  fun onClick()  fun showOff() = println(\"Show~\") // 디폴트 구현. &#125;class Button : Clickable &#123;  override fun onClick() = println(\"Hi~\")&#125;Button().onClick()\n\n클래스 이름 뒤에 콜론(:)을 붙여 인터페이스와 클래스 이름을 적는 것으로 상속과 인터페이스 구현을 모두 처리한다.\n\n자바 : extends, implements\n\n\n자바와 마찬가지로 다중 구현은 허용되지만, 다중 상속은 불가능하다.\n@Override 어노테이션과 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 한다는 뜻이다. 다만, override 변경자는 코틀린에서 꼭 표시해야 한다.\n디폴트 구현을 제공할 수 있으며, 특별한 키워드를 붙이지 않고 메소드 본문을 적어주면 된다.\n\n이 경우, Clickable을 구현하는 하위 클래스에서 showOff를 새롭게 정의할 수도 있고, 정의를 생략해서 디폴트 구현을 사용할 수도 있다.\n\n\n아래 코드를 함께 보자.\n\n1234interface Focusable&#123;  fun setFocus() = ...  fun showOff() = println(\"I'm Focus\")&#125;\n\n이제 한 클래스에서 Clickable, Focusable  두 인터페이스를 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현이 들어있다.\n결론은 어느 쪽의 showOff() 메소드도 호출되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 아래와 같은 컴파일 오류가 발생한다.\n\n\nThe class ‘Button’ must override public open fun showOff()\nbecause it inherits many implementations of it.\n\n\n코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 강제한다.\n\n1234567class Button: Clickable, Focusable&#123;  override fun onClick() = ...  override fun showOff()&#123;    super&lt;Clickable&gt;.showOff()    super&lt;Focusable&gt;.showOff()  &#125;&#125;\n\n즉, 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 존재하는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다.\n자바와 달리 상위 타입의 이름을 꺽쇠 괄호(&lt;&gt;) 사이에 넣어서 super를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.\n\n4.1.2 open, final, abstract 변경자\n\n자바에서는 기본적으로 상위 클래스에 대해 하위 클래스에서 상속하는 걸 막지 않는다. 막기 위해서는 final을 붙여 상속을 할 수 없게 한다.\n기본적으로 상속이 가능하면 편리하지만, 문제가 생기는 경우도 있다.\n취약한 기반 클래스 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 존재한다.\n즉, 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다.\n이런 점을 보완하기 위해 코틀린에서는 클래스와 메소드는 기본적으로 final이다.\n클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다.\n오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 붙일 수 있다.\n\n12345678910open class RichButton : Clickable&#123;  fun disable()    open fun animate()    override fun onClick()    final override fun onClick()   // 오버라이드한 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 막을 수 있다.&#125;\n\nRichButton 클래스는 다른 클래스가 상속할 수 있다.(open)\ndisable() : final이며, 오버라이드 할 수 없다.\nanimate() : oepn으로 오버라이드 가능.\nonClick() : 상위 클래스에서 선언된 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.\n\n\nabstract로 선언한 추상 클래스는 인스턴스화 할 수 없으며, 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야 하는게 보통이다.\n추상 멤버는 항상 열려 있기 때문에 open 변경자를 명시할 필요가 없다.\n\nTodo 표 추가\n4.1.3 가시성 변경자\n\n코틀린의 기본 가시성은 자바와 다르며, 아무 변경자도 없는 경우 public이다.\n자바의 기본 가시성인 package private이 없다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.\n코틀린은 internal이라는 새로운 가시성을 도입했다.\n\n이는 모듈 내부에서만 볼 수 있음을 뜻한다.\n모듈 : 한 번에 한꺼번에 컴파일되는 파일들을 의미한다.\n모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.\n\n\n코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다.\n\n\n? 모듈에 대해 생각해볼 필요가 있어 보인다.\n\n\n\n\n변경자\n클래스멤버\n최상위 선언\n\n\n\n\npublic\n모든 곳에서 볼 수 있다.\n모든 곳에서 볼 수 있다.\n\n\ninternal\n같은 모듈 안에서만 볼 수 있다.\n같은 모듈 안에서만 볼 수 있다.\n\n\nprotected\n하위 클래스에서만 볼 수 있다.\n적용할 수 없음.\n\n\nprivate\n같은 클래스 안에서만 볼 수 있다.\n같은 파일 안에서만 볼 수 있다.\n\n\n\nEx)\n12345678910internal open class TalkativeButton: Focusable&#123;  private fun yell() = println(\"Hey~\")  protected fun wishper() = println(\"Let's talk!\")&#125;fun TalkativeButton.giveSpeech()&#123;  yell()    whisper()&#125;\n\n\npublic 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출함\n\nPublic 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다.\n이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다.\n이는 일반적인 규칙에 해당한다.\n\n\n\nyell은 private이라 접근이 불가능.\n\n\nwhisper는 상속 관계에서 하위 클래스만 접근이 가능. 따라서 불가능.\n\n\n컴파일 오류를 없애기 위해서는 TalkativeButton을 public으로 바꾸거나 giveSpeech 확장 함수의 가시성을 internal로 바꾸면 된다.\n\n\n자바와 달리 코틀린에서의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.\n\n\n클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다는 사실을 알아야 한다.\n\n\n\n코틀린의 가시성 변경자와 자바\n\n코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트 코드 안에서도 그대로 유지된다.\n유일한 예외는 private이며, 자바에서는 클래스를 private으로 만들 수 없으므로 코틀린은 내부적으로 private 클래스는 package private으로 컴파일한다.\ninternal은 자바에서 딱 맞는 가시성이 없다. package private과는 다르다. 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어있을 수도 있다. 따라서 internal은 자바 바이트 코드에서 public이 된다.\n코틀린과 자바 선언에 차이가 존재하기 때문에 다음과 같은 접근이 가능하다.\n\n다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근 가능.\nprotected로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서 접근 가능.\n\n4.1.4 내부 클래스와 중첩된 클래스\n12345678910111213141516171819202122interface State: Serializableinterface View&#123;  fun getCurrentState(): State  fun restoreState(state: State)&#123;&#125;&#125;class Button : View&#123;  override fun getCurrentState(): State = ButtonState()    override fun restoreState(state: State)&#123;    ...  &#125;    class ButtonState: State&#123;    ...  &#125;  // 내부 클래스  inner ButtonState: State&#123;      &#125;&#125;\n\n코틀린에서 ButtonState는 중첩 클래스에 해당되며 아무런 변경자가 붙지 않으면 자바의 static 중첩 클래스와 같다. 따라서 바깥쪽 클래스에 대한 참조가 없고, 이로 인해서 직렬화가 가능하다.\n이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하고 싶으면 inner 변경자를 붙이면 된다. 이렇게 되면 NoSerializableException: Button 이라는 예외가 발생한다.\n\n왜 Button을 직렬화할 수 없을까?\n내부 클래스는 바깥쪽 클래스에 대한 참조를 포함한다. 그 참조로 인해 직렬화할 수 없다. Button 클래스가 직렬화할 수 있는 상태가 아니기 때문에 결론적으로 ButtonState도 직렬화할 수 없는 것이다.\n\n\n\n\n📌 알고 넘어가기~\n\n\n내부 클래스 : 바깥쪽 클래스에 대한 참조를 갖는다.\n중첩 클래스 : 바깥쪽 클래스에 대한 참조를 갖지 않는다.\n\n\n\n\n클래스 B안에 정의된 클래스 A\n자바에서는\n코틀린에서는\n\n\n\n\n중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음)\nStatic class A\nclass A\n\n\n내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)\nclass A\ninner class A\n\n\n\n4.1.5 Sealed Class\n\n\n기존에는 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 그래서 새로운 클래스에 대한 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 버그가 발생할 가능성이 높다.\n\n\n해법을 제공한다. 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.\n\n\nsealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.\n\n\nSealed 클래스는 자동으로 open이다.\n\n\n12345678910sealed class Expr&#123;  class Num(val value: Int): Expr()  class Sum(val left: Expr, val right: Expr): Expr()&#125;fun eval(e: Expr): Int = \twhen(e)&#123;    is Expr.Num -&gt; e.value    is Expr.Sum -&gt; eval(e.left) + eval(e.right)  &#125;\n\nWhen 식이 모든 하위 클래스를 검사하므로 else 분기가 없어도 된다.\n클래스 외부에 sealed 클래스 자신을 상속한 클래스를 둘 수 없다.\n나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가하면 when 식이 컴파일되지 않는다. 따라서 식을 고쳐야 한다는 사실을 파악하기 쉽다.\n내부적으로 Expr 클래스는 private 생성자를 갖는다. 그 생성자는 클래스 내부에서만 호출할 수 있다.\n\n[뻔하지 않은 생성자와 프로퍼티]\n\n주 생성자 : 클래스를 초기화할 때, 주로 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다.\n부 생성자 : 클래스 본문 안에서 정의한다.\n\n4.2.1 클래스 초기화 : 주 생성자와 초기화 블록\n1class User(val name: String)\n\n중괄호도 없고 괄호 사이에 val만 존재한다.\n이처럼 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드는 주 생성자라 부른다.\n주 생성자는 생성자 파라미터를 정의하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.\n\n123456class User constructor(_nickname: String)&#123;  val nickname: String  init&#123;    nickname = _nickname  &#125;&#125;\n\nConstructor : 주 생성자나 부 생성자 정의를 할 때 사용되며, 주 생성자의 경우 어노테이션이나 가시성 변경자가 없으면 생략해도 된다.\nInit : 초기화 블록으로 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다.\n초기화 블록은 주 생성자와 함께 쓰인다. 이유는 주 생성자가 제한적이기 때문에 별도의 코드를 포함할 수 없기 때문!\n\n123class User(_nickname: String)&#123;  val nickname = _nickname&#125;\n\n이처럼 초기화 블록 없이 프로퍼티 선언에 초기화를 포함시킬 수 있다.\n그렇다면 더 간단하게 할 수 있을까? 아래의 코드를 보자.\n\n1234567class User(val nickname: String)&#123;  ...&#125;fun main(args: Array&lt;String&gt;)&#123;  val lee = User(\"VictoryWoo\") // new 없이 바로 생성자 호출!&#125;\n\n주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.\n함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 사용할 수 있다.\n\n12345open class User(val name: String)&#123; ... &#125;class TwitterUser(name: String) : User(name)&#123;  ...&#125;\n\n상위 클래스 초기화를 위해서 클래스 뒤에 괄호 안에 생성자로 인자를 넘긴다.\n\n12345open class Buttoninterface Clickclass RadioButton: Button()class CustomView : Click\n\nButton : 별도의 생성자를 정의하지 않아 컴파일러가 자동으로 아무 일도 하지 않는 인자 없는 디폴트 생성자를 만든다.\nRadioButton : Button 클래스를 상속했기 때문에 Button의 생성자를 호출해야 한다.\nCustomView : Click이 인터페이스이므로 이름만 명시.\n\n4.2.2 부 생성자\n\n코틀린의 디폴트 값 + 이름 있는 인자를 사용해 생성자가 여럿 있는 경우 처리가 가능하다.\n인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말고 대신 파라미터의 디폴트 값을 생성자 시그니처에 명시하라.\n\n12345678910111213141516171819202122232425open class View&#123;  constructor(context: Context)&#123;    ...  &#125;    constructor(context: Context, attr: AttributeSet)&#123;    ...  &#125;&#125;class MyButton : View&#123;  constructor(context: Context) : super(context)&#123;    ...  &#125;    // 디폴트 값을 넘겨 같은 클래스의 다른 생성자 호출.   constructor(context: Context) : this(context, WOO_STYLE)&#123;    ...  &#125;    constructor(context: Context, attr: AttributeSet)  \t: super(context, attr)&#123;      ...    &#125;&#125;\n\nMyButton에서는 super()를 통해 상위 클래스의 생성자를 호출함으로써 객체 생성을 위임한다.\n클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다.\n\n\n프로퍼티란?\n\n\n\n코틀린은 프로퍼티를 언어의 기본 기능으로 제공.\n\n\n이는 필드와 접근자를 통칭하는 것이다.\n\n\n즉, 데이터를 저장하고 get, set이 가능함을 의미한다.\n\n\n1class Person(val name: String, var isMarried: Boolean)\n\n코틀린의 기본 가시성은 public이기 때문에 getter, setter도 동일하게 가져간다. 그런데, 필드에 저장된 데이터의 가시성은 public이 아니다. 생성자에 선언된 데이터는 private이 된다.\n\nQ. 외부에서 Person 객체를 생성한 뒤, name, isMarried에 접근이 가능할까??\n— 고민의 시간 —\n\n[반면, 일반 클래스 필드에 넣은 데이터는 private으로 지정해주지 않을 경우 public이 된다.] 라고 하는데 확인해 본 결과 필드에 넣은 데이터 또한 private으로 선언되며, getter가 public으로 지정된다.\n선언된 데이터가 private이 된다는 것은 자바 코드로 변환했을 때, 필드의 선언이 private이 되며 getter, setter는 public인 상태가 된다는 것을 의미한다. 만약, 생성자의 프로퍼티를 private으로 지정한다면 getter, setter도 private이 되어 접근이 불가능하다. (위의 질문에 대한 답이 된다.)\n\n[생성자 파라미터의 val, var의 차이]\n123class Person(val name: String) // 1class Person(name: String) // 2\n1번의 경우 자바 코드로 변환되면 아래와 같다.\n![스크린샷 2020-02-27 오후 3.09.35](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.09.35.png)\n\n생성자에 있는 name은 프로퍼티가 되며, 외부에서도 접근이 가능하다.\n\n2번의 경우 자바 코드로 변환시 아래와 같다.\n![스크린샷 2020-02-27 오후 3.10.03](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.10.03.png)\n\n이 경우 name은 생성자에서 프로퍼티를 초기화하는 역할만을 하고, 사용할 수 없다. 따라서 클래스의 생성자 외 다른 메소드에서 사용할 수 없다. (프로퍼티가 아니기 때문)\n\n[주의할 점]\n위에서 설명했지만, 한번 더 짚고 넘어간다.\n디컴파일한 자바 코드를 보면 필드가 private으로 되어 있는 것을 볼 수 있다.\n이렇다고 하더라도 코틀린의 프로퍼티가 private은 아니다. 여기서 우리는 필드와 프로퍼티를 다르게 인식할 줄 알아야 한다. 자바는 기본적으로 필드로 다루고, 코틀린은 프로퍼티(필드+접근자)를 기본으로 다루는 언어이기 때문에 약간의 차이가 존재한다.\n1class Person(val name: String)\n123456789101112131415public class Person&#123;  private String name;    public Person(String name) &#123;        this.name = name;  &#125;  public Void setName(String value) &#123;        this.name = value;  &#125;  public String getName() &#123;        return this.name;  &#125;&#125;\n필드인 name 자체만 보면 private 키워드가 붙어있으므로 private이 맞지만, 프로퍼티 전체를 보면 다르다. getter/setter로 접근이 모두 가능하기 때문에 프로퍼티는 private하다고 볼 수 없다.\n위의 코드에서 name 프로퍼티가 private이기 위해서는 아래와 같이 수정해야 한다.\n1class Person(private val name: String)\n123456789public final class Person &#123;   private String name;   public Property(@NotNull String name) &#123;      Intrinsics.checkParameterIsNotNull(name, \"name\");      super();      this.name = name;   &#125;&#125;\ngetter/setter가 없어 프로퍼티는 private이라고 볼 수 있다.\n\n참고\n\n4.2.3 인터페이스에 선언된 프로퍼티 구현\n123interface User&#123;  val name: String&#125;\n\n인터페이스에 추상 프로퍼티 선언이 있고, 상태를 저장하기 위해서는 해당 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다.\n아래는 각기 다른 방식으로 이를 구현한다.\n\n12345678910111213class PrivateUser(override val nickname: String): User// 주 생성자에 있는 프로퍼티class SubscribingUser(val email: String): User&#123;  override val name: String  \tget() = email.substringBefore('@')&#125;// 커스텀 게터class FacebookUser(val accountId: Int): User&#123;  override val nickname = getFacebookNam(accountId)&#125;// 프로퍼티 초기화 식\n\nSubscribingUser : nickname은 매번 호출될 때마다 substringBefore()를 호출해 새로운 값을 계산하는 커스텀 getter를 사용한다.\nFacebookUser : nickname은 객체 초기화 시 계산한 데이터를 저장했다가 불러오는 방식을 이용한다.\n\n4.2.4 게터와 세터에서 뒷받침하는 필드 접근\n1234567891011121314class User(val name: String) &#123;    var address: String = \"unspecified\"        set(value: String) &#123;            println(\"\"\"                Address was changed for $name:                \"$field\" -&gt; \"$value\".\"\"\".trimIndent())            field = value        &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val user = User(\"Alice\")    user.address = \"Elsenheimerstrasse 47, 80687 Muenchen\"&#125;\n\nsetter 접근자의 본문에서 field를 통해 뒷받침하는 필드에 접근할 수 있다.(address)\ngetter는 field 값을 읽을 수만 있고, setter는 field 값을 읽거나 쓸 수 있다.\n\n4.2.5 접근자의 가시성 변경\n1234567891011121314class LengthCounter &#123;    var counter: Int = 0        private set    fun addWord(word: String) &#123;        counter += word.length    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val lengthCounter = LengthCounter()    lengthCounter.addWord(\"Hi!\")    println(lengthCounter.counter)&#125;\n\n기본 가시성을 가지는 getter를 컴파일러가 생성하게 냅두고 setter의 가시성을 private으로 지정하여 외부 코드에서 단어 길이의 합을 마음대로 바꾸지 못하게 하였다.\n\n[컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임]\n4.3.1 모든 클래스가 정의해야 하는 메소드\n자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다.\n\n알고 넘어가기!\n\n자바는 == 를 원시 타입과 참조 타입을 비교할 때 사용한다.\n원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교하고, 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다. 따라서 자바에서 두 객체의 동등성을 알려면 equals()를 호출해야 한다.\n코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다. ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 따라서 클래스가 equals()를 오버라이드하면 == 을 통해 안전하게 클래스의 인스턴스를 비교할 수 있다.\n참조 비교를위해서는. === 연산자를 사용할 수 있다.\n=== 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 ==와 같다.\n4.3.2 data class\n1data class Client(val name: String, val postalCode: Int)\n\nclass 앞에 data를 붙이면 자동으로 toString(), copy(), equals(), hashCode()를 포함한다.\n이를 데이터 클래스라고 부르며 주로 데이터를 저장하는 역할을 한다.\n주의할 점은 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니다.\n\n[copy() 메소드]\n\n데이터 클래스의 프로퍼티가 모두 val일 필요는 없다. var여도 된다. 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어 불변 클래스로 만들라고 권장한다.\n불변의 장점 : 다중 스레드에서 동기화를 고려하지 않아도 됨.\nCopy() : 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해준다.\n객체를 메모리 상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다.\n\n4.3.3 클래스 위임 : by\n\n인터페이스를 구현할 때, by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.\n\n123class DelegatingCollection&lt;T&gt;(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; by innerList &#123;  &#125;\n\n컴파일러가 전달 메소드를 자동으로 생성하며, 자동 생성한 코드의 구현은 책에 실린 코드와 비슷하다.\nCollection의 구현을 innerList에게 위임한다.\n메소드 중 일부의 동작을 변경하고 싶을 때는 메소드를 오버라이드 하면 컴파일러가 오버라이드한 메소드를 쓴다.\n\nEx)\n123456789101112131415161718192021222324import java.util.HashSetclass CountingSet&lt;T&gt;(        val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123;    var objectsAdded = 0    override fun add(element: T): Boolean &#123;        objectsAdded++        return innerSet.add(element)    &#125;    override fun addAll(c: Collection&lt;T&gt;): Boolean &#123;        objectsAdded += c.size        return innerSet.addAll(c)    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val cset = CountingSet&lt;Int&gt;()    cset.addAll(listOf(1, 1, 2))    println(\"$&#123;cset.objectsAdded&#125; objects were added, $&#123;cset.size&#125; remain\")&#125;\n\n\nadd, addAll을 오버라이드해서 count를 증가시키고 MutableCollection 인터페이스의 나머지 메소드는 내부 컨테이너인 innerSet에게 위임한다.\n\n\nCountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 생기지 않는다. CountingSet 코드는 위임 대상 내부 클래스인 MutableCollection의 API를 활용하므로 API를 변경하지 않는 한 CountingSet 코드가 계속 잘 작동할 것임을 확신할 수 있다.\n-&gt; CountingSet의 생성자 파라미터에 존재하는 innerSet 프로퍼티에게 MutableCollection의 구현을 위임했기 때문에 CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 없다. innerSet이 MutableCollection에 의존 관계를 가지고 있다.\n\n\nobject 키워드 : 클래스 선언과 인스턴스 생성\n4.4.1 객체 선언 : 싱글톤\n12345678object Payroll&#123;  val allEmployees = arrayListOf&lt;Person&gt;()  fun calculateSalary()&#123;    for(person in allEmployees)&#123;      ...    &#125;  &#125;&#125;\n\nobject를 통해 기본적으로 싱글톤 기능을 언어 레벨에서 제공한다.\n객체 선언 = 클래스 선언 + 그 클래스에 속한 단일 인스턴스의 선언\n생성자는 쓸 수 없다. 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문에 생성자 정의가 필요없다.\nobject 선언도 클래스나 인터페이스 상속이 가능하다.\n클래스 안에 object 선언도 가능하다. 이 객체도 인스턴스는 단 하나뿐이다. (바깥쪽 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 따로 하나씩 생기는 것이 아니다.)\n\n4.4.2 동반 객체\n\nkotlin에서는 static 개념이 존재하지 않는다.\n패키지 수준의 최상위 함수가 정적 메소드 역할을 대신할 수 있다.  객체 선언은 정적 필드를 대신할 수도 있다.\n최상위 함수를 권장하지만, 클래스에 비공개 멤버를 포함하면 이 멤버에 접근할 수 없다.\n그래서 클래스의 인스턴스와 관계 없이 호출해야 하지만, 클래스 내부 정보에 접근해야 할 때 companion object를 사용하면 된다.\ncompanion object는 외부 클래스의 private한 멤버 접근이 가능하기 때문에 팩토리 메소드를 만들 때 유용하다.\n\n1234567891011class A &#123;    companion object &#123;        fun bar() &#123;            println(\"Companion object called\")        &#125;    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    A.bar()&#125;\n\n호출할 때, 클래스 이름으로 바로 호출이 가능하다.\n이름을 따로 지정하지 않아도 되며, 사용 예를 보면 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.\n즉, 자바의 static 함수 호출과 동일하다.\n\nEx)\n부 생성자가 여럿 있는 클래스\n1234567891011class User&#123;  val nickname: String    constructor(email: String)&#123;    nickname = email.substringBefore('@')  &#125;    constructor(accountId: Int)&#123;    nickname = getFacebookName(accountId)  &#125;&#125;\n팩토리 메소드로 부 생성자 대신하기\n12345678910111213class User private constructor(val nickname: String)&#123;  companion object&#123;    fun newSubscribingUser(email: String) = User(email.substringBefore('@'))        fun newFacebookUser(accountId:Int) = User(getFacebookName(accountId))  &#125;&#125;fun main(args: Array&lt;String&gt;)&#123;  val user = User.newSubscribinUser(\"Victory@gmail.com\")  println(user.nickname)  // Victory&#125;\n\nUser는 private constructor를 가지기 때문에 외부에서 생성하지 못한다. 따라서 외부에서는 companion object로 제공되는 팩토리 메소드를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.\n\n4.3.3 동반 객체를 일반 객체처럼 사용\n동반 객체 = 클래스 안에 정의된 일반 객체\n따라서 아래와 같은 작업이 가능하다.\n\ncompanion object 이름 명명 가능.\ncompanion object 내부에 확장 함수와 프로퍼티 정의\n인터페이스 상속\n\n12345678910111213class Person(val name: String)&#123;  companion object Loader&#123;    fun fromJson(json: String) : Person &#123;      ...    &#125;  &#125;&#125;fun main(args: Array&lt;String&gt;)&#123;  Person.Loader.fromJson(\"&#123;name: 'Lee'&#125;\")  Person.fromJson(\"&#123;name: 'Lee'&#125;\")&#125;// 두 방법 모두 제대로 fromJson을 호출할 수 있다.\n12345678910111213141516171819interface JSONFactory&lt;T&gt; &#123;    fun fromJSON(json: String): T&#125;class Person(val name: String) &#123;    companion object : JSONFactory&lt;Person&gt; &#123;        override fun fromJSON(json: String): Person &#123;            return Person(\"Lee\")        &#125;    &#125;&#125;fun &lt;T&gt; loadFromJSON(factory: JSONFactory&lt;T&gt;): T? &#123;    return null&#125;fun main() &#123;    loadFromJSON(Person)&#125;\n위의 예제처럼 companion object가 특정 인터페이스를 구현할 수도 있고, 동반 객체가 구현한 JSONFactory 인터페이스를 넘길 때 Person 클래스(외부 클래스)의 이름을 사용한다.\n\n알고 넘어가기!\n\n때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다.\n그런 경우 @JvmStatic 어노테이션을 코틀린 멤버에 붙이면 된다.\n정적 필드가 필요하다면 @JvmField 어노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다.\n이는 10장에서 더 자세히 알아보자!\n동반 객체를 이용해 외부에서 확장 함수를 정의할 수 있다고 했다. 아래 코드를 통해서 확인해보자.\n12345678910111213class Person(val name: String)&#123;  companion object&#123;      &#125;&#125;fun Person.Companion.fromJSON(json: String) : Person&#123;  // 확장 함수 정의.&#125;fun main()&#123;  Person.fromJSON(\"json\")&#125;\n\n마치 동반 객체 안에 fromJSON을 정의한 것처럼 함수를 호출할 수 있다.\n동반 객체에 대한 확장 함수를 정의하기 위해서는 원래 클래스에 동반 객체를 꼭 선언해야 한다.(비어있어도 괜찮다.)\n\n4.4.4 무명 클래스\n\n무명 객체를 정의할 때도 object 키워드를 쓴다.\n무명 객체는 자바의 무명 내부 클래스를 대신한다.\n\n1234567891011121314151617181920212223interface ClickListener&#123;  fun onClick()&#125;val listener = object : ClickListener&#123;  override fun onClick()&#123;    println(\"Clicked Listener!!\")  &#125;&#125;fun main()&#123;  setClickAction(object: ClickListener&#123;    override fun onClick()&#123;      println(\"Clicked!!\")    &#125;  &#125;)    setClickAction(listener)&#125;fun setClickAction(clickListener: ClickListener)&#123;  clickListener.onClick()&#125;\n\nobject 선언과 달리 익명 클래스는 싱글톤이 아니다. 따라서 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.\n또한, 무명 객체 즉, 익명 클래스 안에서 함수에 정의된 로컬 변수를 사용할 수도 있다.\n\n자바와 조금 다른 점이다. 자바는 익명 클래스에서 접근 시 무조건 final이어야 한다.\n\n\n\n참고\n\nKotlin In Action\nMade by Me\n\n","dateCreated":"2020-04-01T20:26:32+09:00","dateModified":"2020-08-05T15:42:04+09:00","datePublished":"2020-04-01T20:26:32+09:00","description":"목차\n\n클래스와 인터페이스\n뻔하지 않은 생성자와 프로퍼티\n데이터 클래스\n클래스 위임\nobject 키워드 사용\n","headline":"[Kotlin in action] Chap4. 클래스와 인터페이스","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"},"publisher":{"@type":"Organization","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg","logo":{"@type":"ImageObject","url":"Victory.jpeg"}},"url":"https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/","keywords":"Android, Kotlin, 코틀린, 프로그래밍 언어, Kotlin in Action"}</script>
    <meta name="description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용">
<meta name="keywords" content="Android,Kotlin,코틀린,프로그래밍 언어,Kotlin in Action">
<meta property="og:type" content="blog">
<meta property="og:title" content="[Kotlin in action] Chap4. 클래스와 인터페이스">
<meta property="og:url" content="https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-08-05T06:42:04.477Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Kotlin in action] Chap4. 클래스와 인터페이스">
<meta name="twitter:description" content="목차  클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [Kotlin in action] Chap4. 클래스와 인터페이스
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-04-01T20:26:32+09:00">
	
		    Apr 01, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/Kotlin-in-Action/">Kotlin in Action</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h2 id="목차">목차</h2>
<ul>
<li>클래스와 인터페이스</li>
<li>뻔하지 않은 생성자와 프로퍼티</li>
<li>데이터 클래스</li>
<li>클래스 위임</li>
<li>object 키워드 사용</li>
</ul>
<a id="more"></a>
<h3 id="411-코틀린-인터페이스">4.1.1 코틀린 인터페이스</h3>
<ul>
<li>인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"Show~"</span>) <span class="comment">// 디폴트 구현. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">Clickable &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = println(<span class="string">"Hi~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button().onClick()</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 이름 뒤에 콜론(:)을 붙여 인터페이스와 클래스 이름을 적는 것으로 상속과 인터페이스 구현을 모두 처리한다.
<ul>
<li>자바 : extends, implements</li>
</ul>
</li>
<li>자바와 마찬가지로 다중 구현은 허용되지만, 다중 상속은 불가능하다.</li>
<li>@Override 어노테이션과 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 한다는 뜻이다. 다만, override 변경자는 코틀린에서 꼭 표시해야 한다.</li>
<li>디폴트 구현을 제공할 수 있으며, 특별한 키워드를 붙이지 않고 메소드 본문을 적어주면 된다.
<ul>
<li>이 경우, Clickable을 구현하는 하위 클래스에서 showOff를 새롭게 정의할 수도 있고, 정의를 생략해서 디폴트 구현을 사용할 수도 있다.</li>
</ul>
</li>
<li>아래 코드를 함께 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setFocus</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm Focus"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이제 한 클래스에서 Clickable, Focusable  두 인터페이스를 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현이 들어있다.</li>
<li>결론은 어느 쪽의 showOff() 메소드도 호출되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 아래와 같은 컴파일 오류가 발생한다.</li>
</ul>
<blockquote>
<p>The class ‘Button’ must override public open fun showOff()</p>
<p>because it inherits many implementations of it.</p>
</blockquote>
<ul>
<li>코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 강제한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable</span>, <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br><span class="line">    <span class="keyword">super</span>&lt;Focusable&gt;.showOff()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>즉, 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 존재하는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다.</li>
<li>자바와 달리 상위 타입의 이름을 꺽쇠 괄호(&lt;&gt;) 사이에 넣어서 super를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.</li>
</ul>
<h3 id="412-open-final-abstract-변경자">4.1.2 open, final, abstract 변경자</h3>
<ul>
<li>자바에서는 기본적으로 상위 클래스에 대해 하위 클래스에서 상속하는 걸 막지 않는다. 막기 위해서는 final을 붙여 상속을 할 수 없게 한다.</li>
<li>기본적으로 상속이 가능하면 편리하지만, 문제가 생기는 경우도 있다.</li>
<li><code>취약한 기반 클래스</code> 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 존재한다.</li>
<li>즉, 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 <strong>취약</strong>하다.</li>
<li>이런 점을 보완하기 위해 코틀린에서는 클래스와 메소드는 기본적으로 <strong>final</strong>이다.</li>
<li>클래스의 상속을 허용하려면 클래스 앞에 <strong>open</strong> 변경자를 붙여야 한다.</li>
<li>오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 붙일 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RichButton</span> : <span class="type">Clickable&#123;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> </span><br><span class="line">  <span class="comment">// 오버라이드한 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 막을 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RichButton 클래스는 다른 클래스가 상속할 수 있다.(open)</li>
<li>disable() : final이며, 오버라이드 할 수 없다.</li>
<li>animate() : oepn으로 오버라이드 가능.</li>
<li>onClick() : 상위 클래스에서 선언된 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.</li>
</ul>
<ul>
<li>abstract로 선언한 추상 클래스는 인스턴스화 할 수 없으며, 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야 하는게 보통이다.</li>
<li>추상 멤버는 항상 열려 있기 때문에 open 변경자를 명시할 필요가 없다.</li>
</ul>
<p>Todo 표 추가</p>
<h3 id="413-가시성-변경자">4.1.3 가시성 변경자</h3>
<ul>
<li>코틀린의 기본 가시성은 자바와 다르며, 아무 변경자도 없는 경우 public이다.</li>
<li>자바의 기본 가시성인 package private이 없다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.</li>
<li>코틀린은 <code>internal</code>이라는 새로운 가시성을 도입했다.
<ul>
<li>이는 모듈 내부에서만 볼 수 있음을 뜻한다.</li>
<li>모듈 : 한 번에 한꺼번에 컴파일되는 파일들을 의미한다.</li>
<li>모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.</li>
</ul>
</li>
<li>코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다.</li>
</ul>
<blockquote>
<p>? 모듈에 대해 생각해볼 필요가 있어 보인다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>변경자</th>
<th>클래스멤버</th>
<th>최상위 선언</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>모든 곳에서 볼 수 있다.</td>
<td>모든 곳에서 볼 수 있다.</td>
</tr>
<tr>
<td>internal</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
</tr>
<tr>
<td>protected</td>
<td>하위 클래스에서만 볼 수 있다.</td>
<td>적용할 수 없음.</td>
</tr>
<tr>
<td>private</td>
<td>같은 클래스 안에서만 볼 수 있다.</td>
<td>같은 파일 안에서만 볼 수 있다.</td>
</tr>
</tbody>
</table>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span>: <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">"Hey~"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">wishper</span><span class="params">()</span></span> = println(<span class="string">"Let's talk!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">giveSpeech</span><span class="params">()</span></span>&#123;</span><br><span class="line">  yell()</span><br><span class="line">  </span><br><span class="line">  whisper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>public 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출함</p>
<ul>
<li>Public 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다.</li>
<li>이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다.</li>
<li>이는 일반적인 규칙에 해당한다.</li>
</ul>
</li>
<li>
<p>yell은 private이라 접근이 불가능.</p>
</li>
<li>
<p>whisper는 상속 관계에서 하위 클래스만 접근이 가능. 따라서 불가능.</p>
</li>
<li>
<p>컴파일 오류를 없애기 위해서는 TalkativeButton을 public으로 바꾸거나 giveSpeech 확장 함수의 가시성을 internal로 바꾸면 된다.</p>
</li>
<li>
<p><strong>자바와 달리 코틀린에서의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.</strong></p>
</li>
<li>
<p><strong>클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다는 사실을 알아야 한다.</strong></p>
</li>
</ul>
<blockquote>
<p>코틀린의 가시성 변경자와 자바</p>
</blockquote>
<p>코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트 코드 안에서도 그대로 유지된다.</p>
<p>유일한 예외는 private이며, 자바에서는 클래스를 private으로 만들 수 없으므로 코틀린은 내부적으로 private 클래스는 package private으로 컴파일한다.</p>
<p>internal은 자바에서 딱 맞는 가시성이 없다. package private과는 다르다. 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어있을 수도 있다. 따라서 internal은 자바 바이트 코드에서 public이 된다.</p>
<p>코틀린과 자바 선언에 차이가 존재하기 때문에 다음과 같은 접근이 가능하다.</p>
<ul>
<li>다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근 가능.</li>
<li>protected로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서 접근 가능.</li>
</ul>
<h3 id="414-내부-클래스와-중첩된-클래스">4.1.4 내부 클래스와 중첩된 클래스</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span>: <span class="type">Serializable</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State = ButtonState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ButtonState</span>: <span class="type">State&#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 내부 클래스</span></span><br><span class="line">  inner ButtonState: State&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서 ButtonState는 중첩 클래스에 해당되며 아무런 변경자가 붙지 않으면 자바의 static 중첩 클래스와 같다. 따라서 바깥쪽 클래스에 대한 참조가 없고, 이로 인해서 직렬화가 가능하다.</li>
<li>이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하고 싶으면 <code>inner</code> 변경자를 붙이면 된다. 이렇게 되면 <strong>NoSerializableException: Button</strong> 이라는 예외가 발생한다.
<ul>
<li>왜 Button을 직렬화할 수 없을까?</li>
<li>내부 클래스는 바깥쪽 클래스에 대한 참조를 포함한다. 그 참조로 인해 직렬화할 수 없다. Button 클래스가 직렬화할 수 있는 상태가 아니기 때문에 결론적으로 ButtonState도 직렬화할 수 없는 것이다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 알고 넘어가기~</p>
</blockquote>
<ul>
<li>내부 클래스 : 바깥쪽 클래스에 대한 참조를 갖는다.</li>
<li>중첩 클래스 : 바깥쪽 클래스에 대한 참조를 갖지 않는다.</li>
</ul>
<table>
<thead>
<tr>
<th>클래스 B안에 정의된 클래스 A</th>
<th>자바에서는</th>
<th>코틀린에서는</th>
</tr>
</thead>
<tbody>
<tr>
<td>중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음)</td>
<td>Static class A</td>
<td>class A</td>
</tr>
<tr>
<td>내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)</td>
<td>class A</td>
<td>inner class A</td>
</tr>
</tbody>
</table>
<h3 id="415-sealed-class">4.1.5 Sealed Class</h3>
<ul>
<li>
<p>기존에는 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 그래서 새로운 클래스에 대한 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 버그가 발생할 가능성이 높다.</p>
</li>
<li>
<p>해법을 제공한다. 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.</p>
</li>
<li>
<p>sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.</p>
</li>
<li>
<p>Sealed 클래스는 자동으로 open이다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">	<span class="keyword">when</span>(e)&#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Num -&gt; e.value</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>When 식이 모든 하위 클래스를 검사하므로 else 분기가 없어도 된다.</li>
<li>클래스 외부에 sealed 클래스 자신을 상속한 클래스를 둘 수 없다.</li>
<li>나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가하면 when 식이 컴파일되지 않는다. 따라서 식을 고쳐야 한다는 사실을 파악하기 쉽다.</li>
<li>내부적으로 Expr 클래스는 private 생성자를 갖는다. 그 생성자는 클래스 내부에서만 호출할 수 있다.</li>
</ul>
<h2 id="뻔하지-않은-생성자와-프로퍼티">[뻔하지 않은 생성자와 프로퍼티]</h2>
<ul>
<li>주 생성자 : 클래스를 초기화할 때, 주로 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다.</li>
<li>부 생성자 : 클래스 본문 안에서 정의한다.</li>
</ul>
<h3 id="421-클래스-초기화-주-생성자와-초기화-블록">4.2.1 클래스 초기화 : 주 생성자와 초기화 블록</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<ul>
<li>중괄호도 없고 괄호 사이에 val만 존재한다.</li>
<li>이처럼 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드는 <strong>주 생성자</strong>라 부른다.</li>
<li>주 생성자는 생성자 파라미터를 정의하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  init&#123;</span><br><span class="line">    nickname = _nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Constructor : 주 생성자나 부 생성자 정의를 할 때 사용되며, 주 생성자의 경우 어노테이션이나 가시성 변경자가 없으면 생략해도 된다.</li>
<li>Init : 초기화 블록으로 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다.</li>
<li>초기화 블록은 주 생성자와 함께 쓰인다. 이유는 주 생성자가 제한적이기 때문에 별도의 코드를 포함할 수 없기 때문!</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname = _nickname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 초기화 블록 없이 프로퍼티 선언에 초기화를 포함시킬 수 있다.</li>
<li>그렇다면 더 간단하게 할 수 있을까? 아래의 코드를 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> lee = User(<span class="string">"VictoryWoo"</span>) <span class="comment">// new 없이 바로 생성자 호출!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.</li>
<li>함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwitterUser</span></span>(name: String) : User(name)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>상위 클래스 초기화를 위해서 클래스 뒤에 괄호 안에 생성자로 인자를 넘긴다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Click</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadioButton</span>: <span class="type">Button</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> : <span class="type">Click</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Button : 별도의 생성자를 정의하지 않아 컴파일러가 자동으로 아무 일도 하지 않는 인자 없는 디폴트 생성자를 만든다.</li>
<li>RadioButton : Button 클래스를 상속했기 때문에 Button의 생성자를 호출해야 한다.</li>
<li>CustomView : Click이 인터페이스이므로 이름만 명시.</li>
</ul>
<h3 id="422-부-생성자">4.2.2 부 생성자</h3>
<ul>
<li>코틀린의 디폴트 값 + 이름 있는 인자를 사용해 생성자가 여럿 있는 경우 처리가 가능하다.</li>
<li><strong>인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말고 대신 파라미터의 디폴트 값을 생성자 시그니처에 명시하라.</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 디폴트 값을 넘겨 같은 클래스의 다른 생성자 호출. </span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context, WOO_STYLE)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)</span><br><span class="line">  	: <span class="keyword">super</span>(context, attr)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyButton에서는 super()를 통해 상위 클래스의 생성자를 호출함으로써 객체 생성을 위임한다.</li>
<li>클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다.</li>
</ul>
<blockquote>
<p>프로퍼티란?</p>
</blockquote>
<ul>
<li>
<p>코틀린은 프로퍼티를 언어의 기본 기능으로 제공.</p>
</li>
<li>
<p>이는 필드와 접근자를 통칭하는 것이다.</p>
</li>
<li>
<p>즉, 데이터를 저장하고 get, set이 가능함을 의미한다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린의 기본 가시성은 public이기 때문에 getter, setter도 동일하게 가져간다. 그런데, 필드에 저장된 데이터의 가시성은 public이 아니다. <strong>생성자에 선언된 데이터는 private이 된다.</strong></li>
</ul>
<p><code>Q. 외부에서 Person 객체를 생성한 뒤, name, isMarried에 접근이 가능할까??</code></p>
<p>— 고민의 시간 —</p>
<ul>
<li><strong>[반면, 일반 클래스 필드에 넣은 데이터는 private으로 지정해주지 않을 경우 public이 된다.]</strong> 라고 하는데 확인해 본 결과 필드에 넣은 데이터 또한 private으로 선언되며, getter가 public으로 지정된다.</li>
<li><strong>선언된 데이터가 private이 된다는 것은 자바 코드로 변환했을 때, 필드의 선언이 private이 되며 getter, setter는 public인 상태가 된다는 것을 의미한다.</strong> 만약, 생성자의 프로퍼티를 private으로 지정한다면 getter, setter도 private이 되어 접근이 불가능하다. (위의 질문에 대한 답이 된다.)</li>
</ul>
<p><strong>[생성자 파라미터의 val, var의 차이]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>1번의 경우 자바 코드로 변환되면 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.09.35](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.09.35.png)</p>
<ul>
<li>생성자에 있는 name은 프로퍼티가 되며, 외부에서도 접근이 가능하다.</li>
</ul>
<p>2번의 경우 자바 코드로 변환시 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.10.03](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.10.03.png)</p>
<ul>
<li>이 경우 name은 생성자에서 프로퍼티를 초기화하는 역할만을 하고, 사용할 수 없다. 따라서 클래스의 생성자 외 다른 메소드에서 사용할 수 없다. (프로퍼티가 아니기 때문)</li>
</ul>
<p><strong>[주의할 점]</strong></p>
<p>위에서 설명했지만, 한번 더 짚고 넘어간다.</p>
<p>디컴파일한 자바 코드를 보면 필드가 private으로 되어 있는 것을 볼 수 있다.</p>
<p>이렇다고 하더라도 코틀린의 프로퍼티가 private은 아니다. 여기서 우리는 <strong>필드와 프로퍼티를 다르게 인식할 줄 알아야 한다.</strong> 자바는 기본적으로 필드로 다루고, 코틀린은 프로퍼티(필드+접근자)를 기본으로 다루는 언어이기 때문에 약간의 차이가 존재한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">setName</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>필드인 name 자체만 보면 private 키워드가 붙어있으므로 private이 맞지만, 프로퍼티 전체를 보면 다르다. getter/setter로 접근이 모두 가능하기 때문에 프로퍼티는 private하다고 볼 수 없다.</p>
<p>위의 코드에서 name 프로퍼티가 private이기 위해서는 아래와 같이 수정해야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(@NotNull String name)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter/setter가 없어 프로퍼티는 private이라고 볼 수 있다.</p>
<ul>
<li><a href="https://wooooooak.github.io/kotlin/2019/05/24/property/" target="_blank" rel="noopener">참고</a></li>
</ul>
<h3 id="423-인터페이스에-선언된-프로퍼티-구현">4.2.3 인터페이스에 선언된 프로퍼티 구현</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인터페이스에 추상 프로퍼티 선언이 있고, 상태를 저장하기 위해서는 해당 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다.</li>
<li>아래는 각기 다른 방식으로 이를 구현한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String): User</span><br><span class="line"><span class="comment">// 주 생성자에 있는 프로퍼티</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribingUser</span></span>(<span class="keyword">val</span> email: String): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: String</span><br><span class="line">  	<span class="keyword">get</span>() = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 커스텀 게터</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> accountId: <span class="built_in">Int</span>): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname = getFacebookNam(accountId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 프로퍼티 초기화 식</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SubscribingUser</strong> : nickname은 매번 호출될 때마다 substringBefore()를 호출해 새로운 값을 계산하는 커스텀 getter를 사용한다.</li>
<li><strong>FacebookUser</strong> : nickname은 객체 초기화 시 계산한 데이터를 저장했다가 불러오는 방식을 이용한다.</li>
</ul>
<h3 id="424-게터와-세터에서-뒷받침하는-필드-접근">4.2.4 게터와 세터에서 뒷받침하는 필드 접근</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">"unspecified"</span></span><br><span class="line">        <span class="keyword">set</span>(value: String) &#123;</span><br><span class="line">            println(<span class="string">"""</span></span><br><span class="line"><span class="string">                Address was changed for <span class="variable">$name</span>:</span></span><br><span class="line"><span class="string">                "<span class="variable">$field</span>" -&gt; "<span class="variable">$value</span>"."""</span>.trimIndent())</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"Alice"</span>)</span><br><span class="line">    user.address = <span class="string">"Elsenheimerstrasse 47, 80687 Muenchen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setter 접근자의 본문에서 field를 통해 뒷받침하는 필드에 접근할 수 있다.(<strong>address</strong>)</li>
<li>getter는 field 값을 읽을 수만 있고, setter는 field 값을 읽거나 쓸 수 있다.</li>
</ul>
<h3 id="425-접근자의-가시성-변경">4.2.5 접근자의 가시성 변경</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addWord</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        counter += word.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lengthCounter = LengthCounter()</span><br><span class="line">    lengthCounter.addWord(<span class="string">"Hi!"</span>)</span><br><span class="line">    println(lengthCounter.counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>기본 가시성을 가지는 getter를 컴파일러가 생성하게 냅두고 setter의 가시성을 private으로 지정하여 외부 코드에서 단어 길이의 합을 마음대로 바꾸지 못하게 하였다.</li>
</ul>
<h2 id="컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임">[컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임]</h2>
<h3 id="431-모든-클래스가-정의해야-하는-메소드">4.3.1 모든 클래스가 정의해야 하는 메소드</h3>
<p>자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다.</p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>자바는 == 를 원시 타입과 참조 타입을 비교할 때 사용한다.</p>
<p>원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교하고, 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다. 따라서 자바에서 두 객체의 동등성을 알려면 equals()를 호출해야 한다.</p>
<p><strong>코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다.</strong> ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 따라서 클래스가 equals()를 오버라이드하면 == 을 통해 안전하게 클래스의 인스턴스를 비교할 수 있다.</p>
<p>참조 비교를위해서는. === 연산자를 사용할 수 있다.</p>
<p>=== 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 ==와 같다.</p>
<h3 id="432-data-class">4.3.2 data class</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>class 앞에 data를 붙이면 자동으로 toString(), copy(), equals(), hashCode()를 포함한다.</li>
<li>이를 데이터 클래스라고 부르며 주로 데이터를 저장하는 역할을 한다.</li>
<li>주의할 점은 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니다.</li>
</ul>
<p><strong>[copy() 메소드]</strong></p>
<ul>
<li>데이터 클래스의 프로퍼티가 모두 val일 필요는 없다. var여도 된다. 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어 불변 클래스로 만들라고 권장한다.</li>
<li>불변의 장점 : 다중 스레드에서 동기화를 고려하지 않아도 됨.</li>
<li>Copy() : 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해준다.</li>
<li>객체를 메모리 상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다.</li>
</ul>
<h3 id="433-클래스-위임-by">4.3.3 클래스 위임 : by</h3>
<ul>
<li>인터페이스를 구현할 때, by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingCollection</span>&lt;<span class="type">T</span>&gt;</span>(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러가 전달 메소드를 자동으로 생성하며, 자동 생성한 코드의 구현은 책에 실린 코드와 비슷하다.</li>
<li>Collection의 구현을 innerList에게 위임한다.</li>
<li>메소드 중 일부의 동작을 변경하고 싶을 때는 메소드를 오버라이드 하면 컴파일러가 오버라이드한 메소드를 쓴다.</li>
</ul>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()</span><br><span class="line">) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectsAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(c: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded += c.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cset = CountingSet&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    cset.addAll(listOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;cset.objectsAdded&#125;</span> objects were added, <span class="subst">$&#123;cset.size&#125;</span> remain"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>add, addAll을 오버라이드해서 count를 증가시키고 MutableCollection 인터페이스의 나머지 메소드는 내부 컨테이너인 innerSet에게 위임한다.</p>
</li>
<li>
<p>CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 생기지 않는다. CountingSet 코드는 위임 대상 내부 클래스인 MutableCollection의 API를 활용하므로 API를 변경하지 않는 한 CountingSet 코드가 계속 잘 작동할 것임을 확신할 수 있다.</p>
<p>-&gt; <strong>CountingSet의 생성자 파라미터에 존재하는 innerSet 프로퍼티에게 MutableCollection의 구현을 위임했기 때문에 CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 없다. innerSet이 MutableCollection에 의존 관계를 가지고 있다.</strong></p>
</li>
</ul>
<h2 id="object-키워드-클래스-선언과-인스턴스-생성">object 키워드 : 클래스 선언과 인스턴스 생성</h2>
<h3 id="441-객체-선언-싱글톤">4.4.1 객체 선언 : 싱글톤</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll&#123;</span><br><span class="line">  <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">calculateSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(person <span class="keyword">in</span> allEmployees)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object를 통해 기본적으로 싱글톤 기능을 언어 레벨에서 제공한다.</li>
<li>객체 선언 = 클래스 선언 + 그 클래스에 속한 단일 인스턴스의 선언</li>
<li>생성자는 쓸 수 없다. 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문에 생성자 정의가 필요없다.</li>
<li>object 선언도 클래스나 인터페이스 상속이 가능하다.</li>
<li>클래스 안에 object 선언도 가능하다. 이 객체도 인스턴스는 단 하나뿐이다. (바깥쪽 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 따로 하나씩 생기는 것이 아니다.)</li>
</ul>
<h3 id="442-동반-객체">4.4.2 동반 객체</h3>
<ul>
<li>kotlin에서는 static 개념이 존재하지 않는다.</li>
<li>패키지 수준의 최상위 함수가 정적 메소드 역할을 대신할 수 있다.  객체 선언은 정적 필드를 대신할 수도 있다.</li>
<li>최상위 함수를 권장하지만, 클래스에 비공개 멤버를 포함하면 이 멤버에 접근할 수 없다.</li>
<li>그래서 클래스의 인스턴스와 관계 없이 호출해야 하지만, 클래스 내부 정보에 접근해야 할 때 companion object를 사용하면 된다.</li>
<li>companion object는 외부 클래스의 private한 멤버 접근이 가능하기 때문에 팩토리 메소드를 만들 때 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"Companion object called"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    A.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>호출할 때, 클래스 이름으로 바로 호출이 가능하다.</li>
<li>이름을 따로 지정하지 않아도 되며, 사용 예를 보면 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.</li>
<li>즉, 자바의 static 함수 호출과 동일하다.</li>
</ul>
<p>Ex)</p>
<p><strong>부 생성자가 여럿 있는 클래스</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(email: String)&#123;</span><br><span class="line">    nickname = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(accountId: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    nickname = getFacebookName(accountId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>팩토리 메소드로 부 생성자 대신하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId:<span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> user = User.newSubscribinUser(<span class="string">"Victory@gmail.com"</span>)</span><br><span class="line">  println(user.nickname)</span><br><span class="line">  <span class="comment">// Victory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User는 private constructor를 가지기 때문에 외부에서 생성하지 못한다. 따라서 외부에서는 companion object로 제공되는 팩토리 메소드를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</li>
</ul>
<h3 id="433-동반-객체를-일반-객체처럼-사용">4.3.3 동반 객체를 일반 객체처럼 사용</h3>
<p>동반 객체 = 클래스 안에 정의된 일반 객체</p>
<p>따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object 이름 명명 가능.</li>
<li>companion object 내부에 확장 함수와 프로퍼티 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  Person.Loader.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">  Person.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 두 방법 모두 제대로 fromJson을 호출할 수 있다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : JSONFactory&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Person(<span class="string">"Lee"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">loadFromJSON</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    loadFromJSON(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 companion object가 특정 인터페이스를 구현할 수도 있고, <strong>동반 객체가 구현한 JSONFactory 인터페이스를 넘길 때 Person 클래스(외부 클래스)의 이름을 사용한다.</strong></p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다.</p>
<p>그런 경우 <code>@JvmStatic</code> 어노테이션을 코틀린 멤버에 붙이면 된다.</p>
<p>정적 필드가 필요하다면 <code>@JvmField</code> 어노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다.</p>
<p>이는 10장에서 더 자세히 알아보자!</p>
<p>동반 객체를 이용해 외부에서 확장 함수를 정의할 수 있다고 했다. 아래 코드를 통해서 확인해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.Companion.<span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person&#123;</span><br><span class="line">  <span class="comment">// 확장 함수 정의.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person.fromJSON(<span class="string">"json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>마치 동반 객체 안에 fromJSON을 정의한 것처럼 함수를 호출할 수 있다.</li>
<li>동반 객체에 대한 확장 함수를 정의하기 위해서는 원래 클래스에 동반 객체를 꼭 선언해야 한다.(비어있어도 괜찮다.)</li>
</ul>
<h3 id="444-무명-클래스">4.4.4 무명 클래스</h3>
<ul>
<li>무명 객체를 정의할 때도 object 키워드를 쓴다.</li>
<li>무명 객체는 자바의 무명 내부 클래스를 대신한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span> : ClickListener&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Clicked Listener!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Clicked!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  setClickAction(listener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object 선언과 달리 익명 클래스는 싱글톤이 아니다. 따라서 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.</li>
<li>또한, 무명 객체 즉, 익명 클래스 안에서 함수에 정의된 로컬 변수를 사용할 수도 있다.
<ul>
<li>자바와 조금 다른 점이다. 자바는 익명 클래스에서 접근 시 무조건 final이어야 한다.</li>
</ul>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li>Made by <a href="https://github.com/WooVictory" target="_blank" rel="noopener">Me</a></li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Android/">Android</a> <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin/">Kotlin</a> <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin-in-Action/">Kotlin in Action</a> <a class="tag tag--primary tag--small t-link" href="/tags/코틀린/">코틀린</a> <a class="tag tag--primary tag--small t-link" href="/tags/프로그래밍-언어/">프로그래밍 언어</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/02/KotlinInAction-Chap5/"
                    data-tooltip="[Kotlin in Action] Chap5. 람다"
                    aria-label="PREVIOUS: [Kotlin in Action] Chap5. 람다"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/01/KotlinInAction-Chap3/"
                    data-tooltip="[Kotlin in action] Chap3. 함수 정의와 호출"
                    aria-label="NEXT: [Kotlin in action] Chap3. 함수 정의와 호출"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/02/KotlinInAction-Chap5/"
                    data-tooltip="[Kotlin in Action] Chap5. 람다"
                    aria-label="PREVIOUS: [Kotlin in Action] Chap5. 람다"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/04/01/KotlinInAction-Chap3/"
                    data-tooltip="[Kotlin in action] Chap3. 함수 정의와 호출"
                    aria-label="NEXT: [Kotlin in action] Chap3. 함수 정의와 호출"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    
        <script>
          var disqus_config = function() {
            this.page.url = 'https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/';
              
            this.page.identifier = '2020/04/01/KotlinInAction-Chap4/';
              
          };
          (function() {
            var d = document, s = d.createElement('script');
            var disqus_shortname = 'https-woovictory-github-io';
            s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
    




    </body>
</html>
