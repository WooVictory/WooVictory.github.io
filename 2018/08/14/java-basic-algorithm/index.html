<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="AFirxOxuB2W32dZY1PrMx4c6K3RsM3XVAkRIkCJEEpI" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/android.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Java :: 기초 - VictoryWoo | Blog
        
    </title>

    <link rel="canonical" href="https://woovictory.github.io/2018/08/14/java-basic-algorithm/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/blaise-vonlanthen-433128-unsplash.jpg')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/null');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>Java :: 기초</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by VictoryWoo on
                            2018-08-14
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">VictoryWoo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">about</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <p>자바를 사용해서 알고리즘을 풀면서 더 좋은 방법에 대해서 생각해보고 찾아본 결과를 공부하는 공간입니다. 그리고 자바에 관련된 전공 질문을 함께 공부하면서 정리할 것입니다.</p>
<h1 id="객체지향-언어의-특징">객체지향 언어의 특징?</h1>
<hr>
<p>객체 지향 프로그래밍이란??</p>
<blockquote>
<p>Object Orientged Programming(OOP)</p>
</blockquote>
<p>객체 지향 프로그래밍 이전의 프로그래밍 패러다임을 살펴보면, 중심이 컴퓨터에 있었다. 컴퓨터가 사고하는대로 프로그래밍을 하는 것이다. 하지만, <code>객체지향 프로그래밍</code>이란 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 즉, 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것을 말한다. 현실 세계의 사물들을 <strong>객체</strong>라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 <code>추상화</code>라 한다.</p>
<p>객체 지향 프로그래밍이란 프로그램을 개발하는 기법으로, 부품에 해당하는 <code>객체</code>들을 먼저 만들고 이것들을 하나씩 조립 및 연결해서 전체 프로그램을 완성하는 기법을 말합니다. <strong>자바</strong>는 100% 객체 지향 언어이며, <strong>객체를 만들기 위해 설계도인 클래스를 작성하고 객체와 객체를 연결하여 목적에 맞는 프로그램을 만들어 냅니다.</strong></p>
<p><strong>OOP</strong>로 코드를 작성하면 이미 작성한 코드에 대한 <code>재사용성</code>이 높다. 자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보 할 수 있다. 또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 <strong>버그 발생이 줄어든다.</strong> 그리고 객체 단위로 코드가 나눠져 작성되기 때문에 <strong>디버깅이 쉽고 유지보수에 용이하다.</strong> 또한 <code>데이터 모델링</code>을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.</p>
<p><strong>객체 지향의 시작</strong></p>
<p>우리가 주변에서 사물을 인지하는 방식대로 프로그래밍할 수 있지 않겠는가 하는 것이 객체지향의 출발이다. 객체 지향에서 객체를 다음과 같이 정의한다. 세상에 존재하는 모든 것은 객체이며 각각의 객체는 고유하다. 또한, 객체는 어떠한 속성을 갖고 어떠한 행위를 한다. 이에 따라 객체의 속성을 property로 정의하고 행위를 method로 정의한다.</p>
<p>객체 지향은 어떤 특성을 갖고 있는가?</p>
<blockquote>
<p>캡슐화 : 정보은닉<br>
상속 : 재사용<br>
추상화 : 모델링<br>
다형성 : 사용 편의</p>
</blockquote>
<h2 id="클래스란">클래스란?</h2>
<p>클래스는 <strong>분류에 대한 개념을 정의해둔 것</strong>이다. 객체는 말 그대로 실체다.<br>
프로그래밍 상에서 클래스를 기반으로 객체화된 것을 인스턴스라고 한다.</p>
<h2 id="객체-지향적-설계-원칙">객체 지향적 설계 원칙</h2>
<ol>
<li><code>SRP</code>(Single Responsibility Priciple) : 단일 책임 원칙<br>
클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.</li>
<li><code>OCP</code>(Opne-Closed Principle) : 개방-폐쇄 원칙<br>
확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.</li>
<li><code>LSP</code>(Likov Substitution Principle) : 리스코프 치환 원칙<br>
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.</li>
<li><code>ISP</code>(Interface Segregation Principle) : 인터페이스 분리 원칙<br>
인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.</li>
<li><code>DIP</code>(Dependency Inversion Principle) : 의존 역전 원칙<br>
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li>
</ol>
<h2 id="객체-지향-언어의-특징">객체 지향 언어의 특징</h2>
<ol>
<li><code>상속</code><br>
객체 지향의 가장 대표적인 특성으로 특정 객체의 성격을 다른 객체가 상속받아 사용할 수 있도록 하는 것입니다. 클래스를 설계할 때, 공통적으로 필요한 성격들을 기본적인 클래스에 정의해 두면 다른 클래스를 작성할 때 공통적인 내용을 담은 클래스에서 상속 받아 사용할 수 있습니다.<br>
이미 만들어진 클래스를 파생시켜 새로운 클래스를 정의하는 기법<br>
파생된 클래스는 기존 클래스의 모든 속성과 동작을 물려받음<br>
필요한 기능을 추가하거나 필요 없는 기능을 제거 또는 변경 가능<br>
객체를 아무리 추상적으로 잘 정의해 놓았다 하더라도 현실의 문제는 특수하기 때문에<br>
모든 경우에 일반적으로 적용되지는 않을 경우 -&gt; 객체를 상속받아 원하는 부분만 		수정할 수 있으며 기존 객체를 최대한 재활용함으로써 시간과 노력을 절약 가능</li>
</ol>
<p>추가적인 내용이 필요함 ~ ing</p>
<h1 id="기본형과-참조형의-차이점은">기본형과 참조형의 차이점은?</h1>
<hr>
<h1 id="멀티-쓰레드의-장단점">멀티 쓰레드의 장단점?</h1>
<hr>
<h1 id="java-collection의-대표-인터페이스">Java Collection의 대표 인터페이스</h1>
<hr>
<h1 id="접근-제어-지시자의-종류와-특성에-대하여-설명">접근 제어 지시자의 종류와 특성에 대하여 설명</h1>
<hr>
<p>이 부분은 자세히 설명한 부분이 있습니다.<br>
제어자는 <a href="https://woovictory.github.io/2018/08/12/java-basic-7/">Java :: 제어자에서 확인가능 합니다.</a></p>
<h1 id="thread를-구현하기-위한-두가지-방법은">Thread를 구현하기 위한 두가지 방법은?</h1>
<hr>
<h1 id="인터페이스란">인터페이스란?</h1>
<hr>
<h1 id="abstract-class란">abstract class란?</h1>
<hr>
<h1 id="garbage-collection이란">Garbage Collection이란?</h1>
<hr>
<h1 id="vector와-arraylist">Vector와 ArrayList?</h1>
<hr>
<h1 id="전역지역클래스-변수를-스택과-힙과-관련해서-설명">전역/지역/클래스 변수를 스택과 힙과 관련해서 설명</h1>
<hr>
<ul>
<li><strong>메모리 구조</strong></li>
</ul>
<p>모든 자바 프로그램은 자바 가상 머신(JVM)을 통해서 실행됩니다. 자바 프로그램이 실행되면, JVM은 운영 체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리를 할당받습니다.<br>
이렇게 할당받은 메모리를 <strong>JVM</strong>은 용도에 따라 다음과 같이 구분하여 관리합니다.</p>
<img src="/img/memory_jvm.png" width="400" height="200">
<ol>
<li>메소드(method) 영역</li>
</ol>
<p>메소드 영역은 자바 프로그램에서 사용되는 <strong>클래스에 대한 정보</strong>와 함께 <strong>클래스 변수</strong>(static variable)가 저장되는 영역입니다. JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)을 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장합니다.</p>
<ol start="2">
<li>힙(heap) 영역</li>
</ol>
<p>힙(heap) 영역은 자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역입니다. JVM은 자바 프로그램에서 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장합니다.<br>
힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.</p>
<ol start="3">
<li>스택(stack) 영역</li>
</ol>
<p>스택(stack) 영역은 자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역입니다.<br>
JVM은 자바 프로그램에서 메소드가 호출되면, 메소드의 호출과 관계되는 <strong>지역 변수</strong>와 <strong>매개변수</strong>를 스택 영역에 저장합니다. 이렇게 스택 영역은 메소드의 호출과 함께 할당되며, 메소드의 호출이 완료되면 소멸합니다. 이렇게 스택 영역에 저장되는 메소드의 호출 정보를 <code>스택 프레임</code>(stack frame)이라고 합니다.</p>
<p>스택 영역은 <strong>푸시(push)</strong>  동작으로 데이터를 저장하고, <strong>팝(pop)</strong> 동작으로 데이터를 인출합니다. 이러한 스택은 <code>후입선출(LIFO, Last-In-First-out)</code> 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다. 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당됩니다.</p>
<h2 id="선언-위치에-따른-변수의-종류">선언 위치에 따른 변수의 종류</h2>
<hr>
<p>자바에서의 변수는 <strong>클래스 변수, 인스턴스 변수, 지역 변수</strong>가 있습니다. 변수의 종류를 결정짓는 것은 <code>변수가 선언된 위치</code>입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iv; <span class="comment">// 인스턴스 변수</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cv; <span class="comment">// 클래스 변수</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lv; <span class="comment">// 지역 변수</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iv와 cv는 클래스 내부에 선언되어 있으므로 <strong>멤버 변수</strong>입니다. 그 중 cv는 static으로 선언되었으니 <strong>클래스 변수</strong>이고, iv는 <strong>인스턴스 변수</strong>입니다. lv는 메소드 내에 선언되어 있으므로 <strong>지역 변수</strong>입니다.</p>
<img src="/img/instance_variable.png" width="800" height="200">
<ol>
<li>
<p><strong>인스턴스 변수</strong><br>
<strong>인스턴스 변수</strong>는 인스턴스가 생성될 때 생성됩니다. 그렇기 때문에 인스턴스 변수의 값을 읽어오거나 저장하려면 인스턴스를 먼저 생성해야 합니다. 인스턴스는 <strong>독립적인 저장공간</strong>을 가지므로 인스턴스 별로 다른 값을 가질 수 있으므로, 각각의 인스턴스마다 고유의 값을 가져야할 때는 인스턴스 변수로 선언합니다. - 힙 영역</p>
</li>
<li>
<p><strong>클래스 변수</strong><br>
클래스 변수는 인스턴스 변수에 <code>static</code> 키워드을 붙여주면 됩니다. 인스턴스 변수는 고유한 값을 가지지만 클래스 변수는 <strong>모든 인스턴스가 공통된 값을 공유하게 됩니다.</strong> 한 클래스의 모든 인스턴스들이 공통적인 값을 가져야할 때 클래스 변수로 선언합니다. 클래스가 로딩될 때 생성되어(<code>그러므로 메모리에 딱 한번만 올라갑니다.</code>) 종료 될 때까지 유지되는 클래스 변수는 <strong>public</strong>을 붙이면 같은 프로그램 내에서 어디서든 접근할 수 있는 전역 변수가 됩니다. 또한 인스턴스 변수의 접근법과 다르게 인스턴스를 생성하지 않고 <code>클래스 이름.클래스 변수명</code>을 통해서 접근할 수 있습니다. - 메소드 영역</p>
</li>
<li>
<p><strong>지역 변수</strong><br>
메소드 내에서 선언되며 메소드 내에서만 사용할 수 있는 변수입니다. 메소드가 실행될 때 메모리를 할당받으며 메소드가 끝나면 소멸되어 사용할 수 없게 됩니다. - 스택 영역</p>
</li>
</ol>
<h1 id="inner-class란-사용하는-이유">inner class란? 사용하는 이유?</h1>
<hr>
<h1 id="java-reflection이란-사용하는-이유">Java Reflection이란? 사용하는 이유?</h1>
<hr>
<h1 id="예외처리의-필요성과-목적">예외처리의 필요성과 목적</h1>
<hr>
<h1 id="jvm의-구성에-대해-설명">JVM의 구성에 대해 설명</h1>
<hr>
<p><code>자바</code>는 C언어에 객체 지향적 기능을 추가하여 만든 C++과는 달리 처음부터 <strong>객체 지향 언어</strong>로 개발된 프로그래밍 언어입니다.또한, 자바는 <code>자바 가상 머신(JVM)</code>을 사용하여, 운영체제와는 독립적으로 동작할 수 있습니다. 따라서 어느 운영체제에서나 같은 형태로 실행될 수 있습니다. 그리고 자바는 전 세계에서 가장 많이 사용하는 프로그래밍 언어 중 하나입니다.</p>
<h2 id="java-programming">Java Programming</h2>
<hr>
<p>자바 프로그램의 실행 과정은 다음과 같은 순서로 실행됩니다.</p>
<img src="/img/java_programming.png" width="600" height="300">
<ul>
<li>
<p><strong>Java compiler</strong> : Java를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 <strong>자바 바이트 코드</strong>로 변환합니다. 자바 컴파일러는 자바를 설치하면 javac.exe라는 실행 파일 형태로 설치됩니다.</p>
</li>
<li>
<p><strong>Java bytecode</strong> : <code>자바 바이트 코드</code>란 자바 가상 머신이 이해할 수 있는 언어로 변환된 <strong>자바 소스 코드</strong>를 의미합니다. 자바 컴파일러에 의해서 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불리고 있습니다. 이러한 Java bytecode의 확장자는 .class 입니다.<br>
Java bytecode는 자바 가상 머신(JVM)이 설치되어 있다면, 어떤 운영체제에서라도 실행될 수 있습니다.</p>
</li>
<li>
<p><strong>자바 가상 머신(JVM)</strong> : JVM이란 Java bytecode를 실행시키기 위한 가상의 기계라고 할 수 있습니다. 자바로 작성된 모든 프로그램은 JVM에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 반드시 JVM이 설치되어 있어야 합니다.</p>
</li>
<li>
<p><strong>JVM의 구성</strong></p>
</li>
</ul>
<ol>
<li><strong>Java interpreter</strong><br>
Java compiler에 의해 변환된 Java bytecode를 읽고 해석하는 역할을 합니다.</li>
<li><strong>class loader</strong><br>
자바는 동적으로 클래스를 읽어오므로, 프로그램이 실행 중인 런타임에서야 모든 코드가 자바 가상 머신과 연결됩니다. 이렇게 동적으로 클래스를 로딩해주는 역할을 하는 것이 바로 class loader 입니다.</li>
<li><strong>JIT 컴파일러(Just-In-Time compiler)</strong><br>
프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러를 의미합니다. 동적 번역(dynamic translation)이라고도 불리는 이 기법은 프로그램의 <strong>실행 속도</strong>를 향상시키기 위해 개발되었습니다.<br>
즉, <code>JIT 컴파일러는</code> 자바 컴파일러가 생성한 자바 바이트 코드를 런타임에 바로 기계어로 변환하는 데 사용합니다.</li>
<li><strong>garbage collector</strong><br>
더는 사용하지 않는 메모리를 자동으로 회수해 줍니다. 따라서 개발자가 따로 메모리를 관리하지 않아도 되므로, 더욱 손쉽게 프로그래밍을 할 수 있도록 도와줍니다.</li>
</ol>
<img src="/img/JVM.png" width="600" height="300">
<p>위의 그림처럼 서로 다른 운영체제라도 <strong>JVM</strong>만 설치되어 있다면, 같은 자바 프로그램이 아무런 추가 조치 없이 동작할 수 있습니다. 따라서 개발자는 한 번만 프로그램을 작성하면, <strong>모든 운영체제에서 같이 사용할 수 있는 장점</strong>이 있습니다.</p>
<p>단, 자바 프로그램과는 달리 JVM은 운영체제에 종속적이므로, 각 운영체제에 맞는 JVM을 설치해야 합니다. 또한, 자바 프로그램은 일반 프로그램보다 JVM이라는 한 단계를 더 거쳐야 하므로, <strong>상대적으로 실행 속도가 느린 단점</strong>이 존재합니다.</p>
<p>내용 더 추가해야 함</p>
<h1 id="입력">입력</h1>
<hr>
<p><strong>Scanner</strong>와 <strong>BufferedReader</strong>에 대해서 알고리즘을 풀 때 입력시 속도 측면에서 얼마나 차이가 나는지에 대해 알아보고자 합니다.</p>
<p>자바에서는 입력을 받을 때 보통은 아래와 같은 두 가지를 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>1번과 같은 방법으로 우리는 아주 간편하게 코드를 작성함으로써 <strong>Scanner</strong>를 사용하여 입력을 받을 수 있습니다.그러나 <strong>Scanner의 경우 사용하기 편리하지만 속도가 느리다</strong>는 단점이 있습니다. 아래의 코드를 통해서 Scanner가 1~100만까지 데이터를 입력받는 것은 시간이 얼마나 걸리는지 확인해보았습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inputExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">long</span> st1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            t= sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"소요 시간 : "</span>+(System.currentTimeMillis() - st1)+<span class="string">"ms"</span>);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">소요시간 : <span class="number">2441</span>ms</span><br></pre></td></tr></table></figure>
<p>소요 시간은 약 2.5초가 소요되었습니다. 100만개를 입력받는데 2.5초라고 놓고 보면 빠른 것 같지만, 알고리즘 사이트의 경우에는 최대 입력받는 데이터가 천만~1억에 이르는 경우도 종종 있다고 합니다. 그리고 무엇보다 다른 연산시간까지 고려하면 결코 뛰어난 성능이라고는 할 수 없습니다.</p>
<p>2번과 같은 방법은 <strong>BufferedReader로 한줄을 통째로 입력받는 방법</strong>입니다. Scanner에 비해서 이것 저것 <strong>선언해야할 것이 많아 번거롭지만 비교적 빠를 수 있다는 장점</strong>이 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">String s = bf.readLine(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> a = bf.read(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(bf.readLine()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>1 : 입력받을 값이 String일 때<br>
2 : 입력받을 값이 int일 때<br>
3 : int 값 + enter 까지 입력받을 때</p>
<p>알고리즘 사이트에서 대부분의 데이터 입력은 한줄씩 띄워진 상태로 입력이 들어옵니다. 따라서 <strong>int b</strong>를 입력받은 방법처럼 일단 스트링으로 개행문자(엔터)까지 포함해 통째로 받아온 다음 형 변환을 통해 저장합니다.</p>
<p>또한 new BufferedReader(new InputStreamReader(<a href="http://System.in" target="_blank" rel="noopener">System.in</a>),1024); 이렇게 버퍼 사이즈를 직접 지정할 수도 있는데, 아무것도 지정하지 않을 시 디폴트 사이즈 버퍼를 갖습니다. 어지간한 문제는 디폴트 사이즈로 충분하다고 하네요… ㅎㅎ;</p>
<p>BufferedReader를 이용해 100만개의 값을 입력받는 코드는 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inputExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        bf.readLine();</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">long</span> st2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            t = Integer.parseInt(bf.readLien());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"소요 시간 : "</span>+(System.currentTimeMillis() - st2)+<span class="string">"ms"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>소요 시간은 Scanner의 1/6 수준인 약 0.4초 정도밖에 걸리지 않았습니다. 사실, <strong>BufferedReader</strong>는 한 줄을 통째로 입력받는 방식이기 때문에<br>
1 2 3 4 5 6 7 8 9 10 11 … 과 같이 한 줄로 입력이 들어올 때 Scanner에 비해 훨씬 성능이 더 높아집니다.</p>
<p>따라서 알고리즘 문제를 풀고 제출할 때 코드 상에서 문제가 없음에도 불구하고 시간초과가 난다면 Scanner에서 BufferedReader로 바꿔 제출해보면 됩니다.</p>
<h1 id="stringbuilder-stringformat-string-클래스">StringBuilder, String.format, String 클래스</h1>
<hr>
<p>Java의 String, StringBuffer, StringBuilder에 대해서 알고리즘을 풀면서 다른 점을 확실하게 알 지 못했습니다. 그래서 여러가지 자료를 찾고 구글에 검색해보다가 깔끔하게 정리한 글을 보고 참고하여 작성하였습니다. 여기서는 <code>왜?</code>, <code>어떻게?</code>를 설명하고 있습니다.</p>
<h1 id="stirngstringbufferstringbuilder-특징-및-차이점">Stirng,StringBuffer,StringBuilder 특징 및 차이점</h1>
<p>Java에서 문자열을 처리하는 클래스는 String, StringBuilder, StringBuffer이 있습니다. 이 세 가지 클래스의 특징과 차이가 무엇인지 요약하자면, 세 가지 클래스는 모두 문자열을 처리하는 클래스입니다. 문자열을 더하는 연산을 할 때 성능의 차이가 발생하는데 String 클래스가 <strong>StringBuffer, StringBuilder</strong>보다 느리고 메모리 관리 측면에서도 큰 차이를 보입니다. 따라서 문자열의 더하기 연산을 이용할 때는 <strong>StringBuffer</strong> 혹은 <strong>StringBuilder</strong>의 사용을 고려해봐야 합니다.</p>
<p>StringBuffer와 StringBuilder는 기능이 동일하지만 한 가지 차이점이 존재합니다. 바로 <strong>동기화</strong> 처리 문제입니다.</p>
<ul>
<li>StringBuffer : 동기화를 지원하여 멀티 스레드 환경에서 안전하게 동작합니다.</li>
<li>StringBuilder : 동기화를 지원하지 않습니다. 따라서 단일 스레드 환경에서 안전하게 동작합니다.</li>
</ul>
<p>따라서 단일 스레드 환경에서는 <strong>StringBuilder</strong>를 사용하고, 멀티 스레드 환경에서는 <strong>StringBuffer</strong>를 사용하는 것이 권장됩니다. 굳이 두 클래스의 성능을 비교하자면 단일 스레드 환경에서 <strong>StringBuilder</strong>가 <strong>StringBuffer</strong>보다 빠르게 동작합니다.</p>
<h2 id="문자열을-추가하는-연산에서-string가-느린-이유">문자열을 추가하는 연산에서 String가 느린 이유</h2>
<blockquote>
<p>String 클래스가 StringBuffer 혹은 StringBuilder 클래스보다 성능이 떨어지는 이유는 무엇일까요?</p>
</blockquote>
<p>바로 String 클래스의 <code>immutable</code> 특성 때문입니다. <strong>immutable</strong>이란 변경할 수 없는, 불변의 라는 뜻으로 String의 value 값은 한 번 생성되면 변경될 수 없습니다.</p>
<p>Java 8 API 문서의 일부분을 보게 되면 String 클래스는 문자열을 나타냅니다. 자바에서 &quot;abc&quot;와 같은 모든 리터럴 문자열은 String의 <strong>인스턴스</strong>로 생성됩니다. 이는 상수이고 이 값은 한 번 생성되면 변경될 수 없습니다. thread safe하기 때문에 여러 스레드들이 공유하여 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"aa"</span>;</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">a = a+b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>a와 b의 초기화 방식을 다르게 작성한 이유는 두 코드가 똑같이 동작하는 것을 보여주기 위함입니다. 앞에서 모든 리터럴 문자열은 String 인스턴스로 생성된다고 했습니다. 따라서 <code>String a = &quot;aa&quot;;</code> 는 <code>String b = new String(&quot;bb&quot;);</code>와 같은 동작을 하는 코드가 됩니다.</p>
</blockquote>
<p>위의 두 줄의 코드가 실행되면 “aa”, “bb” 라는 문자열에 대해 메모리가 할당되고 a,b라는 변수가 각각 그 값을 참조하게 됩니다.</p>
<p><code>a = a + b;</code>가 실행된 후에는 어떻게 될까요??</p>
<p>String 클래스는 <strong>immutable</strong>합니다. 즉, 값이 불변합니다. a가 참조하고 있는 공간에 “aa” 대신에 &quot;aabb&quot;라는 값으로 바꿔주는 것이 아니라 &quot;aabb&quot;에 대해 새로운 String 인스턴스를 생성하여 a가 참조하도록 합니다. 이전에 참조하던 &quot;aa&quot;는 쓰레기가 되고 나중에 가비지 컬렉션에 의해 처리됩니다. 바로 이러한 이유 때문에 더 많은 시간과 메모리가 소요되는 것입니다. 연산을 많이 할수록 이런 성능 차이는 더욱 심해집니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stringExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"a"</span>;</span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"bb"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"a | value: %-4s, address: %s\n"</span>, a, a.hashCode());</span><br><span class="line">        System.out.printf(<span class="string">"b | value: %-4s, address: %s\n"</span>, b, b.hashCode());</span><br><span class="line"></span><br><span class="line">        a = a+b;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"a | value: %-4s, address: %s\n"</span>, a, a.hashCode());</span><br><span class="line">        System.out.printf(<span class="string">"b | value: %-4s, address: %s\n"</span>, b, b.hashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 결과</span></span><br><span class="line">a | value: a   , address: <span class="number">97</span></span><br><span class="line">b | value: bb  , address: <span class="number">3136</span></span><br><span class="line">a | value: abb , address: <span class="number">96353</span></span><br><span class="line">b | value: bb  , address: <span class="number">3136</span></span><br></pre></td></tr></table></figure>
<p>실행 결과를 보면 처음에는 a에 <code>97</code>이라는 주소가 할당되었는데 덧셈 연산 이후에 <code>96353</code>으로 새로운 메모리 공간이 할당된 것을 확인할 수 있습니다.</p>
<h2 id="stringbuffer-stringbuilder와-비교한-string-클래스의-장점">StringBuffer, StringBuilder와 비교한 String 클래스의 장점</h2>
<p>StringBuffer와 StringBuilder가 String보다 성능이 그렇게 좋다면 String을 사용하지 않고 StringBuffer와 StringBuilder를 사용하면되는데 왜 String을 사용하는지 의문이 들 것입니다. 당연히 String만의 장점이 있고 Java에서 세 가지의 클래스를 따로 제공하는 이유가 있을 것입니다.</p>
<p><strong>String</strong> 클래스는 <code>immutable</code> 속성을 가짐으로써 안전하다고 했습니다. 값이 변경되지 않기 때문에 여러 스레드가 데이터를 공유하더라도 동기화를 신경쓸 필요가 없이 안정성이 유지되는 장점이 있습니다. 그리고 StringBuffer, StringBuilder 클래스에서도 String 클래스를 이용합니다. <code>toString()</code> 메소드의 경우, StringBuffer, StringBuilder의 <code>toString()</code>가 호출되면 해당 문자열에 대한 String 객체를 생성해서 반환합니다. <strong>따라서, 연산이 적게 사용되고, 문자열 값의 수정 없이 읽기가 많은 경우에는 String 클래스의 사용이 더 적절합니다.</strong></p>
<h2 id="stringbuffer-stringbuilder가-string보다-문자열-연산에서-좋은-성능을-보이는-방법">StringBuffer, StringBuilder가 String보다 문자열 연산에서 좋은 성능을 보이는 방법</h2>
<p>그렇다면 StringBuffer와 StringBuilder는 어떻게 구혀되어 있길래 그렇게 많은 성능 차이를 보일까요??</p>
<p>String 클래스가 덧셈 연산에서 좋지 않은 성능을 보이는 이유는 연산이 수행될 때마다 두 문자열을 모두 읽어 들이고 새로운 메모리에 복사하기 때문이었습니다. StringBuffer, StringBuilder에서도 마찬가지로 문자열 복사를 하긴 하지만 <strong>가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사합니다.</strong></p>
<blockquote>
<p>배열의 크기를 무한정으로 지정할 수 없기 때문에 어느 클래스에서든 배열의 크기를 넘어서는 문자열을 합치려고 하면 문자열의 복사는 불가피합니다.</p>
</blockquote>
<p>StringBuffer, StringBuilder는 모두 <strong>AbstractStringBuilder</strong>라는 추상 클래스를 상속 받아 구현되어있습니다.</p>
<p><strong>멤버 변수</strong></p>
<ul>
<li>문자열 값을 저장하는 char형 배열 <code>value</code></li>
<li>현재 문자열 크기의 값을 가지는 int형의 <code>count</code></li>
</ul>
<p><strong>append()</strong></p>
<p>StringBuffer, StringBuilder에서는 + 연산 대신에 <code>append()</code>라는 함수를 이용합니다.<br>
value에 사용되지 않고 남아있는 공간에 새로운 문자열이 들어갈 정도의 크기가 있다면 그대로 삽입합니다. 그렇지 않다면 value 배열의 크기를 두배로 증가시키면서 기존의 문자열을 복사하고 새로운 문자열을 삽입합니다.</p>
<p><strong>예시</strong></p>
<ol>
<li>
<p>StringBuilder sb = new StringBuilder();</p>
<ul>
<li>StringBuilder 를 생성할 때 capacity를 지정하지 않으면 기본 16으로 설정됩니다.</li>
<li>따라서 value의 크기는 16, 값은 비어있게 되고</li>
<li>count는 0으로 초기화됩니다.</li>
</ul>
</li>
<li>
<p>sb.append(“first string”);</p>
<ul>
<li>“first string” 이라는 문자열의 크기는 12이고 value는 비어있으므로 수용공간 16보다 작으므로 아무런 문자열의 복사 없이 바로 추가됩니다.</li>
<li>value의 값은 &quot;first string&quot;이 되고,</li>
<li>count는 12로 갱신됩니다.</li>
</ul>
</li>
<li>
<p>sb.append(&quot;+second string&quot;);</p>
<ul>
<li>&quot;second string&quot;의 크기는 14, value에 남아있는 공간이 4밖에 되지 않으므로 배열의 크기를 늘려줘야 합니다.</li>
<li>value의 크기를 두배(32)로 늘리고 기존의 문자열을 복사합니다. 새로운 문자열까지 더해주면 value의 값은 &quot;first string+second string&quot;이 됩니다.</li>
<li>count는 26으로 갱신됩니다.</li>
</ul>
</li>
</ol>
<p>실제로는 위의 설명보다 조금 더 복잡하게 구현되어 있지만 핵심적인 부분은 동일합니다. 이런식으로 StringBuffer와 StringBuilder는 문자열을 더하더라도매번 문자열을 복사할 필요가 없어서 성능을 높일 수 있습니다.</p>
<h1 id="eof">EOF</h1>
<hr>
<p>EOF란? <strong>End Of File</strong>의 약자로 파일의 끝을 의미합니다. 즉, 데이터로부터 더 이상 읽을 수 있는 데이터가 없다는 것을 뜻합니다.</p>
<p>알고리즘 문제를 풀다보면 테스트 케이스의 갯수가 정해져있지 않고 입력이 없을 때까지 입력을 받는 문제들이 있습니다. 이럴 경우에 <strong>EOF</strong>까지 어떻게 입력을 받는지 정리해보았습니다.</p>
<ol>
<li>Scanner</li>
<li>BufferedReader</li>
</ol>
<ul>
<li>Scanner의 경우</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">    <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(sc.haxNextInt())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BufferedReader의 경우</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String input = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span>((input = bf.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="scanner에-대해서">Scanner에 대해서</h1>
<hr>
<p>자바를 사용해 알고리즘을 풀 때, 사용자로부터 입력받기 위해서는 가장 일반적인 두 가지 방법을 사용할 수 있습니다.</p>
<ol>
<li>Scanner</li>
<li>BufferedReader</li>
</ol>
<p>BufferedReader는 Scanner에 비해 속도는 빠르지만, 초반에 선언해야할 것들이 많아서 꺼려하시는 분들이 있습니다. 그래도 BufferedReader에 익숙해지시면 편합니다. :)</p>
<p>본론으로 돌아와서 Scanner의 문자열 입력 방법에 대해서 제가 공부한 것을 작성하려고 합니다. 알고리즘 문제를 풀다보면 문자열을 입력받는데, 공백을 포함해서 입력받는 경우와 공백을 포함하지 않고 입력을 받는 경우가 있습니다. 이런 경우에 <strong>Scanner</strong>를 이용해서 쉽게 해결할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">String a = sc.nextLine();</span><br><span class="line">String b = sc.next();</span><br></pre></td></tr></table></figure>
<p><strong>a</strong>는 <code>sc.nextLine()</code>을 통해서 입력을 받습니다. 이것은 '한 줄을 통째로 입력받겠다’는 의미인데요, 즉, 공백을 입력해도 공백까지 포함해서 한 줄을 입력받겠다는 의미입니다. &quot;abc is alphabet&quot;이라고 입력하면 공백을 포함해서 그대로 &quot;abc is alphabet&quot;이라고 출력하게 됩니다.</p>
<p><strong>b</strong>는 <code>sc.next()</code>를 통해서 입력을 받습니다. 이것은 '공백 이전까지의 문자열을 입력받겠다’는 의미입니다. 즉, 공백을 포함해서 &quot;abc is alphabet&quot;이라고 입력하면 출력 결과로는 &quot;abc&quot;만 출력하게 됩니다.</p>
<h1 id="오버로딩과-오버라이딩">오버로딩과 오버라이딩</h1>
<hr>
<blockquote>
<p>오버로딩 vs 오버라이딩</p>
</blockquote>
<p>자바에서 다형성을 지원하는 방법으로 <code>메소드 오버로딩(Overloading)</code>과 <code>메소드 오버라이딩(Overriding)</code>이 있습니다.</p>
<p>사실 오버로딩과 오버라이딩은 이름이 참 헷갈립니다… 그래서 많은 실수를 하곤 하죠. 헷갈리지 않기 위해서 정리해보고자 합니다.</p>
<ul>
<li><code>오버로딩(Overloading)</code> : 같은 이름의 메소드를 여러 개 가지면서 매개변수의 갯수와 타입을 다르게 해서 정의하는 것</li>
<li><code>오버라이딩(Overriding)</code> : 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 즉, 자식 클래스에서 재정의해서 사용하는 것</li>
</ul>
<p>이렇게 둘의 개념이 다른데도 오버로딩과 오버라이딩을 헷갈립니다. 이번 기회에 헷갈리지 않도록 개념 잘 잡고 나아가면 좋을 것 같습니다.</p>
<img src="/img/rules.png" width="600" height="200">
                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/08/17/java-basic-9/" data-toggle="tooltip" data-placement="top" title="Java ::  9) 상속">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/08/13/java-basic-8/" data-toggle="tooltip" data-placement="top" title="Java :: 8) 클래스 멤버">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#객체지향-언어의-특징"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">객체지향 언어의 특징?</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#클래스란"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">클래스란?</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#객체-지향적-설계-원칙"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">객체 지향적 설계 원칙</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#객체-지향-언어의-특징"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">객체 지향 언어의 특징</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#기본형과-참조형의-차이점은"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">기본형과 참조형의 차이점은?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#멀티-쓰레드의-장단점"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">멀티 쓰레드의 장단점?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#java-collection의-대표-인터페이스"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">Java Collection의 대표 인터페이스</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#접근-제어-지시자의-종류와-특성에-대하여-설명"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">접근 제어 지시자의 종류와 특성에 대하여 설명</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#thread를-구현하기-위한-두가지-방법은"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">Thread를 구현하기 위한 두가지 방법은?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#인터페이스란"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">인터페이스란?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#abstract-class란"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">abstract class란?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#garbage-collection이란"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">Garbage Collection이란?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#vector와-arraylist"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">Vector와 ArrayList?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#전역지역클래스-변수를-스택과-힙과-관련해서-설명"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">전역/지역/클래스 변수를 스택과 힙과 관련해서 설명</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#선언-위치에-따른-변수의-종류"><span class="toc-nav-number">11.1.</span> <span class="toc-nav-text">선언 위치에 따른 변수의 종류</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#inner-class란-사용하는-이유"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">inner class란? 사용하는 이유?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#java-reflection이란-사용하는-이유"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">Java Reflection이란? 사용하는 이유?</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#예외처리의-필요성과-목적"><span class="toc-nav-number">14.</span> <span class="toc-nav-text">예외처리의 필요성과 목적</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#jvm의-구성에-대해-설명"><span class="toc-nav-number">15.</span> <span class="toc-nav-text">JVM의 구성에 대해 설명</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#java-programming"><span class="toc-nav-number">15.1.</span> <span class="toc-nav-text">Java Programming</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#입력"><span class="toc-nav-number">16.</span> <span class="toc-nav-text">입력</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#stringbuilder-stringformat-string-클래스"><span class="toc-nav-number">17.</span> <span class="toc-nav-text">StringBuilder, String.format, String 클래스</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#stirngstringbufferstringbuilder-특징-및-차이점"><span class="toc-nav-number">18.</span> <span class="toc-nav-text">Stirng,StringBuffer,StringBuilder 특징 및 차이점</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#문자열을-추가하는-연산에서-string가-느린-이유"><span class="toc-nav-number">18.1.</span> <span class="toc-nav-text">문자열을 추가하는 연산에서 String가 느린 이유</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#stringbuffer-stringbuilder와-비교한-string-클래스의-장점"><span class="toc-nav-number">18.2.</span> <span class="toc-nav-text">StringBuffer, StringBuilder와 비교한 String 클래스의 장점</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#stringbuffer-stringbuilder가-string보다-문자열-연산에서-좋은-성능을-보이는-방법"><span class="toc-nav-number">18.3.</span> <span class="toc-nav-text">StringBuffer, StringBuilder가 String보다 문자열 연산에서 좋은 성능을 보이는 방법</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#eof"><span class="toc-nav-number">19.</span> <span class="toc-nav-text">EOF</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#scanner에-대해서"><span class="toc-nav-number">20.</span> <span class="toc-nav-text">Scanner에 대해서</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#오버로딩과-오버라이딩"><span class="toc-nav-number">21.</span> <span class="toc-nav-text">오버로딩과 오버라이딩</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://leejongchan.github.io/" target="_blank">JongChan</a></li>
                    
                        <li><a href="https://godpp.github.io" target="_blank">godpp</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "your-disqus-ID";
    var disqus_identifier = "https://woovictory.github.io/2018/08/14/java-basic-algorithm/";
    var disqus_url = "https://woovictory.github.io/2018/08/14/java-basic-algorithm/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/WooVictory">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/WooVictory">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; VictoryWoo 2018 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://woovictory.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://woovictory.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
