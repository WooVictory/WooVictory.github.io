<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>Java :: Collection Framework | VictoryWoo</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="Java" />
    
    <meta name="description" content="Collection Framework  컬렉션 프레임워크 핵심 인터페이스 Collection 인터페이스   Array  배열의 복사     여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 Collection Framework에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데,">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java :: Collection Framework">
<meta property="og:url" content="https://woovictory.github.io/2018/03/08/java-collection-framework/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="Collection Framework  컬렉션 프레임워크 핵심 인터페이스 Collection 인터페이스   Array  배열의 복사     여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 Collection Framework에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데,">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://woovictory.github.io/img/collection_framework.png">
<meta property="og:updated_time" content="2018-12-21T05:19:24.667Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java :: Collection Framework">
<meta name="twitter:description" content="Collection Framework  컬렉션 프레임워크 핵심 인터페이스 Collection 인터페이스   Array  배열의 복사     여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 Collection Framework에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데,">
<meta name="twitter:image" content="https://woovictory.github.io/img/collection_framework.png">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" type="text/css" href="">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theeluwin/NotoSansKR-Hestia@master/stylesheets/NotoSansKR-Hestia.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothiccoding.css">
    
    
    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-125410253-1', 'auto');
ga('send', 'pageview');

</script>
    
    


</head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">VictoryWoo&#39;s Blog</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/Programming/Java/">Java</a>
    </h1>
</div>

                        <div class="main-body-content">
                            
                            <article id="post-java-collection-framework" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        Java :: Collection Framework
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/03/08/java-collection-framework/" class="article-date">
            <time datetime="2018-03-08T07:46:14.000Z" itemprop="datePublished">2018-03-08</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Java/">Java</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <ol>
<li><a href="#CollectionFramework">Collection Framework</a>
<ul>
<li><a href="#%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">컬렉션 프레임워크 핵심 인터페이스</a></li>
<li><a href="#Collection-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">Collection 인터페이스</a></li>
</ul>
</li>
<li><a href="#Array">Array</a>
<ul>
<li><a href="#%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%B3%B5%EC%82%AC">배열의 복사</a></li>
</ul>
</li>
</ol>
<blockquote>
<p>여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 <strong>Collection Framework</strong>에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데, 일반적으로 많이 사용되는 자료구조는 <code>리스트, 스택, 큐, 해쉬 테이블</code>이 있습니다.</p>
</blockquote>
<p>이전에 포스팅했던 자료들은 자료구조별로 정리했었는데, 모두 삭제하고 하나의 포스팅에 압축해서 공부하고 올리도록 하겠습니다. :)</p>
<h1 id="collectionframework">CollectionFramework</h1>
<p>자바에서 컬렉션 프레임워크(collection framework)란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.<br>
즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.</p>
<p>이러한 <strong>컬렉션 프레임워크</strong>는 자바의 인터페이스를 사용하여 구현됩니다.</p>
<h2 id="컬렉션-프레임워크-핵심-인터페이스">컬렉션 프레임워크 핵심 인터페이스</h2>
<p>컬렉션 프레임워크에서는 컬렉션(데이터 그룹)을 크게 3가지 타입으로 구분하여 3가지 인터페이스를 정의했습니다. 그리고 인터페이스 중 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였습니다.</p>
<p>인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통 부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했습니다.</p>
<blockquote>
<p>주요 인터페이스 간의 상속 관계</p>
</blockquote>
<img src="/img/collection_framework.png" width="500" height="200">
<ul>
<li><strong>List</strong> : 순서가 있는 데이터의 집합. 데이터의 중복을 허용합니다.
<ul>
<li>구현 클래스 : ArrayList, LinkedList, Stack, Vector 등</li>
</ul>
</li>
<li><strong>Set</strong> : 순서를 유지하지 않는 데이터의 집합(순서가 없음). 데이터의 중복을 허용하지 않습니다.(Key)
<ul>
<li>구현 클래스 : HashSet, TreeSet 등</li>
</ul>
</li>
<li><strong>Map</strong> : 키(Key)와 값(value)의 쌍(Pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며(순서가 없음), 키는 중복을 허용하지 않고, <strong>값은 중복을 허용합니다.</strong>
<ul>
<li>구현 클래스: HashMap, TreeMap, Hashtable, Properties 등</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임워크의 명명법을 따르지 않습니다. Vector나 Hashtable과 같은 기존의 컬렉션들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다고 합니다. 그 대신 새로 추가된 <strong>ArrayList</strong>나 <strong>HashMap</strong>을 사용하는 것이 성능 면에서도 더 나은 결과를 얻을 수 있습니다.</p>
</blockquote>
<h2 id="collection-인터페이스">Collection 인터페이스</h2>
<p>List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고, 두 인터페이스는 그것을 상속받습니다. 따라서 <strong>Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고, 그것을 메소드로 제공하고 있습니다.</strong></p>
<ul>
<li>boolean add(Object o) : 지정된 객체(o)를 Collection에 추가합니다.</li>
<li>boolean addAll(Collection c) : 지정된 Collection©의 객체들을 Collection에 추가합니다.</li>
<li>void clear() : Collection의 모든 객체를 삭제합니다.</li>
<li>boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어 있는지 확인합니다.</li>
<li>boolean equals(Object o) : 동일한 Collection인지 비교합니다.</li>
<li>int hashCode() : Collection의 hash code를 반환합니다.</li>
<li>boolean isEmpty() : Collection이 비어있는지 확인합니다.</li>
<li>Iterator iterator() : Collection의 Iterator를 얻어서 반환합니다</li>
<li>boolean remove(Object o) : 지정된 객체를 삭제합니다.</li>
<li>int size() : Collection에 저장된 객체의 개수를 반환합니다.</li>
<li>Object[] toArray() : Collection에 저장된 객체를 객체배얄(Object[])로 반환합니다.</li>
<li>Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환합니다.</li>
</ul>
<h1 id="array배열">Array(배열)</h1>
<ul>
<li>많은 데이터를 관리할 떄 용이</li>
<li>여러 데이터를 하나의 이름으로 <strong>그룹핑해서 관리</strong>하기 위한 자료구조</li>
<li>배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있고, <strong>반복문과 결합</strong>하면 많은 정보도 효율적으로 처리할 수 있습니다.</li>
<li>배열 인덱스는 값에 대한 <strong>유일무이한 식별자</strong>(리스트에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가짐)</li>
<li><strong>크기가 정해져 있고 기능이 없습니다.</strong></li>
<li><code>인덱스</code>를 가지며, Element의 인덱스는 변경되지 않습니다.</li>
<li>인덱스를 활용하여 빠르게 조회가 가능합니다.</li>
<li>유관 데이터를 메모리에 순차적으로 나열할 수 있다.</li>
<li>인덱스를 이용하여 데이터를 가져오려면 데이터에 대한 인덱스 값이 고정되어야 합니다. (삭제된 Element의 공간이 그대로 남습니다.-&gt;<strong>메모리의 낭비</strong>)</li>
</ul>
<blockquote>
<p><strong>Arrays</strong> 클래스에는 배열을 다루는데 유용한 메소드가 정의되어 있습니다. Arrays에 정의된 메소드는 모두 static 메소드입니다.</p>
</blockquote>
<h2 id="배열의-복사">배열의 복사</h2>
<p>**<code>copyOf()</code>는 배열 전체를, <code>copyOfRange()</code>는 배열의 일부를 복사해서 새로운 배열을 만들어 반환합니다. ** copyOfRange() 메소드에서 지정된 범위의 끝은 포함되지 않습니다.(즉, 지정된 범위의 끝의 바로 앞까지만!)</p>
<h2 id="배열-채우기">배열 채우기</h2>
<p><strong><code>fill()</code>은 배열의 모든 요소를 지정된 값으로 채웁니다. <code>setAll()</code>은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받습니다.</strong> 이 메소드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야 합니다.</p>
<h2 id="배열의-정렬과-검색">배열의 정렬과 검색</h2>
<p><strong><code>sort()</code>는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 <code>binarySearch()</code>를 사용합니다.</strong> binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻습니다. (검색한 값과 일치하는 요소가 여러 개 있다면, 이 중 어떤 것의 위치가 반환될지는 알 수 없습니다.)</p>
<h2 id="문자열의-비교와-출력">문자열의 비교와 출력</h2>
<p><code>toString()</code>은 배열의 모든 요소를 문자열로 편하게 출력할 수 있게 도와줍니다. toString()은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에서는 deepToString()을 사용해야 합니다. <code>deepToString()</code>은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하므로 2차원뿐만 아니라 3차원 이상의 배열에 대해서도 동작합니다.</p>
<p><code>equals()</code>는 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환합니다. equals()도 일차원 배열에만 사용 가능하므로, 다차원 배열의 비교에는 <code>deepEquals()</code>를 사용해야 합니다.</p>
<h2 id="배열을-list로-변환">배열을 List로 변환</h2>
<p><strong><code>asList()</code>는 배열을 List에 담아서 반환합니다.</strong> 한 가지 주의할 점은 asList()가 반환한 List의 크기를 변경할 수 없다는 것입니다. 저장된 내용은 변경 가능하나, 추가 또는 삭제가 불가능합니다. 만약 크기를 변경할 수 있는 List가 필요하다면 다음과 같이 하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h2 id="parallelxxx-spliterator-stream">parallelXXX(), spliterator(), stream()</h2>
<p><code>parallel</code>로 시작하는 이름의 메소드는 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 합니다. <code>spliterator()</code>는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환하며, <code>stream()</code>은 컬렉션을 스트림으로 변환합니다.</p>
<h2 id="사용법">사용법</h2>
<p>아래의 사용법에서 메소드를 사용해볼 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">number[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">number[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">number[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(number.length); <span class="comment">// 길이:4</span></span><br></pre></td></tr></table></figure>
<h2 id="장단점">장/단점</h2>
<ul>
<li>장점
<ul>
<li><code>데이터의 크기가 확정적</code>일 때 배열을 사용하면 <strong>메모리나 처리속도</strong> 면에서 좋습니다.</li>
<li>다른 데이터 Structure의 부품이 되기도 합니다.</li>
</ul>
</li>
<li>단점
<ul>
<li>배열의 크기를 배열을 생성할 때 지정하는 것이나, 배열의 크기를 변경할 수 없습니다.</li>
<li>배열에서 설정된 Element(요소)의 개수를 알아낼 수 없습니다.</li>
</ul>
</li>
</ul>
<h2 id="한계">한계</h2>
<ul>
<li>배열은 길이를 바꿀 수 없습니다. 가변 배열과 길이가 변경 가능한 배열의 겅우
<ul>
<li>기존의 배열은 그대로 두고,</li>
<li>새로운 길이로 지정된 배열을 따로 할당 후</li>
<li>데이터의 복사를 진행하고,</li>
<li>기존의 배열을 삭제한다.</li>
<li><code>총 3번의 작업</code> + <code>메모리 탐색</code>이 필요하기 때문에 리소스 낭비가 크다.</li>
</ul>
</li>
<li>이런 한계를 해결하기 위해서 <code>linked list 자료형</code>을 활용할 수 있다. (탐색, 할당, 복사, 삭제 등의 리소스 낭비가 없습니다.)</li>
<li>배열은 인덱스에 따라서 값을 유지하기 떄문에, Element가 삭제되어도 빈자리(null)가 남게 됩니다.<code>(메모리 낭비)</code></li>
<li>조건문을 통해서 제외할 수 있으나, 조건문을 많이 사용하면 좋지 않습니다.</li>
<li>인덱스가 중요한 경우는 배열을 사용, 인덱스가 중요하지 않은 경우는 리스트를 사용합니다.</li>
<li>삭제한 데이터를 뒤에 위치한 Element로 메꾸면, 데이터가 순서에 따라서 빈틈없이 연속적으로 위치하며 이를 <code>list(리스트)</code>라고 합니다.</li>
</ul>
<p><img src="/img/array.png" alt=""></p>
<ul>
<li>배열 : 삭제된 데이터의 빈 공간을 그래도 남겨둠.</li>
<li>리스트 : 빈 공간을 채움.</li>
</ul>
<p>이러한 문제점을 극복한 것이 <strong>List</strong> 입니다.</p>
<h1 id="list-인터페이스">List 인터페이스</h1>
<p>List는 배열의 한계 때문에 만들어졌으며, List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음과 같은 특징을 가지고 있습니다.</p>
<ol>
<li>리스트 자료구조의 핵심은 Element간의 <code>순서</code>. 즉, <strong>순서가 있는 데이터의 모임이 리스트입니다.</strong></li>
<li>같은 요소의 중복 저장을 허용합니다.</li>
<li>리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 <strong>빈틈 없는 데이터의 적재</strong>라는 장점을 취한 데이터 Structure입니다.</li>
<li>리스트에서 인덱스는 <strong>몇 번쨰 데이터인가</strong> 정도의 의미</li>
<li>빈 Element는 허용하지 않습니다.</li>
<li>데이터 개수가 확실하게 정해져 있고, 자주 사용된다면 Array가 더 효율적입니다.</li>
</ol>
<p>대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>ArrayList<e></e></li>
<li>LinkedList<e></e></li>
<li>Vector<e></e></li>
<li>Stack<e></e></li>
</ol>
<h2 id="arraylist">ArrayList</h2>
<p><strong>List 인터페이스를 구현하기 때문에 데이터의 저장 순서가 유지되고 중복을 허용한다는 특징을 갖습니다.</strong></p>
<p>ArrayList는 Obejct 배열을 이용해서 데이터를 순차적으로 저장합니다. 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장됩니다.</p>
<p>(Vector는 capacity가 부족할 경우 자동적으로 기존의 크기보다 2배의 크기로 증가됩니. 그러나 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 됩니다.)</p>
<p>ArryaList는 내부적으로 데이터를 <code>배열</code>에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 사용합니다. <strong>배열은 크기를 변경할 수 없기 때문에 ArrayList나 Vector와 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야 하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있습니다.</strong></p>
<ul>
<li><strong>capacity</strong> : 현재 ArrayList가 수용할 수 있는 데이터의 수를 의미합니다.</li>
<li><strong>size</strong> : 현재 ArrayList에 저장된 데이터의 수를 의미합니다.</li>
<li><strong>Indexoutofbounds exception</strong> : capacity가 아닌 size에 의해 발생합니다. <strong>데이터의 유무가 중요</strong></li>
</ul>
<img src="/img/mm.png" width="400" height="200">
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add를 이용한 요소 추가</span></span><br><span class="line">        items.add(<span class="number">40</span>);</span><br><span class="line">        items.add(<span class="number">20</span>);</span><br><span class="line">        items.add(<span class="number">10</span>);</span><br><span class="line">        items.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for와 get() 메소드를 이용한 요소 출력</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;items.size();i++)&#123;</span><br><span class="line">            System.out.print(items.get(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for 문과 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e :items) &#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collections.sort() 메소드를 이용한 요소의 정렬</span></span><br><span class="line">        Collections.sort(items);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = items.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set() 메소드를 이용한 요소의 값 변경</span></span><br><span class="line">        items.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수. 반환값은 있으면 true 없으면 false</span></span><br><span class="line">        System.out.println(items.contains(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 함수의 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 값이 추가됩니다. 하지만, 위치를 알 수 없을 때는 indexOf() 함수를 이용해서 위치값을 찾은 뒤 add()함수를 이용하면 됩니다.</span></span><br><span class="line">        <span class="keyword">int</span> index = items.indexOf(<span class="number">20</span>);</span><br><span class="line">        items.add(index, <span class="number">110</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index가 1인 요소 즉, 110 삭제, 인덱스로 삭제하면 어떤 인덱스로 삭제했는지 알려줌</span></span><br><span class="line">        System.out.println(items.remove(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 오브젝트를 넘겨서 오브젝트의 모든 요소 삭제</span></span><br><span class="line">        items.removeAll(items);</span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(items.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">100</span> <span class="number">110</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line">items size : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> : List에 요소를 추가합니다.</li>
<li><strong>get()</strong> : 인덱스를 통한 요소 조회합니다.</li>
<li><strong>set()</strong> : 원하는 인덱스에 원하는 요소를 추가합니다.</li>
<li><strong>contains()</strong> : 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수, 반환값은 있으면 true 없으면 false</li>
<li><strong>indexOf()</strong> : 메소드의 인자로 오브젝트를 넘기면 이 오브젝트의 인덱스를 반환해줍니다.</li>
<li><strong>add(int index, Obejct o)</strong> : 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 두 번째 인자인 오브젝트가 추가됩니다.</li>
<li><strong>remove()</strong> : 인덱스를 이용해서 해당 인덱스를 삭제해줍니다. 인덱스로 삭제하게 되면 어떤 데이터를 삭제했는지 리턴값으로 알려줍니다.</li>
<li><strong>remove(Object element)</strong> : 오브젝트를 인수로 넘기면 검색해서 삭제시켜줍니다. 오브젝트를 이용해서 삭제를 하게 되면 삭제 결과가 성공인지 실패인지만 알려줍니다.</li>
</ul>
<h2 id="linkedlist">LinkedList</h2>
<p><strong>배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있습니다.</strong></p>
<ol>
<li><strong>크기를 변경할 수 없다.</strong>
<ul>
<li>크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요합니다.</li>
<li>실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비됩니다.</li>
</ul>
</li>
<li><strong>비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.</strong>
<ul>
<li>차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,</li>
<li>배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야만 합니다.</li>
</ul>
</li>
</ol>
<p>이러한 배열의 단점을 보완하기 위해서 <strong>LinkedList</strong>(링크드 리스트)라는 자료구조가 고안되었습니다. 배열은 모든 데이터가 연속적으로 존재하지만 LinkedList는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있습니다.</p>
<p>링크드 리스트의 각 요소(node)들은 자신과 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList1.png" width="500" height="200">
<p>링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵습니다. 이 점을 보완한 것이 이중 연결리스트(doubly linked list, 더블 링크드 리스트)입니다.</p>
<p><strong>더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Node previous; <span class="comment">// 이전 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList2.png" width="500" height="200">
<p>더블 링크드 리스트의 접근성을 보다 향상시킨 것이 **더블 쎠큘러 링크드 리스트(이중 연결형 연결 리스트)**입니다. 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것입니다.</p>
<p>실제로 <strong>LinkedList</strong> 클래스는 이름과 달리 '링크드 리스트’가 아닌 '더블 링크드 리스트’로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것입니다.</p>
<ol>
<li><strong>순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: 만약 ArrayList의 크기가 충분하지 않으면, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하게 되므로 순차적으로 데이터를 추가해도 ArrayList보다 LinkedList가 더 빠를 수 있습니다. 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하며, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠릅니다. (단지 마지막 요소의 값을 null로만 바꾸면 되기 때문입니다.)</li>
<li><strong>중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠릅니다.</strong><br>
: LinkedList는 각 요소 간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠릅니다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦습니다. 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지 않습니다.</li>
<li><strong>데이터의 개수가 많아질수록 데이터를 읽어오는 시간, 즉 접근시간(access time)은 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: ArrayList는 인덱스 기반의 자료 구조이며, get(index)를 통해 O(1)의 시간 복잡도를 가집니다. 배열의 경우 만일 n번째 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결됩니다. (배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문입니다.)</li>
</ol>
<blockquote>
<p>n번째 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기</p>
</blockquote>
<p>그러나, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이 아니기 때문에 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있습니다. 검색시 거의 모든 요소를 탐색해야 하기 때문에 최악의 경우에는 O(N)의 시간 복잡도를 갖습니다.</p>
<blockquote>
<p>요약</p>
</blockquote>
<ul>
<li><code>LinkedList</code> : 데이터의 추가/삭제가 많을 때 유리</li>
<li><code>Vector/ArrayList</code> : 데이터 항목 검색이 많을 때 유리</li>
</ul>
<blockquote>
<p>ArrayList와 LinkedList</p>
</blockquote>
<p>데이터를 가져오는 것인 빈번하다면 내부적으로 배열을 이용하는 <strong>ArraysList</strong>가 훨씬 빠릅니다.<br>
하지만, 데이터의 추가/삭제가 빈번하다면 <strong>LinkedList</strong>가 훨씬 효과적입니다.</p>
<p>LikedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다고 보면 됩니다. ArrayList와 같이 데이터의 추가, 삭제 시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, <strong>데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리합니다.</strong></p>
<img src="/img/kk.png" width="400" height="200">
<blockquote>
<p><code>Iterator</code> 사용 이유</p>
</blockquote>
<p>linked 특성상 항상 처음부터 같은 경로를 반복적으로 지나면서 데이터의 위치를 검색해야 하기 때문에 마지막으로 접근한 데이터를 기준으로 그 다음 데이터를 알아내는 것이 더 쉽습니다. - 벡터나 ArrayList 처럼 사용되는 것입니다.</p>
<ul>
<li><code>Iterator</code>(추출 전용 인터페이스)
<ul>
<li>데이터를 추출하기 위한 데이터 임시 저장공간</li>
<li>주로 순서가 없는 자료구조의 값들을 추출할 때 사용합니다.</li>
</ul>
</li>
<li>보통 hasNext와 next 메소드를 이용한 while문으로 값을 추출합니다.</li>
</ul>
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; lnkList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        lnkList.add(<span class="string">"넷"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"둘"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"셋"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lnkList.size(); i++) &#123;</span><br><span class="line">            System.out.print(lnkList.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 삭제</span></span><br><span class="line">        lnkList.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 원하는 위치에 요소 삽입</span></span><br><span class="line">        lnkList.set(<span class="number">2</span>, <span class="string">"둘"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(<span class="string">"리스트의 크기 : "</span> + lnkList.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">넷 셋 하나 </span><br><span class="line">넷 셋 둘 </span><br><span class="line">리스트의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="vector">Vector</h2>
<p>ArrayList와 동일하게 사용이 가능합니다.<br>
ArrayList와 Vector의 차이점은 Stringbuilder와 StringBuffer의 차이로 이해할 수 있습니다. <strong>한 데이터에 동시접속이 발생했을 때 처리 가능한 기능이 있나, 없나의 차이입니다.</strong></p>
<p>동시접속을 고려하여 만들어진 리스트는 <code>Vector</code>입니다. <code>ArrayList</code>는 동시접속을 고려하지 않았지만, 그만큼 Vector보다 가볍다는 장점이 있습니다. 또한 웹에서 사용할 때 서버가 동시접속에 대한 처리를 해주기 때문에 ArrayList를 사용하면 됩니다.</p>
<p>Vector는 현재 기존 코드와의 호환성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다.</p>
<h2 id="list-인터페이스-메소드">List 인터페이스 메소드</h2>
<ul>
<li>void add(int index, Object element) : 지정된 위치(index)에 객체(element)또는 컬렉션에 포함된 객체들을 추가합니다.</li>
<li>Object get(int index) : 지정된 위치(index)에 있는 객체를 반환합니다.</li>
<li>int indexOf(Object o) : 지정된 객체의 위치(index)를 반환합니다. (List의 첫 번째 요소부터 순방향으로 찾습니다.)</li>
<li>lastIndexOf(Object o) : 지정된 객체의 위치(indx)를 반환합니다. (List의 마지막 요소부터 역방향으로 찾습니다.)</li>
<li>ListIterator listIterator() : List의 객체에 접근할 수 있는 ListIterator를 반환합니다.</li>
<li>Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환합니다.</li>
<li>Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장합니다.</li>
<li>void sort(Comparator c) : 지정된 비교자(comparator)로 List를 정렬합니다.</li>
<li>List subList(int formIndex, int toIndex) : 지정된 범위(formIndex부터 toIndex)에 있는 객체를 반환합니다.</li>
</ul>
<h2 id="참고">참고</h2>
<blockquote>
<p>List와 ArrayList 이 둘의 차이는 무엇인가?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
<p>예를 들어서 설명하면, 클래스를 생성할 때 <code>도형</code> 타입으로 생성하게 되면 <strong>정사각형</strong>이 아닌 다른 <strong>직사각형, 삼각형</strong>등 도형 인터페이스를 구현한 클래스에서 사용될 수 있습니다. 하지만, <code>정사각형</code>타입으로 클래스르 생성하게 되면 <strong>직사각형, 삼각형</strong>등에서는 사용할 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 도형 list = new 정사각형();</span></span><br><span class="line"></span><br><span class="line"> 	ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 정사각형 list = new 정사각형();</span></span><br></pre></td></tr></table></figure>
<p><code>List</code>는 <strong>인터페이스</strong>입니다. 인터페이스는 공통되는 메소드를 추출해 놓은 클래스입니다.</p>
<ul>
<li>Java Collection FrameWork<br>
<img src="/img/sse.jpg" alt=""></li>
</ul>
<h1 id="stack과-queue">Stack과 Queue</h1>
<hr>
<p>순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 비효율적입니다. 그래서 큐는 ArrayList보다는 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합합니다.</p>
<h2 id="stack">Stack</h2>
<p><strong>스택</strong>이란 사전적으로는 더미, 쌓아 올림이라는 의미를 갖습니다. '더미’란 많은 물건이 모여서 쌓인 큰 덩어리를 의미합니다. 스택은 같은 타입의 자료를 <code>하나 다음 하나</code>라는 개념으로 순차적으로 저장하는 직선형 자료구조입니다.<br>
Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다.</p>
<p>스택은 한쪽이 막혀있고, <strong>한쪽에서만 삽입이나 삭제가 가능합니다.</strong> 그러므로 가장 마지막 데이터의 위치에 대해 삽입이나 삭제가 발생하므로, 이러한 구조에 사용될 때 간단하며 더욱 효율적이고 쉽게 사용이 가능합니다.</p>
<p>또한 스택은 데이터를 쌓아올리는 형태로 데이터를 저장하여 추출할 때는 맨 위에 있는 데이터를 먼저 꺼내는 형태이기 때문에 제일 마지막에 저장한 데이터를 제일 먼저 꺼내는 <code>후입선출(LIFO - Last In First Out)</code> 형태라고도 합니다.</p>
<p><img src="/img/stack.png" alt=""></p>
<ul>
<li>Stack 용어
<ul>
<li>push : 스택에 자료를 넣는 연산</li>
<li>pop : 스택에 자료를 빼는 연산</li>
<li>top : 스택의 가장 위에 있는 자료를 보는 연산</li>
<li>bottom : 스택에 가장 먼저 입력된 데이터</li>
<li>empty : 스택이 비어있는지 아닌지를 알아보는 연산</li>
<li>size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산</li>
</ul>
</li>
</ul>
<p>스택은 <strong>top</strong>에서만 삽입, 삭제, 읽기 동작이 발생할 수 있습니다. <strong>top</strong>은 데이터의 수에 따라 유동적으로 변하며 데이터가 하나 삽입될 경우 하나 증가하고 데이터가 하나 삭제될 경우 하나 감소하도록 작성됩니다.</p>
<p>스택의 경우에는 순차적으로 데이터를 추가하고 삭제하므로 <strong>ArrayList</strong>와 같은 배열 기반의 컬렉션 클래스가 적합합니다.</p>
<ul>
<li>Stack 메소드
<ul>
<li>boolean empty() : Stack이 비어있는지 알려줍니다.</li>
<li>Object peek() : Stack의 맨 위에(top) 저장된 객체를 반환, pop()과 달리 Stack에서 객체를 꺼내지 않습니다. 단지 보기만 합니다.</li>
<li>Object pop() : Stack의 맨 위에 저장된 객체를 꺼냅니다.</li>
<li>Object push(Object item) : Stack에 객체(item)를 저장합니다.</li>
<li>int search(Object o) : 해당 Stack에서 전달된 객체가 존재하는 위치의 인덱스를 반환합니다. 이 때, 인덱스는 제일 상단에 있는(제일 마지막으로 저장된)요소의 위치부터 0이 아닌 1부터 시작하게 됩니다.</li>
<li>clear() : Stack에 존재하는 모든 자료들을 삭제합니다.</li>
</ul>
</li>
</ul>
<h3 id="사용방법">사용방법</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스택 객체 stack 생성</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 데이터 입력</span></span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스택의 사이즈</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line">System.out.println(<span class="string">"마지막에 넣은 데이터부터 출력.."</span>);</span><br><span class="line"><span class="comment">// 가장 최근에 넣은 데이터부터 추출</span></span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">		</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"스택크기: "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 빼지 않고 현재 가장 위에 위치하는 데이터를 확인</span></span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈 확인</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">System.out.println(stack.search(<span class="number">3</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">4</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">스택 크기 : <span class="number">5</span></span><br><span class="line">마지막에 넣은 데이터부터 출력..</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-----------</span><br><span class="line">스택크기: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">스택 크기 : <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>더욱 복잡하고 빠른 스택을 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다. 단, Stack 클래스와는 달리 <strong>search()</strong> 메소드를 지원하지 않습니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="스택의-활용-사례">스택의 활용 사례</h3>
<ul>
<li><code>Operating Systems</code>
<ul>
<li>프로그램에서 불러지는 함수(Method)들을 모두 Stack이라는 자료형에 저장합니다.</li>
</ul>
</li>
<li><code>Compilers(컴파일러)</code>
<ul>
<li>컴파일러에서 수학기호들으 기계어(Machine Code)로 변환시, 괄호들을 매칭하거나 할 때</li>
</ul>
</li>
<li><code>JVM(Java Virtual Machine) - 자바 가상 머신</code>
<ul>
<li>자바 프로그램이 실행될 때 사용되는 JVM에서도 스택은 사용됩니다. 각각의 스레드는 1개의 스택을 가지고 모든 메소드들을 트랙킹합니다. 새로운 메소드들이 호출될 때마다, 새로운 프레임이 스택에 삽입되고, 메소드가 끝날 때 마다 스택에서 제거됩니다.</li>
</ul>
</li>
</ul>
<h2 id="queue">Queue</h2>
<img src="/img/queues.png" width="500" height="200">
<p>큐는 줄이라는 의미를 가지고 있습니다. <strong>큐(Queue)에서 데이터의 제거는 대기 줄의 가장 앞에서 수행되며 데이터의 삽입은 대기 줄의 가장 뒤에서 수행이 되는 제한된 리스트 구조를 말하며 가장 먼저 삽입된 데이터가 가장 먼저 제거되는 <code>선입선출(FIFO-First In First Out)</code> 형태의 자료구조입니다.</strong></p>
<p>가장 오래전에 입력된 데이터를 <strong>front</strong>라고 하면 가장 최근에 입력된 데이터를 <strong>rear</strong>라고 합니다. <code>데이터의 삽입</code>은 <strong>rear</strong>에서 이루어지고 <code>삭제</code>는 <strong>front</strong>에서 이루어지기 때문에 큐를 구현하기 위해서는 front와 rear를 관리하는 배열을 이용하거나 front노드와 rear노드를 관리하는 <code>연결 리스트</code>를 이용할 수 있습니다.</p>
<img src="/img/queue.jpg" width="300" height="200">
<p><strong>자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있지만 큐는 Queue 인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있진 않습니다. 대신 Queue 인터페이스를 구현한 클래스들이 있어서 이들 중의 하나를 선택해서 사용하면 됩니다.</strong></p>
<p>따라서 Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많습니다. 그 중에서도 Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됩니다.</p>
<p>그리고 Queue는 타입이 될 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 이렇게 선언이 되지 않고</span></span><br><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="queue의-동작">Queue의 동작</h3>
<ul>
<li>
<p>삽입 - offer,add</p>
<ul>
<li>큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다.</li>
<li>add : 큐의 뒤 쪽(rear)에 데이터를 삽입합니다.</li>
<li>push : 큐의 앞 쪽(front)에 데이터를 삽입합니다.</li>
</ul>
</li>
<li>
<p>제거 - pop,remove</p>
<ul>
<li>큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다.</li>
<li><code>poll</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>remove</code>는 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
<li>
<p>읽기 - peek,element</p>
<ul>
<li>큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다.</li>
<li><code>peek</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>element</code>은 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
</ul>
<blockquote>
<p>peekFirst()는 Queue에 가장 먼저 들어온 데이터 즉, front에 있는 데이터를 보여줍니다. peekLast()는 Queue에 가장 나중에 들어온 데이터 즉, rear에 있는 데이터를 보여줍니다.</p>
</blockquote>
<h3 id="사용">사용</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">queue</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        queue.add(<span class="string">"하나"</span>);</span><br><span class="line">        queue.add(<span class="string">"둘"</span>);</span><br><span class="line">        queue.add(<span class="string">"셋"</span>);</span><br><span class="line">        queue.add(<span class="string">"넷"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// element() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"element() 메소드 사용 : "</span>+queue.element());</span><br><span class="line">        <span class="comment">// peek() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"peek() 메소드 사용 : "</span>+queue.peek()+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peekFirst() 메소드는 큐의 맨 위의 요소를 반환 즉, 가장 처음에 삽입된 요소를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 첫 번째 요소 : "</span>+queue.peekFirst());</span><br><span class="line">        <span class="comment">// peekLast() 메소드는 큐의 맨 마지막 요소를 반환 즉, 마지막에 삽입된 요소 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 마지막 요소 : "</span>+queue.peekLast()+<span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.poll());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.remove());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">element() 메소드 사용 : 하나</span><br><span class="line">peek() 메소드 사용 : 하나</span><br><span class="line"></span><br><span class="line">Queue의 첫 번째 요소 : 하나</span><br><span class="line">Queue의 마지막 요소 : 넷</span><br><span class="line"></span><br><span class="line">[하나, 둘, 셋, 넷]</span><br><span class="line">삭제한 요소 : 하나</span><br><span class="line">[둘, 셋, 넷]</span><br><span class="line"></span><br><span class="line">삭제한 요소 : 둘</span><br><span class="line">[셋, 넷]</span><br></pre></td></tr></table></figure>
<h3 id="큐-구현-클래스">큐 구현 클래스</h3>
<p><strong>1. PriorityQueue</strong><br>
Queue 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있습니다. 그리고 null은 저장할 수 없습니다. PIPO(Priority-in, Priority Out)</p>
<p><strong>2. PriorityBlockingQueue</strong><br>
-&gt; Priority Queue의 동기화된 버전<br>
-&gt; 동기화 메소드 보유<br>
-&gt; PriorityQueue보다 느린 속도<br>
-&gt; null 요소를 허용하지 않음</p>
<p><strong>3. LinkedList</strong><br>
-&gt; 끝에 요소를 추가하는 것이 용이<br>
-&gt; List 인터페이스 구현<br>
-&gt; 요소에 null 허용</p>
<p><strong>4. Deque(Double-Ended Queue)</strong><br>
-&gt; Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, <strong>Deque</strong>은 양쪽 끝에 추가/삭제가 가능합니다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있습니다.</p>
<p>문제 : <a href="https://www.acmicpc.net/problem/10866" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10866</a></p>
<blockquote>
<p>Deque의 사용법</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">            String command = st.nextToken();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">				<span class="comment">// first, front, 앞 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 먼저 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// push() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_front"</span>: </span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addFirst(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">// last, rear, 뒤 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 나중에 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// add() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_back"</span>:</span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addLast(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_front"</span>:</span><br><span class="line">					<span class="comment">// 덱이 비어있는지 확인할 수 있음</span></span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 앞쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 먼저 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeFirst()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 나중에 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeLast()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"size"</span>:</span><br><span class="line">					<span class="comment">// 덱의 사이즈를 확인</span></span><br><span class="line">                    System.out.println(deque.size());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"empty"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"front"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱에서 가장 앞쪽의 데이터를 확인(first, front)</span></span><br><span class="line">                        System.out.println(deque.peekFirst());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 확인(last, rear)</span></span><br><span class="line">                        System.out.println(deque.peekLast());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java SE 6부터 지원되는 ArrayDeque 클래스는 스택과 큐 메모리 구조를 모두 구현하는데 가장 적합한 클래스입니다.</p>
</blockquote>
<h1 id="vector-클래스">Vector 클래스</h1>
<hr>
<p><code>List 인터페이스를 구현한 클래스</code>이며, <strong>java.util.Vector</strong>에 있습니다. 그리고 아래와 같은 특징을 갖습니다.</p>
<ol>
<li>객체들을 <strong>삽입, 삭제, 검색</strong>할 수 있는 컨테이너 클래스입니다.</li>
<li>배열의 <strong>길이 제한 단점을 극복</strong>할 수 있습니다.</li>
<li>삽입되는 객체의 수가 많아지면 <code>자동으로 크기가 조절</code>됩니다.</li>
<li>아이템을 벡터의 <strong>맨 마지막</strong>이나 <strong>중간에 삽입</strong>할 수 있습니다.</li>
</ol>
<ul>
<li><code>벡터 맨 뒤에 객체 추가</code> : 벡터 공간이 모자라면 자동으로 늘림</li>
<li><code>벡터 중간에 객체 삽입</code> : 뒤에 존재하던 객체는 한칸씩 뒤로 이동</li>
<li><code>임의의 위치에 있는 객체 삭제</code> : 객체 삭제 후 한칸씩 앞으로 자동으로 이동</li>
</ul>
<h2 id="사용방법">사용방법</h2>
<img src="/img/dd.png" width="400" height="200">
<p>위의 그림은 벡터 객체 내부의 구조와 <code>add(),get() 메소드</code>를 이용하여 객체를 다루는 모습을 보여주고 있습니다. 벡터에는 <strong>String,Integer,Person등의 다양한 타입의 객체가 삽입 가능합니다.</strong> 벡터 내부에 삽입된 요소들은 <code>인덱스</code>로 관리하며 인덱스는 0부터 시작합니다. <code>add()</code>메소드를 이용하여 <strong>객체를 삽입</strong>하고, <code>get()</code>메소드를 이용하여 인덱스에 해당하는 <strong>객체를 얻습니다.</strong></p>
<blockquote>
<p>벡터의 생성</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">Vector&lt;String&gt; v2 = <span class="keyword">new</span> Vector&lt;String&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>v는 어떠한 타입이라도 담을 수 있습니다.</li>
<li>v2는 Vector 객체에 String 객체를 담을 수 있으며, 용량은 3이며 size가 용량을 초과했을 때, 3의 크기만큼 증가합니다. (매개변수를 지정하지 않았을 경우에는 기본 용량:10,증가 용량:10)<br>
<img src="/img/abc.png" width="400" height="200"></li>
</ul>
<blockquote>
<p>벡터에 요소 삽입</p>
</blockquote>
<p>벡터에 삽입할 수 있는 요소는 <code>Object</code>를 상속받은 모든 종류의 객체들이 가능하며 다음과 같이 벡터에 요소를 삽입할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="string">"Hello"</span>);</span><br><span class="line">v.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> Person());</span><br><span class="line">v2.addElement(<span class="string">"이승우"</span>);</span><br><span class="line">v2.addElement(<span class="string">"정지현"</span>);</span><br><span class="line">v2.addElement(<span class="string">"탁형민"</span>);</span><br><span class="line">v2.addElement(<span class="string">"홍주영"</span>);</span><br><span class="line"></span><br><span class="line">v.add(<span class="number">1</span>); <span class="comment">// int형 데이터(Integer 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="string">'r'</span>); <span class="comment">// char형 데이터(Character 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="number">3.14</span>); <span class="comment">// double형 데이터(Double 타입으로 전환되어 저장)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> 메소드는 요소를 벡터의 맨 뒤에 삽입합니다.</li>
<li>v2에는 addElement() 메소드를 이용해서 String 객체를 담을 수 있습니다.</li>
<li>자바에서 제공하는 기본 타입 역시 벡터에 삽입할 수 있습니다.</li>
</ul>
<img src="/img/bcd.png" width="400" height="200">
<blockquote>
<p>벡터 내의 객체 알아내기</p>
</blockquote>
<p>벡터 내에 존재하는 요소 객체를 알아내기 위해서는 <code>get(), elementAt()</code>등의 메소드를 이용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer obj = (Integer)v.get(<span class="number">1</span>); <span class="comment">// 벡터의 1번째 요소를 Integer 타입으로 형 변환</span></span><br><span class="line"><span class="keyword">int</span> i = obj.intValue(); <span class="comment">// obj에 있는 정수를 알아냅니다. 값은 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>벡터의 용량과 개수 알아내기</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = v.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c = v.capacity(); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">int</span> n2 = v2.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c2 = v2.capacity(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>벡터의 크기<code>(size)</code> : <strong>벡터에 들어 있는 요소의 개수</strong></li>
<li>벡터의 용량<code>(capacity)</code> : <strong>요소를 수용할 수 있는 크기</strong>[벡터는 자동으로 조절 가능]</li>
</ul>
<blockquote>
<p>요소 객체 중간에 삽입하기</p>
</blockquote>
<p>벡터에 있는 데이터는 <code>인덱스</code>로 관리할 수 있기 때문에, 인덱스 값을 이용해서 중간에 객체 삽입이 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="number">2</span>,<span class="string">"Sahni"</span>);</span><br></pre></td></tr></table></figure>
<p>벡터 v 내의 인덱스가 2인 위치에 “Shani” 삽입하였으며, 아래 그림과 같은 구조를 가지게 됩니다.</p>
<img src="/img/cde.png" width="400" height="200">
<blockquote>
<p>벡터에서 요소 삭제</p>
</blockquote>
<ul>
<li><code>remove()</code> : 벡터 내에 임의의 인덱스에 있는 요소를 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.remove(<span class="number">1</span>); <span class="comment">// 정수 4가 삭제됨</span></span><br></pre></td></tr></table></figure>
<img src="/img/def.png" width="400" height="200">
<blockquote>
<p>벡터에서 모든 요소 삭제하기</p>
</blockquote>
<ul>
<li><code>removeAllElements()</code> : 벡터 내에 존재하는 모든 요소를 한번에 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.removeAllElements(); <span class="comment">// 벡터 내 모든 요소 삭제</span></span><br></pre></td></tr></table></figure>
<img src="/img/efg.png" width="400" height="200">
<h2 id="벡터-클래스의-주요-메소드">벡터 클래스의 주요 메소드</h2>
<p><img src="/img/aad.png" alt=""></p>
<h2 id="벡터-생성자">벡터 생성자</h2>
<p><img src="/img/lmc.png" alt=""></p>
<h1 id="정렬">정렬</h1>
<hr>
<p>자바에서 정렬하기 위해 사용하는 <code>Comparable</code>과 <code>Comparator</code>를 공부해보았습니다<br>
<strong><code>Comparator</code>와 <code>Comparable</code>은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메소드를 정의하고 있으며, Comparable을 구현하고 있는 클래스들은 같은 타입의 인터페이스끼리 서로 비교할 수 있는 클래스들(주로 Wrapper 클래스)이 있으며, 기본적으로 오름차순으로 구현되어 있습니다. 그래서 Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미합니다.</strong></p>
<p><strong>배열</strong>이나 <strong>Collection</strong>프레임워크 등에서 sort()를 사용하면 컴퓨터에서 알아서 <code>정렬</code>을 해줍니다. 여기서 사용되는 <code>sort()</code>는 <strong>Comparable</strong> 구현에 의한 정렬이고, <strong>Comparable</strong>과 <strong>Comparator</strong>에 대해서 공부해보았습니다.</p>
<p>먼저 Arrays 클래스에서 제공하는 <strong>sort()</strong> 메소드를 이용해서 배열을 정렬하는 예입니다.</p>
<h2 id="arrayssort">Arrays.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String[] sports=&#123;<span class="string">"Soccer"</span>,<span class="string">"Baseball"</span>,<span class="string">"Tennis"</span></span><br><span class="line">,<span class="string">"Football"</span>,<span class="string">"Basketball"</span>,<span class="string">"Ski"</span>,<span class="string">"Hockey"</span>,<span class="string">"Aerobics"</span>&#125;; <span class="comment">// 영어</span></span><br><span class="line">String[] names=&#123;<span class="string">"하정우"</span>,<span class="string">"장동건"</span>,<span class="string">"김수현"</span>,<span class="string">"박보검"</span></span><br><span class="line">,<span class="string">"송중기"</span>,<span class="string">"송승헌"</span>,<span class="string">"조승우"</span>,<span class="string">"조정석"</span>,<span class="string">"강동원"</span>,<span class="string">"김우빈"</span>,<span class="string">"박서준"</span>&#125;; <span class="comment">// 한글</span></span><br><span class="line">		</span><br><span class="line">Arrays.sort(sports);</span><br><span class="line">Arrays.sort(names);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sports.length;i++)&#123;</span><br><span class="line">	System.out.print(sports[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;names.length;j++)&#123;</span><br><span class="line">	System.out.print(names[j]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Aerobics Baseball Basketball Football Hockey Ski Soccer Tennis </span><br><span class="line">강동원 김수현 김우빈 박보검 박서준 송승헌 송중기 장동건 조승우 조정석 하정우</span><br></pre></td></tr></table></figure>
<p>먼저, <strong>Arryays.sort</strong>()의 동작을 확인하였습니다. String 타입의 배열을 2개 만들었고, <strong>Arrays.sort</strong>()를 통해 정렬을 수행하였습니다.<br>
영어는 ABC 순서대로, 한글은 가나다 순서대로 정렬이 된 것을 확인할 수 있습니다. 영어의 경우 같은 알파벳으로 시작하는 단어들도 정확하게 정렬이 되었습니다.</p>
<p>여기서 Arrays.sort(sports),Arryas.sort(names)는 String의 <strong>Comparable</strong>구현에 의해 정렬된 것이다. <strong>Comparable</strong>을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, String, Integer, Date, File등과 같은 것들입니다. 그리고 기본적으로는 작은 값에서 큰 값의 순서, 오름차순 형태로 구현되도록 만들어져 있습니다.</p>
<h2 id="collectionssort">Collections.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sportsList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">sportsList.add(<span class="string">"Soccer"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Baseball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Tennis"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Football"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Basktball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Ski"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Hockey"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Aerobics"</span>);</span><br><span class="line">		</span><br><span class="line">Collections.sort(sportsList);</span><br><span class="line">		</span><br><span class="line">Iterator it = sportsList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이번에는 배열이 아닌 ArrayList의 형태로 sort()를 사용해보았다. 위에서 사용했던 방식과 똑같지만, String 타입의 배열을 ArrayList로 바꿨습니다. 여기서는 <strong>Arrays.sort</strong>()가 아니라 <code>Collections.sort()</code>를 적용해야 합니다.</p>
<h2 id="comparable-인터페이스">Comparable<t> 인터페이스</t></h2>
<p>Comparable 인터페이스는 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드를 정의하고 있습니다. 자바에서 같은 타입의 인스턴스를 서로 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있습니다. 따라서 Boolean을 제외한 래퍼 클래스나 String, Time, Date와 같은 클래스의 인스턴스는 모두 정렬 가능합니다. 이 때 기본 정렬 순서는 작은 값에서 큰 값으로 정렬되는 오름차순이 됩니다.</p>
<p>이제부터는 기본 정렬기준이 아닌 다른 정렬기준으로 시도해보겠습니다. 축구선수를 뜻하는 <strong>SoccerPlayer</strong>라는 클래스를 하나 만들고, 축구선수의 객체배열을 이용해 sort를 해보려고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cars</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cars</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cars</span><span class="params">(String modelName, String color, <span class="keyword">int</span> modelYear)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear+<span class="string">"식"</span>+<span class="keyword">this</span>.modelName+<span class="string">" "</span>+<span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModelYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelYear</span><span class="params">(<span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cars obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.modelYear &gt;obj.modelYear)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.modelYear &lt; obj.modelYear)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arraysExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Cars&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Cars cars1 = <span class="keyword">new</span> Cars(<span class="string">"아반떼"</span>,<span class="string">"Black"</span>,<span class="number">2016</span>);</span><br><span class="line">        Cars cars2 = <span class="keyword">new</span> Cars(<span class="string">"소나타"</span>,<span class="string">"White"</span>,<span class="number">2018</span>);</span><br><span class="line">        Cars cars3 = <span class="keyword">new</span> Cars(<span class="string">"그랜져"</span>,<span class="string">"Brown"</span>,<span class="number">2002</span>);</span><br><span class="line">        Cars cars4 = <span class="keyword">new</span> Cars(<span class="string">"벤츠"</span>,<span class="string">"Yellow"</span>,<span class="number">2009</span>);</span><br><span class="line"></span><br><span class="line">        list.add(cars1);</span><br><span class="line">        list.add(cars2);</span><br><span class="line">        list.add(cars3);</span><br><span class="line">        list.add(cars4);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2002</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p><strong>Cars</strong>는 자동차 모델의 이름과 연식, 색상을 속성으로 가지고 각각 setter와 getter를 선언해주었습니다. 위의 경우와 동일하게 Arrays.sort(), Collections.sort()는 작동하지 않고 <code>오류</code>가 발생합니다. 이유는 <code>정렬을 시도했지만, 객체 내의 어떤 변수를 기준으로 정렬할 지 정하지 않았기 때문</code>입니다. String 타입의 배열이나 ArrayList는 값이 하나지만, 객체를 정렬할 경우 객체 내의 어떤 <strong>변수로 정렬할지 기준을 만들어줘야 합니다.</strong></p>
<p><strong>Comparable</strong>을 implements한 뒤 <strong>comparaTo</strong>메소드를 구현하면 해결할 수 있습니다. [오름차순만 가능]</p>
<p>Cars 클래스에서 <code>Comparable&lt;Cars&gt;</code>를 implements 하였습니다. 그리고 하단에 <strong>compareTo()</strong> 메소드를 오버라이드하여 코드를 추가했습니다. 매개변수로 Cars 객체를 받고 리턴값으로는 객체의 이름을 비교하는 구문을 넣어주었습니다.</p>
<p>여기서 본인이 정렬하고자 하는 클래스를 <code>Comparable&lt;클래스명&gt;</code> 형태로 넣어주는 것을 잊어서는 안됩니다. 이 경우에 정렬하고자 하는 클래스는 <strong>Cars</strong>라는 클래스!</p>
<p>자동차 객체를 4개 만들어서 ArrayList에 추가하였습니다. 그리고 Collections.sort()를 이용해 정렬을 시도하니 가나다 연식 순서로 정렬되어 나오는 결과를 확인할 수 있었습니다.</p>
<p>바로 Cars 클래스에서 Comparable을 implements하였고, 하단에 compareTo를 Override하며 연식 비교 코드를 만들어주었기 때문입니다. 이 부분을 연식이 아닌 자동차 모델 이름으로 바꿀 수 있습니다.</p>
<h2 id="comparator-인터페이스">Comparator<t> 인터페이스</t></h2>
<p>Comparable을 implements 하지 않고도 오브젝트의 특정 변수를 기준으로 정렬하는 방법이 있습니다. 이 때 사용하는 방법이 바로 <strong>Comparator</strong>입니다. <code>Comparator</code>를 사용하면 정렬 기준을 본인이 원하는대로 바꾸는 것이 가능합니다.<code>[오름차순, 내림차순 가능]</code>. <code>주로 객체의 특정 변수를 기준으로 정렬할 때 주로 이용합니다.</code> 이 때 Comparator 인터페이스를 구현한 클래스에서는 compare() 메소드를 재정의하여 사용하게 됩니다.</p>
<p>다음 예제는 SoccerPlayer라는 클래스의 객체를 Comparator 인터페이스를 통해 원하는 기준으로 정렬하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cars</span><span class="params">(String modelName, String color, <span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear + <span class="string">"식"</span> + <span class="keyword">this</span>.modelName + <span class="string">" "</span> + <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModelYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelYear</span><span class="params">(<span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arraysExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Cars&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Cars cars1 = <span class="keyword">new</span> Cars(<span class="string">"아반떼"</span>, <span class="string">"Black"</span>, <span class="number">2016</span>);</span><br><span class="line">        Cars cars2 = <span class="keyword">new</span> Cars(<span class="string">"소나타"</span>, <span class="string">"White"</span>, <span class="number">2018</span>);</span><br><span class="line">        Cars cars3 = <span class="keyword">new</span> Cars(<span class="string">"그랜져"</span>, <span class="string">"Brown"</span>, <span class="number">2002</span>);</span><br><span class="line">        Cars cars4 = <span class="keyword">new</span> Cars(<span class="string">"벤츠"</span>, <span class="string">"Yellow"</span>, <span class="number">2009</span>);</span><br><span class="line"></span><br><span class="line">        list.add(cars1);</span><br><span class="line">        list.add(cars2);</span><br><span class="line">        list.add(cars3);</span><br><span class="line">        list.add(cars4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 자동차 연식을 기준으로 내림차순 정렬</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Cars&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cars o1, Cars o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getModelYear() &gt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getModelYear() &lt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"내림 차순 정렬"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 자동차 연식을 기준으로 오름차순 정렬(원래 방식)</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Cars&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cars o1, Cars o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getModelYear() &gt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getModelYear() &lt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"오름 차순 정렬"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">내림 차순 정렬</span><br><span class="line"><span class="number">2018</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2002</span></span><br><span class="line">오름 차순 정렬</span><br><span class="line"><span class="number">2002</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p>SoccerPlayer 클래스에 <strong>Comparable</strong>을 implements하지 않은 상태로 Main에 Collections.sort()를 만들었습니다. 여기서는 <code>Collections.sort(playerList,new Comparator&lt;SoccerPlayer&gt;(){..}</code>형태로 구현해야 하며, 내부에 있는 compare() 메소드에서 객체의 어떤 필드를 기준으로 졍렬할 지 정해주면 도비니다. 자동차 클래스의 연식을 기준으로 오름차순과 내림차순으로 구현했습니다.</p>
<h2 id="결론">결론</h2>
<p><strong>Comparable</strong> 구현 후 내부의 <strong>compareTo</strong> 메소드를 오버라이드해서 정의해야 하는데, 이 정의 결과에 따라 정렬 값이 나옵니다. 또한, 오브젝트의 다른 값으로 비교를 원한다면 <strong>compareTo</strong>를 하나하나 바꿔줄 필요 없이, <strong>Comparator</strong>를 이용하면 됩니다.</p>
<p>Comparator의 compare()와 Comparable의 compareTo()는 두 객체를 비교한다는 같은 기능을 목적으로 만들어 졌습니다. compareTo() 메소드는 반환값은 int지만 실제로는 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구혀해야 합니다. compare()도 객체를 비교해서 음수, 0, 양수 중 하나를 반환하도록 구현해야 합니다.</p>
<blockquote>
<p>Comparable - 기본 정렬 기준(오름차순)을 구현하는데 사용<br>
Comparator - 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용</p>
</blockquote>
<p>Collections.sort() , Arrays.sort() 등 ~~.sort()는 배열이나 리스트를 정렬할 때 Comparator를 지정하지 않았을 경우<br>
<strong>Comprarable</strong>을 구현하면 구현한 클래스의 객체에 구현된 내용에 따라 정렬!!</p>
<p>Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> <span class="comment">// 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, Comparator c)</span> <span class="comment">// 지정한 Comparator에 의한 정렬</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>다음과 같은 함수들도 존재합니다.
<ul>
<li>Arrays.sort()</li>
<li>Arrays.reverse()</li>
<li>Collections.sort()</li>
<li>Collections.reverse()</li>
</ul>
</li>
</ul>
<h1 id="set">Set</h1>
<hr>
<p><strong>특징</strong></p>
<ol>
<li>순서가 없습니다.</li>
<li>집합이므로 중복된 데이터가 들어갈 수 없습니다.</li>
<li>중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용합니다.</li>
</ol>
<p>Collection의 일부인데 <code>중복되는 element를 포함하지 않는 것</code>이 가장 큰 특징이며, <code>집합</code>을 의미합니다. <strong>Set</strong>인터페이스는 Collection를 상속받아서 만들어진 인터페이스입니다. 때문에 대부분의 함수들이 Collection에서 제공하는 함수들과 동일합니다.</p>
<p><strong>List</strong>와 <strong>Set</strong>은 Collection 인터페이스를 구현한다는 점에서 비슷하다고 할 수 있습니다. 그러나 가장 큰 차이점은 <code>중복</code>에 대한 부분에서의 차이입니다.<br>
List는 같은 값에 대한 중복 추가가 가능합니다. 그러나 <code>Set</code>은 같은 값을 넣었을 때 size()로 내부 엘리먼트의 개수를 출력해보면 1이 나오는 것을 확인할 수 있습니다. 즉, 값(value)에 대한 중복을 허용하지 않습니다.</p>
<p>대표적인 Set 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>HashSet<e></e></li>
<li>TreeSet<e></e></li>
</ol>
<h2 id="hashset-클래스">HashSet<e> 클래스</e></h2>
<p>HashSet 클래스는 Set 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. JDK 1.2부터 제공된 HashSet 클래스는 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠릅니다. 이러한 HashSet 클래스는 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다.</p>
<p>HashSet 클래스는 Set 인터페이스를 구현하므로, <strong>요소를 순서에 상관없이 저장하고, 중복된 값은 저장하지 않습니다.</strong> 만약 요소의 저장 순서를 유지해야 한다면 JDK 1.4부터 제공하는 LinkedHashSet 클래스를 사용하면 됩니다.</p>
<blockquote>
<p>사용법</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        hs.add(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="number">2</span>);</span><br><span class="line">        hs.add(<span class="number">3</span>);</span><br><span class="line">        hs.add(<span class="number">4</span>);</span><br><span class="line">        hs.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 1번</span></span><br><span class="line">        System.out.println(hs.add(<span class="number">10</span>));</span><br><span class="line">        System.out.println(hs.add(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; hs2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        hs2.add(<span class="number">3</span>);</span><br><span class="line">        hs2.add(<span class="number">4</span>);</span><br><span class="line">        hs2.add(<span class="number">5</span>);</span><br><span class="line">        hs2.add(<span class="number">6</span>);</span><br><span class="line">        hs2.add(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 교집합을 구하기 위해서는 retainAll()이라는 메소드를 사용합니다.</span></span><br><span class="line">        hs.retainAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"교집합 : "</span> + hs.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 집합 hs2는 hs의 부분집합이다.</span></span><br><span class="line">        <span class="comment">// 이것이 맞는지 알아보기 위해서는 containsAll()을 사용하면 된다.</span></span><br><span class="line">        System.out.println(hs.containsAll(hs2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 차집합을 구하기 위해서는 removeAll()이라는 메소드를 사용합니다</span></span><br><span class="line">        <span class="comment">// 집합 hs와 집합 hs2에서 집합 hs의 값들 중에서 집합 hs2에도 있는 값을</span></span><br><span class="line">        <span class="comment">// 뺀 값들이 나옵니다.</span></span><br><span class="line">        hs.removeAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"차집합: "</span> + hs.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 합집합을 구하기 위해서는 addAll()이라는 메소드를 사용하면 됩니다.</span></span><br><span class="line">        hs.addAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"합집합 : "</span> + hs.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>containsAll()</strong> : 부분집합임을 알아보기 위해서 사용</li>
<li><strong>addAll()</strong> : 합집합을 구하기 위해서 사용[합집합으로 합쳐집니다.]</li>
<li><strong>removeAll()</strong> : 차집합을 구하기 위해서 사용[hs에서 hs2를 뺀 부분을 보여줍니다.]</li>
<li><strong>retainAll()</strong> : 교집합을 구하기 위해서 사용[두 집합 중 공통된 값을 뽑아냅니다.]</li>
</ul>
<p>1번에서와 같이 add() 메소드를 사용하여 해당 HashSet에 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false를 반환하는 것을 볼 수 있습니다.</p>
<p>이때 해당 HashSet에 이미 존재하는 요소인지를 파악하기 위해서는 내부적으로 다음과 같은 과정을 거치게 됩니다.</p>
<ol>
<li>해당 요소에서 hasCode() 메소드를 호출하여 반환된 해시값으로 검색할 범위를 결정합니다.</li>
<li>해당 범위 내의 요소들을 equals() 메소드로 비교합니다.</li>
</ol>
<p>따라서 HashSet에서 add() 메소드를 사용하여 중복 없이 새로운 요소를 추가하기 위해서는 hashCode()와 equals() 메소드를 상황에 맞게 오버라이딩해야 합니다.</p>
<p><strong>오버라이딩을 통해 작성된 <code>hashCode()</code>는 다음의 세 가지 조건을 만족 시켜야 합니다.</strong></p>
<ol>
<li>실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int 값을 반환해야 합니다. 하지만, 실행 시마다 동일한 int값을 반환할 필요는 없습니다. (String 클래스는 문자열의 내용으로 해시코드를 만들어 내기 때문에 내용이 같은 문자열에 대한 hashCode() 호출은 항상 동일한 해키코드를 반환합니다. 반면에 Object 클래스는 객체의 주소로 해시코드를 만들어 내기 때문에 실행할 때마다 해시코드 값이 달라질 수 있습니다.)</li>
<li>equals 메소드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 합니다.</li>
<li>equals() 메소드를 호출했을 때 false를 반환하는 두 객체는 hashCode() 호출에 대해 같은 int 값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int 값을 반환하는 것이 좋습니다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; hSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">hSet.add(<span class="string">"자바"</span>);</span><br><span class="line">hSet.add(<span class="string">"서블릿"</span>);</span><br><span class="line">hSet.add(<span class="string">"스프링"</span>);</span><br><span class="line">hSet.add(<span class="string">"안드로이드"</span>);</span><br><span class="line">hSet.add(<span class="string">"자바"</span>); <span class="comment">// 중복된 데이터</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈는 4가 나옵니다. 중복을 제거함</span></span><br><span class="line">System.out.println(<span class="string">"hSet의 개수:"</span>+hSet.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator의 사용</span></span><br><span class="line">Iterator&lt;String&gt; it = hSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashSet</strong>은 <code>Iterator</code>를 사용합니다. 이유는 set은 순서가 없기 때문에 데이터에 순서를 정해서 추출해야하기 때문입니다. 중복이 안되는 것을 생각하면 <strong>Hashtable</strong>이나 <strong>HashMap</strong>과 같은 Map 형태가 떠오를 수 있습니다. 그러나 다른 점이라면, Map에서는 형태를 가진다는 점이 가장 큰차이입니다. 중복을 검사하는 대상 자체가 <strong>Key,Value</strong>이기 때문에 <code>Key를 기준으로 중복검사</code>를 하게 됩니다. <strong>이것은 중복되는 key 값을 가져서는 안되고, value는 중복되더라도 상관없다는 이야기입니다.</strong></p>
<h2 id="treeset-클래스">TreeSet<e> 클래스</e></h2>
<p><strong>TressSet 클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리(binary search three)의 형태로 요소를 저장합니다.</strong><br>
이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. JDK 1.2부터 제공되는 TreeSet 클래스는 NavigableSet 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현합니다. TreeSet 클래스는 Set 인터페이스를 구현하므로, 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장 순서를 유지하지도 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        treeSet.add(<span class="number">30</span>);</span><br><span class="line">        treeSet.add(<span class="number">40</span>);</span><br><span class="line">        treeSet.add(<span class="number">20</span>);</span><br><span class="line">        treeSet.add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for문을 이용한 요소의 출력</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : treeSet) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소의 제거</span></span><br><span class="line">        treeSet.remove(<span class="number">40</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 크기 출력</span></span><br><span class="line">        System.out.println(<span class="string">"이진 검색 트리의 크기 : "</span> + treeSet.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// subSet() 메소드를 이용한 부분 집합의 출력</span></span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet.subSet(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet.subSet(<span class="number">10</span>, <span class="keyword">true</span>, <span class="number">20</span>, <span class="keyword">true</span>)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br><span class="line">이진 검색 트리의 크기 : <span class="number">3</span></span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 TreeSet 인스턴스에 저장되는 요소들은 모두 <strong>정렬</strong>된 상태로 저장됩니다. 또한, 위에서 사용된 subSet() 메소드는 TreeSet() 인스턴스에 저장되는 요소가 모두 정렬된 상태이기에 동작이 가능한 해당 트리의 부분 집합만을 보여주는 메소드입니다.</p>
<p>1번 라인에서 사용된 subSet() 메소드는 첫 번째 매개변수로 전달된 값에 해당하는 요소부터 시작하여 두 번째 매개변수로 전달된 값에 해당하는 요소의 바로 직전 요소까지를 반환합니다.<br>
2번 라인에서 사용된 subSet() 메소드는 두 번째와 네 번째 매개변수로 각각 첫 번째와 세 번째 매개변수로 전달된 값에 해당하는 요소를 포함할 것인지 아닌지를 명시할 수 있습니다. 즉, 2번 라인에서 네 번째 매개변수를 false로 변경하면 20을 포함하지 않게 되므로, 1번 라인과 같은 결과를 출력할 것입니다.</p>
<h2 id="set을-정렬하는-방법">Set을 정렬하는 방법</h2>
<p><strong>Set</strong>은 중복 없이 값을 넣기 위한 객체입니다. 여기서는 <code>List</code>를 사용해서 <strong>Set</strong>을 정렬할 수 있습니다. 이 방법을 이용해서 공부해보고 사용해보았습니다.</p>
<p>먼저, fruits의 객체가 있고, <strong>banana, apple, peach</strong>의 중복없는 값을 삽입합니다. 이렇게 삽입한 <code>Set</code>을 정렬하기 위해서는 fruits의 객체를 <code>List</code>로 변환을 해야합니다. 변환하는 방법은 ArrayList를 만드는 방식과 동일하고 생성자에 fruits를 넣어주면 리스트 형태로 변환이 됩니다. 여기서 공부했던 것을 떠올려보면 <code>List</code>를 정렬하기 위해서는 <strong>Collections</strong>를 사용하면 됩니다!!!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set fruits = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">fruits.add(<span class="string">"banana"</span>):</span><br><span class="line">fruits.add(<span class="string">"apple"</span>):</span><br><span class="line">fruits.add(<span class="string">"peach"</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 List로 변환</span></span><br><span class="line">List fruitsList = <span class="keyword">new</span> ArrayList(fruits);</span><br><span class="line"><span class="comment">// List 정렬</span></span><br><span class="line">Collections.sort(fruitsList);</span><br><span class="line"><span class="keyword">for</span>(String s : fruitsList)&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">peach</span><br></pre></td></tr></table></figure>
<h2 id="set-인터페이스">Set 인터페이스</h2>
<p>Set 인터페이스는 Collection 인터페이스를 상속받으므로, Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있습니다. Set 인터페이스에서 제공하는 주요 메소드는 다음과 같습니다.</p>
<img src="/img/set_interface.png" width="500" height="200">
<h1 id="map">Map</h1>
<hr>
<p><code>Map</code> 인터페이스는 Collection 인터페이스와는 다른 저장 방식을 가집니다. Map 인터페이스를 구현한 Map 컬렉션 클래스들은 <strong>키와 값을 하나의 쌍으로 저장하는 방식을 사용합니다. (key-value)</strong><br>
여기서 key란 실질적인 value를 찾기 위한 이름의 역할을 합니다.</p>
<ul>
<li>특징</li>
</ul>
<ol>
<li>요소의 저장 순서를 유지하지 않습니다.</li>
<li>key는 중복을 허용하지 않지만, 값의 중복은 허용합니다.</li>
</ol>
<p>대표적인 Map 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>HashMap&lt;K,V&gt;</li>
<li>Hashtable&lt;K,V&gt;</li>
<li>TreeMap&lt;K,V&gt;</li>
</ol>
<h2 id="hashmapltkvgt">HashMap&lt;K,V&gt;</h2>
<p>Map 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. 그리고 JDK 1.2부터 제공된 <code>HashMap 클래스</code>는 <strong>해시 알고리즘</strong>을 사용하여 검색 속도가 매우 빠릅니다.</p>
<p><strong>HashMap 클래스는 Map 인터페이스를 구현하므로, Map의 특징인 키(Key)와 값(value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖고 있습니다. 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보입니다. 또한, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// put 메소드를 이용한 요소의 저장</span></span><br><span class="line">        map.put(<span class="string">"십"</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"삼십"</span>, <span class="number">30</span>);</span><br><span class="line">        map.put(<span class="string">"사십"</span>, <span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"이백"</span>, <span class="number">200</span>);</span><br><span class="line">        map.put(<span class="string">"십"</span>,<span class="number">30</span>); <span class="comment">// 1</span></span><br><span class="line">        map.put(<span class="string">"십"</span>,<span class="number">1010</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ketSet()을 이용해서 해당 맵에 포함된 모든 키 값들을 하나의 집합(Set)으로 반환해줍니다.</span></span><br><span class="line">        System.out.println(<span class="string">"Map에 저장된 키들의 집합:"</span> + map.keySet());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get() 메소드는 해당 key에 맞는 value 값을 반환합니다.</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키: %s, 값: %s"</span>, key, map.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소 제거</span></span><br><span class="line">        System.out.println(<span class="string">"remove : "</span>+map.remove(<span class="string">"사십"</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;String&gt; keys = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">            String key = keys.next();</span><br><span class="line">            System.out.println(<span class="string">"키 : "</span> + key + <span class="string">", "</span> + <span class="string">"값 : "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace() 메소드를 이용한 요소의 수정</span></span><br><span class="line">        map.replace(<span class="string">"이백"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"값을 수정 한 후 =&gt; "</span>+String.format(<span class="string">"키 : %s, 값 : %s"</span>,<span class="string">"이백"</span>,map.get(<span class="string">"이백"</span>))); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map 사이즈 출력</span></span><br><span class="line">        System.out.println(<span class="string">"Map의 크기 : "</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Map에 저장된 키들의 집합:[이백, 삼십, 사십, 십]</span><br><span class="line"></span><br><span class="line">키: 이백, 값: <span class="number">200</span></span><br><span class="line">키: 삼십, 값: <span class="number">30</span></span><br><span class="line">키: 사십, 값: <span class="number">40</span></span><br><span class="line">키: 십, 값: <span class="number">1010</span></span><br><span class="line">remove : <span class="number">40</span></span><br><span class="line"></span><br><span class="line">키 : 이백, 값 : <span class="number">200</span></span><br><span class="line">키 : 삼십, 값 : <span class="number">30</span></span><br><span class="line">키 : 십, 값 : <span class="number">1010</span></span><br><span class="line">값을 수정 한 후 =&gt; 키 : 이백, 값 : <span class="number">20</span></span><br><span class="line">Map의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>1번 라인에서와 같이 동일한 키 값으로 데이터를 저장하게 되면 가장 나중에 저장된 데이터가 반영됩니다.</p>
<blockquote>
<p>자주 사용되는 for문인 Enhanced for문은 배열과 컬렉션 프레임워크에서 해당 인스턴스에 저장된 모든 요소를 순회해야 할 경우에 자주 사용됩니다.</p>
</blockquote>
<ul>
<li><strong>특징</strong>
<ul>
<li>요소의 저장순서를 유지하지 않습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>메소드</p>
</blockquote>
<ul>
<li>V replace(K key, V value) : 해당 맵에서 전달된 키에 대응하는 값을 특정 값으로 대체</li>
<li>boolean replace(K key, V oldValue, V newV) : 해당 맵에서 특정 값에 대응하는 전달된 키의 값을 새로운 값으로 대체함</li>
<li>void clear() : Map의 모든 객체를 삭제한다.</li>
<li>boolean containsKey(Object key) : 지정된 key객체와 일치하는 Map의 Key객체가 있는지 확인한다.</li>
<li>boolean containsValue(Object value) : 지정된 value객체와 일치하는 Map의 Value객체가 있는지 확인한다.</li>
<li>Set entrySet() : Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.</li>
<li>booelan equals(Object o) : 동일한 Map인지 비교한다.</li>
<li>Object get(Object key) : 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.</li>
<li>int hashCode() : 해시코드를 반환한다.</li>
<li>boolean isEmpty() : Map이 비어있는지 확인한다.</li>
<li>Set keySet() : Map에 저장된 모든 Key객체를 반환한다.</li>
<li>Object put(Object key, Object value) : Map에 value객체를 key객체에 연결(mapping)하여 저장한다.</li>
<li>void putAll(Map t) : 지정된 Map의 모든 key-value 쌍을 추가한다.</li>
<li>Object remove(Object key) : 지정한 key객체와 일치하는 key-value객체를 삭제한다.</li>
<li>int size() : Map에 저장된 key-value 쌍의 개수를 반환한다.</li>
<li>Collection values() : Map에 저장된 모든 value객체를 반환한다.</li>
<li>V remove(Object key) : 해당 맵에서 전달된 키에 대응하는 매핑을 제거함.</li>
<li>boolean remove(Object key, Object value) : 해당 맵에서 특정 값에 대응하는 특정 키의 매핑을 제거함.</li>
</ul>
<blockquote>
<p>자바 공식 문서에서는 키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술하고 있습니다.</p>
</blockquote>
<p><strong>Map 인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환하고, 키(Key)는 중복을 허용하지 않기 때문에 Set 타입으로 반환합니다.</strong></p>
<blockquote>
<p>참고</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry[] table; <span class="comment">// Entry 타입의 배열</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123; <span class="comment">// 내부 클래스</span></span><br><span class="line">        <span class="keyword">final</span> Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap은 Entry라는 내부 클래스를 다시 정의하고, 다시 Entry 타입의 배열을 선언하고 있습니다. 키(key)와  값(value)은 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직하기 때문입니다.</p>
<p>HashMap은 키와 값을 각각 Object 타입으로 저장합니다. 즉 어떠한 객체도 저장할 수 있지만 키는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 합니다.</p>
<h2 id="hashtableltkeyvaluegt">Hashtable&lt;Key,Value&gt;</h2>
<p><code>Hashtable</code> 클래스는 JDK 1.0부터 사용해 온 <strong>HashMap</strong> 클래스와 같은 동작을 하는 클래스입니다. 현재의 Hashtable 클래스는 HashMap 클래스와 마찬가지로 Map 인터페이스를 상속받습니다.</p>
<p>따라서 Hashtable 클래스에서 사용할 수 있는 메소드는 HashMap 클래스에서 사용할 수 있는 메소드와 거의 같습니다. 하지만 현재에는 <strong>기존 코드와의 호환성</strong>을 위해서만 남아있으므로, Hashtable 클래스보다는 <code>HashMap</code> 클래스를 사용하는 것이 좋습니다.</p>
<h2 id="treemapltkeyvaluegt">TreeMap&lt;Key,Value&gt;</h2>
<p>TreeMap 클래스는 Key와 Value를 한 쌍으로 하는 데이터를 <code>이진 검색 트리</code>의 형태로 저장합니다. <code>이진 검색 트리</code>는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 <code>Red-Black Tree</code>로 구현합니다.</p>
<p><code>TreeMap</code> 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, String&gt; tm = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        tm.put(<span class="number">30</span>, <span class="string">"삼십"</span>);</span><br><span class="line">        tm.put(<span class="number">10</span>, <span class="string">"십"</span>);</span><br><span class="line">        tm.put(<span class="number">40</span>, <span class="string">"사십"</span>);</span><br><span class="line">        tm.put(<span class="number">20</span>, <span class="string">"오십"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for 문과 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        System.out.println(<span class="string">"맵에 저장된 키들의 집합 : "</span> + tm.keySet());</span><br><span class="line">        <span class="keyword">for</span> (Integer key : tm.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소의 제거</span></span><br><span class="line">        tm.remove(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; keys = tm.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">            Integer key = keys.next();</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace() 메소드를 이용한 요소의 수정</span></span><br><span class="line">        tm.replace(<span class="number">20</span>, <span class="string">"twenty"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer key : tm.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(<span class="string">"맵의 크기 : "</span> + tm.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">맵에 저장된 키들의 집합 : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : 오십</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line">키 : <span class="number">40</span>, 값 : 사십</span><br><span class="line"></span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : 오십</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line"></span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : twenty</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line"></span><br><span class="line">맵의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>위의 결과와 같이 TreeMap은 <strong>이진 검색 트리를 사용하므로 Map에 저장된 값들은 키(Key)를 기준으로 정렬된 형태로 데이터가 저장됩니다.</strong></p>
<img src="/img/clf2.png" width="650" height="200">
<img src="/img/clf3.png" width="650" height="200">
<h2 id="mapentry-인터페이스">Map.Entry 인터페이스</h2>
<p><strong>Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스</strong>입니다. 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스를 정의하는 것이 가능합니다.</p>
<p>Map에 저장되는 key-value(Entry) 쌍으 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았습니다.</p>
<ul>
<li>boolean equals(Object o) : 동일한 Entry인지 비교합니다.</li>
<li>Object getKey() : Entry의 key 객체를 반환합니다.</li>
<li>Object getValue() : Entry의 value 객체를 반환합니다.</li>
<li>int hashCode() : Entry의 해시코드를 반환합니다.</li>
<li>Object setValue(Object value) : Entry의 value 객체를 지정된 객체로 바꿉니다.</li>
</ul>
<h2 id="해시-알고리즘hash-algorithm">해시 알고리즘(hash algorithm)</h2>
<p><strong>해시 알고리즘(hash algorithm)이란 해시 함수(hash function)를 사용하여 데이터를 해시 테이블(hash table)에 저장하고, 다시 그것을 검색하는 알고리즘입니다. 해시 함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있습니다.</strong></p>
<img src="/img/hashset_pic.png" width="500" height="200">
<p>자바에서 해시 알고리즘을 이용한 자료 구조는 위의 그림과 같이 배열과 연결 리스트로 구현됩니다. 저장할 데이터의 키 값을 해시 함수에 넣어 반환되는 값으로 배열의 인덱스를 구합니다. 그리고서 해당 인덱스에 저장된 연결 리스트에 데이터를 저장하게 됩니다.</p>
<p>예를 들어, 정수형 데이터를 길이가 10인 배열에 저장한다고 한다면 1,000,002를 검색하는 방법은 다음과 같을 수 있습니다. 1,000,002를 10으로 나눈 나머지가 2이므로 배열의 세 번째 요소에 연결된 연결 리스트에서 검색을 시작합니다. 매우 간략화한 예제이지만, 이렇게 해시 알고리즘을 이용하면 매우 빠르게 검색 작업을 수행할 수 있습니다.</p>
<p>저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 됩니다.</p>
<ol>
<li>검색하고자 하는 값의 키로 해시함수를 호출합니다.</li>
<li>해시함수의 계산결괴인 해시코드를 이용해서 해당 값이 저장되어 있는 링크드 리스트를 찾습니다.</li>
<li>링크드 리스트에서 검색한 키와 일치하는 데이터를 찾습니다.</li>
</ol>
<p>링크드 리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 됩니다.</p>
<p>하나의 링크드 리스트에 최소한의 데이터만 저장되려면, 저장될 데이터의 크기를 고려해서 HashMap의 크기를 적절하게 지정해주어야 하고, 해시 함수가 서로 다른 키에 대해서 중복된 해시코드의 반환을 최소화해야 합니다. 그래야 HashMap에서 빠른 검색시간을 얻을 수 있습니다.</p>
<p>실제로는 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object 클래스에서 정의된 hashCode()를 해시함수로 사용합니다. Object 클래스에 정의된 hashCode()는 각 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 hashCode()를 호출한 결과가 서로 다른 좋은 방법입니다.</p>
<p>String 클래스의 경우 Object로부터 상속받은 hashCode()를 오버라이딩해서 문자열의 내용으로 해시코들 ㄹ만들어 냅니다. 그래서 서로 다른 String 인스턴스일지라도 같은 문자열을 가졌다면 hashCode()를 호출하면 같은 해시코드를 얻어냅니다.</p>
<p>HashSet과 마찬가지로 HashMap에서도 서로 다른 두 객체에 대해 equals()로 비교한 결과가 true인 동시에 hashCode()의 반환값이 같아야 같은 객체로 인식합니다.(이미 존재하는 키에 대한 값을 저장하면 기존의 값을 새로운 값으로 덮어씁니다.)</p>
<p>그래서 새로운 클래스를 정의할 때 equals()를 오버라이딩해야 한다면 hashCode()도 같이 오버라이딩해서 equals()의 결과가 true인 두 객체의 해시코드가 항상 같도록 해주어야 합니다.</p>
<p>그렇지 않으면 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 equals()의 호출 결과가 true이지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장할 것입니다.</p>
<h2 id="properties">Properties</h2>
<p><code>Properties</code>는 HashMap의 구 버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키와 값을 (Object, Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 보다 단순한 컬렉션 클래스입니다.</p>
<p><strong>주로 애플리케이션의 환경설정과 관련된 속성(property)을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공합니다.</strong></p>
<h1 id="iterator-listiterator-enumeration">Iterator, ListIterator, Enumeration</h1>
<hr>
<p>위에서 공부를 하던 중에 컬렉션 프레임워크 중에서 List, Map, Set 등을 이용한 자료 구조에서 데이터에 접근하기 위해서는 가장 익숙한 for문을 사용해서 접근할 수 있습니다. for문을 사용하면 가장 간단하고 쉽게 접근할 수 있죠!</p>
<p>하지만, 내가 크기를 모른다면? 혹은 Set,Map과 같이 순서를 유지하지 않는다면 어떻게 접근할 수 있을까요?? 라는 의문에서 나온 것이 Iterator라고 생각합니다.</p>
<p><strong>Iterator, ListIterator, Enumeration</strong>은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스입니다. Enumeration은 Iterator의 구 버전이며, ListIterator는 Iterator의 기능을 향상 시킨 것 입니다.</p>
<h2 id="iterator">Iterator</h2>
<p><strong>컬렉션 프레임워크에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였습니다. 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고, Collection 인터페이스에는 Iterator를 반환하는 iterator() 함수를 정의하고 있습니다.</strong></p>
<p><strong><code>iterator()</code>는 Collection 인터페이스에 정의된 메소드이므로 Collection 인터페이스의 자손인 List와 Set에도 포함되어 있습니다.</strong> 그래서 List나 Set 인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있습니다. 추가적으로 Map에서도 iterator()를 사용할 수 있는데, 이는 Map의 키 집합을 반환하는 <strong>keySet()</strong> 함수는 Set을 반환하므로 iterator()를 사용할 수 있습니다.</p>
<ul>
<li>boolean hasNext() : 읽어 올 다음 요소가 남아있는지 확인합니다. 해당 이터레이션이 다음 요소를 가지고 있으면 true를 반환하고, 더 이상 다음 요소를 가지고 있지 않으면 false를 반환합니다.</li>
<li>Object next() : 다음 요소를 읽어 옵니다. next()를 호춣하기 전에 hasNext()를 호출해서 읽어 올 요소가 남아있는지 확인하는 것이 안전합니다.</li>
<li>void remove() : next()로 읽어 온 요소를 삭제합니다.(선택적 기능)</li>
</ul>
<blockquote>
<p>하지만 현재 자바에서는 될 수 있으면 JDK 1.5부터 추가된 Enhaced for문을 사용하도록 권장하고 있습니다. Enhanced for문을 사용하면 같은 성능을 유지하면서도 코드의 명확성을 확보하고 발생할 수 있는 버그를 예방해 줍니다. 하지만 요소의 선택적 제거나 대체 등을 수행하기 위한 경우에는 반복자(iterator)를 사용해야만 합니다.</p>
</blockquote>
<h2 id="listiterator와-enumeration">ListIterator와 Enumeration</h2>
<p><strong>Enumeration</strong>은 컬렉션 프레임워크가 만들어지기 이전에 사용하던 것으로 Iterator의 구 버전이라고 생각하면 됩니다.</p>
<p><strong>ListIterator</strong>는 Iterator를 상속 받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있는데 반해 ListIterator는 양방향으로의 이동이 가능합니다. 다만, List 인터페이스를 구현한 컬렉션에서만 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;Integer&gt; iterator = list.listIterator();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"순방향 접근"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"역방향 접근"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious())&#123;</span><br><span class="line">            System.out.print(iterator.previous()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">순방향 접근</span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> </span><br><span class="line">역방향 접근</span><br><span class="line"><span class="number">1</span> <span class="number">9</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<img src="/img/listIterator.png" width="700" height="300">
<h1 id="collections">Collections</h1>
<hr>
<p>Arrays가 배열과 관련된 메소드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메소드를 제공합니다. fill(), copy(), sort(), binarySearch() 등의 메소드는 두 클래스에 포함되어 있으며 같은 기능을 합니다.</p>
<h2 id="컬렉션의-동기화">컬렉션의 동기화</h2>
<p>멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 공유되는 객체의 동기화(synchrnization)가 필요합니다.</p>
<p>Vector와 Hashtable과 같은 구버전(JDK 1.2 이전)의 클래스들은 자체적으로 동기화 처리가 되어 있는데, 멀티 쓰레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨리는 요인이 됩니다.</p>
<p>그래서 새로 추가된 ArrayList나 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 java.util.Collections 클래스의 동기화 메소드를 이용해서 동기화 처리가 가능하도록 변경하였습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">synchronizedCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="변경불가-컬렉션-만들기">변경불가 컬렉션 만들기</h2>
<p>컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게 <strong>읽기 전용</strong>으로 만들어야 할 때가 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">unmodifiableCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">unmodifiableList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">unmodifiableSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">unmodifiableMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">unmodifiableSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">unmodifiableSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="컬렉션-클래스-정리-amp-요약">컬렉션 클래스 정리 &amp; 요약</h2>
<ul>
<li><strong>ArrayList</strong> : 배열기반, 데이터의 추가와 삭제에 불리합니다. 순차적인 추가/삭제는 제일 빠르고 임의의 요소에 대한 접근성이 뛰어납니다.</li>
<li><strong>LinkedList</strong> : 연결기반, 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않습니다.</li>
<li><strong>HashMap</strong> : 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어나고, 검색에는 최고 성능을 보입니다.</li>
</ul>

        </div>
        
        <footer class="article-footer">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
            



    <a data-url="https://woovictory.github.io/2018/03/08/java-collection-framework/" data-id="ck8h98bdu0191icpqm4yvquwy" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://www.facebook.com/WooVictory" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/WooVictory" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="linkedin" href="https://www.linkedin.com/in/seungwoo-lee-590844177" target="_blank" rel="noopener">
                        <i class="icon fa fa-linkedin"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/03/19/JavaCollectionPriorityQueue/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            자바 :: Priority Queue?
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/03/02/Android-ActivityLifeCycle/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title"> [안드로이드] 4대 컴포넌트</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
        
            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">58</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/">CS</a><span class="category-list-count">42</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CS/Design-Pattern/">Design Pattern</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/OS/">OS</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/개발-상식/">개발 상식</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/네트워크/">네트워크</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/데이터베이스/">데이터베이스</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/알고리즘/">알고리즘</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CS/자료구조/">자료구조</a><span class="category-list-count">9</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a><span class="category-list-count">85</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Android/">Android</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Inno-SOPT/">Inno_SOPT</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Java/">Java</a><span class="category-list-count">34</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Kotlin/">Kotlin</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/Node-js/">Node.js</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/RxJava/">RxJava</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/etc/">etc</a><span class="category-list-count">5</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a><span class="category-list-count">52</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/BOJ/">BOJ</a><span class="category-list-count">49</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/Programmers/">Programmers</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/개념/">개념</a><span class="category-list-count">1</span></li></ul></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2020/04/01/KotlinInAction-Chap4/" class="title">[Kotlin] Chap4. 클래스와 인터페이스</a></p>
                            <p class="item-date"><time datetime="2020-04-01T11:26:32.000Z" itemprop="datePublished">2020-04-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2020/04/01/KotlinInAction-Chap3/" class="title">[Kotlin] Chap3. 함수 정의와 호출</a></p>
                            <p class="item-date"><time datetime="2020-04-01T11:02:44.000Z" itemprop="datePublished">2020-04-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2020/04/01/KotlinInAction-Chap2/" class="title">[Kotlin] Chap2. 코틀린 기초</a></p>
                            <p class="item-date"><time datetime="2020-04-01T10:49:20.000Z" itemprop="datePublished">2020-04-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2020/03/27/Android-Room-Concept/" class="title">[Android] Room 개념편</a></p>
                            <p class="item-date"><time datetime="2020-03-27T05:22:06.000Z" itemprop="datePublished">2020-03-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2020/03/07/Android-Mockito-Advanced/" class="title">[Android] Mockito 심화편</a></p>
                            <p class="item-date"><time datetime="2020-03-06T16:08:22.000Z" itemprop="datePublished">2020-03-07</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
        
    </div>
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2020 VictoryWoo</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
(adsbygoogle = window.adsbygoogle || []).push({
     google_ad_client: "ca-pub-9725307592233286",
     enable_page_level_ads: true
});
</script>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://woovictory.github.io/2018/03/08/java-collection-framework/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
