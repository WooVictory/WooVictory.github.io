<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta name="google-site-verification" content="AFirxOxuB2W32dZY1PrMx4c6K3RsM3XVAkRIkCJEEpI" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/android.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          Java :: Collection Framework - VictoryWoo | Blog
        
    </title>

    <link rel="canonical" href="https://woovictory.github.io/2018/03/08/java-collection-framework/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/header_img/luca-bravo-149740-unsplash.jpg')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/null');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#Java" title="Java">Java</a>
                            
                        </div>
                        <h1>Java :: Collection Framework</h1>
                        <h2 class="subheading">Collection Framework</h2>
                        <span class="meta">
                            Posted by VictoryWoo on
                            2018-03-08
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">VictoryWoo</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">about</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 <strong>Collection Framework</strong>에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데, 일반적으로 많이 사용되는 자료구조는 <code>리스트, 스택, 큐, 해쉬 테이블</code>이 있습니다.</p>
</blockquote>
<p>이전에 포스팅했던 자료들은 자료구조별로 정리했었는데, 모두 삭제하고 하나의 포스팅에 압축해서 공부하고 올리도록 하겠습니다. :)</p>
<h1 id="컬렉션-프레임워크">컬렉션 프레임워크</h1>
<hr>
<p>자바에서 컬렉션 프레임워크(collection framework)란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.<br>
즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.</p>
<p>이러한 <strong>컬렉션 프레임워크</strong>는 자바의 인터페이스를 사용하여 구현됩니다.</p>
<h2 id="컬렉션-프레임워크-핵심-인터페이스">컬렉션 프레임워크 핵심 인터페이스</h2>
<p>컬렉션 프레임워크에서는 컬렉션(데이터 그룹)을 크게 3가지 타입으로 구분하여 3가지 인터페이스를 정의했습니다. 그리고 인터페이스 중 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였습니다.</p>
<p>인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통 부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했습니다.</p>
<blockquote>
<p>주요 인터페이스 간의 상속 관계</p>
</blockquote>
<img src="/img/collection_framework.png" width="500" height="200">
<ul>
<li><strong>List</strong> : 순서가 있는 데이터의 집합. 데이터의 중복을 허용합니다.
<ul>
<li>구현 클래스 : ArrayList, LinkedList, Stack, Vector 등</li>
</ul>
</li>
<li><strong>Set</strong> : 순서를 유지하지 않는 데이터의 집합(순서가 없음). 데이터의 중복을 허용하지 않습니다.(Key)
<ul>
<li>구현 클래스 : HashSet, TreeSet 등</li>
</ul>
</li>
<li><strong>Map</strong> : 키(Key)와 값(value)의 쌍(Pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며(순서가 없음), 키는 중복을 허용하지 않고, <strong>값은 중복을 허용합니다.</strong>
<ul>
<li>구현 클래스: HashMap, TreeMap, Hashtable, Properties 등</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임워크의 명명법을 따르지 않습니다. Vector나 Hashtable과 같은 기존의 컬렉션들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다고 합니다. 그 대신 새로 추가된 <strong>ArrayList</strong>나 <strong>HashMap</strong>을 사용하는 것이 성능 면에서도 더 나은 결과를 얻을 수 있습니다.</p>
</blockquote>
<h2 id="collection-인터페이스">Collection 인터페이스</h2>
<p>List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고, 두 인터페이스는 그것을 상속받습니다. 따라서 <strong>Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고, 그것을 메소드로 제공하고 있습니다.</strong></p>
<ul>
<li>boolean add(Object o) : 지정된 객체(o)를 Collection에 추가합니다.</li>
<li>boolean addAll(Collection c) : 지정된 Collection©의 객체들을 Collection에 추가합니다.</li>
<li>void clear() : Collection의 모든 객체를 삭제합니다.</li>
<li>boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어 있는지 확인합니다.</li>
<li>boolean equals(Object o) : 동일한 Collection인지 비교합니다.</li>
<li>int hashCode() : Collection의 hash code를 반환합니다.</li>
<li>boolean isEmpty() : Collection이 비어있는지 확인합니다.</li>
<li>Iterator iterator() : Collection의 Iterator를 얻어서 반환합니다</li>
<li>boolean remove(Object o) : 지정된 객체를 삭제합니다.</li>
<li>int size() : Collection에 저장된 객체의 개수를 반환합니다.</li>
<li>Object[] toArray() : Collection에 저장된 객체를 객체배얄(Object[])로 반환합니다.</li>
<li>Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환합니다.</li>
</ul>
<h2 id="array배열">Array(배열)</h2>
<hr>
<ul>
<li>많은 데이터를 관리할 떄 용이</li>
<li>여러 데이터를 하나의 이름으로 <strong>그룹핑해서 관리</strong>하기 위한 자료구조</li>
<li>배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있고, <strong>반복문과 결합</strong>하면 많은 정보도 효율적으로 처리할 수 있습니다.</li>
<li>배열 인덱스는 값에 대한 <strong>유일무이한 식별자</strong>(리스트에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가짐)</li>
<li><strong>크기가 정해져 있고 기능이 없습니다.</strong></li>
<li><code>인덱스</code>를 가지며, Element의 인덱스는 변경되지 않습니다.</li>
<li>인덱스를 활용하여 빠르게 조회가 가능합니다.</li>
<li>유관 데이터를 메모리에 순차적으로 나열할 수 있다.</li>
<li>인덱스를 이용하여 데이터를 가져오려면 데이터에 대한 인덱스 값이 고정되어야 합니다. (삭제된 Element의 공간이 그대로 남습니다.-&gt;<strong>메모리의 낭비</strong>)</li>
</ul>
<h3 id="사용법">사용법</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">number[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">number[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">number[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(number.length); <span class="comment">// 길이:4</span></span><br></pre></td></tr></table></figure>
<h3 id="장단점">장/단점</h3>
<ul>
<li>장점
<ul>
<li><code>데이터의 크기가 확정적</code>일 때 배열을 사용하면 <strong>메모리나 처리속도</strong> 면에서 좋습니다.</li>
<li>다른 데이터 Structure의 부품이 되기도 합니다.</li>
</ul>
</li>
<li>단점
<ul>
<li>배열의 크기를 배열을 생성할 때 지정하는 것이나, 배열의 크기를 변경할 수 없습니다.</li>
<li>배열에서 설정된 Element(요소)의 개수를 알아낼 수 없습니다.</li>
</ul>
</li>
</ul>
<h2 id="한계">한계</h2>
<ul>
<li>배열은 길이를 바꿀 수 없습니다. 가변 배열과 길이가 변경 가능한 배열의 겅우
<ul>
<li>기존의 배열은 그대로 두고,</li>
<li>새로운 길이로 지정된 배열을 따로 할당 후</li>
<li>데이터의 복사를 진행하고,</li>
<li>기존의 배열을 삭제한다.</li>
<li><code>총 3번의 작업</code> + <code>메모리 탐색</code>이 필요하기 때문에 리소스 낭비가 크다.</li>
</ul>
</li>
<li>이런 한계를 해결하기 위해서 <code>linked list 자료형</code>을 활용할 수 있다. (탐색, 할당, 복사, 삭제 등의 리소스 낭비가 없습니다.)</li>
<li>배열은 인덱스에 따라서 값을 유지하기 떄문에, Element가 삭제되어도 빈자리(null)가 남게 됩니다.<code>(메모리 낭비)</code></li>
<li>조건문을 통해서 제외할 수 있으나, 조건문을 많이 사용하면 좋지 않습니다.</li>
<li>인덱스가 중요한 경우는 배열을 사용, 인덱스가 중요하지 않은 경우는 리스트를 사용합니다.</li>
<li>삭제한 데이터를 뒤에 위치한 Element로 메꾸면, 데이터가 순서에 따라서 빈틈없이 연속적으로 위치하며 이를 <code>list(리스트)</code>라고 합니다.</li>
</ul>
<p><img src="/img/array.png" alt=""></p>
<ul>
<li>배열 : 삭제된 데이터의 빈 공간을 그래도 남겨둠.</li>
<li>리스트 : 빈 공간을 채움.</li>
</ul>
<p>이러한 문제점을 극복한 것이 <strong>List</strong> 입니다.</p>
<h2 id="list-인터페이스">List 인터페이스</h2>
<p>List는 배열의 한계 때문에 만들어졌으며, List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음과 같은 특징을 가지고 있습니다.</p>
<ol>
<li>리스트 자료구조의 핵심은 Element간의 <code>순서</code>. 즉, <strong>순서가 있는 데이터의 모임이 리스트입니다.</strong></li>
<li>같은 요소의 중복 저장을 허용합니다.</li>
<li>리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 <strong>빈틈 없는 데이터의 적재</strong>라는 장점을 취한 데이터 Structure입니다.</li>
<li>리스트에서 인덱스는 <strong>몇 번쨰 데이터인가</strong> 정도의 의미</li>
<li>빈 Element는 허용하지 않습니다.</li>
<li>데이터 개수가 확실하게 정해져 있고, 자주 사용된다면 Array가 더 효율적입니다.</li>
</ol>
<p>대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>ArrayList<e></e></li>
<li>LinkedList<e></e></li>
<li>Vector<e></e></li>
<li>Stack<e></e></li>
</ol>
<h3 id="arraylist">ArrayList</h3>
<p><strong>List 인터페이스를 구현하기 때문에 데이터의 저장 순서가 유지되고 중복을 허용한다는 특징을 갖습니다.</strong></p>
<p>ArrayList는 Obejct 배열을 이용해서 데이터를 순차적으로 저장합니다. 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장됩니다.</p>
<p>(Vector는 capacity가 부족할 경우 자동적으로 기존의 크기보다 2배의 크기로 증가됩니. 그러나 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 됩니다.)</p>
<p>ArryaList는 내부적으로 데이터를 <code>배열</code>에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 사용합니다. <strong>배열은 크기를 변경할 수 없기 때문에 ArrayList나 Vector와 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야 하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있습니다.</strong></p>
<ul>
<li><strong>capacity</strong> : 현재 ArrayList가 수용할 수 있는 데이터의 수를 의미합니다.</li>
<li><strong>size</strong> : 현재 ArrayList에 저장된 데이터의 수를 의미합니다.</li>
<li><strong>Indexoutofbounds exception</strong> : capacity가 아닌 size에 의해 발생합니다. <strong>데이터의 유무가 중요</strong></li>
</ul>
<img src="/img/mm.png" width="400" height="200">
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add를 이용한 요소 추가</span></span><br><span class="line">        items.add(<span class="number">40</span>);</span><br><span class="line">        items.add(<span class="number">20</span>);</span><br><span class="line">        items.add(<span class="number">10</span>);</span><br><span class="line">        items.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for와 get() 메소드를 이용한 요소 출력</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;items.size();i++)&#123;</span><br><span class="line">            System.out.print(items.get(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for 문과 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e :items) &#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collections.sort() 메소드를 이용한 요소의 정렬</span></span><br><span class="line">        Collections.sort(items);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = items.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set() 메소드를 이용한 요소의 값 변경</span></span><br><span class="line">        items.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수. 반환값은 있으면 true 없으면 false</span></span><br><span class="line">        System.out.println(items.contains(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 함수의 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 값이 추가됩니다. 하지만, 위치를 알 수 없을 때는 indexOf() 함수를 이용해서 위치값을 찾은 뒤 add()함수를 이용하면 됩니다.</span></span><br><span class="line">        <span class="keyword">int</span> index = items.indexOf(<span class="number">20</span>);</span><br><span class="line">        items.add(index, <span class="number">110</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index가 1인 요소 즉, 110 삭제, 인덱스로 삭제하면 어떤 인덱스로 삭제했는지 알려줌</span></span><br><span class="line">        System.out.println(items.remove(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 오브젝트를 넘겨서 오브젝트의 모든 요소 삭제</span></span><br><span class="line">        items.removeAll(items);</span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(items.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">100</span> <span class="number">110</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line">items size : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> : List에 요소를 추가합니다.</li>
<li><strong>get()</strong> : 인덱스를 통한 요소 조회합니다.</li>
<li><strong>set()</strong> : 원하는 인덱스에 원하는 요소를 추가합니다.</li>
<li><strong>contains()</strong> : 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수, 반환값은 있으면 true 없으면 false</li>
<li><strong>indexOf()</strong> : 메소드의 인자로 오브젝트를 넘기면 이 오브젝트의 인덱스를 반환해줍니다.</li>
<li><strong>add(int index, Obejct o)</strong> : 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 두 번째 인자인 오브젝트가 추가됩니다.</li>
<li><strong>remove()</strong> : 인덱스를 이용해서 해당 인덱스를 삭제해줍니다. 인덱스로 삭제하게 되면 어떤 데이터를 삭제했는지 리턴값으로 알려줍니다.</li>
<li><strong>remove(Object element)</strong> : 오브젝트를 인수로 넘기면 검색해서 삭제시켜줍니다. 오브젝트를 이용해서 삭제를 하게 되면 삭제 결과가 성공인지 실패인지만 알려줍니다.</li>
</ul>
<h3 id="linkedlist">LinkedList</h3>
<p><strong>배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있습니다.</strong></p>
<ol>
<li><strong>크기를 변경할 수 없다.</strong>
<ul>
<li>크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요합니다.</li>
<li>실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비됩니다.</li>
</ul>
</li>
<li><strong>비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.</strong>
<ul>
<li>차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,</li>
<li>배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야만 합니다.</li>
</ul>
</li>
</ol>
<p>이러한 배열의 단점을 보완하기 위해서 <strong>LinkedList</strong>(링크드 리스트)라는 자료구조가 고안되었습니다. 배열은 모든 데이터가 연속적으로 존재하지만 LinkedList는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있습니다.</p>
<p>링크드 리스트의 각 요소(node)들은 자신과 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList1.png" width="500" height="200">
<p>링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵습니다. 이 점을 보완한 것이 이중 연결리스트(doubly linked list, 더블 링크드 리스트)입니다.</p>
<p><strong>더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Node previous; <span class="comment">// 이전 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList2.png" width="500" height="200">
<p>더블 링크드 리스트의 접근성을 보다 향상시킨 것이 **더블 쎠큘러 링크드 리스트(이중 연결형 연결 리스트)**입니다. 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것입니다.</p>
<p>실제로 <strong>LinkedList</strong> 클래스는 이름과 달리 '링크드 리스트’가 아닌 '더블 링크드 리스트’로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것입니다.</p>
<ol>
<li><strong>순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: 만약 ArrayList의 크기가 충분하지 않으면, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하게 되므로 순차적으로 데이터를 추가해도 ArrayList보다 LinkedList가 더 빠를 수 있습니다. 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하며, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠릅니다. (단지 마지막 요소의 값을 null로만 바꾸면 되기 때문입니다.)</li>
<li><strong>중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠릅니다.</strong><br>
: LinkedList는 각 요소 간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠릅니다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦습니다. 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지 않습니다.</li>
<li><strong>데이터의 개수가 많아질수록 데이터를 읽어오는 시간, 즉 접근시간(access time)은 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: ArrayList는 인덱스 기반의 자료 구조이며, get(index)를 통해 O(1)의 시간 복잡도를 가집니다. 배열의 경우 만일 n번째 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결됩니다. (배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문입니다.)</li>
</ol>
<blockquote>
<p>n번째 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기</p>
</blockquote>
<p>그러나, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이 아니기 때문에 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있습니다. 검색시 거의 모든 요소를 탐색해야 하기 때문에 최악의 경우에는 O(N)의 시간 복잡도를 갖습니다.</p>
<blockquote>
<p>요약</p>
</blockquote>
<ul>
<li><code>LinkedList</code> : 데이터의 추가/삭제가 많을 때 유리</li>
<li><code>Vector/ArrayList</code> : 데이터 항목 검색이 많을 때 유리</li>
</ul>
<blockquote>
<p>ArrayList와 LinkedList</p>
</blockquote>
<p>데이터를 가져오는 것인 빈번하다면 내부적으로 배열을 이용하는 <strong>ArraysList</strong>가 훨씬 빠릅니다.<br>
하지만, 데이터의 추가/삭제가 빈번하다면 <strong>LinkedList</strong>가 훨씬 효과적입니다.</p>
<p>LikedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다고 보면 됩니다. ArrayList와 같이 데이터의 추가, 삭제 시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, <strong>데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리합니다.</strong></p>
<img src="/img/kk.png" width="400" height="200">
<blockquote>
<p><code>Iterator</code> 사용 이유</p>
</blockquote>
<p>linked 특성상 항상 처음부터 같은 경로를 반복적으로 지나면서 데이터의 위치를 검색해야 하기 때문에 마지막으로 접근한 데이터를 기준으로 그 다음 데이터를 알아내는 것이 더 쉽습니다. - 벡터나 ArrayList 처럼 사용되는 것입니다.</p>
<ul>
<li><code>Iterator</code>(추출 전용 인터페이스)
<ul>
<li>데이터를 추출하기 위한 데이터 임시 저장공간</li>
<li>주로 순서가 없는 자료구조의 값들을 추출할 때 사용합니다.</li>
</ul>
</li>
<li>보통 hasNext와 next 메소드를 이용한 while문으로 값을 추출합니다.</li>
</ul>
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; lnkList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        lnkList.add(<span class="string">"넷"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"둘"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"셋"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lnkList.size(); i++) &#123;</span><br><span class="line">            System.out.print(lnkList.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 삭제</span></span><br><span class="line">        lnkList.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 원하는 위치에 요소 삽입</span></span><br><span class="line">        lnkList.set(<span class="number">2</span>, <span class="string">"둘"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(<span class="string">"리스트의 크기 : "</span> + lnkList.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">넷 셋 하나 </span><br><span class="line">넷 셋 둘 </span><br><span class="line">리스트의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="vector">Vector</h3>
<p>ArrayList와 동일하게 사용이 가능합니다.<br>
ArrayList와 Vector의 차이점은 Stringbuilder와 StringBuffer의 차이로 이해할 수 있습니다. <strong>한 데이터에 동시접속이 발생했을 때 처리 가능한 기능이 있나, 없나의 차이입니다.</strong></p>
<p>동시접속을 고려하여 만들어진 리스트는 <code>Vector</code>입니다. <code>ArrayList</code>는 동시접속을 고려하지 않았지만, 그만큼 Vector보다 가볍다는 장점이 있습니다. 또한 웹에서 사용할 때 서버가 동시접속에 대한 처리를 해주기 때문에 ArrayList를 사용하면 됩니다.</p>
<p>Vector는 현재 기존 코드와의 호환성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다.</p>
<h3 id="list-인터페이스-메소드">List 인터페이스 메소드</h3>
<ul>
<li>void add(int index, Object element) : 지정된 위치(index)에 객체(element)또는 컬렉션에 포함된 객체들을 추가합니다.</li>
<li>Object get(int index) : 지정된 위치(index)에 있는 객체를 반환합니다.</li>
<li>int indexOf(Object o) : 지정된 객체의 위치(index)를 반환합니다. (List의 첫 번째 요소부터 순방향으로 찾습니다.)</li>
<li>lastIndexOf(Object o) : 지정된 객체의 위치(indx)를 반환합니다. (List의 마지막 요소부터 역방향으로 찾습니다.)</li>
<li>ListIterator listIterator() : List의 객체에 접근할 수 있는 ListIterator를 반환합니다.</li>
<li>Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환합니다.</li>
<li>Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장합니다.</li>
<li>void sort(Comparator c) : 지정된 비교자(comparator)로 List를 정렬합니다.</li>
<li>List subList(int formIndex, int toIndex) : 지정된 범위(formIndex부터 toIndex)에 있는 객체를 반환합니다.</li>
</ul>
<h3 id="참고">참고</h3>
<blockquote>
<p>List와 ArrayList 이 둘의 차이는 무엇인가?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
<p>예를 들어서 설명하면, 클래스를 생성할 때 <code>도형</code> 타입으로 생성하게 되면 <strong>정사각형</strong>이 아닌 다른 <strong>직사각형, 삼각형</strong>등 도형 인터페이스를 구현한 클래스에서 사용될 수 있습니다. 하지만, <code>정사각형</code>타입으로 클래스르 생성하게 되면 <strong>직사각형, 삼각형</strong>등에서는 사용할 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 도형 list = new 정사각형();</span></span><br><span class="line"></span><br><span class="line"> 	ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 정사각형 list = new 정사각형();</span></span><br></pre></td></tr></table></figure>
<p><code>List</code>는 <strong>인터페이스</strong>입니다. 인터페이스는 공통되는 메소드를 추출해 놓은 클래스입니다.</p>
<ul>
<li>Java Collection FrameWork<br>
<img src="/img/sse.jpg" alt=""></li>
</ul>
<h1 id="stack과-queue">Stack과 Queue</h1>
<hr>
<p>순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 비효율적입니다. 그래서 큐는 ArrayList보다는 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합합니다.</p>
<h2 id="stack">Stack</h2>
<p><strong>스택</strong>이란 사전적으로는 더미, 쌓아 올림이라는 의미를 갖습니다. '더미’란 많은 물건이 모여서 쌓인 큰 덩어리를 의미합니다. 스택은 같은 타입의 자료를 <code>하나 다음 하나</code>라는 개념으로 순차적으로 저장하는 직선형 자료구조입니다.<br>
Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다.</p>
<p>스택은 한쪽이 막혀있고, <strong>한쪽에서만 삽입이나 삭제가 가능합니다.</strong> 그러므로 가장 마지막 데이터의 위치에 대해 삽입이나 삭제가 발생하므로, 이러한 구조에 사용될 때 간단하며 더욱 효율적이고 쉽게 사용이 가능합니다.</p>
<p>또한 스택은 데이터를 쌓아올리는 형태로 데이터를 저장하여 추출할 때는 맨 위에 있는 데이터를 먼저 꺼내는 형태이기 때문에 제일 마지막에 저장한 데이터를 제일 먼저 꺼내는 <code>후입선출(LIFO - Last In First Out)</code> 형태라고도 합니다.</p>
<p><img src="/img/stack.png" alt=""></p>
<ul>
<li>Stack 용어
<ul>
<li>push : 스택에 자료를 넣는 연산</li>
<li>pop : 스택에 자료를 빼는 연산</li>
<li>top : 스택의 가장 위에 있는 자료를 보는 연산</li>
<li>bottom : 스택에 가장 먼저 입력된 데이터</li>
<li>empty : 스택이 비어있는지 아닌지를 알아보는 연산</li>
<li>size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산</li>
</ul>
</li>
</ul>
<p>스택은 <strong>top</strong>에서만 삽입, 삭제, 읽기 동작이 발생할 수 있습니다. <strong>top</strong>은 데이터의 수에 따라 유동적으로 변하며 데이터가 하나 삽입될 경우 하나 증가하고 데이터가 하나 삭제될 경우 하나 감소하도록 작성됩니다.</p>
<p>스택의 경우에는 순차적으로 데이터를 추가하고 삭제하므로 <strong>ArrayList</strong>와 같은 배열 기반의 컬렉션 클래스가 적합합니다.</p>
<ul>
<li>Stack 메소드
<ul>
<li>boolean empty() : Stack이 비어있는지 알려줍니다.</li>
<li>Object peek() : Stack의 맨 위에(top) 저장된 객체를 반환, pop()과 달리 Stack에서 객체를 꺼내지 않습니다. 단지 보기만 합니다.</li>
<li>Object pop() : Stack의 맨 위에 저장된 객체를 꺼냅니다.</li>
<li>Object push(Object item) : Stack에 객체(item)를 저장합니다.</li>
<li>int search(Object o) : 해당 Stack에서 전달된 객체가 존재하는 위치의 인덱스를 반환합니다. 이 때, 인덱스는 제일 상단에 있는(제일 마지막으로 저장된)요소의 위치부터 0이 아닌 1부터 시작하게 됩니다.</li>
<li>clear() : Stack에 존재하는 모든 자료들을 삭제합니다.</li>
</ul>
</li>
</ul>
<h3 id="사용방법">사용방법</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스택 객체 stack 생성</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 데이터 입력</span></span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스택의 사이즈</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line">System.out.println(<span class="string">"마지막에 넣은 데이터부터 출력.."</span>);</span><br><span class="line"><span class="comment">// 가장 최근에 넣은 데이터부터 추출</span></span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">		</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"스택크기: "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 빼지 않고 현재 가장 위에 위치하는 데이터를 확인</span></span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈 확인</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">System.out.println(stack.search(<span class="number">3</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">4</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">스택 크기 : <span class="number">5</span></span><br><span class="line">마지막에 넣은 데이터부터 출력..</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-----------</span><br><span class="line">스택크기: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">스택 크기 : <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>더욱 복잡하고 빠른 스택을 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다. 단, Stack 클래스와는 달리 <strong>search()</strong> 메소드를 지원하지 않습니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="스택의-활용-사례">스택의 활용 사례</h3>
<ul>
<li><code>Operating Systems</code>
<ul>
<li>프로그램에서 불러지는 함수(Method)들을 모두 Stack이라는 자료형에 저장합니다.</li>
</ul>
</li>
<li><code>Compilers(컴파일러)</code>
<ul>
<li>컴파일러에서 수학기호들으 기계어(Machine Code)로 변환시, 괄호들을 매칭하거나 할 때</li>
</ul>
</li>
<li><code>JVM(Java Virtual Machine) - 자바 가상 머신</code>
<ul>
<li>자바 프로그램이 실행될 때 사용되는 JVM에서도 스택은 사용됩니다. 각각의 스레드는 1개의 스택을 가지고 모든 메소드들을 트랙킹합니다. 새로운 메소드들이 호출될 때마다, 새로운 프레임이 스택에 삽입되고, 메소드가 끝날 때 마다 스택에서 제거됩니다.</li>
</ul>
</li>
</ul>
<h2 id="queue">Queue</h2>
<img src="/img/queues.png" width="500" height="200">
<p>큐는 줄이라는 의미를 가지고 있습니다. <strong>큐(Queue)에서 데이터의 제거는 대기 줄의 가장 앞에서 수행되며 데이터의 삽입은 대기 줄의 가장 뒤에서 수행이 되는 제한된 리스트 구조를 말하며 가장 먼저 삽입된 데이터가 가장 먼저 제거되는 <code>선입선출(FIFO-First In First Out)</code> 형태의 자료구조입니다.</strong></p>
<p>가장 오래전에 입력된 데이터를 <strong>front</strong>라고 하면 가장 최근에 입력된 데이터를 <strong>rear</strong>라고 합니다. <code>데이터의 삽입</code>은 <strong>rear</strong>에서 이루어지고 <code>삭제</code>는 <strong>front</strong>에서 이루어지기 때문에 큐를 구현하기 위해서는 front와 rear를 관리하는 배열을 이용하거나 front노드와 rear노드를 관리하는 <code>연결 리스트</code>를 이용할 수 있습니다.</p>
<img src="/img/queue.jpg" width="300" height="200">
<p><strong>자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있지만 큐는 Queue 인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있진 않습니다. 대신 Queue 인터페이스를 구현한 클래스들이 있어서 이들 중의 하나를 선택해서 사용하면 됩니다.</strong></p>
<p>따라서 Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많습니다. 그 중에서도 Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됩니다.</p>
<p>그리고 Queue는 타입이 될 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 이렇게 선언이 되지 않고</span></span><br><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="queue의-동작">Queue의 동작</h3>
<ul>
<li>
<p>삽입 - offer,add</p>
<ul>
<li>큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다.</li>
<li>add : 큐의 뒤 쪽에 데이터를 삽입합니다.</li>
<li>push : 큐의 앞 쪽에 데이터를 삽입합니다.</li>
</ul>
</li>
<li>
<p>제거 - poll,remove</p>
<ul>
<li>큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다.</li>
<li><code>poll</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>remove</code>는 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
<li>
<p>읽기 - peek,element</p>
<ul>
<li>큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다.</li>
<li><code>peek</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>element</code>은 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
</ul>
<h3 id="사용">사용</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stack</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        queue.add(<span class="string">"하나"</span>);</span><br><span class="line">        queue.add(<span class="string">"둘"</span>);</span><br><span class="line">        queue.add(<span class="string">"셋"</span>);</span><br><span class="line">        queue.add(<span class="string">"넷"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// element() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"element() 메소드 사용 : "</span>+queue.element());</span><br><span class="line">        <span class="comment">// peek() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"peek() 메소드 사용 : "</span>+queue.peek()+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peekFirst() 메소드는 큐의 맨 위의 요소를 반환 즉, 가장 처음에 삽입된 요소를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 첫 번째 요소 : "</span>+queue.peekFirst());</span><br><span class="line">        <span class="comment">// peekLast() 메소드는 큐의 맨 마지막 요소를 반환 즉, 마지막에 삽입된 요소 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 마지막 요소 : "</span>+queue.peekLast()+<span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.poll());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.remove());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">element() 메소드 사용 : 하나</span><br><span class="line">peek() 메소드 사용 : 하나</span><br><span class="line"></span><br><span class="line">Queue의 첫 번째 요소 : 하나</span><br><span class="line">Queue의 마지막 요소 : 넷</span><br><span class="line"></span><br><span class="line">[하나, 둘, 셋, 넷]</span><br><span class="line">삭제한 요소 : 하나</span><br><span class="line">[둘, 셋, 넷]</span><br><span class="line"></span><br><span class="line">삭제한 요소 : 둘</span><br><span class="line">[셋, 넷]</span><br></pre></td></tr></table></figure>
<h3 id="큐-구현-클래스">큐 구현 클래스</h3>
<p><strong>1. PriorityQueue</strong><br>
Queue 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있습니다. 그리고 null은 저장할 수 없습니다. PIPO(Priority-in, Priority Out)</p>
<p><strong>2. priorityBlockingQueue</strong><br>
-&gt; Priority Queue의 동기화된 버전<br>
-&gt; 동기화 메소드 보유<br>
-&gt; PriorityQueue보다 느린 속도<br>
-&gt; null 요소를 허용하지 않음</p>
<p><strong>3. LinkedList</strong><br>
-&gt; 끝에 요소를 추가하는 것이 용이<br>
-&gt; List 인터페이스 구현<br>
-&gt; 요소에 null 허용</p>
<p><strong>4. Deque(Double-Ended Queue)</strong><br>
-&gt; Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, <strong>Deque</strong>은 양쪽 끝에 추가/삭제가 가능합니다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있습니다.</p>
<p>문제 : <a href="https://www.acmicpc.net/problem/10866" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10866</a></p>
<blockquote>
<p>Deque의 사용법</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">            String command = st.nextToken();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">				<span class="comment">// first, front, 앞 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 먼저 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// push() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_front"</span>: </span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addFirst(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">// last, rear, 뒤 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 나중에 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// add() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_back"</span>:</span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addLast(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_front"</span>:</span><br><span class="line">					<span class="comment">// 덱이 비어있는지 확인할 수 있음</span></span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 앞쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 먼저 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeFirst()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 나중에 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeLast()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"size"</span>:</span><br><span class="line">					<span class="comment">// 덱의 사이즈를 확인</span></span><br><span class="line">                    System.out.println(deque.size());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"empty"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"front"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱에서 가장 앞쪽의 데이터를 확인(first, front)</span></span><br><span class="line">                        System.out.println(deque.peekFirst());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 확인(last, rear)</span></span><br><span class="line">                        System.out.println(deque.peekLast());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java SE 6부터 지원되는 ArrayDeque 클래스는 스택과 큐 메모리 구조를 모두 구현하는데 가장 적합한 클래스입니다.</p>
</blockquote>
<h1 id="vector-클래스">Vector 클래스</h1>
<hr>
<p><code>List 인터페이스를 구현한 클래스</code>이며, <strong>java.util.Vector</strong>에 있습니다. 그리고 아래와 같은 특징을 갖습니다.</p>
<ol>
<li>객체들을 <strong>삽입, 삭제, 검색</strong>할 수 있는 컨테이너 클래스입니다.</li>
<li>배열의 <strong>길이 제한 단점을 극복</strong>할 수 있습니다.</li>
<li>삽입되는 객체의 수가 많아지면 <code>자동으로 크기가 조절</code>됩니다.</li>
<li>아이템을 벡터의 <strong>맨 마지막</strong>이나 <strong>중간에 삽입</strong>할 수 있습니다.</li>
</ol>
<ul>
<li><code>벡터 맨 뒤에 객체 추가</code> : 벡터 공간이 모자라면 자동으로 늘림</li>
<li><code>벡터 중간에 객체 삽입</code> : 뒤에 존재하던 객체는 한칸씩 뒤로 이동</li>
<li><code>임의의 위치에 있는 객체 삭제</code> : 객체 삭제 후 한칸씩 앞으로 자동으로 이동</li>
</ul>
<h2 id="사용방법">사용방법</h2>
<img src="/img/dd.png" width="400" height="200">
<p>위의 그림은 벡터 객체 내부의 구조와 <code>add(),get() 메소드</code>를 이용하여 객체를 다루는 모습을 보여주고 있습니다. 벡터에는 <strong>String,Integer,Person등의 다양한 타입의 객체가 삽입 가능합니다.</strong> 벡터 내부에 삽입된 요소들은 <code>인덱스</code>로 관리하며 인덱스는 0부터 시작합니다. <code>add()</code>메소드를 이용하여 <strong>객체를 삽입</strong>하고, <code>get()</code>메소드를 이용하여 인덱스에 해당하는 <strong>객체를 얻습니다.</strong></p>
<blockquote>
<p>벡터의 생성</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">Vector&lt;String&gt; v2 = <span class="keyword">new</span> Vector&lt;String&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>v는 어떠한 타입이라도 담을 수 있습니다.</li>
<li>v2는 Vector 객체에 String 객체를 담을 수 있으며, 용량은 3이며 size가 용량을 초과했을 때, 3의 크기만큼 증가합니다. (매개변수를 지정하지 않았을 경우에는 기본 용량:10,증가 용량:10)<br>
<img src="/img/abc.png" width="400" height="200"></li>
</ul>
<blockquote>
<p>벡터에 요소 삽입</p>
</blockquote>
<p>벡터에 삽입할 수 있는 요소는 <code>Object</code>를 상속받은 모든 종류의 객체들이 가능하며 다음과 같이 벡터에 요소를 삽입할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="string">"Hello"</span>);</span><br><span class="line">v.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> Person());</span><br><span class="line">v2.addElement(<span class="string">"이승우"</span>);</span><br><span class="line">v2.addElement(<span class="string">"정지현"</span>);</span><br><span class="line">v2.addElement(<span class="string">"탁형민"</span>);</span><br><span class="line">v2.addElement(<span class="string">"홍주영"</span>);</span><br><span class="line"></span><br><span class="line">v.add(<span class="number">1</span>); <span class="comment">// int형 데이터(Integer 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="string">'r'</span>); <span class="comment">// char형 데이터(Character 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="number">3.14</span>); <span class="comment">// double형 데이터(Double 타입으로 전환되어 저장)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> 메소드는 요소를 벡터의 맨 뒤에 삽입합니다.</li>
<li>v2에는 addElement() 메소드를 이용해서 String 객체를 담을 수 있습니다.</li>
<li>자바에서 제공하는 기본 타입 역시 벡터에 삽입할 수 있습니다.</li>
</ul>
<img src="/img/bcd.png" width="400" height="200">
<blockquote>
<p>벡터 내의 객체 알아내기</p>
</blockquote>
<p>벡터 내에 존재하는 요소 객체를 알아내기 위해서는 <code>get(), elementAt()</code>등의 메소드를 이용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer obj = (Integer)v.get(<span class="number">1</span>); <span class="comment">// 벡터의 1번째 요소를 Integer 타입으로 형 변환</span></span><br><span class="line"><span class="keyword">int</span> i = obj.intValue(); <span class="comment">// obj에 있는 정수를 알아냅니다. 값은 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>벡터의 용량과 개수 알아내기</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = v.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c = v.capacity(); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">int</span> n2 = v2.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c2 = v2.capacity(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>벡터의 크기<code>(size)</code> : <strong>벡터에 들어 있는 요소의 개수</strong></li>
<li>벡터의 용량<code>(capacity)</code> : <strong>요소를 수용할 수 있는 크기</strong>[벡터는 자동으로 조절 가능]</li>
</ul>
<blockquote>
<p>요소 객체 중간에 삽입하기</p>
</blockquote>
<p>벡터에 있는 데이터는 <code>인덱스</code>로 관리할 수 있기 때문에, 인덱스 값을 이용해서 중간에 객체 삽입이 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="number">2</span>,<span class="string">"Sahni"</span>);</span><br></pre></td></tr></table></figure>
<p>벡터 v 내의 인덱스가 2인 위치에 “Shani” 삽입하였으며, 아래 그림과 같은 구조를 가지게 됩니다.</p>
<img src="/img/cde.png" width="400" height="200">
<blockquote>
<p>벡터에서 요소 삭제</p>
</blockquote>
<ul>
<li><code>remove()</code> : 벡터 내에 임의의 인덱스에 있는 요소를 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.remove(<span class="number">1</span>); <span class="comment">// 정수 4가 삭제됨</span></span><br></pre></td></tr></table></figure>
<img src="/img/def.png" width="400" height="200">
<blockquote>
<p>벡터에서 모든 요소 삭제하기</p>
</blockquote>
<ul>
<li><code>removeAllElements()</code> : 벡터 내에 존재하는 모든 요소를 한번에 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.removeAllElements(); <span class="comment">// 벡터 내 모든 요소 삭제</span></span><br></pre></td></tr></table></figure>
<img src="/img/efg.png" width="400" height="200">
<h2 id="벡터-클래스의-주요-메소드">벡터 클래스의 주요 메소드</h2>
<p><img src="/img/aad.png" alt=""></p>
<h2 id="벡터-생성자">벡터 생성자</h2>
<p><img src="/img/lmc.png" alt=""></p>
<h1 id="정렬">정렬</h1>
<hr>
<p>자바에서 정렬하기 위해 사용하는 <code>Comparable</code>과 <code>Comparator</code>를 공부해보았습니다</p>
<p><strong>배열</strong>이나 <strong>Collection</strong>프레임워크 등에서 sort()를 사용하면 컴퓨터에서 알아서 <code>정렬</code>을 해줍니다. 여기서 사용되는 <code>sort()</code>는 <strong>Comparable</strong> 구현에 의한 정렬이고, <strong>Comparable</strong>과 <strong>Comparator</strong>에 대해서 공부해보았습니다.</p>
<h2 id="arrayssort">Arrays.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String[] sports=&#123;<span class="string">"Soccer"</span>,<span class="string">"Baseball"</span>,<span class="string">"Tennis"</span></span><br><span class="line">,<span class="string">"Football"</span>,<span class="string">"Basketball"</span>,<span class="string">"Ski"</span>,<span class="string">"Hockey"</span>,<span class="string">"Aerobics"</span>&#125;; <span class="comment">// 영어</span></span><br><span class="line">String[] names=&#123;<span class="string">"하정우"</span>,<span class="string">"장동건"</span>,<span class="string">"김수현"</span>,<span class="string">"박보검"</span></span><br><span class="line">,<span class="string">"송중기"</span>,<span class="string">"송승헌"</span>,<span class="string">"조승우"</span>,<span class="string">"조정석"</span>,<span class="string">"강동원"</span>,<span class="string">"김우빈"</span>,<span class="string">"박서준"</span>&#125;; <span class="comment">// 한글</span></span><br><span class="line">		</span><br><span class="line">Arrays.sort(sports);</span><br><span class="line">Arrays.sort(names);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sports.length;i++)&#123;</span><br><span class="line">	System.out.print(sports[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;names.length;j++)&#123;</span><br><span class="line">	System.out.print(names[j]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Aerobics Baseball Basketball Football Hockey Ski Soccer Tennis </span><br><span class="line">강동원 김수현 김우빈 박보검 박서준 송승헌 송중기 장동건 조승우 조정석 하정우</span><br></pre></td></tr></table></figure>
<p>먼저, <strong>Arryays.sort</strong>()의 동작을 확인하였습니다. String 타입의 배열을 2개 만들었고, <strong>Arrays.sort</strong>()를 통해 정렬을 수행하였습니다.<br>
영어는 ABC 순서대로, 한글은 가나다 순서대로 정렬이 된 것을 확인할 수 있습니다. 영어의 경우 같은 알파벳으로 시작하는 단어들도 정확하게 정렬이 되었습니다.</p>
<ul>
<li><code>Comparable</code> - 기본 정렬 기준을 구현하는데 사용</li>
<li><code>Comparator</code> - 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용</li>
</ul>
<p>여기서 Arrays.sort(sports),Arryas.sort(names)는 String의 <strong>Comparable</strong>구현에 의해 정렬된 것이다. <strong>Comparable</strong>을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, String, Integer, Date, File등과 같은 것들입니다. 그리고 기본적으로는 작은 값에서 큰 값의 순서, 오름차순 형태로 구현되도록 만들어져 있습니다.</p>
<h2 id="collectionssort">Collections.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sportsList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">sportsList.add(<span class="string">"Soccer"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Baseball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Tennis"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Football"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Basktball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Ski"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Hockey"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Aerobics"</span>);</span><br><span class="line">		</span><br><span class="line">Collections.sort(sportsList);</span><br><span class="line">		</span><br><span class="line">Iterator it = sportsList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이번에는 배열이 아닌 ArrayList의 형태로 sort()를 사용해보았다. 위에서 사용했던 방식과 똑같지만, String 타입의 배열을 ArrayList로 바꿨습니다. 여기서는 <strong>Arrays.sort</strong>()가 아니라 <code>Collections.sort()</code>를 적용해야 합니다.</p>
<h2 id="다른-방식">다른 방식</h2>
<p>이제부터는 기본 정렬기준이 아닌 다른 정렬기준으로 시도해보겠습니다. 축구선수를 뜻하는 <strong>SoccerPlayer</strong>라는 클래스를 하나 만들고, 축구선수의 객체배열을 이용해 sort를 해보려고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoccerPlayer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">SoccerPlayer</span>&gt;</span>&#123; <span class="comment">// 여기 추가된 부분</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String position;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SoccerPlayer</span><span class="params">(String name, String position, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.position = position;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> position;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(String position)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.position = position;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="comment">// 여기 추가된 부분</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(SoccerPlayer player)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.compareTo(player.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SoccerPlayer</strong>는 이름, 포지션, 나이 속성을 갖고 있고 각각 setter와 getter를 선언해주었습니다. 위의 경우와 동일하게 Arrays.sort(), Collections.sort()는 작동하지 않고 <code>오류</code>가 발생합니다. 이유는 <code>정렬을 시도했지만, 객체내의 어떤 변수를 기준으로 정렬할 지 정하지 않았기 때문</code>입니다. String 타입의 배열이나 ArrayList는 값이 하나지만, 객체를 정렬할 경우 객체 내의 어떤 <strong>변수로 정렬할지 기준을 만들어줘야 합니다.</strong></p>
<p><strong>Comparable</strong>을 implements한 뒤 <strong>comparaTo</strong>메소드를 구현하면 해결할 수 있습니다. [오름차순만 가능]</p>
<p>SoccerPlayer 클래스에서 <code>Comparable&lt;SoccerPlayer&gt;</code>를 implements 하였습니다. 그리고 하단에 <strong>compareTo</strong>를 오버라이드하여 코드를 추가했습니다. 매개변수로 SoccerPlayer 객체를 받고 리턴값으로는 객체의 이름을 비교하는 구문을 넣어주었습니다.</p>
<p>여기서 본인이 정렬하고자 하는 클래스를 <code>Comparable&lt;클래스명&gt;</code> 형태로 넣어주는 것을 잊어서는 안됩니다. 이 경우에 정렬하고자 하는 클래스는 <strong>SoccerPlayer</strong>라는 클래스!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;SoccerPlayer&gt; playerList = <span class="keyword">new</span> ArrayList&lt;SoccerPlayer&gt;();</span><br><span class="line">		</span><br><span class="line">SoccerPlayer player1 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"메시"</span>, <span class="string">"공격수"</span>, <span class="number">23</span>);</span><br><span class="line">SoccerPlayer player2 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"호날두"</span>, <span class="string">"공격수"</span>, <span class="number">28</span>);</span><br><span class="line">SoccerPlayer player3 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"케인"</span>, <span class="string">"공격수"</span>, <span class="number">29</span>);</span><br><span class="line">SoccerPlayer player4 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"손흥민"</span>, <span class="string">"공격수"</span>, <span class="number">25</span>);</span><br><span class="line">SoccerPlayer player5 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"박지성"</span>, <span class="string">"미드필더"</span>, <span class="number">30</span>);</span><br><span class="line">SoccerPlayer player6 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"베르통언"</span>, <span class="string">"수비수"</span>, <span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">playerList.add(player1);</span><br><span class="line">playerList.add(player2);</span><br><span class="line">playerList.add(player3);</span><br><span class="line">playerList.add(player4);</span><br><span class="line">playerList.add(player5);</span><br><span class="line">playerList.add(player6);</span><br><span class="line">		</span><br><span class="line">Collections.sort(playerList);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;playerList.size();i++)&#123;</span><br><span class="line">	System.out.println(playerList.get(i).getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">메시</span><br><span class="line">박지성</span><br><span class="line">베르통언</span><br><span class="line">손흥민</span><br><span class="line">케인</span><br><span class="line">호날두</span><br></pre></td></tr></table></figure>
<p>축구선수 객체를 6명 만들어서 ArrayList에 추가하였습니다. 그리고 Collections.sort()를 이용해 정렬을 시도하니 가나다 이름순서로 정렬되어 나오는 결과를 확인할 수 있었습니다.</p>
<p>바로 SoccerPlayer 클래스에서 Comparable을 implements하였고, 하단에 compareTo를 Override하며 이름 비교 코드를 만들어주었기 때문입니다. 이 부분을 이름이 아닌 포지션으로 바꿀 수 있습니다.</p>
<h2 id="또-다른-방법">또 다른 방법</h2>
<p>Comparable을 implements 하지 않고도 오브젝트의 특정 변수를 기준으로 정렬하는 방법이 있습니다. 이 때 사용하는 방법이 바로 <strong>Comparator</strong>입니다. <code>Comparator</code>를 사용하면 정렬 기준을 본인이 원하는대로 바꾸는 것이 가능합니다.<code>[오름차순, 내림차순 가능]</code>. <code>주로 객체의 특정 변수를 기준으로 정렬할 때 주로 이용합니다!!</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;SoccerPlayer&gt; playerList = <span class="keyword">new</span> ArrayList&lt;SoccerPlayer&gt;();</span><br><span class="line">		</span><br><span class="line">SoccerPlayer player1 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"메시"</span>, <span class="string">"공격수"</span>, <span class="number">23</span>);</span><br><span class="line">SoccerPlayer player2 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"호날두"</span>, <span class="string">"공격수"</span>, <span class="number">28</span>);</span><br><span class="line">SoccerPlayer player3 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"케인"</span>, <span class="string">"공격수"</span>, <span class="number">29</span>);</span><br><span class="line">SoccerPlayer player4 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"손흥민"</span>, <span class="string">"공격수"</span>, <span class="number">25</span>);</span><br><span class="line">SoccerPlayer player5 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"박지성"</span>, <span class="string">"미드필더"</span>, <span class="number">30</span>);</span><br><span class="line">SoccerPlayer player6 = <span class="keyword">new</span> SoccerPlayer(<span class="string">"베르통언"</span>, <span class="string">"수비수"</span>, <span class="number">20</span>);</span><br><span class="line">		</span><br><span class="line">playerList.add(player1);</span><br><span class="line">playerList.add(player2);</span><br><span class="line">playerList.add(player3);</span><br><span class="line">playerList.add(player4);</span><br><span class="line">playerList.add(player5);</span><br><span class="line">playerList.add(player6);</span><br><span class="line">		</span><br><span class="line">Collections.sort(playerList, <span class="keyword">new</span> Comparator&lt;SoccerPlayer&gt;()&#123;</span><br><span class="line">	<span class="comment">// 달라진 부분</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(SoccerPlayer p1, SoccerPlayer p2)</span> </span>&#123;</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">if</span>(p1.getAge() &gt; p2.getAge())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p1.getAge()&lt;p2.getAge())&#123;</span><br><span class="line">				<span class="keyword">return</span>-<span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	&#125;);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;playerList.size();i++)&#123;</span><br><span class="line">		System.out.println(playerList.get(i).getName()+ <span class="string">" "</span> + playerList.get(i).getAge());</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">베르통언 <span class="number">20</span></span><br><span class="line">메시 <span class="number">23</span></span><br><span class="line">손흥민 <span class="number">25</span></span><br><span class="line">호날두 <span class="number">28</span></span><br><span class="line">케인 <span class="number">29</span></span><br><span class="line">박지성 <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>SoccerPlayer 클래스에 <strong>Comparable</strong>을 implements하지 않은 상태로 Main에 Collections.sort()를 만들었습니다. 여기서는 <code>Collections.sort(playerList,new Comparator&lt;SoccerPlayer&gt;(){..}</code>형태로 구현해야 하며, 내부에 있는 compare 메소드에서 코딩해주면 됩니다. 지금 축구선수의 나이 순서대로 정렬이 되도록 구현하였고, 결과는 위와 같습니다.</p>
<h2 id="결론">결론</h2>
<p><strong>Comparable</strong> 구현 후 내부의 <strong>compareTo</strong> 메소드를 오버라이드해서 정의해야 하는데, 이 정의 결과에 따라 정렬 값이 나옵니다. 또한, 오브젝트의 다른 값으로 비교를 원한다면 <strong>compareTo</strong>를 하나하나 바꿔줄 필요 없이, <strong>Comparator</strong>를 이용하면 됩니다.</p>
<p>Collections.sort() , Arrays.sort() 등 ~~.sort()는 배열이나 리스트를 정렬할 때 Comparator를 지정하지 않았을 경우<br>
<strong>Comprarable</strong>을 구현하면 구현한 클래스의 객체에 구현된 내용에 따라 정렬!!</p>
<ul>
<li>다음과 같은 함수들도 존재합니다.
<ul>
<li>Arrays.sort()</li>
<li>Arrays.reverse()</li>
<li>Collections.sort()</li>
<li>Collections.reverse()</li>
</ul>
</li>
</ul>
<h1 id="set">Set</h1>
<hr>
<p><strong>특징</strong></p>
<ol>
<li>순서가 없습니다.</li>
<li>집합이므로 중복된 데이터가 들어갈 수 없습니다.</li>
<li>중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용합니다.</li>
</ol>
<p>Collection의 일부인데 <code>중복되는 element를 포함하지 않는 것</code>이 가장 큰 특징이며, <code>집합</code>을 의미합니다. <strong>Set</strong>인터페이스는 Collection를 상속받아서 만들어진 인터페이스입니다. 때문에 대부분의 함수들이 Collection에서 제공하는 함수들과 동일합니다.</p>
<p><strong>List</strong>와 <strong>Set</strong>은 Collection 인터페이스를 구현한다는 점에서 비슷하다고 할 수 있습니다. 그러나 가장 큰 차이점은 <code>중복</code>에 대한 부분에서의 차이입니다.<br>
<code>List</code>는 같은 값에 대한 중복 추가가 가능합니다. 그러나 <code>Set</code>은 같은 값을 넣었을 때 size()로 내부 엘리먼트의 개수를 출력해보면 1이 나오는 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; hSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">hSet.add(<span class="string">"자바"</span>);</span><br><span class="line">hSet.add(<span class="string">"서블릿"</span>);</span><br><span class="line">hSet.add(<span class="string">"스프링"</span>);</span><br><span class="line">hSet.add(<span class="string">"안드로이드"</span>);</span><br><span class="line">hSet.add(<span class="string">"자바"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈는 4가 나옵니다. 중복을 제거함</span></span><br><span class="line">System.out.println(<span class="string">"hSet의 개수:"</span>+hSet.size());</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = hSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashSet</strong>은 <code>Iterator</code>를 사용합니다. 이유는 set은 순서가 없기 때문에 데이터에 순서를 정해서 추출해야하기 때문입니다.</p>
<p>중복이 안되는 것을 생각하면 <strong>Hashtable</strong>이나 <strong>HashMap</strong>과 같은 Map 형태가 떠오를 수 있습니다. 그러나 다른 점이라면, Map에서는 형태를 가진다는 점이 가장 큰차이입니다. 중복을 검사하는 대상 자체가 <strong>Key,Value</strong>이기 때문에 <code>Key를 기준으로 중복검사</code>를 하게 됩니다. <strong>이것은 value는 중복되더라도 상관없다는 이야기입니다.</strong></p>
<h1 id="hashset">HashSet</h1>
<p>Set 인터페이스를 구현한 대표적인 <code>HashSet</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">hs.add(<span class="number">1</span>);</span><br><span class="line">hs.add(<span class="number">2</span>);</span><br><span class="line">hs.add(<span class="number">3</span>);</span><br><span class="line">hs.add(<span class="number">4</span>);</span><br><span class="line">hs.add(<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">HashSet&lt;Integer&gt; hs2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">hs2.add(<span class="number">3</span>);</span><br><span class="line">hs2.add(<span class="number">4</span>);</span><br><span class="line">hs2.add(<span class="number">5</span>);</span><br><span class="line">hs2.add(<span class="number">6</span>);</span><br><span class="line">hs2.add(<span class="number">7</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 교집합을 구하기 위해서는 retainAll()이라는 메소드를 사용합니다.</span></span><br><span class="line">hs.retainAll(hs2);</span><br><span class="line">System.out.println(<span class="string">"교집합 : "</span>+hs.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 집합 hs2는 hs의 부분집합이다.</span></span><br><span class="line"><span class="comment">// 이것이 맞는지 알아보기 위해서는 containsAll()을 사용하면 된다.</span></span><br><span class="line">System.out.println(hs.containsAll(hs2));</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"><span class="comment">// 차집합을 구하기 위해서는 removeAll()이라는 메소드를 사용합니다</span></span><br><span class="line"><span class="comment">// 집합 hs와 집합 hs2에서 집합 hs의 값들 중에서 집합 hs2에도 있는 값을</span></span><br><span class="line"><span class="comment">// 뺀 값들이 나옵니다. </span></span><br><span class="line">hs.removeAll(hs2);</span><br><span class="line">System.out.println(<span class="string">"차집합: "</span>+hs.toString());</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"><span class="comment">// 합집합을 구하기 위해서는 addAll()이라는 메소드를 사용하면 됩니다. </span></span><br><span class="line">hs.addAll(hs2);</span><br><span class="line">System.out.println(<span class="string">"합집합 : "</span>+hs.toString());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>containsAll()</code> : 부분집합임을 알아보기 위해서 사용</li>
<li><code>addAll()</code> : 합집합을 구하기 위해서 사용[합집합으로 합쳐집니다.]</li>
<li><code>removeAll()</code> : 차집합을 구하기 위해서 사용[hs에서 hs2를 뺀 부분을 보여줍니다.]</li>
<li><code>retainAll()</code> : 교집합을 구하기 위해서 사용[두 집합 중 공통된 값을 뽑아냅니다.]</li>
</ul>
<h2 id="set을-정렬하는-방법">Set을 정렬하는 방법</h2>
<p><strong>Set</strong>은 중복 없이 값을 넣기 위한 객체입니다. 여기서는 <code>List</code>를 사용해서 <strong>Set</strong>을 정렬하는 방법을 공부해보았습니다.</p>
<p>먼저, fruits의 객체가 있고, <strong>banana, apple, peach</strong>의 중복없는 값을 삽입합니다. 이렇게 삽입한 <code>Set</code>을 정렬하기 위해서는 fruits의 객체를 <code>List</code>로 변환을 해야합니다. 변환하는 방법은 ArrayList를 만드는 방식과 동일하고 생성자에 fruits를 넣어주면 리스트 형태로 변환이 됩니다. 여기서 공부했던 것을 떠올려보면 <code>List</code>를 정렬하기 위해서는 <strong>Collections</strong>를 사용하면 됩니다!!!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set fruits = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">fruits.add(<span class="string">"banana"</span>):</span><br><span class="line">fruits.add(<span class="string">"apple"</span>):</span><br><span class="line">fruits.add(<span class="string">"peach"</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 List로 변환</span></span><br><span class="line">List fruitsList = <span class="keyword">new</span> ArrayList(fruits);</span><br><span class="line"><span class="comment">// List 정렬</span></span><br><span class="line">Collections.sort(fruitsList);</span><br><span class="line"><span class="keyword">for</span>(String s : fruitsList)&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">peach</span><br></pre></td></tr></table></figure>
<h1 id="map">Map</h1>
<hr>
<p><code>Map</code> 인터페이스는 Collection 인터페이스와는 다른 저장 방식을 가집니다. Map 인터페이스를 구현한 Map 컬렉션 클래스들은 <strong>키와 값을 하나의 쌍으로 저장하는 방식을 사용합니다. (key-value)</strong><br>
여기서 key란 실질적인 value를 찾기 위한 이름의 역할을 합니다.</p>
<ul>
<li>특징</li>
</ul>
<ol>
<li>요소의 저장 순서를 유지하지 않습니다.</li>
<li>key는 중복을 허용하지 않지만, 값의 중복은 허용합니다.</li>
</ol>
<h2 id="종류">종류</h2>
<blockquote>
<p>HashMap&lt;Key,Value&gt;</p>
</blockquote>
<p>Map 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. 그리고 <code>HashMap 클래스</code>는 <strong>해시 알고리즘</strong>을 사용하여 검색 속도가 매우 빠릅니다.</p>
<p>HashMap 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment">// put 메소드를 이용한 요소의 저장</span></span><br><span class="line">map.put(<span class="string">"십"</span>, <span class="number">10</span>);</span><br><span class="line">map.put(<span class="string">"삼십"</span>, <span class="number">30</span>);</span><br><span class="line">map.put(<span class="string">"사십"</span>, <span class="number">40</span>);</span><br><span class="line">map.put(<span class="string">"이백"</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Map에 저장된 키들의 집합:"</span>+map.keySet()); </span><br><span class="line"><span class="comment">// 나중에 저장된 값이 가장 앞으로 나옴</span></span><br><span class="line"><span class="comment">// 그리고 처음에 저장된 값이 가장 뒤에 있음</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">	System.out.println(String.format(<span class="string">"키:%s, 값: %s"</span>, key,map.get(key)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.remove(<span class="string">"사십"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator() 메소드와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">Iterator&lt;String&gt; keys = map.keySet().iterator();</span><br><span class="line">		</span><br><span class="line"><span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">	String key = keys.next();</span><br><span class="line">	System.out.println(<span class="string">"키 : "</span>+key+<span class="string">", "</span>+<span class="string">"값 : "</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.replace(<span class="string">"이백"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Map의 크기 : "</span>+ map.size());</span><br></pre></td></tr></table></figure>
<p><strong>특징</strong></p>
<ul>
<li>요소의 저장순서를 유지하지 않습니다.</li>
<li>나중에 저장된 값이 가장 먼저 출력됩니다.</li>
<li>가장 처음에 저장된 값이 나중에 출력됩니다.</li>
<li><code>map.keySet()</code> : 함수를 통해서 키들의 집합을 확인할 수 있습니다.</li>
<li><code>map.get(key)</code> : get 메소드를 통해서 해당 키에 대한 value값을 얻을 수 있습니다.</li>
<li><code>map.remove()</code> : remove() 메소드를 이용한 요소의 제거</li>
<li><code>map.replace()</code> : replace() 메소드를 이용한 요소의 값(value) 수정</li>
<li><code>map.size()</code> : size() 메소드를 이용한 요소의 총 개수</li>
<li><code>keySet()</code> : keySet() 메소드는 해당 Map에 포함된 모든 키값들을 하나의 집합(Set)으로 반환해줍니다.</li>
</ul>
<img src="/img/clf.png" width="650" height="200">
<blockquote>
<p>Hashtable&lt;Key,Value&gt;</p>
</blockquote>
<p><code>Hashtable</code> 클래스는 JDK 1.0부터 사용해 온 <strong>HashMap</strong> 클래스와 같은 동작을 하는 클래스입니다. 현재의 Hashtable 클래스는 HashMap 클래스와 마찬가지로 Map 인터페이스를 상속받습니다.</p>
<p>따라서 Hashtable 클래스에서 사용할 수 있는 메소드는 HashMap 클래스에서 사용할 수 있는 메소드와 거의 같습니다. 하지만 현재에는 <strong>기존 코드와의 호환성</strong>을 위해서만 남아있으므로, Hashtable 클래스보다는 <code>HashMap</code> 클래스를 사용하는 것이 좋습니다.</p>
<blockquote>
<p>TreeMap&lt;Key,Value&gt;</p>
</blockquote>
<p>TreeMap 클래스는 Key와 Value를 한 쌍으로 하는 데이터를 <code>이진 검색 트리</code>의 형태로 저장합니다. <code>이진 검색 트리</code>는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 <code>Red-Black Tree</code>로 구현합니다.</p>
<p><code>TreeMap</code> 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</p>
<img src="/img/clf2.png" width="650" height="200">
<img src="/img/clf3.png" width="650" height="200">

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/03/19/JavaCollectionPriorityQueue/" data-toggle="tooltip" data-placement="top" title="자바 :: Priority Queue?">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/03/02/Android-ActivityLifeCycle/" data-toggle="tooltip" data-placement="top" title=" 안드로이드 :: Study 1">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                    <div class="comment">
                        <div id="disqus_thread" class="disqus-thread"></div>
                    </div>
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#컬렉션-프레임워크"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">컬렉션 프레임워크</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#컬렉션-프레임워크-핵심-인터페이스"><span class="toc-nav-number">1.1.</span> <span class="toc-nav-text">컬렉션 프레임워크 핵심 인터페이스</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#collection-인터페이스"><span class="toc-nav-number">1.2.</span> <span class="toc-nav-text">Collection 인터페이스</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#array배열"><span class="toc-nav-number">1.3.</span> <span class="toc-nav-text">Array(배열)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#사용법"><span class="toc-nav-number">1.3.1.</span> <span class="toc-nav-text">사용법</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#장단점"><span class="toc-nav-number">1.3.2.</span> <span class="toc-nav-text">장/단점</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#한계"><span class="toc-nav-number">1.4.</span> <span class="toc-nav-text">한계</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#list-인터페이스"><span class="toc-nav-number">1.5.</span> <span class="toc-nav-text">List 인터페이스</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#arraylist"><span class="toc-nav-number">1.5.1.</span> <span class="toc-nav-text">ArrayList</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#linkedlist"><span class="toc-nav-number">1.5.2.</span> <span class="toc-nav-text">LinkedList</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vector"><span class="toc-nav-number">1.5.3.</span> <span class="toc-nav-text">Vector</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#list-인터페이스-메소드"><span class="toc-nav-number">1.5.4.</span> <span class="toc-nav-text">List 인터페이스 메소드</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#참고"><span class="toc-nav-number">1.5.5.</span> <span class="toc-nav-text">참고</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#stack과-queue"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">Stack과 Queue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#stack"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">Stack</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#사용방법"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">사용방법</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#스택의-활용-사례"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">스택의 활용 사례</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#queue"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">Queue</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#queue의-동작"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">Queue의 동작</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#사용"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">사용</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#큐-구현-클래스"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">큐 구현 클래스</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#vector-클래스"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">Vector 클래스</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#사용방법"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">사용방법</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#벡터-클래스의-주요-메소드"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">벡터 클래스의 주요 메소드</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#벡터-생성자"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">벡터 생성자</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#정렬"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">정렬</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#arrayssort"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">Arrays.sort()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#collectionssort"><span class="toc-nav-number">4.2.</span> <span class="toc-nav-text">Collections.sort()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#다른-방식"><span class="toc-nav-number">4.3.</span> <span class="toc-nav-text">다른 방식</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#또-다른-방법"><span class="toc-nav-number">4.4.</span> <span class="toc-nav-text">또 다른 방법</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#결론"><span class="toc-nav-number">4.5.</span> <span class="toc-nav-text">결론</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#set"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">Set</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#hashset"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">HashSet</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#set을-정렬하는-방법"><span class="toc-nav-number">6.1.</span> <span class="toc-nav-text">Set을 정렬하는 방법</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#map"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">Map</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#종류"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">종류</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://leejongchan.github.io/" target="_blank">JongChan</a></li>
                    
                        <li><a href="https://godpp.github.io" target="_blank">godpp</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- disqus embedded js code start (one page only need to embed once) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "your-disqus-ID";
    var disqus_identifier = "https://woovictory.github.io/2018/03/08/java-collection-framework/";
    var disqus_url = "https://woovictory.github.io/2018/03/08/java-collection-framework/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/WooVictory">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://github.com/WooVictory">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; VictoryWoo 2018 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://beantech.org">BeanTech</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=YenYuHsuan&repo=hexo-theme-beantech&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://woovictory.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://woovictory.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
