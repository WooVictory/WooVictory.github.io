
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>[운영체제] 인터럽트의 원리 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"articleBody":"\n프로그램의 구조와 인터럽트\n\n프로그램의 구조와 인터럽트\n\n\n프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다.\n코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 기계어 명렁으로 변환되어 저장되는 부분이다.\n데이터 영역 : 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다.\n스택 영역 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다.\n일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다.\n반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 OS 커널 부분에 존재하게 된다.\nOS는 현재 실행 중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다.\n\n1234예를 들어, A, B 두 개의 프로그램이 현재 수행중이라면커널 어딘가에 이 두 프로그램을 관리하기 위한 자료 구조가 존재한다.이 자료 구조를 &quot;프로세스 제어 블록(PCB)&quot;라 부른다.\n\nPCB에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다.\n\n123456프로그램 A가 수행 중에 인터럽트가 발생하면현재 실행 중이던 지점을 A의 프로세스 제어 블록에 저장한 후,인터럽트 처리를 모두 마치면프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.\n컴퓨터 시스템의 작동 개요\n\n\n\nCPU를 컴퓨터의 두뇌라고 부르지만\nCPU는 인간의 뇌처럼 스스로 생각하고 판단하는 능력을 갖추고 있지는 못하다.\n이는 CPU가 빠른 속도로 처리하는 계산 능력은 가지고 있지만,\n어떠한 작업을 수행해야 하는지에 대해 스스로 결정하는 능력이 없기 때문이다.\n\n\nCPU는 현재 수행해야 할 메모리 주소의 명령을 있는 그대로 처리할 뿐이다.\n이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다.\n즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다.\n\n\n일반적으로 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 바로 다음 주소의 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다.\n\n\n메모리에는 사용자 프로그램과 OS가 같이 올라가 수행된다.\n이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다.\n\n\n1234if 만약 프로그램 카운터가 메모리 주소 중 OS가 존재하는 부분을 가리킨다면    CPU가 커널 모드에서 수행 중이라고 이야기한다.else    CPU가 사용자 모드에서 수행 중이라고 이야기한다.\n\nCPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다.\n일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다. 이러한 일반 명령은 모든 프로그램이 수행할 수 있는 명령이다.\n특권 명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다.\n컴퓨터 시스템에서는 CPU 내에 모드 비트를 두어 특권 명령을 항상 OS만이 수행할 수 있도록 제한하고 있다.\n사용자 프로그램이 특권 명령의 수행이 필요한 경우 OS에게 특권 명령의 대행을 요청한다.\n이와 같은 서비스 요청을 시스템 콜이라고 한다.\n사용자 프로그램이 시스템 콜을 하게 되면 OS는 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.\n프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다.\nCPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 주변 장치의 상태를 지속적으로 파악할 수 없다.\n따라서, 주변 장치는 CPU의 도움이 필요한 경우 인터럽트를 사용해 CPU에게 서비스를 요청하게 된다.\n인터럽트를 발생시키기 위해 주변 장치는 인터럽트 라인을 세팅하고\nCPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 있는지 확인한다.\n인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.\n\n프로그램의 실행\n\n\n&quot;프로그램이 실행되고 있다&quot;는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 갖는다.\n\n\n디스크에 존재하던 실행 파일이 메모리에 적재됨을 의미한다.\n프로그램이 CPU를 할당받고 기계 명령을 수행하고 있는 상태를 의미한다.\n\n일반적인 컴퓨터 시스템의 경우 CPU는 하나밖에 없으므로 매 시점 CPU에서 명령을 수행하는 프로그램은 단 하나뿐이다. 하지만, 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 쓰고, 이들 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로 여러 프로그램이 동시에 실행된다는 말을 보편적으로 사용하는 것이다.\n\n\n실행 파일이 메모리에 적재될 때 실행 파일 전체가 메모리에 한꺼번에 올라가기 보다는 일부분만 메모리에 올라가고 나머지는 디스크의 특정 영역에 내려가 있는 것이 일반적이다. 이는 여러 프로그램이 공유하는 메모리 공간을 효율적으로 사용하기 위한 방법이다.\n\n\n프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 스왑 영역에 내려놓는 방식으로 운영된다.\n\n\n\n실행 파일이 실행되어 물리적 메모리에 적재되는 모습\n\n프로그램의 주소 공간은 코드, 데이터, 스택 등으로 구성된다.\n각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 가상 메모리 또는 논리적 메모리라 부른다.\n\n\n주소 변환에 의해 프로세스의 논리적 주소 공간이 물리적 메모리에 적재되는 모습\nOS도 하나의 프로그램이므로 OS 커널 역시 코드, 데이터, 스택의 주소 공간을 갖으며, 각각은 아래와 같은 역할 및 기능을 갖는다.\n\n\n커널의 코드\n\nOS의 기능 : 아랫단의 HW 자원을 효율적으로 관리하는 일 + 윗단의 응용프로그램 및 사용자에게 편리한 서비스 제공\nCPU, 메모리 등의 자원을 관리하기 위한 부분 + 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이룬다.\n이 밖에도 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다.\n\n\n\n커널의 데이터 영역\n\n각종 자원을 관리하기 위한 자료 구조가 저장된다.\nCPU, 메모리와 같은 HW 자원을 관리하기 위한 자료 구조뿐만 아니라 현재 수행 중인 프로그램을 관리하기 위한 자료 구조도 커널의 데이터 영역에 유지된다.\n이 때, 현재 수행 중인 프로그램을 프로세스라고 부른다.\n각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB가 존재한다.\n즉, HW + SW를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료 구조를 각각 유지한다.\n\n\n\n커널의 스택 영역\n\n함수 호출 시 복귀 주소를 저장하기 위한 용도로 사용된다.\n커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다.\n즉, 프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 커널의 주소 공간에 존재하는 커널 스택을 사용하게 된다.\n\n\n\nQ. 프로세스마다 별도의 스택을 두는 이유\nA. 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우에 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간이 필요하기 때문이다.\n또한, 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로 일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 된다.\n\n운영체제의 주소 공간 구조\n사용자 프로그램의 사용 함수\n\n프로그램이 사용하는 함수는 크게 사용자 정의 함수, 라이브러리 함수, 커널 함수 세 가지로 구분할 수 있다.\n\n사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다.\n라이브러리 함수란 누군가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.\n커널 함수는 OS 커널의 정의된 함수를 뜻한다.\n\n사용자 정의 함수와 라이브러리 함수는 모두 컴파일하여 실행 파일을 만들게 되면 프로그램의 코드 부분에 기계 명령 형태로 삽입된다. 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 또한, 함수 호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.\n커널 함수의 종류에는 사용자 프로그램이 OS의 서비스를 요청하기 위한 시스템 콜 함수와 HW/SW가 CPU의 서비스를 요청하기 위한 인터럽트 처리 함수가 있다.\n\n이와 같은 커널 함수는 OS 커널의 주소 공간에 코드가 정의된다. 즉, OS가 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.\n\n인터럽트\n\n인터럽트와 관련된 주요 용어로는 인터럽트 벡터와 인터럽트 핸들러가 있다.\n\n인터럽트 벡터\n\n여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.\n일종의 함수를 가리키는 포인터라고도 할 수 있다.\n\n\n인터럽트 핸들러\n\n실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부른다.\nOS 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 부른다.\n\n\n\n시스템 콜\n\n\n컴퓨터 시스템에서는 HW 및 SW 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다.\n\n사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다 보면, 입출력 등 특권 명령을 수행해야 할 필요가 잇다. 이 경우 사용자 프로그램은 OS에게 시스템 콜을 통해 특권 명령의 대행을 요청하게 된다.\n사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다.\n이 때 하드웨어적으로 모드 비트가 1에서 0으로 자동 세팅되기 때문에 OS는 특권 명령을 수행할 수 있다.\n모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며, 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다. 그러나 시스템 콜은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재ㅐ하는 함수를 호출하는 것이다.\n커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문이다.\n\n시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수를 호출하는 것과는 상이한 방법을 사용한다. 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.\n\n어떤 프로그램이 CPU를 할당받고 명령을 수행하다 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우가 있다.\n\n타이머에 의해 인터럽트 발생\n\n특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 하드웨어로 CPU 할당 시간이 만료되면 인터럽트를 발생시킨다.\n이러한 타이머는 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템의 구현을 위한 필수적인 요소이다.\n\n입출력 요청을 위한 시스템 콜\n\n오래 거리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이향하게 된다.\n입출력을 요청해는 프로세스는 입출력 요청이 완료되어 컨트롤러가 입터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 기회가 생기며 CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다.\n프로세스의 상태\n\n프로세스의 상태는 실행, 준비, 봉쇄의 3가지로 크게 나누어 볼 수 있다.\n실행\nCPU를 할당받고 기계어 명령을 수행하고 있는 프로세스의 상태이다.\n준비 상태\nCPU만 할당받으면 당장 명령을 수행할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당받지 못한 프로세스의 상태이다.\n봉쇄 상태\nCPU를 할당받더라도 명령을 수행할 수 없는 프로세스의 상태이다.\n프로세스가 요청한 입출력 작업이 진행중인 경우 CPU를 할당받더라도 입출력이 끝나기 전까지는 작업을 진행할 수 없기 때문에 CPU를 할당하지 않는다.\n준비상태에 있는 프로세스가 실행 상태로 변경되는 경우는 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태가 되거나 또는 실행 상태에 있던 프로세스의 CPU 할당 시간이 만료되어 타이머 인터럽트가 발생한 경우를 들 수 있다.\n\nOS는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(Ready Queue)를 두고 준비 큐의 제일 앞에 있는 프로세스에게 CPU를 할당한다.\n준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.\n\nOS는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 큐를 두고 있다.\n예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 디스크 입출력 큐(Disk I/O Queue)에 줄을 서게 된다. 그러면, 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행하게 된다. 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시키고 그러면 인터럽트 처리 루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄을 서게 된다.\n\n위에서 언급된 큐는 HW 자원을 기다리는 프로세스들을 줄 세우기 위한 것이었다.\n이와 같은 큐는 SW 자원을 기다리는 경우에도 필요한데, 아래와 같다.\n예를 들어 데이터에 대한 접근 권한은 SW 자원으로 분류될 수 있다.\n어떠한 프로세스가 공유 데이터를 사용하고 있는 도중에\n다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손될 수 있다.\n따라서, 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.\n이 때 접근한다는 의미가 반드시 CPU가 그 데이터를 사용하고 있다는 의미는 아니다.\n공유 데이터를 접근 중인 프로세스가 &quot;준비 상태&quot;나 &quot;봉쇄 상태&quot;로 변경된 경우에도\n새롭게 CPU를 할당받은 프로세스가 동일한 데이터를 접근하게 되면\n데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안된다.\n즉, 공유 데이터라는 일종의 SW 자원을 앞서 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당 받았다 하더라도 접근하지 않고 기다려야 하는 것이다. 여러 프로세스가 공유 데이터를 동시에 접근하려고 할 경우 공유 데이터를 기다리는 &quot;큐&quot;에 줄을 서게 하여 현재 그 데이터를 사용중인 프로세스가 데이터를 반납하기 전까지는 접근을 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방법을 사용하게 된다.\n\n\n위 그림처럼 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 이루어지게 된다.\n각 프로세스들이 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리하고 있다는 뜻이다.\n\n123456789예를 들어 타이머 입터럽트가 발생하면커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해다음에 어느 프로세스에게 CPU를 할당할지 결정하고현재 실행되던 프로세스는 준비 큐의 제일 뒤로 보내진다.준비 큐는 CPU 를 할당받기 위해 기다리고 있는 큐이므로어떤 프로세스에게 CPU를 할당할지 결정하려면 준비 큐를 봐야 한다.타이머 인터럽트이기 때문에 &quot;봉쇄 상태&quot;가 아니라 준비 큐의 가장 마지막에 재삽입하는 것이다.입출력 요청이었을 시에는 &quot;봉쇄 상태&quot;로 빠져 준비 큐에 들어가지 못한다.\n프로세스의 두 가지 실행 상태\n\n하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다.\n이는 프로그램이 사용자 정의 함수나 라이브러리 함수뿐 아니라 입출력 시스템 콜 등을 통해 OS 커널의 함수도 호출하여 실행하기 때문이다.\n12345678910111213141516171819예를 들어 프로세스 A가 CPU에서 실행되고 있다고 하면이는 자신의 주소 공간에 정의된 코드를 실행하는 것과커널의 시스템 콜 함수를 실행하는 것으로 나누어 볼 수 있다.전자를 사용자 모드에서의 실행 상태(User mode Running)이라 하고,후자를 커널 모드에서의 실행 상태(User mode Running)라고 한다.한가지 주의할 점은 시스템 콜이 수행되는 동안프로세스 A의 코드가 아니라 OS 커널의 코드이지만커널이 실행 상태에 있다고 하지 않고프로세스 A가 실행 상태에 있다고 말한다.프로세스 A 입장에서는 CPU를 OS 커널에게 빼앗긴 것으로 생각할 수도 있지만 커널의 코드가 실행되는 것이 사실상 프로세스 A가 해야 할 일을 대행하는것이기 때문에 시스템 콜이 실행 중일 때에도 여전히 프로세스 A는 실행 상태에 있는것으로 간주한다.다만, 프로세스 A 자신의 코드를 실행하는 것과 구분지어이러한 상태를 프로세스 A가 커널 모드에서 실행중이라고 이야기한다.\n\n정리하자면, 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 사용자 모드와 커널 모드의 실행 상태로 구분 지을 수 있다.\n프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 사용자 모드에서의 실행을 하게 되며, 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행하게 된다. 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행하게 된다. 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.\n\n","dateCreated":"2018-12-23T23:14:21+09:00","dateModified":"2020-05-13T00:13:34+09:00","datePublished":"2018-12-23T23:14:21+09:00","description":"","headline":"[운영체제] 인터럽트의 원리","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"},"publisher":{"@type":"Organization","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg","logo":{"@type":"ImageObject","url":"Victory.jpeg"}},"url":"https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/","keywords":"OS, 운영체제"}</script>
    <meta name="description" content="프로그램의 구조와 인터럽트  프로그램의 구조와 인터럽트   프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 기계어 명렁으로 변환되어 저장되는 부분이다. 데이터 영역 : 전역 변수">
<meta name="keywords" content="OS,운영체제">
<meta property="og:type" content="blog">
<meta property="og:title" content="[운영체제] 인터럽트의 원리">
<meta property="og:url" content="https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="프로그램의 구조와 인터럽트  프로그램의 구조와 인터럽트   프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 기계어 명렁으로 변환되어 저장되는 부분이다. 데이터 영역 : 전역 변수">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://woovictory.github.io/img/execute_file_os.png">
<meta property="og:image" content="https://woovictory.github.io/img/address_translation.png">
<meta property="og:image" content="https://woovictory.github.io/img/address_structure_of_os.png">
<meta property="og:image" content="https://woovictory.github.io/img/ready_queue_os.png">
<meta property="og:image" content="https://woovictory.github.io/img/sw_queue_os.png">
<meta property="og:updated_time" content="2020-05-12T15:13:34.565Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[운영체제] 인터럽트의 원리">
<meta name="twitter:description" content="프로그램의 구조와 인터럽트  프로그램의 구조와 인터럽트   프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 기계어 명렁으로 변환되어 저장되는 부분이다. 데이터 영역 : 전역 변수">
<meta name="twitter:image" content="https://woovictory.github.io/img/execute_file_os.png">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [운영체제] 인터럽트의 원리
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-12-23T23:14:21+09:00">
	
		    Dec 23, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Operation-System/">Operation System</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <ul>
<li><a href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8">프로그램의 구조와 인터럽트</a></li>
</ul>
<h1 id="프로그램의-구조와-인터럽트">프로그램의 구조와 인터럽트</h1>
<hr>
<ul>
<li>프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 <strong>코드, 데이터, 스택 영역</strong>으로 구분된다.</li>
<li>코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 <strong>기계어 명렁</strong>으로 변환되어 저장되는 부분이다.</li>
<li>데이터 영역 : 전역 변수 등 프로그램이 사용하는 <strong>데이터</strong>를 저장하는 부분이다.</li>
<li>스택 영역 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다.</li>
<li>일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다.</li>
<li>반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 OS 커널 부분에 존재하게 된다.</li>
<li>OS는 현재 실행 중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">예를 들어, A, B 두 개의 프로그램이 현재 수행중이라면</span><br><span class="line">커널 어딘가에 이 두 프로그램을 관리하기 위한 자료 구조가 존재한다.</span><br><span class="line"></span><br><span class="line">이 자료 구조를 &quot;프로세스 제어 블록(PCB)&quot;라 부른다.</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>PCB</strong>에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">프로그램 A가 수행 중에 인터럽트가 발생하면</span><br><span class="line">현재 실행 중이던 지점을 A의 프로세스 제어 블록에 저장한 후,</span><br><span class="line"></span><br><span class="line">인터럽트 처리를 모두 마치면</span><br><span class="line">프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 </span><br><span class="line">원래 수행하던 일을 재개하게 된다.</span><br></pre></td></tr></table></figure>
<h1 id="컴퓨터-시스템의-작동-개요">컴퓨터 시스템의 작동 개요</h1>
<hr>
<ul>
<li>
<p>CPU를 컴퓨터의 두뇌라고 부르지만<br>
CPU는 인간의 뇌처럼 스스로 생각하고 판단하는 능력을 갖추고 있지는 못하다.<br>
이는 CPU가 빠른 속도로 처리하는 계산 능력은 가지고 있지만,<br>
어떠한 작업을 수행해야 하는지에 대해 스스로 결정하는 능력이 없기 때문이다.</p>
</li>
<li>
<p>CPU는 현재 수행해야 할 <strong>메모리 주소</strong>의 명령을 있는 그대로 처리할 뿐이다.<br>
이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 <strong>레지스터를 프로그램 카운터라고 부른다.</strong><br>
즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다.</p>
</li>
<li>
<p>일반적으로 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 바로 다음 주소의 명령을 가리키게 되어 코드의 <strong>순차적인 수행</strong>이 이루어진다.</p>
</li>
<li>
<p>메모리에는 사용자 프로그램과 OS가 같이 올라가 수행된다.<br>
이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 만약 프로그램 카운터가 메모리 주소 중 OS가 존재하는 부분을 가리킨다면</span><br><span class="line">    CPU가 커널 모드에서 수행 중이라고 이야기한다.</span><br><span class="line">else</span><br><span class="line">    CPU가 사용자 모드에서 수행 중이라고 이야기한다.</span><br></pre></td></tr></table></figure>
<ul>
<li>CPU가 수행하는 명령에는 <strong>일반 명령</strong>과 <strong>특권 명령</strong>이 있다.</li>
<li>일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다. 이러한 일반 명령은 모든 프로그램이 수행할 수 있는 명령이다.</li>
<li>특권 명령은 <strong>보안</strong>이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다.</li>
<li>컴퓨터 시스템에서는 CPU 내에 <code>모드 비트</code>를 두어 특권 명령을 항상 OS만이 수행할 수 있도록 제한하고 있다.</li>
<li>사용자 프로그램이 특권 명령의 수행이 필요한 경우 OS에게 특권 명령의 대행을 요청한다.<br>
이와 같은 서비스 요청을 <strong>시스템 콜</strong>이라고 한다.</li>
<li>사용자 프로그램이 시스템 콜을 하게 되면 OS는 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.</li>
<li>프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다.</li>
<li>CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 주변 장치의 상태를 지속적으로 파악할 수 없다.<br>
따라서, 주변 장치는 CPU의 도움이 필요한 경우 <strong>인터럽트</strong>를 사용해 CPU에게 서비스를 요청하게 된다.</li>
<li>인터럽트를 발생시키기 위해 주변 장치는 <strong>인터럽트 라인</strong>을 세팅하고<br>
CPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 있는지 확인한다.</li>
<li>인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.</li>
</ul>
<h1 id="프로그램의-실행">프로그램의 실행</h1>
<hr>
<ul>
<li>&quot;프로그램이 실행되고 있다&quot;는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 갖는다.</li>
</ul>
<ol>
<li>디스크에 존재하던 <strong>실행 파일이 메모리에 적재됨</strong>을 의미한다.</li>
<li>프로그램이 CPU를 할당받고 <strong>기계 명령</strong>을 수행하고 있는 상태를 의미한다.</li>
</ol>
<p>일반적인 컴퓨터 시스템의 경우 CPU는 하나밖에 없으므로 매 시점 CPU에서 명령을 수행하는 프로그램은 단 하나뿐이다. 하지만, 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 쓰고, 이들 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로 여러 프로그램이 동시에 실행된다는 말을 보편적으로 사용하는 것이다.</p>
<ul>
<li>
<p><strong>실행 파일</strong>이 <strong>메모리에 적재</strong>될 때 실행 파일 전체가 메모리에 한꺼번에 올라가기 보다는 일부분만 메모리에 올라가고 나머지는 <strong>디스크의 특정 영역</strong>에 내려가 있는 것이 일반적이다. 이는 여러 프로그램이 공유하는 메모리 공간을 효율적으로 사용하기 위한 방법이다.</p>
</li>
<li>
<p>프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 <strong>스왑 영역</strong>에 내려놓는 방식으로 운영된다.</p>
</li>
</ul>
<img src="/img/execute_file_os.png" width="400" height="200">
<center>실행 파일이 실행되어 물리적 메모리에 적재되는 모습</center>
<ul>
<li>프로그램의 주소 공간은 <strong>코드, 데이터, 스택</strong> 등으로 구성된다.<br>
각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 <strong>가상 메모리 또는 논리적 메모리</strong>라 부른다.</li>
</ul>
<img src="/img/address_translation.png" width="400" height="200">
<center>주소 변환에 의해 프로세스의 논리적 주소 공간이 물리적 메모리에 적재되는 모습</center>
<p>OS도 하나의 프로그램이므로 OS 커널 역시 코드, 데이터, 스택의 주소 공간을 갖으며, 각각은 아래와 같은 역할 및 기능을 갖는다.</p>
<ul>
<li>
<p>커널의 코드</p>
<ul>
<li>OS의 기능 : 아랫단의 HW 자원을 효율적으로 관리하는 일 + 윗단의 응용프로그램 및 사용자에게 편리한 서비스 제공</li>
<li>CPU, 메모리 등의 자원을 관리하기 위한 부분 + 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이룬다.</li>
<li>이 밖에도 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다.</li>
</ul>
</li>
<li>
<p>커널의 데이터 영역</p>
<ul>
<li>각종 자원을 관리하기 위한 <strong>자료 구조</strong>가 저장된다.</li>
<li>CPU, 메모리와 같은 HW 자원을 관리하기 위한 자료 구조뿐만 아니라 현재 수행 중인 프로그램을 관리하기 위한 자료 구조도 커널의 데이터 영역에 유지된다.</li>
<li>이 때, 현재 수행 중인 프로그램을 <strong>프로세스</strong>라고 부른다.</li>
<li>각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 <strong>PCB</strong>가 존재한다.</li>
<li>즉, HW + SW를 포함하는 <strong>시스템 내의 모든 자원을 관리하기 위한 자료 구조를 각각 유지한다.</strong></li>
</ul>
</li>
<li>
<p>커널의 스택 영역</p>
<ul>
<li>함수 호출 시 복귀 주소를 저장하기 위한 용도로 사용된다.</li>
<li>커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다.</li>
<li>즉, 프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 <strong>자기 주소 공간 내의 스택</strong>을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 <strong>커널의 주소 공간에 존재하는 커널 스택</strong>을 사용하게 된다.</li>
</ul>
</li>
</ul>
<p><strong>Q. 프로세스마다 별도의 스택을 두는 이유</strong></p>
<p>A. 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우에 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간이 필요하기 때문이다.</p>
<p>또한, 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로 <strong>일관성 유지</strong>를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 된다.</p>
<img src="/img/address_structure_of_os.png" width="400" height="200">
<center>운영체제의 주소 공간 구조</center>
<h1 id="사용자-프로그램의-사용-함수">사용자 프로그램의 사용 함수</h1>
<hr>
<p>프로그램이 사용하는 함수는 크게 사용자 정의 함수, 라이브러리 함수, 커널 함수 세 가지로 구분할 수 있다.</p>
<ol>
<li>사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다.</li>
<li>라이브러리 함수란 누군가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.</li>
<li>커널 함수는 OS 커널의 정의된 함수를 뜻한다.</li>
</ol>
<p>사용자 정의 함수와 라이브러리 함수는 모두 <strong>컴파일</strong>하여 실행 파일을 만들게 되면 프로그램의 코드 부분에 <strong>기계 명령</strong> 형태로 삽입된다. 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 또한, 함수 호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.</p>
<p><strong>커널 함수의 종류</strong>에는 사용자 프로그램이 OS의 서비스를 요청하기 위한 <strong>시스템 콜 함수</strong>와 HW/SW가 CPU의 서비스를 요청하기 위한 <strong>인터럽트 처리 함수</strong>가 있다.</p>
<ul>
<li>이와 같은 커널 함수는 OS 커널의 주소 공간에 코드가 정의된다. 즉, OS가 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.</li>
</ul>
<h1 id="인터럽트">인터럽트</h1>
<hr>
<p>인터럽트와 관련된 주요 용어로는 <strong>인터럽트 벡터</strong>와 <strong>인터럽트 핸들러</strong>가 있다.</p>
<ul>
<li>인터럽트 벡터
<ul>
<li>여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다.</li>
<li>일종의 함수를 가리키는 <strong>포인터</strong>라고도 할 수 있다.</li>
</ul>
</li>
<li>인터럽트 핸들러
<ul>
<li>실제 인터럽트를 처리하기 위한 루틴으로 <strong>인터럽트 서비스 루틴</strong>이라고도 부른다.</li>
<li>OS 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 이 부분을 <strong>인터럽트 서비스 루틴</strong> 또는 <strong>인터럽트 핸들러</strong>라고 부른다.</li>
</ul>
</li>
</ul>
<h1 id="시스템-콜">시스템 콜</h1>
<hr>
<ul>
<li>컴퓨터 시스템에서는 HW 및 SW 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다.</li>
</ul>
<p>사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다 보면, 입출력 등 특권 명령을 수행해야 할 필요가 잇다. 이 경우 사용자 프로그램은 OS에게 <strong>시스템 콜</strong>을 통해 <strong>특권 명령의 대행</strong>을 요청하게 된다.<br>
사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다.<br>
이 때 하드웨어적으로 <strong>모드 비트</strong>가 1에서 0으로 자동 세팅되기 때문에 OS는 특권 명령을 수행할 수 있다.</p>
<p>모든 프로그램은 <strong>자신의 독자적인 주소 공간</strong>을 가지고 있으며, 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다. 그러나 <strong>시스템 콜</strong>은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재ㅐ하는 함수를 호출하는 것이다.<br>
<strong>커널</strong>이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문이다.</p>
<ul>
<li>시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수를 호출하는 것과는 <strong>상이한 방법</strong>을 사용한다. 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다.</li>
</ul>
<p>어떤 프로그램이 CPU를 할당받고 명령을 수행하다 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우가 있다.</p>
<ol>
<li>타이머에 의해 인터럽트 발생</li>
</ol>
<p>특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 하드웨어로 CPU 할당 시간이 만료되면 인터럽트를 발생시킨다.</p>
<p>이러한 타이머는 여러 프로세스가 CPU를 나누어 사용하는 <strong>시분할 시스템</strong>의 구현을 위한 필수적인 요소이다.</p>
<ol start="2">
<li>입출력 요청을 위한 시스템 콜</li>
</ol>
<p>오래 거리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이향하게 된다.</p>
<p>입출력을 요청해는 프로세스는 입출력 요청이 완료되어 컨트롤러가 입터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 기회가 생기며 CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다.</p>
<h1 id="프로세스의-상태">프로세스의 상태</h1>
<hr>
<p>프로세스의 상태는 <strong>실행, 준비, 봉쇄</strong>의 3가지로 크게 나누어 볼 수 있다.</p>
<p><strong>실행</strong></p>
<p>CPU를 할당받고 <strong>기계어 명령</strong>을 수행하고 있는 프로세스의 상태이다.</p>
<p><strong>준비 상태</strong></p>
<p>CPU만 할당받으면 당장 명령을 수행할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당받지 못한 프로세스의 상태이다.</p>
<p><strong>봉쇄 상태</strong></p>
<p>CPU를 할당받더라도 명령을 수행할 수 없는 프로세스의 상태이다.<br>
프로세스가 요청한 입출력 작업이 진행중인 경우 CPU를 할당받더라도 입출력이 끝나기 전까지는 작업을 진행할 수 없기 때문에 CPU를 할당하지 않는다.</p>
<p>준비상태에 있는 프로세스가 실행 상태로 변경되는 경우는 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태가 되거나 또는 실행 상태에 있던 프로세스의 CPU 할당 시간이 만료되어 <strong>타이머 인터럽트</strong>가 발생한 경우를 들 수 있다.</p>
<ul>
<li>OS는 준비 상태에 있는 프로세스들을 줄 세우기 위해 <strong>준비 큐</strong>(Ready Queue)를 두고 준비 큐의 제일 앞에 있는 프로세스에게 CPU를 할당한다.<br>
준비 큐에 프로세스를 줄 세우는 방법은 <code>CPU 스케줄링</code> 방법에 따라 달라진다.</li>
</ul>
<p>OS는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 <strong>자원별</strong>로 큐를 두고 있다.</p>
<p>예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 <code>디스크 입출력 큐(Disk I/O Queue)</code>에 줄을 서게 된다. 그러면, 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행하게 된다. 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시키고 그러면 인터럽트 처리 루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄을 서게 된다.</p>
<img src="/img/ready_queue_os.png" width="400" height="200">
<p>위에서 언급된 큐는 HW 자원을 기다리는 프로세스들을 줄 세우기 위한 것이었다.<br>
이와 같은 큐는 <strong>SW 자원</strong>을 기다리는 경우에도 필요한데, 아래와 같다.</p>
<p>예를 들어 데이터에 대한 접근 권한은 SW 자원으로 분류될 수 있다.<br>
어떠한 프로세스가 공유 데이터를 사용하고 있는 도중에<br>
다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손될 수 있다.</p>
<p>따라서, 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.<br>
이 때 접근한다는 의미가 반드시 CPU가 그 데이터를 사용하고 있다는 의미는 아니다.</p>
<p>공유 데이터를 접근 중인 프로세스가 &quot;준비 상태&quot;나 &quot;봉쇄 상태&quot;로 변경된 경우에도<br>
새롭게 CPU를 할당받은 프로세스가 동일한 데이터를 접근하게 되면<br>
데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안된다.</p>
<p>즉, 공유 데이터라는 일종의 SW 자원을 앞서 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당 받았다 하더라도 접근하지 않고 기다려야 하는 것이다. 여러 프로세스가 공유 데이터를 동시에 접근하려고 할 경우 공유 데이터를 기다리는 &quot;큐&quot;에 줄을 서게 하여 현재 그 데이터를 사용중인 프로세스가 데이터를 반납하기 전까지는 접근을 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방법을 사용하게 된다.</p>
<img src="/img/sw_queue_os.png" width="400" height="200">
<ul>
<li>위 그림처럼 프로세스의 상태 관리는 커널의 주소 영역 중 <strong>데이터 영역</strong>에 다양한 큐를 두어 이루어지게 된다.</li>
<li>각 프로세스들이 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 <strong>커널</strong>이 총체적으로 관리하고 있다는 뜻이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">예를 들어 타이머 입터럽트가 발생하면</span><br><span class="line">커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해</span><br><span class="line">다음에 어느 프로세스에게 CPU를 할당할지 결정하고</span><br><span class="line">현재 실행되던 프로세스는 준비 큐의 제일 뒤로 보내진다.</span><br><span class="line"></span><br><span class="line">준비 큐는 CPU 를 할당받기 위해 기다리고 있는 큐이므로</span><br><span class="line">어떤 프로세스에게 CPU를 할당할지 결정하려면 준비 큐를 봐야 한다.</span><br><span class="line">타이머 인터럽트이기 때문에 &quot;봉쇄 상태&quot;가 아니라 준비 큐의 가장 마지막에 재삽입하는 것이다.</span><br><span class="line">입출력 요청이었을 시에는 &quot;봉쇄 상태&quot;로 빠져 준비 큐에 들어가지 못한다.</span><br></pre></td></tr></table></figure>
<h1 id="프로세스의-두-가지-실행-상태">프로세스의 두 가지 실행 상태</h1>
<hr>
<p>하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다.</p>
<p>이는 프로그램이 사용자 정의 함수나 라이브러리 함수뿐 아니라 입출력 시스템 콜 등을 통해 OS 커널의 함수도 호출하여 실행하기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">예를 들어 프로세스 A가 CPU에서 실행되고 있다고 하면</span><br><span class="line">이는 자신의 주소 공간에 정의된 코드를 실행하는 것과</span><br><span class="line">커널의 시스템 콜 함수를 실행하는 것으로 나누어 볼 수 있다.</span><br><span class="line"></span><br><span class="line">전자를 사용자 모드에서의 실행 상태(User mode Running)이라 하고,</span><br><span class="line">후자를 커널 모드에서의 실행 상태(User mode Running)라고 한다.</span><br><span class="line"></span><br><span class="line">한가지 주의할 점은 시스템 콜이 수행되는 동안</span><br><span class="line">프로세스 A의 코드가 아니라 OS 커널의 코드이지만</span><br><span class="line">커널이 실행 상태에 있다고 하지 않고</span><br><span class="line">프로세스 A가 실행 상태에 있다고 말한다.</span><br><span class="line"></span><br><span class="line">프로세스 A 입장에서는 CPU를 OS 커널에게 빼앗긴 것으로 생각할 수도 있지만 </span><br><span class="line">커널의 코드가 실행되는 것이 사실상 프로세스 A가 해야 할 일을 대행하는</span><br><span class="line">것이기 때문에 시스템 콜이 실행 중일 때에도 여전히 프로세스 A는 실행 상태에 </span><br><span class="line">있는것으로 간주한다.</span><br><span class="line"></span><br><span class="line">다만, 프로세스 A 자신의 코드를 실행하는 것과 구분지어</span><br><span class="line">이러한 상태를 프로세스 A가 커널 모드에서 실행중이라고 이야기한다.</span><br></pre></td></tr></table></figure>
<ul>
<li>정리하자면, 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 <strong>사용자 모드</strong>와 <strong>커널 모드</strong>의 실행 상태로 구분 지을 수 있다.</li>
<li>프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 <strong>사용자 모드</strong>에서의 실행을 하게 되며, 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행하게 된다. 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행하게 된다. 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/OS/">OS</a> <a class="tag tag--primary tag--small t-link" href="/tags/운영체제/">운영체제</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/12/25/OS-Process/"
                    data-tooltip="[운영체제] 프로세스"
                    aria-label="PREVIOUS: [운영체제] 프로세스"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/12/22/OS-How-Computer-System-Work/"
                    data-tooltip="[운영체제] 컴퓨터 시스템의 동작 원리"
                    aria-label="NEXT: [운영체제] 컴퓨터 시스템의 동작 원리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/12/25/OS-Process/"
                    data-tooltip="[운영체제] 프로세스"
                    aria-label="PREVIOUS: [운영체제] 프로세스"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/12/22/OS-How-Computer-System-Work/"
                    data-tooltip="[운영체제] 컴퓨터 시스템의 동작 원리"
                    aria-label="NEXT: [운영체제] 컴퓨터 시스템의 동작 원리"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#disqus_thread"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    
        <script>
          var disqus_config = function() {
            this.page.url = 'https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/';
              
            this.page.identifier = '2018/12/23/OS-The-Principle-Of-Interrupt/';
              
          };
          (function() {
            var d = document, s = d.createElement('script');
            var disqus_shortname = 'https-woovictory-github-io';
            s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
    




    </body>
</html>
