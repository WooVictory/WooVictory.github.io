{"meta":{"title":"VictoryWoo","subtitle":"VictoryWoo's Blog","description":"","author":"VictoryWoo","url":"https://woovictory.github.io"},"pages":[{"title":"","date":"2018-03-29T14:17:56.566Z","updated":"2018-02-28T02:29:46.000Z","comments":true,"path":"404.html","permalink":"https://woovictory.github.io/404.html","excerpt":"","text":""},{"title":"Archives","date":"2017-03-20T11:49:56.000Z","updated":"2018-04-13T08:00:10.343Z","comments":false,"path":"archive/index.html","permalink":"https://woovictory.github.io/archive/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-26T06:56:36.690Z","updated":"2020-05-26T06:56:36.690Z","comments":true,"path":"about/index.html","permalink":"https://woovictory.github.io/about/index.html","excerpt":"","text":"😄 Information Name : Seung Woo Lee Mail : jhsw0375@gmail.com 읽기 좋은 글을 작성하기 위해 노력하고 있습니다. Android 앱을 개발합니다. 😎 SNS Github LinkedIn 🍕 Activities 2020 01.26 ~ : 신입 개발자를 위한 지식 정리 공간 운영 04.30 : 신입 개발자를 위한 지식 정리 공간의 Star 100개를 돌파했습니다. 앞으로 더 노력하겠습니다. 2019 03.10 ~ 07.06 : DDD(Designer Developer Day Day) 동아리 활동 05.16 ~ 05.17 : Naver Hack Day Summer Android 개발 참여 01.21 ~ 02.23 : 부스트 캠프 Android 과정 3기 참여 및 ‘하루 듣기’ 애플리케이션 개발 2018 12.17 : SKT x 한국 관광 공사 앱 공모전 수상 11.01 ~ 11.26 : SOPT x KB 금융 지주 App Challenge Android 개발 참여 09.20 ~ 10.20 : 서울시 앱 공모전 Android 개발 참여 09.15 ~ 12.31 : 메이슨 인텔리전스 인턴 인공지능 학습 문서 포맷화 분류 작업 07.20 ~ 07.21 : Amathon 참가 06.30 ~ 07.14 : App Jam Android 개발 대상 수상 at SOPT 03.20 ~ 07.21 : SOPT Android Part 활동 2017 12.31 ~ 18.01.14 : App Jam “Lang” Android 개발 참여 03.15 ~ 07.16 : SOPT 운영팀 활동 03.01 ~ 07.15 : SOPT Android Part 활동 2016 09.29 : 육군 만기 제대 2014 14.12.31 : 육군 입대 02.10 ~ 12.20 : 학과 운영진 센세이션 활동 🎉 Prize 2018.12.17 : SKT x 한국 관광 공사 앱 공모전 장려상 수상 2018.11.26 : SOPT x KB 금융 App Challenge Prototype Android 개발 최우수상 수상 2018.07.14 : App Jam Android Develop 대상 수상 at SOPT"},{"title":"Tags","date":"2018-04-13T08:00:35.794Z","updated":"2018-04-13T08:00:35.794Z","comments":true,"path":"tags/index.html","permalink":"https://woovictory.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Android] Manifest merger failed with multiple errors, see logs","slug":"Android-ManifestError","date":"2020-07-04T15:23:41.000Z","updated":"2020-07-04T15:55:30.010Z","comments":true,"path":"2020/07/05/Android-ManifestError/","link":"","permalink":"https://woovictory.github.io/2020/07/05/Android-ManifestError/","excerpt":"","text":"라인 앱 개발 챌린지에서 만들었던 메모장 앱을 리팩토링해서 스토어에 배포할 마음이 생겨서 조금씩 다시 수정을 하고 있다. 혼자 개발하는 앱이지만, 나름의 체계를 갖추고 싶어서 수정할 부분을 Github의 Issue를 사용하여 티켓형식으로 만들었다. 그리고 브랜치는 해당 이슈의 번호로 생성하여 작업을 완료한 뒤, PR하여 머지하려고 한다. 그 중에서 Ted님의 tedImagePicker 라이브러리를 적용하면서 생긴 상황과 해결 방법을 공유하려고 한다. Error 상황 처음 설계할 때, 카메라를 통해 찍은 사진을 저장하기 위한 폴더를 만들고, 파일로 저장했었다. 그리고 해당 경로의 uri를 얻기 위해 Manifest에 Content-Provider를 정의했었다. 그렇게 많은 이해를 바탕으로 작성한 코드가 아니었던 것 같다. 아무튼, 이번 리팩토링을 하면서 내가 생각했던 설계들의 착오로 많은 부분이 수정되어야 했다. 그래서 가장 핵심 부분을 수정하기 위해 tedImagePicker를 사용하기로 결정했다. 해당 라이브러리를 사용하게 되면 내부의 구현과 동작으로 인해 내가 고민했던 부분을 해결할 수 있었다. 카메라로 찍은 이미지를 폴더를 만들고 파일로 생성한 뒤, 비트맵으로 변환할 필요가 없다. =&gt; 위의 과정을 거쳤던 이유는 카메라로 찍은 사진인 갤러리에 저장되지 않기 때문이었다. 하지만, tedImagePicker를 사용하면 갤러리에 카메라가 함께 포함되어 있다. 사진을 찍을 경우, 찍은 사진이 바로 갤러리에 저장되도록 구조가 잡혀있다. 따라서 갤러리의 사진들과 같이 내가 찍은 사진도 uri가 이미 존재함으로 내가 원하는 uri만을 얻을 수 있다. 글라이드를 사용한 비트맵 처리를 수행하기 때문에 RecyclerView에 항목이 많으면 렌더링 속도로 인해 화면이 버벅이게 된다. =&gt; 카메라를 통해서 찍은 사진의 비트맵 처리로 인해 시간이 오래 걸리는 작업이 되게 된다. 이 작업을 비동기로 돌리기 위해서는 결국, 로직의 처리가 애매해지는 부분도 존재한다. 하지만, 위에서처럼 uri 형태의 리스트를 받게 되면 비트맵 처리로 인해 렌더링 속도가 저하되는 문제는 발생하지 않는다. 따라서 tedImagePicker 라이브러리를 사용하기로 했다. gradle에 추가하고, 빌드를 해봤는데 에러가 발생했다. 에러 내용은 아래와 같다. Error 해결 방법 위의 에러를 확인하기 위해서 AndroidManifest.xml 파일을 열어야 한다. 파일을 열고 아래의 Text 옆의 Merged Manifest를 클릭하면 우측에 에러 메시지를 확인할 수 있다. 필자는 Provider 정의가 이미 되어 있다고 나온다. 그렇다면 빌드를 다시 돌려보면 이제는 정확한 에러가 나온다. 내용을 읽어보니, 필자가 추가한 tedImagePicker에서 이미 Provider 정의가 되어 있기 때문에 직접 추가한 부분과의 충돌이 발생한 것이다. 따라서 필자가 Manifes 파일에 추가한 Provider 정의를 지워주게 된다면 정상적으로 동작하며, tedImagePicker를 사용할 수 있게 된다. Reference [안드로이드] Manifest merger failed with multiple errors, see logs","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Error","slug":"Error","permalink":"https://woovictory.github.io/tags/Error/"},{"name":"Manifest","slug":"Manifest","permalink":"https://woovictory.github.io/tags/Manifest/"}]},{"title":"[ETC] 여러 용어","slug":"ETC-Terms","date":"2020-06-26T04:24:26.000Z","updated":"2020-06-26T04:38:51.761Z","comments":true,"path":"2020/06/26/ETC-Terms/","link":"","permalink":"https://woovictory.github.io/2020/06/26/ETC-Terms/","excerpt":"","text":"MAU, DAU, MCU, ACU 라는 용어에 대해 간략하게 정리하려고 한다. MAU MAU(Monthly Activity User)는 월별 활동한 이용자를 의미하며, 한 달에 몇명이나 이 서비스를 이용하는지에 대해서 구분할 때, 사용한다. 보통, 사용자 키가 있는 경우에 그 기준으로 구성된다. 회원수와는 다르다. DAU DAU(Daily Activity User)는 일별 활동 이용자에 대한 수치이며, 하루에 몇명이나 이 서비스를 사용하는가에 대해서 이야기한다. 동시접속자를 나타내는 수치와는 다른 의미이다. MCU MCU(Maximum Current User)는 순간 동시 접속자를 의미하며, 보통 실시간으로 수치를 해석한다. ACU ACU(Average Current User)로 숫자로 평균 동시 접속 유저수를 의미한다. 이와 같은 단어들은 상당히 많은 곳에서 의미 있는 숫자로 사용되며, 이 추이를 관리하는 것이 서비스나 게임의 유용함이나 어떤 기획에 의해서 새로운 서비스가 의미있는 형태로 사용되고 있는지에 대해서 표시되는 숫자이다. MAU는 보통 해당 서비스가 확보하고 있는 차용자의 총 수를 의미하며, DAU는 ARPU(Average Revenue Per User, 가입자 당 평균 수익) 등을 계산할 때 참고할 수 있는 매우 중요한 숫자이다. DAU는 한 명이 여러번 사이트를 방문하더라도, 1명으로 집계되는 숫자이고 MAU보다 더 세밀한 정보들을 얻을 수 있기 때문에 이 수치를 지속적으로 관찰하고 패턴을 연구하면 단기 이벤트나 고객의 이용 패턴들에 대해 얻을 수 있다. 사용자를 중심으로 매출이나 서비스의 성장 등에 대해서 얻을 수 있는 매우 중요한 지표이다. 그래서 대부분의 서비스를 구현하면서 이 4가지 지표를 얻기 위해서 별도의 서비스들을 구성하거나 내부적으로 구성하게 된다. 정말 중요한 숫자이며, 얻을 수 있는 곳은 어디일까? 어떻게 얻을 수 있을까? 이미 만들어진 서비스에 적절한 로그 시스템을 부착하고, 해당 내용들을 추적하고 보관, 분석하는 방법을 사용한다. 대표적인 것이 Google Analytics(GA)라고 불리는 서비스를 사용하는 것이다. Reference MAU, DAU, MCU, ACU","categories":[{"name":"ETC","slug":"ETC","permalink":"https://woovictory.github.io/categories/ETC/"}],"tags":[{"name":"용어","slug":"용어","permalink":"https://woovictory.github.io/tags/용어/"},{"name":"IT 업계","slug":"IT-업계","permalink":"https://woovictory.github.io/tags/IT-업계/"}]},{"title":"[Kotlin] 공변과 불변","slug":"Convariant-With-Kotlin","date":"2020-06-25T03:51:20.000Z","updated":"2020-06-25T05:18:44.122Z","comments":true,"path":"2020/06/25/Convariant-With-Kotlin/","link":"","permalink":"https://woovictory.github.io/2020/06/25/Convariant-With-Kotlin/","excerpt":"","text":"서론 코틀린의 제네릭과 관련된 개념 중 in, out 키워드의 정확한 의미를 몰라 정리하게 되었다. 본론 모던 랭귀지들은 타입바운드 개념을 제공한다. 타입 바운드는 다음과 같이 3가지로 분류할 수 있다. 1. 무공변성(invariant) 2. 공변성(convariant) 3. 반공변성(contravariant) 1. 무공변성(invariant) 상속 관계에 상관없이, 자기 타입만을 허용하는 것을 의미한다. 보기 편하도록 한 파일 안에 필요한 클래스와 인터페이스를 작성했다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package GenericsSample.invariantTest/** * created by victory_woo on 2020/06/25 * */fun main(args: Array&lt;String&gt;) &#123; val language : Some&lt;Language&gt; = object : Some&lt;Language&gt;&#123; override fun something() &#123; println(\"language\") &#125; &#125; val jvm : Some&lt;JVM&gt; = object : Some&lt;JVM&gt;&#123; override fun something() &#123; println(\"jvm\") &#125; &#125; val kotlin : Some&lt;Kotlin&gt; = object : Some&lt;Kotlin&gt;&#123; override fun something() &#123; println(\"kotlin\") &#125; &#125; test(language) // error test(jvm) // success test(kotlin) // error&#125;fun test(value: Some&lt;JVM&gt;)&#123; println(\"Success\")&#125;interface Some&lt;T&gt; &#123; fun something()&#125;open class Languageopen class JVM : Language()class Kotlin : JVM() test 함수는 Some 타입만을 입력받는다. 따라서 Language, Kotlin은 허용하지 않는다. 이러한 개념은 무공변성이라고 한다. 2. 공변성(convariant) 타입 생성자에게 리스코프 치환 법칙을 허용한다는 의미이다. 12345678910111213141516171819202122232425262728293031323334353637fun main(args: Array&lt;String&gt;)&#123; val language : Some&lt;Language&gt; = object : Some&lt;Language&gt;&#123; override fun something() &#123; println(\"language\") &#125; &#125; val jvm : Some&lt;JVM&gt; = object : Some&lt;JVM&gt;&#123; override fun something() &#123; println(\"jvm\") &#125; &#125; val kotlin : Some&lt;Kotlin&gt; = object : Some&lt;Kotlin&gt;&#123; override fun something() &#123; println(\"kotlin\") &#125; &#125; test(language) // error test(jvm) // success test(kotlin) // success&#125;fun test(value: Some&lt;out JVM&gt;)&#123; println(\"Success\")&#125;interface Some&lt;T&gt; &#123; fun something()&#125;open class Languageopen class JVM : Language()class Kotlin : JVM() test 함수의 JVM 앞에 out 키워드를 추가했다. out : 자기 자신과 자식 객체를 허용하겠다는 의미이다. 따라서 JVM을 상속받은 Kotlin을 타입으로 사용하는 kotlin은 error가 발생하지 않는다. 3. 반공변성(contravariant) 공변성의 반대 개념을 생각하면 쉽다. 자기 자신과 부모 객체만 허용한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package GenericsSample.contravariantTestimport GenericsSample.invariantTest.JVMimport GenericsSample.invariantTest.Kotlinimport GenericsSample.invariantTest.Languageimport GenericsSample.invariantTest.Some/** * created by victory_woo on 2020/06/25 * */fun main(args: Array&lt;String&gt;) &#123; val language: Some&lt;Language&gt; = object : Some&lt;Language&gt; &#123; override fun something() &#123; println(\"language\") &#125; &#125; « val jvm: Some&lt;JVM&gt; = object : Some&lt;JVM&gt; &#123; override fun something() &#123; println(\"jvm\") &#125; &#125; val kotlin: Some&lt;Kotlin&gt; = object : Some&lt;Kotlin&gt; &#123; override fun something() &#123; println(\"kotlin\") &#125; &#125; test(language) // success test(jvm) // success test(kotlin) // error&#125;fun test(value: Some&lt;in JVM&gt;) &#123; println(\"Success\")&#125;interface Some&lt;T&gt; &#123; fun something()&#125;open class Languageopen class JVM : Language()class Kotlin : JVM() test 함수의 JVM 앞에 in 키워드를 추가했다. in : 자기 자신과 부모 객체만을 허용한다는 의미이다. 따라서 JVM과 부모인 Language는 컴파일이 되지만, JVM을 상속받은 Kotlin 객체는 허용하지 않는다. 결론 무공변성은 타입 앞에 아무런 키워드가 붙지 않으며, 해당 타입의 객체 즉, 자신만을 허용한다. 공변성은 out 키워드를 사용하며, 자기 자신과 자기 자신을 상속받은 즉, 자식 객체 타입을 허용한다. 반공변성은 in 키워드를 사용하며, 자기 자신과 자기 자신의 슈퍼 타입 즉, 부모 객체 타입을 허용한다. Reference 공변과 불변 with Kotlin","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"Generics","slug":"Generics","permalink":"https://woovictory.github.io/tags/Generics/"},{"name":"제네릭","slug":"제네릭","permalink":"https://woovictory.github.io/tags/제네릭/"},{"name":"공변과 불변","slug":"공변과-불변","permalink":"https://woovictory.github.io/tags/공변과-불변/"},{"name":"in, out","slug":"in-out","permalink":"https://woovictory.github.io/tags/in-out/"}]},{"title":"[Android] RecyclerView의 NotifyXXX 함수들","slug":"Android-RecyclerView-NotifyXXX-Functions","date":"2020-06-25T02:00:55.000Z","updated":"2020-06-25T03:12:27.108Z","comments":true,"path":"2020/06/25/Android-RecyclerView-NotifyXXX-Functions/","link":"","permalink":"https://woovictory.github.io/2020/06/25/Android-RecyclerView-NotifyXXX-Functions/","excerpt":"","text":"안드로이드의 RecyclerView 어댑터에서 항목이 변경되는 순간 이를 알려주는 메소드들이 있다. 효율적으로 사용하기 위해서 각 메소드들의 특징을 알아야 한다. Methods 데이터 변경 이벤트에는 '아이템 변경’과 '구조 변경’의 두 가지가 존재한다. 아이템 변경(Item change) : 단일 항목의 데이터가 업데이트되었지만 위치는 변경되지 않은 경우 구조 변경(Structural change) : 아이템이 Data Set 내에서 삽입, 이동된 경우 [notifyDataSetChanged] 1void notifyDataSetChanged() 반환값이 없다. Data set이 변경된 경우, 그 내용을 등록된 옵저버에 알려준다. 해당 이벤트는 변경된 Data Set에 대해 규명하지 않으므로 옵저버에게 기존의 모든 아이템과 구조가 유효하지 않을 것이라고 알려준다. LayoutManager는 모든 자료를 다시 바인딩하고, 모든 View를 다시 레이아웃하게 된다. 가능한 이 이벤트를 사용하는 것보다 해당 상황에 더 적합한 구체적인 이벤트를 사용하는 것이 성능 측면에서 좋다. 사용이 편리하지만, 최후의 수단으로 사용하는 게 좋다. [nofityItemChanged] 1void notifyItemChanged(int position, Object payload) position : (필수) 변경된 아이템의 위치 payload : (옵션) null 값인 경우, 모든 업데이트로 식별 아이템의 위치가 변경되면 옵저버에게 알려주는 메소드이다. payload 객체를 옵션으로 사용할 수 있다. 구조가 변경되는 이벤트에는 반응하지 않는다. [notifyItemInserted] 1void notifyItemInserted(int position) position : (필수) Data Set에 새로 삽입된 아이템의 위치 position의 위치에 새로 삽입된 아이템이 있음을 옵저버에게 알려 반영한다. 특정 포지션에 아이템을 삽입하고 싶으면 position 값에 +1을 해야 한다.(3번 위치에 삽입이 되었다면 2+1) 구조가 변경되는 이벤트이며, Data Set의 기존 아이템은 최신의 것으로 간주된다. 위치가 변경될 수는 있지만, rebound 되지는 않는다. [notifyItemMoved] 1void notifyItemMoved(int fromPosition, int toPosition) fromPosition : (필수) 아이템의 이전 위치값 toPosition : (필수) 아이템의 새로운 위치값 fromPosition의 위치값에서 toPosition의 위치값으로 아이템이 이동되었을 때, 옵저버에 알리는 메소드이다. 구조가 변경되는 이벤트이다. 이동되지 않은 기존 아이템은 최신의 것으로 간주된다. [notifyItemRangeChanged] 1void notifyItemRangeChanged(int positionStart, int itemCount, Object payload) positionStart : (필수) 변경된 첫 번째 아이템의 위치 itemCount : (필수) 변경된 아이템의 갯수 payload : (옵션) null 값인 경우, 모든 업데이트로 식별 positionStart 위치에서 시작하여 itemCount 갯수만큼 아이템이 변경되었을 때 옵저버에게 알리는 메소드이다. 아이템 변경 이벤트이지 구조 변경 이벤트는 아니다. Reference RecyclerView.Adapter 변경 알림 메소드 정리","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"},{"name":"NotifyXXX","slug":"NotifyXXX","permalink":"https://woovictory.github.io/tags/NotifyXXX/"}]},{"title":"[Java] 어떤 알고리즘이 사용될까?","slug":"Java-Sort-Methods","date":"2020-06-24T08:09:34.000Z","updated":"2020-06-25T01:30:15.533Z","comments":true,"path":"2020/06/24/Java-Sort-Methods/","link":"","permalink":"https://woovictory.github.io/2020/06/24/Java-Sort-Methods/","excerpt":"","text":"서론 자바의 정렬 함수를 자주 사용하는데, 내부적으로 어떤 알고리즘이 사용되는지 궁금해서 작성하게 되었다. 참고로 이번 글은 정렬 알고리즘을 설명하는 게 아닌 어떤 알고리즘이 쓰이는지를 정리하는 글이다. 본론 Java나 Android에서 Arrays.sort()는 Primitive Type이나 Object Type의 Array를 정렬할 때 사용한다. Collections.sort()는 Collection의 List를 정렬할 때 사용한다. 기본적으로 둘 다 오름차순 정렬이고, 인자로서 Array 또는 List를 넣어주면 인자로 넘겨진 객체의 내용 자체가 바뀐다. 또한, 둘 다 static method이므로 객체를 생성하지 않고 호출이 가능하다. 핵심 Arrays는 하나의 알고리즘만을 쓰는 것이 아니다. 기본적으로 Insertion Sort, Merge Sort, Quick Sort 3가지를 사용한다. 예전에는 3가지 Sorting이 구분되어 사용되었다. 하지만, 현재는 이를 변형한 Tim Sort, Dual-Pivot Quick Sort를 쓴다고 한다. &lt;예전 기준&gt; 1. 배열의 크기가 아주 작을 때(7개 미만) -&gt; Insertion Sort 왜 7개 미만일 때, Insertion Sort를 사용하는지는 수학적으로, 빅오 표기법의 맹점에 대해 접근할 수 있다. Insertion Sort는 대상의 갯수에 따라 비교 횟수가 다르다. 2개의 대상일 때는 1번 비교 3개의 대상일 때는 2번 비교 4개의 대상일 때는 3번 비교 즉, n개일 때 (n-1)번 비교한다. 이는 1+2+…+n-1+n이고 n(n-1)/2라는 공식이 도출된다. n^2이 영향이 가장 크므로 빅오 표기법으로는 O(N^2)이 되지만 정확히는 n(n-1) /2이다. n=6일 때, 6x5 / 2 = 15가 나오며, n=7일 때, 7x6 / 2 = 21이 나온다. [Merge Sort] Merge Sort의 시간 복잡도는 O(N logN)이다. n=6일 때, 대략 15.509가 나오며, n=7일 때, 19.651이 나온다. 따라서 n=6일 때는 일반적으로 Insertion Sort가 유리하며, n=7일 때는 Merge Sort가 유리하다. n=6 이하일 때는 Insertion Sort를 사용하고, n=7 이상일 때는 Merge Sort를 사용하는 것이 빠른 경우이다. Insertion Sort의 최악의 경우는 정렬할 데이터가 완전히 역순일 때이다. 하지만, 이러한 경우는 특별한 케이스이기 때문에 무시하고 평균적으로 n=6일 때, Insertion Sort가 더 빠르므로 사용하는 것이다. 2. Merge Sort와 Quick Sort를 사용하는 여부는 Sorting 알고리즘의 Stable과 관계가 있다. Stable : 안전성을 의미하며, 정렬에서의 Stable은 같은 값을 비교했을 때 기존의 순서가 바뀌는지, 안바뀌는지를 의미한다. Primitive Type의 Array를 정렬하는 것은 값의 대소를 비교하며, 같은 값을 가지는 2개의 숫자를 구분할 방법은 없다. ex) [2 1 2 3] 배열을 오름차순 정렬하면 [1 2 2 3]이 된다. 이때 2와 2는 서로 같은 값을 가지지만, 정렬 과정에서 상대적인 위치가 바뀔 수 있다. 하지만, Primitive Type끼리는 이를 구분할 수 없고 별다른 영향도 없기에 구분할 필요도 없다. 위와 같은 것을 Not Stable하다고 한다. Merge Sort를 써도 상관 없으나 일반적으로 Quick Sort가 더 빠르므로 Primitive Type은 Quick Sort를 사용하여 정렬한다. Quick Sort가 Merge Sort보다 값에 대한 비교를 더 많이한다고 할지라도 Array에 대한 Access 횟수가 적기 때문에 크게 봤을 때, 더 빠르다. Quick, Merge Sort 모두 분할 정복 방법에 기반하여 서브 리스트를 나누어 작은 배열을 정렬하는 방식을 사용한다. 일반적으로 Quick Sort가 더 빠른 이유는 어느 정도 정렬을 하면서 서브 리스트로 분할하고 마지막에도 정렬을 한다. 하지만, Merge Sort는 쪼개질 수 없을 때까지 나눈 후 이를 합칠 때 부터서야 조금씩 정렬하기 때문에 Quick Sort보다 느리다. [Object Array] 이 경우에는 조금 달라진다. 객체는 주소를 가지고 있고 엄연히 구분될 수 있기 때문에 구분할 필요가 있다. 따라서 이러한 Object Sorting은 Stable한 정렬 방법을 사용해야 한다. 특정 애플리케이션에서 값은 같은데 객체 자체가 다른 경우, 개발자가 생각한 것과 다른 결과물을 낼 수 있기 때문이다. Stable한 정렬 방법 중 빠른 편에 속하는 것이 Merge Sort이다. 결론 Primitive Type Array -&gt; Quick Sort Object Type Array -&gt; Merge Sort Quick Sort : Not Stable Merge Sort : Stable &lt;현재 기준&gt; 예전에는 3개의 알고리즘인 완전히 나뉘었지만, 지금은 Insertion Sort와 Merge Sort를 합친 Tim Sort라는 것을 사용하고 Quick Sort 역시 그냥 쓰는게 아니라 Dual-Pivot Quick Sort라는 것을 사용한다. Tim Sort는 Stable하므로 Object에 사용한다. Dual-Pivot Quick Sort는 Not Stable하므로 Primitive Type에 사용한다. 마지막으로 Quickt Sort는 최악의 경우 O(N^2)으로 O(N logN)을 보장하지 않지만, Merge Sort는 최악의 경우일지라도 O(N log N)을 보장한다. Reference [Java] 정렬 알고리즘","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Sorting","slug":"Sorting","permalink":"https://woovictory.github.io/tags/Sorting/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://woovictory.github.io/tags/Algorithm/"},{"name":"정렬 알고리즘","slug":"정렬-알고리즘","permalink":"https://woovictory.github.io/tags/정렬-알고리즘/"}]},{"title":"[Android] RecyclerView의 setHasFixedSize 이해","slug":"Android-RecyclerView-Attr","date":"2020-06-24T05:43:50.000Z","updated":"2020-06-24T08:15:30.289Z","comments":true,"path":"2020/06/24/Android-RecyclerView-Attr/","link":"","permalink":"https://woovictory.github.io/2020/06/24/Android-RecyclerView-Attr/","excerpt":"","text":"서론 RecyclerView는 앱에서 거의 필수적인 존재라고 생각이 든다. 대부분의 서비스가 리스트 형식이 존재하기 때문이다. 이렇듯 리스트를 효율적으로 보여주기 위해 사용하는 것이 RecyclerView이다. 그렇다면 우리가 자주 사용하는 setHasFixedSize를 true로 설정한다는 게 무엇을 의미할까?? 본론 필자는 setHasFixedSize = true의 문장을 별 의미 없이 타이핑했다. 이렇게 하는 것은 정말 좋지 않은 습관이다. 필자도 이 코드만 이렇게 했을 뿐, 다른 코드는 다 생각하고 작성한다. 아무튼, 저 함수는 무엇을 의미하는지 살펴보자. setHasFixedSize StackOverflow의 답변을 해석했다. 아래의 함수를 보자 1234void onItemsInsertedOrRemoved() &#123; if (hasFixedSize) layoutChildren(); else requestLayout();&#125; 기본적으로 아이템을 삽입, 이동 혹은 제거할 때마다 RecyclerView의 크기 및 너비나 높이가 변경될 수 있으며, 뷰 계층 구조의 다른 뷰의 크기가 변경될 수 있다. 따라서 항목을 자주 추가하거나 제거하는 경우, 특히 문제가 될 수 있다. 어댑터의 내용을 변경해도 높이나 너비가 변경되지 않는 경우, setHasFixedSize를 true로 설정하여 불필요한 레이아웃 패스를 피하라. 결국, 아이템 항목을 추가할 때마다 RecyclerView의 크기는 변경된다. 크기가 변경되기 때문에 레이아웃을 그릴 때, 크기를 측정하고 다시 그리는 것을 반복할 것이다. setHasFixedSize의 기능은 RecyclerView의 크기 변경이 일정하다는 것을 사용자의 입력으로 확인한다. 항목의 높이나 너비가 변경되지 않으며, 추가 또는 제거된 모든 항목은 동일하다. setHasFixedSize를 설정하지 않으면 항목의 크기가 변경되어 비용이 많이 드는 작업을 하는지 확인한다. 결론 대부분 RecyclerView를 사용하는 목적은 동일한 크기의 아이템 항목을 사용자에게 리스트로 보여주기 위해서다. 따라서 아이템의 크기가 변하는 경우는 없을 것이고, 그렇다면 setHasFixedSize를 true로 설정함으로써 변경되지 않는다는 것을 명시하는게 좋다. 따라서 레이아웃을 다시 그리는 비용이 많이 드는 작업을 피하도록 하여 성능 하락을 방지할 수 있다고 생각한다. Reference stack overflow 안드로이드 리사이클러뷰 사용법","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"},{"name":"hasFixedSize","slug":"hasFixedSize","permalink":"https://woovictory.github.io/tags/hasFixedSize/"}]},{"title":"[Android] Bottom Sheet","slug":"Android-BottomSheet","date":"2020-06-15T01:25:48.000Z","updated":"2020-06-25T01:54:22.144Z","comments":true,"path":"2020/06/15/Android-BottomSheet/","link":"","permalink":"https://woovictory.github.io/2020/06/15/Android-BottomSheet/","excerpt":"","text":"이번에 사용하게 된 Bottom Sheet에 대해 간단한 내용을 정리한다. Bottom Sheet Android Material Design 중 하나이다. 크게 3가지의 종류가 존재한다. standard bottom sheet 화면 하단에 보여주는 bottom sheet modal bottom sheet 다이얼로그 형태의 bottom sheet으로 화면 하단에 다이얼로그 형태로 보여준다. expading bottom sheet standard bottom sheet에서 더 나아가 일부 뷰를 미리 보여주며 스크롤을 통해 뷰를 확장할 수 있다. [Dependency] 먼저, material 의존성을 추가한다. 1234ext &#123; materialVersion = '1.3.0-alpha01'&#125;implementation “com.google.android.material:material:$materialVersion” [Implementation] Bottom Sheet의 역할을 할 레이아웃을 작성한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;variable name=\"vm\" type=\"app.woovictory.presentation.vm.FilterViewModel\" /&gt; &lt;/data&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorWhite\" android:clipToPadding=\"false\" android:padding=\"@dimen/padding_16\" app:layout_behavior=\"@string/bottom_sheet_behavior\"&gt; &lt;TextView android:id=\"@+id/titleFilter\" style=\"@style/Text.FilterTitleStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"100dp\" android:text=\"@string/title_filter\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;TextView android:id=\"@+id/titleAges\" style=\"@style/Text.DescriptionStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_16\" android:text=\"@string/title_ages\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/titleFilter\" /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/ageList\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_8\" app:layoutManager=\"com.google.android.flexbox.FlexboxLayoutManager\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/titleAges\" /&gt; &lt;TextView android:id=\"@+id/titleStyles\" style=\"@style/Text.DescriptionStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_16\" android:text=\"@string/title_styles\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/ageList\" /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/styleList\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_8\" app:layoutManager=\"com.google.android.flexbox.FlexboxLayoutManager\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/titleStyles\" /&gt; &lt;View android:id=\"@+id/divider\" android:layout_width=\"0dp\" android:layout_height=\"0.1dp\" android:layout_marginTop=\"@dimen/margin_16\" android:background=\"@color/colorGray\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/styleList\" /&gt; &lt;LinearLayout android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_8\" android:layout_marginBottom=\"@dimen/margin_8\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/divider\"&gt; &lt;TextView android:id=\"@+id/resetButton\" style=\"@style/Text.FilterTextStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_weight=\"2\" android:drawableStart=\"@drawable/img_undo\" android:drawablePadding=\"@dimen/margin_8\" android:gravity=\"center_vertical\" android:onClick=\"@&#123;() -&gt; vm.onClickReset()&#125;\" android:text=\"@string/action_undo\" /&gt; &lt;Button style=\"@style/Text.ButtonTextStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"3\" android:background=\"@drawable/bg_complete_button\" android:gravity=\"center\" android:onClick=\"@&#123;() -&gt; vm.onClickComplete()&#125;\" android:text=\"@string/action_complete\" android:textColor=\"@color/colorWhite\" /&gt; &lt;/LinearLayout&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/layout&gt; BottomSheedDialogFragment를 상속받아 Fragment를 만들고, 레이아웃을 연결한다. 12345678910class FilterFragment : BottomSheetDialogFragment() &#123; override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? &#123; binding = DataBindingUtil.inflate(inflater, R.layout.filter_bottom_sheet, container, false) return binding.root &#125;&#125; Activity에서 이벤트를 통해 Bottom Sheet을 보여주도록 코드를 작성하면 된다. 123456789101112131415class ShopActivity : BaseActivity&lt;ActivityShopBinding&gt;() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125; override fun onOptionsItemSelected(item: MenuItem): Boolean &#123; return when (item.itemId) &#123; R.id.action_filter -&gt; &#123; FilterFragment.newInstance().apply &#123; show(supportFragmentManager, this.tag) &#125; true &#125; else -&gt; super.onOptionsItemSelected(item) &#125; &#125;&#125; Reference Using BottomSheetDialogFragment with Material Design Guideline 정상에서 IT를 외치다","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Material Design","slug":"Material-Design","permalink":"https://woovictory.github.io/tags/Material-Design/"},{"name":"Bottom Sheet","slug":"Bottom-Sheet","permalink":"https://woovictory.github.io/tags/Bottom-Sheet/"}]},{"title":"[CleanCode] 2장. 의미있는 이름","slug":"CleanCode-2","date":"2020-06-14T10:31:36.000Z","updated":"2020-06-14T12:19:42.434Z","comments":true,"path":"2020/06/14/CleanCode-2/","link":"","permalink":"https://woovictory.github.io/2020/06/14/CleanCode-2/","excerpt":"","text":"이름은 많이 사용하므로 잘 지으면 여러모로 편하다. 의도를 분명히 밝혀라 의도가 분명하게 이름을 지어라. 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 많다. 그러므로 이름을 주의 깊게 살펴 더 나은 이름이 떠오르면 개선하기 바란다. 변수나 함수, 클래스 이름은 다음의 질문에 답해야 한다. 변수, 함수, 클래스의 존재 이유는? 수행 기능은? 사용 방법은? 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다. 123456int d; // 경과 시간(단위 : 날짜)// 아무 의미도 드러나지 않는다. 경과 시간이나 날짜라는 느낌이 안 든다.int daysSinceCreation;int fildAgeInDays;// 의도가 드러나는 이름을 사용한다. 그러므로 코드 이해와 변경이 쉬워진다. 이름만 고쳐도 함수가 하는 일, 코드의 의미를 이해하기 쉬워진다. 그릇된 정보를 피하라 프로그래머는 코드에 그릇된 단서를 남겨서는 안된다. 이는 코드 의미를 흐린다. 나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안된다. ex) hp, iax, sco는 변수 이름으로 적합하지 않다. 이유는 유닉스 플랫폼이나 유닉스 변종을 가리키는 이름이기 때문이다. 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 accountList라 명명하지 않는다. 계정을 담는 컨테이너가 실제 List가 아니라면 프로그래머에게 그릇된 정보를 제공하는 셈이다. 그러므로 accountGroup, bunchOfAccounts 아니면 Accounts라 명명한다. 서로 흡사한 이름을 사용하지 않도록 주의한다. 유사한 개념은 유사한 표기법을 사용한다. 이것도 정보다. 일관성이 떨어지는 표기법은 그릇된 정보다. 이름으로 그릇된 정보를 제공하는 끔찍한 예는 소문자 L이나 대문자 O 변수다. 절대 쓰지 말자! 의미있게 구분하라 동일한 범위 안에서 다른 두 개념에 같은 이름을 사용하지 못한다. 컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 불용어를 추가하는 것은 적절하지 못하다. 이름이 달라야 한다면 의도도 달라져야 한다. 연속적인 숫자를 덧붙인 이름(a1, a2, …, aN)은 의도적인 이름과 정반대다. 그릇된 정보를 제공하는 것이 아니라 아무런 정보도 제공하지 못하는 이름이다. 불용어를 추가한 이름 역시 아무런 정보도 제공하지 못한다. Product라는 클래스가 있고, 다른 클래스를 ProductInfo, ProductData라 부른다면 개념을 구분하지 않은 채 이름만 달리한 경우다. moneyAmount는 money와 구분이 안된다. 이처럼 읽는 사람이 차이를 알도록 이름을 지어라. 발음하기 쉬운 이름을 사용하라 사람들은 단어에 능숙하며, 우리 두뇌에서 상단 부분은 단어라는 개념만 전적으로 처리한다. 그리고 정의상으로 단어는 발음이 가능하다. 따라서 발음하기 쉬운 이름을 선택한다. 발음하기 어려운 이름은 토론하기도 어렵다. ex) genymdhms(generate date, year, month, day, hour, minute, second)라는 단어를 사용한 회사가 있다. 직원들은 &quot;젠 와이 엠 디 에이취 엠 에스&quot;라고 발음했고, 저자는 &quot;젠 야 무다 힘즈&quot;라고 발음했다. 우스꽝스러운 발음이지만, 농담처럼 주고받으니 재미있었다. 하지만, 형편은 없었다. 12345class DtaRcrd102&#123; private Date genymdhms; private Date modymdhms; private final String pszqint = \"102\";&#125; 12345class Customer&#123; private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = \"102\";&#125; 위의 두 코드를 보면 지적인 대화가 가능한 것은 두 번째 코드이다. 따라서 발음하기 쉬운 이름은 의사소통에 영향을 미친다. 검색하기 쉬운 이름을 사용하라 문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다음 문제점이 있다. 숫자 7은 찾기 까다롭다. 7이 들어가는 파일 이름이나 수식이 모두 검색되기 때문이다. 또한, 7을 사용한 의도가 다른 경우도 있다. e라는 문자도 변수 이름으로 적합하지 못하다. e는 영어에서 많이 쓰이며, 프로그램의 거의 모든 문장에 등장한다. 이런 관점에서 긴 이름이 짧은 이름보다 좋다. 검색하기 쉬운 이름이 상수보다 좋다. 123456789101112for(int j=0; j&lt; 32; j++)&#123; s += (t[j]*4) / 5;&#125;int realDaysPerIdealDay = 4;const int WORK_DAYS_PER_WEEK = 5;int sum = 0;for(int j=0; j&lt; NUMBER_OF_TASKS; j++)&#123; int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK) sum += realTaskWeeks&#125; 위 코드에서 sum이 유용하진 않으나 최소한 검색은 가능하다. 이름을 의미있게 지으면 함수가 길어진다. 하지만, WORK_DAYS_PER_WEEK를 찾기가 훨씬 쉽다. 인코딩을 피하라 유형이나 범위 정보까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다. 문제 해결에 집중하는 개발자에게 인코딩은 불필요한 정신적 부담이다. 헝가리식 표기법 모든 변수가 정수 핸들, long 포인터, void 포인터, (속성과 용도가 다른) 여러 ‘문자열’ 중 하나였다. 당시는 컴파일러가 타입을 점검하지 않았으므로 프로그래머에게 타입을 기억할 단서가 필요했다. 요즘은 IDE가 코드를 컴파일하지 않고도 타입 오류를 감지한다. 딸서 헝가리식 표기법이나 기타 인코딩 방식이 오히려 방해가 된다. 멤버 변수 접두어 멤버 변수에 m_이라는 접두어를 붙일 필요도 없다. 클래스나 함수는 접두어가 필요없을 정도로 작아야 마땅하다. 123456789101112131415public class Part&#123; private String m_dsc; // 설명 문자열 void setName(String name)&#123; m_dsc = name; &#125;&#125;--------- public class Part&#123; String description; void setDescription(String description)&#123; this.description = description; &#125;&#125; 인터페이스 클래스와 구현 클래스 인터페이스 이름은 접두어를 붙이지 않는 편이 좋다. 접두어 I는 주의를 흐트리고 나쁘게는 과도한 정보를 제공한다. 내가 다루는 클래스가 인터페이스라는 사실을 남에게 알리고 싶지 않다. 클래스 사용자는 그냥 ShapeFactory 라고만 생각하면 좋겠다. 그래서 인터페이스 클래스 이름과 구현 클래스 이름 중 하나를 인코딩 해야 한다면 구현 클래스 이름을 택하겠다. ShapeFactoryImpl나 심지어 CShapeFactory가 IShapeFactory보다 좋다. 자신의 기억력을 자랑하지 마라 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름을 바람직하지 못하다. 문자 하나만 사용하는 변수 이름은 문제가 있다. 루프에서 반복 횟수를 세는 i,j,k는 괜찮다.(l은 안된다!) 단, 루프 범위가 아주 작고 다른 이름과 충돌하지 않을 때만 괜찮다. (루프에서 반복 횟수 변수는 전통적으로 한글자를 사용한다.) 똑똑한 프로그래머는 기억력이 좋다. 전문가 프로그래머와의 차이점을 들자면, 전문가 프로그래머는 명료함이 최고라는 사실을 이해한다. 전문가 프로그래머는 자신의 능력을 좋은 방향으로 사용해 남들이 이해하는 코드를 내놓는다. 클래스 이름 클래스 이름과 객체 이름은 명사나 명사구가 적합하다. Customer, WikiPage, Account, AddressParser 등이 좋은 예다. Manager, Processor, Data, Info 등과 같은 단어는 피하고 동사는 사용하지 않는다. 메소드 이름 메소드 이름은 동사나 동사구가 적합하다. postPayment, deletePage, save 등이 좋은 예다. 접근자, 변경자, 조건자는 javabean 표준에 따라 앞에 get, set, is를 붙인다. 12345string name = employee.getName();customer.setName(\"Lee\");if(paycheck.isPosted())&#123; ...&#125; 생성자를 오버로딩할 때는 정적 팩토리 메소드를 사용한다. 메소드는 인수를 설명하는 이름을 사용한다. 123Complex flucrumPoint = Complex.FromRealNumber(23.0); // 1Complex flucrumPoint = new Complex(23.0); // 2 1번 코드가 2번보다 좋다. 생성자 사용을 제한하려면 해당 생성자를 private으로 선언한다. 기발한 이름은 피하라 재미난 이름보다 명료한 이름을 선택하라. 구어체나 속어를 사용하는 것도 피해야 한다. 예를 들어, kill() 대신 whack()를 사용한다거나, Abort() 대신 eatMyShort()라 부르는 것처럼 특정 문화에서만 사용하는 농담은 피하는 편이 좋다. 의도를 분명하고 솔직하게 표현하라. 한 개념에 한 단어를 사용하라 추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다. ex) 똑같은 메소드를 클래스마다 fetch, retrieve, get으로 제각각 부르면 혼란스럽다. 마찬가지로 동일 코드 기반에 controller, manager, driver를 섞어 쓰면 혼란스럽다. DeviceManager와 ProtocolController는 근본적으로 어떻게 다른가? 어째서 둘 다 Controller가 아닌가? 어째서 둘 다 Manager가 아닌가? 이름이 다르면 독자는 당연히 클래스도 다르고 타입도 다르다고 생각한다. 일관성 있는 어휘는 코드를 사용할 프로그래머가 반갑게 여길 선물이다. 말장난을 하지 마라 한 단어를 두 가지 목적으로 사용하지 마라. 다른 개념에 같은 단어를 사용한다면 그것은 말장난에 불과하다. 프로그래머는 코드를 최대한 이해하기 쉽게 짜야 한다. 집중적인 탐구가 필요한 코드가 아니라 대충 훑어봐도 이해할 코드 작성이 목표다. ex) 지금까지 구현한 add 메소드는 모두 기존 값 두개를 더하거나 이어서 새로운 값을 만든다고 가정하자. 새로 작성하는 메소드는 집합에 값 하나를 추가한다. 이 메소드를 add라 불러도 괜찮을까? add라는 메소드가 많으므로 일관성을 지키려면 add라 불러야 하지 않을까? 하지만 새 메소드는 기존 add 메소드와 맥락이 다르다 그러므로 insert나 append라는 이름이 적당하다. 새 메소드를 add라 부른다면 이는 말장난이다. 의미를 해독할 책임이 있는 독자에게 있는 논문 모델이 아니라 의도를 밝힐 책임이 있는 저자에게 있는 잡지 모델이 바람직하다. 해법 영역에서 가져온 이름을 사용하라 코드를 읽는 사람도 프로그래머다. 그러므로 전산 용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다. 모든 이름을 도메인에서 가져오는 정책은 현명하지 못하다. 같은 개념을 다른 이름으로 이해하던 동료들이 매번 고객에게 의미를 물어야 하기 때문이다. 기술 개념에는 기술 이름이 가장 적합한 선택이다. 문제 영역에서 가져온 이름을 사용하라 적절한 '프로그래머 용어’가 없다면 문제 영역에서 이름을 가져온다. 그러면 코드를 보수하는 프로그래머가 분야 전문가에게 의미를 물어 파악할 수 있다. 의미 있는 맥락을 추가하라 아래 메소드를 보자. 변수에 좀 더 의미 있는 맥락이 필요할까? 함수 이름은 맥락 일부만 제공하며, 알고리즘이 나머지 맥락을 제공한다. 함수를 끝까지 읽어보고 나서야 number, verb, pluralModifier라는 변수 세 개가 통계 추측 메시지에 사용된다는 사실이 드러난다. 이는 독자가 맥락을 유추해야만 한다. 그냥 메소드만 훑어서는 세 변수의 의미가 불분명하다. 12345678910111213141516171819202122Private void printGuessStatistics (char candidate, int count) &#123; String number; String verb; String pluralModifier; if (count == 0) &#123; number = \"no\"; verb = \"are\"; pluralModifier = \"s\"; &#125; else if (count ==1) &#123; number = \"1\"; verb = \"is\"; pluralModifier = \"\"; &#125; else &#123; number = Integer.toString(count); verb = \"are\"; pluralModifier = \"s\"; &#125; String guessMessage = String.format(\"There %s %s %s%s\", verb, number, candidate, pluralModifer); print(guessMessage);&#125; 위의 코드는 함수가 길며 세 변수를 함수 전반에서 사용한다. 함수를 작은 조각으로 쪼개고자 GuessStatisticsMessage라는 클래스를 만든 후, 세 변수를 클래스에 넣는다. 그러면 세 변수는 맥락이 분명해진다. 즉, 세 변수는 확실하게 GuessStatisticsMessage에 속한다. 이렇게 맥락을 개선하면 함수를 쪼개기가 쉬워진다. 1234567891011121314151617181920212223242526272829303132333435363738public class GuessStatisticsMessage&#123; private String number; private String verb; private String pluralModifier; public String maek(char candidate, int count)&#123; createPluralDependentMessageParts(count); return String.format(\"There %s %s %s%s\", verb, number, candidate, pluralModifier); &#125; private void createPluralDependentMessageParts(int count)&#123; if(count == 0)&#123; thereAreNoLetters(); &#125; else if(count == 1)&#123; thereIsOneLetter(); &#125; else &#123; thereAreManyLetters(count); &#125; &#125; private void thereAreNoLetters()&#123; number = \"no\"; verb = \"are\"; pluralModifier = \"s\"; &#125; private void thereIsOneLetter()&#123; number = \"1\"; verb = \"is\"; pluralModifier = \"\"; &#125; private void thereAreManyLetters(int count)&#123; number = Integer.toString(count); verb = \"are\"; pluralModifier = \"s\"; &#125;&#125; 불필요한 맥락을 없애라 일반적으로 짧은 이름이 긴 이름보다 좋다. 단, 의미가 분명한 경우에 한해서다. 이름에 불필요한 맥락을 추가하지 않도록 주의한다. accountAddress, customerAddress는 Address 클래스의 인스턴스로는 좋은 이름이나 클래스 이름으로는 적합하지 못하다. Address는 클래스 이름으로 적합하다. Reference Clean Code","categories":[{"name":"Book","slug":"Book","permalink":"https://woovictory.github.io/categories/Book/"},{"name":"CleanCode","slug":"Book/CleanCode","permalink":"https://woovictory.github.io/categories/Book/CleanCode/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://woovictory.github.io/tags/Clean-Code/"},{"name":"클린 코드","slug":"클린-코드","permalink":"https://woovictory.github.io/tags/클린-코드/"},{"name":"의미있는 이름","slug":"의미있는-이름","permalink":"https://woovictory.github.io/tags/의미있는-이름/"}]},{"title":"[Android] FlexBoxLayout","slug":"Android-FlexBoxLayout","date":"2020-06-13T12:28:29.000Z","updated":"2020-06-13T13:57:23.262Z","comments":true,"path":"2020/06/13/Android-FlexBoxLayout/","link":"","permalink":"https://woovictory.github.io/2020/06/13/Android-FlexBoxLayout/","excerpt":"","text":"최근에 만든 프로젝트에서 필터 화면을 만들어야 했다. 하지만, 어떻게 구현해야할지 난감하기도 했다. 실제 화면을 보여주기는 그렇고, 대략 아래와 같은 화면이다. 즉, 크기가 서로 다른 필터 아이템을 정해진 넓이에 따라 자동으로 행을 바꿔 배치하려고 하는 경우, 안드로이드에서는 기본 레이아웃으로는 구현이 불가능하다. 사진 출처 위의 사진과 같은 화면을 어떻게 구현할 수 있을지 먼저 생각해봤다. ContraintLayout? -&gt; 불가능 개수가 정해진 경우에는 자식 뷰들간의 제약 조건을 구성하여 배치가 쉽지만, 새로운 항목이 추가되거나 제거되는 동적인 환경에서는 사용하기 어렵다. 또한, 목록이 많아지는 경우 스크롤되지 않으며 자식 뷰의 크기가 줄어들어 적합하지 않다. RelativeLayout -&gt; 불가능 ContraintLayout과 동일한 구조적인 문제로 적합하지 않다. GridLayout -&gt; 불가능 RecyclerView를 사용하여 행에 표시될 기본 갯수를 지정해야 하기 때문에 자식 뷰의 넓이에 따라 행의 갯수를 가져야 하는 것과 동떨어지기 때문에 적합하지 않다. LinearLayout -&gt; 최선은 아니지만, 구현 가능 ScrollView와 조합하여 수동으로 구현할 수 있다. 부모 레이아웃의 넓이를 가져와 자식 뷰를 하나씩 추가하면서 행을 언제 바꿔야 할지 수동으로 구현할 수 있다. 이미 TagView 라이브러리가 존재한다. 여러 방법을 생각해보다가 FlexBoxLayout이라는 걸 알게 되었다. Github을 살펴보고 여러 자료를 참고한 결과, 사용하기 적절할 것 같았다. FlexBoxLayout 기본 개념은 웹에서 사용되던 CSS Flexible Box Layout Module을 안드로이드에 접목하여 개발한 라이브러리이다. 위의 4번에서 LinearLayout으로 구현하기 위해 사용한 중첩 구조를 완벽하게 피할 수 있으면서 원하는 구조를 만들 수 있다. 1. dependency 123dependencies &#123; implementation \"com.google.android:flexbox:2.0.1\"&#125; 2. usage FlexboxLayout을 정의하고, flexwrap 속성을 사용하면 ViewGroup 내의 자식 뷰들이 자동으로 다음 행으로 이동한다. GirdLayout의 행에 고정된 항목이 아닌 행 별로 다른 넓이를 가질 수 있도록 항목이 가변적일 수 있다. 123456789101112131415161718192021222324252627282930&lt;com.google.android.flexbox.FlexboxLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:flexWrap=\"wrap\" app:alignItems=\"stretch\" app:alignContent=\"stretch\" &gt; &lt;TextView android:id=\"@+id/textview1\" android:layout_width=\"120dp\" android:layout_height=\"80dp\" app:layout_flexBasisPercent=\"50%\" /&gt; &lt;TextView android:id=\"@+id/textview2\" android:layout_width=\"80dp\" android:layout_height=\"80dp\" app:layout_alignSelf=\"center\" /&gt; &lt;TextView android:id=\"@+id/textview3\" android:layout_width=\"160dp\" android:layout_height=\"80dp\" app:layout_alignSelf=\"flex_end\" /&gt;&lt;/com.google.android.flexbox.FlexboxLayout&gt; 또한, FlexboxLayout은 RecyclerView와 함께 사용하여 스크롤을 자동으로 처리할 수 있다. 화면에 모두 표시된다면 문제가 없지만, 아이템이 많아 스크롤되어야 한다면 ScrollView에서 FlexboxLayout을 구현하는 것보다 RecyclerView를 이용하는 것이 성능이나 메모리면에서 훨씬 더 많은 이점이 있다. FlexboxLayoutManager를 사용하면 된다. 123456789&lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/ageList\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"@dimen/margin_8\" app:layoutManager=\"com.google.android.flexbox.FlexboxLayoutManager\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/titleAges\" /&gt; 이 경우에는 flexWrap 속성을 xml에서 설정할 수 없으므로 코드 상에서 설정해야 한다. flexGlow : 이 속성은 LinearLayout의 weight와 같은 속성으로 동작한다. 각 행의 나머지 공간을 균등한 공간으로 채울 수 있다. 하지만, itemView에 margin을 추가해서 이를 대체할 수 있다.(필자는 그렇게 했다…ㅎ) -&gt; 이게 아닌 divider를 사용하는 방법도 있는데, 이는 Github을 참고하자! flexDirection : 총 4가지 속성으로 구성되어 있다. ROW : 아이템 항목이 배치되는 방향은 행(가로) 방향으로 배치된다.(왼쪽부터 시작한다.) 행을 다 채웠다면 자동으로 다음 행으로 바뀐다. ROW_REVERSE : 반대 방향으로 진행되며 행 방향으로 배치된다. COLUMN : 아이템 항목이 배치되는 방향은 열(세로) 방향으로 배치된다.(위쪽부터 시작한다.) 아래로 길어진다. COLUMN_REVERSE : 반대 방향으로 진행되면 열 방향으로 배치된다. 12345678910111213141516171819with(binding) &#123; styleList.run &#123; adapter = styleAdapter layoutManager = FlexboxLayoutManager(activity).apply &#123; flexWrap = FlexWrap.WRAP flexDirection = FlexDirection.ROW &#125; setHasFixedSize(true) &#125; ageList.run &#123; adapter = ageAdapter layoutManager = FlexboxLayoutManager(activity).apply &#123; flexWrap = FlexWrap.WRAP flexDirection = FlexDirection.ROW &#125; setHasFixedSize(true) &#125;&#125; 3. Supported attributes justifyContent : 설정된 방향에 따라 배치된 정렬 상태를 변경할 수 있으며, 왼쪽으로 정렬하거나 가운데 또는 뒤쪽으로 정렬할 수 있다. flexWrap : wrap으로 설정하면, 현재 라인에 충분한 공간이 없는 경우 다음 라인에 view를 배치한다. 반응형 레이아웃을 구성할 수 있다. landscape 모드로 전환했을 때, 레이아웃이 자동으로 landscape 모드에 맞게 변경된다. 만약, 같은 기능을 LinearLayout을 이용해 구성하려고 했다면 수많은 레이아웃 파일들이 필요했을 것이다. FlexboxLayout을 통해 필자가 원하는 기능을 구현할 수 있었다. 사용법도 어렵지 않고, Github에 잘 설명되어 있다. 간단하게 적용해봤지만, 조금 더 공부한다면 더 멋지게 활용할 수 있을 것 같다. 추가 사항은 Github을 참고하길 바란다! Thanks Google :-) Reference google/flexbox-layout [펌] FlexboxLayout 뜯어보기 Unboxing the FlexboxLayout. 안드로이드의 새로운 레이아웃 탐구서","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"FlexBoxLayout","slug":"FlexBoxLayout","permalink":"https://woovictory.github.io/tags/FlexBoxLayout/"}]},{"title":"[Android] Koin을 통한 Activity, Fragment의 ViewModel 공유","slug":"Android-Share-ViewModel","date":"2020-06-13T11:47:36.000Z","updated":"2020-06-13T12:22:58.195Z","comments":true,"path":"2020/06/13/Android-Share-ViewModel/","link":"","permalink":"https://woovictory.github.io/2020/06/13/Android-Share-ViewModel/","excerpt":"","text":"최근에 간단하게 개발하면서 Fragment -&gt; Activity로 값을 전달하는 경우가 있었다. Activity -&gt; Fragment 방향으로 데이터를 전달할 때는 Bundle 객체를 사용하여 값을 담아서 전달한다. 그렇다면 반대의 경우는 어떻게 전달할 수 있을까?? 1) Interface Use 가장 널리 사용되는 방법 중 하나일 것이다. 1. Interface 생성 - Interface를 생성하고 구현할 콜백을 정의한다. - 주로, Fragment 안에 생성한다. (밖에 생성해도 상관 없다.) 123interface OnFilterListenter&#123; fun setFilter(count: Int)&#125; 2. Activity에서 Interface 구현 - Activity에서 1번에서 생성한 인터페이스를 구현한다. - Fragment에서 count 값을 받아 total 변수에 저장한다. 1234567class ShopActivity : BaseActivity&lt;ActivityShopBinding&gt;(), OnFilterListenter &#123; private var total = 0 override fun setFilter(count: Int)&#123; total = count &#125;&#125; 3. Fragment 구현 - Activity는 우리가 만든 Interface를 구현했으므로, Fragment에서 접근할 수 있는 Context를 해당 Interface로 캐스팅하여 접근할 수 있다. - onAttach()에서 context에 접근할 수 있고, 이 리스너를 변수에 담아서 사용하면 된다. - 주의할 점은 detach 되는 시점에 null로 초기화하여 메모리 누수를 방지해야 한다. 1234567891011private var listener : OnFilterListenter? = nulloverride fun onAttach(context: Context) &#123; super.onAttach(context) if (context as OnFilterListenter) listener = context&#125;override fun onDetach() &#123; super.onDetach() listener = null&#125; 이제 이 리스너를 이요해서 Activity에서 구현한 메소드를 호출하여 Activity 쪽으로 데이터를 전달하게 된다. 2) ViewModel Use 필자는 MVVM 구조를 사용하고 있었고, bottomSheetDialogFragment를 이용하여 필터 설정을 구현했다. Activity와 필터 값을 공유할 필요가 있었고, 결국 필터 화면은 Activity의 일부로 판단했다. 따라서 Activity, Fragment의 ViewModel을 공유하는 것이 가장 적합한 방법으로 보였다. Koin을 사용해 의존성을 주입하고 ViewModel 또한 주입하고 있으므로 Koin을 사용하여 해결할 수 있었다. 상황 Activity의 ViewModel을 Fragment와 공유하여 사용한다. In Activity 1private val viewModel: ShopViewModel by viewModel() ShopViewModel은 Shop에 대한 정보 처리와 Filter 값을 관리한다. Activity에서 ViewModel을 주입받는다. In Fragment created from Activity 1private val shopViewModel: ShopViewModel by sharedViewModel() Fragment에서는 이 ViewModel을 공유하여 필터 값을 Activity와 공유한다. by viewModel이 아닌 by sharedViewModel을 사용함으로써 해당 뷰모델의 생성은 두번 되지 않고 Activity에서 생성한 뷰모델을 공유해서 사용한다. by viewModel을 통해 생성하면 새로운 ViewModel 객체가 생성된다. Reference Fragment에서 Activity로 데이터 전달하기 koin viewModel in activity, fragment koin 2.0 맛보기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Koin","slug":"Koin","permalink":"https://woovictory.github.io/tags/Koin/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://woovictory.github.io/tags/ViewModel/"}]},{"title":"[CleanCode] 1장. 깨끗한 코드","slug":"CleanCode-1","date":"2020-06-13T07:44:37.000Z","updated":"2020-06-13T09:21:26.186Z","comments":true,"path":"2020/06/13/CleanCode-1/","link":"","permalink":"https://woovictory.github.io/2020/06/13/CleanCode-1/","excerpt":"","text":"나쁜 코드 Killer App으로 대박난 회사가 머지 않아 실패했다. 원인은 나쁜 코드였다. 일정을 맞추기 위해 나쁜 코드들을 방치하고 '나중에 고쳐야지’라는 생각이었다. 물론, 다들 이런 생각을 할 것이고 그런 경험이 있을 것이다. 하지만, 나중은 절대 오지 않는다. - 르블랑의 법칙 난장판을 품는 데에 드는 비용 초기에는 빠른 속도로 진행되던 프로젝트가 1~2년 만에 달팽이처럼 느린 페이스로 진행되는 것을 볼 수 있다. 나쁜 코드로 짠 프로그램에 가해지는 변경사항은 어느것 하나 사소하지 않다. 나쁜 코드가 쌓일수록 그 팀의 생산성을 떨어지고 이윽고 0에 수렴한다. 관리팀은 인력을 추가한다. 하지만, 새 팀원들은 구조를 이해하지 못한다. 팀은 '새 인력을 투입했으므로 생산성이 늘겠지’라는 압박을 받는다. 결과, 나쁜 코드는 더 쌓인다. 장대한 재디자인 팀은 봉기하고 재디자인을 요구한다. 달갑지 않지만 관리팀 또한 개발팀의 생산성이 바닥임을 알고 있으므로 허가한다. 새로운 타이거 팀이 만들어지고, 기존 프로덕트의 스펙 + 새로운 기능을 맡게 된다. 기존의 팀원들은 기존 코드를 유지보수하게 된다. 두 팀은 오랫 동안 경쟁하게 된다. 타이거 팀인 기존의 프로젝트를 거의 따라잡을 즈음, 타이거 팀의 초기 멤버들은 대부분 새 멤버들로 교체되어 있다. 그리고 그들은 다시 재디자인을 요구한다… 깨끗한 코드는 효율적인 뿐 아니라 생존과 직결되는 문제다. 마음가짐 1시간이면 될 변경을 1주일이 넘도록 보고 있다던지, 한줄만 바꾸면 될 문제를 가지고 수백개의 모듈을 건드린다던지 하는 증상은 흔하다. 왜 좋은 코드는 그렇게도 빠르게 나쁜 코드로 바뀌는 것일까? 초기와 다른 스펙, 스케줄, 멍청한 매니저, 참을성 없는 고객, 쓸데없는 마케팅 인간들을 비난할 지도 모른다. 하지만 그건 우리 잘못이다. 대부분 매니저들은 우리 생각보다 더 진실을 원하고 있다. 그들 또한 좋은 코드를 원한다. 그와 동시에 스케줄 또한 지키고 싶어 한다. 그와 마찬가지로, 좋은 코드를 지키는 것 또한 우리의 몫이다. 태고의 난제 더러운 코드는 생산성을 저하시킨다. 그와 동시에 개발자들은 기한을 맞추기 위해 더러운 코드를 짠다. 하지만, 더러운 코드를 만들어서는 절대 기한을 맞추지 못한다. 빨리 가기 위한 단 하나의 방법은 &quot;최대한 깨끗한 코드를 항상 유지하는 것&quot;이다. 클린 코드의 미학이란? 클린코드란 예술작품과 같다. 어떤 코드가 클린코드인지 아닌지를 구분하는 것과 클린코드를 쓸 수 있는지는 다른 문제이다. 클린코드를 작성하려면 피를 토해가며 얻은 클린코드에 대한 감각을 사용해 무수하게 많은 작은 기술들을 적용해야 한다. 깨끗한 코드란? 비야네 스트롭스트룹 깨끗한 코드는 보기에 즐거운 코드다. 효율적인 코드여야 한다. 성능적인 측면 뿐 아니라 나쁜 코드는 나쁜 코드를 더 크게 만든다. 깨진 창문 이론 : 창문이 깨진 건물은 누구도 신경 쓰지 않는다. 사람들은 관심을 끊고, 창문이 더 깨져도 상관하지 않는다. 마침내 자발적으로 창문을 깨고, 방치하며, 쇠퇴하는 과정이 시작된다. 메모리 누수, 경쟁 상태, 일관성 없는 네이밍 등의 세세한 사항을 신경 써야 한다. 깨끗한 코드는 한 가지에 집중한다. 각 함수와 클래스, 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다. 그래디 부치 깨끗한 코드는 단순하고 직접적이다. 잘 쓴 문장처럼 읽힌다. 깨끗한 코드는 해결할 문제의 긴장을 명확히 드러내고 긴장을 쌓으며 클라이맥스에 이르렀다가 명백한 해법을 제시하며 긴장과 문제를 풀어야 한다. 명쾌한 추상화 : 코드는 추측이 아니라 사실에 기반해야 한다. 반드시 필요한 내용만 담아야 한다. 이를 통해 프로그래머가 단호하다는 느낌을 받게 해야 한다. Big 데이브 토마스 가독성이 중요하며, 다른 사람이 고치기 쉬워야 한다. 테스트 케이스가 없으면 깨끗한 코드가 아니다. 테스트 케이스가 있어야 한다. 코드는 작을 수록(간결할수록) 좋다.(Smaller is better) 코드는 문학적이어야 한다. 즉, 인간이 읽기 좋은 코드여야 한다. 마이클 페더스 주의 깊게 코드를 작성하라. 론 제프리스 중복을 없애야 한다. 클래스나 메소드는 한 가지 일만 수행해야 한다. 초반부터 간단한 추상화를 고려하여 개발을 빠르게 진행하라. 메소드나 변수의 이름 등으로 코드가 하는 일을 명시하라. 워드 커닝햄 읽고 고개를 끄덕이고 다음 주제로 넘어갈 수 있는 코드를 작성하라. 코드를 독해하느라 머리를 쥐어짤 필요가 없어야 한다. 언어를 탓하지 말자. 코드(언어)를 단순하게 보이도록 만드는 것은 프로그래머의 역할이다. 우리는 작가들이다 기존 프로젝트에 새로운 코드를 작성할 때, 코드를 읽는 시간 : 코드를 짜는 시간 비율은 10 : 1을 훌쩍 넘는다. 새 코드를 짜면서 끊임없이 기존 코드를 읽는다. 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다. 기존 코드를 일겅야 새 코드를 짜므로 읽기 쉽게 만들면 사실은 짜기도 쉬워진다. 쉽게 짜려면 읽기 쉽게 만들어라. 보이스카우트 규칙 잘 짠 코드가 전부는 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다. 적극적으로 코드의 퇴보를 막아야 한다. &quot;캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.&quot; 우리가 본 코드를 그 순간보다 조금만 개선한다면 코드는 더러워질 수가 없다. 변수 이름을 하나 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if문 하나를 정리하면 충분하다. Reference Clean Code Chapter 01 - 깨끗한 코드","categories":[{"name":"Book","slug":"Book","permalink":"https://woovictory.github.io/categories/Book/"},{"name":"CleanCode","slug":"Book/CleanCode","permalink":"https://woovictory.github.io/categories/Book/CleanCode/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"https://woovictory.github.io/tags/Clean-Code/"},{"name":"클린 코드","slug":"클린-코드","permalink":"https://woovictory.github.io/tags/클린-코드/"},{"name":"깨끗한 코드","slug":"깨끗한-코드","permalink":"https://woovictory.github.io/tags/깨끗한-코드/"}]},{"title":"[Android] Font 적용","slug":"Android-Font","date":"2020-06-12T06:57:33.000Z","updated":"2020-06-12T07:47:55.138Z","comments":true,"path":"2020/06/12/Android-Font/","link":"","permalink":"https://woovictory.github.io/2020/06/12/Android-Font/","excerpt":"","text":"안드로이드 스튜디오에서 기본으로 제공하는 폰트가 아닌 다른 폰트를 적용할 경우가 생긴다. 필자도 그랬다. 그래서 폰트 적용 방법을 소개하려고 한다. 1. font directory 생성 폰트 추가를 위해서는 디렉토리를 먼저 생성해야 한다. res/font 폴더를 만든다. 2. 원하는 font 넣기 적용하고 싶은 font 파일을 font 디렉토리 안에 넣는다. https://noonnu.cc/ 이 곳에서 무료로 이용할 수 있는 폰트를 다운받을 수 있다. 그러므로 필요한 폰트를 다운받도록 하자! 주의할 점은 font 파일 이름은 모두 소문자로 바꿔줘야 한다는 것이다. 3. 필요한 곳에 font 적용하기 우리가 원하는 곳에 font를 적용해보자. 보통 font를 적용한다고 하면 한 곳에만 적용하기 보다 통일성을 유지하면서 Title, Description 등에 폰트를 적용할 것이다. font 디렉토리 아래에 font resource file을 생성한다. 필자는 app_font.xml이다. (2번의 사진을 참고하면 된다.) 4. font resource file 구현 font resource file은 API 26 이상부터 지원하기 때문에 이보다 낮은 버전에서도 적용하기 위해 app namesapce를 사용한다. font : 사용할 글꼴 파일 위치 fontStyle : 해당 글꼴의 스타일 fontWeight : 글꼴의 굵기 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;font-family xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" tools:ignore=\"UnusedAttribute,ResourceCycle\"&gt; &lt;!--demi light--&gt; &lt;font android:font=\"@font/noto_sans_demi_light\" android:fontStyle=\"normal\" android:fontWeight=\"300\" app:font=\"@font/noto_sans_demi_light\" app:fontStyle=\"normal\" app:fontWeight=\"300\" /&gt; &lt;!--regular--&gt; &lt;font android:font=\"@font/noto_sans_regular\" android:fontStyle=\"normal\" android:fontWeight=\"500\" app:font=\"@font/noto_sans_regular\" app:fontStyle=\"normal\" app:fontWeight=\"500\" /&gt; &lt;!--medium--&gt; &lt;font android:font=\"@font/noto_sans_medium\" android:fontStyle=\"normal\" android:fontWeight=\"1000\" app:font=\"@font/noto_sans_medium\" app:fontStyle=\"normal\" app:fontWeight=\"1000\" /&gt;&lt;/font-family&gt; 5. style.xml에 custom font family 적용 여기서 폰트를 일괄 적용시키는 방법은 2가지다. 위젯의 기본테마를 상속받아서 해당 위젯을 사용하는 곳에서는 폰트를 무조건 사용하도록 한다. TextAppearance를 상속받은 스타일을 만들어 그 스타일을 적용하는 위젯만 폰트를 사용하도록 한다. 필자는 2번의 방식으로 적용했기 때문에 2번을 기준으로 설명하겠다. 123456789101112131415&lt;style name=\"Text.RankStyle\" parent=\"android:TextAppearance\"&gt; &lt;item name=\"android:textStyle\"&gt;normal&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;@dimen/text_size_14&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorGray&lt;/item&gt; &lt;item name=\"android:fontFamily\"&gt;@font/app_font&lt;/item&gt; &lt;item name=\"android:includeFontPadding\"&gt;false&lt;/item&gt; &lt;/style&gt;&lt;style name=\"Text.TitleStyle\" parent=\"android:TextAppearance\"&gt; &lt;item name=\"android:textStyle\"&gt;bold&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;@dimen/text_size_16&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorBlack&lt;/item&gt; &lt;item name=\"android:fontFamily\"&gt;@font/app_font&lt;/item&gt; &lt;item name=\"android:includeFontPadding\"&gt;false&lt;/item&gt; &lt;/style&gt; 위의 xml처럼 필요한 스타일을 정의하고, 그에 맞는 폰트를 지정해준다. textStyle을 normal, bold처럼 수정하여 원하는 글꼴을 사용할 수 있다. 6. 글꼴 적용 이제 원하는 TextView에서 정의된 style을 적용하여 글꼴을 적용할 수 있다. 12345678910&lt;TextView android:id=\"@+id/itemTextName\" style=\"@style/Text.TitleStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"@dimen/margin_16\" android:hint=\"@string/dummy_name\" android:text=\"@&#123;model.name&#125;\" app:layout_constraintStart_toEndOf=\"@id/itemImageShop\" app:layout_constraintTop_toTopOf=\"@id/itemImageShop\" /&gt; 예시 사진 로즈베이에 bold하면서 원하는 글꼴이 적용된 것을 볼 수 있다. Reference [Android] 어플리케이션 글꼴 변경하기 + 글꼴 일괄 적용 [Android] 안드로이드 - 커스텀 폰트(Custom Font) 적용하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Font 적용","slug":"Font-적용","permalink":"https://woovictory.github.io/tags/Font-적용/"},{"name":"폰트","slug":"폰트","permalink":"https://woovictory.github.io/tags/폰트/"}]},{"title":"[Android] Drawable, Drawable v24 차이점","slug":"Android-Drawable","date":"2020-06-12T06:05:04.000Z","updated":"2020-06-12T06:48:18.274Z","comments":true,"path":"2020/06/12/Android-Drawable/","link":"","permalink":"https://woovictory.github.io/2020/06/12/Android-Drawable/","excerpt":"","text":"drawable, drawable-v24의 차이점에 대해 간략하게 정리하려고 한다. 많은 내용은 없고, 단지 차이점을 기록한다. 차이점 drawable 비교적 오래된 Android version을 사용하는 기기에 호환하기 위한 폴더 API 24 누가 이전 버전의 기기를 호환한다. drawable-v24 비교적 최근에 나온 Android version을 사용하는 기기에 호환하기 위한 폴더 API 24 즉, 누가 버전 이상의 기기를 호환한다. 이렇게 나눠진 이유는 기기 호환성 및 Android version마다 다른 화면 밀도에 맞춰서 프로그램을 제공하기 위함이다. stack overflow 뭔가 내용이 부족하다. 그래서 조금 더 검색해서 찾아보니 스택 오버플로우에서 어떤 답변의 글을 링크하는 걸 볼 수 있었다. 질문 내용 이전에는 Android Studio에서 모든 Drawable 폴더가 'drawable-mdpi, drawable-hdpi 등’처럼 생성되었다. 새로운 버전에서는 drawable, drawable-v21을 제공하는 데 왜 그런걸까? 이에 대한 답변이 달렸고 해석하면서 봤는데, 잘 이해가 가지 않았다. 결국 SVG를 가져와서 PNG로 변환한 뒤, 다음 빌드 시퀀스 중에 자동으로 생성한 해상도별 폴더에 배치한다고 한다. API 21 이전의 모든 버전에 대해 이 작업을 수행한다고 한다. 다른 내용은 이해가 잘 가지 않아서 적지는 않았고, 링크만 첨부하겠다. 스택오버플로우 결국에는 drawable, drawable-v24 2개의 폴더로 나누었고, 이를 Android 내부에서 처리하여 자동으로 해상도별로 배치하는 것으로 이해가 된다. 따라서 개발자들이 여러 해상도의 이미지를 넣을 필요가 없어졌다는 것과 폴더가 2개이므로 관리가 쉬워졌다는 장점이 있는 것 같다. 참고하면 좋은 글 : 동해둘리 Reference drawable 과 drawable-v24 차이 stack overflow","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Drawable","slug":"Drawable","permalink":"https://woovictory.github.io/tags/Drawable/"}]},{"title":"[Android] String Resource 관리하기","slug":"Android-String-Resource","date":"2020-06-12T05:36:44.000Z","updated":"2020-06-12T05:58:23.915Z","comments":true,"path":"2020/06/12/Android-String-Resource/","link":"","permalink":"https://woovictory.github.io/2020/06/12/Android-String-Resource/","excerpt":"","text":"오랜만에 포스팅하는 것 같다. 공부하면서 블로그보다 깃헙에 정리하다보니 블로그가 소홀했던 것 같다. 내 자신을 반성해야지… 아무튼, 오늘은 가벼운 내용을 정리하려고 한다. [안드로이드에서 문자열을 관리하는 방법]이다. 이 방법이 정답은 아니며, 모든 곳에서 통용되고 있는 건지도 모르겠다. 다만, 이렇게 관리하는 개발자가 많다는 건 사실인 것 같다. String Resource 관리 사실, String을 관리하는 가장 쉬운 방법은 필요한 파일에서 정의해서 쓰는 것이다. 예를 들어, MainActivity에서 &quot;이름&quot;이라는 String이 필요하다면 해당 파일에서 정의하여 사용하면 된다. 그리고 xml에서 TextView에 text가 필요하다면 “text” 처럼 작성해도 된다. 하지만, 단기적으로 봤을 때는 이게 편하지만 장기적으로 보면 굉장히 불편한 작업이다. 화면이 많아지면서 &quot;이름&quot;이 필요한 곳이 많아질 수 있다. 그렇다면 필요한 파일마다 정의하는 건 번거로운 작업이다. 또한, 다국어 서비스를 지원한다면 더 번거로운 작업이 된다. 그렇다면 한 곳에서 관리하고 이를 사용하면 번거로운 작업을 벗어날 수 있을 것 같다는 생각이 든다. 역시나 안드로이드는 이러한 작업을 지원해준다. res/values 밑에 strings.xml 파일이 있다. 이 곳에 &quot;이름&quot;을 저장하고 필요한 곳에서 불러와 사용한다. Code 상에서는 context.getString(R.string.XXX)와 같은 방식으로 접근한다. XML에서는 @string/name과 같은 방식으로 접근한다. 이를 통해 문자열을 한 곳에서 관리할 수 있게 된다. 따라서 번거로움이 줄어들고 문자열 관리의 통일성을 유지할 수 있게 되었다. 또한, 다국어 서비스를 지원할 때도 이전보다 번거로움이 줄어들었다는 장점이 존재한다. 추가적으로 string-array도 정의할 수 있어 로컬에서 필요한 문자열 배열이 있고, 이 배열의 값이 추가되거나 수정될 수 있으며 관리의 통일성을 유지하고 싶다면 strings.xml 파일에 저장하여 사용하는 것이 좋다고 생각한다. 이 방법이 강제되는 방법은 아니지만, 개발하면서 효율성을 조금은 향상시켜 줄 것이라고 생각한다. 이렇게 관리하지 않았다면 이 글을 보고 앞으로 효율적인 문자열 관리를 하기 바라고, 이런 방식으로 관리했다면 멋지다고 말하고 싶다. Reference Developers","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"String Resource","slug":"String-Resource","permalink":"https://woovictory.github.io/tags/String-Resource/"}]},{"title":"[자료구조] 우선순위 큐(Priority Queue)","slug":"PriorityQueue","date":"2020-05-12T15:28:24.000Z","updated":"2020-05-12T15:29:42.548Z","comments":true,"path":"2020/05/13/PriorityQueue/","link":"","permalink":"https://woovictory.github.io/2020/05/13/PriorityQueue/","excerpt":"","text":"우선순위 큐(Priority Queue) 일반적인 큐는 먼저 들어간 데이터가 먼저 나오는 구조이다. 이런 큐의 특성과 달리 우선순위 큐(Priority Queue)는 들어간 순서에 상관없이 일정한 규칙에 따라 우선순위를 선정하고 우선순위가 가장 높은 데이터가 가장 먼저 나오게 된다. 대표적인 예로는 병원의 응급 환자를 생각할 수 있으며, 은행의 업무를 기다리는 상황과 달리 위급한 우선순위에 따라 먼저 처리된다. 사용하기 우선순위 큐도 Java에서 내부적으로 구현되어 있어 사용이 용이하다. 큐와 동일하게 add(), peek(), poll() 등의 메소드를 사용할 수 있다. [Code] 12345678910 public class Sample &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); pq.add(4); pq.add(19); pq.add(2); pq.add(1); System.out.println(pq.poll()); // 1이 출력된다. &#125;&#125; add() 대신 offer() 메소드를 사용해도 동일한 결과를 얻는다. 우선순위 변경하기 우선순위를 정하는 기준은 Java의 정렬 기준과 동일하다. Java는 기본적으로 낮은 숫자부터 큰 숫자까지 오름차순으로 정렬하게 되는데, 만약 다른 오름차순으로 정렬하고 싶다면 Comparator 클래스나 Comparable 인터페이스를 이용해야 한다. Ex) 객체의 어떤 값에 따라 우선순위를 정해 정렬해야 할때, 오름차순이 아닌 내림차순 정렬을 할때 등등 Integer는 Collections.reverseOrder()를 사용해 내림차순 정렬을 할 수 있다. [Code] 1234567891011public class Sample &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); pq.add(4); pq.add(19); pq.add(2); pq.add(1); System.out.println(pq.poll()); // 19가 출력된다. &#125;&#125; 우선순위 큐 예제 고양시에서 강남까지 가는 방법이 있다고 하자. 대중교통, 자가용, 도보, 자전거 총 4가지의 방법이 존재한다. 대중 교통 : 1시간 10분 자가용 : 45분 도보 : 6시간 40분 자전거 : 2시간 5분 시간이 제일 적게 걸리는 순서로 정렬하면 -&gt; 자가용, 대중교통, 자전거, 도보 순이다. 우선순위 큐에 저장한 뒤, 데이터를 추출하면 위의 순서대로 추출된다. 하지만, 큐는 들어간 순으로 나온다. [Code] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package programmers;import java.util.PriorityQueue;/** * created by victory_woo on 2020/05/12 */public class Sample &#123; public static void main(String[] args) &#123; PriorityQueue&lt;Vehicle&gt; pq = new PriorityQueue&lt;&gt;(); pq.add(new Vehicle(\"대중교통\", 70)); pq.add(new Vehicle(\"자가용\", 45)); pq.add(new Vehicle(\"오토바이\", 45)); pq.add(new Vehicle(\"도보\", 400)); pq.add(new Vehicle(\"자전거\", 125)); while (!pq.isEmpty()) &#123; System.out.println(pq.poll()); &#125; &#125; static class Vehicle implements Comparable&lt;Vehicle&gt; &#123; private String name; private int time; Vehicle(String name, int time) &#123; this.name = name; this.time = time; &#125; public String getName() &#123; return name; &#125; public int getTime() &#123; return time; &#125; @Override public String toString() &#123; return \"Vehicle&#123;\" + \"name='\" + name + '\\'' + \", time=\" + time + '&#125;'; &#125; @Override public int compareTo(Vehicle that) &#123; if (this.time == that.time) return this.name.compareTo(that.name); return this.time - that.time; &#125; &#125;&#125;// 결과Vehicle&#123;name='오토바이', time=45&#125;Vehicle&#123;name='자가용', time=45&#125;Vehicle&#123;name='대중교통', time=70&#125;Vehicle&#123;name='자전거', time=125&#125;Vehicle&#123;name='도보', time=400&#125; Vehicle 클래스를 만들었다. 그리고 자바에서 PriorityQueue를 사용하기 위해서는(객체인 경우) 우선순위 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현해야 한다. compareTo 메소드를 오버라이드 하여 우선순위 조건을 설정하면 PriorityQueue가 우선순위가 높은 객체를 추출하게 된다. 시간이 작은 순서로 정렬해야 하기 때문에 오름차순 정렬을 한다. 다만, 시간이 같은 경우에는 이름의 사전순 정렬을 한다.(오름차순) name이 String이기 때문에 this.name.compareTo(that.name) 을 활용한다. Int 형인 time 간의 연산에서 Integer.compareTo() 를 사용하지 않은 이유는 Integer와 int의 size가 메모리 차이 때문이다. int의 size가 훨씬 작아 연산시 적은 메모리를 사용한다는 점에서 서로의 값을 뺄셈하여 계산했다. 관련 내용은 해당 Repository에 있으니 확인하면 좋을 것 같다. 참고 우선순위 큐 - Java에서 다루기 자바로 정리한 우선순위큐(PriorityQueue)","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"우선순위 큐","slug":"우선순위-큐","permalink":"https://woovictory.github.io/tags/우선순위-큐/"},{"name":"Priority Queue","slug":"Priority-Queue","permalink":"https://woovictory.github.io/tags/Priority-Queue/"}]},{"title":"[Java] 트라이(Trie) 자료구조 구현","slug":"Java-Trie-Implement","date":"2020-04-22T07:46:14.000Z","updated":"2020-04-22T15:01:50.234Z","comments":true,"path":"2020/04/22/Java-Trie-Implement/","link":"","permalink":"https://woovictory.github.io/2020/04/22/Java-Trie-Implement/","excerpt":"","text":"구현 과정에서 람다를 사용하므로 Java 8을 베이스로 진행한다. 자바에서 Trie 구현하기 클래스 생성 자바로 Trie 자료구조를 구현하기 위해서는 자료구조인 Trie와 이를 구성할 TrieNode 클래스가 각각 필요하다. 먼저, TrieNode 클래스부터 보도록 하자. TrieNode.java TrieNode는 자식 노드맵과 현재 노드가 마지막 글자인지 여부에 대한 정보를 가지고 있다. 여기에서 마지막 글자 여부란 'DEV’라는 단어에서 [D], [E]는 마지막 글자가 아니지만 [V]는 마지막 글자로, 한 단어가 완성되는 시점임을 알 수 있도록 하는 boolean 값이다. 123456789101112import java.util.HashMap;import java.util.Map;/** * created by victory_woo on 2020/04/22 */public class TrieNode &#123; // 자식 노드맵. private Map&lt;Character, TrieNode&gt; childeNodes = new HashMap&lt;&gt;(); // 마지막 글자인지 여부. private boolean isLastChar;&#125; 이렇게 두 변수가 할당되었으면 이 변수에 접근할 수 있는 getter/setter를 구현한다. 자식 노드는 Trie 차원에서 생성해서 넣을 것이기 때문에 getter만 생성해준다. 마지막 글자 여부는 추후 노드 삭제하는 과정에서 변경이 필요하기 때문에 getter/setter를 둘 다 생성해준다. 12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;/** * created by victory_woo on 2020/04/22 */public class TrieNode &#123; // 자식 노드맵. private Map&lt;Character, TrieNode&gt; childeNodes = new HashMap&lt;&gt;(); // 마지막 글자인지 여부. private boolean isLastChar; public Map&lt;Character, TrieNode&gt; getChildeNodes() &#123; return childeNodes; &#125; public boolean isLastChar() &#123; return this.isLastChar; &#125; public void setLastChar(boolean isLastChar) &#123; this.isLastChar = isLastChar; &#125;&#125; Trie.java Trie는 기본적으로 빈 문자열을 가지는 루트 노드만 가지고 있다. 이후에 나올 insert() 메소드를 통해 단어를 넣음으로써 그에 맞게 자식 노드가 생성된다. 우선, Trie가 생성되면 rootNode가 생성될 수 있도록 생성자를 통해 rootNode를 초기화해준다. 1234567891011/** * created by victory_woo on 2020/04/22 */public class Trie &#123; // 루트 노드. private TrieNode rootNode; Trie() &#123; rootNode = new TrieNode(); &#125;&#125; 메소드 구현 이제 본격적으로 Trie 자료구조에 단어 정보를 저장(insert)하고, 해당 단어가 존재하는지 확인(contains)하고, Trie에서 특정 단어를 삭제(delete)하는 세 가지 메소드를 만들어보자. 1. insert 입력받은 단어의 각 알파벳을 계층 구조의 자식 노드로 만들어 넣는다. 이떄, 이미 같은 알파벳이 존재하면 공통 접두어 부분까지는 생성하지 않는다. 즉, 해당 계층 문자의 자식노드가 존재하지 않을 때에만 자식 노드를 생성해준다.(여기서 람다식 사용) 예를 들면, 이미 'DEV’가 들어있는 Trie에 'DEAR’를 넣을 때, 'DE-'는 중복이므로 ‘D-E-’ 노드 아래 'A-R’만 추가로 자식 노드를 생성해주는 것이다. 그리고 마지막 글자에서는 여기까지를 끝으로 하는 단어가 존재한다는 표시를 위해 setLastCahr(true) 해준다. 123456789101112// 자식 노드 추가.void insert(String word) &#123; TrieNode thisNode = this.rootNode; // word 문자열의 각 단어를 확인한다. // thisNode 가 word 문자열의 각 단어를 key 로 하는 자식 노드가 존재하지 않을 때만 자식 노드를 생성해준다. for (int i = 0; i &lt; word.length(); i++) &#123; thisNode = thisNode.getChildNodes().computeIfAbsent(word.charAt(i), c -&gt; new TrieNode()); &#125; thisNode.setLastChar(true);&#125; 2. contains 특정 단어가 Trie에 존재하는지를 확인하기 위해서는 다음 두 가지 조건을 만족시켜야 한다. 루트 노드부터 순서대로 알파벳이 일치하는 자식 노드들이 존재할 것! 해당 단어의 마지막 글자에 해당하는 노드의 isLastChar가 true일 것! (해당 글자를 마지막으로 하는 단어가 있다는 뜻) 여기서 두 번째 조건에 유념해야 한다. 예를 들어, Trie에는 'POW’와 'PIE’라는 단어만 등록되어 있는데, 'PI’라는 단어를 검색한다고 가정해보자. 'PI’는 'PIE’와 'PI-'가 일치하기 때문에 1번 조건에는 부합(PI가 PIE에 포함되는 단어)하지만, insert 메소드에서 'PIE’의 '-E’에만 setIsLastChar(true) 했기 때문에 2번 조건에는 부합하지 않아 Trie에 없는 단어임을 확인할 수 있게 된다. 123456789101112131415161718192021// 특정 단어가 들어있는지 확인.boolean contains(String word) &#123; TrieNode thisNode = this.rootNode; for (int i = 0; i &lt; word.length(); i++) &#123; char character = word.charAt(i); // TrieNode 가 가지고 있는 자식 노드 중에서 해당 문자를 가진 노드를 가져온다. TrieNode node = thisNode.getChildNodes().get(character); // rootNode 의 자식 노드 중 해당 문자를 가진 노드가 없다면 null 이므로 false 를 반환한다. // 즉, word 라는 문자가 없음을 뜻한다. if (node == null) &#123; return false; &#125; // 문자가 존재하면 문자열의 모든 단어가 trie 에 존재하는지 확인하기 위해서 // thisNode 를 자식 노드로 바꾸면서 반복한다. thisNode = node; &#125; return thisNode.isLastChar();&#125; 3. delete 마지막으로 Trie에 넣었던 단어를 삭제하는 과정이다. contains 메소드처럼 주어진 단어를 찾아 하위 노드로 단어 길이만큼 내려간다. 주의할 점은 노드들이 부모노드의 정보를 가지고 있지 않기 때문에, 하위 노드로 내려가며 삭제 대상 단어를 탐색하고 다시 올라오며 삭제하는 과정이 콜백(Callback) 형식으로 구현되어야 한다는 점이다. 탐색 진행방향 : 부모 노드 -&gt; 자식 노드 삭제 진행방향 : 자식 노드 -&gt; 부모 노드 삭제 진행은 마지막 글자에서 부모 노드 방향으로 되돌아 오는 과정에서 진행된다는 점에 유이하여 다음 삭제 조건을 살펴보자. 자식 노드를 가지고 있지 않아야 한다. 위 그림에서 'PI’를 지워버리면 'PIE’까지 삭제되어 버리기 때문이다. 삭제를 시작하는 첫 노드는 isLastChar == true이어야 한다. false인 경우는 Trie에 없는 단어란 뜻이기 때문이다. 예를 들어, 위 그림에서 'PO’라는 글자를 지우라고 명령을 내려도 Trie가 가지고 있지 않은 단어라는 점이다. 삭제를 진행하던 중에는 isLastChar == false이어야 한다. 삭제 과정 중에서 isLastChar가 true라는 것은 또다른 단어가 있다는 의미이므로 삭제 대상이 아니다. 'PIE’를 삭제 대상으로 했을 때, '-E’를 삭제 후 'PI’라는 단어의 'I’가 isLastChar==true이므로 또다른 단어가 있음을 알려준다. 3번이 의미하는 바는 이해가 잘 안갔지만, 이해가 되었다. 삭제 과정 중에 isLastChar가 true라는 것은 또 다른 단어가 있다는 의미이므로 삭제 대상이 아니다. 'PIE’를 삭제 대상으로 했을 때, '-E’를 삭제 후, 'PI’라는 단어의 'I’가 isLastChar == true이면 'PI’라는 단어가 있음을 뜻한다. 참고로, 삭제 대상 단어의 마지막 글자가 isLastChar false이거나 해당하는 마지막 글자가 없는 경우는 new Error를 던지도록 구현했습니다. 참고 [자료구조] Trie(트라이)-2 : 자바로 구현하기","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"},{"name":"트라이","slug":"트라이","permalink":"https://woovictory.github.io/tags/트라이/"},{"name":"Trie","slug":"Trie","permalink":"https://woovictory.github.io/tags/Trie/"}]},{"title":"[Java] 트라이(Trie) 자료구조 개념","slug":"Java-Trie","date":"2020-04-22T07:27:46.000Z","updated":"2020-04-22T07:44:36.902Z","comments":true,"path":"2020/04/22/Java-Trie/","link":"","permalink":"https://woovictory.github.io/2020/04/22/Java-Trie/","excerpt":"","text":"Trie 자료구조란? 일반 트리 자료구조 중 하나로, Digital Tree, Radix Tree, Prefix Tree라고도 불린다. 텍스트 자동 완성 기능과 같이 문자열을 저장하고 탐색하는데 유용한 자료구조이다. Trie 자료구조의 형태는? 각 노드는 &lt;Key, Value&gt; 맵을 가지고 있다. Key는 하나의 알파벳이 되고, Value는 그 Key에 해당하는 자식 노드가 된다. 다음은 DEV, DEAR, PIE, POP, POW라는 단어가 들어있는 Trie 자료구조를 도식화한 것이다. 휴대폰 전화번호부에서 검색을 하거나 사전에서 단어를 찾는 것과 같다. 예를 들어, 아래 그림에서 'DEV’라는 문자열을 찾으려면 루트 노드에서부터 순차적으로 [D] -&gt; [E] -&gt; [V] 를 탐색한다. 그림에서 볼 수 있듯이 루트 노드는 특정 문자를 의미하지 않고, 자식 노드만 가지고 있다. 유의할 점은 '부모 노드’나 '자신이 어떤 알파벳(Key)에 해당하는 노드(Value)'인지를 가지고 있는게 아니라는 점입니다. 즉, 루트 노드는 [D], [P]라고 하는 알파벳을 Key로 하는 자식 노드들을 가지고 있고, [D]는 [E]를 Key로 하는 자식 노드, [P]는 [I]와 [O]를 Key로 하는 자식 노드들을 가지고 있는 것이다. 또 루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다는 특징이 있다. 즉, ‘DE’ 노드의 자손인 'DEAR’와 'DEV’는 'DE-'를 공통 접두어로 가지며, 'P’의 자손인 'POW’와 'PIE’는 'P-'를 공통 접두어로 가진다. Trie 자료구조의 특징 정렬된 트리 구조이다.(데이터에 따라 이진트리일 때도 있다.) Trie는 자식 노드를 Map&lt;Key, Value&gt; 형태로 가지고 있다. 루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다. 루트 노드는 빈 문자와 연관있다.(특정 문자가 할당되어 있지 않다.) 참고 [자료구조] Trie(트라이)-1 : 기초 개념","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"},{"name":"트라이","slug":"트라이","permalink":"https://woovictory.github.io/tags/트라이/"},{"name":"Trie","slug":"Trie","permalink":"https://woovictory.github.io/tags/Trie/"}]},{"title":"[Java] 얕은 복사와 깊은 복사","slug":"Java-Array-Copy","date":"2020-04-22T00:27:35.000Z","updated":"2020-04-22T01:54:10.210Z","comments":true,"path":"2020/04/22/Java-Array-Copy/","link":"","permalink":"https://woovictory.github.io/2020/04/22/Java-Array-Copy/","excerpt":"","text":"배열의 복사와 관련해서는 얕은 복사와 깊은 복사의 차이점을 알아야 한다. 얕은 복사(shallow copy) 한 쪽에서 수정이 발생되면 다른쪽에도 영향을 끼쳐 같아지게 된다. 가능한 이유는 얕은 복사가 주소값을 복사하기 때문에 주소로 값을 참조하여 값이 변경되면 해당 값을 참조하고 있는 배열들의 값이 변경된다. 즉, 복사된 배열이나 원본 배열이 변경될 때, 함께 변경된다. = 연산자는 얕은 복사를 수행한다. 12345678910111213int[] a = new int[2];a[0] = 2;a[1] = 4;int[] b = a;b[0] = 6;b[1] = 8;System.out.println(a[0]+\", \"+a[1]);System.out.println(b[0]+\", \"+b[1]);// 결과6, 86, 8 위의 코드처럼 1차원 배열을 = 연산자를 사용해 얕은 복사를 진행하게 되면 복사된 배열의 값이 변경될 때, 원본 배열의 값도 변경된다. 2차원 배열도 마찬가지이다. 다음 코드를 보자. 123456789101112131415161718192021int[][] a = new int[2][2];int[][] copy = a;copy[0][0] = 1;for (int[] aa : a) &#123; for (int v : aa) System.out.print(v + \" \"); System.out.println();&#125;System.out.println();for (int[] aa : copy) &#123; for (int v : aa) System.out.print(v + \" \"); System.out.println();&#125;// 결과1 00 01 00 0 = 연산자를 이용해 2차원 배열에서 얕은 복사가 이뤄졌다. 그렇다면 이러한 문제를 어떻게 해결할 수 있을까? 깊은 복사를 사용하자! 깊은 복사(Deep copy) 깊은 복사는 주소값을 참조하는 것이 아닌, 새로운 메모리 공간에 값을 복사하는 것이기 때문에 원본 배열이 변경되어도 복사된 배열에 전혀 상관이 없다. 따라서 배열을 복사한 후에 한쪽 값을 수정해도 다른 배열에 영향을 끼치지 않는다. 1) 1차원 배열의 깊은 복사 1차원 배열의 깊은 복사는 배열.clone() 함수를 이용하면 간단하게 할 수 있다.(일반 자료형의 경우) 혹은 간단하게 for문을 돌며 넣어줘도 된다. 1234567891011121314151617181920212223public static void main(String[] args) &#123; int[] arr = new int[10]; int[] copy = deepCopyWithClone(arr); for (int i = 0; i &lt; arr.length; i++) arr[i] = i; for (int a : arr) System.out.print(a + \" \"); System.out.println(); copy[0] = 100; for (int a : copy) System.out.print(a + \" \");&#125;private static int[] deepCopyWithClone(int[] original) &#123; if (original == null) return null; int[] result = new int[original.length]; result = original.clone(); return result;&#125;// 결과0 1 2 3 4 5 6 7 8 9 -&gt; arr100 0 0 0 0 0 0 0 0 0 -&gt; copy 주의 객체 배열의 경우, .clone()을 사용하면 깊은 복사가 안된다. 이유는 객체는 주소값을 가지고 있기 때문이다. 마찬가지로 2차원 배열의 경우도 각각 row에 대한 주소값을 가지고 있기 때문에 deepCopy가 안된다. 2) 1차원 객체 배열의 경우, 깊은 복사 1234567891011121314151617181920212223242526272829private static void ObjectArray() &#123; Position[] pos = new Position[10]; for (int i = 0; i &lt; pos.length; i++) pos[i] = new Position(i, i); Position[] copy = deepCopy(pos); copy[0].a = 100; copy[0].b = 200; for (int i = 0; i &lt; pos.length; i++) &#123; System.out.print(\"(\" + pos[i].a + \", \" + pos[i].b + \")\"); &#125; System.out.println(); for (int i = 0; i &lt; copy.length; i++) &#123; System.out.print(\"(\" + copy[i].a + \", \" + copy[i].b + \")\"); &#125;&#125;private static Position[] deepCopy(Position[] original) &#123; if (original == null) return null; Position[] result = new Position[original.length]; for (int i = 0; i &lt; result.length; i++) result[i] = new Position(original[i].a, original[i].b); return result;&#125;// 결과(0, 0)(1, 1)(2, 2)(3, 3)(4, 4)(5, 5)(6, 6)(7, 7)(8, 8)(9, 9)(100, 200)(1, 1)(2, 2)(3, 3)(4, 4)(5, 5)(6, 6)(7, 7)(8, 8)(9, 9) 이처럼 1차원 객체 배열을 복사하기 위해서는 for문을 돌며 넣어주는데 이때마다 새로운 객체를 new로 생성하며 직접 값을 넣어주어야 한다. 그래야 다른 새로운 객체를 담은 배열로 복사된 배열을 가질 수 있다. 3) 2차원 배열의 깊은 복사 이중 for문을 순회하는 방법 기본 자료형인 경우, 간단하게 사용할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private static void TwoArrayDeepCopy() &#123; int[][] arr = new int[5][5]; int[][] copy = deepCopyTwoArray(arr); arr[0][0] = 1; copy[0][1] = 2; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println(); for (int i = 0; i &lt; copy.length; i++) &#123; for (int j = 0; j &lt; copy.length; j++) &#123; System.out.print(copy[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println();&#125;private static int[][] deepCopyTwoArray(int[][] original) &#123; if (original == null) return null; int[][] result = new int[original.length][original.length]; for (int i = 0; i &lt; result.length; i++) &#123; for (int j = 0; j &lt; result.length; j++) &#123; result[i][j] = original[i][j]; &#125; &#125; return result;&#125;// 결과// arr1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 // copy0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 이처럼 값을 직접 넣어줘도 deepCopy가 잘된다. 배열을 복사한 이후, 복사한 배열의 값을 변경해도 원래 배열에 영향을 끼치지 않는 깊은 복사가 잘 이루어졌다. System.arraycopy를 이용하는 방법 기본 자료형인 경우, 아래 코드처럼 System.arraycopy 메소드를 이용해 2차원 배열을 복사할 수 있다. 1차원 배열을 2차원 배열의 row 길이만큼 복사한다고 생각하면 된다. 1번에서 사용한 배열과 같은 배열을 사용했다. 1234567891011121314151617181920private static int[][] deepCopyUseSystemArrayCopy(int[][] original) &#123; if (original == null) return null; int[][] result = new int[original.length][original.length]; for (int i = 0; i &lt; result.length; i++) &#123; System.arraycopy(original[0], 0, result[0], 0, original[0].length); &#125; return result;&#125;// 결과1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1번과 동일한 결과를 보이며, deepCopy가 이루어졌음을 확인할 수 있다. 4) 2차원 객체 배열의 복사 2차원 객체 배열의 복사를 할 경우, arraycopy나 clone을 이용해서 복사할 수 없다. 그래서 for문을 돌면서 값을 직접 복사하며, 객체를 새로 생성해야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public static void main(String[] args) &#123; Position[][] positions = new Position[3][3]; for (int i = 0; i &lt; positions.length; i++) &#123; for (int j = 0; j &lt; positions[i].length; j++) &#123; positions[i][j] = new Position(i, j); &#125; &#125; Position[][] copy = deepCopy(positions); copy[0][0].a = 100; copy[0][1].b = 200; positions[0][0].a = 2; positions[0][0].b = 2; print(positions); print(copy);&#125;public static void print(Position[][] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[0].length; j++) &#123; Position pos = arr[i][j]; System.out.print(\"(\" + pos.a + \", \" + pos.b + \") \"); &#125; System.out.println(); &#125; System.out.println();&#125;// for문을 돌면서 값을 직접 복사하며 객체를 새로 생성한다.private static Position[][] deepCopy(Position[][] original) &#123; if (original == null) return null; Position[][] result = new Position[original.length][original.length]; for (int i = 0; i &lt; result.length; i++) &#123; for (int j = 0; j &lt; result[i].length; j++) &#123; result[i][j] = new Position(original[i][j]); &#125; &#125; return result;&#125;static class Position &#123; int a; int b; Position(int a, int b) &#123; this.a = a; this.b = b; &#125; // 복사를 위한 생성자. Position(Position position) &#123; this.a = position.a; this.b = position.b; &#125;&#125; 복사된 배열의 값을 변경해도 원본 배열에 영향을 끼치지 않으며, 그 반대도 성립한다. 따라서 deepCopy가 잘 이루어진 것을 확인할 수 있다. 참고 자바(java) 배열의 깊은 복사(deep copy)와 얕은 복사 완벽정리(1차원 배열, 2차원 배열, 객체 배열 복사) [JAVA] JAVA 1차원 배열, 2차원 배열 깊은복사","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"배열","slug":"배열","permalink":"https://woovictory.github.io/tags/배열/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"},{"name":"복사","slug":"복사","permalink":"https://woovictory.github.io/tags/복사/"},{"name":"얕은 복사","slug":"얕은-복사","permalink":"https://woovictory.github.io/tags/얕은-복사/"},{"name":"깊은 복사","slug":"깊은-복사","permalink":"https://woovictory.github.io/tags/깊은-복사/"}]},{"title":"[Java] 문자열 관련 함수.","slug":"Java-String-Method","date":"2020-04-21T11:28:08.000Z","updated":"2020-04-21T13:03:26.871Z","comments":true,"path":"2020/04/21/Java-String-Method/","link":"","permalink":"https://woovictory.github.io/2020/04/21/Java-String-Method/","excerpt":"","text":"최근에 프로그래머스에서 제공하는 2020 카카오 블라인드 채용 코딩 테스트 문제를 풀었다. 그 중에서도 문자열 압축이라는 문제를 풀었는데, 그렇게 어렵지 않았다. 하지만, 문자열을 처리하는 부분에 대해서 취약하다는 걸 깨달을 수 있는 문제였다. 어렵지 않지만, 문자열 처리에 관해 얼마나 아는지 물어보는 문제였다. 그래서 푸는데 시간이 좀 걸리긴 했지만, 이 문제를 통해서 문자열 관련 함수를 한 번 정리하는 계기가 된 것 같다. 문자열 함수 startsWith 대상 문자열이 특정 문자 또는 문자열로 시작하는지 체크하는 함수이다. 해당 문자열로 시작되는지 여부를 확인하고 boolean에 맞춰 true/false 값을 반환한다. 대소문자를 구별한다. 123String s = \"I have a book\"s.startsWith(\"I\") // 1. trues.startWith(\"book\") // 2. false endsWith 대상 문자열이 특정 문자 또는 문자열로 끝나는지 체크하는 함수이다. 해당 문자열로 끝나는지 여부를 확인하고 boolean에 맞춰 true/false 값을 반환한다. 대소문자를 구별한다. 123String s = \"I have a book\";System.out.println(s.endsWith(\"book\")); // trueSystem.out.println(s.endsWith(\"a\")); // false equals 두 개의 String 문자열 값만을 비교하는 함수이다. 두 문자열의 값이 같으면 true, 다르면 false를 반환한다. 123String str1 = \"Java\";String str2 = \"Java\";System.out.println(str1.equals(str2)); // true indexOf 지정한 문자가 대상 문자열의 몇번째에 위치한 인덱스인지 확인한다. 반환값은 지정한 문자가 위치한 인덱스를 반환한다. 다만, 문자열에 지정한 문자가 여러 개 존재하는 경우, 제일 앞쪽에 나타나는 인덱스를 반환한다. 지정한 문자가 문자열에 존재하지 않는 경우, -1을 반환한다. 123String a = \"I have a book\";System.out.println(a.indexOf('z')); // -1System.out.println(a.indexOf('a')); // 3 lastIndexOf 지정한 문자가 대상 문자열의 마지막 몇번째에 위치한 인덱스인지 확인한다. indexOf() 함수가 앞에서부터 확인했다면, lastIndexOf() 함수는 뒤에서부터 확인하고, 찾으면 찾은 인덱스를 반환한다. 지정한 문자가 문자열에 존재하지 않는 경우, -1을 반환한다. 123String a = \"I have a book\";System.out.println(a.lastIndexOf('z')); // -1System.out.println(a.lastIndexOf('a')); // 7 replace 문자열에 지정한 문자가 있으면 새로 지정한 문자로 바꿔준다. replace()는 지정한 문자를 새로 지정한 문자로 바꾼 새로운 문자열을 반환한다. 따라서 기존의 문자열을 변경되지 않는다. 지정한 문자가 대상 문자열에 존재하지 않으면, replace() 함수는 수행되지 않는다. 1234String a = \"I have a book\";System.out.println(a.replace('I', 'Y')); // Y have a bookSystem.out.println(a); // I have a bookSystem.out.println(a.replace('z', 'Y')); // I have a book replaceAll split 지정한 문자로 대상 문자열을 나누어 배열을 반환한다. 문자열을 문자열 배열로 만들기 위해서는 지정 문자를 &quot;&quot;로 하면 된다. 공백이 있는 경우, 공백도 문자열 배열에 들어간다. 123456789101112String str = \"A:B:C:D:abcd\";String[] split = str.split(\":\");for (String s:split) System.out.print(s);System.out.println();System.out.println(split[4]);// ABCDabcd// abcdString a = \"ABCDEF G\";String[] b = a.split(\"\");for (String s:b) System.out.print(s);// ABCDEF G substring 문자열에 지정한 범위에 속하는 문자열을 반환한다. 시작범위의 값은 포함하고, 끝나는 범위의 값은 포함하지 않는다. 123String a = \"ABCDEFG\";System.out.println(a.substring(0,2)); // ABSystem.out.println(a); // ABCDEFG toLowerCase 문자열에 존재하는 대문자를 소문자로 바꾼 새로운 문자열을 반환한다. 기존에 소문자였던 문자열은 그대로 유지한다. 123String a = \"abcDEFG\";System.out.println(a.toLowerCase()); // abcdefgSystem.out.println(a); // abcDEFG toUpperCase 문자열에 존재하는 소문자를 대문자로 바꾼 새로운 문자열을 반환한다. 마찬가지로, 기존에 대문자였던 문자열은 그대로 유지한다. 123String a = \"abcDEFG\";System.out.println(a.toUpperCase()); // ABCDEFGSystem.out.println(a); // abcDEFG trim 문자열에 존재하는 공백을 제거할 때, 사용한다. 문자열의 앞, 뒤 쪽에 있는 공백만 제거할 수 있으며 가운데 존재하는 공백은 제거할 수 없고, replace() 함수를 사용해야 한다. 123String a = \" a aaa a \";System.out.println(a.trim()); // a aaa aSystem.out.println(a); // a aaa a contains 두 개의 String 값을 비교하여 비교 대상 String 문자열을 포함하고 있는지 여부를 확인한다. 비교 대상 문자열을 포함하고 있으면 true, 그렇지 않으면 false를 반환한다. 123String a = \"I have a book\";System.out.println(a.contains(\"have\")); // trueSystem.out.println(a.contains(\"z\")); // false toString 문자열을 반환한다. 12String a = \"a\";System.out.println(a.toString()); // a valueOf 지정한 개체의 원시 값을 반환한다. 123456int i = 123456789;long l = 1l;char c = '1';System.out.println(String.valueOf(i)); // 123456789System.out.println(String.valueOf(l)); // 1System.out.println(String.valueOf(c)); // 1 toString() vs valueOf() toString()과의 차이점이 존재한다. 먼저, toString(), valueOf() 메소드는 모두 Object의 값을 String으로 변환하지만, 변경하고자 하는 Object가 null인 경우 다르다. toString() : Null Pointer Exception(NPE) 발생. valueOf() : &quot;null&quot;이라는 문자열로 처리한다. valueOf() 함수의 원형은 다음과 같다. obj가 null인 경우, “null” 문자열을 반환한다. 123public static String valueOf(Object obj) &#123; return (obj == null) ? \"null\" : obj.toString();&#125; 두 메소드의 차이는 null 값에 따른 NPE의 발생 유무이다. null로 인해 발생된 에러는 시간이 지나고, 타인의 소스인 경우 디버깅하기 어렵다. 또한, 어떤 의미를 내포하고 있는지 판단하기 어렵다. 때문에 NPE를 방지하기 위해 toString보다는 valueOf를 사용하는 것을 추천한다. charAt 지정한 index번째 문자를 반환한다. 문자열의 길이보다 큰 인덱스를 지정하면 StringIndexOutOfBoundsException라는 예외가 발생한다. 123String a = \"I have a book\";System.out.println(a.charAt(0)); // ISystem.out.println(a.charAt(20)); // 예외 발생. concat 문자열과 문자열을 결합해 새로운 문자열을 반환한다. 12345String a = \"I\";String b = \" have\";System.out.println(a.concat(b)); // I haveSystem.out.println(a); // ISystem.out.println(b); // have format 서식 문자열을 이용해서 서식화된 문자열을 반환한다. 12int i = 123456789;System.out.println(String.format(\"%,d\",i)); // 123,456,789 matches 지정한 정규 표현식과 일치할 때, true를 반환하고 그렇지 않으면 false를 반환한다. 12345int i = 123456;String str1 = String.format(\"%,d\", i); // 123,456String str2 = \"123456\";boolean matcher = str1.matches(str2);System.out.println(matcher); // false replaceFirst 문자열에 지정한 문자열이 있으면 첫 번째만 새로 지정한 문자열로 바꿔서 새로운 문자열을 반환한다. 아래의 a는 &quot;A&quot;라는 문자열이 앞, 뒤에 등장한다. 이 경우에 replaceFirst() 메소드는 처음에 등장하는 &quot;A&quot;만을 &quot;Super&quot;라는 문자열로 바꾼다. 따라서 결과는 &quot;SupermenA&quot;가 된다. b 문자열은 뒤에만 &quot;A&quot;라는 문자열이 존재하기 때문에 이게 처음 등장하는 &quot;A&quot;가 된다. 따라서 결과는 &quot;menSuper&quot;가 된다. replace는 &quot;A&quot;라는 문자열이 등장하면 이를 모두 &quot;Super&quot;로 바꾼다. 따라서 결과는 &quot;SupermenSuper&quot;가 된다. 123456String a = \"AmenA\";System.out.println(a.replace(\"A\",\"Super\")); // SupermenSuperSystem.out.println(a.replaceFirst(\"A\",\"Super\")); // SupermenAString b = \"menA\";System.out.println(b.replaceFirst(\"A\",\"Super\")); menSuper 참고 Java의 toString()과 String.valueOf()의 차이점 자바 문자열 함수","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"},{"name":"문자열","slug":"문자열","permalink":"https://woovictory.github.io/tags/문자열/"},{"name":"문자열 처리","slug":"문자열-처리","permalink":"https://woovictory.github.io/tags/문자열-처리/"},{"name":"문자열 함수","slug":"문자열-함수","permalink":"https://woovictory.github.io/tags/문자열-함수/"}]},{"title":"[SWEA] SW17142 연구소3","slug":"SW17142","date":"2020-04-20T02:12:07.000Z","updated":"2020-04-20T02:14:45.076Z","comments":true,"path":"2020/04/20/SW17142/","link":"","permalink":"https://woovictory.github.io/2020/04/20/SW17142/","excerpt":"","text":"연구소 3 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 0.25 초 (하단 참고) 512 MB 13337 3607 2123 25.304% 문제 인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다. 연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다. 예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다. 12345672 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2 M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다. 1234567* 6 5 4 - - 25 6 - 3 - 0 14 - - 2 - 1 23 - 2 1 2 2 32 2 1 0 1 - -1 - 2 1 2 3 40 - 3 2 3 4 * 시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다. 12345670 1 2 3 - - 21 2 - 3 - 0 12 - - 2 - 1 23 - 2 1 2 2 33 2 1 0 1 - -4 - 2 1 2 3 4* - 3 2 3 4 * 연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자. 입력 첫째 줄에 연구소의 크기 N(4 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 위치이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다. 출력 연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다. 풀이 입력으로 주어진 바이러스의 갯수는 M개보다 크거나 같다. 따라서 바이러스의 갯수에서 M개를 골라서 활성화시킬 바이러스를 고른다. 그리고 바이러스를 퍼트린다. 모든 칸에 바이러스를 퍼트릴 수 있다. 이때, 바이러스를 모든 칸에 퍼트리는데 걸리는 최소 시간을 구하는 문제이다. 나의 풀이는 다음과 같다. 바이러스의 위치를 확인하여 리스트에 넣는다. 조합을 통해서 이 리스트에서 m개의 바이러스만 선택한다. m개의 바이러스가 선택되면, 바이러스를 퍼트린다. 퍼트리는 과정은 bfs 탐색을 통해 진행한다. 이를 copy 한 배열에 퍼트림으로써 원본 배열을 유지한다. 하지만, 문제에서 제공하는 테스트 케이스 1과 7만 맞고 나머지는 맞지 않았다. 조합을 통해서 구하는 건 맞는데, 바이러스를 퍼트리고 그 과정에서 활성 바이러스와 비활성 바이러스를 구분하는 부분의 구현이 조금 어려웠다. 그래서 거기서 틀린 것으로 추측된다. 처음 접근한 나의 코드는 다음과 같다. [나의 Code] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.LinkedList;/** * created by victory_woo on 2020/04/19 * 연구소3. * 삼성 기출. */public class Problem17142 &#123; private static int min = Integer.MAX_VALUE; private static int n, m; private static int[][] map; private static ArrayList&lt;Virus&gt; list; private static int[] comArr; private static int[][] distance; private static boolean[][] visit; private static int[] dx = &#123;-1, 0, 1, 0&#125;; private static int[] dy = &#123;0, 1, 0, -1&#125;; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] in = br.readLine().split(\" \"); n = toInt(in[0]); m = toInt(in[1]); map = new int[n][n]; distance = new int[n][n]; list = new ArrayList&lt;&gt;(); int index = 0, r; for (int i = 0; i &lt; n; i++) &#123; in = br.readLine().split(\" \"); for (int j = 0; j &lt; n; j++) &#123; map[i][j] = toInt(in[j]); //if (map[i][j] == 1) map[i][j] = -1; if (map[i][j] == 2) list.add(new Virus(index++, i, j)); &#125; &#125; r = list.size(); comArr = new int[m]; combination(r, m, 0, 0); System.out.println(min == Integer.MAX_VALUE? -1 : min); &#125; private static void combination(int k, int r, int index, int target) &#123; if (r == 0) &#123; print(); return; &#125; if (target == k) return; comArr[index] = target; combination(k, r - 1, index + 1, target + 1); combination(k, r, index, target + 1); &#125; // 여기서 visit, distance 배열 초기화. private static void print() &#123; int[][] copy = new int[n][n]; visit = new boolean[n][n]; LinkedList&lt;Virus&gt; q = new LinkedList&lt;&gt;(); for (int index : comArr) &#123; Virus virus = list.get(index); q.add(new Virus(virus.index, virus.x, virus.y)); visit[virus.x][virus.y] = true; //distance[virus.x][virus.y] =-2; //copy[virus.x][virus.y] = -2; &#125; while (!q.isEmpty()) &#123; Virus cur = q.remove(); for (int i = 0; i &lt; 4; i++) &#123; int nx = cur.x + dx[i]; int ny = cur.y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) continue; if (visit[nx][ny]) continue; if (map[nx][ny] == 0) &#123; q.add(new Virus(-1, nx, ny)); //copy[nx][ny] = map[cur.x][cur.y] + 1; distance[nx][ny] = distance[cur.x][cur.y] + 1; visit[nx][ny] = true; &#125; &#125; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; Virus virus = list.get(i); if (!visit[virus.x][virus.y]) &#123; distance[virus.x][virus.y] = -3; &#125; &#125; for (int index : comArr) &#123; Virus virus = list.get(index); distance[virus.x][virus.y] = -2; &#125;/* for (int a : comArr) System.out.print(a + \" : \" + list.get(a) + \" \"); System.out.println();*/ int result = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (result &lt; distance[i][j]) result = distance[i][j]; //System.out.print(distance[i][j] + \" \"); &#125; //System.out.println(); &#125; if (result &lt; min) min =result; &#125; private static int toInt(String value) &#123; return Integer.parseInt(value); &#125; static class Virus &#123; int index; int x; int y; Virus(int index, int x, int y) &#123; this.index = index; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Virus&#123;\" + \"x=\" + x + \", y=\" + y + '&#125;'; &#125; &#125;&#125; 바이러스를 퍼트리는 과정에서 감이 잘 잡히지 않아서 다른 풀이를 참고했다. 참고한 풀이는 규글님의 블로그이다. 풀이 순서는 다음과 같다. 입력을 받으면서 바이러스가 나오면 리스트를 통해 바이러스의 정보를 저장한다. 총 바이러스의 갯수에서 m개 만큼의 바이러스를 선택한다.(조합 사용) m개의 바이러스를 선택했으면, bfs 탐색을 이용해서 바이러스를 퍼트린다. 선택된 m개의 바이러스를 큐에 넣는다. bfs copy 배열을 만든다. 조합에서 선택되지 않은 바이러스는 비활성 바이러스로 -9로 표시한다. 벽인 부분은 -1로 표시한다. 조합을 통해 선택된 바이러스는 활성 바이러스로 -2로 표시한다. 큐에서 바이러스를 하나씩 빼면서, 네 방향을 탐색하며 퍼트릴 수 있는 만큼 퍼트리며, copy 배열을 채운다. 범위를 벗어나거나 방문한 적이 있거나 벽이거나 활성 바이러스의 경우는 건너뛴다. 위의 조건에서 걸리지 않은 경우에는 빈칸이거나 비활성 바이러스인 경우이다. 이때는 큐에 넣어주고, 빈칸인 경우에는 이전까지 온 거리 + 1을 copy 배열의 위치에 넣어준다. 비활성 바이러스인 경우에는 copy 배열을 갱신하지 않고 -9인 채로 유지한다. copy 값이 0이 아닌 경우에는 이미 그 공간을 방문한 적이 있는 것이므로 최소값으로 갱신한다. copy 값보다 이전까지 온 거리가 더 작다면 그 작은 값으로 갱신한다. bfs 탐색이 끝나고 바이러스를 퍼트리지 못한 지점이 하나라도 존재하면 그 바이러스 조합은 종료한다. copy 배열을 탐색하며 가장 큰 값을 찾는다. 이 값은 바이러스를 퍼트리는데 걸린 총 시간을 의미한다. 그리고 copy 배열에서 0보다 큰 값이 하나라도 존재한다면 이는 바이러스를 퍼트린 시간을 계산할 수 있음을 의미한다. 따라서 result 값과 비교하여 가장 작은 값을 result 값에 갱신하도록 한다. copy 배열에서 0보다 큰 값이 하나라도 존재하는 것은 바이러스를 퍼트린 시간이 존재함을 뜻한다. 0보다 큰 값이 없다는 것은 이미 바이러스가 벽이 아닌 공간에 모두 퍼져 있어 더 이상 퍼트릴 공간이 없다는 것을 뜻하며 시간은 0이 된다. 0보다 큰 값이 하나라도 존재하면 퍼트린 시간이 존재하므로 이때는 더 작은 값을 max에 저장한다. 주의할 점은 활성 바이러스가 비활성 바이러스 칸에 가면 비활성 -&gt; 활성이 된다는 것이다. 벽 : -1 비활성 바이러스 : -9 활성 바이러스 : -2 이렇게 설정하고 문제를 접근한다. [Code] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.LinkedList;/** * created by victory_woo on 2020/04/20 * 연구소 3. * 삼성 기출. * &lt;p&gt; * 초기 * 0 : 빈칸 * 1 : 벽 * 2 : 바이러스 위치. */public class Problem17142_3 &#123; private static int n; private static int result; private static int[][] map; private static int[] set; private static ArrayList&lt;Virus&gt; list; private static int[] dx = &#123;-1, 1, 0, 0&#125;; private static int[] dy = &#123;0, 0, -1, 1&#125;; // 상하좌우. public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] in = br.readLine().split(\" \"); n = toInt(in[0]); int m = toInt(in[1]); // 초기화. init(); // 입력을 받으면서 바이러스의 위치를 리스트에 저장한다. for (int i = 0; i &lt; n; i++) &#123; in = br.readLine().split(\" \"); for (int j = 0; j &lt; n; j++) &#123; map[i][j] = toInt(in[j]); if (map[i][j] == 2) list.add(new Virus(i, j, 0)); &#125; &#125; set = new int[m]; // 총 바이러스의 개수에서 m개를 뽑는 조합을 진행한다. combination(list.size(), m, 0, 0); System.out.println(result == Integer.MAX_VALUE ? -1 : result); &#125; private static void init() &#123; map = new int[n][n]; list = new ArrayList&lt;&gt;(); result = Integer.MAX_VALUE; &#125; private static void combination(int N, int R, int index, int target) &#123; // 조합을 만든 경우, 그 조합을 기반으로 bfs 를 진행한다. if (R == 0) &#123; bfs(); return; &#125; if (target == N) return; set[index] = target; combination(N, R - 1, index + 1, target + 1); combination(N, R, index, target + 1); &#125; /* * bfs() 탐색을 진행해 바이러스를 퍼트린다. * 벽은 -1로 초기화. * 비활성 바이러스는 -9로 초기화. * 바이러스는 -2로 초기화. * */ private static void bfs() &#123; int[][] copy = new int[n][n]; LinkedList&lt;Virus&gt; q = new LinkedList&lt;&gt;(); boolean[][] visit = new boolean[n][n]; // 활성 바이러스와 비활성 바이러스를 나눠서 처리한다. // 비활성 바이러스는 -9로 초기화한다. // 활성 바이러스는 -2로 초기화 하면서 큐에 넣고 방문 여부를 체크한다. for (int i = 0; i &lt; list.size(); i++) &#123; boolean flag = false; for (int index : set) &#123; // 활성 바이러스인 경우. if (i == index) flag = true; &#125; Virus virus = list.get(i); if (!flag) &#123; copy[virus.x][virus.y] = -9; &#125; else &#123; copy[virus.x][virus.y] = -2; q.add(virus); visit[virus.x][virus.y] = true; &#125; &#125; // 벽 초기화. for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (map[i][j] == 1) copy[i][j] = -1; &#125; &#125; // bfs 탐색을 진행한다. while (!q.isEmpty()) &#123; Virus cur = q.remove(); int time = cur.time; for (int i = 0; i &lt; 4; i++) &#123; int nx = cur.x + dx[i]; int ny = cur.y + dy[i]; // 범위를 벗어나거나 방문한 적이 있거나 해당 정점이 벽이거나 혹은 활성 바이러스인 경우에는 건너뛴다. if (!isRange(nx, ny) || visit[nx][ny] || copy[nx][ny] == -1 || copy[nx][ny] == -2) continue; // 빈칸이거나 비활성 바이러스인 경우, 방문 여부를 체크하고 큐에 넣는다. // 이유는 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 -&gt; 활성 상태로 바뀌기 때문이다. if (copy[nx][ny] == 0 || copy[nx][ny] == -9) &#123; visit[nx][ny] = true; q.add(new Virus(nx, ny, time + 1)); // 빈칸인 경우, 처음 방문한 곳이기 때문에 해당 정점에 지금가지 걸린 시간 + 1을 넣어준다. if (copy[nx][ny] == 0) &#123; copy[nx][ny] = time + 1; &#125; else &#123; // 이미 값이 있는 경우는 다른 바이러스에 의해서 이미 퍼지고 시간이 적혀 있는 것을 의미한다. // 따라서 최소 시간으로 갱신이 가능하면 갱신한다. // 왜냐하면 바이러스는 동시에 인접한 네 칸으로 퍼지기 때문이다. // 현재 정점에 적힌 시간보다 지금까지 걸린 시간 + 1이 작으면 지금까지 걸린 시간 + 1로 갱신한다. if (copy[nx][ny] &gt; time + 1) copy[nx][ny] = time + 1; &#125; &#125; &#125; &#125; int max = Integer.MIN_VALUE; if (isFinish(copy)) return; // 0보다 큰 값에 대해서 확인을 하며 가장 큰 값을 찾아 max 에 저장한다 // 이는 바이러스를 모두 퍼트리는 데 걸린 시간을 구한다. for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (copy[i][j] &lt; 0) continue; if (max &lt; copy[i][j]) max = copy[i][j]; &#125; &#125; // true : 바이러스를 퍼트리는 데 걸린 시간 중 최소 값을 구한다. if (isCompleted(copy)) &#123; if (max &lt; result) result = max; &#125; else &#123; result = 0; &#125; &#125; // 이미 벽과 충분한 바이러스로 꽉 차고 애초에 빈칸이 없는 경우에는 false 값을 반환한다. // 따라서 바이러스가 퍼지는 데 걸리는 시간은 없다. 0이다. // 0보다 큰 값이 하나라도 존재한다면 바이러스가 퍼진 시간을 계산할 수 있기 때문에 true 반환. private static boolean isCompleted(int[][] copy) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (copy[i][j] &gt; 0) return true; &#125; &#125; return false; &#125; // 바이러스가 모든 곳에 퍼졌는지 확인한다. // 모든 곳에 퍼졌다면 false 반환. // 퍼지지 않은 곳이 한 곳이라도 존재하면 true 반환. private static boolean isFinish(int[][] copy) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (copy[i][j] == 0) return true; &#125; &#125; return false; &#125; // 범위 안에 들어오는 지 확인한다. private static boolean isRange(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n; &#125; private static int toInt(String value) &#123; return Integer.parseInt(value); &#125; static class Virus &#123; int x; int y; int time; Virus(int x, int y, int time) &#123; this.x = x; this.y = y; this.time = time; &#125; &#125;&#125;","categories":[{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/categories/삼성-기출/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/tags/삼성-기출/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://woovictory.github.io/tags/시뮬레이션/"}]},{"title":"[SWEA] SW17144 미세먼지 안녕!","slug":"SW17144","date":"2020-04-17T02:22:13.000Z","updated":"2020-04-20T02:11:40.310Z","comments":true,"path":"2020/04/17/SW17144/","link":"","permalink":"https://woovictory.github.io/2020/04/17/SW17144/","excerpt":"","text":"미세먼지 안녕! 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 1 초 512 MB 7939 4272 2890 53.988% 문제 미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다. 공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 Ar,c이다. 1초 동안 아래 적힌 일이 순서대로 일어난다. 미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다. (r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다. 인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다. 확산되는 양은 Ar,c/5이고 소수점은 버린다. (r, c)에 남은 미세먼지의 양은 Ar,c - (Ar,c/5)×(확산된 방향의 개수) 이다. 공기청정기가 작동한다. 공기청정기에서는 바람이 나온다. 위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다. 바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다. 공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다. 다음은 확산의 예시이다. 왼쪽과 오른쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다. 인접한 네 방향으로 모두 확산이 일어난다. 공기청정기가 있는 칸으로는 확산이 일어나지 않는다. 공기청정기의 바람은 다음과 같은 방향으로 순환한다. 방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자. 입력 첫째 줄에 R, C, T (6 ≤ R, C ≤ 50, 1 ≤ T ≤ 1,000) 가 주어진다. 둘째 줄부터 R개의 줄에 Ar,c (-1 ≤ Ar,c ≤ 1,000)가 주어진다. 공기청정기가 설치된 곳은 Ar,c가 -1이고, 나머지 값은 미세먼지의 양이다. -1은 2번 위아래로 붙어져 있고, 가장 윗 행, 아랫 행과 두 칸이상 떨어져 있다. 출력 첫째 줄에 T초가 지난 후 구사과 방에 남아있는 미세먼지의 양을 출력한다. 풀이 아래의 일이 1초 동안 일어난다. 미세먼지가 모든 칸에서 동시에 일어난다. -&gt; bfs 탐색을 통해서 진행한다. 공기 청정기의 위쪽은 반시계 방향, 아래쪽은 시계 방향으로 바람이 분다. 이로 인해 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다. -&gt; 이 부분은 그대로 구현을 하면 된다. 공기 청정기의 위치로 들어간 미세먼지는 정화된다. 공기 청정기가 움직인 뒤, 바뀐 map 배열을 업데이트 해준다. T초가 지난 후 방에 남아있는 미세먼지의 양을 출력한다. 문제에서 주의해야 할 점은 원본 배열이 바뀌면 안되기 배열을 복사해서 copy를 이용해서 미세먼지를 확장시키고 난 뒤의 배열을 원본 배열에 업데이트 해준다. 그리고 공기 청정기가 돌면서 정화한 뒤의 배열을 다시 원본 배열에 업데이트 시키는데, 이때 공기 청정기의 바람이 지나가면서 바뀐 부분만 업데이트 하도록 한다. 문제에서 공기 청정기의 바람에 의해 정화된 후, 바뀐 배열을 원본 배열에 업데이트 시킬 때, 변경된 부분만 업데이트 시키려 하는 과정에서 조건문을 ||로 줘야 하는데 &amp;&amp; 로 하나를 주면서 20분 정도 해맸다… 풀이 조금 더 시간을 줄일 수 있는 방법이 있다. 위의 풀이에서는 visit 배열을 두어 방문 여부를 체크하고 결국, 다시 초기화 하는 형태였는데 이는 불필요하다. 굳이 bfs 탐색을 하면서 visit 배열을 사용하지 않는 것이다. 어차피 미세먼지의 확산은 동시에 일어나기 때문에 이로 인해서 방문한 곳은 또 방문하게 된다. 따라서 이를 아예 고려하지 않으면 문제가 되지 않는다. 미세먼지가 있는 곳은 큐에 넣는다. bfs 탐색을 통하여 미세먼지를 확장한다. 공기 청정기가 움직이며 바람을 통해 순환시킨다. 위의 과정을 t 동안 반복하고, 미세 먼지의 양의 합을 구한다. 다만, 주의할 점은 원본 배열이 변경되기 때문에 copy 배열을 만들어서 작업한 후, 원본 배열에 업데이트 시켜줘야 한다는 점이다. [Code] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;/** * created by victory_woo on 2020/04/17 * 미세먼지 안녕! * 삼성 기출. * 시뮬레이션 + 구현. */public class Problem17144Re &#123; private static int r, c, t; private static int[][] map; private static Node[] cleaners; private static int[] dx = &#123;-1, 0, 1, 0&#125;; private static int[] dy = &#123;0, 1, 0, -1&#125;; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] in = br.readLine().split(\" \"); r = toInt(in[0]); c = toInt(in[1]); t = toInt(in[2]); map = new int[r][c]; cleaners = new Node[2]; int index = 0; for (int i = 0; i &lt; r; i++) &#123; in = br.readLine().split(\" \"); for (int j = 0; j &lt; c; j++) &#123; map[i][j] = toInt(in[j]); // 공기 청정기의 위치를 저장한다. if (map[i][j] == -1) cleaners[index++] = new Node(i, j); &#125; &#125; solve(); &#125; private static void solve() &#123; for (int i = 0; i &lt; t; i++) &#123; spreadDust(); // 미세 먼지를 확장한다. spreadCleaner(); &#125; getResult(); &#125; // 미세먼지를 확장시킨다. // 이를 위해서 copy 배열을 두고 큐에서 꺼내면서 미세 먼지가 동시에 확장되는 것을 구현한다. private static void spreadDust() &#123; // 모든 미세먼지는 동시에 확장되기 때문에 copy 배열을 두어 map 배열에서 꺼내면서 확장시킨다. int[][] copy = new int[r][c]; // 미세 먼지가 존재하는 칸을 큐에 넣는다. LinkedList&lt;Node&gt; q = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (map[i][j] &gt; 0) q.add(new Node(i, j)); &#125; &#125; // 큐에서 꺼내면서 인접한 네 방향을 검사하면서 미세 먼지를 확장한다. // 이 과정은 동시에 일어난다. while (!q.isEmpty()) &#123; Node dust = q.remove(); int x = dust.x, y = dust.y; // 확산되는 양. int amountOfDust = map[x][y] / 5; int count = 0; // 인접한 네 방향 검사. for (int i = 0; i &lt; 4; i++) &#123; int nx = x + dx[i]; int ny = y + dy[i]; // 범위 검사. if (nx &lt; 0 || ny &lt; 0 || nx &gt;= r || ny &gt;= c) continue; // 공기 청정기가 아닌 곳은 미세먼지를 확장시킬 수 있으므로, 미세먼지를 확장시킬 수 있는 공간의 갯수를 구한다. // 그리고 미세먼지가 있는 곳에 확산되는 양을 더해준다. if (map[nx][ny] != -1) &#123; count++; copy[nx][ny] += amountOfDust; &#125; &#125; copy[x][y] += map[x][y] - amountOfDust * count; &#125; copyDust(copy); &#125; // map &lt;- copy private static void copyDust(int[][] copy) &#123; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; map[i][j] = copy[i][j]; &#125; &#125; /*System.out.println(\"== 미세 먼지 확장 ==\"); print();*/ &#125; // 공기 청정기가 바람을 통해서 순환한다. // !!! 여기는 t가 아니라 공기청정기가 2칸 차지하니까 2여야 함.. private static void spreadCleaner() &#123; int[][] copy = new int[r][c]; for (int i = 0; i &lt; 2; i++) &#123; Node cleaner = cleaners[i]; int x = cleaner.x; int y = cleaner.y + 1; // 오른쪽으로 끝까지 이동한다. while (y &lt; c - 1) &#123; copy[x][y + 1] = map[x][y]; y++; &#125; // 반시계 방향의 경우. if (i == 0) &#123; // 위로 올라간다. while (x &gt; 0) &#123; copy[x - 1][y] = map[x][y]; x--; &#125; &#125; else &#123; // 시계 방향의 경우. while (x &lt; r - 1) &#123; copy[x + 1][y] = map[x][y]; x++; &#125; &#125; // 왼쪽으로 끝까지 이동한다. while (y &gt; 0) &#123; copy[x][y - 1] = map[x][y]; y--; &#125; // 반시계 방향의 경우. if (i == 0) &#123; while (x &lt; cleaner.x - 1) &#123; copy[x + 1][y] = map[x][y]; x++; &#125; &#125; else &#123; // 시계 방향의 경우. while (x &gt; cleaner.x + 1) &#123; // !!! -1로 했었는데, 그게 아니라 +1로 해야 함 // 아래에서 위로 올라가기 때문이다. copy[x - 1][y] = map[x][y]; x--; &#125; &#125; &#125; copyCleaner(copy); &#125; // 공기 청정기의 바람이 순환하는 경로만 map 배열로 업데이트 시켜준다. private static void copyCleaner(int[][] copy) &#123; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (i == 0 || i == r - 1 || j == 0 || j == c - 1 || i == cleaners[0].x || i == cleaners[1].x) map[i][j] = copy[i][j]; &#125; &#125; /*System.out.println(\"== 공기청정기 동작 후 ==\"); print();*/ &#125; private static void getResult() &#123; int sum = 0; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; if (map[i][j] &gt; 0) sum += map[i][j]; &#125; &#125; System.out.println(sum); &#125; private static int toInt(String value) &#123; return Integer.parseInt(value); &#125; // 확인용. private static void print() &#123; for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; static class Node &#123; int x; int y; public Node(int x, int y) &#123; this.x = x; this.y = y; &#125; &#125;&#125; 참고 [백준 미세먼지 안녕!](","categories":[{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/categories/삼성-기출/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/tags/삼성-기출/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://woovictory.github.io/tags/시뮬레이션/"}]},{"title":"[SWEA] SW16236 아기 상어","slug":"SW16236","date":"2020-04-16T01:09:47.000Z","updated":"2020-04-20T02:11:39.516Z","comments":true,"path":"2020/04/16/SW16236/","link":"","permalink":"https://woovictory.github.io/2020/04/16/SW16236/","excerpt":"","text":"아기 상어 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 512 MB 16449 6615 3776 36.991% 문제 N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다. 아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다. 아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다. 아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다. 더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다. 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다. 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다. 거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다. 거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다. 아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다. 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다. 공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오. 입력 첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다. 0: 빈 칸 1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기 9: 아기 상어의 위치 아기 상어는 공간에 한 마리 있다. 출력 첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다. 풀이 bfs + 시뮬레이션인 것 같다. 풀이 2차원 배열을 통해 입력을 받는다. 상어가 존재하는 9일 경우, 상어의 위치를 저장한다. 그리고 이후에 bfs 탐색을 하면서 조건을 검사하기 위해 상어가 있던 위치는 0으로 바꿔준다. 최초의 shark 객체를 상어의 위치와 distance 0으로 만들어준다. size = count = 2이다. 초기 상어의 크기가 2이기 때문이다. 상어가 가장 가까운 물고리를 찾기 위해서 bfs 를 시작한다. 초기에 상어를 큐에 넣어준다. 상어의 distance는 INF 값으로 할당한다. 이유는 최단 거리를 찾아서 업데이트 할 것이기 때문! 큐에서 상어를 네 방향을 탐색한다. 범위를 벗어나지 않고, 방문한 적이 없는 곳을 큐에 넣는다. 5번을 반복하면 큐에 여러 값들이 들어가므로 조건 검사를 제대로 할 수 있게 된다. 조건을 검사한다. 상어의 distance에는 최단 거리가 담기는데, 현재 위치의 거리가 더 크다면? 이때는 bfs를 중단한다. 최단 거리보다 더 움직인 것이기 때문에 최단 거리는 구해졌다. 상어의 크기인 size 보다 큰 물고기는 먹을 수 없으므로 다음 물고기를 확인하기 위해 skip 한다. 물고기가 존재하면서, 상어의 크기보다 작은 물고기인 경우에는 상어가 먹을 수 있다. 상어가 이 물고기까지 온 거리가 그 전에 알고 있던 거리보다 작다면 최단 거리로 갱신한다. 그렇지 않고 이 물고기까지 온 거리와 그 전에 알고 있던 거리가 같다면 더 위에 있는 물고기를 먹는다. 그러한 물고기가 여러 마리라면 더 왼쪽에 있는 물고기를 먹는다. 물고기를 먹는 것은 상어가 그 물고기가 있는 곳에 위치하는 것으로 먼저 표현을 한다. bfs 탐색이 끝나고 나서 상어의 distance 가 바뀌었는지 확인한다. 바뀌었다면, 상어의 위치가 바뀌고 distance 값도 바뀌었다. 이는 상어가 그 물고기의 위치를 찾아서 먹었음을 의미한다. 상어가 물고기를 먹으러 이동한 거리를 time에 더하고, count 값을 감소시킨다. 이는 상어가 자신의 크기만큼 물고기를 먹기 위함이다. count == 0인 경우를 확인한다. true 라면 상어가 자신의 크기만큼 물고기를 다 먹었고 상어의 크기는 1 증가한다. 그리고 count는 size로 초기화 해준다. 8번의 조건을 확인하면서 상어의 distance 값이 바뀌지 않았다면, 상어가 물고기를 먹을 수 있는 물고기를 찾지 못해 bfs가 그대로 종료됐음을 의미한다. 따라서 반복문을 빠져나온다. time 값을 반환한다. [Code] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148package SW_Study;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;/** * created by victory_woo on 2020/04/15 * 아기 상어. * 시뮬레이션 + bfs * 난이도 높음... 어려움... * 다시 풀어보기! */public class Problem16236 &#123; private static final int INF = Integer.MAX_VALUE; private static int n; private static int[][] map; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = toInt(br.readLine()); map = new int[20][20]; // 상어의 위치를 저장하기 위한 변수를 선언한다. int sharkX = 0, sharkY = 0; for (int i = 0; i &lt; n; i++) &#123; String[] in = br.readLine().split(\" \"); for (int j = 0; j &lt; n; j++) &#123; map[i][j] = toInt(in[j]); // 상어의 위치를 저장한다. if (map[i][j] == 9) &#123; sharkX = i; sharkY = j; // 상어가 이동할 때, 최초 상어의 위치는 중요하지 않기 때문에 // 상어가 최초 위치했던 곳은 빈곳으로 바꿔준다. map[i][j] = 0; &#125; &#125; &#125; System.out.println(solve(sharkX, sharkY)); &#125; private static int[] dx = &#123;-1, 0, 1, 0&#125;; private static int[] dy = &#123;0, 1, 0, -1&#125;; private static int solve(int x, int y) &#123; int time = 0; // 이동하는 데 걸리는 시간. int size = 2; // 상어의 크기. 이동할 때마다 상어의 크기와 비교해야 함. int count = size; Fish shark = new Fish(x, y, 0); // 최단 거리를 찾아야 하기 때문에 최초 위치는 상어의 위치로 시작한다. // 상어가 가장 가까운 물고기를 찾기 위해서 bfs 탐색을 한다. while (true) &#123; // 방문 여부 체크. boolean[][] visit = new boolean[20][20]; LinkedList&lt;Fish&gt; q = new LinkedList&lt;&gt;(); visit[shark.x][shark.y] = true; q.add(new Fish(shark.x, shark.y, 0)); shark.distance = INF; while (!q.isEmpty()) &#123; Fish cur = q.remove(); // 계속 진행하다 보면 현재 위치의 거리가 우리가 찾은 최단 거리보다 커지는 경우가 존재한다. // bfs 탐색을 중단한다. // 거리가 최단 거리보다 멀어졌다는 의미는 더이상 확인할 물고기가 없다는 걸 뜻한다. if (cur.distance &gt; shark.distance) break; // 상어의 크기보다 큰 물고기가 있다면 해당 물고기는 skip 한다. 즉, 건너뛰고 다른 물고기를 탐색한다. if (map[cur.x][cur.y] &gt; size) continue; // 물고기가 존재하고, 현재 상어보다 물고기의 크기가 작다고 하면 먹을 수 있다. if (map[cur.x][cur.y] != 0 &amp;&amp; map[cur.x][cur.y] &lt; size) &#123; // 이 물고기까지 온 거리가 그 전에 알고 있던 거리보다 작다면 최단 거리를 갱신한다. // shark 를 현재 위치로 바꿔준다. if (cur.distance &lt; shark.distance) &#123; shark = cur; &#125; else if (cur.distance == shark.distance) &#123; // 거리가 같은 물고기가 존재한다면 // 더 위에 있는 물고기를 먹는다. if (cur.x &lt; shark.x) &#123; shark = cur; &#125; else if (cur.x == shark.x &amp;&amp; cur.y &lt; shark.y) &#123; // 같은 높이에 있다면 더 왼쪽에 있는 물고기를 먹어야 한다. // 따라서 y 좌표가 더 작은 물고기를 먹는다. shark = cur; &#125; &#125; // 가장 가까운 물고기를 찾았기 때문에 continue 로 아래 네 방향으로 진행하는 탐색을 skip 한다. continue; &#125; for (int i = 0; i &lt; 4; i++) &#123; int nx = cur.x + dx[i]; int ny = cur.y + dy[i]; if (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) continue; if (visit[nx][ny]) continue; visit[nx][ny] = true; q.add(new Fish(nx, ny, cur.distance + 1)); &#125; &#125; // INF 가 아닌 경우 물고기를 찾은 경우. // 이동 거리르 증가하고, 물고기의 갯수를 줄여준다. if (shark.distance != INF) &#123; time += shark.distance; count--; if (count == 0) &#123; size++; count = size; &#125; // 먹은 물고기는 0으로 지워준다. map[shark.x][shark.y] = 0; &#125; else &#123; break; &#125; &#125; return time; &#125; private static int toInt(String value) &#123; return Integer.parseInt(value); &#125; static class Fish &#123; int x; int y; int distance; // 상어가 이동하는 데 걸린 거리.(거리가 곧 시간) Fish(int x, int y, int distance) &#123; this.x = x; this.y = y; this.distance = distance; &#125; &#125;&#125;","categories":[{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/categories/삼성-기출/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/tags/삼성-기출/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://woovictory.github.io/tags/시뮬레이션/"}]},{"title":"[SWEA] SW17825 주사위 윷놀이","slug":"SW17825","date":"2020-04-14T16:40:29.000Z","updated":"2020-04-20T02:11:43.600Z","comments":true,"path":"2020/04/15/SW17825/","link":"","permalink":"https://woovictory.github.io/2020/04/15/SW17825/","excerpt":"","text":"주사위 윷놀이 시간 제한 메모리 제한 제출 정답 맞은 사람 정답 비율 2 초 512 MB 2885 1052 652 31.976% 문제 주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다. 처음에는 시작 칸에 말 4개가 있다. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다. 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다. 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다. 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다. 주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자. 입력 첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다. 출력 얻을 수 있는 점수의 최댓값을 출력한다. 풀이 글쎄,? 어떻게 풀어야 할까 일단, 예상 로직은 다음과 같다. 그림이 그래프 형태를 이루고 있고, 얻을 수 있는 점수의 최댓값 말을 골라서 이동시켜야 함. Dfs + 백트래킹을 사용하면 될 것 같다. 하지만, 고려할 점 그림을 어떻게 표현할 것인가? 말을 선택하는 부분! 이동 전에 이동할 칸에 말이 있는지 여부를 확인해야 한다. buddev 님의 블로그를 참고했다. 구현 포인트 파란 점일 때, 아닐 때를 구분해서 리스트를 구현해주면 된다. 1234567891011static class Node &#123; int score; // 해당 칸의 점수. int red; // 빨간 화살표로 이동할 경우, 다음 점. int blue; // 파란 화살표로 이동할 경우, 다음 점. boolean isBlue; // 파란 점인지 여부. Node(int score, int red) &#123; this.score = score; this.red = red; &#125; &#125; 문제에서 칸의 번호와 점수가 동일한데, 같은 번호가 있는 칸이 두개씩 있는 경우가 존재한다. 따라서 겹치는 번호들에 한해서 번호를 바꿔서 지정했다. 이를 디버깅하고 난 후, 내가 생각한 풀이를 적는다. 윷놀이 판의 가장 바깥 라인은 2의 배수로 채운다. -&gt; 문제와 똑같이 간다. 꺾이는 부분, 파란 점으로 인한 지름길이다. 바깥 라인과 값이 중복되기 때문에 다른 값으로 대체한다. 중복을 허용하는 수열을 이용해서 주사위가 나오는 값 별로 올 수 있는 말의 경우를 모두 구한다. 모두 구했으면, now 배열, check 배열을 초기화 하고 말을 움직인다.(move() 호출) [Code] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * created by victory_woo on 2020/04/15 */public class sw17825Re &#123; private static final int TEN = 10; private static int[] permutation, now, step; private static boolean[] check; private static Node[] map; private static int max; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] in = br.readLine().split(\" \"); permutation = new int[TEN]; step = new int[TEN]; map = new Node[43]; for (int i = 0; i &lt; TEN; i++) step[i] = toInt(in[i]); setDice(); getPermutation(0); System.out.println(max); &#125; // 파란 점이 있는 부분에 대해서 처리한다. // 바깥 라인과의 중복된 값이 존재하기 때문에 인덱스를 다르게 주었고, 값은 그대로 저장했다. // 또한, 빨간 점으로 된 다음 좌표를 저장한다. private static void setDice() &#123; for (int i = 0; i &lt;= 40; i += 2) map[i] = new Node(i, i + 2); map[10].isBlue = map[20].isBlue = map[30].isBlue = true; map[10].setBlue(11); map[20].setBlue(17); map[30].setBlue(31); map[11] = new Node(13, 13); map[13] = new Node(16, 15); map[15] = new Node(19, 25); map[17] = new Node(22, 19); map[19] = new Node(24, 25); map[31] = new Node(28, 33); map[33] = new Node(27, 35); map[35] = new Node(26, 25); map[25] = new Node(25, 37); map[37] = new Node(30, 39); map[39] = new Node(35, 40); map[42] = new Node(0, 42); &#125; private static void getPermutation(int depth) &#123; if (depth == 10) &#123; now = new int[4]; check = new boolean[43]; move(); return; &#125; for (int i = 0; i &lt; 4; i++) &#123; permutation[depth] = i; getPermutation(depth + 1); &#125; &#125; private static void move() &#123; int score = 0; for (int i = 0; i &lt; TEN; i++) &#123; // 말을 움직여서 말이 도착한 지점의 값을 구한다. // 말이 step 만큼 움직이도록 horseMove() 함수를 호출한다. // end 값은 말이 주사위 step 만큼 움직이고 난 뒤의 칸. int end = horseMove(permutation[i], step[i]); if (end == -1) return; now[permutation[i]] = end; // 현재 말이 있는 칸을 업데이트 한다. score += map[end].score; &#125; if (max &lt; score) max = score; &#125; // now : 윷놀이 판 위에서 말이 위치한 인덱스.(말이 있는 윷놀이 판의 인덱스) private static int horseMove(int horse, int step) &#123; // 몇 번째 말이 움직일 것인지 뽑는다. // 즉, 이동할 말을 정한다. int temp = now[horse]; // 말이 step 만큼 움직인다. // 첫 좌표이면서 파란 점이라면 파란 점을 temp 에 저장한다. // 그게 아니라면 말이 이동할 다음 좌표(빨간 점의 위치)를 찾아 temp 에 저장한다. for (int i = 0; i &lt; step; i++) &#123; if (i == 0 &amp;&amp; map[temp].isBlue) &#123; temp = map[temp].blue; continue; &#125; temp = map[temp].red; &#125; // 도착 지점에 도착하지도 않았는데, 방문한 곳을 또 방문한 경우. if (temp &lt;= 40 &amp;&amp; check[temp]) &#123; return -1; &#125; else &#123; check[now[horse]] = false; check[temp] = true; return temp; &#125; &#125; private static int toInt(String value) &#123; return Integer.parseInt(value); &#125; static class Node &#123; int score; int blue; int red; boolean isBlue; public Node(int score, int red) &#123; this.score = score; this.red = red; &#125; public void setBlue(int blue) &#123; this.blue = blue; &#125; public void setRed(int red) &#123; this.red = red; &#125; &#125;&#125; 이 문제는 주사위를 저렇게 구현해 낼 수 있느냐 없느냐의 싸움인 것 같다. 풀고나면 어렵지 않지만, 저렇게 생각해 내는 연습이 필요한 것 같다. 더 열심히 하자~ 뿅!","categories":[{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/categories/삼성-기출/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"},{"name":"삼성 기출","slug":"삼성-기출","permalink":"https://woovictory.github.io/tags/삼성-기출/"},{"name":"시뮬레이션","slug":"시뮬레이션","permalink":"https://woovictory.github.io/tags/시뮬레이션/"}]},{"title":"[Java] contains, startsWith 차이점","slug":"Java-contains-and-startsWith-diff","date":"2020-04-03T02:39:38.000Z","updated":"2020-04-03T03:12:05.095Z","comments":true,"path":"2020/04/03/Java-contains-and-startsWith-diff/","link":"","permalink":"https://woovictory.github.io/2020/04/03/Java-contains-and-startsWith-diff/","excerpt":"","text":"startsWith() 함수 원형 : boolean startsWith(String prefix) 대상 문자열이 특정 문자 또는 문자열로 시작하는지 체크하는 함수이다. 해당 문자열로 시작되는지 여부를 확인하고 boolean에 맞춰 true/false 값을 반환한다. 123String s = \"I have a book\"s.startsWith(\"I\") // 1. trues.startWith(\"book\") // 2. false 첫 번째 문장은 &quot;I have a book&quot;이라는 문자열 s가 매개 변수 문자열인 &quot;I&quot;로 시작하는지 확인한다. 따라서 결과는 true를 반환한다. 두 번째 문장은 &quot;book&quot;으로 시작하는지 확인하므로 이는 false를 반환한다. contains() 함수 원형 : boolean contains(CharSequence s) 대상 문자열에 특정 문자열이 포함되어 있는지 확인하는 함수이다. 대/소문자를 구분한다. 12String s = \"I have a book\"s.contains(\"book\") // 1. true &quot;book&quot;이라는 문자열이 s 문자열 안에 포함되어 있으므로 true를 반환한다. 참고 [JAVA] 자바_startsWith/endsWith (특정 문자로 시작하거나 끝나는지 체크)","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"메소드","slug":"메소드","permalink":"https://woovictory.github.io/tags/메소드/"},{"name":"contains","slug":"contains","permalink":"https://woovictory.github.io/tags/contains/"},{"name":"startsWith","slug":"startsWith","permalink":"https://woovictory.github.io/tags/startsWith/"},{"name":"차이점","slug":"차이점","permalink":"https://woovictory.github.io/tags/차이점/"},{"name":"문자열","slug":"문자열","permalink":"https://woovictory.github.io/tags/문자열/"}]},{"title":"[Kotlin in Action] Chap7. 연산자 오버로딩과 기타 관례","slug":"KotlinInAction-Chap7","date":"2020-04-02T06:52:56.000Z","updated":"2020-05-12T15:17:39.013Z","comments":true,"path":"2020/04/02/KotlinInAction-Chap7/","link":"","permalink":"https://woovictory.github.io/2020/04/02/KotlinInAction-Chap7/","excerpt":"","text":"목차 연산자 오버로딩 관례 : 여러 연산을 지원하기 위해 특별한 이름이 붙은 메소드 위임 프로퍼티 OverViews 어떤 클래스 안에 pluse라는 이름의 특별한 메소드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다. 이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법 -&gt; 관례 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 함수 이름을 통한 관례에 의존한다. 이 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다. 기존 자바 클래스가 구현하는 인터페이스는 이미 고정되어 있다. 그래서 코틀린 쪽에서 자바 클래스가 새로운 인터페이스를 구현하도록 할 수 없다. 반면, 확장 함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다. 따라서 기존 자바 클래스에 대해 확장 함수를 구현하면서 관례에 따라 이름을 붙이면 기존 자바 코드를 바꾸지 않아도 새로운 기능을 부여할 수 있다. 이번 장에서는 Point라는 클래스를 예제로 사용할 것이다. 코드는 아래와 같다. 1data class Point(val x: Int, val y: Int) 7.1 산술 연산자 오버로딩 자바는 원시 타입에 대해서만 산술 연산자를 정의할 수 있고, 추가적으로 String에 대해 + 연산자 사용이 가능하다. 하지만 다른 클래스에서도 유용한 경우가 있을 수 있다. Ex) BigInteger 클래스의 add를 호출하기 보다는 +연산을 사용하는 편이 낫다. 어떻게 하는지 알아보자. 7.1.1 이항 산술 연산 오버로딩 123456789101112131415161718data class Point(val x: Int, val y: Int) &#123; operator fun plus(other: Point): Point &#123; return Point(x + other.x, y + other.y) &#125;&#125;class PointTest &#123; @Test fun `포인트 테스트`() &#123; val p = Point(10, 20) val p2 = Point(30, 40) println(p + p2) // p.plus(p2) 로 컴파일된다. &#125;&#125;// ResultPoint(x=40, y=60) 연산자를 오버로딩 하는 함수 앞에 operator 키워드가 있어야 한다. 이를 통해 이 함수가 관례를 따르는 함수임을 명확하게 알 수 있다. operator 없이 관례에서 사용하는 함수 이름을 쓰면 &quot;operator modifier is required … &quot; 오류를 접하게 된다. 즉, plus 처럼 미리 정해진 이름의 함수를 operator 키워드를 통해 선언하면 +와 연결되어 + 호출로 연산을 수행할 수 있다. 연산자를 확장 함수로 정의할 수도 있다. 123operator fun Point.plus(other: Point): Point&#123; return Point(x+other.x, y+other.y)&#125; 코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고, 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며, 관례에 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다. 식 함수 이름 a*b times a/b div a%b mod(1.1부터 rem) a+b plus a-b minus 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다. 연산자를 정의할 때, 두 피연산자는(연산자 함수의 두 파라미터) 같은 타입일 필요는 없다. Ex) 어떤 점을 비율에 따라 확대 및 축소하는 연산자를 정의하면 아래와 같다. 12345678910111213operator fun Point.times(scale: Double): Point &#123; return Point((x * scale).toInt(), (y * scale).toInt())&#125;@Testfun `포인트 times 테스트`() &#123; val p = Point(10, 20) println(p.times(1.5)) println(p * 1.5)&#125;// ResultPoint(x=15, y=30)Point(x=15, y=30) 코틀린 연산자는 자동으로 교환 법칙을 지원하지 않는다. 따라서 p * 1.5 가 된다고 해서 1.5 * p 가 되지는 않는다. 역을 지원하기 위해서는 마찬가지로 역의 식에 대응하는 연산자 함수를 정의해야 한다. 또한, 연산자 함수의 반환 타입이 두 피연산자 중 하나와 일치하지 않아도 된다. 일반 함수와 마찬가지로 operator 함수도 오버로딩 가능하다. 따라서 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다. 대신 operator 함수는 파라미터의 개수는 1개밖에 정의하지 못한다. 이항 연산이기 때문! 비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다. 코틀린은 표준 숫자 타입에 대해 비트 연산자를 정의하지 않는다. 따라서 커스텀 타입에서 비트 연산자를 정의할 수도 없다. 대신, 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행한다. 7.1.2 복합 대입 연산자 오버로딩 12345var point = Point(1,2)point +=Point(3,4)println(point)// ResultPoint(x=4, y=6) +=, -= 등의 연산자를 복합 대입 연산자라 부른다. point +=Point(3,4) 식은 point = point + Point(3,4) 라고 쓴 식과 동일하다. 물론, 변경 가능한 경우에만 복합 대입 연산자를 사용할 수 있다. += 연산은 객체에 대한 참조를 다른 참조로 바꿔치기 한다. point = point + Point(3,4)의 실행을 살펴보자. point의 plus는 새로운 객체를 반환한다. point + Point(3,4)는 두 점의 좌표 각각 더한 값을 좌표로 갖는 새로운 Point 객체를 반환한다. 그 후 대입이 이뤄지면 point 변수는 새로운 Point 객체를 가리키게 된다. 코틀린 표준 라이브러리는 MutableCollection에 대해 plusAssign을 정의하며, 아래와 같다. 이는 원래 객체의 내부 상태를 변경한다. 123operator fun &lt;T&gt; MutableCollection&lt;T&gt;.plusAssign(element: T)&#123; this.add(element)&#125; +=를 plus와 plusAssign 양쪽으로 컴파일 할 수 있다. 어떤 클래스가 이 두 함수를 모두 정의하고 둘 다 +=에 사용 가능한 경우 컴파일러는 오류를 보여준다. 일반 연산자를 이용해 해결하거나 var를 val로 바꿔서 plusAssign 적용을 불가능하게 할 수도 있다. 하지만, 일반적으로 새로운 클래스를 일관성 있게 설계하는 게 가장 좋다. plus와 plusAssign을 동시에 정의하는 것을 피해야 한다. 코틀린은 컬렉션에 대해 두 가지 접근 방법을 제공한다. +, -는 항상 새로운 컬렉션을 반환한다. +=, -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다. 또한, 읽기 전용 컬렉션에서 +=, 0-는 변경을 적용한 복사본을 반환한다. 이런 연산자의 피연산자로 개별 원소를 사용하거나 원소 타입이 일치하는 다른 컬렉션을 사용할 수 있다. 123456789val list = arrayListOf(1,2)list +=3 // 변경 가능한 컬렉션 list에 대해 +=을 통해 객체 상태를 변경.val newList = list + listOf(4,5) // 두 리스트를 +로 합쳐 새로운 리스트를 반환.println(list)println(newList)// Result[1,2,3][1,2,3,4,5] 7.1.3 단항 연산자 오버로딩 123456789101112operator fun Point.unaryMinus(): Point &#123; return Point(-x, -y)&#125;@Testfun `단항 연산자 테스트`() &#123; val p = Point(10, 20) println(-p)&#125;// ResultPoint(x=-10, y=-20) 이항 연산자의 오버로딩과 마찬가지로 미리 정해진 이름의 함수를 멤버나 확장 함수로 선언하면서 operator를 표시하면 된다. 단항 연산자를 오버로딩하기 위해 사용하는 함수는 인자를 취하지 않는다. [오버로딩할 수 있는 단항 산술 연산자] 식 함수 이름 +a unaryPlus -a unaryMinus !a not ++a, a++ inc –a, a– dec Ex) 1234567891011121314operator fun BigDecimal.inc() = this + BigDecimal.ONE@Testfun `증가 연산자 테스트`()&#123; var bd= BigDecimal.ZERO println(bd++) // 0 println(bd) // 1 println(++bd) // 2&#125;// Result012 후위 ++ 연산은 bd 값을 반환한 후, bd의 값을 증가시킨다. 전휘 ++ 연산은 그 반대로 동작한다. 전위와 후위 연산을 처리하기 위해 별다른 처리를 해주지 않아도 제대로 동작한다. 7.2 비교 연산자 오버로딩 equals, compareTo를 호출해야 하는 자바와 달리 코틀린에서는 == 비교 연산자를 직접 사용함으로써 코드가 간결하며 이해하기 쉬운 장점이 있다. 7.2.1 동등성 연산자 : equals != 연산자도 equals로 컴파일된다. 이는 비교 결과를 뒤집은 값을 결과값으로 사용한다. ==와 !=는 내부에서 인자가 널인지 검사하므로 다른 연산과 달리 널이 될 수 있는 값에도 적용할 수 있다. 아래 코드를 보자. 123a == b// 위의 식은 아래처럼 컴파일 된다.a?.equals(b) ?: (b == null) a가 널인지 판단해서 널이 아닌 경우에만 a.equals(b)를 호출한다. 만약 a가 널이라면 b도 널인 경우에만 결과가 true가 된다. Point는 data class이므로 컴파일러가 자동으로 equals를 생성해준다. 구현한다면 아래와 같을 것이다. 12345678class Point(val x: Int, val y: Int)&#123; override equals(obj: Any?): Boolean&#123; if(this === obj) return true if(obj !is Point) return false return x == obj.x &amp;&amp; y == obj.y &#125;&#125; ===(식별자 비교 연산자)를 사용해 equals의 파라미터가 수신 객체와 같은지 확인한다. ===는 자바의 == 연산자와 같다. 따라서 ===는 자신의 두 핀연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교한다. ===를 사용해 자기 자신과의 비교를 최적화하는 경우가 많으며, ===는 오버로딩할 수 없다. Any의 equals에는 operator가 붙어있지만 그 메소드를 오버라이드하는 하위 클래스의 메소드 앞에는 operator를 붙이지 않아도 자동으로 상위 클래스의 operator 지정이 적용된다. 또한, Any에서 상속받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수 없다. 7.2.2 순서 연산자 : compareTo 자바에서 정렬이나 최댓값, 최솟값 등 값을 비교하는 알고리즘에 사용할 클래스는 Comparable 인터페이스를 구현한다. 코틀린도 똑같은 Comparable 인터페이스를 지원한다. 게다가 코틀린은 Comparable 인터페이스 안에 있는 compareTo 메소드를 호출하는 관례를 제공한다. 따라서 비교 연산자 (&lt;, &gt;, &lt;=, &gt;=)는 compareTo 호출로 컴파일 된다. 반환값은 Int이다. 다른 비교 연산자도 동일한 방식으로 동작한다. 1234567a &gt;= b// 위의 코드는 아래로 컴파일된다.a.compareTo(b) &gt;= 0println(\"abc\" &lt; \"bac\")// Resulttrue 7.3 컬렉션과 범위에 대해 쓸 수 있는 관례 7.3.1 인덱스로 원소에 접근 : get, set 배열, 리스트, 맵에 접근할 때 []를 통해서 접근이 가능하다. []는 원소를 읽는 연산일 때는 get 연산자 메소드로 변환되고, 원소를 쓰는 연산은 set 연산자 메소드로 변환된다. 1234567891011121314operator fun Point.get(index: Int): Int &#123; return when (index) &#123; 0 -&gt; x 1 -&gt; y else -&gt; throw IndexOutOfBoundsException(\"Invalid coordinate $index\") &#125;&#125;@Testfun `get 테스트`()&#123; val p = Point(10,20) println(p[1]) // p[1] -&gt; p.get(1) 호출로 변환된다.&#125;// Result20 get 연산자를 정의한다. get 메소드의 파라미터로 Int가 아닌 타입도 사용할 수 있다. 맵의 경우는 키 타입이 될 수도 있다. 여러 파라미터를 사용하는 get을 정의할 수도 있다. 12345operator fun get(rowIndex: Int, colIndex:Int)&#123; ...&#125;// matrix[row, col]로 호출한다. 인덱스에 해당하는 컬렉션 원소를 쓰고 싶을 때는 set 함수를 정의하면 된다. 123456789101112131415161718192021data class MutablePoint( var x: Int, var y: Int)operator fun MutablePoint.set(index: Int, value: Int) &#123; when (index) &#123; 0 -&gt; x = value 1 -&gt; y = value else -&gt; throw IndexOutOfBoundsException(\"Invalid coordinate $index\") &#125;&#125;@Testfun `set 테스트`()&#123; val p = MutablePoint(10,20) p[0] = 30 // p[0] = 30 -&gt; p.set(30) p[1] = 60 // p[1] = 60 -&gt; p.set(60) println(p)&#125;// ResultMutablePoint(x=30, y=60) 7.3.2 in 관례 객체가 컬렉션에 들어있는지 검사한다. in 연산자와 대응하는 함수는 contains이다. 12345678910111213141516data class Rectangle(val upperLeft: Point, val lowerRight: Point)operator fun Rectangle.contains(p: Point): Boolean &#123; return p.x in upperLeft.x until lowerRight.x &amp;&amp; p.y in upperLeft.y until lowerRight.y&#125;@Testfun `in 테스트`() &#123; val rect = Rectangle(Point(10, 20), Point(50, 50)) println(Point(10, 30) in rect) // a in rect -&gt; rect.contains(a) println(Point(10, 50) in rect)&#125;// Resulttruefalse 범위를 만들고 x, y 좌표가 그 범위 안에 있는지 검사한다. until 함수를 사용해 열린 범위를 만든다. 열린 범위 : 끝 값을 포함하지 않는 범위를 말한다. Ex) 10…20 식을 사용해 일반적인 (닫힌) 범위를 만들면 10 이상 20 이하인 범위가 생긴다.(20을 포함.) Ex) 1o until 20으로 만드는 열린 범위는 10 이상 19이하인 범위며, 20은 범위 안에 포함되지 않는다. 7.3.3 rangeTo 관례 1…10 : 1부터 10까지 모든 수가 들어있는 범위를 가리킨다. … 연산자는 rangeTo 함수를 간략하게 표현하는 방법이다. 따라서 … 는 rangeTo로 컴파일된다. 범위를 반환하며, 아무 클래스에나 정의할 수 있다. rangeTo 연산자는 다른 산술 연산자보다 우선순위가 낮다. 하지만 혼동을 피하기 위해 괄호로 감싸주는 것이 더 좋다. 또한, 범위 연산자는 우선 순위가 낮아서 범위의 메소드를 호출하려면 범위를 괄호로 둘러싸야 한다. 123456789101112val n = 9println(0 .. (n + 1))0..10// 아래 식은 컴파일할 수 없다.0..n.forEach&#123;&#125;// 아래 코드처럼 범위의 메소드를 호출하려면 범위를 괄호로 둘러싸면 된다.(0..n).forEach&#123; ...&#125; 추가적으로 코틀린에서는 모든 Comparable 객체에 대해 적용 가능한 rangeTo 함수를 제공한다. rangeTo는 ClosedRange 객체를 반환한다. 1operator fun &lt;T: Comparable&lt;T&gt;&gt; T.rangeTo(that: T): ClosedRange&lt;T&gt; 7.3.4 for 루프를 위한 iterator 관례 2장에서 살펴봤듯이 코틀린의 for 루프는 범위 검사와 똑같이 in 연산자를 사용한다. 하지만 의미는 다르다. 아래 코드는 list.iterator()를 호출해서 이터레이터를 얻은 다음, 자바와 마찬가지로 그 이터레이터에 대해 hasNext, next 호출을 반복하는 식으로 변환된다. 123for (x in list)&#123; ...&#125; 이 또한 관례이므로 iterator 메소드를 확장 함수로 정의할 수 있다. 이런 성질로 인해 자바 문자열에 대한 for 루프가 가능하다. 코틀린은 String의 상위 클래스인 CharSequence에 대한 iterator 확장 함수를 제공한다. 따라서 아래와 같은 구문이 가능하다. 12345operator fun CharSequence.iterator(): CharIteratorfor(c in \"abc\")&#123; ...&#125; 클래스 안에 직접 iterator를 구현한 예이다. 1234567891011121314151617operator fun ClosedRange&lt;LocalDate&gt;.iterator(): Iterator&lt;LocalDate&gt; = object : Iterator&lt;LocalDate&gt; &#123; var current = start override fun hasNext() = current &lt;= endInclusive override fun next() = current.apply &#123; current = plusDays(1) &#125; &#125;fun main(args: Array&lt;String&gt;) &#123; val newYear = LocalDate.ofYearDay(2017, 1) val daysOff = newYear.minusDays(1)..newYear for (dayOff in daysOff) &#123; println(dayOff) &#125;&#125; 앞에서 rangeTo 함수가 ClosedRange 인스턴스를 반환한다. 코드에서 ClosedRange&lt; LocaDate &gt; 에 대한 확장 함수 Iterator를 정의했기 때문에 LocalDate의 범위 객체를 for 루프에서 사용할 수 있다. 7.4 구조 분해 선언과 component 함수 구조 분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화할 수 있다. 구조 분해 선언은 일반 변수 선언과 비슷하다. 다만, = 좌변에 여러 변수를 괄호로 묶었다는 점이 다르다. 1234567val p = Point(10,20)val (x,y) = pprintln(x)println(y)// Result1020 내부에서 구조 분해 선언은 관레를 사용한다. 구조 분해 선언의 각 변수를 초기화하기 위해 componentN이라는 함수를 호출한다. 1234val (a,b) = p// 위의 구조 분해 선언은 아래의 componentN() 함수 호출로 변환된다.val a = p.component1()val b = p.component2() data class의 주 생성자에 있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN 함수를 만들어준다. 일반 클래스에서는 아래와 같이 구현한다. 1234class Point(val x: Int, val y: Int)&#123; operator fun component1() = x operator fun component2() = y&#125; 또한, 구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다. 여러 값을 반환해야 하는 함수가 있다면 반환해야 하는 모든 값이 들어갈 holder 역할의 데이터 클래스를 정의하고 함수의 반환 타입을 그 데이터 클래스로 바꾼다. 구조 분해 선언 구문을 사용해 이 함수가 반환하는 값을 쉽게 풀어 여러 변수에 넣을 수 있다. 1234567891011121314151617data class NameComponents(val name: String, val extension: String)fun splitFilename(fullName: String): NameComponents &#123; val result = fullName.split('.', limit = 2) return NameComponents(result[0], result[1])&#125;fun main(args: Array&lt;String&gt;) &#123; val (name, ext) = splitFilename(\"example.kt\") // 구조 분해 선언 구문을 사용해 데이터 클래스를 푼다. println(name) println(ext)&#125;// Resultexamplekt 코틀린은 맨 앞의 다섯 원소에 대한 componentN 함수를 제공한다. 따라서 컬렉션의 크기가 5보다 작아도 1~5까지접근이 가능하다. 하지만, IndexOutOfBoundsException이 발생한다. 여섯 개 이상의 변수를 사용하는 구조 분해를 컬렉션에 대해 적용하면 컴파일 오류가 발생한다. 7.4.1 구조 분해 선언과 루프 변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 사용할 수 있다. 맵의 원소에 대해 이터레이션할 때, 구조 분해 선언이 유용하다. 1234567891011fun print(map: Map&lt;String, String))&#123; for((key, value) in map)&#123; println(\"$key -&gt; $value\") &#125;&#125;val map = mapOf(\"Oracle\" to \"Java\", \"JetBrains\" to \"Kotlin\")print(map)//ResultOracle -&gt; JavaJetBrains -&gt; Kotlin 객체를 이터이션하는 관례, 구조 분해 선언 2가지 관례를 사용한다. 코틀린의 맵은 확장 함수로 iterator가 들어있다. 그 iterator는 맵 원소에 대한 이터레이터를 반환한다. 따라서 자바와 달리 코틀린에서는 맵을 직접 이터레이션할 수 있다. 7.5 프로퍼티 접근자 로직 재활용 : 위임 프로퍼티 위임이란 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 맡기는 디자인 패턴. 작업을 처리하는 객체를 위임 객체(delegate)라고 한다. 7.5.1 위임 프로퍼티 1234class Foo&#123; val p : Type by Delegate() // by 키워드는 프로퍼티와 위임 객체를 연결한다.&#125; p 프로퍼티는 접근자 로직을 다른 객체에게 위임한다. 여기서는 Delegate 클래스의 인스턴스를 위임 객체로 사용한다. by 뒤에 있는 식을 계산해서 위임에 쓰일 객체를 얻는다. 123456class Foo&#123; private val delegate = Delegate() val p: Type set(value: Type) = delegate.setValue(..., value) get() = delegate.getValue(...)&#125; 위의 코드처럼 컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다. p 프로퍼티는 바로 그 위임 객체에게 자신의 작업을 위임한다. Delegate 클래스를 단순화하면 다음과 같다. 1234567891011class Delegate&#123; operator fun getValue(...)&#123; ... // getter를 구현하는 로직을 담는다. &#125; operator fun setValue(...)&#123; ... // setter를 구현하는 로직을 담는다. &#125;&#125; 123val foo = Foo()val oldValue = foo.p // 1foo.p = newValue // 2 1번과 같은 프로퍼티 호출은 내부에서 delegate.getValue()을 호출한다. 2번처럼 프로퍼티 값을 변경하는 문장은 내부에서 delegate.setValue(…, newValue)를 호출한다. 7.5.2 by lazy()를 사용한 프로퍼티 초기화 지연 지연 초기화는 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우, 초기화할 때 흔히 쓰이는 패턴이다. 초기화 과정에 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화하지 않아도 되는 프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있다. 123456789101112131415161718192021222324class Email &#123; /*...*/ &#125;fun loadEmails(person: Person): List&lt;Email&gt; &#123; println(\"Load emails for $&#123;person.name&#125;\") return listOf(/*...*/)&#125;class Person(val name: String) &#123; private var _emails: List&lt;Email&gt;? = null // 데이터를 저장하고 emails의 위임 객체 역할을 하는 _emails 프로퍼티. val emails: List&lt;Email&gt; get() &#123; if (_emails == null) &#123; _emails = loadEmails(this) // 최초 접근 시 이메일을 가져온다. &#125; return _emails!! // 저장해둔 데이터가 있으면 그 데이터를 반환한다. &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(\"Alice\") p.emails // 최초로 emails를 읽을 때 단 한번만 이메일을 가져온다. p.emails&#125; 뒷받침하는 프로퍼티라는 기법을 사용한다. _emails 프로퍼티는 값을 저장하고, emails 프로퍼티는 _emails 프로퍼티에 대한 읽기 연산을 제공한다. _emails는 Nullable 하고, emails는 널이 될 수 없는 타입이므로 프로퍼티 2개를 사용해야 한다. 이런 기법은 자주 사용된다. 이와 같은 방법은 성가시며, 스레드 안전하지 않아서 언제나 제대로 동작한다고 말할 수 없다. 대신 위임 프로퍼티를 사용해보자. 123456789class Person(val name: String)&#123; val emails by lazy &#123; loadEmails(this) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person(\"Alice\") p.emails p.emails&#125; lazy 함수는 코틀린 관례에 맞는 시그니처의 getValue() 메소드가 들어있는 객체를 반환한다. 따라서 lazy와 by 키워드와 함께 사용해 위임 프로퍼티를 만들 수 있다. lazy 함수의 인자는 값을 초기화할 때 호출할 람다다. 그리고 lazy 함수는 기본적으로 스레드 안전하다. 추가적으로 필요에 따라 동기화에 사용할 락을 lazy 함수에 전달할 수도 있고, 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 lazy 함수가 동기화를 하지 못하게 막을 수도 있다. 7.5.3 위임 프로퍼티 사용 위임 프로퍼티를 사용해서 변경을 통지해주는 부분의 코드를 작성해 처음부터 리팩토링 해나가는 과정을 보여주고 있습니다. 설명하기 보다는 직접 읽어보는 것이 좋을 것 같아서 정리하지 않았으니 양해 바랍니다 😁 7.5.4 위임 프로퍼티 컴파일 규칙 12345class C&#123; var prop : Type by MyDelegate()&#125;val c = C() 컴파일러는 MyDelegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티는 라는 이름으로 부른다. 또한, 컴파일러는 프로퍼티를 표현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 라고 부른다. 컴파일러는 다음의 코드를 생성한다. 1234567class C&#123; private val &lt;delegate&gt; = MyDelegate() var prop : Type get() = &lt;delegate&gt;.getValue(this, &lt;property&gt;) set(value: Type) = &lt;delegate&gt;.setValue(this, &lt;property&gt;, value)&#125;// this는 C 클래스를 가리킨다. 컴파일러는 모든 프로퍼티 접근자 안에 getValue, setValue 호출 코드를 생성해준다. 이 매커니즘은 상당히 단순하지만, 상당히 흥미로운 활용법이 많다고 한다. 프로퍼티 값이 저장될 장소를 바꿀 수도 있고(맵, 데이터베이스 테이블, 사용자 세션의 쿠키 등) 프로퍼티를 읽거나 쓸 때 벌어질 일을 변경할 수도 있다.(값 검증, 변경 통지 등) 이 모두를 간결한 코드로 달성할 수 있다. 아직까지 위임 프로퍼티를 사용해 본 경험은 없다. 그래서 이 내용이 와닿지 않지만, 저런 식으로 사용하면 확실히 간결하게 코드를 작성할 수 있고 여러 일을 수행하는 객체가 있다면 Delegate 패턴을 사용해 역할을 어느 정도 위임해 분리할 수 있지 않을까란 생각을 해봤다. 아래의 링크가 Delegate 패턴에 대해 설명하고 있으니 참고하면 좋을 것 같습니다. Delegate 패턴 [Java][정리] 위임(delegation)과 구현/포함(Composite) 개념 7.5.5 프로퍼티 값을 맵에 저장 자신의 프로퍼티를 동적으로 정의할 수 있는 객체를 만들 때, 위임 프로퍼티를 활용하는 경우가 자주 있다. 그런 객체를 확장 가능한 객체(expando object)라고한다. 123456789101112131415161718192021222324class Person &#123; // 추가 정보 private val _attributes = hashMapOf&lt;String, String&gt;() fun setAttribute(attrName: String, value: String) &#123; _attributes[attrName] = value &#125; // 필수 정보 val name: String get() = _attributes[\"name\"]!! // 수동으로 맵에서 정보를 꺼낸다.&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person() val data = mapOf(\"name\" to \"Dmitry\", \"company\" to \"JetBrains\") for ((attrName, value) in data) p.setAttribute(attrName, value) println(p.name)&#125;// ResultDmitry 위의 코드를 위임 프로퍼티를 활용하여 변경할 수 있다. by 키워드 뒤에 맵을 직접 넣으면 된다. 1234567891011121314151617class Person &#123; private val _attributes = hashMapOf&lt;String, String&gt;() fun setAttribute(attrName: String, value: String) &#123; _attributes[attrName] = value &#125; val name: String by _attributes&#125;fun main(args: Array&lt;String&gt;) &#123; val p = Person() val data = mapOf(\"name\" to \"Dmitry\", \"company\" to \"JetBrains\") for ((attrName, value) in data) p.setAttribute(attrName, value) println(p.name)&#125; 이와 같은 코드가 동작하는 이유는 표준 라이브러리가 Map과 MutableMap 인터페이스에 대해 getValue, setValue 확장 함수를 제공하기 때문이다. getValue에서 맵에 프로퍼티 값을 저장할 때는 자동으로 프로퍼티 이름을 키로 활용한다. p.name -&gt; _attributes.getValue(p, prop)라는 호출을 대신한다. 이는 다시 _attributes.getValue(p, prop) -&gt; _attributes[prop.name]을 통해 구현된다. 참고 Kotlin In Action","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"},{"name":"Kotlin in Action","slug":"Kotlin-in-Action","permalink":"https://woovictory.github.io/tags/Kotlin-in-Action/"}]},{"title":"[Kotlin in Action] Chap6. 코틀린 타입 시스템","slug":"KotlinInAction-Chap6","date":"2020-04-02T06:40:07.000Z","updated":"2020-05-12T15:17:29.775Z","comments":true,"path":"2020/04/02/KotlinInAction-Chap6/","link":"","permalink":"https://woovictory.github.io/2020/04/02/KotlinInAction-Chap6/","excerpt":"","text":"1. 널 가능성(Nullability) 물음표 기호 ’ ? '를 사용하여 Null이 될 수 있는 여부를 컴파일러가 미리 감지하게 함. NPE처리를 위해 Nullable타입을 명시적으로 지원 1public void strLen(@NotNull String s1, @Nullable String s2) &#123;...&#125; 1fun strLen(s1 : String, s2 : String?) &#123;...&#125; Ex) 123456789101112fun strLen(s : String) = s.lengthfun strLenSafe(s : String?) = s!!.length //모순...fun strLenSafe2(s : String?) = if(s != null) s.length else 0fun main(args: Array&lt;String&gt;) &#123; println(strLen(\"abc\")) // 3 println(strLenSafe(\"abc\")) // 3 println(strLenSafe2(\"abc\")) // 3 val x: String? = null println(strLenSafe(x)) // ? &#125; Kotlin에서는 NPE가 일어나지 않는가? NullPointerException을 상속한 KotlinNullPointerException이 발생 인자로 넘겨준 값이 Nullable이라면 함수내에서도 Nullable 통일! 12345public open class KotlinNullPointerException : NullPointerException &#123; constructor() constructor(message: String?) : super(message)&#125; 1.1 Safe Call 연산자 Safe Call 연산자는 ’ .? ’ 을 붙여 사용 Null검사와 메소드 호출을 한 번의 연산으로 수행 Ex.1) Safe Call 연쇄시키기1 123456789fun printAllCaps(s: String?) &#123; val allCaps: String? = s?.toUpperCase() println(allCaps)&#125;fun main(args: Array&lt;String&gt;) &#123; printAllCaps(\"abc\") //ABC printAllCaps(null) //null&#125; Ex.2) Safe Call 연쇄시키기2 12345678910111213141516class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)class Company(val name: String, val address: Address?)class Person(val name: String, val company: Company?)fun Person.countryName(): String &#123; val country = this.company?.address?.country return if (country != null) country else \"Unknown\"&#125;fun main(args: Array&lt;String&gt;) &#123; val person = Person(name = \"Dmitry\", company = null) println(person.countryName())&#125; 생각해보자! 위의 Safe Call 연산자를 보고 처음엔 읽기 불편했지만 아래의 예시를 보고 느낌이 왔다. 12val country = this.company?.address?.countryreturn if (country != null) country else \"Unknown\" 저 부분만 Java로 변환하면 123456789if(this.getCompany() != null &amp;&amp; this.getCompany().getAddress() != null &amp;&amp; this.getCompany().getAddress().getCountry() != null)&#123; String country = this.getCompany().getAddress().getCountry(); return country;&#125;else&#123; return \"Unknown\";&#125; 1.2 Elvis 연산자 널복합 연산자(Null coalescing) 라고도 함 이항연산자로 좌항을 계산한 값이 Null인 경우, 특정 값(우항)으로 값을 할당 예외 처리에 유용 삼항 연산자 + Null 처리(Kotlin에서는 삼항 연산자를 지원하지 않음) Ex .1) Safe Call 연산자 vs Elvis 연산자 12345678//Safe Call 연산자fun Person.countryName(): String &#123; val country = this.company?.address?.country return if (country != null) country else \"Unknown\"&#125;//Elvis 연산자fun Person.countryName() = this.company?.address?.country ?: \"Unknown\" Ex.2) Elvis 연산자를 이용한 예외 처리 123456789101112131415161718192021222324class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)class Company(val name: String, val address: Address?)class Person(val name: String, val company: Company?)fun printShippingLabel(person: Person) &#123; val address = person.company?.address ?: throw IllegalArgumentException(\"No address\") with (address) &#123; println(streetAddress) println(\"$zipCode $city, $country\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val address = Address(\"Elsestr. 47\", 80687, \"Munich\", \"Germany\") val jetbrains = Company(\"JetBrains\", address) val person = Person(\"Dmitry\", jetbrains) printShippingLabel(person) //Elsestr. 47 //80687 Munich, Germany printShippingLabel(Person(\"Alexey\", null)) //java.lang.IllegalArgumentException: No address&#125; 1.3 Type Cast 연산자 : as 와 Safe Cast :as? as?는 변환 가능한 타입인지 검사 후, 아니면 Null값 반환 123456789101112131415161718192021class Person(val firstName: String, val lastName: String) &#123; override fun equals(o: Any?): Boolean &#123; val otherPerson = o as? Person ?: return false return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName &#125; override fun hashCode(): Int = firstName.hashCode() * 37 + lastName.hashCode()&#125; fun main(args: Array&lt;String&gt;) &#123; val p1 = Person(\"Dmitry\", \"Jemerov\") val p2 = Person(\"Dmitry\", \"Jemerov\") println(p1 == p2) //true println(p1.equals(42)) //false println(\"p1 HashCode : \" + p1.hashCode()) println(\"p1 HashCode : \" + p2.hashCode())&#125; 심화학습… //혼자 다 설명할 수 없음… 위의 코드를 보면, 뜬금없이 hashCode를 재정의한 것을 볼 수 있는데 그 이유를 간략히 설명하자면, Effective Java에서는 다음과 같이 설명한다. equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다. 그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다. 따라서, eqauls를 재정의 하는 경우 다음 3가지 규약을 지켜야한다. equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다. (단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문)) equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다. equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision) 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다. 참고 HashCode() 재정의 이유 : https://jaehun2841.github.io/2019/01/12/effective-java-item11/#서론 37을 곱한 이유 : https://d2.naver.com/helloworld/831311 1.4 널 아님 단언(Not-null Assertion) 널 아님 단언은 ’ !! '로 표현 컴파일러에게 &quot;나는 이 값이 null이 아님을 잘 알고있으며, 예외가 발생해도 감수하겠다&quot;라는 표현 Ex.1) Swing(프레임워크)에서 널 아님 단언 사용 123456class CopyRowAction(val list: JList&lt;String&gt;): AbstractAction()&#123; override fun isEnabled(): Boolean = list.selectedValue != null override fun actionPerformed(e : ActionEvent)&#123; val value = list.selectedValue!! &#125;&#125; 한 줄에 나란히 널 아님 단언이 쓰였을 경우, 어떤 식에서 발생한 예외인지 알 수 없으니 나란히 사용은 피하자 1person.company!!.address!!.country 1.5 let함수 널이 될 수 있는 값(Nullable)을 널이 아닌 값(NotNull)만 인자로 받을 때, 용이하게 사용 여러 값에 대한 null 체크 시, let을 중첩해서 사용하면 코드가 복잡해지므로 피하는 것이 좋다. (if (something != null) 사용을 권장) Ex.1) let을 사용해 Null이 아닌 인자로 함수 호출하기 12345678910fun sendEmailTo(email: String) &#123; println(\"Sending email to $email\")&#125;fun main(args: Array&lt;String&gt;) &#123; var email: String? = \"yole@example.com\" email?.let &#123; sendEmailTo(it) &#125; //Sending email to yole@example.com email = null email?.let &#123; sendEmailTo(it) &#125;&#125; let을 호출하면 람다의 인자인 it은 널이 될 수 있는 타입으로 추론됨 1.6 lateinit 변경자 lateinit 변경자를 사용하면 Nullable, NotNull을 난잡하게 사용하지않고 프로퍼티를 나중에 초기화 할 수 있다. 프로퍼티가 val인 경우는 적용할 수 없고, 항상 var여야만 한다. 12345678910111213141516171819202122import org.junit.Beforeimport org.junit.Testimport org.junit.Assertclass MyService &#123; fun performAction(): String = \"foo\"&#125;class MyTest &#123; private var myService: MyService? = null //lateinit 변경자 선언 시 private lateinit myService : MyService @Before fun setUp() &#123; myService = MyService() &#125; @Test fun testAction() &#123; Assert.assertEquals(\"foo\", myService!!.performAction()) //lateinit 변경자로 선언 시, Assert.assertEquals(\"foo\", myService.performAction()) &#125;&#125; lateinit에 대한 초기화진행 여부를 확인하기 위해서는 ex) ::myService.isInitialized 형태로 분기처리하여 확인할 수 있다 1.7 널 가능 타입의 확장 null이 될 수 있는 타입에 대한 확장함수를 정의하면, Safe Call을 하지않아도 된다. Ex.1) Null이 될 수 있는 수신 객체에 대해 확장 함수 호출 123456789101112131415161718fun verifyUserInput(input: String?) &#123; if (input.isNullOrBlank()) &#123; //&lt;- input이 Nullable이지만 Safe Call 연산자를 쓰지않음 println(\"Please fill in the required fields\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; verifyUserInput(\" \") //Please fill in the required fields verifyUserInput(null) //Please fill in the required fields&#125;//String에서의 확장함수 정의public inline fun CharSequence?.isNullOrBlank(): Boolean &#123; contract &#123; returns(false) implies (this@isNullOrBlank != null) &#125; return this == null || this.isBlank()&#125; 1.8 타입 파라미터의 널 가능성 Kotlin에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.(t를 Any 타입으로 추론하기 때문) 타입 파라미터는 타입 상한을 지정하지 않는다면 Null이 될 수 있다.(t를 Any?의 타입으로 추론하기 때문) Ex.) 널이 될 수 있는 타입파라미터와 상한 지정 123456789101112131415161718//널이 될 수 있는 타입 파라미터fun &lt;T&gt; printHashCode(t: T) &#123; println(t?.hashCode())&#125;fun main(args: Array&lt;String&gt;) &#123; printHashCode(null) //null&#125;//상한을 지정한 타입 파라미터fun &lt;T : Any&gt; printHashCode(t: T) &#123; println(t.hashCode())&#125;fun main(args: Array&lt;String&gt;) &#123; printHashCode(null) //Type parameter bound for T in fun &lt;T : Any&gt; printHashCode(t: T): Unit is not satisfied&#125; 참고: https://stackoverflow.com/questions/54760309/why-i-cant-assign-nullable-type-to-any-in-kotlin 1.9 플랫폼 타입 플랫폼 타입은 Kotlin이 널 관련 정보를 알 수 없는 Java 타입을 지칭 Kotlin은 보통 NotNull타입의 값에 대해 널 안정성을 검사하지만 플랫폼 타입의 값에 대해서는 경고하지않음 12345678910//Javapublic class Person&#123; private final String name; public Person(String name)&#123; this.name = name; &#125; public String getName()&#123; return name; &#125;&#125; 1234567891011//Kotlinfun yellAtSafe(person: Person) &#123; println(person.name.toUpperCase() + \"!!!\") //toUpperCase()의 수신객체의 person.name이 non-null인데 null이라 컴파일 에러 println((person.name ?: \"Anyone\").toUpperCase() + \"!!!\") //ANYONE!!!&#125;fun main(args: Array&lt;String&gt;) &#123; yellAtSafe(Person(null))&#125; 전부 다 널이 될 수 있는 타입으로 하면 되지않을까? 모든 자바 타입을 널이 될 수 있는 타입으로 처리하기엔 널 안정성 검사로 인해 얻는 이익보다 쓸데없는 비용이 늘어나 프로그래머에게 타입의 널 가능성의 책임을 부여함. 1.10 상속 자바클래스를 코틀린에서 상속할때, 파라미터나 반환타입의 Null처리를 결정해야함 1234//Javainterface StringProcessor&#123; void process(String value);&#125; 123456789101112//Kotlinclass StringPrinter : StringProcessor&#123; override fun process(value: String)&#123; // notnull 선언 println(value) &#125;&#125;class NullableStringPrinter : StringProcessor&#123; override fun process(value: String?)&#123; //nullable 선언 value?.let&#123;println(it)&#125; &#125;&#125; 2. 코틀린의 원시 타입 Kotlin은 원시타입과 참조타입을 구분하지 않고, 항상 같은 타입을 사용 대부분, Kotlin의 Int타입은 Java의 int 타입으로 컴파일 되고, Int를 타입인자로 넘기는 경우 Integer로 컴파일된다. 2.1 null이 될 수 있는 원시타입 : Int?, Boolean? 등 코틀린에서 null이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일 된다. Ex.) 123456789101112data class Person(val name: String, val age: Int? = null) &#123; fun isOlderThan(other: Person) : Boolean? &#123; if (age == null || other.age == null) return null return age &gt; other.age &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; println(Person(\"Sam\", 35).isOlderThan(Person(\"Amy\", 42))) //false println(Person(\"Sam\", 35).isOlderThan(Person(\"Jane\"))) //null&#125; age는 컴파일러에 의해 널 안정성 검사를 마친 후 값을 비교가 허용되므로, age의 프로퍼티값은래퍼 타입으로 저장된다. 2.2 숫자 변환 Kotlin은 Boolean을 제외한 모든 원시 타입에 대한 변환 함수를 제공 Kotlin은 한 타입의 숫자를 다른 타입으로 자동변환 하지 않음. 명시적으로 변환 메소드를 사용해야함 12345678910111213141516171819val i = 1val l = Long = i // \"Error: type mismatch\" 컴파일 오류 발생val i = 1val l: Long = i.toLong() // 명시적으로 변환 메소드 사용---------------------------명시 이유---------------------------val x = 1 // Intval list = listOf(1L, 2L, 3L) // Long 리스트 x in list // 묵시적 타입 변환으로 인해 falseval x = 1println(x.toLong() in listOf(1L, 2L, 3L)) //truefun foo(l: Long) = pinrtln(l)val b: Byte = 1 // 상수 값는 적절한 타입으로 해석 된다.val l = b + 1L // +는 Byte와 Long을 인자로 받을 수 있다.foo(42) // 함수 인자이므로 42를 Long으로 해석한다. 2.3 Any, Any? : 최상위 타입 Java는 Object, Kotlin은 Any가 널이 될 수 없는 타입의 최상위타입 내부적으로 Any는 자바의 java.lang.Object로 컴파일 된다. 모든 코틀린 클래스에는 toString, equals, hashCode 라는 3개의 메소드가 있다. 하지만 java.lang.Object에 있는 다른 메소드(wait나 notify 등)는 Any에서 사용할 수 없다. 그런 메소드를 사용하고 싶다면 java.lang.Object로 캐스트해야 한다. 2.4 Unit 타입 : Kotlin의 void Kotlin의 Unit타입은 Java의 void와 같은 기능을 함. 12fun f(): Unit&#123;...&#125;fun f()&#123;...&#125; //fun의 기본 선언은 void라고 생각 Ex.) void 와Unit의 차이 반환 타입으로 Unit을 반환가능 타입 매개변수로 Unit을 쓸 수 있다 123456789101112131415161718interface Processor&lt;T&gt; &#123; fun process(): T&#125;//반환 타입으로 Unit을 묵시적으로 반환 가능class NoResultProcessor : Processor&lt;Unit&gt; &#123; override fun process() &#123; // 업무 처리 코드 &#125;&#125;class ResultProcessor : Processor&lt;Integer&gt; &#123; override fun process(): Int &#123; // 업무 처리 코드 return someInt &#125;&#125; Kotlin은 왜 void가 아닌 Unit을 만들었을까? Kotlin의 Unit은 Java의 void와 다르게 두 가지 특징을 가진다 Unit은 싱글톤 인스턴스이다. 그래서 Kotlin에서 Unit이라는 키워드는 타입이면서도 동시에 객체 1val unit : Unit = Unit Unit은 객체이기도 하기때문에 Any를 상속하는 서브 클래스이다. 1val unit : Any = Unit 2.5 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다. 함수가 정상적으로 끝나지 않는 사실을 표현할 때 사용 Nothing 타입은 아무 값도 포함하지 않음 = return이라는 행위 자체를 하지않음 Ex. 1) 함수가 리턴 될 일이 없을 경우 12345fun infiniteLoop(): Nothing &#123; while (true) &#123; println(\"Hi there!\") &#125;&#125; Ex. 2) 예외를 던지는(throw Exception)함수의 리턴 타입 123fun throwException(): Nothing &#123; throw IllegalStateException()&#125; Ex. 3) 함수의 리턴 타입이 Nothing? 일 경우 123456789101112131415fun mayThrowAnException(throwException: Boolean): Nothing? &#123; return if (throwException) &#123; throw IllegalStateException() &#125; else &#123; println(\"Exception not thrown :)\") null &#125;&#125;fun main() &#123; val result = mayThrowAnException(true) if (result == null) &#123; // Always true println(\"Ignored code\") &#125;&#125; 3. 컬렉션과 배열 3.1 널 가능성과 컬렉션 Ex.1)null이 될 수 있는 값으로 이뤄진 컬렉션 1234567891011121314151617181920212223242526272829303132333435fun readNumbers(reader: BufferedReader): List&lt;Int?&gt; &#123; val result = ArrayList&lt;Int?&gt;() for (line in reader.lineSequence()) &#123; try &#123; val number = line.toInt() result.add(number) &#125; catch(e: NumberFormatException) &#123; result.add(null) &#125; &#125; return result&#125;fun addValidNumbers(numbers: List&lt;Int?&gt;) &#123; var sumOfValidNumbers = 0 var invalidNumbers = 0 for (number in numbers) &#123; if (number != null) &#123; sumOfValidNumbers += number &#125; else &#123; invalidNumbers++ &#125; &#125; println(\"Sum of valid numbers: $sumOfValidNumbers\") println(\"Invalid numbers: $invalidNumbers\")&#125;fun main(args: Array&lt;String&gt;) &#123; val reader = BufferedReader(StringReader(\"1\\nabc\\n42\")) val numbers = readNumbers(reader) addValidNumbers(numbers) //Sum of valid numbers: 43 //Invalid numbers: 1 &#125; List&lt;Int?&gt; 과 List?과 List&lt;Int?&gt;? 잘 구분해서 쓸 것! 3.2 읽기 전용과 변경 가능한 컬렉션 Kotlin 컬렉션은 자바와 다르게 읽기 전용 컬렉션(Collection)과 변경가능 컬렉션(MutableCollection)이 분리되어있다. Ex) Collection(size, iterator(), contains()) / MutableCollection(add(), remove(), clear()) 12345678910111213fun &lt;T&gt; copyElements(source: Collection&lt;T&gt;, target: MutableCollection&lt;T&gt;) &#123; for (item in source) &#123; target.add(item) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val source: Collection&lt;Int&gt; = arrayListOf(3, 5, 7) val target: MutableCollection&lt;Int&gt; = arrayListOf(1) copyElements(source, target) println(target) //[1, 3, 5, 7]&#125; Ex) Thread-safe하지않은 읽기전용 Collection 12345678910111213141516171819//MutableCollection이 Collection 참조val collection: Collection&lt;Int&gt; = arrayListOf(1, 2, 3)val mutableCollection: MutableCollection&lt;Int&gt; = collectionerror: type mismatch: inferred type is Collection&lt;Int&gt; but MutableCollection&lt;Int&gt; was expected// Collection이 MutableCollection 참조val mutableCollection: MutableCollection&lt;Int&gt; = arrayListOf(1, 2, 3)val collection: Collection&lt;Int&gt; = mutableCollection //가능 &gt;&gt;&gt; collection[1, 2, 3]&gt;&gt;&gt; mutableCollection[1, 2, 3]&gt;&gt;&gt; mutableCollection.add(5)&gt;&gt;&gt; mutableCollection[1, 2, 3, 5]&gt;&gt;&gt; collection[1, 2, 3, 5] // mutalbeCollection에 5를 추가했지만 collection에도 영향을 미친다// 같은 객체를 다른 타입의 참조들이 가리키고 있다. 따라서, ConcurrentModificationException등의 오류가 발생할 수 있으므로, 다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화 하거나 동시 접근을 허용하는 데이터 구조를 활용해야한다. 3.3 코틀린 컬렉션과 자바 코틀린에서 읽기 전용인 Collection으로 선언된 객체라도 자바코드에서는, 이를 구분하지 않으므로 수정가능 코틀린 컴파일러가 컬렉션이 어떤 일을 하는지 정확한 분석이 어려움 어차피 ImmutableList가 나와도 자바로 가면 변경이 가능하니 차라리 변경 가능한 컬렉션을 넘기고 명시를 정확히 해두는 것이 좋다. 12345678910//Javapublic class CollectionUtils &#123; public static List&lt;String&gt; uppercaseAll(List&lt;String&gt; items) &#123; for (int i = 0; i &lt; items.size(); i++) &#123; items.set(i, items.get(i).toUpperCase()); &#125; return items; &#125;&#125; 1234567891011//Kotlinfun printInUppercase(list: List&lt;String&gt;) &#123; println(CollectionUtils.uppercaseAll(list)) println(list.first())&#125;fun main(args: Array&lt;String&gt;) &#123; val list = listOf(\"a\", \"b\", \"c\") printInUppercase(list) //[A, B, C] //A&#125; 3.4 자바의 콜렉션 타입을 플랫폼 타입으로 다루기 자바의 콜렉션 타입은 읽기전용이나 변경 가능으로 다룰 수 있음 시그니처에서 콜렉션 타입을 사용한 자바 메서드를 오버라이드할 경우 코틀린 타입 선택 필요 선택 사항 컬렉션이 널이 될 수 있는가? 컬렉션의 원소가 널이 될 수 있는가? 오버라이드하는 메서드가 컬렉션을 변경할 수 있는가? 자바 인터페이스나 클래스가 어떤 맥락에서 사용되는지 정확히 알아야한다. 3.5 객체의 배열과 원시타입의 배열 코틀린에서 배열을 만드는 방법 arrayOf : 함수에 원소를 넘김 1234fun main(args: Array&lt;String&gt;) &#123; val strings = listOf(\"a\", \"b\", \"c\") println(\"%s/%s/%s\".format(*strings.toTypedArray())) // a/b/c&#125; arrayOfNuls : 원소타입이 널이 될 수 있는 타입인 경우에만 호출할 수 있고, 인자에 배열의 크기를 넘김 1val nullStorableArray = arrayOfNulls&lt;String&gt;(3) Array() : 배열의 크기와 람다를 인자로 받아, 람다를 호출하여 각 배열 원소를 초기화 1234fun main(args: Array&lt;String&gt;) &#123; val squares = IntArray(5) &#123; i -&gt; (i+1) * (i+1) &#125; println(squares.joinToString()) //1, 4, 9, 16, 25&#125; 참고 Kotlin In Action Made by iyj9328","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"},{"name":"Kotlin in Action","slug":"Kotlin-in-Action","permalink":"https://woovictory.github.io/tags/Kotlin-in-Action/"}]},{"title":"[Kotlin in Action] Chap5. 람다","slug":"KotlinInAction-Chap5","date":"2020-04-02T06:27:53.000Z","updated":"2020-05-12T15:17:17.696Z","comments":true,"path":"2020/04/02/KotlinInAction-Chap5/","link":"","permalink":"https://woovictory.github.io/2020/04/02/KotlinInAction-Chap5/","excerpt":"","text":"람다 식 | 람다 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다. 람다 식과 멤버 참조 람다는 자바 8에 도입되어 자바에서도 비로소 람다를 사용할 수 있게 되었다. 람다 소개: 코드 블록을 함수 인자로 넘기기 [자바에서 익명 클래스를 통해 버튼 클릭 리스너 구현] 1234567/* 자바 */button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View view) &#123; /* 클릭시 동작 */ &#125;&#125;); [람다로 리스너 구현] 1button.setOnClickListener &#123; /* 클릭시 동작 */&#125; 두 구현은 동일한 동작이지만 람다를 이용한 경우 코드가 훨씬 간결하고 읽기 쉬워진다. 람다와 컬렉션 [컬렉션에서 가장 큰 값 찾기: 직접 구현] 12345678910111213141516fun findTheOldest(people: List&lt;Person&gt;) &#123; var maxAge = 0 var theOldest: Person? = null for (person in people) &#123; if (person.age &gt; maxAge) &#123; maxAge = person.age theOldest = person &#125; &#125; println(theOldest)&#125;val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))findTheOldest(people)// 결과: Person(name=Bob, age=31) [컬렉션에서 가장 큰 값 찾기: 람다 이용] 123456val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))println(people.maxBy &#123; it.age &#125;) // 나이 프로퍼티를 비교해서 가장 큰 원소 찾기// 결과: Person(name=Bob, age=31)println(people.maxBy(Person::age)) // 나이 프로퍼티를 비교해서 가장 큰 원소 찾기// 결과: Person(name=Bob, age=31 자바 컬렉션에 대해 (자바 8 이전, 람다 지원 전) 수행하던 대부분의 불편했던 작업들은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선이 가능하다. 이렇게 개선된 후에는 코드가 한결 짧아지고 더 이해하기 쉬워졌다. 람다 식의 문법 12&#123; x: Int, y: Int -&gt; x + y &#125;// 파라미터 -&gt; 본문 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다. 추가로 람다를 따로 선언해서 변수에 저장도 가능하다. 그렇다곤 해도 보통은 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다. 123val sum = &#123; x: Int, y: Int -&gt; x + y&#125; // 람다식 변수에 저장println(sum(1, 2)) // 변수에 저장된 람다식 호출// 결과: 3 심지어는 람다식을 직접 호출도 가능하다. 12&#123; println(42) &#125;()// 결과: 42 굳이 이렇게 쓰는 것보다는 가독성 때문에라도 람다 본문을 직접 실행하는 편이 낫다. 123// 인자로 받은 람다를 실행해주는 라이브러리 함수인 run을 사용하여 람다 본문 실행run &#123; println(42) &#125;// 결과: 42 코틀린 람다 식은 항상 중괄호로 둘러싸여있다. 인자 목록 주변에 괄호가 없다. 화살표(-&gt;)를 통해 인자 목록과 람다 본문을 구분한다. 람다식 사용 예제 123456789101112val people = listOf(Person(\"Alice\", 29), Person(\"Bob\", 31))// 인자가 한 개고 타입 추론 가능하면 디폴트 이름인 it 사용 가능println(people.maxBy &#123; it. age &#125;)people.maxBy(&#123; p: Person -&gt; p.age&#125;)// 람다가 마지막 인자면, 괄호 밖에 위치 가능people.maxBy() &#123; p: Person -&gt; p.age&#125;// 람다가 마지막 인자고, 괄호 뒤에 람다를 썼을 경우 괄호 생략 가능people.maxBy &#123; p: Person -&gt; p.age&#125; 간단한 경우라면 괄호 없이 람다식만으로 명시해도 나쁘지 않을 것으로 생각되지만 웬만하면 괄호를 사용하여 해당 람다식이 메소드에 포함된 람다식이라는 것을 확실히 하는 것이 가독성에 더 좋을 것 같다. 이름 붙인 인자를 사용해 람다 넘기기 1234567val people = listOf(Person(\"이몽룡\", 29), Person(\"성춘향\", 31))val names = people.joinToString(seprator = \" \", transform = &#123; p: Person -&gt; p.name &#125;)println(names)// 결과: 이몽룡 성춘향// 괄호 밖으로 처리val names = people.joinToString(\" \") &#123; p: Person -&gt; p.name&#125; 개인적인 생각이지만 이 예제를 보니 개인적인 프로젝트에서 특정 메소드에 대한 완벽한 이해가 있고 람다식을 사용하는 곳도 완벽한 이해가 있는 경우에는 람다식을 괄호 밖으로 빼서 표현하는 것이 코드도 간결하고 보기도 더 좋지만 협업을 하는 상황이라면 누구라도 코드를 이해하기 쉽도록 괄호를 사용하여 일반적인 메소드 호출을 이용하여 람다식을 표현하는 것이 더 좋을 것으로 생각된다. 람다 파라미터 타입 제거하기 123456people.maxBy &#123; p: Person -&gt; p.age &#125; // 파라미터 타입 명시people.maxBy &#123; p -&gt; p.age &#125; // 파라미터 타입 생략 (컴파일러가 추론)// 변수에 람다식 담는 경우 컴파일러가 타입 추론 불가val getAge = &#123; p: Person -&gt; p.age &#125;people.maxBy(getAge) 컴파일러는 람다 파라미터의 타입도 추론 할 수 있다. people은 Person을 담은 컬렉션이므로 컴파일러는 Person 객체가 파라미터로 들어올 것을 추론할 수 있다. 컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있으나 이번 장에서는 다루지 않는다. 단, 람다식을 변수에 담는 경우 파라미터의 타입을 추론할 문맥이 존재하지 않으므로 파라미터를 명시해야만 한다. 디폴트 파라미터 이름 it 사용하기 1people.maxBy &#123; it.age &#125; it는 자동 생성된 파라미터 이름이다. 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it를 사용할 수 있다. 람다 내에 람다가 중첩되는 경우나 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에는 파라미터를 명시적으로 선언하는 것이 가독성에 더 좋다. 본문이 여러줄로 이뤄진 람다식 1234val sum = &#123; x: Int, y: Int -&gt; println(\"Computing the sum of $x and $y...\") x + y&#125; 본문이 여러줄로 이루어진 경우 맨 마지막에 있는 식이 람다식의 결과값이 된다. 현재 영역에 있는 변수에 접근 12345678910fun printMessageWithPrefix(messages: Collection&lt;String&gt;, prefix: String) &#123; messages.forEach &#123; println(\"$prefix $it\") // 람다 내부에서 함수의 \"prefix\" 변수 사용 &#125;&#125;// &gt;&gt;&gt; val errors = listOf(\"403 Forbidden\", \"404 Not Found\")// &gt;&gt;&gt; printMessagesWithPrefix(errors, \"Error:\")// 결과: Error: 403 Forbidden// Error: 404 Not Found 람다를 함수 안에서 정의하면 함수의 파라미터에 접근이 가능하다. 뿐만 아니라 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다. 1234567891011121314151617fun printProblemCounts(response: Collection&lt;String&gt;) &#123; var clientErrors = 0 // 람다 외부에 로컬 변수 선언 var serverErrors = 0 // 람다 외부에 로컬 변수 선언 response.forEach &#123; if (it.startsWith(\"4\")) &#123; clientErrors++ // 람다 내부에서 외부의 로컬 변수 값 변경 &#125; else if (it.startsWith(\"5\")) &#123; serverErrors++ // 람다 내부에서 외부의 로컬 변수 값 변경 &#125; &#125; println(\"$ClientErrors client errors, $serverErrors server errors\")&#125;// &gt;&gt;&gt; val responses = listOf(\"200 OK\", \"418 I'm a teapot\", \"500 Internal Server Error\"// &gt;&gt;&gt; printProblemCounts(responses)// 결과: 1 client errors, 1 server errors 람다 내부에서는 final 변수가 아닌 변수에 접근이 가능하다. 람다 내부에서 람다 외부의 변수 변경도 가능하다. 람다 내부에서 사용하는 람다 외부 변수를 람다가 포획한 변수라고 부른다. (위 예제들의 prefix, clientErrors, serverErrors) 람다를 실행 시점에 표현하는 데이터 구조는 람다에서 시작하는 모든 참조가 포함된 닫힌(closed) 객체 그래프를 람다 코드와 함께 저장해야 한다. 그런 데이터 구조를 클로저(closure) 라고 부른다. 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야 하고, 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다. 그래서 람다를 클로저라고 부르기도 한다. TODO 무슨 말인지 이해가 가지 않는다… 코틀린 스터디 팀원들에게 물어보고 내용을 추가하도록 하자…! 로컬 변수의 생명주기와 함수의 생명주기가 다른 경우 (예를 들면, 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장하는 경우가 있다.) 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다. final 변수인 경우: 람다 코드를 변수 값과 함께 저장하여 함수가 끝난 뒤에도 포획한 변수에 접근이 가능하다. final 변수가 아닌 경우: 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다. 코틀린에서도 자바와 같이 약간의 꼼수(?)로 변경 가능한 변수를 포획하게 된다. 12345678// 실제 코드var counter = 0val inc = &#123; counter++ &#125;// 내부 동작을 보여주는 코드class Ref&lt;T&gt;(var value: T)val counter = Ref(0)val inc = &#123; counter.value++ &#125; Ref 라는 클래스로 래핑하여 해당 클래스를 final 하게 선언하고 그 내부에 멤버 변수에 counter 값을 저장한다. 그 이후 람다식에서는 클래스의 변수값에 접근하여 변경 가능한 변수를 포획한다. 람다를 이벤트 핸들러 등 비동기 실행 코드로 활용하는 경우 12345fun tryToCountButtonClicks(button: Button): Int &#123; var clicks = 0 button.onClick &#123; clicks++ &#125; return clicks&#125; 람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다는 점을 인지해 유의하여 사용해야 한다. 위 예시 코드에서 해당 함수는 항상 0을 반환한다. onCiick 핸들러는 버튼이 클릭될 때마다 clicks 변수를 증가시키지만 그 때에는 함수 호출이 종료된 이후이기 때문이다. 즉, 해당 clicks 변수를 확인할 수 있도록 클래스의 프로퍼티나 전역 프로퍼티 등의 위치로 빼서 나중에 해당 변수를 확인할 수 있도록 해야 한다. 멤버 참조 이미 선언된 함수를 값으로 사용해야 할 때 멤버 참조 :: 를 사용하면 된다. 123456789101112131415161718192021// 모두 같은 동작people.maxBy(Person::age) // 멤버 참조people.maxBy &#123; p -&gt; p.age &#125;people.maxBy &#123; it.age &#125;fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult // 확잠 함수도 동일하게 멤버 참조를 사용할 수 있음fun salute() = println(\"Salute!\")run(::salute) // 최상위 함수 참조// 결과: Salute!// sendEmail 함수에게 작업 위임val action = &#123; person: Person, message: String -&gt; sendEmail(person, message) &#125;// 람다 대신 멤버 참조 사용val nextAction = ::sendEmail// 생성자 참조data class Person(val name: String, val age: Int)val createPerson = ::Person // 생성자 참조 저장val p = createPerson(\"Alice\", 29) // 생성자 참조를 이용해 인스턴스 생성 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다. :: 는 클래스 이름과 참조하려는 멤버(프로퍼티나 메소드) 이름 사이에 위치한다. 멤버 참조 뒤에는 괄호를 넣으면 안된다. (메소드여도!!) 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다. 최상위 함수, 최상위 프로퍼티 참조도 가능하다. 클래스 이름을 생략하고 :: 로 참조를 바로 시작하면 된다. 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다. :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다. 바운드 멤버 참조 (1.1부터 사용 가능) 1234567891011// 1.0 멤버 참조val p = Person(\"Dmistry\", 34)val personAgeFunction = Person::ageprintln(personAgeFunction(p))// 결과: 34// 1.1 바운드 멤버 참조val p = Person(\"Dmistry\", 34)val ageFunction = p::age // p에 엮인 멤버 참조println(ageFunction())// 결과: 34 TODO 바운드 멤버 참조는 한 인스턴스에 대해서만 동작이 될 것으로 생각이 드는데 이걸 사용할만한 곳이 있을까? 하는 의문이 든다. 컬렉션 함수형 API 필수적인 함수: filter와 map filter 함수 12345678val list = listOf(1, 2, 3, 4)println(list.filter &#123; it % 2 == 0 &#125;) // 짝수만 filtering// 결과: [2, 4]val personList = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterList = personList.filter &#123; it.age &gt; 30 &#125;println(filterList)// 결과: [Person(name=Bob, age=31)] 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 true인 원소를 모은다. 만족하는 원소들을 모아 새로운 컬렉션으로 반환한다. map 함수 12345678910111213val list = listOf(1, 2, 3, 4)println(list.map &#123; it * it &#125;) // 자기자신을 곱함// 결과: [1, 4, 9, 16]val personList = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val mapList = personList.map &#123; it.age &#125; // 나이만으로 컬렉션을 만듦println(mapList)// 결과: [31, 29]// 멤버 참조 사용val memberRefMapList = personList.map(Person::name)println(memberRefMapList)// 결과: [Bob, Alice] 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다. filter + map 조합 123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterAndMap = list.filter &#123; it.age &gt; 30 &#125;.map &#123; it.name &#125;// 결과: [Bob] 연쇄로 호출하여 사용도 가능하다. maxBy + filter 조합 123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val filterAndMaxBy = list.filter &#123; it.age == list.maxBy(Person::age)!!.age&#125;// 결과: [Person(name=Bob, age=31)] 위 코드의 단점은 filter가 이터레이션하기 때문에 maxby 함수가 컬렉션 수 만큼 호출되며 처리된다는 것이다. 개선해보면… 123val list = listOf(Person(\"Bob\", 31), Person(\"Alice\", 29))val maxAge = list.maxBy(Person::age)!!.ageval filterAndMaxBy = list.filter &#123; it.age == maxAge &#125; 이터레이션 된다는 것을 항상 기억하고 불필요한 작업을 반복하지 않도록 유의해야 한다. 컬렉션 맵에서의 filter, map 123456789101112131415val numbers = mapOf(0 to \"zero\", 1 to \"one\", 2 to \"two\", 3 to \"three\", 4 to \"four\")val filterValuesMap = numbers.filterValues &#123; it == \"zero\"&#125;val mapValuesMap = numbers.mapValues &#123; it.value.toUpperCase() &#125;println(filterValuesMap)println(mapValuesMap)val filterKeysMap = numbers.filterKeys &#123; it == 1 &#125;val mapKeysMap = numbers.mapKeys &#123; it.key % 2 &#125;println(filterKeysMap)println(mapKeysMap)// 결과: filterValuesMap = &#123;0=zero&#125;// mapValuesMap = &#123;0=ZERO, 1=ONE, 2=TWO, 3=THREE, 4=FOUR&#125;// filterKeysMap = &#123;1=one&#125;// mapKeysMap = &#123;0=four, 1=three&#125; 맵에서의 filter와 map은 별도의 API가 존재한다. 맵의 filterValues, filterKeys 의 it 는 각각 value와 key를 가르킨다. 컬렉션에 술어 사용: all, any, count, find 12345678910111213val list = listOf(Person(\"Alice\", 27), Person(\"Bob\", 31), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))// 술어 선언val canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= 27 &#125;println(\"all: $&#123;list.all(canBeInClub27)&#125;\")println(\"any: $&#123;list.any(canBeInClub27)&#125;\")println(\"count: $&#123;list.count(canBeInClub27)&#125;\")println(\"find: $&#123;list.find(canBeInClub27)&#125;\")// 결과: all: false// any: true// count: 3// find: Person(name=Alice, age=27) all: 컬렉션의 모든 원소가 조건을 만족하는지 판단 any: 컬렉션의 모든 원소 중 하나라도 조건을 만족하는지 판단 count: 조건을 만족하는 원소의 갯수를 반환 find: 조건을 만족하는 첫 번째 원소를 반환, 만족하는 원소가 없을 경우 null을 반환 함수형 API 사용시 고려할 점 함수형 API count 와 컬렉션에 포함된 함수 size() 의 차이? count의 경우 조건을 만족하는 원소의 개수만 추적할 뿐 원소를 따로 저장하지 않는다. size()의 경우 만족하는 원소를 가진 객체를 생성 시키게 된다. 위 예제 코드의 결과에서 보듯이 all과 any는 서로 부정으로 대응한다. 하지만 가독성을 이유로 any 대신 !all 이나 all 대신 !any는 사용하지 않는 것이 좋다. groupBy 12345678910val list = listOf(Person(\"Alice\", 27), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))println(\"groupBy: $&#123;list.groupBy &#123; it.age &#125;&#125;\")// 결과: groupBy: &#123;27=[Person(name=Alice, age=27), Person(name=WooVictory, age=27)], // 25=[Person(name=hzoou, age=25)], // 28=[Person(name=txxbro, age=28), Person(name=iyj, age=28)]&#125;val strs = listOf(\"12\", \"345\", \"11\", \"456\")println(strs.groupBy &#123; it.length &#125;)// 결과: &#123;2=[12, 11], 3=[345, 456]&#125; groupBy: 리스트를 특정 기준에 맞춰 맵으로 변경하여 반환 flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리 1234567891011121314151617val strings = listOf(\"abc\", \"def\")println(strings.flatMap &#123; it.toList() &#125;)//결과: [a, b, c, d, e, f]data class Book(val title: String, val authors: List&lt;String&gt;)val books = listOf(Book(\"책1\", listOf(\"작가1\")), Book(\"책2\", listOf(\"작가2\", \"작가3\")), Book(\"책3\", listOf(\"작가4\", \"작가1\")))println(\"toSet(): $&#123;books.flatMap &#123; it.authors &#125;.toSet()&#125;\")println(\"기본: $&#123;books.flatMap &#123; it.authors &#125;&#125;\")// 결과: toSet(): [작가1, 작가2, 작가3, 작가4]// 기본: [작가1, 작가2, 작가3, 작가4, 작가1]println(\"flatten(): $&#123;books.map &#123; it.authors &#125;.flatten()&#125;\")// 결과: flatten(): [작가1, 작가2, 작가3, 작가4, 작가1] flatMap: 인자로 주어진 람다를 컬렉션의 모든 객체에 적용(매핑)하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 모은다(flatten). 즉, 리스트의 리스트가 있을 때 중첩된 리스트의 원소를 한 리스트로 모을 때 사용한다. toSet(): 컬렉션의 중복을 제거리 flatten(): 변환할 내용 없이 펼치기만 하는 경우 사용 책에서 다루지 않은 이외에도 많은 컬렉션 API가 존재한다. 이외의 API 는 Kotlin Collection Reference 를 참고하자. 지연 계산(lazy) 컬렉션 연산 콜렉션의 연산자(e.g. map, filter)는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다. 시퀀스(sequence)를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다. 1poeple.map(Person::name).filter &#123; it.startsWith(\"A\") &#125; map과 filter는 둘 다 리스트를 반환한다. 즉 위 코드에서 연쇄 호출로 인해 리스트를 2개 만들어졌다. 123people.asSequence() // 원본 컬렉션을 시퀀스로 변환 .map(Person::name).filter &#123; it.startsWith(\"A\")&#125; .toList() // 결과 시퀀스를 다시 리스트로 변환 시퀀스의 원소는 필요할 때 비로소 계산되기 때문에 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해 효율적으로 계산을 수행할 수 있다. asSequence(): 어떤 컬렉션이든 시퀀스로 바꿀 수 있다. toList(): 시퀀스를 리슷트로 바꿀 때 사용한다. 리스트 대신에 시퀀스를 쓰는 것이 더 낫지 않은가? “항상 그렇지는 않다.” 인덱스를 사용해 접근하는 등 다른 API 메소드를 사용하기 위해서는 리스트로 변환해야 한다. 시퀀스 연산 실행: 중간 연산과 최종 연산 중간 연산과 최종 연산은 p225의 그림 5.7을 참고하자. 중간 연산: 다른 시퀀스를 반환하며 최초 시퀀스의 원소를 변환하는 방법을 알고 있다. 항상 지연 계산된다. 즉, 최종 연산을 하지 않으면 계속 지연이 되어 결과를 반환하지 않는다. 최종 연산: 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자, 객체이다. 즉시 계산의 수행 순서와 지연 계산의 수행 순서 12345678910111213141516171819202122232425// eagerlylistOf(1, 2, 3, 4).map &#123; println(\"eagerly map($it)\"); it * it &#125; .filter &#123; println(\"eagerly filter($it)\"); it % 2 == 0 &#125;// 결과: eagerly map(1)// eagerly map(2)// eagerly map(3)// eagerly map(4)// eagerly filter(1)// eagerly filter(4)// eagerly filter(9)// eagerly filter(16)// lazylistOf(1, 2, 3, 4).asSequence() .map &#123; println(\"lazy map($it)\"); it * it&#125; .filter &#123; println(\"lazy filter($it)\"); it % 2 == 0 &#125; .toList()//결과: lazy map(1)// lazy filter(1)// lazy map(2)// lazy filter(4)// lazy map(3)// lazy filter(9)// lazy map(4)// lazy filter(16) 즉시 계산의 경우 모든 원소에 대해 먼저 map을 끝낸 후 이후 filter를 수행하게 된다. 시퀀스(지연 계산)의 경우 각 원소에 대해 순차적으로 적용이 된다. p226의 그림 5.8을 참고하자. map과 filter 호출 순서에 따른 성능 차이의 발생 1234567val list = listOf(Person(\"Alice\", 27), Person(\"hzoou\", 25), Person(\"txxbro\", 28), Person(\"iyj\", 28), Person(\"WooVictory\", 27))list.asSequence().map(Person::name) // map 먼저 실행 .filter &#123; it.length &lt; 4 &#125;.toList()list.asSequence().filter &#123; it.length &lt; 4 &#125; // filter 먼저 실행 .map(Person::name).toList() p227의 그림 5.9를 참고하자. filter 보다 map을 호출할 경우 map은 모든 원소를 변환하므로 더 많은 이터레이션이 발생하게 된다. 자바 스트림과 코틀린 시퀀스 비교 자바 8의 스트림과 코틀린의 시퀀스는 개념적으로 같다. 다만, 자바 8일 경우 코틀린 컬렉션과 시퀀스에서 제공하지 않는 스트림 연산(map과 filter)을 여러 CPU에서 병렬적으로 실행하는 기능이 존재한다. 그렇기 때문에 자바 버전에 따라서 시퀀스와 스트림 중에 적절한 것을 사용하면 된다. 자바 8에 대해서는 다른 개발자의 블로그의 글인 자바 8 스트림 이란? 을 참고하자. 시퀀스 만들기 1234567891011// 첫번째 인자: 초기값 / 두번째 인자: 다음 값 생성 로직val numbers = generateSequence(0) &#123; it + 1 &#125; // 시퀀스 생성val numbersTo100 = numbers.takeWhile &#123; it &lt;= 100 &#125; // while loop 시퀀스 생성println(numbersTo100.sum()) // 위의 모든 시퀀스는 sum의 결과를 계산할 때 수행된다.// 결과: 5050// File의 확장함수 선언fun File.isInsideHiddenDirectory() = generateSequence(this) &#123; it.parentFile &#125;.any &#123; it.isHidden &#125;val file = File(\"/Users/svtk/.HiddenDir/a.txt\")println(file.isInsideHiddenDirectory())// 결과: true generateSequence: 이전의 원소를 인자로 받아 다음 원소를 계산하는 시퀀스를 만드는 함수 최종 연산인 sum() 을 호출 하기 전에는 계산되지 않다가 최종 연산이 호출될 때에 계산이 수행된다. 자바 함수형 인터페이스 활용 함수형 인터페이스 추상 메소드가 단 하나 있는 인터페이스를 함수형 인터페이스 또는 SAM(단일 추상 메소드, Single Abstract method) 인터페이스라고 한다. 12345678910// java 8 이전 익명클래스로 표현button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; /* TODO */ &#125;&#125;)// java 8 이후 함수형 인터페이스를 람다로 표현button.setOnClickListener &#123;view -&gt; /* TODO */&#125; 자바에서는 함수형 인터페이스 즉, SAM 인터페이스인 경우 자바 8버전 이후 람다를 이용하여 더 간결하게 표현할 수 있다. (코틀린도 너무나 당연하게 사용 가능하다.) 자바 메소드에 람다를 인자로 전달 12// java 함수형 인터페이스를 인자로 전달void postponeComputation(int delay, Runnable computation); 123456789// 위의 자바 코드에 코틀린에서 람다를 전달하여 호출postponeComputation(1000) &#123; println(42) &#125; // 함수형 인터페이스에 람다를 전달// 객체 식을 전달postponeComputation(1000, object: Runnable &#123; override fun run() &#123; println(42) &#125;&#125;) 컴파일러는 자동으로 람다를 Runnable 인스턴스(Runnable을 구현한 익명 클래스 인스턴스)로 변환하여 전달한다. Runnable을 구현하는 무명 객체를 명시적으로 만들어서 사용하는 것도 가능하다. 람다를 넘길 때와 무명 객체를 생성하여 넘길 때의 차이점? 무명 객체를 생성하여 넘기는 경우, 메소드를 호출할 때마다 새로운 인스턴스가 생성된다. 생성된 Runnable 인스턴스는 단 하나만 생성되며 메소드 호출 시 반복 사용된다. 단, 람다 내에서 람다 외부의 변수를 포획하는 경우에는 무명 객체처럼 새로운 인스턴스가 생성된다. Java 8 언어 기능과 Jack을 활성화 방법 app 단 build.gradle 내에 compileOptions 를 통해 지정해준다. 코틀린 컴파일 시 자바 8 바이트 코드생성 방법 jvm-target 1.8 이라고 kotlinc 호출할 때 커맨드라인에서 옵션 설정을 지정 메이븐이나 그래들 프로젝트 설정에 명시 SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경 컴파일러가 자동으로 람다를 함수형 인터페이스 익명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용한다. 1234567891011val listener = OnClickListener &#123; view -&gt; val text = when (view.id) &#123; R.id.button1 -&gt; \"First button\" R.id.button2 -&gt; \"Second button\" else -&gt; \"Unknown button\" &#125; toast(text)&#125;button1.setOnClickListener(listener)button2.setOnClickListener(listener) 람다와 리스너 등록/해제 람다는 코드 블럭이기 때문에 this 가 없다. 즉, 객체처럼 익명 클래스의 인스턴스를 참조할 수 없다. 람다 내에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가르킨다. 주의하자. 리스너를 가르키고 싶다면 람다가 아닌 무명 객체를 사용해야 한다. 무명 객체 내에서 this는 객체 인스턴스 자신을 가르킨다. 수신 객체 지정 람다: with와 apply 자바의 람다에는 없는, 코틀린 람다만의 독특한 기능인 수신 객체 지정 람다는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다. with 함수 with 함수는 파라미터가 2개인 메소드로 첫 번째 인자는 객체를 두 번째 인자는 람다를 받는다. 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다. 12345678910fun alphabet(): String &#123; val sb = StringBuilder() return with(sb) &#123; for (letter in 'A'..'Z') &#123; this.append(letter) // this를 통해 수신 객체에 접근 &#125; append(\"\\nNow I know alphabet!\") // this 없이 수신 객체의 메소드 호출 this.toString() // 람다에서 값 반환 &#125;&#125; 수신 객체 지정 람다는 확장 함수와 비슷한 동작을 정의하는 한 방법이다. &lt;T, R&gt; with(receiver: T, block: T.() ‐&gt; R): block 함수의 수신 객체는 T apply 함수 apply 함수는 with 함수와 동일한 동작이지만 항상 자신에게 전달된 객체(수신 객체)를 반환한다. 123456fun alphabet() = StringBuilder().apply &#123; for (letter in 'A'..'Z') &#123; append(letter) &#125; append(\"\\nNow I know the alphabet!\")&#125;.toString() fun &lt;T&gt; T.apply(block: T.() ‐&gt; Unit): T: apply 함수는 확장 함수로 정의되어 있다. 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화 해야 하는 경우 유용하다. apply를 이용해 TextView 만들면서 초기화 하기 123456fun createViewWithCustomAttributes(context: Context) = TextView(context).apply &#123; text = \"Sample Text\" // this 생략하여 TextView의 프로퍼티 사용 textSize = 20.0 setPadding(10, 0, 0, 0) // this 생략하여 TextView의 멤버 함수 사용 &#125; buildString 함수 buildString 함수는 StringBuilder 객체를 만들어 toString()을 호출해주는 작업을 해준다. 123456fun alphabet() = buidlString &#123; for (letter in 'A'..'Z') &#123; append(letter) &#125; append(\"\\nNow I know the alphabet!\")&#125; 참고 Kotlin In Action 탤로우 월드#Kotlin","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"},{"name":"Kotlin in Action","slug":"Kotlin-in-Action","permalink":"https://woovictory.github.io/tags/Kotlin-in-Action/"}]},{"title":"[Kotlin in action] Chap4. 클래스와 인터페이스","slug":"KotlinInAction-Chap4","date":"2020-04-01T11:26:32.000Z","updated":"2020-05-12T15:17:07.923Z","comments":true,"path":"2020/04/01/KotlinInAction-Chap4/","link":"","permalink":"https://woovictory.github.io/2020/04/01/KotlinInAction-Chap4/","excerpt":"","text":"목차 클래스와 인터페이스 뻔하지 않은 생성자와 프로퍼티 데이터 클래스 클래스 위임 object 키워드 사용 4.1.1 코틀린 인터페이스 인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다. 12345678910interface Clickable&#123; fun onClick() fun showOff() = println(\"Show~\") // 디폴트 구현. &#125;class Button : Clickable &#123; override fun onClick() = println(\"Hi~\")&#125;Button().onClick() 클래스 이름 뒤에 콜론(:)을 붙여 인터페이스와 클래스 이름을 적는 것으로 상속과 인터페이스 구현을 모두 처리한다. 자바 : extends, implements 자바와 마찬가지로 다중 구현은 허용되지만, 다중 상속은 불가능하다. @Override 어노테이션과 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 한다는 뜻이다. 다만, override 변경자는 코틀린에서 꼭 표시해야 한다. 디폴트 구현을 제공할 수 있으며, 특별한 키워드를 붙이지 않고 메소드 본문을 적어주면 된다. 이 경우, Clickable을 구현하는 하위 클래스에서 showOff를 새롭게 정의할 수도 있고, 정의를 생략해서 디폴트 구현을 사용할 수도 있다. 아래 코드를 함께 보자. 1234interface Focusable&#123; fun setFocus() = ... fun showOff() = println(\"I'm Focus\")&#125; 이제 한 클래스에서 Clickable, Focusable 두 인터페이스를 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현이 들어있다. 결론은 어느 쪽의 showOff() 메소드도 호출되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 아래와 같은 컴파일 오류가 발생한다. The class ‘Button’ must override public open fun showOff() because it inherits many implementations of it. 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 강제한다. 1234567class Button: Clickable, Focusable&#123; override fun onClick() = ... override fun showOff()&#123; super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() &#125;&#125; 즉, 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 존재하는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다. 자바와 달리 상위 타입의 이름을 꺽쇠 괄호(&lt;&gt;) 사이에 넣어서 super를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다. 4.1.2 open, final, abstract 변경자 자바에서는 기본적으로 상위 클래스에 대해 하위 클래스에서 상속하는 걸 막지 않는다. 막기 위해서는 final을 붙여 상속을 할 수 없게 한다. 기본적으로 상속이 가능하면 편리하지만, 문제가 생기는 경우도 있다. 취약한 기반 클래스 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 존재한다. 즉, 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다. 이런 점을 보완하기 위해 코틀린에서는 클래스와 메소드는 기본적으로 final이다. 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 붙일 수 있다. 12345678910open class RichButton : Clickable&#123; fun disable() open fun animate() override fun onClick() final override fun onClick() // 오버라이드한 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 막을 수 있다.&#125; RichButton 클래스는 다른 클래스가 상속할 수 있다.(open) disable() : final이며, 오버라이드 할 수 없다. animate() : oepn으로 오버라이드 가능. onClick() : 상위 클래스에서 선언된 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다. abstract로 선언한 추상 클래스는 인스턴스화 할 수 없으며, 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야 하는게 보통이다. 추상 멤버는 항상 열려 있기 때문에 open 변경자를 명시할 필요가 없다. Todo 표 추가 4.1.3 가시성 변경자 코틀린의 기본 가시성은 자바와 다르며, 아무 변경자도 없는 경우 public이다. 자바의 기본 가시성인 package private이 없다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다. 코틀린은 internal이라는 새로운 가시성을 도입했다. 이는 모듈 내부에서만 볼 수 있음을 뜻한다. 모듈 : 한 번에 한꺼번에 컴파일되는 파일들을 의미한다. 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다. 코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다. ? 모듈에 대해 생각해볼 필요가 있어 보인다. 변경자 클래스멤버 최상위 선언 public 모든 곳에서 볼 수 있다. 모든 곳에서 볼 수 있다. internal 같은 모듈 안에서만 볼 수 있다. 같은 모듈 안에서만 볼 수 있다. protected 하위 클래스에서만 볼 수 있다. 적용할 수 없음. private 같은 클래스 안에서만 볼 수 있다. 같은 파일 안에서만 볼 수 있다. Ex) 12345678910internal open class TalkativeButton: Focusable&#123; private fun yell() = println(\"Hey~\") protected fun wishper() = println(\"Let's talk!\")&#125;fun TalkativeButton.giveSpeech()&#123; yell() whisper()&#125; public 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출함 Public 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다. 이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다. 이는 일반적인 규칙에 해당한다. yell은 private이라 접근이 불가능. whisper는 상속 관계에서 하위 클래스만 접근이 가능. 따라서 불가능. 컴파일 오류를 없애기 위해서는 TalkativeButton을 public으로 바꾸거나 giveSpeech 확장 함수의 가시성을 internal로 바꾸면 된다. 자바와 달리 코틀린에서의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다는 사실을 알아야 한다. 코틀린의 가시성 변경자와 자바 코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트 코드 안에서도 그대로 유지된다. 유일한 예외는 private이며, 자바에서는 클래스를 private으로 만들 수 없으므로 코틀린은 내부적으로 private 클래스는 package private으로 컴파일한다. internal은 자바에서 딱 맞는 가시성이 없다. package private과는 다르다. 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어있을 수도 있다. 따라서 internal은 자바 바이트 코드에서 public이 된다. 코틀린과 자바 선언에 차이가 존재하기 때문에 다음과 같은 접근이 가능하다. 다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근 가능. protected로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서 접근 가능. 4.1.4 내부 클래스와 중첩된 클래스 12345678910111213141516171819202122interface State: Serializableinterface View&#123; fun getCurrentState(): State fun restoreState(state: State)&#123;&#125;&#125;class Button : View&#123; override fun getCurrentState(): State = ButtonState() override fun restoreState(state: State)&#123; ... &#125; class ButtonState: State&#123; ... &#125; // 내부 클래스 inner ButtonState: State&#123; &#125;&#125; 코틀린에서 ButtonState는 중첩 클래스에 해당되며 아무런 변경자가 붙지 않으면 자바의 static 중첩 클래스와 같다. 따라서 바깥쪽 클래스에 대한 참조가 없고, 이로 인해서 직렬화가 가능하다. 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하고 싶으면 inner 변경자를 붙이면 된다. 이렇게 되면 NoSerializableException: Button 이라는 예외가 발생한다. 왜 Button을 직렬화할 수 없을까? 내부 클래스는 바깥쪽 클래스에 대한 참조를 포함한다. 그 참조로 인해 직렬화할 수 없다. Button 클래스가 직렬화할 수 있는 상태가 아니기 때문에 결론적으로 ButtonState도 직렬화할 수 없는 것이다. 📌 알고 넘어가기~ 내부 클래스 : 바깥쪽 클래스에 대한 참조를 갖는다. 중첩 클래스 : 바깥쪽 클래스에 대한 참조를 갖지 않는다. 클래스 B안에 정의된 클래스 A 자바에서는 코틀린에서는 중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음) Static class A class A 내부 클래스(바깥쪽 클래스에 대한 참조를 저장함) class A inner class A 4.1.5 Sealed Class 기존에는 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 그래서 새로운 클래스에 대한 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 버그가 발생할 가능성이 높다. 해법을 제공한다. 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다. sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다. Sealed 클래스는 자동으로 open이다. 12345678910sealed class Expr&#123; class Num(val value: Int): Expr() class Sum(val left: Expr, val right: Expr): Expr()&#125;fun eval(e: Expr): Int = when(e)&#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.left) + eval(e.right) &#125; When 식이 모든 하위 클래스를 검사하므로 else 분기가 없어도 된다. 클래스 외부에 sealed 클래스 자신을 상속한 클래스를 둘 수 없다. 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가하면 when 식이 컴파일되지 않는다. 따라서 식을 고쳐야 한다는 사실을 파악하기 쉽다. 내부적으로 Expr 클래스는 private 생성자를 갖는다. 그 생성자는 클래스 내부에서만 호출할 수 있다. [뻔하지 않은 생성자와 프로퍼티] 주 생성자 : 클래스를 초기화할 때, 주로 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다. 부 생성자 : 클래스 본문 안에서 정의한다. 4.2.1 클래스 초기화 : 주 생성자와 초기화 블록 1class User(val name: String) 중괄호도 없고 괄호 사이에 val만 존재한다. 이처럼 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드는 주 생성자라 부른다. 주 생성자는 생성자 파라미터를 정의하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다. 123456class User constructor(_nickname: String)&#123; val nickname: String init&#123; nickname = _nickname &#125;&#125; Constructor : 주 생성자나 부 생성자 정의를 할 때 사용되며, 주 생성자의 경우 어노테이션이나 가시성 변경자가 없으면 생략해도 된다. Init : 초기화 블록으로 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다. 초기화 블록은 주 생성자와 함께 쓰인다. 이유는 주 생성자가 제한적이기 때문에 별도의 코드를 포함할 수 없기 때문! 123class User(_nickname: String)&#123; val nickname = _nickname&#125; 이처럼 초기화 블록 없이 프로퍼티 선언에 초기화를 포함시킬 수 있다. 그렇다면 더 간단하게 할 수 있을까? 아래의 코드를 보자. 1234567class User(val nickname: String)&#123; ...&#125;fun main(args: Array&lt;String&gt;)&#123; val lee = User(\"VictoryWoo\") // new 없이 바로 생성자 호출!&#125; 주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다. 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 사용할 수 있다. 12345open class User(val name: String)&#123; ... &#125;class TwitterUser(name: String) : User(name)&#123; ...&#125; 상위 클래스 초기화를 위해서 클래스 뒤에 괄호 안에 생성자로 인자를 넘긴다. 12345open class Buttoninterface Clickclass RadioButton: Button()class CustomView : Click Button : 별도의 생성자를 정의하지 않아 컴파일러가 자동으로 아무 일도 하지 않는 인자 없는 디폴트 생성자를 만든다. RadioButton : Button 클래스를 상속했기 때문에 Button의 생성자를 호출해야 한다. CustomView : Click이 인터페이스이므로 이름만 명시. 4.2.2 부 생성자 코틀린의 디폴트 값 + 이름 있는 인자를 사용해 생성자가 여럿 있는 경우 처리가 가능하다. 인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말고 대신 파라미터의 디폴트 값을 생성자 시그니처에 명시하라. 12345678910111213141516171819202122232425open class View&#123; constructor(context: Context)&#123; ... &#125; constructor(context: Context, attr: AttributeSet)&#123; ... &#125;&#125;class MyButton : View&#123; constructor(context: Context) : super(context)&#123; ... &#125; // 디폴트 값을 넘겨 같은 클래스의 다른 생성자 호출. constructor(context: Context) : this(context, WOO_STYLE)&#123; ... &#125; constructor(context: Context, attr: AttributeSet) : super(context, attr)&#123; ... &#125;&#125; MyButton에서는 super()를 통해 상위 클래스의 생성자를 호출함으로써 객체 생성을 위임한다. 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다. 프로퍼티란? 코틀린은 프로퍼티를 언어의 기본 기능으로 제공. 이는 필드와 접근자를 통칭하는 것이다. 즉, 데이터를 저장하고 get, set이 가능함을 의미한다. 1class Person(val name: String, var isMarried: Boolean) 코틀린의 기본 가시성은 public이기 때문에 getter, setter도 동일하게 가져간다. 그런데, 필드에 저장된 데이터의 가시성은 public이 아니다. 생성자에 선언된 데이터는 private이 된다. Q. 외부에서 Person 객체를 생성한 뒤, name, isMarried에 접근이 가능할까?? — 고민의 시간 — [반면, 일반 클래스 필드에 넣은 데이터는 private으로 지정해주지 않을 경우 public이 된다.] 라고 하는데 확인해 본 결과 필드에 넣은 데이터 또한 private으로 선언되며, getter가 public으로 지정된다. 선언된 데이터가 private이 된다는 것은 자바 코드로 변환했을 때, 필드의 선언이 private이 되며 getter, setter는 public인 상태가 된다는 것을 의미한다. 만약, 생성자의 프로퍼티를 private으로 지정한다면 getter, setter도 private이 되어 접근이 불가능하다. (위의 질문에 대한 답이 된다.) [생성자 파라미터의 val, var의 차이] 123class Person(val name: String) // 1class Person(name: String) // 2 1번의 경우 자바 코드로 변환되면 아래와 같다. ![스크린샷 2020-02-27 오후 3.09.35](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.09.35.png) 생성자에 있는 name은 프로퍼티가 되며, 외부에서도 접근이 가능하다. 2번의 경우 자바 코드로 변환시 아래와 같다. ![스크린샷 2020-02-27 오후 3.10.03](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.10.03.png) 이 경우 name은 생성자에서 프로퍼티를 초기화하는 역할만을 하고, 사용할 수 없다. 따라서 클래스의 생성자 외 다른 메소드에서 사용할 수 없다. (프로퍼티가 아니기 때문) [주의할 점] 위에서 설명했지만, 한번 더 짚고 넘어간다. 디컴파일한 자바 코드를 보면 필드가 private으로 되어 있는 것을 볼 수 있다. 이렇다고 하더라도 코틀린의 프로퍼티가 private은 아니다. 여기서 우리는 필드와 프로퍼티를 다르게 인식할 줄 알아야 한다. 자바는 기본적으로 필드로 다루고, 코틀린은 프로퍼티(필드+접근자)를 기본으로 다루는 언어이기 때문에 약간의 차이가 존재한다. 1class Person(val name: String) 123456789101112131415public class Person&#123; private String name; public Person(String name) &#123; this.name = name; &#125; public Void setName(String value) &#123; this.name = value; &#125; public String getName() &#123; return this.name; &#125;&#125; 필드인 name 자체만 보면 private 키워드가 붙어있으므로 private이 맞지만, 프로퍼티 전체를 보면 다르다. getter/setter로 접근이 모두 가능하기 때문에 프로퍼티는 private하다고 볼 수 없다. 위의 코드에서 name 프로퍼티가 private이기 위해서는 아래와 같이 수정해야 한다. 1class Person(private val name: String) 123456789public final class Person &#123; private String name; public Property(@NotNull String name) &#123; Intrinsics.checkParameterIsNotNull(name, \"name\"); super(); this.name = name; &#125;&#125; getter/setter가 없어 프로퍼티는 private이라고 볼 수 있다. 참고 4.2.3 인터페이스에 선언된 프로퍼티 구현 123interface User&#123; val name: String&#125; 인터페이스에 추상 프로퍼티 선언이 있고, 상태를 저장하기 위해서는 해당 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다. 아래는 각기 다른 방식으로 이를 구현한다. 12345678910111213class PrivateUser(override val nickname: String): User// 주 생성자에 있는 프로퍼티class SubscribingUser(val email: String): User&#123; override val name: String get() = email.substringBefore('@')&#125;// 커스텀 게터class FacebookUser(val accountId: Int): User&#123; override val nickname = getFacebookNam(accountId)&#125;// 프로퍼티 초기화 식 SubscribingUser : nickname은 매번 호출될 때마다 substringBefore()를 호출해 새로운 값을 계산하는 커스텀 getter를 사용한다. FacebookUser : nickname은 객체 초기화 시 계산한 데이터를 저장했다가 불러오는 방식을 이용한다. 4.2.4 게터와 세터에서 뒷받침하는 필드 접근 1234567891011121314class User(val name: String) &#123; var address: String = \"unspecified\" set(value: String) &#123; println(\"\"\" Address was changed for $name: \"$field\" -&gt; \"$value\".\"\"\".trimIndent()) field = value &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user = User(\"Alice\") user.address = \"Elsenheimerstrasse 47, 80687 Muenchen\"&#125; setter 접근자의 본문에서 field를 통해 뒷받침하는 필드에 접근할 수 있다.(address) getter는 field 값을 읽을 수만 있고, setter는 field 값을 읽거나 쓸 수 있다. 4.2.5 접근자의 가시성 변경 1234567891011121314class LengthCounter &#123; var counter: Int = 0 private set fun addWord(word: String) &#123; counter += word.length &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val lengthCounter = LengthCounter() lengthCounter.addWord(\"Hi!\") println(lengthCounter.counter)&#125; 기본 가시성을 가지는 getter를 컴파일러가 생성하게 냅두고 setter의 가시성을 private으로 지정하여 외부 코드에서 단어 길이의 합을 마음대로 바꾸지 못하게 하였다. [컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임] 4.3.1 모든 클래스가 정의해야 하는 메소드 자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다. 알고 넘어가기! 자바는 == 를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교하고, 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다. 따라서 자바에서 두 객체의 동등성을 알려면 equals()를 호출해야 한다. 코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다. ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 따라서 클래스가 equals()를 오버라이드하면 == 을 통해 안전하게 클래스의 인스턴스를 비교할 수 있다. 참조 비교를위해서는. === 연산자를 사용할 수 있다. === 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 ==와 같다. 4.3.2 data class 1data class Client(val name: String, val postalCode: Int) class 앞에 data를 붙이면 자동으로 toString(), copy(), equals(), hashCode()를 포함한다. 이를 데이터 클래스라고 부르며 주로 데이터를 저장하는 역할을 한다. 주의할 점은 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니다. [copy() 메소드] 데이터 클래스의 프로퍼티가 모두 val일 필요는 없다. var여도 된다. 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어 불변 클래스로 만들라고 권장한다. 불변의 장점 : 다중 스레드에서 동기화를 고려하지 않아도 됨. Copy() : 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해준다. 객체를 메모리 상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다. 4.3.3 클래스 위임 : by 인터페이스를 구현할 때, by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다. 123class DelegatingCollection&lt;T&gt;(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; by innerList &#123; &#125; 컴파일러가 전달 메소드를 자동으로 생성하며, 자동 생성한 코드의 구현은 책에 실린 코드와 비슷하다. Collection의 구현을 innerList에게 위임한다. 메소드 중 일부의 동작을 변경하고 싶을 때는 메소드를 오버라이드 하면 컴파일러가 오버라이드한 메소드를 쓴다. Ex) 123456789101112131415161718192021222324import java.util.HashSetclass CountingSet&lt;T&gt;( val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()) : MutableCollection&lt;T&gt; by innerSet &#123; var objectsAdded = 0 override fun add(element: T): Boolean &#123; objectsAdded++ return innerSet.add(element) &#125; override fun addAll(c: Collection&lt;T&gt;): Boolean &#123; objectsAdded += c.size return innerSet.addAll(c) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val cset = CountingSet&lt;Int&gt;() cset.addAll(listOf(1, 1, 2)) println(\"$&#123;cset.objectsAdded&#125; objects were added, $&#123;cset.size&#125; remain\")&#125; add, addAll을 오버라이드해서 count를 증가시키고 MutableCollection 인터페이스의 나머지 메소드는 내부 컨테이너인 innerSet에게 위임한다. CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 생기지 않는다. CountingSet 코드는 위임 대상 내부 클래스인 MutableCollection의 API를 활용하므로 API를 변경하지 않는 한 CountingSet 코드가 계속 잘 작동할 것임을 확신할 수 있다. -&gt; CountingSet의 생성자 파라미터에 존재하는 innerSet 프로퍼티에게 MutableCollection의 구현을 위임했기 때문에 CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 없다. innerSet이 MutableCollection에 의존 관계를 가지고 있다. object 키워드 : 클래스 선언과 인스턴스 생성 4.4.1 객체 선언 : 싱글톤 12345678object Payroll&#123; val allEmployees = arrayListOf&lt;Person&gt;() fun calculateSalary()&#123; for(person in allEmployees)&#123; ... &#125; &#125;&#125; object를 통해 기본적으로 싱글톤 기능을 언어 레벨에서 제공한다. 객체 선언 = 클래스 선언 + 그 클래스에 속한 단일 인스턴스의 선언 생성자는 쓸 수 없다. 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문에 생성자 정의가 필요없다. object 선언도 클래스나 인터페이스 상속이 가능하다. 클래스 안에 object 선언도 가능하다. 이 객체도 인스턴스는 단 하나뿐이다. (바깥쪽 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 따로 하나씩 생기는 것이 아니다.) 4.4.2 동반 객체 kotlin에서는 static 개념이 존재하지 않는다. 패키지 수준의 최상위 함수가 정적 메소드 역할을 대신할 수 있다. 객체 선언은 정적 필드를 대신할 수도 있다. 최상위 함수를 권장하지만, 클래스에 비공개 멤버를 포함하면 이 멤버에 접근할 수 없다. 그래서 클래스의 인스턴스와 관계 없이 호출해야 하지만, 클래스 내부 정보에 접근해야 할 때 companion object를 사용하면 된다. companion object는 외부 클래스의 private한 멤버 접근이 가능하기 때문에 팩토리 메소드를 만들 때 유용하다. 1234567891011class A &#123; companion object &#123; fun bar() &#123; println(\"Companion object called\") &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; A.bar()&#125; 호출할 때, 클래스 이름으로 바로 호출이 가능하다. 이름을 따로 지정하지 않아도 되며, 사용 예를 보면 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다. 즉, 자바의 static 함수 호출과 동일하다. Ex) 부 생성자가 여럿 있는 클래스 1234567891011class User&#123; val nickname: String constructor(email: String)&#123; nickname = email.substringBefore('@') &#125; constructor(accountId: Int)&#123; nickname = getFacebookName(accountId) &#125;&#125; 팩토리 메소드로 부 생성자 대신하기 12345678910111213class User private constructor(val nickname: String)&#123; companion object&#123; fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(accountId:Int) = User(getFacebookName(accountId)) &#125;&#125;fun main(args: Array&lt;String&gt;)&#123; val user = User.newSubscribinUser(\"Victory@gmail.com\") println(user.nickname) // Victory&#125; User는 private constructor를 가지기 때문에 외부에서 생성하지 못한다. 따라서 외부에서는 companion object로 제공되는 팩토리 메소드를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다. 4.3.3 동반 객체를 일반 객체처럼 사용 동반 객체 = 클래스 안에 정의된 일반 객체 따라서 아래와 같은 작업이 가능하다. companion object 이름 명명 가능. companion object 내부에 확장 함수와 프로퍼티 정의 인터페이스 상속 12345678910111213class Person(val name: String)&#123; companion object Loader&#123; fun fromJson(json: String) : Person &#123; ... &#125; &#125;&#125;fun main(args: Array&lt;String&gt;)&#123; Person.Loader.fromJson(\"&#123;name: 'Lee'&#125;\") Person.fromJson(\"&#123;name: 'Lee'&#125;\")&#125;// 두 방법 모두 제대로 fromJson을 호출할 수 있다. 12345678910111213141516171819interface JSONFactory&lt;T&gt; &#123; fun fromJSON(json: String): T&#125;class Person(val name: String) &#123; companion object : JSONFactory&lt;Person&gt; &#123; override fun fromJSON(json: String): Person &#123; return Person(\"Lee\") &#125; &#125;&#125;fun &lt;T&gt; loadFromJSON(factory: JSONFactory&lt;T&gt;): T? &#123; return null&#125;fun main() &#123; loadFromJSON(Person)&#125; 위의 예제처럼 companion object가 특정 인터페이스를 구현할 수도 있고, 동반 객체가 구현한 JSONFactory 인터페이스를 넘길 때 Person 클래스(외부 클래스)의 이름을 사용한다. 알고 넘어가기! 때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다. 그런 경우 @JvmStatic 어노테이션을 코틀린 멤버에 붙이면 된다. 정적 필드가 필요하다면 @JvmField 어노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다. 이는 10장에서 더 자세히 알아보자! 동반 객체를 이용해 외부에서 확장 함수를 정의할 수 있다고 했다. 아래 코드를 통해서 확인해보자. 12345678910111213class Person(val name: String)&#123; companion object&#123; &#125;&#125;fun Person.Companion.fromJSON(json: String) : Person&#123; // 확장 함수 정의.&#125;fun main()&#123; Person.fromJSON(\"json\")&#125; 마치 동반 객체 안에 fromJSON을 정의한 것처럼 함수를 호출할 수 있다. 동반 객체에 대한 확장 함수를 정의하기 위해서는 원래 클래스에 동반 객체를 꼭 선언해야 한다.(비어있어도 괜찮다.) 4.4.4 무명 클래스 무명 객체를 정의할 때도 object 키워드를 쓴다. 무명 객체는 자바의 무명 내부 클래스를 대신한다. 1234567891011121314151617181920212223interface ClickListener&#123; fun onClick()&#125;val listener = object : ClickListener&#123; override fun onClick()&#123; println(\"Clicked Listener!!\") &#125;&#125;fun main()&#123; setClickAction(object: ClickListener&#123; override fun onClick()&#123; println(\"Clicked!!\") &#125; &#125;) setClickAction(listener)&#125;fun setClickAction(clickListener: ClickListener)&#123; clickListener.onClick()&#125; object 선언과 달리 익명 클래스는 싱글톤이 아니다. 따라서 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다. 또한, 무명 객체 즉, 익명 클래스 안에서 함수에 정의된 로컬 변수를 사용할 수도 있다. 자바와 조금 다른 점이다. 자바는 익명 클래스에서 접근 시 무조건 final이어야 한다. 참고 Kotlin In Action Made by Me","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"},{"name":"Kotlin in Action","slug":"Kotlin-in-Action","permalink":"https://woovictory.github.io/tags/Kotlin-in-Action/"}]},{"title":"[Kotlin in action] Chap3. 함수 정의와 호출","slug":"KotlinInAction-Chap3","date":"2020-04-01T11:02:44.000Z","updated":"2020-05-12T15:16:58.308Z","comments":true,"path":"2020/04/01/KotlinInAction-Chap3/","link":"","permalink":"https://woovictory.github.io/2020/04/01/KotlinInAction-Chap3/","excerpt":"","text":"함수 정의와 호출 코틀린 컬렉션 123456789val set = hashSetOf(1, 7, 53)val list = listOf(1, 7, 53)val map = hashMapOf(1 to \"one\", 7 to \"seven\", 53 to \"fifty-three\")fun main(args: Array&lt;String&gt;) &#123; println(set.javaClass) //class java.util.HashSet println(list.javaClass) //class java.util.ArrayList println(map.javaClass) //class java.util.HashMap&#125; 자바 컬렉션을 활용한 코틀린 컬렉션 자바보다 더 많은 기능을 쓸 수 있음 1234val strings = listOf(\"first\", \"second\", \"fourteenth\")println(strings.last()) //fourteenthval numbers = setOf(1, 14, 2)println(numbers.max()) //14 last(), max() 는 코틀린에서 편의를 위해 추가한 확장함수 직관적인 함수 호출 toString()함수 응용한 함수 1234567891011121314151617181920212223242526fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String, prefix: String, postfix: String): String &#123; val result = StringBuilder(prefix) for ((index, element) in collection.withIndex()) &#123; if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1, 2, 3) val alphabets = listOf(\"a\", \"b\", \"c\") println(joinToString(list, separator = \"; \", prefix = \"(\", postfix = \")\")) println(joinToString(alphabets, separator = \"; \", prefix = \"(\", postfix = \")\")) //(1; 2; 3) //(a; b; c)&#125; 인자 이름 &amp; 기본 파라미터 값 인자의 이름을 명시 가능 Java 1joinToString(collection, /* separator */ \"\", /* prefix */ \"\", /*postfix */ \".\"); Kotlin 1joinToString(collection, prefix = \"(\", separator = \";\", postfix = \")\") 차이점? 파라미터 이름이 같다면 순서를 바꿔도 가능! 주의! 자바에서 작성한 코드를 코틀린에서 호출한 경우에는 인자 이름 명시 불가능! 함수 파라미터에 정보를 넣는 것은 자바 8이후, 코틀린은 JDK 6과 호환! 기본 파라미터 값 초기화 1234567891011121314151617181920fun &lt;T&gt; joinToString( collection : Collection&lt;T&gt;, separator: String = \", \", prefix: String = \"\", postfix: String = \"\"): String &#123; ...&#125; fun main(args: Array&lt;String&gt;) &#123; val list = listOf(1, 2, 3) println(joinToString(list)) //1, 2, 3 println(joinToString(list, separator = \";\")) //1;2;3 println(joinToString(list, separator = \"; \", prefix = \"(\")) //(1; 2; 3 println(joinToString(list, separator = \"; \", prefix = \"(\", postfix = \")\")) //(1; 2; 3;) &#125; 값을 지정하지 않은 모든 인자는 디폴트 값을 적용 주의! 자바에는 디폴트 파라미터 값이라는 개념이 없기때문에 코틀린 함수를 자바에서 호출하는 경우 @JvmOverloads 애노테이션을 추가하면 컴파일러가 자동으로 오버로딩 함수 생성 최상위 함수와 프로퍼티 최상위 함수 Java 12345package strings;public class JoinKt&#123; public static String joinToString(...)&#123;...&#125;&#125; Kotlin 123package stringsfun joinToString(...)&#123;...&#125; 자바에서 함수 호출 1234import strings.JointKt; ... JoinKt.joinToStirng(list,\",\",\"\",\"\"); 파일에 대응하는 클래스 이름 변경 123//코틀린@file:JvmName(\"StringFunctions\") //패키지명 선언보다 이전에 위치package strings 123//자바에서 호출import strings.StringFunctions;StringFunctions.joinToString(list, \",\", \"\", \"\"); UtilClass를 대신해서 사용할 수 있다는 장점이 있다고 했는데, Util이 더 편하지않나…? 최상위 프로퍼티 123456var cnt; //최상위 프로퍼티fun performOperation()&#123; //최상위 함수 cnt++&#125;... 프로퍼티를 클래스보다 더 이전에 위치 최상위 프로퍼티도 접근자 메소드를 통해 접근가능 const 변경자를 추가하면 public static final 필드로 만들 수 있다. 확장함수와 확장 프로퍼티 클래스의 멤버 메서드처럼 호출되지만 클래스 밖에 호출되는 함수 확장함수를 만들기 위해서는 수신객체타입(Receiver Type)과 수신객체(Receiver Object)가 필요 123fun String.lastChar() : Char = this.get(this.length - 1)println(\"Kotlin\".lastChar())//n 수신객체타입(Receiver Type): 확장이 정의될 클래스 ex) String 수신객체(Receiver Object): 위 클래스의 인스턴스 객체 ex)“Kotlin”, this 확장함수 안에서는 private나 protected 접근 불가능, 해당 클래스의 public함수에만 접근 가능 확장함수의 Import 확장함수를 사용하기 위해서는 import를 통해서 사용 123import strings.lastChar //import strings.*val c = \"Kotlin\".lastChar() 주의! : 한 클래스 내의 같은 이름의 확장함수가 둘 이상일 경우 이름이 충돌할 수 있으니 as를 사용 12import strings.lastChar as lastval c = \"Kotlin\".last() joinToString함수를 이용한 확장함수 1234567891011121314151617181920212223242526fun &lt;T&gt; Collection&lt;T&gt;.joinToString( separator: String = \", \", prefix: String = \"\", postfix: String = \"\"): String &#123; val result = StringBuilder(prefix) for ((index, element) in this.withIndex()) &#123; //this는 수신객체 if (index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;//문자열의 컬렉션만 받음fun Collection&lt;String&gt;.join( separator: String = \", \", prefix: String = \"\", postfix: String = \"\") = joinToString(separator, prefix, postfix)fun main(args: Array&lt;String&gt;) &#123; println(listOf(\"one\", \"two\", \"eight\").join(\" \")) //one two eight&#125; 내부적으로 확장함수는 수신객체를 첫 번째 인자로 받음 자바에서 호출시 수신객체를 첫 번째 인자로 넘겨줘야함 확장함수의 오버라이드 멤버함수 오버라이드 123456789101112open class View &#123; open fun click() = println(\"View clicked\") //멤버함수&#125;class Button: View() &#123; override fun click() = println(\"Button clicked\")&#125;fun main(args: Array&lt;String&gt;) &#123; val view: View = Button() view.click() //Button Clicked&#125; 확장 함수가 정적 메소드와 같은 특징을 가지므로 확장함수를 하위 클래스에서 오버라이드 할 수 없다. 123456789101112131415open class View &#123; open fun click() = println(\"View clicked\") //멤버함수&#125;class Button: View() &#123; override fun click() = println(\"Button clicked\")&#125;fun View.showOff() = println(\"I'm a view!\") //확장함수fun Button.showOff() = println(\"I'm a button!\") //확장함수fun main(args: Array&lt;String&gt;) &#123; val view: View = Button() view.showOff() //I'm a view!&#125; 확장 함수는 클래스의 밖에 선언되며 확장함수 호출 시, 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장함수가 올 지 결정되는 것이지, 변수의 객체에 저장된 동적인 타입에 의해 확장 함수가 결정되지 않는다. &lt;그림 3.2 참고&gt; TODO - 알고가자! open class : 코틀린에서의 모든 클래스는 암시적으로 상위 클래스로 Any클래스를 가지는데,명시적으로 상위클래스를 지정하기 위해서는 open을 명시 멤버메서드? 정적메서드? 확장메서드? 특정 클래스에 추가된 확장함수가 멤버함수와 이름이 같다면 우선순위는 멤버함수 &gt; 확장함수 확장 프로퍼티 12345678val String.lastChar : Char get() = get(length - 1) //getter만var StringBuilder.lastChar : Char get() = get(length - 1) set(value : Char)&#123; this.setChartAt(length - 1, value) &#125; 일반 프로퍼티와 같은데 대신 수신객체클래스가 추가 되었을 뿐 확장 프로퍼티는 backing field를 가지고 있지않으니 최소한 getter()는 구현해야 함. 컬렉션 처리 가변인자함수 1234val numbers = listOf(1,2,3,4,5)val strings = listOf(\"1\", \"2\", \"3\")fun listOf&lt;T&gt;(vararg var: T) : List&lt;T&gt;&#123;...&#125; vararg를 변경자로 선언타입 앞에 붙임 123456789fun printNumbers(vararg numbers: Int) &#123; for (number in numbers) &#123; println(number) &#125;&#125;val numbers = intArrayOf(1, 2, 3)printNumbers(*numbers)printNumbers(10, 20, *numbers, 30, 40) 자바의 스프레드 연산자: ... / 코틀린의 스프레드 연산자 * 배열(Array)을 함수에 전달할 수 있다. 중위 호출 121 to \"one\" //중위함수 호출1.to(\"one\") //확장함수 호출 중위함수 to 1infix fun Any.to(other : Any) = Pair(this, other) // to는 중위함수이자 확장함수 구조 분해 선언(7장에서 자세히 다룸) data class 형태로 나오는 여러 값을 동시에 반환할 수 있다. 자동으로 componentN함수가 생성됨. 123for ((index, element) in this.withIndex()) &#123; //this는 수신객체 Collection&lt;Int&gt; / (1, 2, 3) println(\"$index: $element\")&#125; 1234567891011data class Size(val width : Int, val height : Int)fun main()&#123; val size = Size(10, 20) val (w, h) = size val a = size.component1() val b = size.component2() println(a) // 10 println(b) // 20&#125; 문자열과 정규식 문자열 나누기 / split() 123//String.ktpublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List&lt;String&gt; = regex.split(this, limit)public fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List&lt;String&gt; &#123;...&#125; 1234println(\"12.345-6.A\".split(\"\\\\.|-\".toRegex())) //정규식을 파라미터로 받는 함수//[12, 345, 6, A]println(\"12.345-6.A\".split(\".\", \"-\")) //String을 파라미터로 받는 함수//[12, 345, 6, A] 마침표 . 를 문자로 읽기위해 \\\\.을 사용하여 escape 시킴 코틀린에서는 split()의 확장함수를 제공함으로써 Java의 와일크카드 문자(?)로 인한 혼동을 피함. 정규식 표현 https://regexr.com/, https://ihateregex.io/playground에서 찾으면 쉽다. 정규식과 3중 따옴표 123456789101112131415161718fun parsePath(path: String) &#123; val regex = \"\"\"(.+)/(.+)\\.(.+)\"\"\".toRegex() //group#1: /Users/yole/kotlin-book //group#2: chapter //group#3: adoc val matchResult = regex.matchEntire(path) if (matchResult != null) &#123; val (directory, filename, extension) = matchResult.destructured // val directory = matchResult.destructured.component1() // val filename = matchResult.destructured.component2() // val extension = matchResult.destructured.component3() println(\"Dir: $directory, name: $filename, ext: $extension\") &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; parsePath(\"/Users/yole/kotlin-book/chapter.adoc\")&#125; 3중 따옴표를 사용하면, \\, \\n등을 포함한 어떤 문자도 따로 escape 시킬 필요가 없다. 주의! : 역슬래쉬(\\)나 줄바꿈(\\n)등을 3중 따옴표 안에 넣으면 문자로 인식해서 그냥 출력된다. 중첩함수(Local method) 함수에서 추출한 함수를 원 함수 내부에 중첩시키는 것을 말함. 코드중복을 보여주는 예제 //아직 중첩함수 X 1234567891011121314151617181920class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) &#123; if (user.name.isEmpty()) &#123; //-----------검증 중복 throw IllegalArgumentException( \"Can't save user $&#123;user.id&#125;: empty Name\") &#125; if (user.address.isEmpty()) &#123; //------------검증 중복 throw IllegalArgumentException( \"Can't save user $&#123;user.id&#125;: empty Address\") &#125; // Save user to the database&#125;fun main(args: Array&lt;String&gt;) &#123; saveUser(User(1, \"\", \"\")) //Can't save user $&#123;user.id&#125;: empty Name&#125; 중첩함수를 이용한 중복 줄이기 123456789101112131415161718192021class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) &#123; fun validate(user: User, //중첩함수 validate(...)선언 value: String, fieldName: String) &#123; if (value.isEmpty()) &#123; throw IllegalArgumentException( \"Can't save user $&#123;user.id&#125;: empty $fieldName\") &#125; &#125; validate(user, user.name, \"Name\") validate(user, user.address, \"Address\") // Save user to the database&#125;fun main(args: Array&lt;String&gt;) &#123; saveUser(User(1, \"\", \"\"))&#125; 중첩함수는 자신이 속한 바깥함수의 모든 파라미터와 변수를 참조 가능 따라서 validate의 파라미터인 user까지 제거 1234567891011121314151617181920class User(val id: Int, val name: String, val address: String)fun saveUser(user: User) &#123; fun validate(value: String, fieldName: String) &#123; //불필요한 user파라미터 제거 if (value.isEmpty()) &#123; throw IllegalArgumentException( \"Can't save user $&#123;user.id&#125;: \" + \"empty $fieldName\") &#125; &#125; validate(user.name, \"Name\") //user.name만 전달 validate(user.address, \"Address\") //user.address만 전달 // Save user to the database&#125;fun main(args: Array&lt;String&gt;) &#123; saveUser(User(1, \"\", \"\"))&#125; 확장함수를 이용해서 검증로직 개선 1234567891011121314151617181920212223class User(val id: Int, val name: String, val address: String)fun User.validateBeforeSave() &#123; //User클래스의 확장함수 fun validate(value: String, fieldName: String) &#123; //중첩함수 if (value.isEmpty()) &#123; throw IllegalArgumentException( \"Can't save user $id: empty $fieldName\") //&#123;$user.id&#125;를 쓸 필요 X, $id O &#125; &#125; validate(name, \"Name\") validate(address, \"Address\")&#125;fun saveUser(user: User) &#123; user.validateBeforeSave() // Save user to the database&#125;fun main(args: Array&lt;String&gt;) &#123; saveUser(User(1, \"2\", \"\"))&#125; TODO - 생각해보자! 좋은 구조인가?? 과유불급이라고 중첩된 함수의 깊이가 깊어지면 깊어질수록 코드 읽기가 어려우니 일반적으로는 한 단계만 함수를 중첩시키는 것을 권장한다. 참고 Kotlin In Action Made by iyj9328","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"Kotlin in action","slug":"Kotlin-in-action","permalink":"https://woovictory.github.io/tags/Kotlin-in-action/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"}]},{"title":"[Kotlin in Action] Chap2. 코틀린 기초","slug":"KotlinInAction-Chap2","date":"2020-04-01T10:49:20.000Z","updated":"2020-05-12T15:16:46.930Z","comments":true,"path":"2020/04/01/KotlinInAction-Chap2/","link":"","permalink":"https://woovictory.github.io/2020/04/01/KotlinInAction-Chap2/","excerpt":"","text":"현재 진행하고 있는 스터디에서 코틀린 인 액션을 가지고 공부를 진행하고 있습니다. Github에 Repository를 생성하여 내용을 정리하여 관리하고 있지만, 블로그에서도 확인할 수 있도록 마이그레이션 하고 있습니다. 코틀린 기초 1. 함수 12345678// 블록이 본문인 함수fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125;// 식이 본문인 함수fun max2(a: Int, b: Int): Int = if (a &gt; b) a else b// 식입 본문인 함수는 return type 생략 가능 (feat. 타입 추론)fun max3(a: Int, b: Int) = inf (a &gt; b) a else b 함수 선언은 fun 키워드로 시작 fun 다음에 함수명을 명시 함수 이름 뒤에 괄호 안에 파라미터들 명시 변수 선언과 마찬가지로 파라미터 뒤에 :을 통해 타입을 명시 본문 블록이 본문인 함수: 중괄호로 본문을 감싼 형태 식이 본문인 함수: 중괄호 대신 등호와 식을 이용한 형태 TODO - 알고가자! 문(statement)과 식(expression)의 차이 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있으나 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값도 만들어내지 않는다 2. 변수 12345678// 타입 표기 생략 (feat. 타입 추론)val question = \"TEAM-Android Study Coworker !\"val answer1 = 42// 타입 명시val answer2: Int = 42// 초기화를 하지 않는 경우 타입 명시 필수!val answer3: Intanswer3 = 42 코틀린은 변수를 선언할 때에 변수명 뒤에 :을 통해 명시 TODO - 알고가자 ! 변수명을 뒤에 명시하는 이유? 타입을 생략할 경우 식과 변수 선언이 구별을 할 수 없기 때문에 변수명 뒤에 명시하거나 생략하도록 설계되었다. 자바와 마찬가지로 부동소수점 사용시 Double 타입이 된다. 변경 가능한 변수와 변경 불가 함수 val: 변경 불가능한 값을 저장하는 변수. 일단 초기화하면 재대입이 불가. 딱 1번만 초기화가 가능 자바의 final 변수에 해당 val 참조 자체가 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다. 아래 코드는 올바른 코드이다. 12345678910val languages = arrayListOf(\"java\") // 불변 참조 선언languages.add(\"kotlin\") // 참조가 가리키는 객체 내부를 변경// message를 한번만 초기화한다는 것을 컴파일러가 알 수 있어 올바른 코드이다.val message: Strinif (canPerformOperation()) &#123; message = \"Success&#125; else &#123; message = \"Failed\"&#125; TODO - 의논해보자! val 객체의 내부 값이 변경 가능한 이유는 무엇일까? 태형’s Think 코틀린은 자바와 동일하게 기본적으로 call by value 이며 객체 전달 시 메모리 주소를 전달하므로 객체 내부를 변경하여도 메모리 값이 변하는 것이 아니기 때문에 변경이 가능하다. TODO - 고민해보자! 호출되는 순서를 고민해보자. 12345678910111213141516171819object Main &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; callByValue(funA()) // funA // callByValue &#125; fun callByValue(b: Boolean): Boolean &#123; println(\"callByValue\") return b &#125; val funA: () -&gt; Boolean = &#123; println(\"funA\") true &#125;&#125; 12345678910111213141516171819object Main &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; callByName(funA) // callByName // funA &#125; fun callByName(f: () -&gt; Boolean): Boolean &#123; println(\"callByName\") return f() &#125; val funA: () -&gt; Boolean = &#123; println(\"funA\") true &#125;&#125; callByValue정답: funA() -&gt; callByValue() callByName 정답: callByName() -&gt; funA() callByName의 이점? 12345678910111213141516171819202122232425object Main &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; val condition = false callByValue(condition, doSomething()) //doSomething //callByValue &#125; fun callByValue(condition: Boolean, value: Int) &#123; println(\"callByValue\") if (condition) &#123; println(value) &#125; &#125; val doSomething: () -&gt; Int = &#123; // 굉장히 오래 걸리는 연산 println(\"doSomething\") 1 &#125;&#125; 1234567891011121314151617181920212223object Main &#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; val condition = false callByName(condition, doSomething) //callByName &#125; fun callByName(condition: Boolean, value: () -&gt; Int) &#123; println(\"callByName\") if (condition) &#123; println(value()) &#125; &#125; val doSomething: () -&gt; Int = &#123; // 굉장히 오래 걸리는 연산 println(\"doSomething\") 1 &#125;&#125; callByValue의 경우 condition에 상관 없이 doSomething()이 실행되며 비효율적으로 동작하게 되지만, callByName을 사용하는 경우 condition 값에 따라 doSomething()이 실행되므로 효율적인 측면에서 더 뛰어나다. var: 변경 가능한 참조. 변수 타입은 고정. 자바의 일반 변수에 해당 타입은 변환시킬 수 없음 12var answer = 42answer = \"no answer\" // \"error: type mismatch\" 컴파일 오류 발생 문자열 템플릿 123456val name =\"TEAM-ASC\"println(\"Hello, $name\")println(\"Hello, $&#123;name&#125;\")println(\"\\$name의 값 = $name\") // \\$ 탈출문자 사용println(\"max(1, 2) = $&#123;max(1, 2)&#125;\") // 중괄호 안에서 식 사용println(\"args: $&#123;if (args.isEmpty()) \"empty\" else args[0]&#125;\") // 식에서 큰 따옴표 사용 클래스 12// kotlinclass Person(val name: String) 123456789101112// javapublic class Person &#123; private final String name; public Person(String name) &#123; this.name = name; &#125; public String getString() &#123; return name; &#125;&#125; 코틀린 클래스의 기본 접근지정자가 public 으로 생략 가능 getter/setter 메소드를 기본적으로 제공하여 생략 가능 프로퍼티 자바의 필드와 접근자 메소드(getter/setter 메소드)를 완전히 대신함 1234class Person( val name: String, // 읽기 전용(val) 프로퍼티 var isMarried: Boolean // 변경 가능(var) 프로퍼티) 1234Person p = Person(\"Bob\", false)println(p.name)println(p.isMarried)p.isMarried = true; val 프로퍼티: 읽기 전용 프로퍼티로 private 필드와 필드를 읽는 pulbic getter() 를 생성함(backing 필드) TODO - 찾아보자 ! 프로퍼티에 접근지정자 (private)을 지정했을 경우에 private 필드 + private getter()가 되어 접근이 안되는 것인가? 아니면 접근 지정자 지정을 안했을 때에 default가 public 필드인가? var 프로퍼티: 읽고 쓰기가 가능한 프로퍼티로 private 필드와 public getter()/public setter() 를 생성함(backing 필드) 뿐만 아니라 생성자가 필드를 초기화 하는 구현이 내부적으로 구현되어 있음 TODO - 알고가자! backing 필드 ? 프로퍼티의 값을 저장하기 위한 비공개 필드 프로퍼티 이름이 is로 시작할 경우 프로퍼티 이름과 동일한 getter() 생성: 예, isMarried() 커스텀 접근자 123456789class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; // 프로퍼티 getter 선언, 블록 사용 return height == width; &#125; val size: Int get() = height * width // 식 사용&#125; 위와 같이 사용 시 해당 프로퍼티에 접근할 때마다 getter가 프로퍼티 값을 매번 다시 계산함 소스코드 구조 파일의 맨 앞에 package 문 사용해서 패키지 지정 파일의 모든 선언 (클래스, 함수, 프로퍼티 등)이 해당 패키지에 속함 디렉토리 구조와 패키지 구조가 일치할 필요 없음 같은 패키지에 속해있다면 다른 파일에서 임포트 없이 정의한 선언 사용 가능 다른 패키지에서 사용하려면 import 키워드로 사용할 선언을 임포트해야 함 enum enum 키워드를 사용하여 열거타입 지정 123enum class Color &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET&#125; 자바는 enum, 코틀린은 enum class 코틀린에서의 enum은 소프트 키워드(soft keyword) 라고 부름 class 앞에 붙여질 경우 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있음(예약어처럼 사용이 불가하지 않음) 프로퍼티와 메소드 선언 가능 (메소드 선언시 마지막 열거 값 뒤에 세미콜론 필수) 12345678enum class Color(val r: Int, val g: Int, val b: Int) &#123; READ(255, 0, 0), ORANGE(255, 165, 0), YELLOW(255, 255, 0), BLUE(0, 0, 255), VIOLET(238, 130, 238); fun rgb() = (r * 256 + g) * 256 + b&#125;println(Color.BLUE.rgb()) // 결과: 255 when 자바의 switch와 유사하며 코틀린의 when은 if와 마찬가지로 값을 만들어내는 식 임 12345678910fun getColorString(color: Color) = when (color) &#123; Color.RED -&gt; \"It is RED !\" Color.ORANGE -&gt; \"It is ORANGE !\" Color.YELLOW -&gt; \"It is YELLOW !\" Color.GREEN, Color.BLUE -&gt; \"It is GREEN OR BLUE !\" else -&gt; \"What is Color..?\" &#125;println(getColorString(Color.ORANGE)) // 결과: It is ORANGE 각 분기에 break 키워드 필요 없음 ,를 통해 여러 매치 패턴을 지정할 수 있음 모든 분기 식에 만족하지 않으면 else 분기가 실행됨 when 식은 객체의 동등성 사용 1234567fun mix(c1: Color, c2: Color) = when (setOf(c1, c2)) &#123; setOf(RED, YELLOW) -&gt; ORANGE setOf(YELLOW, BLUE) -&gt; GREEN setOf(BLUE, VIOLET) -&gt; INDIGO else -&gt; throw Exception(\"Dirty color\") &#125; setOf(): 자바로 치면 set을 만들어 주는 메소드로 HashSet과 비슷하다고 생각하면 됨 c1, c2가 들어오는 순서에 상관이 없음 인자 없는 when 식 123456789101112131415fun mixOptimized(c1: Color, c2: Color) = when &#123; (c1 == RED &amp;&amp; c2 == YELLOW) || (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; ORANGE (c1 == YELLOW &amp;&amp; c2 == BLUE) || (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt; GREEN (c1 == BLUE &amp;&amp; c2 == VIOLET) || (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt; INDIGO else -&gt; throw Exception(\"Dirty color\") &#125;println(mixOptimized(BLUE, YELLOW)) //결과: GREEN when에 인자가 없으려면 각 분기의 조건이 Boolean 결과를 계산하는 식이어야 함 TODO - 생각해보자! 불필요한 인스턴스를 생성하지 않아 불필요한 가비지 객체가 늘어나지 않는 장점이 있으나 가독성이 매우 떨어지는 코드가 될 수 있어 주의하여 사용하는 것이 좋을 것 같다. 스마트 캐스트 Object의 타입 확인과 변환을 한번에 해주는 기능 1234567891011fun eval(e: Expr): Int &#123; if (e is Num) &#123; val n = e as Num // 명시적 형변환, 스마트 캐스트로 사실상 필요 없음 return n.value &#125; if (e is Sum) &#123; return eval(e.left) + eval(e.right) &#125; throw IllegalArgumentException(\"Unknown expression\")&#125; 12345678910fun eval(e: Expr): Int &#123; when (e) &#123; is Num -&gt; &#123; println(\"num: $&#123;e.value&#125;\") e.value // 블록에서는 마지막 식이 반환값이 됨 &#125; is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException(\"Unknown expression\") &#125;&#125; is 연산자를 통해 변수 타입 검사 검사한 이후에는 명시적인 캐스팅 없이 해당 타입으로 바로 사용 가능 블록으로 되어있는 경우 마지막 식이 반환값이 되어 반환됨 while 루프 자바의 while 루프와 동일하게 사용된다. 1234567while (조건) &#123; // TODO 조건이 참인 경우 반복 실행&#125;do &#123; // TODO 최초 1번 실행 후 조건이 참인 경우 반복 실행&#125; while (조건) for 루프 범위(CloseRange 인터페이스): 두 값으로 이루어진 구간 수열(Progression): 범위에 속한 값을 일정한 순서로 이터레이션 예시 1 rangeTo 10 step 2 또는 1..10 step 2: 1~10 까지 2씩 증가하며 이터레이션 100 downTo 1 step 2: 100부터 1로 줄어들며 2씩 감소하며 이터레이션 0 until 10: 0부터 10까지 이터레이션(단, 10은 미포함) 자바의 for (int i = 0; i &lt; length; i++)에 해당하는 루프가 없다. 대신 범위를 사용한다. 12// 범위 1~100 (100 포함)val oneToTen = 1..100 맵, 리스트에 대한 이터레이션 123456789101112131415161718192021222324252627val binaryReps = TreeMap&lt;Char, String&gt;()for (c in 'A'..'F') &#123; val binary = Integer.toBinaryString(c.toInt()) binaryReps[c] = binary; // 자바의 put(), get() 대신에 이와 같이 사용함&#125;// 맵에 대한 이터레이션// letter에는 키, binary에는 값(2진 표현)이 들어감for ((letter, binary) in binaryReps) &#123; println(\"$letter = $binary\")&#125;// 결과: A = 1000001// B = 1000010// C = 1000011// D = 1000100// E = 1000101// F = 1000110val list = arrayListOf(\"10\", \"11\", \"1001\")for ((index, element) in list.withIndex()) &#123; print(\"$index = $element\")&#125;// 결과: 0 = 10// 1 = 11// 2 = 1001 in을 통해 값이 범위에 속하는지 검사하기 123456789fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'fun isNotDigit(c: Char) = c !in '0'..'9'println(isLetter('q')) // 결과: trueprintln(isNotDigit('x')) // 결과: true// Comparable 구현 클래스println(\"Kotlin\" in \"Java\"..\"Scala\")println(\"Kotlin\" in setOf(\"Java\", \"Scala\", \"Kotlin\")) // 결과: true in은 contains와 동일 익셉션(Exception) 자바나 다른 언어의 예외 처리와 비슷하다. 즉, 함수 실행 중 오류가 발생하면 예외를 던질(throw) 수 있고 함수를 호출하는 쪽에서는 그 예외를 잡아 처리(catch)할 수 있다. 예외에 대해 처리를 하지 않은 경우 함수 호출 스택을 거슬러 올라가면서 예외를 처리하는 부분이 나올 때까지 예외를 다시던진다(rethrow). 123if (percentage !in 0..100) &#123; throw IllegalArgumentException(\"message: $percentage\")&#125; 12345678910111213fun readNumber(reader: BufferedReader): Int? &#123; try &#123; val line = reader.readLine() return Integer.parseInt(line) &#125; catch (e: NumberFormatException) &#123; return null &#125; finally &#123; reader.close() &#125;&#125;val reader = BufferedReader(StringReader(\"239\"))println(readNumber(reader)) // 결과: 239 자바와의 가장 큰 차이점은 함수명 뒤에 throws 절이 없다는 것임 자바에서 상기 코드는 함수 뒤에 throws IOException을 붙여야 함 IOException이 체크 예외이기 때문에 자바는 명시적으로 표현해야 함 TODO - 알고가자! Java에서의 체크 예외 ClassNotFoundException CloneNotSupportedException InstantiationException IOException Java에서의 언체크 예외 RuntimeException을 상속받는 Exception ArithmeticException IllegalArgumentException IndexOutOfBoundsException try는 식 1234567891011121314fun readNumber(reader: BufferedReader) &#123; val number = try &#123; Integer.parseInt(reader.readLine()) &#125; catch (e: NumberFormatException) &#123; return // null로 수정 시 null을 반환하게 된다. &#125; finally &#123; reader.close &#125; println(number) // Exception 발생 시 호출되지 않음&#125;val reader = BufferedReader(StringReader(\"not a number\"))readNumber(readNumber(reader)) // 결과: 아무것도 출력되지 않음. 참조 코틀린 인 액션 스터디 정리 자료 :: 자바캔(Java Can Do IT) 탤로우 월드#Kotlin","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"Kotlin in action","slug":"Kotlin-in-action","permalink":"https://woovictory.github.io/tags/Kotlin-in-action/"},{"name":"프로그래밍 언어","slug":"프로그래밍-언어","permalink":"https://woovictory.github.io/tags/프로그래밍-언어/"}]},{"title":"[Android] Room 개념편","slug":"Android-Room-Concept","date":"2020-03-27T05:22:06.000Z","updated":"2020-06-16T05:18:11.328Z","comments":true,"path":"2020/03/27/Android-Room-Concept/","link":"","permalink":"https://woovictory.github.io/2020/03/27/Android-Room-Concept/","excerpt":"","text":"Room 내용에 대해 정리한 포스팅의 클릭수와 노출수가 상당히 높았다. 그래서 필자가 정리한 내용을 보니 Room에 필요한 내용이 정리되어있지만, 잘 정리되어 있다는 느낌을 받지는 못했다. 필자는 Room에 관한 내용을 더 깔끔하게 정리하여 이 글을 읽는 분들이 더 쉽게 이해할 수 있게 하기 위해 글을 다시 작성하려 한다. Android Architecture Components(이하 AAC) 중 하나인 Room의 개념에 대해 알아보는 포스팅이다. ORM 먼저, ORM이 무엇인지 알 필요가 있다. ORM은 Objectg Relational Mapping으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것을 의미한다. Room Room은 ORM 기반의 라이브러리이다. SQLite 위에 추상화 계층을 제공하여 SQLite의 기능을 최대한 활용하는 동시에 데이터베이스에 원활하게 접근할 수 있도록 고안된 라이브러리이다. 사용법 1) Gradle 설정 (androidX 기준) version은 사용하는 시점에 최신 버전을 사용하면 된다. 123456789101112131415161718dependencies &#123; def room_version = \"2.1.0-alpha03\" implementation \"androidx.room:room-runtime:$room_version\" annotationProcessor \"androidx.room:room-compiler:$room_version\" // use kapt for Kotlin // optional - RxJava support for Room implementation \"androidx.room:room-rxjava2:$room_version\" // optional - Guava support for Room, including Optional and ListenableFuture implementation \"androidx.room:room-guava:$room_version\" // optional - Coroutines support for Room implementation \"androidx.room:room-coroutines:$room_version\" // Test helpers testImplementation \"androidx.room:room-testing:$room_version\"&#125; 2) Room의 구성요소 Database Database 접근 지점을 제공하며 DAO를 관리한다. Annotaion 내에 사용할 Entity 목록을 배열로 작성해야 한다. DAO Database에 접근하는데 사용되는 메소드들을 포함하며, Annotation으로 관리된다. Select, Insert, Delete 등 데이터를 쓰거나 읽을 때 사용한다. Entity Database 내의 테이블을 의미한다. [Database의 특징] Database 접근 지점을 제공하며, DAO를 관리한다. 클래스에 @Database 어노테이션을 붙이며, 아래의 조건을 만족해야 한다. RoomDatabase 클래스를 상속받는 추상 클래스여야 한다. 어노테이션 내에 Database에 들어갈 Entity 목록을 배열로 포함해야 한다. 파라미터가 0개인 추상 메소드를 포함하고 @Dao 어노테이션된 클래스를 반환한다. 이를 통해 RoomDatabase에게 관리 권한을 위임하여 직접적으로 접근하는 것을 막는다. Runtime에 Room.databaseBuilder()를 호출해 데이터베이스 인스턴스를 얻을 수 있다. 인스턴스를 만드는 과정을 많은 비용이 든다. 하지만 접근은 자주하기 때문에 문서에서는 싱글톤 패턴을 이용해 만드는 것을 권장하고 있다. [DAO(Data Access Object)의 특징] Database에 접근하는데 사용되는 메소드들을 갖고 있으며, 어노테이션으로 관리된다. SELECT, INSERT, DELETE 등 데이터를 읽거나 쓸 때 사용한다. LiveData를 사용하면 Observable Query를 이용할 수 있다. @DAO 어노테이션을 활용하며, interface or abstract class로 작성해야 한다. 12345678@Daointerface UserDao&#123; @Query(\"SELECT * FROM user\") fun getUsers(): List&lt;UserEntity&gt; @Insert fun insert(user: UserEntity)&#125; [Entity 특징] Database 내의 테이블을 의미한다. 이름을 지정할 수도 있고, 지정하지 않을 경우 default 값으로 클래스의 이름이 Entity의 이름으로 지정되며, 대소문자를 구분하지 않는다. 컬럼 값도 위의 규칙과 동일하다. 관련 필드 집합을 Entity들로 정의한다. 각 Entity에 대해 항목을 보관하기 위해 연결된 데이터베이스 객체 내에 테이블이 생성된다. 필드를 유지하려면 Room은 필드에 접근할 수 있어야 한다. 따라서 필드를 public으로 만들거나 getter/setter를 제공할 수 있어야 한다. 그렇지 않고 private으로 필드를 만든다면 에러가 발생한다. 12345@Entitydata class UserEntity( val userId: Int = 0, val name: String=\"\") 참고 MVVM AAC Room사용법(1.개념편)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Room","slug":"Room","permalink":"https://woovictory.github.io/tags/Room/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"},{"name":"JetPack","slug":"JetPack","permalink":"https://woovictory.github.io/tags/JetPack/"},{"name":"Database","slug":"Database","permalink":"https://woovictory.github.io/tags/Database/"}]},{"title":"[Android] Mockito 심화편","slug":"Android-Mockito-Advanced","date":"2020-03-06T16:08:22.000Z","updated":"2020-03-07T04:57:10.075Z","comments":true,"path":"2020/03/07/Android-Mockito-Advanced/","link":"","permalink":"https://woovictory.github.io/2020/03/07/Android-Mockito-Advanced/","excerpt":"","text":"이번에는 심화편이다. 이 글을 읽기 전에 기본편을 먼저 보고 오면 좋다. Gradle Mockito는 기본적으로 Java 기반의 라이브러리이다. 그렇기 때문에 Kotlin을 함께 사용하면 모호한 부분이 존재하기 마련이다. 예를 들면 다음과 같은 구문들이 있다. 123456789public class PersonTest&#123; @Test public void mockTest()&#123; Person p = mock(Person.class); assertTrue(p!=null); when(p.getName()).thenReturn(\"VictoryWoo\") &#125;&#125; 여기서 when문을 보면 그냥 쓰였다. 이는 자바이기 때문에 그대로 쓰이지만 코틀린에서는 다음과 같이 쓰인다. 12345678910class PersonTest&#123; @Test fun personMockTest()&#123; val p: Person = mock(Person::class.java) assertTrue(p != null) `when`(p.name).thenReturn(\"VictoryWoo\") &#125;&#125; 표현이 다르다. when의 앞뒤로 `가 붙는다. 자바와 코틀린을 사용할 때, 구문이 맞지 않아서 생기는 문제이다. 크게 신경 쓰이지 않을 수도 있지만, 필자는 신경이 쓰인다. 이뿐만 아니라, 앞서 말했던 Kotlin에서는 모든 클래스가 기본적으로 final로 선언되어 있어 Mockito는 기본적으로 Mocking을 할 수 없는 등의 여러 문제가 있다. 그래서 Niek Haarman이라는 분이 유지 및 관리하는 mockito-kotlin 라이브러리를 사용하면 깔끔하게 해결할 수 있다. Mockito-Kotlin app/build.gradle 파일에 아래와 같이 추가하면 된다. 12testImplementation 'org.mockito:mockito-inline:2.21.0'testImplementation \"com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0\" 첫 번째는 Mockito-Kotlin 의존성이다. 두 번째는 Kotlin의 클래스는 기본이 final이기 때문에 mockito-inline을 추가해주어 open 클래스로 매번 선언해야 하는 번거로움을 제거한다. Mock 객체 만들기 mockito-kotlin에서는 mock을 생성할 때, 더이상 클래스를 파라미터로 전달할 필요가 없다. 코틀린의 특성처럼 타입을 유추할 수 있다면 생략이 가능하다. 또한, p2처럼 타입을 추론할 수 없다면 아래와 같이 &lt;&gt; 안에 타입을 명시해준다. 12val p: Person = mock()val p2 = mock&lt;Person&gt;() # Stubbing Stub : 토막, 꽁초, 남은 부분, 몽당연필이라는 뜻으로 dummy 객체가 마치 실제로 동작하는 것처럼 보이도록 만들어놓은 것을 말한다. 위키피디아에서는 test stub을 아래와 같이 정의한다. Test stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test. 스텁은 &quot;canned answer&quot;를 호출한 쪽에 제공한다는 것이다. canned answer : 미리 준비된 답변은 일반적인 질문에 대한 미리 정해진 답변이라는 뜻이다. 즉, stub은 실제 코드나 아직 준비되지 못한 코드를 미리 정해진 답변으로 가장하는 매커니즘이다. # Stub 특징 dummy 객체가 실제로 동작하는 것처럼 보이게 만들어 놓은 객체 실제 코드나 아직 준비되지 못한 코드의 행동을 가장하는 행위 호출자를 실제 구현물로부터 격리시키는 목적으로 사용가능 인터페이스 or 기본클래스가 최소한으로 구현된 상태 테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다. # Stub이 주로 사용되는 경우 구현이 되지 않은 함수나 라이브러리에서 제공하는 함수를 사용하고자 할때 함수가 반환하는 값을 임의로 생성하고 싶을때 복잡한 논리 흐름을 가지는 경우, 테스트를 단순화하고 싶을때 의존성을 가지는 유닛의 응답을 모사하여 독립적인 시험 수행을 하고자할 때 # Test Stub을 사용하여 얻을 수 있는 이점 의존하는 것에 대하여 독립적으로 개발/테스트가 가능하다. Interface만 존재하는 것을 Stub으로 개발하고 테스트할 수 있다. 촘촘한 테스트가 가능하다. Stub으로 다양한 응답결과 케이스를 만들어 테스트할 수 있다. mockito-kotlin은 when을 쓰지 않고 whenever를 사용한다. 12val p : Person = mock()whenever(p.name).thenReturn(\"VIC\") 위의 식처럼 stubbing을 하거나 혹은 람다식을 사용할 수도 있다. 12345val p: Person = mock &#123; on &#123; name &#125; doReturn \"LEE\"&#125;assertTrue(\"LEE\" == p.name) // 테스트 통과. Mockito 다양한 함수 Mockito에서 자주 사용되거나 유용한 함수들에 대해서 알아볼 것이다. 더 자세한 내용은 돼지왕 왕돼지 놀이터 블로그 글을 참고하면 될 것 같다. 참고 Mockito-Kotlin 알아보기 Test Stub이란 ? mockito 사용법(mockito usage)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Mockito","slug":"Mockito","permalink":"https://woovictory.github.io/tags/Mockito/"},{"name":"Unit Test","slug":"Unit-Test","permalink":"https://woovictory.github.io/tags/Unit-Test/"},{"name":"Test","slug":"Test","permalink":"https://woovictory.github.io/tags/Test/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"}]},{"title":"[Android] Mockito 기본편","slug":"Android-Mockito","date":"2020-03-05T15:24:52.000Z","updated":"2020-03-06T16:24:00.438Z","comments":true,"path":"2020/03/06/Android-Mockito/","link":"","permalink":"https://woovictory.github.io/2020/03/06/Android-Mockito/","excerpt":"","text":"Mockito Mockito는 객체를 Mocking하는데 사용되는 Java 기반의 라이브러이다. JUnit과 함께 Unit Test를 작성하는데 사용된다. Android도 Unit Test를 작성하는데 공식적으로 Mockito를 사용하도록 권장하고 있다. 이전에 Test와 관련된 글에서도 살펴봤듯이 Android는 JVM에서 동작하는 Test와 디바이스 또는 애뮬레이터에서 동작하는 Instrumentation Test가 있다. mocking : 쉽게 말해서 흉내낸다는 것을 의미한다. 이번에는 Mockito를 이용해서 Unit Test를 작성하는 방법에 대해서 알아보려고 한다. Gradle 자바를 사용한다면 다음과 같이 한 줄을 app/build.gralde 파일에 추가하면 된다. 1testImplementation 'org.mockito:mockito-core:2.24.5' 아래의 줄은 안드로이드 Test를 위해 mockito를 사용할 때, 필요한 의존성이다. 추가하지 않아도 테스트 코드로 검증할 때 필요하지 않기 때문에 필요시 추가하도록 하자! 아래는 androidTest 파일에서 mockito를 사용할 때, 필요하다. 1androidTestImplementation(\"org.mockito:mockito-android:2.24.5\") 하지만 코틀린을 사용한다면, 이렇게 의존성을 추가하여 사용할 경우에 다음과 같은 문제가 발생한다. Mockito cannot mock/spy final class라는 에러가 발생한다. 에러 로그를 확인해보면, Mockito가 final class를 Mock으로 만들려고 했기 때문이다. Kotlin은 기본적으로 final class로 설정되기 때문에 이러한 문제가 발생한 것이다. 해결하기 위해서 open 키워드를 Mock으로 만들려는 클래스 앞에 붙여주면 에러가 발생하지 않는다. 그러나 이런 작업을 매번 해주는 것은 귀찮은 작업이다. 그러나 우리에겐 라이브러리가 있다. 행복한 일이다~ ^__^ 아래의 줄을 app/build.gradle 파일에 추가하면 된다. 1testImplementation 'org.mockito:mockito-inline:2.13.0' 간단히 Person이라는 클래스를 만들어서 Mockito를 사용해 mock 객체를 만들고 Mockito에서 제공하는 함수를 이용해서 person 객체의 반환 값을 지정해주는 예제이다. 1234data class Person( val name: String val age: Int) 1234567891011121314151617import org.mockito.Mockito.*class PersonTest&#123; @Test fun personMockTest()&#123; val p: Person = mock(Person::class.java) assertTrue(p != null) `when`(p.name).thenReturn(\"VictoryWoo\") `when`(p.age).thenReturn(27) assertTrue(\"VictoryWoo\" == p.name) assertTrue(27 == p.age) &#125;&#125; mock을 통해서 Person 클래스의 객체를 생성한다. when() 함수를 통해서 p 객체의 name, age의 반환값을 정해준다. 마지막으로 p의 반환값이 기대하는 값과 같은지 비교한다. 성공적으로 2개의 테스트를 통과할 수 있다. 여기서 org.mockito.Mockito.*를 import하였기 때문에 Mockito.을 생략해서 쓸 수 있다. 이처럼 객체의 반환값을 임의로 정해 Unit Test를 할 수 있는 단순한 기능 외에도 Mockito는 객체에 데이터를 추가하는 다양한 기능 및 검증을 할 수 있는 함수를 많이 제공한다. 이번에는 Mockito와 관련된 기본 개념들에 대해서 살펴봤다. 다음에는 조금 더 심화된 내용과 Mockito를 Kotlin과 함께 사용할 때, 모호한 구문을 어떻게 해결할 수 있는지에 대해서 알아볼 예정이다. 참고 Mockito cannot mock/spy final class 에러 해결 방법 [Android, Mockito] Unit Test using Mockito Mockito Android Mockito로 테스트 코드 작성하기 (kotlin)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Mockito","slug":"Mockito","permalink":"https://woovictory.github.io/tags/Mockito/"},{"name":"Test","slug":"Test","permalink":"https://woovictory.github.io/tags/Test/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Android] Test 개념","slug":"Android-Test","date":"2020-03-04T11:22:26.000Z","updated":"2020-03-05T15:21:44.961Z","comments":true,"path":"2020/03/04/Android-Test/","link":"","permalink":"https://woovictory.github.io/2020/03/04/Android-Test/","excerpt":"","text":"Test Code를 짜는 것은 중요하다. 하지만 짜려는 습관이 없다보니 계속해서 Test Code를 짜지 않고 개발하는 습관이 들었다. 최근에 Test Code에 관심을 가지게 되어 공부를 하고 테스트 코드를 짜보려고 한다. 이와 관련된 글은 개념편과 실전편(적용편)으로 나누어 작성할 예정이다. Unit Test 컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 동작하는지 검증하는 절차이다. 단위 테스트를 적용하기 위해서는 러닝 커브도 필요하고, 무엇보다도 직접적인 기능 개발 이외에도 공수가 들어가기 때문에 꺼리는 부분이 있는데, 단위 테스트를 하면 아래와 같은 여러 장점이 있다. 잘못된 부분을 빠르게 확인할 수 있다. -&gt; 프로그램의 안정성이 높아진다. 디버깅 시간을 단축시켜준다. -&gt; 개발 시간을 줄여준다. 모듈이 의도대로 동작하고 있음을 확인할 수 있다. -&gt; 리팩토링 시 부담을 줄여준다. 프로그램의 각 부분을 검증한다. -&gt; 유닛 자체의 불확실성을 제거해준다. -&gt; 유닛을 합쳐서 다시 검증하는 통합 테스트에 유용하다. 안드로이드의 테스트 종류 Unit Test 일반적으로 코드의 유닛 단위(메소드, 클래스, 컴포넌트)의 기능을 실행하는 방식 Tool : JUnit, Mockito, PowerMock UI Test 사용자 인터랙션(버튼 클릭, 텍스트 입력 등)을 평가 Tool : Espresso, UIAutomator etc… src/androidTest 파일과 src/test 파일이 있는 것을 사진을 통해 확인할 수 있다. androidTest 파일이 UI Test를 진행하는 파일들이 있는 곳이고, 아래의 test 파일이 Unit Test를 진행하는 파일들이 있는 곳이다. 기본적으로 안드로이드에서는 JUnit을 지원하여 이를 활용해 Unit Test를 진행할 수 있다. Unit 테스트를 통해서 안드로이드 UI와 관련이 없는 부분을 테스트할 수 있다. 가령, 계산기 클래스를 만들어서 그 안의 메소드 동작을 검증할 수 있다. JUnit &amp; Mockito JUnit : Java 프로그래밍 언어용으로 설계된 단위 테스트 프레임워크. Mockito : 자바에서 단위 테스트를 하기 위해 Mock을 만들어주는 프레임워크. 모의 객체(Mock Object)란 주로 객체 지향 프로그래밍으로 개발한 프로그램을 테스트할 경우, 테스트를 수행할 모듈과 연결되는 외부의 다른 서비스나 모듈들을 실제 사용하는 모듈을 사용하지 않고 실제의 모듈을 흉내내는 가짜 모듈을 작성하여 테스트의 효용성을 높이는 데 사용하는 객체이다. 다른 포스팅에서 Mockito에 관해서 더 알아볼 예정이다. 참고 [Android, Test ] UnitTest, UiTest 기본 예제 MVP unit test","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Unit test","slug":"Unit-test","permalink":"https://woovictory.github.io/tags/Unit-test/"},{"name":"UI Test","slug":"UI-Test","permalink":"https://woovictory.github.io/tags/UI-Test/"}]},{"title":"[Android] Dagger 개념","slug":"Android-Dagger2","date":"2020-02-13T04:00:21.000Z","updated":"2020-03-05T14:46:53.363Z","comments":true,"path":"2020/02/13/Android-Dagger2/","link":"","permalink":"https://woovictory.github.io/2020/02/13/Android-Dagger2/","excerpt":"","text":"DI(Dependency Injection) 구성 요소 간의 의존 관계가 소스 코드 내부가 아닌 외부 설정 파일 등을 통해 정의되게 하는 디자인 패턴. 분리시켜 놓음으로써 객체의 생성과 사용을 분리시킬 수 있고, 재사용이 유연해진다. 크게 3가지 유형으로 나누어 볼 수 있다. 생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입한다.(가장 권장된다.) Setter를 통한 주입 : 의존성을 입력 받는 Setter 메소드를 만들고 이를 통해 의존성을 주입한다. Interface를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행 시에 이를 통해 의존성을 주입한다. 주의할 점 : 생성자 주입이 권장되는 방법이지만, Activity 같은 경우에는 멤버 인젝션을 해야 한다. 이유는 Activity에서 생성자를 쓰지 않기 때문이다. 물론 할 수도 있지만, onCreate()보다 먼저 실행되어버리기 때문에 절대로 권장하지 않는다. 장점 클래스 간의 결합도를 낮춰 유지 보수를 용이하게 할 수 있다. 코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스 코드의 수정 없이 사용할 수 있다. Mock 객체 등을 이용한 단위 테스트의 편의성을 높여준다. 위의 그림에서 A 클래스가 B 클래스를 의존할 때, B의 Object를 A가 직접 생성하지 않고 외부에서 생성하여 넘겨주면 의존성을 주입했다고 할 수 있다. 결국, DI를 위해서는 객체를 생성하고 넘겨주는 외부의 무언가가 필요하다. 직접 DI를 제공하는 Provide 형태의 클래스를 만들 수 있고, 라이브러리로 넘겨서 대신 처리하도록 구현할 수도 있다. DI는 이렇게 의존성이 있는 객체의 제어를 외부 Framework로 올리면서 IoC(Inversion of Control) 개념을 구현한다. -&gt; 제 3자에 의해 정의 당하기 때문에 의존 관계가 역전되었다고 이해할 수 있다. 이를 지원하는 라이브러리 중 Dagger2와 koin이 있으며, 저번에는 koin에 대해 알아봤고 이번에는 Dagger2에 대해 알아볼 예정이다. DI의 필요성? 의존성 파라미터를 생성자에 작성하지 않아도 되므로 보일러 플레이트 코드를 많이 줄일 수 있다. 보일러 플레이트 코드를 줄이는 것만으로도 유연한 프로그래밍이 가능. Interface에 구현체를 쉽게 교체하면서 상황에 따라 적절한 행동을 정의할 수 있다. Mock 객체와 실제 객체를 바꿔가며 테스트할 때, 유용. Dagger2의 핵심 키워드 Inject 의존성 주입을 요청한다. Inject 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 Inject를 요청한 쪽으로 넘겨준다. Component 연결된 Module을 이용해 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다. Module Component에 연결되어 의존성 객체를 생성하여 제공한다. 생성 후 Scope에 따라 관리도 한다. Scope 생성된 객체의 Lifecycle 범위를 뜻한다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서 Scope을 보고 객체를 관리한다. Subcomponent Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위 계층 Component이다. Sub의 Sub도 가능하다. Subcomponent는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고 없으면 부모로 올라가면서 검색한다. @Module + @Provides -&gt; 의존성 제공 @Inject -&gt; 의존성 요청 @Component -&gt; Module과 Inject 사이의 브릿지 역할 수행 @Qualifier -&gt; 동이한 유형이지만, 다른 인스턴스를 가진 객체를 구별하는 데 사용된다. Flow @Inject -&gt; Subcomponent -&gt; Modulce -&gt; Scope에 있으면 return. 없으면 생성. Subcomponent Module에서 맞는 타입을 못찾으면 상위 Component -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성. 그림으로 한번 더 이해하기 Module, Provides -&gt; 공급자의 역할. Module : 의존성을 제공하는 @Provides 메소드를 가진 클래스에 이용한다. 모든 @Provides 메소드는 @Module 클래스 안에 속해야 한다. Provides : 어떻게 의존성을 구성하고 제공하는지 정의하는 메소드에 사용한다. Inject -&gt; 소비자. Component -&gt; 위의 둘을 연결해주는 역할을 한다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Dagger2","slug":"Dagger2","permalink":"https://woovictory.github.io/tags/Dagger2/"},{"name":"DI","slug":"DI","permalink":"https://woovictory.github.io/tags/DI/"}]},{"title":"[Android] Clean Architecture 2.","slug":"Android-Clean-Architecture2","date":"2020-02-11T09:16:23.000Z","updated":"2020-02-11T12:13:28.773Z","comments":true,"path":"2020/02/11/Android-Clean-Architecture2/","link":"","permalink":"https://woovictory.github.io/2020/02/11/Android-Clean-Architecture2/","excerpt":"","text":"지난 포스팅에서는 간략하게 Clean Architecture에 대해 알아보고, 이를 적용할 시 어떠한 장점을 갖는지만 정리를 해봤다. 이번에는 4개의 계층으로 나뉘어진 아키텍처에서 각각의 계층이 어떠한 역할을 하는지 알아보려고 한다. Clean Architecture 좋은 코드란? 가독성이 좋은 코드? 테스트 커버리지가 높은 코드? 여러가지 기준이 있겠지만, 그 중 하나인 유지보수하기 쉬운 코드(변화에 잘 대응할 수 있는 코드)또한 좋은 코드의 기준 중 하나일 것이다. 유지보수하기 쉬운 코드는 변화에 따른 코드 변경이 적다는 것일 가능성이 높다. 그러기 위해서는 코드가 잘 분리되어 있어야 한다. 그 방법 중 하나로 Clean Architecture를 예로 들 수 있고, 우리가 알아봐야 할 개념이다. 위의 그림은 Robert Martin이 소개한 Clean Architecture 다이어그램이다. 양파 모양의 4개의 Layer가 존재한다. 가장 바깥쪽의 Frameworks &amp; Drivers가 사용자와 접점에 있는 Presentation이다. 가장 안쪽의 Entities가 사용자가 실제로 생각하는 개념의 단위이다. Clean Architecture는 실제로 서버쪽 내용이라고 한다. 하지만, 안드로이드에서도 이 개념을 적용시켜 UI를 독립시키고 데이터베이스를 분리시키고 외부적인 설정에 독립적인 구조를 적용하여 프레임워크에 의존적이지 않은 독립적인 코드를 짤 수 있다. android에서 Clean Architecture를 적용할 때, 4개의 레이어로 분리하면 위와 같은 사진으로 적용된다. 4 Layer 안드로이드 계층을 4개로 나눌 수 있다. 사용자에게 보여지는 로직과 관련된 Presentation Layer Network를 포함한 데이터를 가져오는 Data Layer 사용자의 use case로 분리되는 Domain Layer 사용자의 개념을 정의하는 Entity Layer 위의 4개의 레이어 간의 의존성은 안쪽으로만 발생해야 한다. 가장 하단부의 레이어일수록 의존성이 낮아야 한다. Presentation Layer는 Data Layer를 알지만, Data Layer는 Presentation Layer를 몰라야 한다. 이 덕분에 맨 아래 Entity Layer는 순수한 Java 또는 Kotlin 모듈이 될 수 있고 안드로이드에 의존성을 가질 수도 있고 안드로이드 의존성을 가지지 않을 수도 있다. (즉, 의존성이 적기 때문에 다른 플랫폼에서도 사용이 가능하다.) 이러한 분리를 통해서 어떤 데이터베이스에 저장될지, 어떤 뷰에 보일지 고민하지 않고 Entity를 작성할 수 있고, 이에 대한 유스 케이스로 Domain Layer를 작성할 수 있다. 또한, 트랜잭션을 가져오는 것은 Data에서 어떻게 보여줄 것인지를 Presentation에서 정할 수 있다. 각 Layer별 설명. 1. Entity Layer Entity는 순수한 Java 또는 Kotlin 모듈이므로 안드로이드와 의존성이 없다. 안드로이드에서만 사용하는 것이 아니라고 생각하고 작성해야 한다. 다른 플랫폼의 같은 서비스를 만든다면 Android, iOS, Server 모두 같은 이름과 타입을 사용하는 동일한 형태여야 한다. 따라서 넘기는 데이터를 Parcelable 등으로 정의하는 등의 행위는 삼가해야 한다. 정리하자면, 사용자가 생각하는 형태대로 도메인(비즈니스 로직)에서 파생되는 개념을 표현한다. 2. Domain Layer Domain Layer도 순수한 Java나 Kotlin 모듈이다. 실제로 사용자가 하는 일련의 행동들, 즉, 유스 케이스를 적용하는 것인데, 이 역시 안드로이드에 의존할 필요가 없기 때문이다. 유스 케이스를 구성할 때는 데이터베이스가 무엇인지 뷰가 어떤 것인지 고민하지 않고, 도메인에서 정의한 적당한 레포지토리를 이용하여 구축하므로 코드가 사고의 흐름처럼 구성될 수 있다. 3. Data Layer Data Layer에서 하는 한 가지 일을 고르자면, Domain Layer를 알고 있으므로 Domain Layer에 정의된 Repository를 실제로 구현하는 것이다. 또한 여기에서는 Data Source에 의존성이 생기므로, 안드로이드 의존성이 생길 수 있다. 4. Presentation Layer 마지막 최상위 레이어인 Presentation Layer는 UI 레벨에서의 처리이고 Android 의존성이 높다. MVP 구조를 사용한다면 presenter가 생성되는 시점에 유스 케이스를 주입받을 수 있는 구조로 작성한다. 이처럼 작성하게 될 시에 테스트하기에 좀 더 편리하다. 참고 범석의 안드로이드 메모장","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Clean Architecture","slug":"Clean-Architecture","permalink":"https://woovictory.github.io/tags/Clean-Architecture/"}]},{"title":"[Android] Clean Architecture Intro.","slug":"Android-Clean-Architecture","date":"2020-02-11T07:56:24.000Z","updated":"2020-02-11T09:16:04.286Z","comments":true,"path":"2020/02/11/Android-Clean-Architecture/","link":"","permalink":"https://woovictory.github.io/2020/02/11/Android-Clean-Architecture/","excerpt":"","text":"Clean Architecture라는 말은 안드로이드에만 국한되는 것이 아니다. 소프트웨어 개발을 하고 있다면 이에 대해서 관심을 가져봤을 법하다고 생각한다. 필자는 지금까지 Clean Architecture를 들어봤지만, 실제로 무엇인지 제대로 살펴본 적이 없다. 그래서 이번에 간단한 프로젝트를 하게 되었는데 Clean Architecture를 왜 사용하는지와 사용했을 때의 장점을 알아보려고 한다. 아직, 제대로 된 공부를 하지 않았기에 '어떤 장점이 있어서 써야된다.'라고 말하지 못할 것 같다. 머릿속에 정리하고 개념을 이해한 뒤, 실제 적용하면서 느끼는 점이 있지 않을까 하면서 공부를 시작한다. Clean Architecture 클린 아키텍처를 검색했을 때, 만날 수 있는 그림이다. 이 그림이 의미하는 바를 알아보자. Robert C Martin 블로그의 글에서 대부분의 아키텍처는 세부적인 차이는 있어도 공통적인 목표는 계층을 분리하여 관심사의 분리를 하는 것이라고 말한다. 이런 아키텍처가 동작하기 위해서는 의존성 규칙을 지켜야 한다고 한다. 의존성 규칙은 모든 소스코드의 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 한다고 말한다. 즉, 업무의 업무 로직을 담당하는 코드들이 DB 또는 Web 같이 구체적인 세부 사항에 의존하지 않아야 한다. 이를 통해 업무 로직(고수준 정책)은 세부 사항들(저수준 정책)의 변경에 영향을 받지 않도록 할 수 있다. 이번에는 Fernando 분이 설명하신 글을 살펴보자. 이와 같은 구조는 다음과 같은 측면에서 도움을 준다. Problem Solving Scalability(확장성) Modularization(모듈화) Testability(테스트 가능한 코드) Independence of frameworks, UI and Databases. 클린 아키텍처는 크게 3개의 architecture로 나눌 수 있다. 참고 안드로이드 - Clean Architecture 연습하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Clear Architecture","slug":"Clear-Architecture","permalink":"https://woovictory.github.io/tags/Clear-Architecture/"}]},{"title":"[알고리즘] 다익스트라","slug":"Dijkstra","date":"2020-01-30T07:18:12.000Z","updated":"2020-01-30T07:52:26.750Z","comments":true,"path":"2020/01/30/Dijkstra/","link":"","permalink":"https://woovictory.github.io/2020/01/30/Dijkstra/","excerpt":"","text":"알고리즘 문제를 풀면서 다익스트라 알고리즘과 관련된 내용이 나왔다. 잘 모르는 부분이 있어서 기억하기 위해 정리하려 한다. 다익스트라 알고리즘 다익스트라 알고리즘은 그래프에서 출발점에서 도착점까지의 최단거리를 구할 때 사용하는 알고리즘이다. 주로 사용하는 변수 두개가 있다. 12int[] distance = new int[n+1];boolean[] visit = new boolean[n+1]; distance 배열에는 각각의 노드까지의 최단 거리가 저장된다. visit 배열에는 각각의 노드를 방문했는지 여부를 표시하여 저장한다. 다익스트라 알고리즘의 순서는 다음과 같다. 최단 거리를 저장하는 distance 배열에는 처음에 나올 수 있는 가장 큰 값으로 초기화 해준다. 보통 Integer.MAX_VALUE 값으로 초기화 한다. 시작 노드의 거리를 0으로 표시한다. (이는 당연하다. 자기 자신까지의 거리는 0이기 때문.) 그리고 시작 노드의 visit 값을 true로 바꿔준다. 시작노드와 연결되어 있는 노드들의 distance 값을 갱신한다. 방문하지 않은 노드 중 distance 값이 최소인 노드 min_node를 찾는다. min_node의 visit 값을 true로 변경한다. 그리고 min_node와 연결된 노드들(방문하지 않은)의 distance 값을 갱신한다. 이때, min_node와 연결된 distance 값이 distance[min_node] + min_node와 그 노드의 거리 보다 큰 경우 distance 값을 distance[min_node]+ min_node와 그 노드의 거리로 갱신해준다. 4 ~ 5번을 모든 노드를 방문할 때까지 반복한다. 이렇게 순서를 설명했지만, 말로 설명하는 것보다는 그림을 보면서 이해하는 편이 더 빠를 것이다. 다음과 같은 그래프가 존재하고 시작점은 1이라고 가정한다. 그리고 간선에 표시되어 있는 값들은 가중치로 생각하면 된다. distance 값을 초기화 해준다. node 1 2 3 distance 무한대 무한대 무한대 visit false false false 시작 노드가 1이므로 시작 노드의 distance와 visit 값을 변경해준다. node 1 2 3 distance 0 무한대 무한대 visit true false false 시작 노드와 연결되어 있는 distance 값을 갱신한다. node 1 2 3 distance 0 2 4 visit true false false 방문하지 않은 노드 중 distance가 최소인 값을 찾는다. 노드 2가 될 것이다. 최소인 노드2의 visit 값을 true로 변경한다. node 1 2 3 distance 0 2 4 visit true true false 여기서는 노드 2와 연결되면서 방문하지 않은 노드들(여기서 노드 3)에 대해서 distance(3) &gt; distance(2) + (2번과 3번 거리) 조건이 참이면 distance(3) = distance(2) + (2번과 3번 거리) 를 통해서 distance 값을 갱신한다. 3번까지의 거리는 4이고, 2번까지의 거리는 2 + 2와 3거리는 1이므로 4 &gt; 2+1 이 성립된다. 따라서 distance(3)은 3으로 갱신된다. node 1 2 3 distance 0 2 3 visit true true false 이처럼 노드 3의 distance 값은 더 최소인 값으로 갱신된다. 다익스트라 알고리즘과 관련된 문제는 알고스팟이라는 문제이다. 참고 자바로 만드는 다익스트라 (dijkstra) 알고리즘","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"다익스트라","slug":"다익스트라","permalink":"https://woovictory.github.io/tags/다익스트라/"},{"name":"최단 거리","slug":"최단-거리","permalink":"https://woovictory.github.io/tags/최단-거리/"}]},{"title":"[알고리즘] 이분 그래프","slug":"Bipartite-Graph","date":"2020-01-26T05:59:18.000Z","updated":"2020-01-26T09:35:49.887Z","comments":true,"path":"2020/01/26/Bipartite-Graph/","link":"","permalink":"https://woovictory.github.io/2020/01/26/Bipartite-Graph/","excerpt":"","text":"이분 그래프란? 인접한 정점끼리 서로 다른 색으로 칠해서 모든 정점을 두 가지 색으로만 칠할 수 있는 그래프를 말한다. 즉, 그래프의 모든 정점이 두 그룹으로 나눠지고 서로 다른 그룹의 정점이 간선으로 연결된 그래프를 이분 그래프라고 한다. (여기서 중요한 점은 같은 그룹에 속한 정점끼리는 서로 인접하지 않도록 해야 한다. 이는 간선이 존재하지 않음을 의미한다.) 이분 그래프의 특징 이분 그래프인지 확인하기 위해서 bfs, dfs 같은 그래프 탐색 방법을 이용할 수 있다. 특히, bfs를 이용할 경우에는 같은 레벨의 정점끼리는 같은 색으로 칠해진다. 연결 요소의 개수를 구하는 방법과 유사하다. 모든 정점을 방문하며 간선을 검사하기 때문에 시간 복잡도는 O(V+E)로 그래프 탐색 알고리즘과 같다. 이분 그래프인지 확인하는 방법 서로 인접한 정점이 같은 색으로 칠해진다면 이분 그래프가 아니다. 그래프 탐색(bfs, dfs)를 이용해 정점을 방문할 때마다 두 가지 색 중 다른 색을 칠한다. 다음 정점을 방문하면서 자신과 인접한 정점(간선으로 연결된 정점)은 자신과 다른 색으로 칠한다. 탐색을 진행할 때, 자신과 인접한 정점의 색이 자신과 동일하면 이분 그래프가 아니다. bfs의 경우, 정점을 방문하다가 만약 같은 레벨에서 정점을 다른 색으로 칠해야 한다면 이는 이분 그래프가 아니다. 모든 정점을 방문했는데, 위의 경우가 없다면 이분 그래프이다. 주의해야 할 점은 연결 그래프와 비연결 그래프 모두 고려해야 한다는 것이다. 그래프가 비연결 그래프인 경우에는 모든 정점에 대해서 확인하는 작업이 필요하다. 이분 그래프와 관련된 문제는 아래 링크를 통해 확인해보자. 1707 참고 [알고리즘] 이분 그래프(Bipartite Graph)란","categories":[],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"이분 그래프","slug":"이분-그래프","permalink":"https://woovictory.github.io/tags/이분-그래프/"}]},{"title":"[RxJava] Chap08. 테스팅과 Flowable","slug":"RxJava-Chap08","date":"2019-09-15T11:51:07.000Z","updated":"2020-05-26T07:06:42.555Z","comments":true,"path":"2019/09/15/RxJava-Chap08/","link":"","permalink":"https://woovictory.github.io/2019/09/15/RxJava-Chap08/","excerpt":"","text":"TestObserver 클래스 RxJava에서 제공하는 TestObserver 클래스다. JUnit 기반의 테스트 코드와 다른 점은 test()와 assertResult() 함수다. 코드는 다음과 같다. 12345678910111213public class JUnitBasic &#123; @Test public void testGetShapeObservable() &#123; String[] data = &#123;\"1\", \"2-R\", \"3-T\"&#125;; // source : 실제 결과. Observable&lt;String&gt; source = Observable.fromArray(data) .map(Shape::getShape); // expected : 예상 결과. String[] expected = &#123;Shape.BALL, Shape.RECTANGLE, Shape.TRIANGLE&#125;; source.test().assertResult(expected); &#125;&#125; assertResult() : 예상된 결과와 실제 결과를 비교하는 메소드. JUnit의 assertEquals() 메소드와 같다. assertFailure() : Observable에서 기대했던 에러가 발생하는지 확인하는 코드다. 만약, 기대했던 에러가 발생하지 않으면 테스트 코드 실행은 실패한다. 총 3개의 값을 넣어 앞 두 번째 값까지는 정상적으로 발행하고 마지막 값에서 기대했던 예외가 발생하는지 확인한다. 세번째 데이터는 %를 붙여서 Integer.parseInt()에서 변환이 안되기 때문에 NumberFormatException이 발생하고 onError 이벤트로 종료된다. 12345678@Test public void assertFailureExample() &#123; String[] data = &#123;\"100\", \"200\", \"%300\"&#125;; Observable&lt;Integer&gt; source = Observable.fromArray(data) .map(Integer::parseInt); source.test().assertFailure(NumberFormatException.class, 100, 200); &#125; assertFailureAndMessage() : 기대했던 에러 발생시 에러 메시지까지 확인할 수 있다. 에러 메시지를 확인하기 위한 message 인자가 추가되었다. 에러가 발생했을 때 메시지를 확인하기 위해 아래와 같은 구문을 추가한다. 123456789@Testpublic void assertFailureAndMessage() &#123; String[] data = &#123;\"100\", \"200\", \"%300\"&#125;; Observable&lt;Integer&gt; source = Observable.fromArray(data) .map(Integer::parseInt); source.test().assertFailureAndMessage(NumberFormatException.class, \"For input string : \\\"%300\\\"\", 100, 200);&#125; awaitDone() : interval() 함수처럼 비동기로 동작하는 Observable 코드를 테스트할 수 있다. assertComplete() : Observable을 정상적으로 완료했는지(onComplete 이벤트) 확인한다. 비동기 코드 테스트 RxJava는 다양한 상황에서 비동기 코드를 직관적으로 작성할 수 있다. 하지만, 비동기 코드를 테스트하는 것은 어려우므로 RxJava는 비동기로 동작하는 코드를 테스트할 방법을 제공한다. Observable.interval() 메소드는 main 스레드가 아닌 계산 스케줄러에서 실행되기 때문에 비동기 코드를 테스트할 필요가 있다. awaitDone() 함수를 사용하면 된다. awaitDone() 함수는 test() 함수가 실행되는 스레드에서 onComplete() 함수를 호출할 때까지 기다려준다. 1234567891011121314public class TestAsync &#123; @Test public void testInterval() &#123; Observable&lt;Integer&gt; source = Observable.interval(100L, TimeUnit.MILLISECONDS) .take(5) .map(Long::intValue); source.doOnNext(Log::d) .test() .awaitDone(1L, TimeUnit.SECONDS) .assertResult(0, 1, 2, 3, 4); &#125;&#125; HTTP 서버와 통신하는 코드를 테스트하는 것은 소스 코드만 봐도 충분히 이해할 수 있다. 1234567891011121314151617@Testpublic void testHttp() &#123; final String url = \"http://api.github.com/users/yudong80\"; Observable&lt;String&gt; source = Observable.just(url) .subscribeOn(Schedulers.io()) .map(OkHttpHelper::get) .doOnNext(Log::d) // json 을 로그로 찍는다. .map(json -&gt; GsonHelper.parseValue(json, \"name\")) .observeOn(Schedulers.newThread()); // json 중에서 name 만 뽑은 것을 로그로 찍는다. String expected = \"Dong Hwan Yu\"; source.doOnNext(Log::i) .test() .awaitDone(3, TimeUnit.SECONDS) .assertResult(expected);&#125; HTTP 호출은 IO 스케줄러에서 실행되었고 JSON 파싱 결과는 뉴 스레드 스케줄러에서 출력한다. UI 프로그래밍을 할 때는 뉴 스레드 스케줄러 대신 UI 스레드로 변경하면 된다. Flowable 클래스 배압 이슈를 위해 별도로 분리한 클래스다. Flowable 클래스를 도입한 이유는 Observable 클래스의 성능을 향상시키기 위해서다. 기존의 Observable 클래스(배압 관련 함수들을 포함했었다.)는 배압에 관한 처리가 불필요한 경우에는 초기 로딩 때문에 약간의 오버헤드가 있었지만, RxJava 2.X의 Observable 클래스에는 배압으로 인한 성능 오버헤드가 사라졌다. Flowable -&gt; Observable로 변환하는 것뿐만 아니라 반대도 어렵지 않다. Observabler과 Flowable의 선택 기준 1. Observable을 사용해야 할 때 최대 1000개 미만의 데이터 흐름. 예를 들어, 응용 프로그램에서 OOM이 발생할 확률이 거의 없는 경우다 마우스 이벤트나 터치 이벤트를 다루는 GUI 프로그래밍. 이 경우에는 배압의 이슈가 거의 발생하지 않는다. Observable로는 초당 1000회 이하의 이벤트를 다루는데 이때 sample()이나 debounce() 같은 흐름 제어 함수를 활용하면 된다. 데이터 흐름이 본질적으로 동기 방식이지만, 프로젝트에서 사용하는 플랫폼이 자바 Stream API나 그에 준하는 기능을 제공하지 않을 때, Observable은 보통 Flowable과 비교했을 때 성능 오버헤드가 낮다. 2. Flowable을 사용해야 할 때 특정 방식으로 생성된 1000개 이상의 데이터를 처리하는 경우. 이때 메소드 체인에서 데이터 소스에 데이터 개수 제한을 요청해야 한다. 디스크에서 파일을 읽어 들일 경우, 본질적으로 블로킹 I/O 방식을 활용하고 내가 원하는 만큼 가져오는 방식(pull-based)으로 처리해야 하기 때문이다. 예를 들면, 특정 단위로 잘라 몇 행씩 가져오도록 제어할 수 있다. JDBC를 활용해 데이터베이스의 쿼리 결과를 가져오는 경우, 블로킹 방식을 이용하므로 ResultSet.next()를 호출하는 방식으로 쿼리의 결과를 읽어오도록 제어할 수 있다. 네트워크 I/O를 실행하는 경우, 네트워크나 프로토콜을 통해 서버에서 가져오길 원하는 만큼의 데이터양을 요청할 수 있을 때이다. 다수의 블로킹 방식을 사용하거나 가져오는 방식(pull-based)의 데이터 소스가 미래에는 논 블로킹 방식의 리액티브 API나 드라이버를 제공할 수도 있는 경우다. 디스크에서 파일 읽기, JDBC를 활용한 데이터베이스 쿼리하기, 네트워크 I/O 등은 차가운 Observable(구독자가 구독하면 데이터의 처음부터 모두 발행하는 Observable)에 해당한다. 이는 결과 데이터를 처리할 수 있는만큼 조금씩 가져오는 것이 아니라 한 번에 모두 가져온다. 따라서 이 경우에는 반드시 Flowable을 활용해야 하는 것은 아니다. 업스트림에서 발생하는 데이터의 속도와 다운스트림에서 처리하는 속도의 차이가 작다면 Observable을 활용해도 된다. 즉, 데이터 발행과 처리 속도가 차이나더라도 먼저 sample(), throttle(), debounce() 같은 흐름 제어 함수를 활용해 해결하는 것이 좋다. 이러한 함수로도 해결하기 어려울 때는 Flowable 클래스로 전환하면 된다. Flowable을 활용한 배압 이슈 대응 onBackpressureBuffer() : 배압 이슈가 발생했을 때 별도의 버퍼에 저장한다. Flowable 클래스는 기본적으로 128개의 버퍼가 있다. onBackpressureDrop() : 배압 이슈가 발생했을 때 해당 데이터를 무시한다. onBackpressureLatest() : 처리할 수 없어서 쌓이는 데이터를 무시하면서 최신의 데이터만 유지한다. 12345678910111213141516171819public class FlowableSample &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); PublishSubject&lt;Integer&gt; subject = PublishSubject.create(); subject.observeOn(Schedulers.computation()) .subscribe(data -&gt; &#123; CommonUtils.sleep(100); // 100ms 후에 데이터 처리. Log.it(data); &#125;, err -&gt; Log.e(err.toString())); // 뜨거운 Observable 로 50,000,000개의 데이터를 연속으로 발행함. for (int i = 0; i &lt; 50000000; i++) &#123; subject.onNext(i); &#125; subject.onComplete(); &#125;&#125; PublishSubject 객체를 생성한 후, 처리 결과는 계산 스케줄러로 전달한다. subscribe() 함수를 호출한 후 Subject 객체가 발행한 데이터는 100ms 후에 로그를 찍는다. 한편 PublishSubject 객체는 뜨거운 Observable이다. 데이터를 발행하는 속도와 데이터를 처리하는 속도의 차이가 발생했을 때 어떠한 보호 장치도 없다. 결과는 아래와 같다. 1234567891011RxComputationThreadPool-1 | 604 | value = 0RxComputationThreadPool-1 | 742 | value = 1RxComputationThreadPool-1 | 3172 | value = 2RxComputationThreadPool-1 | 5158 | value = 3RxComputationThreadPool-1 | 7426 | value = 4RxComputationThreadPool-1 | 7528 | value = 5RxComputationThreadPool-1 | 8017 | value = 6RxComputationThreadPool-1 | 8570 | value = 7RxComputationThreadPool-1 | 9180 | value = 8RxComputationThreadPool-1 | 15089 | value = 9RxComputationThreadPool-1 | 15675 | value = 10 처리 결과를 보면 100ms 간격보다 상당히 느리게 데이터를 처리한다. 그리고 데이터는 반복문을 통해서 PublishSubject 객체에서 매우 빠르게 발행되는데 데이터는 겨우 10개만 처리되었다. 만약, 발행하는 데이터의 개수가 훨씬 많아지면 JVM은 곧 OOM 예외를 발생하고 실행을 중단할 것이다. 이런 배압 이슈가 발생했을 때 Flowable 클래스를 활용한다. 위와 같은 배압 이슈에 대응하기 위해서 첫 번째 방법은 사용해보자. 버퍼 만들기 onBackpressureBuffer() 함수에는 다음과 같은 오버로딩이 있다. 123456789101112131415// 기본값(128)의 버퍼 개수가 있다.public final Flowable&lt;T&gt; onBackpressureBuffer()// delayError 여부를 지정할 수 있다. // true : 예외가 발생했을 때 버퍼에 쌓인 데이터를 모두 처리할 때가지 예외를 던지지 않는다.// false : 예외가 발생했을 때 바로 다운스트림에 예외를 던진다.// 기본값은 false다.public final Flowable&lt;T&gt; onBackpressureBuffer(boolean delayError)// capacity 인자로 버퍼의 개수를 지정한다.// onOverflow 인자에 버퍼가 넘쳤을 때 실행할 동작을 지정한다.public final Flowable&lt;T&gt; onBackpressureBuffer(int capacity, Action onOverflow)// 버퍼가 가득찼을 때 추가로 실행하는 전략을 지정할 수 있다.public final Flowable&lt;T&gt; onBackpressureBuffer(long capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy) 지정할 수 있는 전략은 아래와 같다. ERROR : MissingBackpressureException 예외를 던지고 데이터 흐름을 중단한다. DROP_LATEST : 버퍼에 쌓여있는 최근 값을 제거한다. DROP_OLDEST : 버퍼에 쌓여있는 가장 오래된 값을 제거한다. 1234567891011121314public class onBackPressureBufferSample &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); Flowable.range(1, 50000000) .onBackpressureBuffer(128, () -&gt; &#123; &#125;, BackpressureOverflowStrategy.DROP_OLDEST) .observeOn(Schedulers.computation()) .subscribe(data -&gt; &#123; CommonUtils.sleep(100); Log.it(data); &#125;, error -&gt; Log.e(error.getMessage())); &#125;&#125; Flowable.range() 함수를 활용해 동일한 개수의 데이터를 발행한다. 그리고 128개의 버퍼를 생성한 후 버퍼가 넘치면 버퍼의 가장 오래된 데이터를 버리도록 지정한다. 결과는 아래와 같다. 12345678910111213141516RxComputationThreadPool-1 | 356 | value = 1RxComputationThreadPool-1 | 459 | value = 2RxComputationThreadPool-1 | 561 | value = 3RxComputationThreadPool-1 | 662 | value = 4RxComputationThreadPool-1 | 766 | value = 5RxComputationThreadPool-1 | 869 | value = 6RxComputationThreadPool-1 | 972 | value = 7RxComputationThreadPool-1 | 1072 | value = 8RxComputationThreadPool-1 | 1176 | value = 9RxComputationThreadPool-1 | 1276 | value = 10RxComputationThreadPool-1 | 1380 | value = 11RxComputationThreadPool-1 | 1485 | value = 12RxComputationThreadPool-1 | 1586 | value = 13RxComputationThreadPool-1 | 1688 | value = 14RxComputationThreadPool-1 | 1793 | value = 15RxComputationThreadPool-1 | 1895 | value = 16 이처럼 버퍼를 활용해 데이터를 훨씬 빠르게 다운스트림으로 발행하는 것을 알 수 있다. 거의 10배의 속도이다. 발행하는 속도도 이전보다 빨라졌고 더 많은 데이터를 발행한다. 데이터의 발행 속도가 워낙 빠르기 때문에 128개의 버퍼로는 모두 대응하기 어렵다. 배압 이슈에 대응하는 두 번째 방법은 onBackpressureDrop() 함수를 활용하는 것이다. onBackpressureBuffer() 함수가 버퍼를 만들어 쌓아 두었다가 처리하는 방식이라면, onBackpressureDrop() 함수는 버퍼가 가득 찼을 때, 이후 데이터를 그냥 무시한다. 12345678910111213141516171819202122public class onBackPressureDropSample &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); Flowable.range(1, 50000000) .onBackpressureDrop() .observeOn(Schedulers.computation()) .subscribe(data -&gt; &#123; CommonUtils.sleep(100); Log.it(data); &#125;, error -&gt; Log.e(error.getMessage())); CommonUtils.sleep(20000); &#125;&#125;// 결과... 생략RxComputationThreadPool-1 | 13004 | value = 124RxComputationThreadPool-1 | 13105 | value = 125RxComputationThreadPool-1 | 13207 | value = 126RxComputationThreadPool-1 | 13309 | value = 127RxComputationThreadPool-1 | 13411 | value = 128 버퍼에 128개의 데이터가 가득 찼을 때, 데이터를 계산 스케줄러에서 출력하기도 전에 예제가 끝난다. 따라서 계산 스케줄러에서 데이터를 다운스트림으로 발행할 수 있도록 충분한 시간(여기서는 20초)을 기다려줘야 한다. UI 프로그래밍(안드로이드)에서는 이와 같은 기다림이 필요하지 않다. 기본 버퍼 개수만큼만 버퍼에 저장하고 나머지는 모두 무시했기 때문에 128개의 데이터만 출력하고 종료한다. 마지막 방법은 onBackpressureLatest() 함수를 활용하는 것이다. 위의 두 함수의 기능을 섞을 것으로 데이터가 많이 쌓이면 무시하면서 최신의 데이터 즉, 마지막 데이터를 유지하는 것이다. 12345678910111213141516171819public class onBackPressureLatest &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); Flowable.range(1, 50000000) .onBackpressureLatest() .observeOn(Schedulers.computation()) .subscribe(data -&gt; &#123; CommonUtils.sleep(100); Log.it(data); &#125;, error -&gt; Log.e(error.getMessage())); CommonUtils.sleep(20000); &#125;&#125;// 결과RxComputationThreadPool-1 | 13416 | value = 127RxComputationThreadPool-1 | 13518 | value = 128RxComputationThreadPool-1 | 13622 | value = 50000000 함수만 교체해주었고, 결과는 위와 같다. 버퍼가 꽉찼을 때, 데이터를 무시하면서 마지막 데이터를 다운 스트림으로 발행하는 것을 확인할 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"테스팅","slug":"테스팅","permalink":"https://woovictory.github.io/tags/테스팅/"},{"name":"Flowable","slug":"Flowable","permalink":"https://woovictory.github.io/tags/Flowable/"}]},{"title":"[RxJava] Chap07. 디버깅 - 흐름 제어","slug":"RxJava-Chap07-3","date":"2019-09-14T14:23:20.000Z","updated":"2020-05-26T07:06:46.869Z","comments":true,"path":"2019/09/14/RxJava-Chap07-3/","link":"","permalink":"https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/","excerpt":"","text":"흐름 제어 흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다. RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다. sample() 특정한 시간 동안 가장 최근에 발행한 데이터만 걸러준다. 즉, 최근에 발행된 데이터만 넘겨주고 나머지는 무시한다. 해당 시간에는 아무리 많은 데이터가 들어와도 해당 구간의 마지막 데이터만 발행하고 나머지는 무시한다. 123@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; sample(long period, TimeUnit unit)public final Observable&lt;T&gt; sample(long period, TimeUnit unit, boolean emitLast) emitLast 인자는 sample() 함수의 데이터 발행이 완료되지 않고 마지막에 데이터가 남아 있을 때, 해당 데이터를 발행할 것인지 결정한다. true로 설정하면 마지막 데이터를 발행한다. 123456789101112131415161718192021222324252627282930public class sampleTest &#123; public static void main(String[] args) &#123; String[] data = &#123;\"1\", \"7\", \"2\", \"3\", \"6\"&#125;; // 시간 측정용. CommonUtils.exampleStart(); // 앞의 4개의 데이터는 100ms 간격으로 발행. Observable&lt;String&gt; earlySource = Observable.fromArray(data) .take(4) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 마지막 데이터는 300ms 후에 발행. Observable&lt;String&gt; lateSource = Observable.just(data[4]) .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 2개의 Observable 을 결합하고 300ms 로 샘플링. Observable&lt;String&gt; source = Observable.concat(earlySource, lateSource) .sample(300L, TimeUnit.MILLISECONDS); source.subscribe(Log::it); CommonUtils.sleep(1000); &#125;&#125;// 결과RxComputationThreadPool-1 | 552 | value = 7RxComputationThreadPool-1 | 849 | value = 3 먼저, 100ms 간격으로 data 배열에 있는 데이터 4개를 발행한다. 그리고 마지막 데이터인 6을 300ms 후에 발행한다. 또한 내가 원하는 특정 시간 후에 발행하기 위해 concat() 함수를 호출해 2개의 데이터 흐름(Observable)을 결합했다. 이렇게 전체 데이터 흐름을 세부 데이터 흐름으로 나누면 코드의 가독성이 좋아진다. sample() 함수는 300ms 간격으로 수행한다. 매 300ms 마다 가장 최근에 들어온 값만 최종적으로 발행한다. 처음에 데이터를 발행하기 위해 약간의 지연 시간이 있어서(100ms+a) 다이어그램을 보면 시작할 때 약간의 간격이 있음을 볼 수 있다. 다음 데이터 발행이 3XXms이기 때문에 300ms일 때는 가장 최근 데이터가 이전에 발행했던 7이 되는 것이다.(처음 기준!) 마지막 인자를 true로 설정하면 마지막 데이터를 발행한다. 기본값이 false이다. buffer() 일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해준다. 따라서 넘치는 데이터 흐름을 제어할 필요가 있을 때 활용한다. 컴퓨터의 버퍼 같은 기능을 한다. 처음에 빨,노,초 원을 발행하면 그것을 모아서 List 객체에 전달해준다. 그 다음 다시 하늘,파,보 원이 모이면 그것을 모아서 한 번에 발행해준다. 매우 단순한 로직이다. 함수의 원형은 다음과 같다. 기본적으로 스케줄러 없이 현재 스레드에서 동작하며 입력되는 값을 count에 저장된 수만큼 모아서 List에 한꺼번에 발행한다. 12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;List&lt;T&gt;&gt; buffer(int count) 1234567891011121314151617181920212223242526272829303132public class bufferSample &#123; public static void main(String[] args) &#123; String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;; CommonUtils.exampleStart(); // 앞의 3개는 100ms 간격으로 발행. Observable&lt;String&gt; earlySource = Observable.fromArray(data) .take(3) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 가운데 1개는 300ms 후에 발행. Observable&lt;String&gt; middleSource = Observable.just(data[3]) .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 마지막 2개는 100ms 후에 발행. Observable&lt;String&gt; lataSource = Observable.just(data[4], data[5]) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); Observable&lt;List&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lataSource) .buffer(3); source.subscribe(Log::it); CommonUtils.sleep(1000); &#125;&#125;// 결과RxComputationThreadPool-1 | 562 | value = [1, 2, 3]RxComputationThreadPool-3 | 1067 | value = [4, 5, 6] buffer(3)는 데이터를 3개씩 모았다가 List에 채운 후 값을 한꺼번에 발행해준다. 그래서 위의 결과를 보면 확인 가능하다. buffer() 함수에는 모으거나(count) 무시할(skip) 데이터 개수를 입력할 수 있다. skip 변수는 count보다 값이 커야 한다. count가 2이고 skip이 3이면 2개 데이터를 모으고 3번째 데이터 1개는 스킵한다. 코드는 위와 같으면 buffer(2,3)으로 호출하면 아래와 같은 결과를 얻을 수 있다. 12RxComputationThreadPool-1 | 562 | value = [1, 2]RxComputationThreadPool-3 | 1067 | value = [4, 5] Observable에서 onNext 이벤트가 발생하면 내부 데이터는 3개가 아니라 2개 값을 모아 바로 List에 채운 후 구독자에게 데이터를 발행한다. throttleFirst(), throttleLast() throttle는 조절판이라는 뜻이다. 그것에 맞게 throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행한다. throttleLast() 함수는 주어진 조건에서 가장 마지막에 입력된 값을 발행한다. throttleFirst()와 throttleLast()는 정반대의 의미가 아니다. throttleFirst() 함수는 어떤 데이터가 입력된 후 일정 시간 동안 다른 데이터가 발행되지 못하도록 방지하지만, throttleLast() 함수는 sample() 함수처럼 고정된 시간 간격안에서 마지막 데이터만 발행한다. throttleFirst() : sample() 함수와 비슷하지만 다르다. sample() 함수가 주어진 시간 동안 입력된 마지막 값을 발행한다면 throttleFirst() 함수는 어떤 데이터를 발행하면 지정된 시간 동안 다른 데이터를 발행하지 않도록 막는다. throttleLast() : sample() 함수와 기본 개념은 동일하다. 주어진 시간 동안 입력된 값 중 마지막 값을 발행한다. 함수 원형은 다음과 같다. 계산 스케줄러에서 실행한다. 즉, 비동기로 동작하도록 설계된 함수다. windowDuration는 시간 간격을 지정하며 unit은 시간의 단위다. 12@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; throttleFirst(long windowDuration, TimeUnit unit) 123456789101112131415161718192021222324252627282930313233343536public class throttleFirstSample &#123; public static void main(String[] args) &#123; String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;; CommonUtils.exampleStart(); // 앞의 1개는 100ms 간격으로 발행. Observable&lt;String&gt; earlySource = Observable.just(data[0]) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 다음 1개는 300ms 후에 발행. Observable&lt;String&gt; middlerSource = Observable.just(data[1]) .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 마지막 4개는 100ms 후에 발행. Observable&lt;String&gt; lateSource = Observable.just(data[2], data[3], data[4], data[5]) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a) .doOnNext(Log::dt); // 디버깅 정보 출력. Observable&lt;String&gt; source = Observable.concat(earlySource, middlerSource, lateSource) .throttleFirst(200L, TimeUnit.MILLISECONDS); source.subscribe(Log::it); CommonUtils.sleep(1000); &#125;&#125;// 결과RxComputationThreadPool-1 | 371 | value = 1RxComputationThreadPool-3 | 673 | value = 2RxComputationThreadPool-4 | 779 | debug = 3RxComputationThreadPool-4 | 876 | debug = 4RxComputationThreadPool-4 | 975 | debug = 5RxComputationThreadPool-4 | 975 | value = 5RxComputationThreadPool-4 | 1077 | debug = 6 처음 100ms가 지난 후에 1을 발행한 후, 300ms 동안 기다린 다음 2를 발행한다. 그리고 100ms 간격으로 나머지 값들을 발행한다. 마지막으로 throttleFirst() 함수를 호출해 200ms 간격으로 타임 윈도에 맨 먼저 입력된 값을 발행한다. 위에서는 1,2,4,6이 다운 스트림으로 발행된다. window() groupBy() 함수와 개념적으로 비슷하다. throttleFirst()나 sample() 함수처럼 내가 처리할 수 있는 일부의 값들만 받아들일 수 있다. 흐름 제어 기능에 groupBy() 함수와 비슷한 별도의 Observable 분리 기능을 모두 갖추었다고 생각하면 된다. count를 인자로 받는다. 예를 들어, 3을 인자로 받으면 앞으로 데이터 3개가 발행될 때마다 새로운 Observable을 생성하겠다는 뜻이다. 함수의 원형은 다음과 같다. 현재 스레드를 그대로 활용한다. 왜 그런지 window() 함수의 다른 변형을 비교하면 알 수 있다. 12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;Observable&lt;T&gt;&gt; window(long count) 123456@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;Observable&lt;T&gt;&gt; window( long timespan, long timeskip, TimeUnit unit)&#123; // 생략.&#125; count만을 인자로 갖는 window() 함수는 입력된 값을 그대로 발행하기 때문에 비동기 작업이라고 보기 어렵다. 위의 함수 원형에는 timespan이라는 시간 동안 입력된 값 중에서 일부를 무시하는 기능을 포함한다. 어떤 필터링 작업을 해줘야 하기 때문에 계산 스케줄러를 활용하게 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class windowSample &#123; public static void main(String[] args) &#123; String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;; CommonUtils.exampleStart(); // 앞의 3개는 100ms 간격으로 발행. Observable&lt;String&gt; earlySource = Observable.fromArray(data) .take(3) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 가운데 1개는 300ms 후에 발행. Observable&lt;String&gt; middleSource = Observable.just(data[3]) .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 마지막 2개는 100ms 후에 발행. Observable&lt;String&gt; lateSource = Observable.just(data[4], data[5]) .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a); // 데이터 3개씩 모아서 새로운 Observable 생성. Observable&lt;Observable&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lateSource) .window(3); source.subscribe(observable -&gt; &#123; Log.dt(\"New Observable Started!!\"); observable.subscribe(Log::it); &#125;); CommonUtils.sleep(1000); CommonUtils.exampleComplete(); &#125;&#125;// 결과RxComputationThreadPool-1 | 365 | debug = New Observable Started!!RxComputationThreadPool-1 | 366 | value = 1RxComputationThreadPool-1 | 461 | value = 2RxComputationThreadPool-1 | 560 | value = 3RxComputationThreadPool-2 | 861 | debug = New Observable Started!!RxComputationThreadPool-2 | 861 | value = 4RxComputationThreadPool-3 | 963 | value = 5RxComputationThreadPool-3 | 1062 | value = 6 window() 함수의 인자로 3을 넣었다. 처음에 Observable을 생성하고 3개의 데이터를 전달받으면 새로운 Observable을 다시 생성하여 값을 발행한다. 1 값을 발행할 때와 4 값을 발행할 때 각각 새로운 Observable이 생성되었다. debounce() 빠르게 연속 이벤트를 처리하는 흐름 제어 함수다. 안드로이드와 같은 UI 기반의 프로그래밍에서는 유용하게 활용할 수 있다. 예를 들어, 버튼을 빠르게 누르는 상황에서 마지막에 누른 이벤트만 처리해야할 때 간단하게 적용할 수 있다. RxJava를 이용하지 않는다면 마지막에 버튼을 누른 시간을 멤버 변수에 저장하고 일정 시간 동안 if문으로 예외 처리해야 하기 때문에 매우 번거롭고 실수할 가능성도 크다. 첫 번째 원은 지정한 시간 간격 안에 들어왔고 다른 이벤트는 없어서 그대로 발행되었다. 두 번째 원의 경우 시간 간격 안에 세 번째 원이 다시 들어왔으므로 두 번째가 아닌 세 번째 원을 발행한다. 마지막도 마찬가지다. 함수의 원형은 다음과 같다. 계산 스케줄러에서 동작한다. 어떤 이벤트가 입력되고 timeout에서 지정한 시간 동안 추가 이벤트가 발생하지 않으면 마지막 이벤트를 최종적으로 발행한다. 12@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit) 123456789101112131415161718public class debounceSample &#123; public static void main(String[] args) &#123; String[] data = &#123;\"1\", \"2\", \"3\", \"5\"&#125;; Observable&lt;String&gt; source = Observable.concat( Observable.timer(100L, TimeUnit.MILLISECONDS).map(i -&gt; data[0]), Observable.timer(300L, TimeUnit.MILLISECONDS).map(i -&gt; data[1]), Observable.timer(100L, TimeUnit.MILLISECONDS).map(i -&gt; data[2]), Observable.timer(300L, TimeUnit.MILLISECONDS).map(i -&gt; data[3]) ).debounce(200L, TimeUnit.MILLISECONDS); source.subscribe(Log::i); CommonUtils.sleep(1000); &#125;&#125;// 결과RxComputationThreadPool-2 | value = 1RxComputationThreadPool-2 | value = 3RxComputationThreadPool-2 | value = 5 데이터를 발행하는 부분이 특이하다. 각각의 시간 간격이 서로 다르기 때문에 concat() 함수를 활용해 각가 데이터를 발행했다. timer() 함수는 이벤트를 한 번만 발생시키고 완료하기 때문에 concat()과 timer() 함수의 조합은 유용하다. debounce()를 활용해 어떤 이벤트가 입력되고 지정된 timeout인 200ms 안에 더 이상의 이벤트가 없으면 마지막에 입력된 값을 발행한다. 여기서 이해가 잘 안되었던 부분이 있었다. 결과를 예상해봤을 때, 1,2,5라고 생각했지만 아니었다. 왜냐면 정의 자체가 어떤 이벤트가 입력되고 나서 timout 내에 더 이상의 이벤트가 없으면 마지막 이벤트를 발행하는 것이다. 그러니까 어떤 이벤트가 입력되고 나서 timout 내에 이벤트가 있는지 찾는 것이다. 그래서 결과는 1,3,5가 맞다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"흐름 제어","slug":"흐름-제어","permalink":"https://woovictory.github.io/tags/흐름-제어/"},{"name":"디버깅","slug":"디버깅","permalink":"https://woovictory.github.io/tags/디버깅/"}]},{"title":"[Android] Network State Check","slug":"Android-network-check","date":"2019-08-21T08:55:46.000Z","updated":"2020-03-01T10:27:26.939Z","comments":true,"path":"2019/08/21/Android-network-check/","link":"","permalink":"https://woovictory.github.io/2019/08/21/Android-network-check/","excerpt":"","text":"안드로이드 개발을 하다보면 마주하는 상황이 있다. 바로 인터넷 연결 상태를 확인하는 것이다. 서버와 네트워크 통신을 진행하는 도중 네트워크 연결이 끊기면 예외 처리를 해줘야 한다. 그래야 사용자들이 앱을 사용함에 있어서 사용자 경험을 나쁘지 않게 할 수 있다. 그래서 구글에 검색해봤다. 역시나 개발자 문서에 나와있다. Android Developer 한가지로 예로 동영상을 다운받는다고 가정해보자. 영상을 다운받는 도중에 네트워크 연결이 너무 느리거나 끊겼다면 이에 대한 알림이나 메시지를 사용자에게 보여줘야 한다. 그래서 네트워크 연결을 다시 확인하도록 권장해야 한다. ConnectivityManager를 사용하면 인터넷에 실제로 연결되어 있는지, 연결되어 있다면 어떤 유형의 연결이 설정되어 있는지를 확인할 수 있다. 여기서 어떤 유형이라 함은 WiFi인지 데이터 연결인지를 의미한다. 아래 코드를 확인하자. 간단하다. 먼저, 다음의 권한을 매니페스트 파일에 등록한다. 1&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; 123456fun isNetworkConnected(context: Context): Boolean&#123; val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager val activeNetwork : NetworkInfo? = cm.activeNetworkInfo val isConnected = activeNetwork != null &amp;&amp; activeNetwork.isConnected return isConnected&#125; 끝이다. 그래서 네트워크 연결이 되었는지 혹은 끊겼는지 확인이 필요한 곳에서 사용하면 된다. util로 빼서 함수로 작성해도 되고 확장 함수 개념을 사용해서 작성해도 된다. 주의할 점은 API Level 29부터는 deprecated되었기 때문에 다른 방법을 이용해야 한다. 필자는 API Level 28로 하였다. 29부터도 적용되는 방법은 구글에 검색해보면 나와있다. 추가로 네트워크의 유형이 와이파이인지 데이터인지 확인하는 방법도 있으니 사용할 때, 참고하면 된다. 참고 Android Developer","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"},{"name":"Network State","slug":"Network-State","permalink":"https://woovictory.github.io/tags/Network-State/"}]},{"title":"[회고] 2019 상반기 Review","slug":"2019-the-first-half-year-review","date":"2019-08-10T12:50:07.000Z","updated":"2019-08-20T04:17:37.062Z","comments":true,"path":"2019/08/10/2019-the-first-half-year-review/","link":"","permalink":"https://woovictory.github.io/2019/08/10/2019-the-first-half-year-review/","excerpt":"","text":"2019년도 상반기 회고를 하려고 생각을 했었지만, 2달이나 지났다. 그래서 이 포스팅을 작성할까 말까 고민을 했었으나 고민을 깔끔하게 날려준 결정적인 사건이 있어서 글을 쓰게되었다. 무슨 사건인지는 아래에서 확인할 수 있다. 이번 회고는 2018 회고와 겹치는 부분이 있어서 겹치는 내용은 간략하게 작성할 것이다. 부스트 캠프 면접 DDD 동아리 여행 취업 준비 취업 부스트 캠프 올해 초에 부스트 캠프 3기 안드로이드 과정에 참여했다. 운이 좋아 면접부터 최종합격까지 할 수 있었다. 그래서 약 한 달 간은 강남에서 출퇴근을 하며 부스트 캠프 과정을 진행했다. 개발자와 협업을 하며 좋은 경험을 쌓았고 멘토링을 받으며 현실적인 조언도 받을 수 있었다. 제일 중요한 건 기술적인 시야가 넓어졌다는 점이다. 패턴도 모르고 데이터 바인딩도 몰랐지만, 부스트 캠프를 통해서 알게 되었고 관심을 가지고 공부를 시작할 수 있었다. 면접 위의 부스트 캠프 관련 내용은 지난번 회고 관련 포스팅과 비슷하기 때문에 대략적으로 적었다. 여기서부터는 새로운 내용일 것이다. 좋은 기회가 주어져서 부스트 캠프와 연계되어 면접을 보게 되었다. 직접적인 회사의 부서를 언급하지는 않겠다. 부스트 캠프에서의 활동을 좋게 봐주셔서 면접을 제안받았다. 그래서 면접을 준비하면서 '어떻게 준비해야 할까?'라는 생각을 했다. 필자는 프로젝트 관련 질문과 인성 질문을 준비했다. 지금와서 떠올려보니 왜 ‘인성’ 관련 준비를 했는지 의문이다. 아무튼, 이렇게 준비를 하고 면접을 보러 갔다. 상세한 질문 내용은 적지 않겠지만 상황을 설명하겠다. 2:1 면접이었고 분위기는 굉장히 편안했다. 면접관분들도 면접자를 많이 배려해주었다. 그래서 걱정이 사라지고 긴장도 풀렸다. 하지만, 나의 준비와는 다르게 면접이 흘러갔다. 전산학 기초와 관련된 질문이 대부분이었고, 프로젝트에 관련된 질문은 비중이 굉장히 적었다. 그래서 답변이 부족했고, 그에 따라 자신감도 적어지며 대답에 대한 확신이 없었다. 소위 말해서 말렸다. 면접을 보고 나서 떨어질 확률이 높았다. 그래서 기대를 하지 않았지만, 결과를 받으니 실망이 컸다. 나의 준비가 부족했지만, 그때는 핑계를 대고 싶었나보다. 핑계를 대면서 '준비한 부분이 나오지 않았다.'라는 식의 핑계였다. 지금와서 생각해보니 어리석은 핑계였고 그냥 부족했던 거였다. 그렇게 조금 아픈 경험을 하고 빠르게 잊었다. 그래도 느낀 점은 있었다. 전산학 기초가 부족했고 질문에 대한 답변을 하는 능력이 부족하다는 걸 많이 깨달았다. 부족한 부분에 대한 보강이 필요하다는 걸 절실히 느낄 수 있는 기회였다. DDD 동아리 이전에 활동했던 동아리를 졸업?하고 다른 동아리를 할지말지 고민했다. 그러던 와중에 친구에게 DDD라는 동아리를 소개받고 괜찮아 보여서 지원을 했고 합격하여 활동을 시작했다. 먼저, 좋다고 생각했던 점은 다음과 같다. 직장인이 많이 활동한다. 하나의 주제를 잡고 스터디를 한다. 활동 처음부터 팀을 정해 프로젝트를 시작해서 기간이 길다. 이러한 이유 때문에 DDD 동아리가 괜찮다고 생각했다. 3월부터 시작을 했고 RxJava 책을 정해 스터디를 진행했다. 2주에 한 번씩 모여 챕터별로 맡아서 공부하고 발표를 했다. 동시에 프로젝트는 팀별로 진행을 했다. 필자는 프로젝트를 하면서 이전에는 해보지 않았던 것이나 새로운 기술을 적용하고 싶었다. 새로운 기술 혹은 새로운 것을 적용하는 것은 설레면서 재미있다. 하지만, 그 과정은 쉽지만은 않다. 이 프로젝트에서 필자가 하고 싶은 것은 다음과 같았다. 새로운 아키텍처를 공부해서 적용하는 것 -&gt; MVVM 동시에 새로운 기술들을 적용해보는 것 유지보수가 원활하게 디자인 요소를 컴포넌트화 하는 것 RxJava를 적용하는 것 새로운 아키텍처를 적용해봤다. 전에 MVP를 사용했지만, 이번에 새로운 패턴을 적용해보고 싶었다. 이유는 View와 Presenter가 1:1 관계를 갖는다는 점과 인터페이스의 작성이 많아진다는 게 조금은 불편했다. 그래서 MVVM을 적용하기 위해 여러 블로그와 코드를 참고하여 프로젝트에 적용을 했다. 처음에 이게 맞는 것인가 싶어서 다른 사람의 코드를 비교했는데, 결국 MVVM 패턴도 각자의 코딩 스타일에 따라서 조금씩은 다르다는 것을 알았다. 큰 범주는 같지만 그 안에서 어떻게 코딩하는지는 각자 다 다르다는 것을 알았다. 이를 통해서 내 코드에 대한 의심은 없어졌고 다른 사람들은 어떻게 작성했는지 보면서 깨달음도 얻고 이 과정에서 공부도 할 수 있어서 좋은 기회였다. 계속해서 어떻게 하면 의존성을 낮추고 유지보수하기 좋은 코드를 작성할 수 있는지 생각할 수 있는 계기가 되었고, 다른 사람의 코드를 해석하는 과정에서 공부가 되었다. :) 새로운 기술을 적용해보고 싶었다. 적용하기 힘들지만, 구현하고 나면 성취감과 뿌듯함이 몰려온다. 필자는 Motion Layout과 BottomNavigationView에 애니메이션을 적용했다. 먼저, 모션 레이아웃은 카카오뱅크처럼 스크롤할 때 이미지가 작아지면서 우측 상단으로 이동시키고 싶었다. 자연스러운 Transition이 필요했고 깔끔하게 코드 없이 xml로만 작성할 수 있다는 장점이 있어서 모션 레이아웃을 적용했다. 두 번째는 BottomNavigationView에 애니메이션을 적용하는 것이다. 이는 내용이 길어질 것 같아서 짧게 말하면, 하단탭을 눌렀을 때 애니메이션을 보여주는 것이다. ShapeShifter라는 사이트를 통해서 svg 파일로 애니메이션을 만들어서 안드로이드에 앱에 적용하면 된다. 이 기술들을 적용하면서 삽질도 많이 했고, 포기하려고도 해봤지만 꼭 구현하고 싶은 마음이 강했기 때문에 완성할 수 있었다. 이 과정에서 많은 공부를 할 수 있었고 새로운 기술을 적용하는 것에 대한 두려움도 없앨 수 있었다. 새로운 기술을 적용하는 것은 언제나 즐겁다. ^0^ 디자인 요소를 컴포넌트화 하는 것은 예전부터 하고 싶었던 작업이었다. 이전에 프로젝트는 기간이 짧아서 여유롭게 회의를 해서 이런 디자인 요소를 일치시키는 작업을 한 경험이 없었다. 하지만, 이번 프로젝트는 초반에 여유가 있어서 디자이너들과 함께 디자인 요소에 관해 회의를 할 수 있었다. 먼저, 마진을 8의 배수로 지정해서 공통적으로 사용할 수 있게 그리드 형식으로 UI를 구성해주었다. 그래서 마진 값이 8의 배수로만 떨어졌고 일반적인 규칙이 있어서 레이아웃을 작성할 때, 편했다. 예를 들면, 타이틀은 좌우에서 24dp만큼 떨어지는 규칙이 있어서 편하게 적용할 수 있었다. 두번째는 style과 color이다. text나 button에 대한 스타일도 컴포넌트화 시켜서 어느 곳에서든 필요한 곳이 있으면 가져다 쓸 수 있도록 지정했다. 그래서 한 속성이 이전과는 다르면 그 속성만 수정하여 재사용이 원활했다. 덕분에 레이아웃을 작성할 때, 재사용이 용이했으며 유지보수도 원활하게 할 수 있어서 뜻깊은 프로젝트가 되었다. 나중에는 가이드를 정해서 가이드에 맞게 디자인 요소를 컴포넌트화 해야겠다. 안드로이드 직군이 RxJava를 함께 공부해서 프로젝트에 부분적으로 적용하는 것은 그리 어렵지 않았다. 연산자도 그 역할을 알고 사용했기 때문에 재미있었다. 하지만, 활용하는 것은 조금 쉽지 않았다. 아무래도 공부가 더 필요한 것 같다. DDD 동아리는 혼자서 공부하고 새로운 걸 많이 도전해볼 수 있는 좋은 기회가 되었던 것 같다. 여행 취업 준비도 하면서 동아리 프로젝트를 진행하니 생각보다 바빴다. 그래서 쉬지 못하고 계속 공부와 프로젝트를 병행했다. 더운 여름을 맞이하기 전에 시원한 곳으로 떠나고 싶었다. 그래서 블라디보스토크로 떠나기로 했다. 생각보다 추웠다. 그래도 굉장히 재미있게 잘 다녀왔다. 가보고 싶은 곳도 거의 다 방문했고 마지막 날에는 아쿠아리움에 가서 돌고래쇼도 볼 수 있어서 너무 좋았다. 첫 해외 여행이었지만, 돈을 모아서 다른 곳도 여행하고 싶은 마음이 잔뜩 생겼다. 재미있고 행복한 힐링 여행이었다. 취업 준비 동아리 활동이 끝났다. 이제 본격적인 취업 준비에 들어가기로 했다. 함께 동아리에서 진행했던 프로젝트를 완전 마무리 짓고 스토어에 올릴 계획을 세웠다. 이유는 처음에 프로젝트를 시작할 때 목표 중 하나가 스토어에 올리는 것이었기 때문이다. 하지만, 아직 서버와 관련해서 통신하는 과정에 매끄럽지 못한 부분이 있어서 이 부분을 수정해야 한다. 수정해야 한다는 생각만을 가지고 각자 다들 바쁘게 지내면서 시간이 흘러갔다. 필자는 취업 준비를 하면서 알고리즘 공부를 꾸준하게 했고, 전산학 관련 공부도 했다. 동시에 프로젝트에서 사용한 기술과 적용한 패턴, 그리고 시행착오도 정리를 했다. 그러다 이전 동아리의 행사에서 리쿠르팅 관련 발표를 하시는 것을 봤고 채용 공고를 접하게 되었다. 스타트업에 지원해보고 싶었다. 왜냐하면 빠르게 성장할 수 있을 것 같았다. 치열하겠지만, 시간이 지나 돌아봤을 때 확실히 달라진 모습일 것 같았다. 사실, 내가 하기 나름이겠지만 열심히 한다면 큰 성장을 경험할 수 있을 것 같았다. 그래서 더는 고민하지 않고 지원했다. 서류로 지원서와 포트폴리오를 제출했다. 몇일 뒤에 연락이 왔고 서류 합격과 함께 간단한 코딩 테스트를 본다고 했다. 그래서 구현 문제 위주로 풀었다. 2문제가 나왔고 어려운 난이도는 아니었지만, 애매한 부분이 있었다. 문제를 풀고 제출을 했다. 이후에 복기를 하면서 다시 풀어봤는데, 접근 방법이 조금 틀렸다는 것을 알게 되었다. 그래도 떨어지는 것보다는 붙는다는 것을 생각하여 1차 면접 준비를 조금씩 했다. 문제를 다시 풀어보고 기술적인 부분들을 준비했다. 준비한게 기특해서였는지 좋은 기회를 주셨다.(아마 신이 주신게 분명하다.) 1차 면접을 보러 오라는 제안 메일을 받았다. 면접 준비를 하면서 계속 이야기하는 연습을 했다. 면접관과 이야기하는 것이기 때문에 모르더라도 이야기할 수 있도록 노력했다. 그리고 대망의 면접!! 기술적인 부분과 필자가 진행한 프로젝트에 관한 내용이 주였다. 아는 내용은 최대한 설명하려고 노력했고, 모르는 부분은 생각해 본 다음 떠오르면 대답했고 그렇지 않은 경우 모르겠다고 당당하게 말했다. 면접 시간은 꽤 길었다. 기억은 잘 나지 않는다. 면접이 끝나고 집에 가려 했는데, 퇴근 시간과 겹쳐서 근처 카페로 가서 면접 봤던 내용을 정리했다. 기억이 잘 안나는데 최대한 생각해보고 정리를 했다. 정리를 하는 이유는 필자가 어떤 질문에 대답을 못했는지를 파악하기 위함이고 혹시나 떨어진다면 다음에 다른 곳 면접 볼 때, 도움이 되지 않을까 하기 때문이다. 집에 와서 씻고 꿀잠을 잤다. 거의 9시간 정도 숙면을 취했다. 긴장을 많이 해서 그런듯 싶다. 하루는 그냥 휴식을 취했다. 힘이 안났다. 그리고 몇일 지나서 2차 면접 제안 메일을 받았다. 좋은 기회를 또 받을 수 있어서 행복했다. 2차 면접은 임원 면접이라고 채용 공고에서 본 적이 있었다. 그래서 기술적인 질문이 아닌 인성 질문에 대해서 준비를 했고, 자기 소개와 지원 동기 등등을 준비했다. 2차 면접을 봤다. 1차 면접보다는 시간이 짧았지만 제대로 된 답변을 하지 못한 것이 많았다. 많이 당황했고, 쉽지 않았던 면접이었다고 생각한다. 그래서 끝나고 집에 돌아오는 길에 '아, 느낌이 좋지 않다.'라고 생각을 하며 힘 없이 돌아왔다. 1차 면접때와 비슷하게 긴장을 많이해서 힘이 없었다. 그래서 이날도 아마 9시간 꿀잠을 잤다. ㅎㅎ 그리고 결과가 나오기까지 휴식을 취하면서 알고리즘만 조금씩 풀었다. 그리고 몇일이 지나서 합격했다는 메일을 받았다. 드디어 합격하게 되었다. 입사일까지 몇일이 남아서 가족들과 시간을 보내고 친구들도 만나고 못한 업무 같은 것들을 처리하면서 쉬려고 한다. 취업 학생의 신분은 끝이 났지만, 이제 직장인 즉 개발자의 신분으로는 새로운 시작이다. 그러니 끝났다는 것에 안주하지 말고 잘 쉬다가 다시 버닝을 해야 한다. 잘 쉬다가 출근하면서 열심히 하자~ 그동안 수고했다. 앞으로 더 수고하자~","categories":[],"tags":[{"name":"2019","slug":"2019","permalink":"https://woovictory.github.io/tags/2019/"},{"name":"Review","slug":"Review","permalink":"https://woovictory.github.io/tags/Review/"},{"name":"회고","slug":"회고","permalink":"https://woovictory.github.io/tags/회고/"}]},{"title":"[Android] koin part.2","slug":"Android-koin2","date":"2019-08-08T11:42:07.000Z","updated":"2020-03-01T10:25:06.114Z","comments":true,"path":"2019/08/08/Android-koin2/","link":"","permalink":"https://woovictory.github.io/2019/08/08/Android-koin2/","excerpt":"","text":"koin과 관련된 두 번째 포스팅이다. 첫 번째 포스팅이 궁금하다면 다음 링크를 참고하면 된다. koin part.1 koin과 Dagger를 간단하게 비교하고 koin에서 추가되거나 변경된 기능에 대해서 살펴보도록 하겠다. koin과 Dagger의 차이점 Dagger는 Annotation을 통해 컴파일 과정에서 DI를 주입한다. 물론 Annotation을 처리하는 과정에서 컴파일 속도가 느려질 순 있지만 논리적으로는 런타임 과정에서 에러가 발생하지않고 순수한 자바로 되어있다. Koin은 런타임 과정에서 DI를 주입하고 컴파일 시 오버헤드가 없는 반면, 런타임중 Crash가 자주 발생한다. 또한, Kotlin DSL에 의존하고 있기 때문에 순수한 코틀린 코드로 작성되어있다. Dagger 장점 순수 자바 안정적이고 유연하다. 런타임 에러가 발생하지 않는다. 런타임시에 매우 빠르다. 단점 컴파일시 오버헤드가 발생한다. 학습곡선이 상당하다. (쉽지않음.) Koin 장점 Annotation 과정이 없어 컴파일이 빠르다. 학습하기 쉽고 설치도 간단하다. 단점 런타임 중 에러가 발생한다. Dagger에 비해 런타임시 오버헤드가 있다. Koin 정식버전 Koin의 안정적인 정식 버전이 나왔다. 이로 인해 변경되거나 추가된 기능이 있는데, 일부만 살펴보겠다. 자세한 내용은 아래 링크를 참조하면 된다. Koin developers 1.Bean이 아닌 Single 기존 싱글톤을 만들 때, bean{}으로 만들었지만, 이제는 single{}을 이용해서 만든다. 12345val retrofitModule = module&#123; single&#123; BusinessService() &#125;&#125; 2. Scope 추가 MVP 패턴 사용시 Presenter에 Scope를 주어 메모리를 효율적으로 관리할 수 있다. 1234567val appModule = module&#123; // Scope로 session을 준다. // Application Level에서 Module을 정의할 때, 사용. scope(\"session\")&#123; MyScopePresenter(get()) &#125;&#125; Activity나 Fragment 레벨에서 다음과 같이 사용한다. 123456789101112class MainActivity: AppCompatActivity()&#123; // scope에 바인딩된 Presenter를 생성한다. val scopePresenter: MyScopePresenter by inject() override fun onCreate(savedInstanceState: Bundle?)&#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // session scope가 현재 액티비티의 Lifecycle을 따름을 선언한다. bindScope(getOnCreateScope(\"session\")) &#125;&#125; Dagger처럼 Scope를 도입하기는 했지만, 생각보다 유연하지 않은 것 같다고 합니다. 3. Parameter 전달 ViewModel 등에 Parameter를 넘기는 문법이 바뀌었다. 다음과 같다. 12345viewModel &#123; parameterList -&gt; SomeViewModel( parameterList[0], parameterList[1], parameterList[2] )&#125; 위와 같이 람다식으로 파라미터를 선언한다. 123class SomeViewModel: ViewModel(val pararmFirst: String, val paramTwo: String, val paramThree: String)&#123; // 생략.&#125; 뷰모델 클래스에서 인자만큼 선언해준다. 그 다음은 아래와 같다. 1by viewModel&lt;DialogViewModel&gt;&#123;parametersOf(\"param1\", \"param2\")&#125; 위와 같이 parametersOf를 이용해 인자들을 전달한다. 4. Koin Test 테스트를 하기 위해 아래의 의존성을 Gradle에 추가한다. implementatin 'org.koin:koin-test:1.0.1' 12345678910111213141516171819202122232425open class BaseTest: KoinTest&#123; @Before fun before()&#123; // StandAloneContext로 코인을 시작한다. StandAloneContext.startKoin( listOf(contextModule, networkModule, repositoriesModule) ) &#125; @Test fun myTest()&#123; // DI를 주입한다. val service: BusinessService = get() // by inject도 가능하다. // 테스트 코드 작성. &#125; @After fun after()&#123; // 테스트 후 Koin을 정지한다. StandAloneContext.stopKoin() &#125;&#125; 이외에도 Koin에서는 많은 테스트 메소드를 제공하고 있다. 이곳에서 확인할 수 있다. Reference koin github koin developers [Android] Koin vs Dagger 그리고 추가된기능","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"DI","slug":"DI","permalink":"https://woovictory.github.io/tags/DI/"},{"name":"koin","slug":"koin","permalink":"https://woovictory.github.io/tags/koin/"}]},{"title":"[Kotlin] 더블콜론(::) 참조","slug":"Kotlin-Double-Ref","date":"2019-08-08T07:03:39.000Z","updated":"2020-05-12T15:18:34.136Z","comments":true,"path":"2019/08/08/Kotlin-Double-Ref/","link":"","permalink":"https://woovictory.github.io/2019/08/08/Kotlin-Double-Ref/","excerpt":"","text":"코틀린에서 사용하는 더블콜론 참조에 대해서 알아보려고 한다. 리플렉션(Reflection)이란 코틀린에서 더블콜론(::)은 리플렉션을 위해 사용한다. 리플렉션이란 코드를 작성하는 시점에는 런타임상 컴파일된 바이트 코드에서 내가 작성한 코드가 어디에 위치하는지 알 수 없기 때문에 바이트 코드를 이용해 내가 참조하려는 값을 찾기위해 사용한다. 자바와 코틀린에서의 리플렉션 12SomeClass.class -&gt; 클래스 그 자체를 리플렉션someInstance.getClass() -&gt; 인스턴스에서 클래스를 리플렉션 자바에서는 클래스를 참조할 때 위와 같이 사용한다. 12SomeClass::classsomeInstance::class 코틀린에서는 더블콜론을 리플렉션을 위해 사용하며 위와 같은 형태로 사용한다. 하지만 우리가 액티비티를 넘길 때는 SomeClass::class.java와 같이 끝에 .java가 붙는 것을 볼 수 있다. 그 이유는 자바에서 쓰는 클래스와 코틀린에서 쓰는 클래스가 다르기 때문이다. 자바에서의 SomeClass.class는 Class를 리턴한다. 반면, 코틀린에서는 SomeClass::class를 하면 KClass를 리턴한다. 그렇기 때문에 KClass를 Class로 바꾸어 주어야하는데 이때 .Java를 이용하여 자바 클래스 값을 받는다. KClass 안의 java의 getter는 위 그림과 같이 확장함수 형태로 되어있으며 KClass에서 자바의 클래스 타입을 반환한다. 코틀린에서의 함수참조 코틀린에서 SomeClass::class와 같이 클래스를 참조할 수도 있지만 SomeClass:Method와 같이 클래스 내의 메소드도 참조할 수 있고 ::Function 형식의 함수도 참조할 수 있다. 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; val numbers = listOf(1, 2, 3, 4, 5, 6, 7, 8) numbers.filter(::isOdd) .forEach &#123; println(it) &#125;&#125;fun isOdd(x: Int): Boolean &#123; return x % 2 != 0&#125;// 단축형//fun isOdd(x: Int) = x % 2 !=0 isOdd() 함수를 filter를 사용한 코드이다. filter를 사용하면서 함수참조를 이용해 ::isOdd 형태로 함수를 호출하였다. 필터의 원형은 IntArray에서 Int 값을 받아 Boolean을 반환하는 inline 함수이다. 마찬가지로 Int를 받아 Boolean을 반환하기 때문에 함수를 참조하여 동일한 형식의 isOdd를 사용할 수 있다. Reference 코틀린의 더블콜론(::) 참조","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"}]},{"title":"[Kotlin] ixXXX() 함수들","slug":"Kotlin-isXXX-funcion-diff","date":"2019-08-08T05:11:00.000Z","updated":"2020-05-12T15:18:29.924Z","comments":true,"path":"2019/08/08/Kotlin-isXXX-funcion-diff/","link":"","permalink":"https://woovictory.github.io/2019/08/08/Kotlin-isXXX-funcion-diff/","excerpt":"","text":"코틀린에서 제공되는 isEmpty, isNotEmpty, isBlank, isNotBlank, isNullOrBlank, isNullOrEmpty 함수의 차이점을 알아보려고 한다. 비교를 위해 사용할 문자열은 다음과 같다. 123456val emptyString = \"\"val blankString = \" \"val blankNewLineString = \" \\n\"val withBlankString = \" victory\"val nullString: String? = nullval standardString = \"standard\" isEmpty CharSequence가 아무 값도 포함하고 있지 않을 때, true를 반환한다. 결과는 다음과 같다. 1234567891011121314 println(emptyString.isEmpty()) println(blankString.isEmpty()) println(blankNewLineString.isEmpty()) println(withBlankString.isEmpty()) println(nullString?.isEmpty()) println(standardString.isEmpty())// 결과truefalsefalsefalsenullfalse isNotEmpty CharSequence가 어떠한 값을 포함하고 있을 때(공백 포함), true를 반환한다. 결과는 다음과 같다. 1234567891011121314 println(emptyString.isNotEmpty()) println(blankString.isNotEmpty()) println(blankNewLineString.isNotEmpty()) println(withBlankString.isNotEmpty()) println(nullString?.isNotEmpty()) println(standardString.isNotEmpty())// 결과falsetruetruetruenulltrue isBlank CharSequence가 공백만을 가지고 있을 경우나 empty일 경우, true를 반환한다. 결과는 다음과 같다. 공백+개행문자 -&gt; 공백으로 판단한다. 1234567891011121314 println(emptyString.isBlank()) println(blankString.isBlank()) println(blankNewLineString.isBlank()) println(withBlankString.isBlank()) println(nullString?.isBlank()) println(standardString.isBlank())// 결과truetruetruefalsenullfalse isNotBlank CharSequence가 empty 상황이 아니고, 값에 공백만 있지 않을 때 true를 반환한다. 즉, 아무 값도 없거나 공백만 있을 때는 false를 반환한다. 결과는 다음과 같다. 1234567891011121314 println(emptyString.isNotBlank()) println(blankString.isNotBlank()) println(blankNewLineString.isNotBlank()) println(withBlankString.isNotBlank()) println(nullString?.isNotBlank()) println(standardString.isNotBlank())// 결과falsefalsefalsetruenulltrue isNullOrEmpty CharSequence가 비어있거나 null일 경우, true를 반환한다. 공백은 비어있는게 아니다. 그래서 false를 반환한다. 결과는 다음과 같다. 1234567891011121314 println(emptyString.isNullOrEmpty()) println(blankString.isNullOrEmpty()) println(blankNewLineString.isNullOrEmpty()) println(withBlankString.isNullOrEmpty()) println(nullString.isNullOrEmpty()) println(standardString.isNullOrEmpty())// 결과truefalsefalsefalsetruefalse isNullOrBlank CharSequence가 null이거나 blank인 상황일 때, true를 반환한다. 공백+개행 -&gt; 비어있음(blank 상태) 결과는 다음과 같다. 12345678// 결과truetruetruefalsetruefalse Summary 어려운 내용은 아니지만, 헷갈리는 함수들이다. 그래서 사용할 때 자주 헷갈려서 정리를 했다. 주의해야 할 점은 다음과 같다. empty : 정말 아무 값도 가지지 않는 것을 말한다. blank보다 empty가 작은 개념. blank : 공백만 있거나 정말 아무 값도 가지지 않는 것을 의미한다. 공백+개행문자도 공백으로 판단 blank가 더 큰 개념. Reference [Android/Kotlin] isNotEmpty(), isNotBlank(), isNullOrEmpty(), isNullOrBlank() 차이점","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"함수 차이","slug":"함수-차이","permalink":"https://woovictory.github.io/tags/함수-차이/"}]},{"title":"[Kotlin] inline, infix","slug":"Kotlin-inline","date":"2019-08-04T05:59:31.000Z","updated":"2020-05-12T15:19:13.917Z","comments":true,"path":"2019/08/04/Kotlin-inline/","link":"","permalink":"https://woovictory.github.io/2019/08/04/Kotlin-inline/","excerpt":"","text":"커니의 코틀린이라는 책을 참고하여 코틀린을 공부했다. inline이라는 개념이 나왔지만 간단하게만 설명이 되어있었고, 필자도 간단하게만 정리하고 넘어갔다. 그런데 다시 보니 무슨 개념인지 모르겠어서 정리하려고 한다. OverView 문서는 다음과 같이 설명되어있다. 고차 함수를 사용하면 런타임 패널티가 있기 때문에 함수 구현 자체를 코드 내부에 넣음으로써 오버헤드를 없앨 수 있다. 무슨 내용인지 잘 와닿지 않는다. 다음의 글을 보고 다시 생각해보자. 일급 함수 일급 함수는 스스로 객체로써 취급되는 함수로 다른 함수를 파라미터로 전달받고 반환할 수 있는 함수를 뜻한다. 코드를 통해서 확인해보자. 12345fun print(body: (Int, Int) -&gt; Int)&#123; println(body(5,5))&#125;print(&#123;a,b -&gt; a&#125;) 위 함수는 두 개의 정수를 받아 하나의 정수값만을 출력하는 함수이다. 위와 같은 선언을 하게 된다면 Java에서 아래와 같은 코드로 변화을 하여 사용할 수 있다. 12345public final void print(@NotNull Fuction2 body)&#123; Intrinsics.checkParameterIsNotNull(body, \"body\"); Object result = body.invoke(5,5); System.out.println(result);&#125; 위와 같이 자동으로 컨버팅이 될 수 있기 때문에 아래와 같은 유동적인 방법도 사용이 가능하다. 1234567891011121314private fun printResult(body: (Int, Int) -&gt; Int)&#123; println(body(10,5))&#125;fun sum(a: Int, b: Int) = a + bfun subtract(a: Int, b: Int) = a - bfun main(args:Array&lt;String&gt;)&#123; printResult(::sum) printResult(::subtract)&#125;// 결과155 위의 코드처럼 sum이나 subtract를 유동적으로 붙일 수 있다. inline 123456789fun doSomething(body: () -&gt; Unit)&#123; body()&#125;fun callFunction()&#123; doSomething&#123; print(\"문자열 출력!\") &#125;&#125; 위의 코드를 자바로 표현하면 다음과 같다. 1234567public void doSomething(Function body)&#123; body.invoke();&#125;public void callFunction()&#123; doSomething(System.out.println(\"문자열 출력!\"));&#125; 위의 코드와 같이 자바로 표현된다. 그리고 이 자바코드는 아래와 같이 변환된다. 12345678public void callFunction()&#123; doSomething(new Function()&#123; @Override public void invoke()&#123; System.out.println(\"문자열 출력!\"); &#125; &#125;);&#125; 문제는 위의 sum이나 subtract처럼 조합하는 함수가 많아질수록 계속 N개만큼의 function 오브젝트가 생성된다. 이럴때 사용하게 되는 것이 inline 키워드이다. 123456789inline fun doSomething(body: () -&gt; Unit)&#123; body()&#125;fun callFunction()&#123; doSomething&#123; println(\"문자열 출력\") &#125;&#125; 위의 코드는 아래와 같이 변환된다. 123public void callFunction()&#123; System.out.println(\"문자열 출력!\");&#125; 그리고 실제로 컴파일 시 doSomething()의 body()를 호출하는 부분에 저렇게 선언된 함수가 그대로 들어가게 된다. 12// body() 부분에 그대로 들어온다.System.out.println(\"문자열 출력!\"); 위와 같이 Fuction 인스턴스를 만들지 않고 callFunction 내부에 삽입되어 바로 선언되어지게 된다. 때문에 람다함수와 1급 함수가 호출된 곳에서 해당 함수를 가지게 된다. 하지만 inline 함수는 주의할 점이 있는데, private 키워드를 사용하여 함수를 정의할 수 없다. 대신 다른 접근 한정자인 internal을 사용해야 한다. noinline 모든 람다함수에 inline을 쓰고싶지 않을 수 있다. 이 경우 아래와 같이 해당 람다 함수에 noinline 키워드를 추가해준다. 1234inline fun callLambda(aLambda: () -&gt; Unit, noinline dontInlineLambda: () -&gt; Unit, aLambda2: () -&gt; Unit)&#123; // 실행.&#125; 모든 함수를 inline을 사용하여 내부로 컨버팅 되어지길 원치않을 수 있다. 이 경우 위처럼 inline을 먼저 선언한 뒤 람다함수 중 사용하지 않을 함수에 noinline 키워드를 붙여준다. 참고 [kotlin] inline, noinline 한번에 이해하기","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"코틀린","slug":"코틀린","permalink":"https://woovictory.github.io/tags/코틀린/"},{"name":"inline","slug":"inline","permalink":"https://woovictory.github.io/tags/inline/"},{"name":"infix","slug":"infix","permalink":"https://woovictory.github.io/tags/infix/"}]},{"title":"[Android] AsyncTask","slug":"AsyncTask","date":"2019-08-03T12:01:12.000Z","updated":"2020-05-26T07:05:51.697Z","comments":true,"path":"2019/08/03/AsyncTask/","link":"","permalink":"https://woovictory.github.io/2019/08/03/AsyncTask/","excerpt":"","text":"OverView 안드로이드에서는 기본적으로 메인 스레드를 갖는다. 이를 UI 스레드라고 부르기도 하는데, UI 관련 작업을 해당 스레드에서만 작업하도록 제한하기 때문에 이렇게 부른다. UI 스레드에서는 UI 관련 작업만 한다고 했는데, 그렇다면 파일을 다운로드 받거나 네트워크를 통해 데이터를 받아오는 입출력 작업 등의 시간이 오래 걸리는 작업을 하면 앱의 반응성이 낮아지고 안드로이드 시스템은 사용자의 사용성을 위해 ANR(Application Not Responding)을 발생시키게 된다. 이 문제를 해결하기 위해 안드로이드에서는 Handler, AsyncTask 등의 방법을 제공한다. 이번 포스팅에서 알아볼 친구는 AsyncTask이다. 그 중에서도 문제점과 유의사항이다. 사실 인터넷에 많은 사용법과 개념이 있으니 여기서는 다루지 않겠다. AsyncTask Google은 AsyncTask를 사용할 때, '수 초 내의 동작에만 사용’하는 것을 권장하고 있다. 그 이상의 작업을 하고 싶을 때는 별도의 스레드를 생성해 직접 구현하는 것을 권장한다. 그 이유는 AsyncTask가 액티비티에 종속되지 않기 때문이다. 1. AysncTask 사용 규칙 AsyncTask는 일회용 클래스이다. 두 번 이상 사용하면 안된다. 두 번째 execute() 호출시 오류가 발생한다. AsyncTask 객체는 메인스레드에서 생성되어야 하고 실행되어야 한다. AsyncTask의 콜백 메소드인 onPreExecute(), doInBackground(), onProgress() 등을 수동으로 호출하면 오류가 발생한다. 2. AsyncTask가 액티비티에 종속되지 않아 생길 수 있는 문제 AsyncTask는 액티비티에 포함되지 않는다. 그래서 doInBackground()가 수행되고 있는 동안에 액티비티가 종료되면 수행되던 AsyncTask는 다음과 같은 2가지 문제가 발생할 수 있다. 액티비티 종료 시의 문제점 AsyncTask를 execute() 하고 doInBackground()가 수행되고 있는 동안에 액티비티가 먼저 종료되면 AsyncTask와 액티비티는 독립적인 존재이므로 AsyncTask가 종료되지 않는다. 액티비티가 종료되더라도 doInBackground()의 수행이 끝날 때까지 AsyncTask는 실행 중 상태를 유지하게 된다. doInBackground() 수행 완료 후에 AsyncTask의 생명주기 상 onCancelled()나 onPostExecute() 메소드가 호출된다. 이때 존재하지 않은 액티비티의 UI에 접근을 한다면 메모리 누수(Memory Leak)이 발생하고 IllegalArgumentException 에러가 발생할 수 있다. 그래서 다음처럼 액티비티가 종료될 때, AsyncTask의 cancel() 메소드를 호출해 오류를 방지해야 한다. 1234override fun onDestroy() &#123; super.onDestroy() task.cancel(true) &#125; 디바이스의 화면 회전시의 문제점 액티비티 종료시의 문제점 사례와 같은 상황이다. 액티비티는 디바이스의 화면을 회전시키면 액티비티가 종료되고 새로운 액티비티가 생성된다. 그렇게 되면 액티비티의 모든 변수가 초기화되고 회전 전에 실행했던 AsyncTask는 계속 백그라운드에서 수행이 되고 doInBackground()가 종료되고 난 뒤에 UI 객체에 접근을 하면 메모리 누수와 스레드 IllegalArgumentException 에러가 발생할 수 있다. 3. AsyncTask를 취소하는 방법 AsyncTask는 수행 중에 cancel()을 호출하여 취소할 수 있다. cancel()이 한 번이라도 호출되면 isCancelled() 메소드는 true를 반환한다. 하지만 주의해야 할 것은 cancel()을 호출했다고 doInBackground()의 실행이 취소되는 것은 아니라는 점이다. 액티비티 종료나 화면이 회전되는 상황이 발생했을 때 cancel()을 호출하더라도 남아있는 작업은 계속 돌게 되어 원치 않은 상황이 될 수 있다. 그래서 작업 취소 요청에 바로 반응하기 위해서 doInBackground() 메소드에서 주기적으로 isCancelled()의 반환값을 확인하여 적절한 조치를 취해야 한다. 참고 안드로이드 | 스레드 | AsyncTask의 문제점과 유의사항 안드로이드 개념 및 예제 - AsyncTask","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"AsyncTask","slug":"AsyncTask","permalink":"https://woovictory.github.io/tags/AsyncTask/"},{"name":"비동기 작업","slug":"비동기-작업","permalink":"https://woovictory.github.io/tags/비동기-작업/"}]},{"title":"[Java] Static Method Overriding?!","slug":"Java-Static-Method-Override","date":"2019-07-31T08:45:34.000Z","updated":"2020-04-22T07:47:33.490Z","comments":true,"path":"2019/07/31/Java-Static-Method-Override/","link":"","permalink":"https://woovictory.github.io/2019/07/31/Java-Static-Method-Override/","excerpt":"","text":"Java에서 오버라이딩이란 기본적이면서 중요한 개념이다. 간략하게 말하면 부모 클래스의 메소드를 자식 클래스에서 재정의하여 사용하는 것이라고 할 수 있다. 그러면 여기서 의문이 하나 생기는데, static 메소드는 오버라이딩이 될까? 오버라이딩이 어떤 개념이라는 것은 알지만, 실제로 이런 경우를 생각해보니 대답을 하기 쉽지 않다. 대답을 하더라도 이유를 정확히 아는 것인지도 모르겠다. 그래서 '과연 가능한가? 불가능한가?'를 알아보기 위해서 해당 글을 작성하게 되었다. static 메소드는 오버라이딩이 될까? 필자는 static 메소드가 오버라이딩이 된다고 생각을 했다. 이유는 인터페이스에 디폴트 메소드와 static 메소드가 추가된 것이 생각나서 그렇게 생각했다. 그런데, 다시 생각해보니까 아닌 것 같았다. static 메소드는 컴파일할 때, 메모리에 올라가서 메소드 영역에 존재한다. 즉, 객체 생성과 관련이 없고 해당 클래스로부터의 모든 인스턴스가 공유할 것이다. 그런데 이게 오버라이딩이 되면 논리가 맞지 않는다. 나의 생각이 맞는지 확인해보자. 일단, 실제로 되는지 안되는지 테스트해보자. 123456789101112131415161718192021// 부모 클래스.public class Parent &#123; public static void louder()&#123; System.out.println(\"나는 부모 클래스의 louder 이다.\"); &#125; public void talk()&#123; System.out.println(\"나는 부모 클래스의 talk 이다.\"); &#125;&#125;// 자식 클래스.public class Child extends Parent&#123; public static void louder()&#123; System.out.println(\"나는 자식 클래스의 louder 이다.\"); &#125; public void talk()&#123; System.out.println(\"나는 자식 클래스의 talk 이다.\"); &#125;&#125; 이렇게 구성한 클래스를 실행시켜보자. 1234567891011121314151617181920212223public class CheckMain &#123; public static void main(String[] args) &#123; Parent p = new Parent(); p.louder(); p.talk(); Parent c = new Child(); c.louder(); c.talk(); &#125;&#125;// 예상 결과나는 부모 클래스의 louder 이다.나는 부모 클래스의 talk 이다.나는 자식 클래스의 louder 이다.나는 자식 클래스의 talk 이다.// 실제 결과나는 부모 클래스의 louder 이다.나는 부모 클래스의 talk 이다.나는 부모 클래스의 louder 이다.나는 자식 클래스의 talk 이다. static 메소드는 상속이 되지 않는다. 이유는 static 메소드는 클래스가 컴파일되는 시점에 결정이 되지만 override의 경우에는 런타임 시점에 사용될 메소드가 결정이 된다. 그래서 애초에 성립하기가 어려운 것이다. static 메소드의 경우 클래스 단위로 만들어지기 때문에 객체 단위로 형성되는 Override는 성립될 수 없다. 즉, 런타임시에 c 객체가 실제로 참조하고 있는 클래스를 찾아가는 것이 아니라 컴파일시에 결정된 클래스를 찾아가서 해당 메소드를 호출하기 때문이다. 필자가 생각했던 것과 비슷한 이유이다. 그런데 뭔가 아직 부족한 것 같은 느낌이 든다. JVM은 static method를 호출할 때, instance method의 경우 런타임시 해당 메소드를 구현하고 있는 실제 객체를 찾아 호출한다. -&gt; 다형성. 하지만 컴파일러와 JVM 모두 static method에 대해서는 실제 객체를 찾는 작업을 시행하지 않기 때문에 class method(static method)의 경우, 컴파일 시점에 선언된 타입의 메소드를 호출한다. 컴파일러와 JVM 모두 클래스 (스태틱)메소드에 대해서는 실제 객체를 찾는 작업을 시행하지 않기 때문이다. 그래서 static 메소드에서는 다형성이 적용되지 않는다. 원칙적으로는 오버라이딩이 안되지만 아래 코드처럼 오버라이딩된 것처럼 구현이 가능하다. 자바에서는 이같은 경우를 하이딩(hiding)이라고 한다. 하이딩은 이론적으로만 존재할 뿐, 실제 프로그래밍에서 클래스를 설계할 때 추천되는 방법은 아니다. 오버라이드된(하이딩된) static method를 정확하게 호출하려면 메소드가 포함된 실제 객체로 선언해야 한다. 웬만하면, 하이딩의 사용은 피하자. 12345678910111213141516171819202122232425// 기본적인 상속과 구현.public class A&#123; public static void test() &#123; System.out.println(\"A test()\"); &#125;&#125;class B extends A&#123; @Override // 컴파일 오류 public static void test() &#123; System.out.println(\"B test()\"); &#125;&#125;// 하이딩.public class A&#123; public static void test() &#123; System.out.println(\"A test()\"); &#125;&#125;class B extends A&#123; public static void test() &#123; System.out.println(\"A test()\"); &#125;&#125; 참고 static method와 Override hiding 대한 정리 왜 자바에서 static메소드의 오버라이딩을 허용하지 않는걸까요? Overriding Vs Hiding - Override Static Method","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"},{"name":"Static 메소드","slug":"Static-메소드","permalink":"https://woovictory.github.io/tags/Static-메소드/"},{"name":"Overriding","slug":"Overriding","permalink":"https://woovictory.github.io/tags/Overriding/"},{"name":"오버라이딩","slug":"오버라이딩","permalink":"https://woovictory.github.io/tags/오버라이딩/"}]},{"title":"[RxJava] Chap01 리액티브 소개","slug":"RxJava-Chap01-Introduce","date":"2019-07-31T04:38:38.000Z","updated":"2020-05-26T07:07:05.623Z","comments":true,"path":"2019/07/31/RxJava-Chap01-Introduce/","link":"","permalink":"https://woovictory.github.io/2019/07/31/RxJava-Chap01-Introduce/","excerpt":"","text":"해당 포스팅 글이 로컬에서만 보이는 문제로 인하여 재업로드한 글입니다. RxJava와 관련된 내용은 RxJava 프로그래밍 책을 구매하여 공부하면서 참고하였습니다. 앞으로 작성하는 RxJava 글은 위의 책으로 공부하면서 정리한 내용입니다. 문제가 된다면 해당 게시글을 삭제하도록 하겠습니다. 아래 글은 제가 책을 보고 공부한 내용과 참고한 내용으로 작성되었으므로 정확하지 않을 수 있으니 깃헙에 있는 이메일로 연락주시면 감사하겠습니다. 리액티브 프로그래밍 리액티브 프로그래밍 리액티브 프로그래밍(Reative Programming)은 반응형 프로그래밍이라고도 한다. 데이터 의 흐름과 전달에 관한 프로그래밍 패러다임이다. 기존의 명령형 프로그래밍은 주로 컴퓨터 하드웨어를 대상으로 프로그래머가 작성한 코드가 정해진 절차에 따라 순서대로 실행된다. 리액티브 프로그래밍은 데이터 흐름을 먼저 정의하고 데이터가 변경되었을 때 연관되는 수식이나 함수가 업데이트되는 방식이다. 가장 쉽게 이해할 수 있는 예는 MS의 엑셀(즉, 스프레드 시트)이다. 엑셀에서 값을 변경했을 때 자동으로 반영되는 것이 이러한 예를 설명한다. 기존의 명령형 프로그래밍 &lt;–&gt; 반응형 프로그래밍(즉, 리액티브 프로그래밍) 명령형 프로그래밍 방식은 변경이 발생했다는 통지를 받아서 연말 매출액을 새로 계산하는 당겨오는(pull) 방식이지만, 리액티브 프로그래밍은 데이터 소스가 변경된 데이터를 밀어주는(push 방식이다. 일종의 옵저버 패턴이라고 생각하면 된다. 명령형 프로그래밍의 반대말은 선언형 프로그래밍이라고도 한다. ex) SQL. 반응형 프로그래밍은 선언형 프로그래밍을 지향한다. 자바언어와 리액티브 프로그래밍 기존의 pull 방식의 프로그래밍 개념 -&gt; push 방식의 프로그래밍 개념으로 바뀜. 함수형 프로그래밍의 지원을 받는다. 리액티브 프로그래밍에서는 데이터의 변화가 발생했을 때 변경이 발생한 곳(데이터 소스)에서 새로운 데이터를 보내(push 방식) 준다. 기존 자바 프로그래밍이 pull 방식이라면 리액티브 프로그래밍은 push 방식이다. 한편 우리가 아는 콜백이나 옵저버 패턴을 넘어서 RxJava 기반의 리액티브 프로그래밍이 되려면 함수형 프로그래밍이 필요하다. 콜백이나 옵저버 패턴은 옵저버가 1개이거나 단일 스레드 환경에서는 문제가 없지만, 멀티 스레드 환경에서는 사용시 많은 주의가 필요하다. 대표적인 예가 데드락과 동기화문제이다. 추가적으로 함수형 프로그래밍은 부수 효과(side effect)가 없다. 부수 효과란 콜백이나 옵저버 패턴이 스레드에 안전하지 않은 이유가 같은 자원에 여러 스레드가 경쟁 조건(race condition)에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오는 것을 말한다. 한 두개의 스레드가 있을 때는 잘 동작하다가 수십, 수백개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이게 되고 디버깅도 어려워진다. 함수형 프로그래밍은 부수 효과가 없는 순수 함수(pure function)를 지향한다. 따라서 멀티 스레드 환경에서도 안전하다. 자바를 사용해 리액티브 프로그래밍을 하기 위해서는 함수형 프로그래밍의 도움이 필요하다. 그럼 여기서 말하는 함수형 프로그래밍은 무엇을 말하는 걸까? 간략하게 말하면 함수형 프로그래밍 언어는 함수를 단지 호출하는 대상이 아닌 변수로도 할 수 있고 인자로도 넘길 수 있고 마음대로 지지고 볶고? 할 수 있다. (아직 개념이 정확히 잡히지 않아서. . ㅜㅜ) 어려운 말로는 일급 시민이라고 표현한다고 한다. 반응형 프로그래밍은 이런 함수형 언어의 도구들을 자유자재로 활용해야 한다. 예를 들어 Java 8에 도입된 람다 표현식은 반드시 알아야 한다. 리액티브 프로그래밍 개념 다시 잡아보자. RxJava를 비롯해서 리액티브 프로그래밍을 공부하다 보면 새로 등장하는 개념으로 인해 많은 혼란을 겪는다고 한다. 일단, 프로그래밍 스타일이 너무 다르다. 자바는 객체 지향 언어인데 리액티브 프로그래밍은 뭔가 좀 다른 것 같다. 그리고 내가 문제를 바라보는 개념도 이전과는 달라야 하는 것 같다. 이 부분은 아직 감이 안잡히지만 천천히 잡아보도록 하겠다. 아무튼 어렵고 새로운 개념은 초반에 잘 잡아놓으면 나중에 공부할 때 도움이 많이 되기 때문에 여기서 잘 잡아서 앞으로 나아가자. 다음은 위키 백과에 나와 있는 설명 중 일부분이다. 위키 백과의 일부 상호 작용 프로그램은 프로그램이 주도하는 속도로 사용자 혹은 다른 프로그램과 상호작용 한다. 사용자의 관점으로 볼 때 시분할 시스템은 상호작용 프로그램이다. 리액티브 프로그래밍은 주변의 환경과 끊임없이 상호작용을 하는데 프로그램이 주도하는 것이 아니라 환경이 변하면 이벤트를 받아 동작한다. 상호작용 프로그램은 자신의 속도에 맞춰 일하고 대부분 통신을 담당하는 반면 리액티브 프로그램은 외부 요구에 반응에 맞춰 일하고 대부분 정확한 인터럽트 처리를 담당한다. 자바에서는 이런 RxJava와 같은 리액티브 프로그래밍을 하기 위해서 기반이 마련되야 한다. 즉, 데이터 소스를 정의할 수 있고 그것의 변경 사항을 받아서 내 프로그램에 알려줄 존재(push)가 필요하다. 이를 RxJava 라이브러리를 통해서 구현할 수 있다. RxJava를 만든 이유가 뭘까?? RxJava는 지금 우리가 아주 아주 잘 사용하는 [넷플릭스]\u001d(https://www.netflix.com/kr/)의 기술 블로그에서 처음 소개되었다. 성능 개선을 위해서 넷플릭스는 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅(??)하여 RxJava를 만들었다. 넷플릭스가 RxJava를 만든 핵심적인 이유는 아래와 같다. 동시성을 적극적으로 끌어안기에 자바는 번거롭다. 자바가 동시성(? 정확히 뭐지…?)을 처리하기에 번거롭기 때문에 넷플릭스는 클라이언트의 요청을 서비스 계층에서 동시성을 적극적으로 끌어안음으로 이를 해결했다. 클라이언트의 요청을 처리할 때 다수의 비동기 실행 흐름(스레드 등등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다고 한다. 자바의 Future를 조합하기 어렵다?! 약 6년 전 (시간이 벌써 2019년이라니ㅜ.ㅜ) 내가 대학교 1학년일 때이다. 이 당시에 자바 8에서 제공하는 CompletableFuture 같은 클래스가 제공되지 않았다고 한다. 그래서 비동기 흐름을 조합할 수 있는 방법이 거의 없었고, RxJava에서는 이를 해결하려고 비동기 흐름을 조합(Compose)할 수 있는 방법을 제공한다. RxJava에서 조합하는 실행 단위를 리액티브 연산자(Operator)라고 한다. 콜백 지옥 탈출! 콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황은 코드의 가독성을 떨어트린다. 또한, 문제 발생 시 디버깅을 어렵게 만든다. 콜백은 비동기 방식으로 동작하는 가장 대표적인 패턴이다. 이런 지옥을 탈출하고자 RxJava에서는 콜백을 사용하지 않는 방향으로 설계하려고 했다. 정리 위에서 쭉 반응형 프로그래밍(즉, 리액티브 프로그래밍)은 비동기 데이터의 흐름과 전달에 초점을 맞춘 패러다임이다. 그리고 함수형 프로그래밍 언어의 지원을 받고 이를 활용한다고 했다. 정리하자면 반응형 프로그래밍은 함수형 프로그래밍 언어의 도구들을 가지고 데이터의 흐름을 Composable(구성 가능하게?!)하게 구현하는 것이라고 할 수 있다. 참고 RxJava 반응형 프로그래밍이란 무엇인가? 아래는 참고하면 좋을 자료들! 함수형 프로그래밍이란 무엇인가? 함수형 프로그래밍 RxJava에 관하여 RxJava 기초","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Rxjava","slug":"Rxjava","permalink":"https://woovictory.github.io/tags/Rxjava/"},{"name":"리액티브 프로그래밍","slug":"리액티브-프로그래밍","permalink":"https://woovictory.github.io/tags/리액티브-프로그래밍/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","permalink":"https://woovictory.github.io/tags/함수형-프로그래밍/"}]},{"title":"[Android] Live Template?!","slug":"AndroidStudio-Live-Template","date":"2019-07-15T02:24:17.000Z","updated":"2020-03-01T10:26:10.003Z","comments":true,"path":"2019/07/15/AndroidStudio-Live-Template/","link":"","permalink":"https://woovictory.github.io/2019/07/15/AndroidStudio-Live-Template/","excerpt":"","text":"매일 아침 10시에 Daily DevBlog를 통해서 개발 관련 블로그 포스팅들이 메일로 온다. 이를 통해서 매일 아침 따끈따근한 소식을 볼 수 있고, 내가 관심 있어하는 주제가 있다면 얻을 수 있어서 굉장히 좋아하고 잘 사용하고 있다. 어쨋든, 오늘 글의 주제는 이게 아니다. 글을 보던 중 괜찮은 내용이 있어서 참고해서 작성하려고 한다. Android Studio의 Live Template 기능이다. Live Template 지극히 주관적인 생각이지만, 개발자들은 귀찮은 걸 싫어하는 것 같다. 코딩을 하더라도 조금만 귀찮은 작업이라면 싫어한다. 그래서 IDE에서 제공하는 기능을 잘 사용한다면 귀찮음을 덜어줄 수 있다. 그 중에서 나는 JetBrains이 만든 IDE가 좋다고 생각한다. 물론, IDE에서 제공하는 기능을 잘 사용한다면 말이다. Live Template은 축약형 값을 입력하면 자주 쓰는 코드 구성을 불러오는 기능이다. 쉽게 말해 상용구이다. 안드로이드 스튜디오에서 기본적으로 제공하는 라이브 템플릿 중에서도 유용한 것들이 꽤 있고, 사용자가 직접 커스텀해 사용할 수도 있다. 하나의 예로, 우리가 자주 사용하는 반복문 중 for문을 사용한다고 가정해보자. for문의 fo만 입력해도 밑에 자동 완성으로 제공되는 모습을 볼 수 있을 것이다. 설정을 변경할 수도 있고, 사용자가 원하는 상용구를 추가할 수도 있다. 환경 설정(Preferences) -&gt; Editor -&gt; Live Template 에 들어가면 템플릿을 확인할 수 있다. 커스텀해보자. 그렇다면 간단한 커스텀 템플릿을 만들어보자. 12val intent = Intent(this, MainActivity::class.java)startActivity(intent) 액티비티 이동을 위해서 이렇게 두 줄을 입력하기가 귀찮을 수 있다. 물론, 함수로 빼서 사용할 수도 있지만 그 경우는 제외하고 지금 상황만 보자. 그래서 축약형을 적었을 때, 위에 정의한 두 줄이 자동 생성되도록 하고 싶다. 현재 액티비티는 자동으로 완성되고, 이동할 두 번째 클래스명만 입력하도록 할 것이다. cis를 입력했을 때 아래의 두 줄이 뜨게 할 것이다. Preferences -&gt; Editor -&gt; Live Template 창에서 우측 상단의 + 버튼을 눌러 새로운 Template Group을 만든다. 만든 Group을 누른 상태에서 + 버튼을 한 번 더 누른 뒤, Live Template을 눌러 Template Text를 입력해준다. 12val intent = android.content.Intent(this@$first$, $second$::class.java)startActivity(intent) android.content.Intent를 입력함으로써 자동으로 import되도록 했다. 먼저, 이 템플릿을 어디에서 호출하여 사용할 것인지 지정해야 한다. 하단에 보면 주의사항 No applicable contexts 옆의 Define을 눌러 kotlin 전체에 체크해준다. 다음으로 $first$와 $second$는 자유롭게 정할 수 있는 변수명이다. 이 변수에 대한 설정은 Template Text 코드 우측 하단에 Edit variables에서 설정할 수 있다. 누르면 Expression을 불러 사용할 수 있다. first 변수 : 미리 정의되어 있는 함수 목록에서 클래스 이름을 불러오는 className() 메소드를 사용한다. 오른쪽에 있는 Skip if defined에 체크하면 템플릿을 불러온 후, 커서가 바로 second 변수 쪽으로 이동하도록 설정할 수 있다. second 변수 : 직접 다음 액티비티 이름을 적어줄 것이기 때문에 아무 작업을 하지 않는다. 이제 Ok 버튼을 눌러서 마무리하면 코드에서 사용할 수 있다. 필자는 cis라는 축약형을 사용했다. 위 그림을 보면 cis 축약형을 입력했을 때, 원하는 코드가 뜨는 것을 확인할 수 있다. 결론 Live Template을 사용하면 간단한 코드를 작성하는 것을 템플릿화시켜서 아주 유용하게 사용할 수 있을 것 같다. 아주 유용한 기능이다. 참고 [Android] Live Template 라이브 템플릿","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://woovictory.github.io/tags/Android-Studio/"},{"name":"Live Template","slug":"Live-Template","permalink":"https://woovictory.github.io/tags/Live-Template/"}]},{"title":"[Android] DI에 대해서","slug":"DI","date":"2019-07-08T06:09:36.000Z","updated":"2020-05-12T11:30:35.717Z","comments":true,"path":"2019/07/08/DI/","link":"","permalink":"https://woovictory.github.io/2019/07/08/DI/","excerpt":"","text":"DI Dagger는 DI 프레임워크이다 DI는 Dependency Injection(의존성 주입)의 준말이다. 의존성 주입이란 외부에서 의존 객체를 생성하여 넘겨주는 것을 의미한다. 예를 들어 A class가 B class를 의존할 때 B Object를 A가 직접 생성하지 않고 외부에서 생서아여 넘겨주면 의존성을 주입했다고 할 수 있다. 왼쪽은 A에서 B,C를 생성하는 일반적인 의존 형태이고, 오른쪽은 외부에서 의존 객체를 생성하고 주입하는 형태이다. DI를 위해서는 객체를 생성하고 넘겨주는 외부의 뭔가가 필요하다. 이것이 DI 프레임워크가 하는 일이다. 외부에서 넘겨주는 무언가를 스프링에서는 컨테이너, Dagger에서는 Component와 Module이라고 부른다. DI는 이렇게 의존성이 있는 객체의 제어를 외부 Framework로 올리면서 IoC 개념을 구현한다. IoC는 Inversion of Control(제어의 역전)의 준말이다. 외부 컨테이너가 객체를 생성하고 주입한다. 제어가 거꾸로 가는 개념을 IoC라고 하고, DI는 IoC를 구현하는 방법 중 하나이다. DI는 왜 필요할까? 의존성 파라미터를 생성자에 작성하지 않아도 되므로 보일러 플레이트 코드를 줄일 수 있다. 이를 통해서 유연한 프로그래밍이 가능하다. Interface에 구현체를 쉽게 교체하면서 상황에 따라 적절한 행동을 정의할 수 있다. 이것은 특히 Mock 객체와 실제 객체를 바꿔가며 테스트할 때 유용하다. 즉, 테스트 가능한 코드를 작성할 수 있다. 이로 인해 재사용성이 높아지고 유지보수가 용이해진다. DI를 구현하는 방법은 다음과 같다. 직접 Provider를 구성해 코드로 작성하는 방법 라이브러리로 넘겨서 처리하도록 하는 방법 Dagger2 koin Dagger 이해하기 1. Inject 의존성 주입을 요청한다. Inject 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다. 2. Component 연결된 Module을 이용하여 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다. 3. Subcomponent Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위 계층 Component이다. Sub의 Sub도 가능하다. Subcomponent는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고, 없으면 부모로 올라가면서 검색한다. 4. Module Component에 연결되어 의존성 객체를 생성한다. 생성 후 Scope에 따라 관리도 한다. 5. Scope 생성된 객체의 Lifecycle 범위이다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서 Scope을 보고 객체를 관리한다. 위의 5가지 개념을 따라 Dagger가 의존성을 주입하는 플로우는 다음과 같다. Inject로 의존성을 요청하면 Subcomponent에서부터 Module을 검색하고, Scope에 따라 객체를 가져와 주입한다. koin과 관련된 글은 다음의 포스팅을 참고하면 된다. 참고 DI 기본개념부터 사용법까지, Dagger2 시작하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"의존성 주입","slug":"의존성-주입","permalink":"https://woovictory.github.io/tags/의존성-주입/"},{"name":"Dependency Injection","slug":"Dependency-Injection","permalink":"https://woovictory.github.io/tags/Dependency-Injection/"}]},{"title":"[RxJava] Chap07. 디버깅","slug":"RxJava-Chap07","date":"2019-07-05T14:23:57.000Z","updated":"2020-05-26T07:06:44.637Z","comments":true,"path":"2019/07/05/RxJava-Chap07/","link":"","permalink":"https://woovictory.github.io/2019/07/05/RxJava-Chap07/","excerpt":"","text":"디버깅 코딩하는 도중에 로그를 넣는 이유는 잘못되었을 때를 대처하기 위함이다. 하지만 RxJava 코드는 로그를 넣을 수 있는 공간이 없다. Observable로 시작하는 업스트림(upstream)과 그것을 받아서 처리하는 다운스트림(downstream)이 동일한 문장으로 이루어져 있기 때문이다. 즉, 전체 동작을 선언적으로 만들 수 있으므로 전체 맥락에 대한 가독성은 높아지지만 예외 코드를 어떻게 넣어야 하는지에 대한 어려움이 있다. 원래 함수형 프로그래밍은 함수의 부수 효과를 없도록 하는 것이 원칙이지만 doOnXXX() 계열 함수는 오히려 부수 효과를 일으켜서 내가 작성하는 코드가 문제없는지 알아볼 수 있게 도와준다. 이번 Chapter에서 알아보자. doOnXXX() 함수 doOnNext(), doOnComplete(), doOnError() 3가지 함수는 Observable의 알림 이벤트에 해당한다. Observable에서 어떤 데이터를 발행할 때는 onNext, 중간에 에러가 발생하면 onError, 모든 데이터를 발행하면 onComplete 이벤트가 발생한다. 어떻게 보면 이 알림 이벤트를 위의 함수가 가로채서 디버깅을 할 수 있도록 도와주는 것이다. 1234567891011121314151617public class doOnXXX &#123; public static void main(String[] args) &#123; Observable.just(\"1\", \"3\", \"5\") .doOnNext(data -&gt; Log.d(\"onNext()\", data)) .doOnComplete(() -&gt; Log.d(\"onComplete()\")) .doOnError(error -&gt; Log.e(\"onError\", error)) .subscribe(Log::i); &#125;&#125;// 결과main | onNext() | debug = 1main | value = 1main | onNext() | debug = 3main | value = 3main | onNext() | debug = 5main | value = 5main | debug = onComplete() 결과는 위와 같이 나온다. doOnNext(), doOnComplete(), doOnError() 함수를 사용해 로그를 출력해봤다. 모두 main 스레드에서 실행되었고, 실제로 Observable이 구독자에게 발행한 데이터는 value로 표시하였다. 하지만, doOnError() 함수의 동작을 보지 못했다. 다른 예제를 통해서 확인해보자. 1234567891011121314151617public class doOnXXX &#123; public static void main(String[] args) &#123; Observable.just(10, 5, 0) .map(divider -&gt; 1000 / divider) .doOnNext(data -&gt; Log.d(\"onNext()\", data)) .doOnComplete(() -&gt; Log.d(\"onComplete()\")) .doOnError(error -&gt; Log.e(\"onError()\", error.getMessage())) .subscribe(Log::i); &#125;&#125;// 결과main | onNext() | debug = 100main | value = 100main | onNext() | debug = 200main | value = 200main | onError() | error = / by zeroio.reactivex.exceptions.OnErrorNotImplementedException: The exception was not handled due to missing onError handler in the subscribe() method call. Further reading 어떤 수를 0으로 나누려고 하기 때문에 0 데이터가 발행될 때 에러가 발생하는 것을 볼 수 있다. doOnEach() 함수 onNext, onComplete, onError 이벤트를 각각 처리하는 것이 아니라 한 번에 처리할 수 있기 때문에 편리하다. 123456789101112131415161718192021222324252627public class doOnEach &#123; public static void main(String[] args) &#123; Observable.just(\"ONE\", \"TWO\", \"THREE\") .doOnEach(noti -&gt; &#123; if (noti.isOnNext()) &#123; Log.d(\"onNext()\", noti.getValue()); &#125; if (noti.isOnComplete()) &#123; Log.d(\"onComplete()\"); &#125; if (noti.isOnError()) &#123; Log.d(\"onError()\", noti.getError().getMessage()); &#125; &#125;) .subscribe(Log::i); &#125;&#125;// 결과main | onNext() | debug = ONEmain | value = ONEmain | onNext() | debug = TWOmain | value = TWOmain | onNext() | debug = THREEmain | value = THREEmain | debug = onComplete() Notification 객체는 발생한 이벤트의 종류를 알 수 있는 boolean 타입의 isOnNext(), isOnComplete(), isOnError() 함수를 제공한다. onNext()의 경우는 getValue() 함수를 호출하면 발행된 값을 얻을 수 있다. onError() 함수의 경우 getError() 함수를 호출하면 Throwable 객체를 얻을 수 있다. doOnEach() 함수는 오직 onNext, onComplete, onNext 이벤트만 처리한다. 그리고 람다식을 잘 활용하여 간결하 코드를 유지하도록 한다. doOnSubscribe(), doOnDispose(), 기타 함수 Observable의 알림 이벤트 중에는 onSubscribe와 onDispose 이벤트도 있다. 각각 Observable을 구독했을 때와 구독 해지했을 때의 이벤트를 처리할 수 있다. doOnSubscribe() : Observable을 구독했을 때 어떤 작업을 할 수 있다. 람다 표현식의 인자로는 구독의 결과로 나오는 Disposable 객체가 제공된다. doOnDispose() : Observable의 구독을 해지했을 때 호출되며 인자는 Action 객체이다. 여러 스레드에서 Observable을 참조할 수 있기 때문에 Action 객체는 Thread-Safe하게 동작해야 한다. 12345678910111213141516171819public class doOnSubscribe &#123; public static void main(String[] args) &#123; Observable&lt;String&gt; source = Observable.just(\"1\", \"3\", \"5\", \"2\", \"6\") .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS), (a, b) -&gt; a) .doOnSubscribe(data -&gt; Log.d(\"onSubscribe()\")) .doOnDispose(() -&gt; Log.d(\"onDispose\")); Disposable d = source.subscribe(Log::i); CommonUtils.sleep(200); d.dispose(); CommonUtils.sleep(300); &#125;&#125;// 결과main | debug = onSubscribe()RxComputationThreadPool-1 | value = 1RxComputationThreadPool-1 | value = 3main | debug = onDispose 한편 doOnSubscribe()와 doOnDispose() 함수를 각각 호출하지 않고 한번에 호출하는 함수인 doOnLifeCycle() 함수가 존재한다. 위의 코드에서 doOnSubscribe()와 doOnDispose() 함수를 빼고 doOnLifeCycle() 함수를 사용하면 된다. 결과는 같다. 또한, doOnTerminate() 함수는 Observable이 끝나는 조건이 onComplete 혹은 onError 이벤트가 발생했을 때 실행하는 함수이다. 정확하게는 onComplete() 혹은 onError() 이벤트 발생 직전에 호출된다. 다음 코드를 통해서 결과를 확인해보자. 12345678910111213141516171819202122public class doOnTerminate &#123; public static void main(String[] args) &#123; Observable.just(\"1\", \"3\", \"5\", \"7\") .doOnTerminate(() -&gt; Log.d(\"onTerminate()\")) .doOnNext(data -&gt; Log.d(\"onNext()\", data)) .doOnComplete(() -&gt; Log.d(\"onComplete()\")) .doOnError(error -&gt; Log.d(\"onError()\", error.getMessage())) .subscribe(Log::i); &#125;&#125;// 결과main | onNext() | debug = 1main | value = 1main | onNext() | debug = 3main | value = 3main | onNext() | debug = 5main | value = 5main | onNext() | debug = 7main | value = 7main | debug = onTerminate()main | debug = onComplete() onComplete 이벤트가 발생하기 직전에 doOnTerminate() 함수가 호출되는 것을 확인할 수 있다. 예외 처리 자바에서는 예외를 처리할 때 try-catch문을 사용했지만, RxJava에서는 사용할 수 없다. 사용한다면 다음과 같은 에러를 만나게 된다. 1OnErrorNotImplementedException RxJava 내부에서 onError를 함수의 인자로 넘긴다. 따라서 try-catch문을 활용할 수가 없다. 추가로 함수 체인이나 Observable 내부에서 예외가 발생해도 onError 이벤트가 발생하고 try-catch 문으로는 해결할 수 없다. onErrorRetrun() 함수 에러도 어떠한 데이터로 보는 것이 적절하다. 예외가 발생했을 때 에러를 의미하는 다른 데이터로 대체한다. onError 이벤트는 데이터 흐름이 바로 중단되므로 subscribe() 함수를 호출할 때, onError 이벤트를 처리하는 것은 OOM 같은 중대한 에러가 발생했을 때만 활용한다. 에러가 발생했을 때 내가 원하는 데이터로 대체할 수 있다. 위의 그림에서 앞의 3개의 데이터가 정상적으로 발행되고 마지막 데이터에서 에러가 발생하는 경우, onErrorReturn() 함수는 인자로 넘겼던 기본ㄱ밧을 대신 발행하고 onComplete 이벤트가 발생한다. onError() 이벤트는 발생하지 않는다. 12345678910111213141516171819202122public class onErrorReturn &#123; public static void main(String[] args) &#123; String[] grades = &#123;\"70\", \"60\", \"$100\", \"93\", \"83\"&#125;; Observable&lt;Integer&gt; source = Observable.fromArray(grades) .map(data -&gt; Integer.parseInt(data)) .onErrorReturn(e -&gt; &#123; if (e instanceof NumberFormatException) &#123; e.printStackTrace(); &#125; return -1; &#125;); source.subscribe(data -&gt; &#123; if (data &lt; 0) &#123; Log.e(\"Wrong Data found!!\"); return; &#125; Log.i(\"Grade is \" + data); &#125;); &#125;&#125; 에러를 onErrorReturn() 함수에서 처리하며 NumberFormatException 발생 시 -1을 리턴한다. subscribe() 함수는 성적 데이터를 처리하므로 0보다 커야 하낟. onErrorReturn() 함수에서 예외 발생 시 음수 값을 리턴했으므로 data가 0보다 작으면 에러 발생 여부를 판단하고 에러 로그를 출력한다. onError 이벤트에서 예외를 처리하는 것과 다른 점 예외 발생이 예상되는 부분을 선언적으로 처리할 수 있다. Observable을 생성하는 측과 구독하는 측이 서로 다를 수 있다는 점이다. 구독자는 Observable에서 발생할 수 있는 예외를 구독한 이후에 파악하는 것이 어렵다. 다시 말하면 Observable에서 에러 가능성을 명시하지 않았는데 구독자가 필요한 예외 처리를 빠짐없이 하는 것은 어렵다는 뜻이다. 이럴때 Observable을 생성하는 측에서 발생하는 예외 처리를 미리 해두면 구독자는 선언된 예외 상황을 보고 그에 맞는 처리를 할 수 있다. onErrorReturnItem() : onErrorReturn() 함수와 동일하지만 Throwable 객체를 인자로 전달하지 않기 때문에 코드는 좀 더 간결해진다. 즉, 가독성이 좋아진다. 1234567891011121314151617public class onErrorReturn &#123; public static void main(String[] args) &#123; String[] grades = &#123;\"70\", \"60\", \"$100\", \"93\", \"83\"&#125;; Observable&lt;Integer&gt; source = Observable.fromArray(grades) .map(data -&gt; Integer.parseInt(data)) .onErrorRetrunItem(-1) source.subscribe(data -&gt; &#123; if (data &lt; 0) &#123; Log.e(\"Wrong Data found!!\"); return; &#125; Log.i(\"Grade is \" + data); &#125;); &#125;&#125; onErrorResumeNext() 함수 onErrorReturn(), onErrorReturnItem()은 에러가 발생한 시점에 특정 값으로 대체. 에러가 발생했을 때, 내가 원하는 Observable로 대체하는 방법이다. Observable로 대체한다는 것은 에러 발생 시 데이터를 교체하는 것뿐만 아니라 관리자에게 이메일을 보낸다던가 자원을 해제하는 등의 추가 작업을 해야할 때 유용하다. 에러가 발생했을 때, 특정 값을 원하는 Observable로 설정할 수 있다. 123456789101112131415161718192021222324252627public class onErrorResumeNext &#123; public static void main(String[] args) &#123; String[] salesData = &#123;\"100\", \"200\", \"A300\"&#125;; Observable&lt;Integer&gt; onParseError = Observable.defer(() -&gt; &#123; Log.d(\"send email to administrator\"); return Observable.just(-1); &#125;).subscribeOn(Schedulers.io()); Observable&lt;Integer&gt; source = Observable.fromArray(salesData) .map(Integer::parseInt) .onErrorResumeNext(onParseError); source.subscribe(data -&gt; &#123; if (data &lt; 0) &#123; Log.e(\"Wrong Data Found!\"); return; &#125; Log.i(\"Sales data: \" + data); &#125;); &#125;&#125;// 결과main | value = Sales data: 100main | value = Sales data: 200RxCachedThreadScheduler-1 | debug = send email to administratorRxCachedThreadScheduler-1 | error = Wrong Data Found! 이처럼 에러가 발생했을 때 관리자에게 이메일을 보내고 '-1’이라는 데이터를 발행하는 Observable로 대체한다. onParseError 변수는 subscribeOn() 함수를 호출하여 IO 스케줄러에서 실행한다. 이처럼 내가 원하는 코드를 실행하는 스케줄러를 선언적으로 지정할 수 있어 활용범위가 넓다. retry() 함수 예외 처리의 다른 방법은 재시도이다. 예를 들어 서버와 통신할 때 인터넷이 일시적으로 안되거나 서버에 일시적인 장애가 발생하면 클라이언트에서는 일정 시간 후에 다시 통신을 요청하는 것이 필요하다. 이때 1개의 API가 아닌 다수의 API를 연속해서 호출해야 하는 경우 재시도하는 시나리오가 복잡해질 수도 있다. 이런 것을 단순하게 처리할 수 있는 retry() 함수를 제공한다. onError 이벤트 발생 시 해당 처리를 재시도한다. 123456789101112131415public class RetrySample &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); String url = \"https://api.github.com/zen\"; Observable&lt;String&gt; source = Observable.just(url) .map(OkHttpHelper::getT) .retry(5) .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE); source.subscribe(data -&gt; &#123; Log.it(\"result: \" + data); &#125;); &#125;&#125; retry() 함수의 실행횟수는 5회로 지정한다. 마지막으로 에러 발생시 ERROR_CODE를 반환한다. 재시도 동작을 확인하기 위해서는 인터넷 환경을 끊은 상태에서 테스트를 진행해야 한다. 결과는 다음과 같다. 1234567main | 645 | error = api.github.com: nodename nor servname provided, or not knownmain | 646 | error = api.github.commain | 646 | error = api.github.commain | 647 | error = api.github.commain | 647 | error = api.github.commain | 647 | error = api.github.commain | 647 | value = result: -500 5회의 재시도 후 최종 요청이 실패 처리되었다. getT() 함수를 통해서 api 접속을 시도하지만 예외가 발생해서 에러 로그를 찍는 부분으로 빠진다. 요청을 5번 시도하면서 계속 에러 로그를 찍고 그 후에 onErrorReturn() 함수에서 에러 코드를 반환하고 종료한다. 위에서 실행 시간이 문제가 있다. 재시도를 할 때 지연 시간이 없이 바로 재시도하기 때문에 도움이 되지 않는다. 지연 시간을 설정해서 재시도를 해보자. 1234567891011121314151617181920212223public class RetryDelaySample &#123; public static void main(String[] args) &#123; final int RETRY_MAX = 5; final int RETRY_DELAY = 1000; CommonUtils.exampleStart(); String url = \"https://api.github.com/zen\"; Observable&lt;String&gt; source = Observable.just(url) .map(OkHttpHelper::getT) .retry((retryCount, e) -&gt; &#123; Log.e(\"retryCount: \" + retryCount); CommonUtils.sleep(RETRY_DELAY); return retryCount &lt; RETRY_MAX ? true : false; &#125;) .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE); source.subscribe(data -&gt; &#123; Log.it(\"result: \" + data); &#125;); &#125;&#125; 재시도 횟수는 5회이고 지연 시간 간격은 1000ms이다. 재시도할 때 CommonUtils.sleep() 함수를 호출해 1000ms 동안 대기한다. api 호출을 하고 인터넷 연결이 되어 있지 않다면 재시도를 하게 된다. 5번까지 재시도를 하고 1000ms 간격으로 시도를 하면서 재시도 횟수를 로그를 통해 기록한다. 재시도 횟수가 5회 이하일 때는 true를 이후에는 false를 반환한다. 결과는 다음과 같다. 1234567891011main | 716 | error = api.github.com: nodename nor servname provided, or not knownmain | error = retryCount: 1main | 1721 | error = api.github.commain | error = retryCount: 2main | 2726 | error = api.github.commain | error = retryCount: 3main | 3726 | error = api.github.commain | error = retryCount: 4main | 4728 | error = api.github.commain | error = retryCount: 5main | 5732 | value = result: -500 retryUntil() retry() 함수는 재시도를 지속할 조건이 없을 때 재시도를 중단한다. 재시도를 중단할 조건이 발생할 때까지 재시도 한다. 함수 원형은 다음과 같다. 1public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop) BooleanSupplier 객체는 인자는 없고 Boolean 값을 리턴하는 함수형 인터페이스다. 즉, retryUntil() 함수의 인자로 Boolean 값을 리턴하는 구문이 들어가야 한다. 이게 재시도를 중단할 조건을 의미한다. 123456789101112131415161718192021222324public class RetryUntil &#123; public static void main(String[] args) &#123; CommonUtils.exampleStart(); String url = \"https://api.github.com/zen\"; Observable&lt;String&gt; source = Observable.just(url) .map(OkHttpHelper::getT) .subscribeOn(Schedulers.io()) .retryUntil(() -&gt; &#123; if (CommonUtils.isNetworkAvailable()) &#123; return true; // 중지. &#125; CommonUtils.sleep(1000); return false; // 계속 진행. &#125;) .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE); source.subscribe(Log::i); // IO 스케줄러에서 실행되기 때문에 sleep 함수가 필요함. CommonUtils.sleep(5000); &#125;&#125; 보통 재시도 로직은 별도의 스레드에서 동작하기 때문에 IO 스케줄러를 활용한다. retryUntil() 함수의 인자인 람다 표현식에는 먼저 CommonUtils.isNetworkAvailable()를 호출해 네트워크가 사용 가능한 상태인지 확인한다. 만약, true를 반환하면 재시도를 중단하도록 true를 반환한다. 네트워크를 사용할 수 없는 상태라면 1000ms를 쉬고 재시도(재구독)한다. 이때 람다 표현식은 false를 반환한다. 결국 retryUntil 함수의 인자인 람다 표현식이 true를 반환해야 재시도를 중단하게 된다. false를 반환하면 재시도를 계속하게 된다. 결과는 다음과 같다. Process가 종료된 것은 인터넷에 연결되어 재시도가 끝났다는 것으로 해석할 수 있다. 123456789101112RxCachedThreadScheduler-1 | 680 | error = api.github.com: nodename nor servname provided, or not knownRxCachedThreadScheduler-1 | Network is not availableRxCachedThreadScheduler-2 | 1685 | error = api.github.comRxCachedThreadScheduler-2 | Network is not availableRxCachedThreadScheduler-1 | 2691 | error = api.github.comRxCachedThreadScheduler-1 | Network is not availableRxCachedThreadScheduler-2 | 3695 | error = api.github.comRxCachedThreadScheduler-2 | Network is not availableRxCachedThreadScheduler-1 | 4698 | error = api.github.comRxCachedThreadScheduler-1 | Network is not availableProcess finished with exit code 0 retryWhen() 재시도와 관련된 함수 중 가장 복잡하다. 주로 재시도 조건을 동적으로 설정해야 하는 복잡한 로직을 구현할 때 사용한다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"디버깅","slug":"디버깅","permalink":"https://woovictory.github.io/tags/디버깅/"}]},{"title":"[Android] RecyclerView ClickListener","slug":"Android-RecyclerView-ClickListener-kotlin","date":"2019-07-05T03:34:18.000Z","updated":"2020-03-01T10:27:10.253Z","comments":true,"path":"2019/07/05/Android-RecyclerView-ClickListener-kotlin/","link":"","permalink":"https://woovictory.github.io/2019/07/05/Android-RecyclerView-ClickListener-kotlin/","excerpt":"","text":"이번에는 Android에서 RecyclerView를 사용할 때, 각 아이템의 ClickListener를 다는 방법에 대해서 설명하려고 한다. 여러가지 방법이 있겠지만, 이번에는 Kotlin의 특징 중 하나인 함수를 매개변수로 넘길 수 있다는 특징을 사용하려고 한다. 필자가 진행 중인 프로젝트의 일부 코드를 기반으로 설명할 예정이다. 구현 먼저, MainFragment에서 RecyclerView를 사용할 것이다. 그리고 RecyclerView의 각 아이템을 눌렀을 때 어떤 동작을 할 것인지를 미리 정의해둔다. 1234567private fun startToDetailActivity(id: Int, message: String) &#123; val intent = Intent(context, MissionDetailActivity::class.java) intent.putExtra(\"id\", id) intent.putExtra(\"completeMessage\", message) intent.putExtra(\"main\",\"main\") startActivity(intent) &#125; Int 타입인 id와 String 타입인 message를 매개변수로 받는 함수이다. 이 함수는 id, message를 가지고 MissionDetailActivity로 이동하는 함수이다. 이제는 이 함수를 RecyclerView에서 사용될 Adapter에 매개변수로 넘기는 과정이 필요하다. 이 과정은 두 단계로 나눠보도록 하겠다. Adapter에서 함수를 인자로 받을 수 있도록 수정. MainFragment에서 Adapter 객체를 만들 때 위에서 만든 함수를 전달한다. Adapter에서 함수를 인자로 받을 수 있도록 수정해보도록 하겠다. 1234567891011121314class MainMissionAdapter(private var onMainMissionItemClick: (Int, String) -&gt; Unit) : RecyclerView.Adapter&lt;MainMissionViewHolder&gt;() &#123; private var itemsMock = ArrayList&lt;MissionFeedResponse&gt;() override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MainMissionViewHolder &#123; val binding = ItemListMainMissionBinding.inflate( LayoutInflater.from(parent.context) , parent, false ) return MainMissionViewHolder(binding, onMainMissionItemClick) &#125; // 생략.&#125; MainMissionAdapter의 기본 생성자를 호출하면서 (Int, String) -&gt; Unit을 확인할 수 있다. 이는 Int, String을 인자로 받고 반환값이 없는 함수를 의미한다. 따라서 Int, String을 인자로 받고 반환값이 없는 함수를 매개변수를 받겠다는 의미이다. 그리고 onCreateViewHodler에서 MainMissionViewHolder에 매개변수로 받은 onMainMissionItemClick 함수를 넘기고 있다. ViewHolder는 위의 남은 단계가 끝나고 살펴볼 예정이다. 그러면 MainFragment에서 함수를 전달해보도록 하자. 함수를 전달할 때는 람다식을 사용할 수 있다. 이유는 익명 함수이기 때문에 람다식을 이용해서 가독성을 높이고 쉽게 처리할 수 있기 때문이다. 123mainMissionAdapter = MainMissionAdapter &#123; id, message -&gt; startToDetailActivity(id, message) &#125; 초기화 하는 코드이다. MainMissionAdapter의 인자로 id, message를 받는 익명함수가 전달되어야 하기 때문에 람다식을 통해서 id, message를 넘겨 받는다. 이는 위에서 구현해놓은 startToDetailActivity() 함수의 매개변수로 넘겨줘야 한다. 이것은 실제로 값을 받는 코드가 아니다. 이렇게 값을 받을 것이다라고 선언만 해놓은 것이지 아직 코드가 실행되지 않는다. 어떻게 보면 startToDetailActivity 함수를 Adapter에 넘기는 것이다. 이 함수는 위치는 MainFragment에 존재하는 것이고 이 함수의 호출을 대신하기 위해서 함수를 넘기는 것이다. 따라서 함수를 넘긴다는 것의 의미는 실제로 이 함수를 넘기는 것이 아니라 원하는 값을 얻어 이 함수에 담아서 호출하기 위함이다. 그래서 Adapter에서 ViewHolder로 넘기면 ViewHolder에서 onMainMissionItemClick 이라는 익명 함수를 받는다. 코드를 먼저 보도록 하자. 1234567891011121314class MainMissionViewHolder( private val binding: ItemListMainMissionBinding , private val onMainMissionItemClick: (Int, String) -&gt; Unit) : RecyclerView.ViewHolder(binding.root) &#123; fun onBind(item: MissionFeedResponse) &#123; binding.item = item binding.executePendingBindings() binding.itemMainImage.setOnClickListener &#123; onMainMissionItemClick.invoke(item.mission.id, item.mission.category.completeMessage) &#125; &#125;&#125; ViewHolder에서 필자가 원하는 아이템에 setOnClickListener를 통해서 클릭 리스너를 달아준다. 그리고 그 안에서 onMainMissionItemClick.invoke()를 호출함으로써 넘겨받은 함수를 대신 호출할 수 있도록 해준다. invoke() 함수가 함수를 대신 호출하는 의미를 가진듯 하다. 그래서 여기서 호출하게 되면 MainFragment에서 정의했던 startToDetailActivity() 함수가 호출되고 원하는 동작을 할 수 있게 된다. 내가 원하는 값을 인자로 받는 부분은 ViewHolder에서 이루어지게 되고 실제 함수는 MainFragment에 존재한다. 그리고 호출도 이 함수를 호출하게 되는 것이다. 설명을 두서없이 하였다. 다음에 Kotlin의 사용자 정의 get(), set()을 통해 변경된 코드로 다시 한번 설명하도록 하겠다. 그 때는 더 깔끔하게 글을 쓰도록 할 예정이다. 마지막으로 이 글을 쓴 목적은 코틀린스럽게 코드를 작성하고자 하는 사람들이 영어로 된 자료말고 이 자료를 통해서 더 쉽게 해당 지식을 얻어갔으면 하는 바램에서 작성하게 되었다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"},{"name":"ClickListener","slug":"ClickListener","permalink":"https://woovictory.github.io/tags/ClickListener/"}]},{"title":"[Android] EditText 유용한 기능","slug":"Android-EditTextFunction","date":"2019-07-04T06:56:02.000Z","updated":"2020-03-29T15:19:05.917Z","comments":true,"path":"2019/07/04/Android-EditTextFunction/","link":"","permalink":"https://woovictory.github.io/2019/07/04/Android-EditTextFunction/","excerpt":"","text":"안드로이드에서 EditText는 거의 필수적인 존재라고 봐도 무방할 것 같다. 자주 사용하지만, 매번 필요한 기능을 검색해보기 때문에 유용한 기능들을 정리하려고 포스팅하게 되었다. 기능 maxLength : EditText에 작성할 수 있는 최대 길이를 지정한다. singleLine : 이 기능은 true/false로 설정할 수 있으며, false로 설정하게 되면 EditText의 오른쪽 면에 닿으면 줄바꿈이 된다. scrollHorizontally : 이 기능도 마찬가지로 true/false로 설정할 수 있으며, false로 설정하게 되면 EditText의 길이가 오른쪽으로 길어져도 좌우 스크롤이 안된다. 필자는 singleLine과 scrollHorizontally 속성을 함께 사용하였다. inputType : 키보드의 형태를 지정할 수 있다. 숫자만으로 구성된 키보드를 띄울 수도 있고, e-mail 입력을 할 수 있도록 그에 맞는 키보드를 띄울 수 있다. 공식 문서를 참고하면 잘 정리되어있다. imeOptions : 키보드의 완료 버튼을 지정할 수 있다. 아무 값도 지정하지 않았다면 줄바꿈이 되어 있을 것이다. 필자는 완료를 위해서 actionDone으로 지정했다. style : EditText의 커서 색상이나 백그라운드 등을 바꾸고 싶다면 style을 작성해서 EditText에 지정해주면 된다. 추가적으로 생각이 나는 부분은 이 포스팅에 계속해서 올릴 예정이다. [2020.02.19 내용 추가] 이번에 추가하는 부분은 함수라기 보다는 개발하면서 알게 된 방법 중 하나이다. 정말 간단하고, 읽는데 1분도 안걸린다. 어떤 글에 대해 수정 버튼을 누르기 전에는 글을 수정할 수 없다. 하지만, 어떤 액션을 했을 경우, 글을 수정할 수 있도록 하기 위해서 EditText의 enabled 속성을 이용했다. 또한, drawable에 파일을 생성해 selector 같이 만들었다. drawable에 파일을 만든다 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:color=\"@android:color/holo_orange_dark\" android:state_enabled=\"false\" /&gt; &lt;item android:color=\"@android:color/black\" /&gt;&lt;/selector&gt; EditText의 textColor에 drawable 파일을 연결한다. 123456789101112131415&lt;EditText android:id=\"@+id/et_title\" android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"@android:color/white\" android:enabled=\"false\" android:gravity=\"center_vertical\" android:hint=\"@string/label_title\" android:paddingStart=\"@dimen/space_16\" android:paddingEnd=\"@dimen/space_8\" android:text=\"@&#123;vm.memo.title&#125;\" android:textColor=\"@drawable/selector_et\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/toolbar\" /&gt; [2020.03.30 추가] 자동 개행하기 필자는 EditText를 사용해 글을 입력 받는데, 오른쪽 면에 닿았을 때 자동 개행이 되기를 원했다. 그래서 android:scrollHorizontally=&quot;false&quot;를 설정하고 android:inputType=&quot;text&quot;로 설정했었다. 하지만, 자동 개행은 적용되지 않았다. 구글링을 해 본 결과 왜 되지 않는가에 대해서는 나오지 않았다. 필자가 생각하기로는 text로 설정함으로써 scrollHorizontally 속성이 제대로 적용되지 않는 것으로 판단이 되었다. 여기까지가 근거 없는 이유였다. 역시나 구글링을 더 해보니 이유를 생각할 수 있었다. EditText의 inputType 속성에 대해서 검색하고 찾아봤다. 그 중 필자가 사용했던 android:inputType=&quot;text&quot;는 다음과 같은 의미를 갖고 있다. android:inputType=&quot;text&quot; : none과 같으나 줄바꿈이 불가능하다. android:inputType=&quot;none&quot; : 다른 특징이 없는 기본 EditText. 입력 폼 안에 줄 바꿈이 가능하다. 그렇다. text 설정으로 인해서 줄바꿈이 되지 않는다. 때문에 scrollHorizontally 설정을 바꾼다하더라도 자동 개행이 되지 않았던 것이다. 이제 속성의 정확한 의미를 알았기 때문에 inputType 값을 설정하지 않아도 되고 설정해도 된다. 필자는 다음과 같이 설정했다. 1234567891011121314151617181920&lt;EditText android:id=\"@+id/et_content\" android:layout_width=\"0dp\" android:layout_height=\"200dp\" android:layout_marginStart=\"@dimen/space_16\" android:layout_marginTop=\"@dimen/space_8\" android:layout_marginEnd=\"@dimen/space_16\" android:background=\"@drawable/bg_et_content\" android:gravity=\"top|start\" android:hint=\"@string/hint_content\" android:inputType=\"textMultiLine\" android:maxHeight=\"250dp\" android:padding=\"@dimen/space_16\" android:scrollHorizontally=\"false\" android:text=\"@&#123;vm.memo.content&#125;\" android:textColor=\"@drawable/selector_et\" android:theme=\"@style/EditTextStyle\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/et_title\" /&gt; [inputType 속성] textMultiLine : 입력 폼에 줄 바꿈이 가능하다. 따로 설정하지 않으면 단일 줄의 텍스트로 제한된다. scrollHorizontally : 자동으로 줄이 바뀌고 enter 엔터키를 누르면 다음줄로 이동한다. 또한 쎄씨’s님의 블로그에 inputType에 대해서 정리되어 있으니 가서 확인해보는 것도 좋다. 공식 문서가 사실 더 좋다! 참고 [안드로이드] EditText 의 disable 텍스트 색상 설정하는 방법 android 안드로이드 edittext 자동 줄바꿈","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"EditText","slug":"EditText","permalink":"https://woovictory.github.io/tags/EditText/"},{"name":"Widget","slug":"Widget","permalink":"https://woovictory.github.io/tags/Widget/"},{"name":"Function","slug":"Function","permalink":"https://woovictory.github.io/tags/Function/"},{"name":"자동 개행","slug":"자동-개행","permalink":"https://woovictory.github.io/tags/자동-개행/"},{"name":"inputType","slug":"inputType","permalink":"https://woovictory.github.io/tags/inputType/"},{"name":"유용한 속성","slug":"유용한-속성","permalink":"https://woovictory.github.io/tags/유용한-속성/"}]},{"title":"[Android] Dialog Error?!","slug":"Android-Dialog-Context","date":"2019-06-26T14:27:06.000Z","updated":"2020-03-01T10:29:04.989Z","comments":true,"path":"2019/06/26/Android-Dialog-Context/","link":"","permalink":"https://woovictory.github.io/2019/06/26/Android-Dialog-Context/","excerpt":"","text":"Android 개발을 함에 있어서 AlertDialog를 사용하는 경우를 많이 접해봤을 것이다. 예를 들면, 야놀자 앱을 켰을 때 뜨는 광고가 Dialog의 한 예라고 볼 수 있다. 필자도 이러한 Dialog를 만들어야 하는데, 기본으로 제공하는 것이 아니라 Custom 해야 했다. 그래서 xml로 원하는 뷰를 작성하고 CustomDialog라는 클래스를 만들어 xml을 inflate했다. 그리고 Click이 필요하다면 ClickListener도 설정하면 된다. CustomDialog.class 1234567891011121314151617181920212223class CustomDialog(context: Context) : Dialog(context), View.OnClickListener &#123; private val layout = R.layout.custom_dialog override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(layout) init() &#125; private fun init() &#123; dialogOkayButton.setOnClickListener(this) &#125; override fun onClick(v: View) &#123; when (v.id) &#123; R.id.dialogOkayButton -&gt; &#123; dismiss() &#125; &#125; &#125;&#125; 그리고 MyPageFragmet 클래스에서 CustomDialog를 사용하려고 한다. 간단하게 호출하면 된다. 코드를 한번 봐보자. MyPageFragment.class 123456fragmentMyPageDataBinding.myPageMissionSuggest.setOnClickListener &#123; toast(requireContext().toString()) val dialog = CustomDialog(activity?.applicationContext) dialog.setCanceledOnTouchOutside(false) dialog.show() &#125; 필자는 DataBinding을 사용하기 때문에 위와 같은 코드를 구성했다. 버튼 클릭 시 Dialog를 띄우는 코드이다. Dialog 클래스는 Context를 필요로 하기 때문에 applicationContext를 넘겼다. ‘그럼 이제 Dialog가 뜨겠지?’ 라고 기대해본다. Unable to add window – token null is not for an application 흠, 이게 무슨 상황인가. 왜 실행이 되지 않는 것일까? 역시 해결책은 구글링이다. 찾아보니 Dialog를 생성할 때 넘겨야 하는 Context는 Activity의 Context를 넘겨야 한다. 나는 지금까지 applicationContext를 넘겼기 때문에 저런 에러를 겪은 것이다. 이유는 Dialog가 Activity에 종속적이기 때문이다. 그래서 applicationContext가 아니라 Activity의 Context를 넘겨야 한다. 아마도 Dialog는 Activity가 떠야 그 위에서 그릴 수 있기 때문일 것이다. Application의 생명주기를 따르지 않고 Activity의 생명주기를 따라서 Dialog가 함께 존재하기 때문이다. 그럼 fragment에서 Activity의 context는 어떻게 얻을 수 있을까? 이에 대한 답변은 자바와 코틀린이 조금 다르다. Java : getActivity() 혹은 getContext()를 통해서 얻을 수 있다. Kotlin : requireContext() 함수를 통해서 얻을 수 있다. 그래서 위의 MyPageFragment.class의 코드를 수정하면 아래와 같다. 123456fragmentMyPageDataBinding.myPageMissionSuggest.setOnClickListener &#123; toast(requireContext().toString()) val dialog = CustomDialog(requireContext()) dialog.setCanceledOnTouchOutside(false) dialog.show() &#125; 그러면 말끔하게 에러가 해결된 모습을 만나게 될 것이다. 참고 StackOverflow","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"AlertDialog","slug":"AlertDialog","permalink":"https://woovictory.github.io/tags/AlertDialog/"},{"name":"Error","slug":"Error","permalink":"https://woovictory.github.io/tags/Error/"}]},{"title":"[Android] RecyclerView Bottom padding","slug":"Android-RecyclerView-BottomSpace","date":"2019-06-25T11:30:17.000Z","updated":"2020-03-01T10:27:12.315Z","comments":true,"path":"2019/06/25/Android-RecyclerView-BottomSpace/","link":"","permalink":"https://woovictory.github.io/2019/06/25/Android-RecyclerView-BottomSpace/","excerpt":"","text":"Android에서 RecyclerView의 사용은 거의 필수라고 할 수 있다. 왜냐하면 리스트를 보여주는 화면은 대부분의 앱에 존재할 것이기 때문이다. 이번 글은 간단하다. 리싸이클러뷰를 사용하는 사람이라면 글을 읽는데 어려움이 없을 것이다. 사실, 몰라도 볼 수 있다. 그만큼 간단한 글이다. RecyclerView 리싸이클러뷰는 리스트 화면을 구성하는데 효율적이다. 이유는 View를 재활용하기 때문이다. 화면을 작성하고 보면 리스트의 제일 하단 공간이 아래와 바짝 붙어있는 경우를 본 적이 있을 것이다. 이를 해결하기 위한 방법은 내가 할 수 있는 것 중에서는 두 가지가 있다. ItemDecoration 클래스를 만들어서 마지막 아이템일 경우 공간을 추가하는 방법 RecyclerView 자체에 padding을 주는 방법 첫 번째 방법은 addDecoration 키워드를 가지고 검색해보면 답을 구할 수 있다. 이 방법은 추후에 설명하도록 하겠다. 이것보다 훨씬 간단한 두 번째 방법을 설명하겠다. 두 번째 방법 그대로 padding을 RecyclerView에 추가하면 어떻게 될까?? 내가 원하는 것처럼 바닥과 공간이 떨어진다. 하지만, 스크롤이 되는 위치도 그만큼 떨어지게 된다. 즉 RecyclerView를 자식으로 가지는 부모 뷰에 꽉 차지 않는 것이다. 이를 해결하기 위해서는 다음의 한 줄을 추가하면 간단하게 해결된다 1android:clipToPadding=\"false\" 공식 문서의 내용을 보면 다음과 같다. Defines whether the ViewGroup will clip its children and resize (but not clip) any EdgeEffect to its padding, if padding is not zero. This property is set to true by default. 해석해보면 패딩이 0이 아닌 경우에는 ViewGroup이 자신의 자식 뷰의 영역을 자르고 EdgeEffect의 크기를 조정(clip)할지 여부를 규정한다. 이 속성은 기본적으로 true로 설정되어 있다. 기본적으로 패딩값이 설정되어 있다면 ViewGroup은 자신의 자식 뷰의 영역을 자르고 EdgeEffect(사용자가 2D 공간에서 콘텐츠 경계를 넘어 스크롤할 때 스크롤 가능한 위젯의 가장자리에서 사용하는 그래픽 효과를 말한다.)의 크기를 조정한다. 이 속성을 false로 설정한다는 것은 EdgeEffect의 크기를 조정하지 않는다. 따라서 스크롤 가능한 위젯의 가장자리에서 사용하는 그래픽 효과는 부모 뷰에 맞도록 설정이 된다는 걸 뜻한다. 그래서 스크롤할 때 부모 뷰에서 떨어지지 않고 내가 원하는 동작을 할 수 있다. 이것은 나의 해석과 생각이 담겨 있다. 그래서 사실이 아닐 수도 있다. 질문이나 틀린 점이 있다면 알려주면 피드백 반영해서 수정하도록 하겠습니다. 참고 Android Developer clipToPadding Android Developer EdgeEffect","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"}]},{"title":"[Android] 로딩시 어떻게 할 것인가?","slug":"Android-Progressbar-tip","date":"2019-06-24T14:37:18.000Z","updated":"2020-03-01T10:27:16.226Z","comments":true,"path":"2019/06/24/Android-Progressbar-tip/","link":"","permalink":"https://woovictory.github.io/2019/06/24/Android-Progressbar-tip/","excerpt":"","text":"안드로이드 개발에서 서버로부터 데이터를 불러올 때, 네트워크 상황이 좋지 않다면 금방 불러올 수 없을 것이다. 시간이 어느 정도 걸린다. 또한, 불러오는 데이터 중 사진, 영상이 많거나 데이터의 양이 많다면 시간이 오래 걸린다. 이처럼 시간이 오래 걸리는 작업을 아무런 동작 없이 그냥 냅두면 사용자는 빈 화면을 보다가 갑자기 나타난 화면에 좋지 않은 경험을 할 것이다. 그래서 이를 해결하기 위한 방법은 내가 생각했을 때는 두가지가 있다. Progress Bar를 이용한 로딩 loaderViewLibrary를 사용하는 방법 아마도 이 글은 두 Part로 나뉘어서 쓸 것 같다. 이번에는 Progress Bar를 이용한 로딩 방법을 다뤄보고 다음에는 loaderViewLibrary를 이용한 방법을 다룰 예정이다. Progressbar 사용방법은 정말 간단하다. 그냥 xml에 정의해서 사용하면 된다. 아래 xml 코드를 보자. 123456789&lt;ProgressBar android:id=\"@+id/loading\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"8dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; 이렇게 정의하면 빨간색의 ProgressBar를 볼 수 있다. 원형이 기본 형태인 것 같다. 색상도 빨간색이 기본으로 설정되어 있다. 하지만, 이 빨간색은 여러분이 개발하고 있는 앱의 색상과 맞지 않을 것이다. 그래서 변경하려는 사람이 많다. 필자도 변경하려고 구글링을 좀 해봤다. 여러 방법이 있지만, 가장 단순한 방법은 다음 코드 한 줄을 추가하는 것이다. 1android:indeterminateTint=&quot;@color/fe_fu_main&quot; 이 속성이 무엇인지는 Android Developer 문서에 설명되어 있다. 사진을 아래와 같이 첨부했다. 해석해보면 ProgressBar에 적용할 색상이라고 한다. indeterminate가 뭔지 몰랐는데 불확정의라는 뜻을 가진다. ProgressBar가 불확정에서 확정으로 되는 동안 로딩하기 위해 쓰이는 것이라 이런 이름을 붙이지 않았을까 추측해본다. (물론 나의 생각!!) 저 속성을 통해서 원하는 색상을 지정하면 사용자가 원하는 색상을 사용할 수 있다. 직접 drawable 파일을 만들어서 커스텀하는 방법도 있는데, 이는 디자인 자체에서 조금 다르면 커스텀해서 사용해도 좋을 것 같다. 다음의 스택 오버플로우 질문을 보면 답변에 두 방식 모두 나와있다. -&gt; https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769 사용해보기 참고 Android Developer https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Progress Bar","slug":"Progress-Bar","permalink":"https://woovictory.github.io/tags/Progress-Bar/"}]},{"title":"[Android] NestedScrollView Issue","slug":"Android-NestedScrollview-issue","date":"2019-06-24T08:04:21.000Z","updated":"2020-03-27T04:54:25.920Z","comments":true,"path":"2019/06/24/Android-NestedScrollview-issue/","link":"","permalink":"https://woovictory.github.io/2019/06/24/Android-NestedScrollview-issue/","excerpt":"","text":"안드로이드 개발을 하다보면 ScrollView 안에 RecyclerView를 넣어야 하는 경우가 생긴다. 이럴 때, NestedScrollView를 사용하면 된다. 이름처럼 중첩된 스크롤뷰라는 뜻이다. 필자는 NestedScrollView를 아주 유용하게 사용한다. 사용하는 상황은 다음과 같다. RecyclerView이 있는데 다른 형태의 뷰가 보여질 때 타이틀이 있고 아래에 리스트 목록이 보일 때 두 가지 경우는 거의 비슷하다. 첫 번째 경우는 사실 ViewType을 다르게 하여 RecyclerView를 구성할 수도 있다. 하지만, 이 부분이 조금 번거롭다면 NestedScrollView를 사용하는 것도 하나의 방법이다. issue 이제 필자가 겪은 문제를 말하려고 한다. 서론이 길었다. 위에서 두 번째 경우를 구현해야 하는 상황이 있었다. NestedScrollView는 ScrollView와 마찬가지로 내부에 ViewGroup을 하나만 가질 수 있다. 그래서 LinearLayout을 두고 그 안에 타이틀을 보여주는 TextView와 리스트를 나타내는 RecyclerView를 두었다. 그런데 경우에 따라서 이 NestedScrollView가 자기 멋대로 밑으로 스크롤이 내려갈 때가 있다. 처음에는 이유를 몰랐다. 그래서 구글링을 해보면서 찾아봤다. 이유는 뷰가 그려지면서 안에 넣어둔 또 다른 ScrollView(즉, 여기서는 RecyclerView)에 포커스가 잡히면서 타이틀이 보이지 않는 것이었다. 그래서 이 포커스를 어떻게 없앨까 찾아보았다. 포커스만 없앤다면 뷰가 그려지면서 RecyclerView에 포커스되는 상황이 없어지고 스크롤이 제멋대로 내려가지 않을테니 말이다. 바로 다음의 한줄만 추가하면 된다. 1android:descendantFocusability=\"blocksDescendants\" 무슨 속성일까? descendantFocusability : ViewGroup 내에서 포커스를 맞출 때 ViewGroup과 그의 하위 뷰의 관계를 설정한다. 여기서 하위 뷰란 자식 뷰를 의미한다. blocksDescendants : 해당 뷰 그룹의 하위 뷰가 포커스를 받지 못하게 하는 옵션이다. 어디에 정의할까? ScrollView의 자식 뷰에 설정하면 된다. 스크롤뷰는 자식 뷰를 하나만 가지기 때문에 LinearLayout에 설정하면 된다. xml 코드 123456789101112131415161718192021222324252627282930313233&lt;androidx.core.widget.NestedScrollView android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintTop_toBottomOf=\"@id/achieveAppBar\" app:layout_constraintBottom_toBottomOf=\"parent\"&gt; &lt;LinearLayout android:descendantFocusability=\"blocksDescendants\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_marginStart=\"@dimen/margin_24dp\" android:layout_marginTop=\"@dimen/margin_16dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/text_my_page_achieve_list_title\" style=\"@style/SubTitleHeaderStyle\" /&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=\"@+id/achieveListRv\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:overScrollMode=\"never\" android:layout_marginTop=\"@dimen/margin_24dp\"/&gt; &lt;/LinearLayout&gt; &lt;/androidx.core.widget.NestedScrollView&gt; 결론 1android:descendantFocusability=\"blocksDescendants\" 정리하면, 위의 설정은 NestedScrollView 안의 자식 뷰(하위 뷰)가 포커스를 가져가는 현상을 막아준다. 즉, NestedScrollView 안에 있는 RecyclerView가 포커스를 가져가지 않는다. 따라서 NestedScrollView는 원하던 대로 포커스를 받고 스크롤이 내려가는 현상도 방지할 수 있다. 참고 NestedScrollView가 보여질 때 제멋대로 스크롤 되는 문제 NestedScrollView scrolls to top on Recyclerview resized","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"},{"name":"NestedScrollView","slug":"NestedScrollView","permalink":"https://woovictory.github.io/tags/NestedScrollView/"},{"name":"Issue","slug":"Issue","permalink":"https://woovictory.github.io/tags/Issue/"},{"name":"Application","slug":"Application","permalink":"https://woovictory.github.io/tags/Application/"}]},{"title":"[Design Pattern] 옵저버 패턴","slug":"DesignPattern-Observer","date":"2019-06-20T04:32:51.000Z","updated":"2020-05-12T11:30:15.896Z","comments":true,"path":"2019/06/20/DesignPattern-Observer/","link":"","permalink":"https://woovictory.github.io/2019/06/20/DesignPattern-Observer/","excerpt":"","text":"옵저버 패턴이란 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 하고 자동으로 내용이 갱신되는 방식으로 일대다 객체 의존 관계를 구성하는 패턴이다. 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할 때 유용하다. ex) 새로운 파일이 추가되거나 기존 파일이 삭제되었을 때 탐색기는 다른 탐색기에게 즉시 변경을 통보해야 한다. ex) 차량 연료량 클래스는 연료량이 부족한 경우 연료량에 관심을 가지는 구체적인 클래스에 직접 의존하지 않는 방식으로 연료량 변화를 통보해야 한다. ‘행위 패턴’ 중 하나 옵저버 패턴은 통보 대상 객체의 관리를 Subject 클래스와 Observer 인터페이스로 일반화한다. 이를 통해 데이터 변경을 통보하는 클래스는 통보 대상 클래스나 객체에 대한 의존성을 없앨 수 있다. 결과적으로 통보 대상 클래스나 대상 객체의 변경에도 통보하는 클래스(ConcreteSubject)를 수정없이 그대로 사용할 수 있다. 대부분 상태를 저장하고 있는 주제 인터페이스를 구현한 하나의 주제 객체와 주제 객체에 의존하고 있는 옵저버 인터페이스를 구현한 여러 개의 옵저버 객체가 있는 디자인을 바탕으로 한다. 결국, 위와 같은 의미이다. 역할이 수행하는 작업 Observer 데이터의 변경을 통보 받는 인터페이스 즉, Subject에서는 Observer 인터페이스의 update 메소드를 호출함으로써 ConcreteSubject의 데이터 변경을 ConcreteObserver에게 통보한다. Subject ConcreteObserver 객체를 관리하는 요소 Observer 인터페이스를 참조해서 ConcreteObserver를 관리하므로 ConcreteObserver의 변화에 독립적일 수 있다. ConcreteSubject 변경 관리 대상이 되는 데이터가 있는 클래스(통보하는 클래스) 데이터 변경을 위한 setState 메소드가 있다. setState 메소드에서는 자신의 데이터인 subjectState를 변경하고 Subject의 nofityObservers 메소드를 호출해서 ConcreteObserver 객체에 변경을 통보한다. ConcreteObserver ConcreteSubject의 변경을 통보 받는 클래스 Observer 인터페이스의 update 메소드를 구현함으로써 변경을 통보받는다. 변경된 데이터는 ConcreteSubject의 getState 메소드를 호출함으로써 변경을 조회한다. 예시 - 여러 가지 방식으로 성적을 출력해보기. - 입력된 성적 값을 출력하는 프로그램 ScoreRecord 클래스 12345678910111213141516171819202122/*** 입력된 점수를 저장하는 클래스*/public class ScoreRecord &#123; private List&lt;Integer&gt; scores = new ArrayList&lt;&gt;(); private DataSheetView dataSheetView; public void setDataSheetView(DataSheetView dataSheetView) &#123; this.dataSheetView = dataSheetView; &#125; // 새로운 점수를 추가하면 출력하는 것에 변화를 통보(update())하여 출력하는 부분 갱신. public void addScore(int score) &#123; scores.add(score); // scores 목록에 주어진 점수를 추가한다. dataSheetView.update(); &#125; // 출력하는 부분에서 변화된 내용을 얻어감. public List&lt;Integer&gt; getScoreRecord() &#123; return scores; &#125;&#125; DataSheetView 클래스 123456789101112131415161718192021222324252627/** * 1. 출력 형태 : 목록 형태로 출력하는 클래스 */public class DataSheetView &#123; private ScoreRecord scoreRecord; private int viewCount; public DataSheetView(ScoreRecord scoreRecord, int viewCount) &#123; this.scoreRecord = scoreRecord; this.viewCount = viewCount; &#125; // 점수의 변경을 통보 받는다. public void update() &#123; List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); // 점수를 조회한다. displayScores(record, viewCount); // 조회된 점수를 viewCount 만큼만 출력한다. &#125; // 점수를 출력한다. private void displayScores(List&lt;Integer&gt; record, int viewCount) &#123; System.out.println(\"List of \" + viewCount + \" entries: \"); for (int i = 0; i &lt; viewCount &amp;&amp; i &lt; record.size(); i++) &#123; System.out.println(record.get(i) + \" \"); &#125; System.out.println(); &#125;&#125; ObserverClient 클래스 12345678910111213141516public class ObserverClient &#123; public static void main(String[] args) &#123; ScoreRecord scoreRecord = new ScoreRecord(); // 3개까지의 점수만 출력. DataSheetView dataSheetView = new DataSheetView(scoreRecord, 3); scoreRecord.setDataSheetView(dataSheetView); for (int i = 1; i &lt;= 5; i++) &#123; int score = i * 10; System.out.println(\"Adding : \" + score); // 10, 20, 30, 40, 50을 추가한다. // 추가할 때마다 최대 3개의 점수만 출력한다. scoreRecord.addScore(score); &#125; &#125;&#125; ScoreRecord 클래스의 addScore() 메소드가 호출되면 ScoreRecord 클래스는 자신의 필드인 scores 객체에 점수를 추가한다. 그리고 DataSheetView 클래스의 update() 메소드를 호출함으로써 성적을 출력하도록 요청한다. DataSheetView 클래스는 ScoreRecord 클래스의 getScoreRecord() 메소드를 호출해 출력할 점수를 구한다. 이때 DataSheetView 클래스의 update() 메소드에서는 구한 점수 중에서 명시된 개수만큼(viewCount)의 점수만 출력한다. 문제점 성적을 다른 형태로 출력하는 경우 성적을 목록으로 출력하지 않고 성적의 최소, 최대 값만 출력하려면? 1234567891011121314151617public class ScoreRecord &#123; private List&lt;Integer&gt; scores = new ArrayList&lt;&gt;(); private MinMaxView minMaxView; public void setMinMaxView(MinMaxView minMaxView) &#123; this.minMaxView = minMaxView; &#125; public void addScore(int score) &#123; scores.add(score); minMaxView.update(); &#125; public List&lt;Integer&gt; getScoreRecord() &#123; return scores; &#125;&#125; 점수 변경에 대한 통보 대상 클래스가 다른 대상 클래스(DataSheetView -&gt; MinMaxView)로 바뀌면 기존 코드(ScoredRecord 클래스)의 내용을 수정해야 하므로 OCP에 위배된다. 동시 혹은 순차적으로 성적을 출력하는 경우 성적이 입력되었을 때 최대 3개 목록, 최대 5개 목록, 최소/최대 값을 동시에 출력하려면? 처음에는 목록으로 출력하고 나중에는 최소/최대 값을 출력하려면? 123456789101112131415161718192021222324public class ScoreRecord &#123; private List&lt;Integer&gt; scores = new ArrayList&lt;&gt;(); private MinMaxView minMaxView; private DataSheetView dataSheetView; public void setMinMaxView(MinMaxView minMaxView) &#123; this.minMaxView = minMaxView; &#125; public void setDataSheetView(DataSheetView dataSheetView)&#123; this.dataSheetView = dataSheetView; &#125; // 새로운 점수를 추가하면 출력하는 것에 변화를 통보(update())하여 출력하는 부분을 갱신한다. public void addScore(int score) &#123; scores.add(score); dataSheetView.update(); // scores가 변경됨을 통보한다. minMaxView.update(); // scores가 변경됨을 통보한다. &#125; public List&lt;Integer&gt; getScoreRecord() &#123; return scores; &#125;&#125; 이 경우에도 점수 변경에 대한 통보 대상 클래스가 다른 클래스로 바뀌면(DataSheetView -&gt; MinMaxView) 기존 코드의 내용을 수정해야 하므로 OCP에 위배된다. 즉, 성적 변경을 새로운 클래스에 통보할 때마다 ScoreRecord 클래스의 코드를 수정해야 하므로 번거롭고 재사용하기가 어렵다. 위의 그림처럼 양방향의 의존 관계를 가지고 있기 때문에 통보 대상 클래스가 변경되면 ScoreRecord 클래스도 수정해야 한다. 따라서 우리는 이 문제를 해결해야 한다. 해결책 문제를 해결하기 위해서는 공통 기능을 상위 클래스 및 인터페이스로 일반화하고 이를 활용하여 통보하는 클래스를 구현해야 한다. 즉, ScoreRecord 클래스에서 변화되는 부분을 식별하고 이를 일반화시켜야 한다. 이를 통해 성적 통보 대상이 변경되더라도 ScoreRecord 클래스를 그대로 재사용할 수 있다. ScoreRecord 클래스에서 하는 작업 통보 대상인 객체를 참조하는 것을 관리(추가/제거) -&gt; Subject 클래스로 일반화 addScore 메소드 : 각 통보 대상인 객체의 update() 메소드를 호출 -&gt; Observer 인터페이스로 일반화 ScoreRecord 클래스의 addScore(상태 변경) 메소드 호출 자신의 성적 값을 저장한다. 상태가 변경될 때마다 Subject 클래스의 notifyObservers() 메소드를 호출한다. Subject 클래스의 notifyObservers() 메소드 호출 Observer 인터페이스를 통해 성적 변경을 통보한다. DataSheetView 클래스의 update() 메소드 호출 MinMaxView 클래스의 update() 메소드 호출 개선 시킨 후의 코드 Observer 인터페이스 1234public interface Observer &#123; // 데이터 변경을 통보했을 때 처리하는 메소드 void update();&#125; Subject 클래스 123456789101112131415161718192021222324252627/** * 추상화된 변경 관심 데이터 * 즉, 데이터에 공통적으로 들어가야 하는 메소드들 -&gt; 일반화 */public abstract class Subject &#123; // 추상화된 통보 대상 목록. // 즉, 출력 형태에 대한 Observer private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); // 통보 대상 추가. public void attach(Observer observer) &#123; observers.add(observer); &#125; // 통보 대상 제거. public void detach(Observer observer) &#123; observers.remove(observer); &#125; // 각 통보 대상에게 변경을 통보한다. public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125;&#125; ScoreRecord 클래스 1234567891011121314151617/** * 구체적인 감시 대상 데이터 * 출력 형태 2개를 가질 때 */public class ScoreRecord extends Subject &#123; private List&lt;Integer&gt; scores = new ArrayList&lt;&gt;(); // 새로운 점수를 추가. -&gt; 상태 변경 public void addScore(int score) &#123; scores.add(score); // scores 목록에 주어진 점수를 추가한다. notifyObservers(); // scores 가 변경됨을 각 통보 대상에게 통보한다. &#125; public List&lt;Integer&gt; getScoreRecord() &#123; return scores; &#125;&#125; DataSheetView 클래스 12345678910111213141516171819202122232425262728/** * 1. 출력 형태 : 목록 형태로 출력하는 클래스 */public class DataSheetView implements Observer &#123; private ScoreRecord scoreRecord; private int viewCount; public DataSheetView(ScoreRecord scoreRecord, int viewCount) &#123; this.scoreRecord = scoreRecord; this.viewCount = viewCount; &#125; // 점수를 출력한다. private void displayScores(List&lt;Integer&gt; record, int viewCount) &#123; System.out.println(\"List of \" + viewCount + \" entries: \"); for (int i = 0; i &lt; viewCount &amp;&amp; i &lt; record.size(); i++) &#123; System.out.println(record.get(i) + \" \"); &#125; //System.out.println(); &#125; // 점수의 변경을 통보 받는다. @Override public void update() &#123; List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); // 점수를 조회한다. displayScores(record, viewCount); // 조회된 점수를 viewCount 만큼만 출력한다. &#125;&#125; MinMaxView 클래스 1234567891011121314151617181920212223/** * 2. 출력 형태 : 최대, 최소 값만을 출력한다. */public class MinMaxView implements Observer &#123; private ScoreRecord scoreRecord; public MinMaxView(ScoreRecord scoreRecord) &#123; this.scoreRecord = scoreRecord; &#125; private void displayScores(List&lt;Integer&gt; record) &#123; int min = Collections.min(record); int max = Collections.max(record); System.out.println(\"Min : \" + min + \", Max : \" + max); &#125; @Override public void update() &#123; List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); displayScores(record); &#125;&#125; ObserverClient 클래스에서의 사용 123456789101112131415161718192021public class ObserverClient &#123; public static void main(String[] args) &#123; ScoreRecord scoreRecord = new ScoreRecord(); // 3개까지만 데이터를 출력한다. DataSheetView dataSheetView = new DataSheetView(scoreRecord, 3); // 최대, 최소 값만 출력한다. MinMaxView minMaxView = new MinMaxView(scoreRecord); // 각 통보 대상 클래스를 Observer 로 추가한다. scoreRecord.attach(dataSheetView); scoreRecord.attach(minMaxView); for (int i = 1; i &lt;= 5; i++) &#123; int score = i * 10; System.out.println(); System.out.println(\"Adding : \" + score); scoreRecord.addScore(score); &#125; &#125;&#125; Observer : 추상화된 통보 대상 DataSheetView, MinMaxView : Observer를 구현함으로써 구체적인 통보 대상이 된다. Subject : 성적 변경에 관심이 있는 대상 객체들을 관리한다. ScoreRecord : Subject를 상속받음으로써 구체적인 통보 대상을 직접 참조하지 않아도 된다. notifyObservers()를 호출함으로써 Subject 클래스에서 각 통보 대상들에게 변경 사항을 통보한다. 이렇게 Observer 패턴을 이용하면 ScoreRecord 클래스의 코드를 변경하지 않고도 새로운 관심 클래스 및 객체를 추가/제거하는 것이 가능해진다. 느낀 점 결국, 처음에는 양방향으로 참조를 해서 강한 의존성을 갖고 있었다. 하지만, Observer 패턴을 적용함으로써 의존성을 약하게 결합하도록 하고 양방향 참조를 하지 않도록 함으로써 디자인 원칙을 위배하지 않으면서 데이터 변경을 적절하게 통보할 수 있게 되었다. 이처럼 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도 무난하게 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다. (객체 사이의 상호 의존성을 최소화 할 수 있기 때문이다.) 참고 [Design Pattern] 옵저버 패턴이란","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/tags/Design-Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://woovictory.github.io/tags/디자인-패턴/"},{"name":"Observer Pattern","slug":"Observer-Pattern","permalink":"https://woovictory.github.io/tags/Observer-Pattern/"},{"name":"옵저버 패턴","slug":"옵저버-패턴","permalink":"https://woovictory.github.io/tags/옵저버-패턴/"}]},{"title":"[RxJava] Chap05. 스케줄러","slug":"RxJava-Chap05-Scheduler","date":"2019-06-19T13:22:26.000Z","updated":"2020-05-26T07:06:49.050Z","comments":true,"path":"2019/06/19/RxJava-Chap05-Scheduler/","link":"","permalink":"https://woovictory.github.io/2019/06/19/RxJava-Chap05-Scheduler/","excerpt":"","text":"지금까지 공부했던 예제의 공통점은 대부분의 동작이 현재 즉, main 스레드에서 동작한다는 것이었다. 하지만, 실무에서는 요구사항에 맞게 비동기로 동작할 수 있도록 이를 바꿔야 한다. 이때 스케줄러를 이용한다. 스케줄러는 스레드를 지정할 수 있게 해준다. 단순히 새로운 스레드를 생성하거나 기존의 Executors를 활용하는 것을 넘어 새로운 방식으로 볼 수 있다. 그동안 어렵게 다뤄야 했단 비동기 프로그래밍이 간결한 코드로 구성될 수 있다. 위의 그림에서 시간 표시줄에 주목해야 한다. 마블 다이어그램을 코드로 표현하면 아래와 같다. 1234567891011121314151617181920public class FlipSample &#123; public static void main(String[] args) &#123; String[] objs = &#123;\"1-T\", \"2-S\", \"3-P\"&#125;; Observable&lt;String&gt; source = Observable.fromArray(objs) .doOnNext(data -&gt; Log.d(\"Original data = \" + data)) .subscribeOn(Schedulers.newThread()) .observeOn(Schedulers.newThread()) .map(Shape::flip); source.subscribe(Log::i); CommonUtils.sleep(500); &#125;&#125;// 결과RxNewThreadScheduler-1 | debug = Original data = 1-TRxNewThreadScheduler-1 | debug = Original data = 2-SRxNewThreadScheduler-1 | debug = Original data = 3-PRxNewThreadScheduler-2 | value = (flipped)1-TRxNewThreadScheduler-2 | value = (flipped)2-SRxNewThreadScheduler-2 | value = (flipped)3-P doOnNext() : Observable 에서 onNext 이벤트가 발생하면 실행되며, 여기에서는 원래의 데이터 값을 확인한다. subscribeOn() : 구독자가 Observable 에 subscribe() 함수를 호출하여 구독할 때 실행되는 스레드를 지정한다. -&gt; 해당 작업을 어느 쓰레드에서 실행할 것인가?! observeOn() : Observable 에서 생성한 데이터 흐름이 여기저기 함수를 거치며 처리될 때, 동작이 어느 쓰레드에서 일어나는지 지정할 수 있다. -&gt; 받은 결과를 어느 쓰레드에서\b 수행할지?! 결과를 보면 최초의 데이터 흐름이 발생하는 스레드와 flip() 함수를 거쳐서 구독자에게 전달되는 스레드가 다르다. 보통 우리는 새로운 스레드를 생성하거나 Runnable 혹은 Callable 객체를 생성하는데 우리는 전달한 적이 없다. 단지 subscribeOn()과 observeOn() 함수에 어떤 스케줄러를 지정했을 뿐이다. 이처럼 스케줄러를 활용하는 비동기 프로그래밍의 핵심은 바로 데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 전달하는 스레드를 분리할 수 있다는 것이다. 위의 코드에서 observeOn() 함수 호출 부분을 제거해보면 어떤 결과가 나올까? 결과는 아래에서 확인할 수 있다. 1234567// 결과RxNewThreadScheduler-1 | debug = Original data = 1-TRxNewThreadScheduler-1 | value = (flipped)1-TRxNewThreadScheduler-1 | debug = Original data = 2-SRxNewThreadScheduler-1 | value = (flipped)2-SRxNewThreadScheduler-1 | debug = Original data = 3-PRxNewThreadScheduler-1 | value = (flipped)3-P observeOn() 함수를 지정하지 않으면 subscribeOn() 함수로 지정한 스레드에서 모든 로직을 실행한다. 지금까지 배운 내용을 간단하게 정리하면 아래와 같다. 스케줄러는 RxJava 코드를 어느 스레드에서 실행할지 지정할 수 있다. subscribeOn() 함수와 observeOn() 함수를 모두 지정하면 Observable에서 데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 발행하는 스레드를 분리할 수 있다. subscribeOn() 함수만 호출하면 Observable의 모든 흐름이 동일한 스레드에서 실행된다.(observeOn() 함수를 생략했을 경우!) 스케줄러를 별도로 지정하지 않으면 현재(main) 스레드에서 동작을 실행한다. 스케줄러의 종류 특정 스케줄러를 사용하다가 다른 스케줄러로 변경하기 쉽다는 특징을 가지고 있다. 마치 map() 함수를 한 번 더 호출하는 것처럼 새롭게 스케줄러를 추가하거나 기존의 스케줄러를 다른 것으로 교체할 수 있다. 1. 뉴 스레드 스케줄러 이름처럼 새로운 스레드를 생성한다. 새로운 스레드를 만들어 동작을 실행하고 싶을 때 Schedulers.newThread()를 인자로 넣어주면 된다. 그럼 뉴 스레드 스케줄러는 요청을 받을 때마다 새로운 스레드를 생성한다. 뉴 스레드 스케줄러는 새로운 스레드를 생성하여 내가 원하는 동작을 처리하는 방법이다. 하지만 적극적으로 추천하는 방법은 아니다. RxJava에는 뉴 스레드 스케줄러보다 활용도가 높은 계산 스케줄러와 IO 스케줄러와 같은 다른 스케줄러를 제공하기 때문이다. 2. 계산 스케줄러 4장에서 봤던 interval() 함수는 기본적으로 계산 스케줄러에서 동작한다. 물론 내가 원하는 스케줄러에서 동작하도록 변경할 수도 있다. 123@SchedulerSupport(SchedulerSupport.CUSTOM)public static Observable&lt;Long&gt; interval( long period, TimeUnit unit, Scheduler scheduler) CUSTOM은 원하는 스케줄러를 지정할 수 있다는 의미이다. 리액티브 함수 대부분은 마지막 인자로 스케줄러를 지정할 수 있다. flatMap()이나 scan() 함수 등은 대표적인 연산자이지만 스케줄러를 인자로 받지 않는 경우도 있다. 계산 스케줄러는 CPU에 대응하는 계산용 스케줄러이다. 계산 작업(입출력(I/O) 작업을 하지 않는)을 할 때는 대기 시간 없이 빠르게 결과를 도출하는 것이 중요하다. 내부적으로 스레드 풀을 생성하며 스레드 개수는 기본적으로 프로세서 개수와 동일하다. 3. IO 스케줄러 IO 스케줄러는 네트워크상의 요청을 처리하거나 각종 입,출력 작업을 실행하기 위한 스케줄러이다. 계산 스케줄러와 다른 점은 기본적으로 생성되는 스레드 개수가 다르다는 것이다. 즉, 계산 스케줄러는 CPU 개수만큼 스레드를 생성하지만, IO 스케줄러는 필요할 때마다 스레드를 계속 생성한다. 입,출력 작업은 비동기로 실행되지만 결과를 얻기까지 대기 시간이 길다. 두 스케줄러의 비교 계산 스케줄러 : 일반적인 계산 작업 IO 스케줄러 : 네트워크상의 요청, 파일 입출력, DB 쿼리 등 4. 트램펄린 스케줄러 트램펄린 스케줄러는 새로운 스레드를 생성하지 않고 현재 스레드에 무한한 크기의 대기 행렬을 생성하는 스케줄러이다. RxJava 1.x에서는 repeat() 함수와 retry() 함수의 기본 스케줄러였으나 RxJava 2.x에서는 이러한 제약이 사라졌다. 새로운 스레드를 생성하지 않는다는 것과 대기 행렬을 자동으로 만들어준다는 것이 뉴 스레드 스케줄러, 계산 스케줄러, IO 스케줄러와 다른 점이다. 5. 싱글 스레드 스케줄러 싱글 스레드 스케줄러는 RxJava 내부에서 단일 스레드를 별도로 생성하여 구독 작업을 처리한다. 단, 생성된 스레드는 여러 번 구독 요청이 와도 공통으로 사용한다. 리액티브 프로그래밍이 비동기 프로그래밍을 지향하기 때문에 싱글 스레드 스케줄러를 활용할 확률은 낮다. 트팸펄린 스케줄러 예제와 비교해보면 실행 스레드가다르다는 사실을 알 수 있다. 트램펄린 스케줄러 : 메인 스레드 싱글 스레드 스케줄러 : RxSingleScheduler-1 뒤에 -1과 같이 번호가 붙있지만 결국 단일 스레드만 사용한다는 사실도 확인할 수 있다. 스케줄러를 활용하여 콜백 지옥 벗어나기 안드로이드 개발을 한다면 가장 쉽게 접근할 수 있고 유용하게 사용할 수 있는 부분이다. 서버와 통신하는 네트워크 프로그래밍을 할 때 마주치는 콜백 지옥(Callback Hell)을 해결하는 것에 집중해보자. RxJava의 스케줄러를 활용하면 비동기 프로그래밍 방식이 달라진다. 계산 스케줄러나 IO 스케줄러의 예제에서도 살펴봤듯이 스레드를 생성하거나 Callable, Runnable 객체를 실행하는 코드가 사라진다. 리액티브 프로그래밍은 서버와 연동하는 비동기 프로그래밍을 작성할 때 큰 힘을 발휘한다. observeOn() 함수의 활용 RxJava 스케줄러의 핵심은 결국 제공되는 스케줄러의 종류를 선택한 후 subscribeOn()과 observeOn() 함수를 호출하는 것이다. subscribeOn() : Observable에서 구독자가 subscribe() 함수를 호출했을 때 데이터 흐름을 발행하는 스레드를 지정한다.(즉, 작업 스레드를 지정한다.) observeOn() : 처리된 결과를 구독자에게 전달하는 스레드를 지정한다.(UI 갱신을 위한 스레드를 지정한다.) 또한, subscribeOn() 함수는 처음 지정한 스레드를 고정시키므로 다시 subscribeOn() 함수를 호출해도 무시한다. 하지만, observeOn() 함수는 다르다. subscribeOn(A)를 호출했을 때는 데이터를 발행하는 첫 줄이 스레드 A에서 실행된다. 이후에는 observeOn() 함수가 호출될 때까지 스레드 A에서 실행된다. observeOn(B)를 호출하면 그 다음인 두 번째 줄부터는 스레드 B에서 실행된다. map(o–&gt;D) 함수는 스레드 변겨와는 상관없으므로 세 번째 줄은 계속 스레드 B에서 실행된다. 이제 observeOn© 함수를 호출하면 그 다음 데이터 흐름은 스레드 C에서 실행된다. 요약하면 다음과 같다. subscribeOn() 함수는 한번 호출했을 때 결정한 스레드를 고정하며 이후에는 다시 호출해도 스레드가 바뀌지 않는다. observeOn() 함수는 여러 번 호출할 수 있으며 그 다음부터 동작하는 스레드를 바꿀 수 있다. 전통적인 스레드 프로그래밍에서는 일일이 스레드를 만들어야 하고 스레드가 늘어날 때마다 동기화하는 것이 매우 부담스럽기 때문에 이러한 로직을 구현하는 것이 매우 힘들다. 하지만 observeOn() 함수는 스레드 변경이 쉬우므로 활용할 수 있는 범위가 매우 넓다. 책이 있다면 책에 나와있는 openWeatherMap 예제를 실행해보는 것을 추천한다.","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"연산자 활용","slug":"연산자-활용","permalink":"https://woovictory.github.io/tags/연산자-활용/"},{"name":"조건 연산자","slug":"조건-연산자","permalink":"https://woovictory.github.io/tags/조건-연산자/"},{"name":"기타 및 수학 연산자","slug":"기타-및-수학-연산자","permalink":"https://woovictory.github.io/tags/기타-및-수학-연산자/"}]},{"title":"[RxJava] Chap04. 조건 및 기타 연산자","slug":"RxJava-Chap04-Condition","date":"2019-06-19T09:04:52.000Z","updated":"2020-05-26T07:06:57.316Z","comments":true,"path":"2019/06/19/RxJava-Chap04-Condition/","link":"","permalink":"https://woovictory.github.io/2019/06/19/RxJava-Chap04-Condition/","excerpt":"","text":"조건 연산자 조건 연산자는 Observable의 흐름을 제어하는 역할을 한다. filter 연산자가 발행된 값을 채택하느냐 기각하느냐 여부에 초점을 맞춘다면, 조건 연산자는 지금까지의 흐름을 어떻게 제어할 것인지에 초점을 맞춘다. 다음과 같은 연산자가 있다. amb() takeUntil() skipUntil() all() 1. amb() amb는 ambiguous(모호한)라는 영어 단어의 줄임말이다. 여러 개의 Observable 중에서 1개의 Observable을 선택하는데, 선택 기준은 가장 먼저 데이터를 발행하는 발행하는 Observable이다. 이후에 나머지 Observable에서 발행하는 데이터는 모두 무시한다. List 인터페이스처럼 Iterable&lt;Observable&gt; 객체를 인자로 넣으면 그 중에서 가장 먼저 데이터를 발행하는 Observable만 선택해서 계속 값을 발행하도록 해준다. 2. takeUntil() takeUntil() 함수는 take() 함수에 조건을 설정할 수 있다. 구체적으로 살펴보면 인자로 받은 Observable에서 어떤 값을 발행하면 현재 Observable의 데이터 발행을 중단하고 즉시 완료(onComplete 이벤트 발생)한다. 즉, take() 함수처럼 일정 개수만 값을 발행하되 완료 기준을 다른 Observable에서 값을 발행하는지로 판단하는 것이다. 3. skipUntil() takeUntil()과 정반대의 함수이다. other Observable을 인자로 받는다는 점은 같지만 Observable에서 데이터를 발행할 때까지 값을 건너뛴다. takeUntil() 함수와는 다르게 other Observable에서 화살표가 나올 때까지는 값을 발행하지 않고 건너뛰다가 other Observable에서 값을 발행하는 순간부터 원래 Observable에서 값을 정상적으로 발행하기 시작한다. 4. all() all() 함수는 단순하다. 주어진 조건에 100% 맞을 때만 true 값을 발행하고 조건에 맞지 않는 데이터가 발행되면 바로 false 값을 발행한다. 위의 마블 다이어그램은 ‘1’ 원부터 ‘6’ 원까지 모두 ‘원’ 모양이어야만 true를 발행한다. all() 함수의 원형은 다음과 같다. 12@SchedulerSupport(SchedulerSupport.NONE)public final Single&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate) predicate 인자는 filter() 함수의 인자와 동일하다. 주어진 람다 표현식이 true인지 false인지를 판정해주어야 한다. 수학 및 기타 연산자 max(), sum()과 같은 수학 함수와 기타 분류에 해당하는 함수가 있다. RxJavaMath가 있지만, RxJava 2.x를 지원하지 않으므로 다른 라이브러리를 사용한다. Rxjava2Extensions 라이브러리를 활용해 간단한 수학 함수 및 집합 함수의 활용법을 공부해보자. 1. 수학 함수 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MathSample &#123; public static void main(String[] args) &#123; executeMath(); &#125; private static void executeMath() &#123; Integer[] data = &#123;1, 2, 3, 4&#125;; // 1. count Single&lt;Long&gt; source = Observable.fromArray(data) .count(); source.subscribe(count -&gt; Log.i(\"count is \" + count)); // 2. max // MathFlowable 클래스의 max() 함수를 호출해 구현한다. // to() 함수는 다른 타입으로 변환해주기 위한 함수. Flowable.fromArray(data) .to(MathFlowable::max) .subscribe(max -&gt; Log.i(\"max is \" + max)); // 3. min Flowable.fromArray(data) .to(MathFlowable::min) .subscribe(min -&gt; Log.i(\"min is \" + min)); // 4. sum Flowable&lt;Integer&gt; flowable = Flowable.fromArray(data) .to(MathFlowable::sumInt); flowable.subscribe(sum -&gt; Log.i(\"sum is \" + sum)); // 5. average Flowable&lt;Double&gt; flowable1 = Observable.fromArray(data) .toFlowable(BackpressureStrategy.BUFFER) .to(MathFlowable::averageDouble); flowable1.subscribe(avg -&gt; Log.i(\"avg is \" + avg)); &#125;&#125;// 결과main | value = count is 4main | value = max is 4main | value = min is 1main | value = sum is 10main | value = avg is 2.5 2. delay() delay() 함수는 시간을 인자로 받는다. 앞에서 봤던 시간과 관련된 함수들(interval, timer, defer)이 Observable을 생성하는 역할이라면 delay() 함수는 유틸리티 연산자로서 보조 역할을 한다. delay() 함수의 원형 12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;T&gt; delay(long delay, TimeUnit unit) 인자로 delay 변수와 시간 단위(ms 등)을 받는다. 그리고 intervale() 함수와 마찬가지로 계산 스케줄러에서 실행한다. 즉, main 스레드가 아닌 계산을 위한 별도 스레드 풀에서 실행하는 것이다. 3. timeInterval() 어떤 값을 발행했을 때 이전 값을 발행한 이후 얼마나 시간이 흘렀는지를 알려준다. timeInterval() 함수의 원형 12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;Timed&lt;T&gt;&gt; timeIntervale() Timed 객체에는 다음처럼 시간을 얻어오거나 Observable의 데이터를 얻을 수 있는 메소드를 제공할 수 있다. 1234public T value()public TimeUnit unit()public long time()public long time(TimeUnit unit)","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"연산자 활용","slug":"연산자-활용","permalink":"https://woovictory.github.io/tags/연산자-활용/"},{"name":"조건 연산자","slug":"조건-연산자","permalink":"https://woovictory.github.io/tags/조건-연산자/"},{"name":"기타 및 수학 연산자","slug":"기타-및-수학-연산자","permalink":"https://woovictory.github.io/tags/기타-및-수학-연산자/"}]},{"title":"[Design Pattern] 커맨드 패턴","slug":"DesignPattern-CommandPattern","date":"2019-06-13T05:13:21.000Z","updated":"2020-05-12T11:30:13.215Z","comments":true,"path":"2019/06/13/DesignPattern-CommandPattern/","link":"","permalink":"https://woovictory.github.io/2019/06/13/DesignPattern-CommandPattern/","excerpt":"","text":"커맨드 패턴이란 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다. 즉, 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생시키는 클래스를 변경하지 않고 재사용하고자 할 때 유용하다. ‘행위(Behavioral) 패턴’ 중 하나이다. 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(위 그림에서 Invoker) 클래스와 실제 기능을 실행하는 수신자(Receiver) 클래스 사이의 의존성을 제거한다. 따라서 실행될 기능의 변경에도 호출자 클래스의 수정 없이 그대로 사용할 수 있도록 해준다. 위 그림에서 각 역할이 수행하는 작업 Command 실행될 기능에 대한 인터페이스 실행될 기능을 execute 메소드로 선언한다. ConcreteCommand 실제로 실행되는 기능을 구현한다. 즉, Command 인터페이스를 구현한다. Invoker 기능의 실행을 요청하는 호출자 클래스 Receiver ConcreteCommand에서 execute 메소드를 구현할 때 필요한 클래스 즉, ConcreteCommand의 기능을 실행하기 위해 사용하는 수신자 클래스 예시 개념을 어느 정도 봤으니 예시를 살펴보자. 이번에는 만능 버튼을 만들어 볼 예정이다. 버튼이 눌리면 불이 켜지는 프로그램이다. Lamp, Button 클래스 123456789101112131415161718// Lamp 클래스.public class Lamp &#123; public void turnOn()&#123; System.out.println(\"Turn On!\"); &#125;&#125;// Button 클래스.public class Button &#123; private Lamp lamp; public Button(Lamp lamp)&#123; this.lamp=lamp; &#125; public void buttonPress()&#123; lamp.turnOn(); &#125;&#125; Client 클래스 1234567public class CommandClient &#123; public static void main(String[] args) &#123; Lamp lamp = new Lamp(); Button button = new Button(lamp); button.buttonPress(); &#125;&#125; Lamp 클래스로부터 Lamp 객체를 생성한다. Button 클래스의 생성자를 이용해 불을 켤 Lamp 객체를 전달한다. Button 클래스의 buttonPress()가 호출되면 생성자를 통해 전달받은 Lamp 객체의 turnOn()를 호출해 불을 켠다. 문제점 버튼을 눌렀을 때 다른 기능을 실행하는 경우 버튼을 눌렀을 때 알람이 시작되게 하려면? 다음과 같이 수정하면 된다. Alarm, Button 클래스 123456789101112131415161718// Alarm 클래스.public class Alarm &#123; public void startAlarm()&#123; System.out.println(\"Start Alarm ~~~~!!\"); &#125;&#125;// 수정된 Button 클래스.public class Button &#123; private Alarm alarm; public Button(Alarm alarm) &#123; this.alarm = alarm; &#125; public void buttonPress() &#123; alarm.startAlarm(); &#125;&#125; Clien 클래스 1234567public class CommandClient &#123; public static void main(String[] args) &#123; Alarm alarm = new Alarm(); Button button = new Button(alarm); button.buttonPress(); &#125;&#125; 새로운 기능으로 변경하려고 기존 코드인 Button 클래스의 내용을 수정했다. 이로 인해 OCP 원칙에 위배된다. Button 클래스의 buttonPress() 전체를 변경해야 한다. 버튼을 누르는 동작에 따라 다른 기능을 실행하는 경우 버튼을 처음 눌렀을 때는 램프를 켜고, 두 번째 눌렀을 때는 알람을 동작하게 하려면? 수정된 Button 클래스 12345678910111213141516171819202122232425262728public class Button &#123; private Alarm alarm; private Lamp lamp; private Mode mode; // 생성자에서 버튼을 눌렀을 필요한 기능을 인자로 받는다. public Button(Alarm alarm, Lamp lamp) &#123; this.alarm = alarm; this.lamp = lamp; &#125; // 램프 모드 또는 알람 모드를 설정. public void setMode(Mode mode) &#123; this.mode = mode; &#125; // 설정된 모드에 따라서 램프를 켜거나 알람을 시작한다. public void buttonPress() &#123; switch (mode) &#123; case LAMP: lamp.turnOn(); break; case ALARM: alarm.startAlarm(); break; &#125; &#125;&#125; 필요한 기능을 새로 추가할 때마다 Button 클래스의 코드를 수정해야 한다. 따라서 재사용하기 굉장히 어렵다. 해결책 문제를 해결하기 위해서는 구체적인 기능을 직접 구현하는 대신 실행될 기능을 캡슐화해야 한다. 즉, Button 클래스의 buttonPress() 메소드에서 구체적인 기능(램프 켜기, 알람 동작 등)을 직접 구현하는 대신 버튼을 눌렀을 때 실행될 기능을 Button 클래스 외부에서 제공받아 캡슐화해 buttonPress() 메소드에서 호출한다. 이를 통해서 Button 클래스 코드를 수정하지 않고도 그대로 사용할 수 있다. Button 클래스는 미리 약속된 Command 인터페이스의 execute 메소드를 호출한다. 램프를 켜는 경우에는 theLamp.turnOn() 메소드를 호출하고 알람이 동작하는 경우에는 theAlarm.start() 메소드를 호출하도록 buttonPress() 메소드를 수정한다. LampOnCommand 클래스에서는 Command 인터페이스의 execute 메소드를 구현해 Lamp 클래스의 turnOn() 메소드를 호출한다.(램프 켜는 기능) 마찬가지로 AlarmStartCommand 클래스에서는 Command 인터페이스의 execute 메소드를 구현해 Alarm 클래스의 start() 메소드를 호출한다.(알람이 울리는 기능) Command 인터페이스 123public interface Command &#123; void execute();&#125; Button 클래스 1234567891011121314151617public class Button &#123; private Command command; // 생성자에서 버튼을 눌렀을 때 필요한 기능을 인자로 받는다. Button(Command command) &#123; setCommand(command); &#125; public void setCommand(Command command) &#123; this.command = command; &#125; // 버튼이 눌리면 주어진 Command 의 execute() 메소드를 호출한다. public void buttonPress() &#123; command.execute(); &#125;&#125; Lamp, LampOnCommand 클래스 1234567891011121314151617181920public class Lamp &#123; public void turnOn()&#123; System.out.println(\"Turn On!\"); &#125;&#125;// 램프를 켜는 명령을 수행하는 LampOnCommand 클래스.public class LampOnCommand implements Command &#123; private Lamp theLamp; public LampOnCommand(Lamp lamp) &#123; this.theLamp = lamp; &#125; // Command 인터페이스의 execute() 메소드 실행. @Override public void execute() &#123; theLamp.turnOn(); &#125;&#125; Alarm, AlarmStartCommand 클래스 12345678910111213141516171819public class Alarm &#123; public void startAlarm()&#123; System.out.println(\"Start Alarm ~~~~!!\"); &#125;&#125;// 알람을 울리는 명령을 수행하는 AlarmStartCommand 클래스.public class AlarmStartCommand implements Command &#123; private Alarm theAlarm; public AlarmStartCommand(Alarm alarm) &#123; this.theAlarm = alarm; &#125; @Override public void execute() &#123; theAlarm.startAlarm(); &#125;&#125; Client에서 사용 1234567891011121314151617181920public class CommandClient &#123; public static void main(String[] args) &#123; Lamp lamp = new Lamp(); Alarm alarm = new Alarm(); Command lampOnCommand = new LampOnCommand(lamp); Command alarmStartCommand = new AlarmStartCommand(alarm); // Lamp 를 켜는 Command 를 설정. Button button = new Button(lampOnCommand); button.buttonPress(); // 램프를 켜는 기능 수행. System.out.println(); // 알람을 울리는 Command 를 설정. Button button1 = new Button(alarmStartCommand); button1.buttonPress(); // 알람 울리는 기능 수행. button1.setCommand(lampOnCommand); // 다시 램프를 켜는 Command 로 설정. button1.buttonPress(); // 램프를 켜는 기능 수행. &#125;&#125; Command 인터페이스를 구현하는 LampOnCommand와 AlarmStartCommand 객체를 Button 객체에 설정한다.(setCommand() 메소드를 통해서) Button 클래스의 buttonPress() 메소드에서 Command 인터페이스의 execute() 메소드를 호출한다. 즉, 버튼을 눌렀을 때 필요한 임의의 기능은 Command 인터페이스를 구현한 클래스의 객체를 Button 객체에 설정해서 실행할 수 있다. 이렇게 Command 패턴을 이용하면 Button 클래스의 코드를 변경하지 않으면서 다양한 동작을 구현할 수 있게 된다. 정리 커맨드 패턴을 적용하지 않은 경우, Button에 많은 기능이 추가될수록 Button 클래스가 가지고 있는 객체 프로퍼티는 더욱 늘어날 것이고 기존의 buttonPress() 메소드에서 분기가 더 늘어날 것이다. 이는 결국 OCP에 위배된다. 커맨드 패턴을 적용하면, Button이 할 수 있는 기능들(램프를 킨다, 알람을 시작한다.)을 클래스로 만든다. 즉, 기능을 수행하도록 명령을 내리는 클래스(LampOnCommand, AlarmStartCommand)로 만들어서 각 기능들을 캡슐화 한다. 그리고 Button 클래스의 buttonPress() 메소드에서 lamp.turnOn(), alarm.start()와 같이 기능들을 직접 호출하지 않고, 캡슐화한 Command 인터페이스의 execute() 메소드를 호출하도록 한다. 만약 버튼에 TV를 틀어주는 기능이 추가된다면 TvOnCommand 클래스와 TV 클래스를 추가하면 되므로, 기존의 코드를 수정할 필요가 없다. 따라서 OCP에 위배되지 않으면서 기능을 추가할 수 있다. 참고 [Design Pattern] 커맨드 패턴이란 디자인패턴 - 커맨드 패턴 (command pattern) [디자인패턴] 커맨드 패턴 (Command Pattern)","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/tags/Design-Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://woovictory.github.io/tags/디자인-패턴/"},{"name":"Command Pattern","slug":"Command-Pattern","permalink":"https://woovictory.github.io/tags/Command-Pattern/"},{"name":"커맨드 패턴","slug":"커맨드-패턴","permalink":"https://woovictory.github.io/tags/커맨드-패턴/"}]},{"title":"[Android] CoordinatorLayout 삽집","slug":"Android-CoordinatorLayout","date":"2019-06-12T15:50:45.000Z","updated":"2020-03-01T10:28:59.890Z","comments":true,"path":"2019/06/13/Android-CoordinatorLayout/","link":"","permalink":"https://woovictory.github.io/2019/06/13/Android-CoordinatorLayout/","excerpt":"","text":"위의 화면은 Google의 Material Design을 설명하는 글이나 예제에서 많이 보는 화면이다. 스크롤을 하게 되면 달과 산이 있는 이미지가 사라지면서 Toolbar 형태가 되면서 Title이 위치하게 되는 구조이다. 이것에 대해 설명하는 것은 아니다. 이는 CoordinatoryLayout과 AppbarLayout, CollapsingToolbarLayout, Toolbar를 사용해서 구성할 수 있고, 구글에 많은 예제가 있으니 참고하면 된다. 이번 글에서 설명하려고 하는 것은 내가 겪은 issue와 삽질 과정을 설명하려고 한다. CoordinatorLayout Status bar issue 이슈의 이름은 내가 그냥 지은 것이다. 왜 이런 이름을 짓게 되었냐면 스크롤을 아래로 해서 내리면 Status bar의 일부가 딸려오는 issue가 발생했기 때문이다. 말로 설명하기에는 쉽지 않아 사진을 첨부했다. 해당 프로젝트는 내가 현재 진행하고 있는 프로젝트의 일부 화면이다. 이 화면은 상세 페이지이고 CoordinatorLayout, AppbarLayout, CollapsingToolbarLayout, Toolbar 를 사용하여 구성했다. 사실 이 4개가 제일 중요하다. 위의 사진은 스크롤을 내리는 상황이다. 자세히 보면 Status bar의 초록색이 밑으로 딸려 가는 모습을 볼 수 있다. 그래서 나는 ‘이게 버퍼링이 걸린 것인가, 혹은 다른 에러가 있는 것인가’ 생각을 해봤다. 그리고 Wanted의 앱을 참고해봤다. 왜냐하면 구글의 Material Design이 가장 잘 반영된 앱이라고 생각을 했기 때문이다. 물론 CoordinatorLayout을 사용한 것으로 추정되는 화면도 있다. 이 화면을 보니 내가 겪은 이슈가 없었다. 먼저, 내 xml 코드를 보자. xml 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\".view.mission.MissionDetailActivity\"&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=\"@+id/missionDetailAppbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\" android:fitsSystemWindows=\"true\"&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:id=\"@+id/missionDetailCollapsingToolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" app:contentScrim=\"@color/fe_fu_white\" &gt; &lt;ImageView android:id=\"@+id/missionDetailImage\" android:layout_width=\"match_parent\" android:layout_height=\"400dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/fufe_illust_jh_04\" app:layout_collapseMode=\"parallax\"/&gt; &lt;androidx.appcompat.widget.Toolbar android:id=\"@+id/missionDetailToolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" android:background=\"@android:color/transparent\" app:layout_collapseMode=\"pin\"/&gt; &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.core.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:overScrollMode=\"never\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;LinearLayout android:layout_marginTop=\"@dimen/margin_32dp\" android:layout_marginStart=\"@dimen/margin_32dp\" android:layout_marginEnd=\"@dimen/margin_32dp\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginBottom=\"200dp\" android:orientation=\"vertical\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;TextView android:id=\"@+id/missionDetailTitle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"@color/fe_fu_black\" android:text=\"@string/text_mission_detail_title_mock\" style=\"@style/TitleBlackStyle\" /&gt; &lt;TextView android:layout_marginTop=\"6dp\" style=\"@style/ContentsBodyStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/text_mission_detail_content_mock\" /&gt; &lt;View android:layout_marginTop=\"@dimen/margin_16dp\" android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"#e3e3e3\"/&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_32dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" style=\"@style/DetailContentsBodyStyle\" android:text=\"옆 동네 토마토를 먹으면,\" /&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_8dp\" style=\"@style/ContentsBodyStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"전국 방방곡곡 및 전세계에서 농산물을 실어 나르려면 연료가 많이 들어요. 이렇게 연료를 지나치게 많이 사용하는 것은 대기 오염의 원인이 된답니다.\" /&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_32dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" style=\"@style/DetailContentsBodyStyle\" android:text=\"미션 방식\" /&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_8dp\" style=\"@style/ContentsBodyStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/text_mission_detail_mock_data\" /&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_32dp\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"미션 효과\" style=\"@style/DetailContentsBodyStyle\" /&gt; &lt;TextView android:layout_marginTop=\"@dimen/margin_8dp\" style=\"@style/ContentsBodyStyle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/text_mission_detail_mock_data\" /&gt; &lt;/LinearLayout&gt; &lt;/androidx.core.widget.NestedScrollView&gt; &lt;RelativeLayout android:id=\"@+id/missionDetailSelectButtonLayout\" android:layout_gravity=\"bottom\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"@drawable/border_button_background_active\" android:visibility=\"visible\"&gt; &lt;TextView style=\"@style/ButtonWhiteCenterStyle\" android:layout_centerInParent=\"true\" android:text=\"@string/text_mission_select\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/RelativeLayout&gt; &lt;LinearLayout android:id=\"@+id/missionDetailDecideButtonLayout\" android:layout_gravity=\"bottom\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:visibility=\"gone\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/missionDetailGiveUpButton\" style=\"@style/ButtonWhiteCenterStyle\" android:layout_weight=\"1\" android:gravity=\"center\" android:text=\"@string/text_mission_detail_cancel\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:background=\"@color/fe_fu_gray\"/&gt; &lt;TextView android:id=\"@+id/missionDetailCompleteButton\" style=\"@style/ButtonWhiteCenterStyle\" android:layout_weight=\"2\" android:gravity=\"center\" android:text=\"@string/text_mission_detail_complete\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:background=\"@color/fe_fu_main\"/&gt; &lt;/LinearLayout&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 여기서 주목해야 할 것은 android:fitsSystemWindows 속성이다. 이는 위의 4개 중에서 Toolbar만 제외하고 모두 true로 설정이 되어있다. 처음에는 큰 신경을 쓰지 않고 구글링을 통해 찾은 자료를 기반으로 구성했는데, 이게 문제가 된 것이었다. StackOverflow의 답변 중 android:fitsSystemWindows를 false로 설정하라는 부분을 보았다. 그래서 CoordinatorLayout 부분에서 제거를 하니 해당 이슈가 말끔하게 사라진 것이었다. 그래서 android:fitsSystemWindows이 어떤 속성일까 궁금해지기 시작했다. 그래서 다음과 같은 글을 찾게 되었다. Why would I want to fitsSystemWindows? 아직 읽어보지는 않았지만, 어떻게 이 속성으로 인해 해결을 했는지를 알 수 있을 것 같다. 느낀 점 역시 구글링도 실력인가 보다. 처음에는 감을 못잡아서 이상한 키워드로 검색을 했었다. 그러다가 MotionLayout을 사용해서 만들어봤는데, 내가 원하는 Performance를 100% 낼 수 없었다. 그러다가 문제를 다시 파악하고 검색을 해서 내가 원하는 결과를 얻을 수 있었다. 위의 첨부한 링크는 빠른 시일 내에 읽어보도록 노력할 것이다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"CoordinaotorLayout","slug":"CoordinaotorLayout","permalink":"https://woovictory.github.io/tags/CoordinaotorLayout/"},{"name":"삽집","slug":"삽집","permalink":"https://woovictory.github.io/tags/삽집/"}]},{"title":"[Design Pattern] 싱글톤 패턴","slug":"DesignPattern-Singleton","date":"2019-06-12T02:47:52.000Z","updated":"2020-05-12T11:30:25.006Z","comments":true,"path":"2019/06/12/DesignPattern-Singleton/","link":"","permalink":"https://woovictory.github.io/2019/06/12/DesignPattern-Singleton/","excerpt":"","text":"싱글톤 패턴은 굉장히 많이 사용되는 패턴이다. 나도 많이 사용하지만, 개념을 정리하고 싶어서 글을 쓰게 되었다. 싱글톤 패턴이란 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴이다. ‘생성 패턴’ 중 하나이다. Singleton의 역할 하나의 인스턴스만을 생성하는 책임이 있으며 getInstance() 메소드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다. 예시 프린트 관리자 만들기 프린트 하나를 10명이 공유해서 사용한다고 가정하자. 12345public class Printer &#123; public Printer()&#123; &#125; public void print(String str)&#123;...&#125;&#125; 그러나 Printer 클래스를 사용해 프린터를 이용하려면 Client 프로그램에서 new Printer()가 반드시 한 번만 호출되도록 주의해야 한다. 왜냐하면 프린터는 하나이기 때문에! 이를 해소하는 방법 중 하나는 생성자를 외부에서 호출할 수 없도록 하는 것이다. Printer 클래스의 생성자를 private으로 선언 123456public class Printer &#123; // Printer 생성자를 외부에서 사용하지 못함. private Printer()&#123; &#125; public void print(String str)&#123;...&#125;&#125; 자기 자신 프린터에 대한 인스턴스를 하나 만들어 외부에 제공해줄 메소드가 필요하다. static 메소드, static 변수 구체적인 인스턴스에 속하는 영역이 아니고, 클래스 자체에 속한다. 클래스의 인스턴스를 생성하지 않고도 메소드를 실행할 수 있고 변수를 참조할 수 있다. 객체가 저장되는 힙 영역이 아닌 클래스(메소드) 영역에 저장되어 모든 객체가 공유하는 메모리가 된다. 만약 new Printer()가 호출되기 전이면 인스턴스 메소드인 print() 메소드는 호출할 수 없다. 123456789101112131415161718192021public class Printer &#123; // 외부에 제공할 자기 자신의 인스턴스 // static 하기 때문에 해당 클래스의 객체들이 공유하낟. private static Printer printer = null; private Printer() &#123; &#125; // 자기 자신의 인스턴스를 외부에 제공하는 메소드. public static Printer getPrinter() &#123; if (printer == null) &#123; // printer 인스턴스 생성. printer = new Printer(); &#125; return printer; &#125; public void print(String str) &#123; System.out.println(str); &#125;&#125; Client에서 사용 1234567891011121314151617181920212223242526272829303132public class PrinterClient &#123; private static final int USER_NUMBER = 5; public static void main(String[] args) &#123; User[] users = new User[USER_NUMBER]; for (int i = 0; i &lt; USER_NUMBER; i++) &#123; users[i] = new User(String.valueOf(i + 1)); users[i].print(); &#125; &#125; public static class User &#123; private String name; public User(String name) &#123; this.name = name; &#125; public void print() &#123; Printer printer = Printer.getPrinter(); printer.print(this.name + \" print using \" + printer.toString()); &#125; &#125;&#125;// printer.toString()을 통해서 하나의 printer 객체를 사용하는 것을 확인할 수 있다.// 결과1 print using Singleton.Printer@60e53b932 print using Singleton.Printer@60e53b933 print using Singleton.Printer@60e53b934 print using Singleton.Printer@60e53b935 print using Singleton.Printer@60e53b93 문제점 다중 스레드 환경에서 Printer 클래스를 이용할 때 인스턴스가 1개 이상 생성되는 경우가 발생할 수 있다. 경합 조건(Race Condition)을 발생시키는 경우 Printer 인스턴스가 아직 생성되지 않았을 때 스레드 1이 getPrinter() 메소드의 if문을 실행해 이미 인스턴스가 생서되었는지 확인한다. 현재 printer 변수는 null인 상태이다. 만약 스레드 1이 생성자를 호출해 인스턴스를 만들기 전에 스레드 1의 CPU 이용시간이 끝나 스레드 2가 CPU를 획득해 스레드 2가 if문을 실행해 printer 변수가 null인지 확인한다. 현재 printer 변수는 null이므로 인스턴스를 생성하는 생성자를 호출하는 코드를 실행하게 된다. 스레드 1도 스레드 2와 마찬가지로 인스턴스를 생성하는 코드를 실행하게 되면 결과적으로 Printer 클래스의 인스턴스가 2개 생성되는 문제가 발생한다. race Condition이란? 메모리와 같은 한정적인 자원을 2개 이상의 스레드가 이용하려고 경합하는 현상을 말한다. 해결책 프린터 관리자(Lazy Initialization)는 사실 다중 스레드 환경의 애플리케이션이 아닌 경우에는 아무런 문제가 되지 않는다. 다중 스레드 환경에서 발생하는 문제를 해결하는 방법 정젹 변수에 인스턴스를 만들어서 바로 초기화 하는 방법(Eager Initialization) 인스턴스를 만드는 메소드에 동기화 하는 방법(Thread-Safe Initialization) Enum 클래스 사용. Holder에 의한 초기화 1. 정적 변수에 인스턴스를 만들어서 바로 초기화 하는 방법 이른 초기화(Eager Initialization)라고도 한다. 123456789101112131415public class Printer &#123; // static 변수에 외부에 제공할 자기 자신의 인스턴스를 만들어 초기화한다. private static Printer printer = new Printer(); private Printer() &#123; &#125; // 자기 자신의 인스턴스를 외부에 제공. private Printer getPrinter() &#123; return printer; &#125; public void print(String str) &#123; System.out.println(str); &#125;&#125; static 변수는 객체가 생성되기 전 클래스 로더에 의해 클래스가 메모리에 로딩될 때 만들어지기 때문에 초기화가 한 번만 실행된다. 또, 클래스 로더에 의해 클래스가 최초 로딩될 때 객체가 생성됨으로 Thread-Safe 하다. 프로그램 시작부터 종료까지 없어지지 않고 메모리에 계속 상주하며 클래스에서 생성된 모든 객체에서 참조할 수 있다. 하지만, 싱글톤 객체의 사용 유무와 상관 없이 클래스가 로딩되는 시점에 항상 싱글톤 객체가 생성되고 메모리를 점유하고 있기 때문에 비효율적인 부분이 있다. 2-1. 인스턴스를 만드는 메소드에 동기화 하는 방법 늦은 초기화(Lazy Initializaion)라고 한다. 123456789101112131415161718192021222324252627public class Printer &#123; // 외부에 제공할 자기 자신의 인스턴스 private static Printer printer = null; private int count = 0; private Printer() &#123; &#125; // 인스턴스를 생성하는 메소드 동기화. (임계 구역) public synchronized static Printer getInstance() &#123; if (printer == null) &#123; // printer 인스턴스 생성 printer = new Printer(); &#125; return printer; &#125; public void print(String str) &#123; // 오직 하나의 스레드 접근만을 허용한다. (임계 구역) // 성능을 위해 필요한 부분만을 임계 구역으로 설정한다. synchronized (this) &#123; count++; System.out.println(str); &#125; &#125;&#125; 임계 구역 인스턴스를 만드는 메소드를 임계 구역으로 변경했다. 임계 구역 : 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부를 말한다. 다중 스레드 환경에서 동시에 여러 스레드가 getPrinter() 메소드를 소유하는 객체에 접근하는 것을 방지한다. 공유 변수에 접근하는 부분을 임계 구역으로 변경 여러 개의 스레드가 하나뿐인 count 변수 값에 동시에 접근해서 갱신하는 것을 방지하기 위함이다. synchronized 키워드를 사용해서 getInstance() 메소드를 lock, unlock 처리하기 때문에 많은 비용이 발생한다. 대략 100배 정도 비효율적이라고 한다. 따라서 많은 쓰레드가 getInstance() 메소드를 호출하게 되면 프로그램의 전반적인 성능 저하가 발생한다. 2-2. Thread Safe Lazy Initialization + Double - Checked locking 2-1에서 언급한 인스턴스를 만드는 메소드에 동기화를 하는 방법에서 조금 바꾸면 된다. 2-1의 문제는 많은 쓰레드들이 동시에 synchronized 처리된 getInstance() 메소드를 접근하면 성능저하가 발생한다. 이를 완화하기 위해서 Double-Checked locking 기법을 사용한다. DCL이라고도 부른다. 12345678910111213141516public Printer&#123; private volatile static Printer printer; private Printer()&#123; &#125; public static Printer getInstance()&#123; if(printer == null)&#123; synchronized(Printer.class)&#123; if(printer == null)&#123; printer = new Printer(); &#125; &#125; &#125; return printer; &#125;&#125; 메소드에 synchronized를 제거하면서 동기화 오버헤드를 줄여보고자 하는 의도로 설계되었다. printer가 null인지 체크하고 null일 경우 동기화 블록에 진입하게 된다. 그래서 최초 객체가 생성된 이후로는 동기화 블록에 진입하지 않기 때문에 효율적이다. 하지만, 아주 안 좋은 케이스로 정상 동작하지 않을 수도 있다. 그래서 권고하지 않는 방법 중 하나이다. 3. Enum 클래스 간단하게 class가 아닌 enum으로 정의하는 것이다. 1234567public enum Printer&#123; INSTANCE; public static Printer getInstance()&#123; return INSTANCE; &#125;&#125; Enum은 인스턴스가 여러 개 생기지 않도록 확실하게 보장해준다.(Thread-Safe) 또한, 복잡한 직렬화나 리플렉션 상황에서도 직렬화가 자동으로 지원된다는 이점이 있다. 하지만, Enum에도 한계라는 것이 있다. 보통 Android 개발을 하게 될 경우 Singleton의 초기화 과정에 Context라는 의존성이 끼어들 가능성이 노다. Enum의 초기화는 컴파일 타임에 결정되므로 매번 메소드 등을 호출할 때 Context 정보를 넘겨야 하는 비효율적인 상황이 발생할 수 있다. 결론적으로 Enum은 효율적인 방법이지만, 상황에 따라 사용이 어려울 수도 있다는 점이다. 4. Holder에 의한 초기화 지금까지 나온 방법 중 가장 완벽하다고 평가 받는 방법이다. 코드를 먼저 확인해보자. 123456789101112public class Printer &#123; private Printer() &#123; &#125; private static Printer getInstance() &#123; return LazyHolder.INSTANCE; &#125; private static class LazyHolder &#123; private static final Printer INSTANCE = new Printer(); &#125;&#125; 한마디로 객체가 필요할 때로 초기화를 미루는 것이다. 따라서 Lazy Initialization이라고도 한다. Printer 클래스에는 LazyHolder 클래스의 변수가 없기 때문에 Printer 클래스 로딩 시 LazyHolder 클래스를 초기화하지 않는다. LazyHolder 클래스는 Printer 클래스의 getInstance() 메소드에서 LazyHolder.INSTANCE를 참조하는 순간 클래스 로더에 의해 Class가 로딩되며 초기화가 진행된다. 클래스 로더가 Class를 로딩하고 초기화하는 시점은 Thread-Safe를 보장하기 때문에 volatile이나 synchronized 같은 키워드가 없어도 thread-safe 하면서 성능도 보장하는 아주 훌륭한 방법이다. 참고 [Design Pattern] 싱글턴 패턴이란 Multi Thread 환경에서의 올바른 Singleton","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/tags/Design-Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://woovictory.github.io/tags/디자인-패턴/"},{"name":"싱글톤 패턴","slug":"싱글톤-패턴","permalink":"https://woovictory.github.io/tags/싱글톤-패턴/"}]},{"title":"[Design Pattern] 스트래티지 패턴","slug":"DesignPattern-StrategyPattern","date":"2019-06-11T08:51:03.000Z","updated":"2020-05-12T11:30:23.003Z","comments":true,"path":"2019/06/11/DesignPattern-StrategyPattern/","link":"","permalink":"https://woovictory.github.io/2019/06/11/DesignPattern-StrategyPattern/","excerpt":"","text":"스트래티지 패턴(Strategy Pattern)이란 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴 같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴 행위 패턴(Behavioral) 중 하나이다. 즉, 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴 전략 : 어떤 목적을 달성하기 위해 일을 수행하는 방식, 비즈니스 규칙, 문제를 해결하는 알고리즘 등을 말한다. 예를 들어, 게임 프로그래밍에서 게임 캐릭터가 자신이 처한 상황에 따라 공격이나 행동하는 방식을 바꾸고 싶을 때 스트래티지 패턴은 유용하다. 그림 각 역할이 수행하는 작업 Strategy 인터페이스나 추상 클래스로 외부에서 동일한 방식으로 알고리즘을 호출하는 방법을 명시 ConcreteStrategy 스트래티지 패턴에서 명시한 알고리즘을 실제로 구현한 클래스. 즉, 구현체 Context 스트래티지 패턴을 이용하는 역할을 수행한다. 필요에 따라 동적으로 구체적인 전략을 바꿀 수 있도록 setter 메소드(집약 관계)를 제공한다. 집약 관계 참조값을 인자로 받아 필드를 세팅하는 경우 전체 객체의 라이프 타임과 부분 객체의 라이프 타임은 독립적이다. 즉, 전체 객체가 메모리에서 사라진다 해도 부분 객체는 사라지지 않는다. 예시 오리 게임을 만들어보자. 오리 어플리케이션 게임을 운영하는 회사를 다니면서 오리게임을 만든다고 가정해보자. 표준적인 객체지향 기법을 사용해 Duck 이라는 슈퍼클래스를 만든 다음, 그 클래스를 확장하여 다른 종류의 오리를 만든다. 추상 클래스인 Duck 클래스를 RedHeadDuck 클래스와 MallardDuck 클래스가 상속을 받아 추상 메소드인 display()를 각각 구현한다. 문제의 시작1 처음 계획에는 없었는데 오리들이 물에 떠있는 기능 이외에 날아다녀야 하는 요구사항이 생겼다. 이건 간단하다. 그림처럼 나는 기능을 하는 fly() 메소드를 추가했다. 이로써 모든 오리들에게 날 수 있는 기능이 추가되었다. 그런데 오리 중 날 수 없는 오리가 있다는 사실을 잊고 있었다. Duck 클래스에서 코드 한 부분만을 바꿈으로 인해서 프로그램 전체에 부작용이 발생했다. 장난감 고무 오리도 날게 된 것이다. 문제를 해결하기 위해 RubberDuck 클래스에서 fly() 메소드와 quak() 메소드를 오버라이드 하여 소리를 낼 수 있고 날 수 있게 하는 기능을 변경시켜 주었다. 눈 앞에 있는 문제는 해결되었지만, 향후에 RubberDuck과 같은 가짜 오리가 더 추가가 된다면 그때마다 맞지 않는 상속되는 메소드들을 오버라이드해서 구현해야 하는 문제가 여전히 존재한다. 문제의 시작2 갑자기 회사에서 1개월 마다 한번씩 새로운 오리를 업데이트 한다고 한다. 여러 오리가 새롭게 추가될 것이고 그 규격도 계속 변할 것이라고 한다. 그렇다면 매번 모든 오리 서브클래스의 fly()와 quack() 같은 메소드를 일일이 살펴봐야 하고 상황에 따라 오버라이드 해야 할 수도 있다. 그럼 여기서 의문이 생긴다. ‘과연 상속을 활용하는게 맞는 방법일까?’ 다시 생각해보자. ‘인터페이스는 어떨까?’ 음, 코드 중복이 엄청나다. 메소드 몇개 오버라이드 하는 것을 피하다가 날아가는 동작 바꾸기 위해서 새롭게 생긴 모든 Duck 서브 클래스들을 전부 고쳐야 한다. 해결해보자 상속을 사용하는 것도 서브 클래스의 행동이 바뀔 수 있는데도 모든 서브 클래스들이 하나의 행동을 사용하는 것이 문제가 된다. 그리고 Flyable, Quackable 인터페이스를 사용하는 방법도 코드 재사용을 할 수 없다는 문제가 있다. (한가지의 행동을 바꿀 때마다 그 행동이 정의되어 있는 모든 서브 클래스들은 전부 찾아서 코드를 일일히 고쳐야 하고, 그 과정에서 새로운 버그가 생길 가능성이 많다.) 디자인 원칙 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리킨다. 위의 디자인 원칙을 적용해보자. 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 캡슐화를 시켜준다. 그러면 위에서 달라지는 부분은 fly(), quak() 이다. 이러한 행동을 Duck 클래스로부터 분리시키기 위해 각 행동을 나타낼 새로운 클래스의 집합을 만들어준다. 행동에 관한 인터페이스가 2개 생겼고 구체적인 행동을 구현하는 클래스들이 각각 생성된다. 이제 더이상 Duck에서 나는 행동과 소리를 내는 행동을 Duck 클래스나 그 서브 클래스에서 구현하지 않고 다른 클래스에게 위임을 해주게 된다. 디자인 원칙 상속보다는 구성을 활용한다. 구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다. 그리고 Duck 클래스는 두 개의 인터페이스 형식의 인스턴스 변수가 추가된다. Duck 클래스에서는 이제 행동을 직접 처리하는 대신에 새로 만든 performFly(), performQuack() 메소드에서 각각 FlyBehavior, QuackBehavior로 참조되는 객체에 그 행동을 위임해 줄 것이다. A는 B이다 보다는 A에는 B가 있다가 나을 수 있다. 각각의 오리들에게는 FlyBehavior와 QuackBehavior 인터페이스 객체가 있으며 각각 나는 행동과 소리 행동을 위임 받는다. 이런 방식으로 두 클래스를 합치는 것을 구성(Composition)을 이용하는 것이라고 한다. 여기의 오리 클래스는 행동을 상속받는 대신, 올바른 행동 객체로 구성됨으로써 행동을 부여받게 되는 것이다. 예시2 이번에는 로봇 만들기로 예시를 들어보자. Robot 클래스 123456789101112131415public abstract class Robot &#123; private String name; public Robot(String name) &#123; this.name = name; &#125; public String getName()&#123; return name; &#125; // 추상 메소드. public abstract void attack(); public abstract void movie();&#125; TaekwonV, Atom 클래스 12345678910111213141516171819202122232425262728293031public class TaekwonV extends Robot &#123; public TaekwonV(String name) &#123; super(name); &#125; @Override public void attack() &#123; System.out.println(\"I have Missile.\"); &#125; @Override public void movie() &#123; System.out.println(\"I can only walk.\"); &#125;&#125;public class Atom extends Robot &#123; public Atom(String name) &#123; super(name); &#125; @Override public void attack() &#123; System.out.println(\"I have strong punch.\"); &#125; @Override public void movie() &#123; System.out.println(\"I can fly.\"); &#125;&#125; client 클래스 123456789101112131415public class RobotClient &#123; public static void main(String[] args) &#123; Robot taekwonV = new TaekwonV(\"TaekwonV\"); Robot atom = new Atom(\"Atom\"); System.out.println(\"My Name is \"+taekwonV.getName()); taekwonV.movie(); taekwonV.attack(); System.out.println(); System.out.println(\"My Name is \"+atom.getName()); atom.movie(); atom.attack(); &#125;&#125; 문제점 기존 로봇의 공격과 이동 방법을 수정하는 경우 Atom이 날 수는 없고 오직 걷게만 만들고 싶다면? TaekwonV를 날게 하려면? 123456789101112131415public class Atom extends Robot &#123; public Atom(String name) &#123; super(name); &#125; @Override public void attack() &#123; System.out.println(\"I have strong punch.\"); &#125; @Override public void movie() &#123; System.out.println(\"I can only Walk.\"); &#125;&#125; 새로운 기능으로 변경하려고 기존 코드의 내용을 수정해야 한다. 따라서 OCP(개방 폐쇄 원칙)에 위배된다. 또한, TaekwonV와 Atom의 move() 메소드의 내용이 중복된다. 이런 중복 상황은 많은 문제를 야기하는 원인이 된다. 만약, 걷는 방식에 문제가 있거나 새로운 방식으로 수정하려면 모든 중복 코드를 일관성 있게 변경해야만 한다. 새로운 로봇을 만들어 기존의 공격 또는 이동 방법을 추가, 수정하는 경우 새로운 로봇으로 Sungard를 만들어 TaekwonV의 미사일 공격 기능을 추가하려면? 123456789101112131415public class Sungard extends Robot &#123; public Sungard(String name) &#123; super(name); &#125; @Override public void attack() &#123; System.out.println(\"I have Missile.\"); &#125; @Override public void movie() &#123; System.out.println(\"I can only walk.\"); &#125;&#125; TaekwonV와 Sungard 클래스의 attack() 메소드의 내용이 중복된다. 현재 시스템의 캡슐화 단위가 Robot 자체이므로 로봇을 추가하기는 매우 쉽다. 그러나 새로운 로봇인 Sungard에 기존의 공격 또는 이동 방법을 추가하거나 변경하려고 하면 문제가 발생한다. (메소드의 중복 문제라던지 OCP 원칙 위반 등) 해결책 문제를 해결하기 위해서는 무엇이 변화되었는지를 찾은 후에 변화하지 않는 부분과 분리하여 변화하는 부분을 클래스로 캡슐화해야 한다. 로봇 예제에서 변화되면서 문제를 발생시키는 요인은 로봇의 이동 방식과 공격 방식의 변화이다. 이를 캡슐화하려면 외부에서 구체적인 이동 방식과 공격 방식을 담은 구체적인 클래스들을 은닉해야 한다. 공격과 이동을 위한 인터페이스를 각각 만들고, 이들을 실제로 구현한 클래스를 만들어야 한다. Robot 클래스가 이동 기능과 공격 기능을 이용하는 클라이언트 역할을 수행한다. 구체적인 이동, 공격 방식이 MovingStrategy와 AttackStrategy 인터페이스에 의해 캡슐화 되어 있다. 이 인터페이스들이 일종의 방화벽 역할을 수행해 Robot 클래스의 변경을 차단해준다. 스트래티지 패턴을 이용하면 새로운 기능의 추가(새로운 이동, 공격 기능)가 기존의 코드에 영향을 미치지 못하게 하므로 OCP를 만족하는 설계가 된다. 이렇게 변경된 새로운 구조에서는 외부에서 로봇 객체의 이동, 공격 방식을 임의대로 바꾸도록 해주는 setter 메소드가 필요하다. setMovingStrategy, setAttackStrategy 이렇게 변경이 가능한 이유는 상속 대신 집약 관계를 이용했기 때문이다. 스트래티지 패턴을 적용해서 로봇 예시를 수정해보자. 공격에 대한 인터페이스 구체적인 클래스 123456789101112131415161718// 공격 기능에 대한 인터페이스.public interface AttackStrategy &#123; void attack();&#125;// 공격 인터페이스를 구현한 구현체 클래스.public class MissileStrategy implements AttackStrategy &#123; @Override public void attack() &#123; System.out.println(\"I have Missile\"); &#125;&#125;public class PunchStrategy implements AttackStrategy &#123; @Override public void attack() &#123; System.out.println(\"I have strong punch.\"); &#125;&#125; 이동에 대한 인터페이스와 구체적인 클래스 123456789101112131415161718// 이동 기능에 대한 인터페이스.public interface MovingStrategy &#123; void move();&#125;// 이동 인터페이스를 구현한 구체적인 클래스.public class FlyingStrategy implements MovingStrategy &#123; @Override public void move() &#123; System.out.println(\"I can fly.\"); &#125;&#125;public class WalkingStrategy implements MovingStrategy &#123; @Override public void move() &#123; System.out.println(\"I can only walk.\"); &#125;&#125; Robot 클래스 12345678910111213141516171819202122232425262728293031public abstract class Robot &#123; private String name; private AttackStrategy attackStrategy; private MovingStrategy movingStrategy; public Robot(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void attack() &#123; attackStrategy.attack(); &#125; public void movie() &#123; movingStrategy.move(); &#125; // setter 메소드 // 집약 관계, 전체 객체가 메모리에서 사라진다 해도 부분 객체는 사라지지 않는다. public void setAttackStrategy(AttackStrategy attackStrategy) &#123; this.attackStrategy = attackStrategy; &#125; public void setMovingStrategy(MovingStrategy movingStrategy) &#123; this.movingStrategy = movingStrategy; &#125;&#125; 구체적인 Robot 클래스 1234567891011public class TaekwonV extends Robot &#123; public TaekwonV(String name) &#123; super(name); &#125;&#125;public class Atom extends Robot &#123; public Atom(String name) &#123; super(name); &#125;&#125; Client에서 사용 1234567891011121314151617181920212223242526272829public class RobotClient &#123; public static void main(String[] args) &#123; Robot taekwonV = new TaekwonV(\"TaekwonV\"); Robot atom = new Atom(\"Atom\"); taekwonV.setAttackStrategy(new MissileStrategy()); taekwonV.setMovingStrategy(new FlyingStrategy()); System.out.println(\"My name is \" + taekwonV.getName()); taekwonV.attack(); taekwonV.move(); // 수정된 부분 : 전략 변경 방법. System.out.println(); taekwonV.setAttackStrategy(new PunchStrategy()); taekwonV.setMovingStrategy(new WalkingStrategy()); taekwonV.attack(); taekwonV.move(); System.out.println(); atom.setMovingStrategy(new WalkingStrategy()); atom.setAttackStrategy(new PunchStrategy()); System.out.println(\"My name is \" + atom.getName()); atom.attack(); atom.move(); &#125;&#125; 따라서 기존의 코드를 수정하지 않고도 기능을 추가하거나 수정할 수 있게 되었다. OCP 원칙을 위배하지 않고 스트래티지 패턴을 적용한 예시이다. 참고 디자인패턴 - 스트래티지 패턴 (strategy pattern) [Design Pattern] 스트래티지 패턴이란","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/tags/Design-Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://woovictory.github.io/tags/디자인-패턴/"},{"name":"스트래티지 패턴","slug":"스트래티지-패턴","permalink":"https://woovictory.github.io/tags/스트래티지-패턴/"}]},{"title":"[Design Pattern] 개요","slug":"DesignPattern-Overview","date":"2019-06-10T08:55:41.000Z","updated":"2020-05-12T11:30:18.367Z","comments":true,"path":"2019/06/10/DesignPattern-Overview/","link":"","permalink":"https://woovictory.github.io/2019/06/10/DesignPattern-Overview/","excerpt":"","text":"디자인 패턴(Design Pattern) 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 문제들을 해결하기 위해 만든 재사용 가능한 해결책 패턴 각기 다른 프로젝트를 개발할 때, 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있다. 이러한 유사점을 패턴이라고 한다. 패턴은 공통의 언어를 만들어주며 팀원 사이의 의사 소통을 원활하게 해주는 아주 중요한 역할을 한다. 디자인 패턴의 종류 GoF 디자인 패턴 GoF(Gang of Fout)라 불리는 에리히 감마(Erich Gamma), 리차드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시디스(John Vissides)가 소프트웨어 개발 영역에서 디자인 패턴을 구체화하고 체계화하였다. 23가지의 디자인 패턴을 정리하고 각각의 디자인 패턴을 생성(Creational), 구조(Structural), 행위(Behavioral)의 3가지로 분류했다. 분류 생성(Creational) 패턴 객체 생성에 관련된 패턴 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다. 구조(Structural) 패턴 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴 예를 들어, 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다. 행위(Behavioral) 패턴 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다. 이 포스팅은 디자인 패턴을 공부하면서 정리하는 글입니다. 하루에 1개씩 공부하고 정리하면서 학습할 예정입니다. ^__^ 참고 [Design Pattern] 디자인 패턴 종류","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/tags/Design-Pattern/"},{"name":"디자인 패턴","slug":"디자인-패턴","permalink":"https://woovictory.github.io/tags/디자인-패턴/"}]},{"title":"[Android] MVVM Part.2","slug":"Android-MVVM","date":"2019-06-10T06:51:20.000Z","updated":"2020-03-01T10:27:31.091Z","comments":true,"path":"2019/06/10/Android-MVVM/","link":"","permalink":"https://woovictory.github.io/2019/06/10/Android-MVVM/","excerpt":"","text":"[Android] MVVM Part.1 [Android] MVVM Part.2 MVVM에 대한 이해가 부족해 보충하고자 조금 더 공부하며 정리를 하고자 한다. 안드로이드 개발을 처음 시작한다면 하나의 액티비티에 모든 코드를 넣어서 개발을 할 것이다. 이렇게 되면 시간이 지날수록 액티비티는 무거워지고 많은 일을 담당하게 될 것이다. 그로 인해 수정이나 유지보수하기가 힘들어진다. 이처럼 비구조적이고 유지보수가 어려운 코드를 스파게티 코드라고 하는데, 나의 첫 프로젝트도 기가 막힌 스파게티 코드였다. 스파게티 코드를 줄이고 이쁜 코드를 만들기 위해 디자인 패턴 공부의 필요성을 느끼게 되었다. 수업 시간에 들은 디자인 패턴을 잘 숙지해둘 걸 하는 후회가 밀려온다. 기억이 잘 나지 않기 때문이다…ㅜ 아무튼 디자인 패턴은 차근차근 공부하기로 하고 MVVM에 대한 글을 쓰면서 내가 알고 있는 개념도 정리하려고 두 번째 글을 쓰게 되었다. 첫 번째 글은 MVP와 MVVM의 차이에 대한 설명과 어떤 점이 좋은지에 대해 간략하게 설명하고 있다. MVVM 패턴 액티비티에 기능을 붙이다보면 액티비티가 무거워지거나 혹은 종속성이 너무 강해 테스트가 힘들고 유지보수가 어려워진다. 이러한 고민을 해결하기 위해 Architecture 패턴이 등장했고 그 중 하나가 이번에 살펴볼 MVVM이다. MVVM은 View - ViewModel - Model을 이용해 각각의 역할을 분리하여 가독성과 재사용성을 높인 Architecture 패턴이다. MVC와 MVV 차이점 기존 MVC(Model - View - Controller) 구조에서는 액티비티가 컨트롤러의 역할을 했으며, 뷰와 연결되어 사용자와 상호작용도 하고 모델과 연결되어 데이터도 처리했다. 즉, 뷰와 모델 사이에서 중재자 역할을 했다. MVVM에서는 뷰에서 뷰모델로, 뷰모델에서 모델로 작업을 처리하며, 뷰에서 모델을 직접 참조하지 않는다. 대신 뷰에서 뷰모델을 관찰하여 데이터의 변경 사항을 감지한다. 예를 들어보자. 유저가 목록에 새로운 아이템을 추가했다. MVC에서는 컨트롤러가 유저의 클릭 액션을 확인하고, 모델에 데이터를 갱신하도록 요청한다. 그리고 뷰에도 화면을 업데이트하라고 요청을 해야 한다. 이 경우 액티비티가 해야 할 일이 너무 많다. 까닥하면 DB만 갱신되고 화면은 갱신되지 않는 경우도 있다. MVVM에서도 뷰가 유저의 클릭 액션을 확인하지만, 뷰에서 곧바로 DB에 접근하지 않는다. 말 그대로 뷰이기 때문에 UI를 갱신하는 역할에 충실하다. 대신 뷰모델을 참조하고, 뷰모델에서는 다시 모델에서 정리된 데이터를 참조한다. 또, 뷰는 뷰모델은 관찰(Observe) 한다. DB에 새로운 아이템을 추가한 후에 화면을 업데이트 하라고 직접 명령하지 않아도 된다. 뷰에서는 이미 뷰모델을 관찰하고 있기 때문에 데이터의 변화를 알아차리고 자동으로 화면을 갱신한다. MVVM의 장점 뷰가 데이터를 실시간으로 관찰한다. LiveData 즉, Observer 패턴을 이용하기 때문에 데이터베이스를 관찰하고 자동으로 UI를 갱신한다. 직접 뷰를 바꿔주는 번거로움도 없으며 데이터와 불일치할 확률이 줄어든다. 생명주기로부터 안전하다. 메모리 누수 방지! AAC의 뷰모델을 통해 데이터를 참조하기 때문에 액티비티/프래그먼트의 생명주기를 따르지 않는다. 즉, 액티비티/프래그먼트의 생명주기 동안 계속 살아있고, onDestroy()가 호출될 때 사라지게 된다. 화면 회전과 같이 액티비티가 파괴된 후에 재구성되어도 뷰모델이 데이터를 홀드하고 있기 때문에 영향을 받지 않는다. 또한, 뷰가 활성화되어있을 경우에만 작동하기 때문에 불필요한 메모리 사용을 줄일 수 있다. 역할 분리! UI, 비즈니스 로직, 모델이 기능별로 모듈화 되어 있어서 역할 별로 분리가 되어있다. 이로 인해서 테스트 코드를 작성하는게 한결 수월해진다. 이처럼 모듈화가 잘 되어 있다면 다음과 같은 상황에서 수정이 쉽다. 내장 DB를 통째로 바꾸고 싶다고 할 때, 뷰나 다른 코드에 깊게 종속되어 있지 않기 때문에 DB만 교체하면 된다. 뷰모델과 뷰는 1:N 관계를 갖기 때문에 뷰모델에 하나의 메소드를 구현하고 A 액티비티나 B 액티비티, 여러 뷰에서 호출해 사용하기 때문에 재사용이 가능하다. AAC 구글은 Android Architecture Component 이하 AAC를 제공한다. AAC는 앱 구조를 더 튼튼하고 테스트에 용이하고, 유지보수성이 뛰어나게 만들도록 도와주는 라이브러리의 모음이다. 조금 더 모듈화된 코딩을 돕기 위해 Databinding, LiveData, ViewModel 등의 유용한 라이브러리를 제공하며, 이러한 라이브러리를 사용해 MVVM 패턴을 조금 더 쉽게 구성할 수 있다. 위의 이미지에서 MVVM의 구성 요소로 역할을 나눠보자. View : 초록색(UI) ViewModel: 파란색 Model : 노란색(Repository), Room Database View UI를 담당하는 액티비티, 프래그먼트를 의미한다. 화면에 무엇을 그릴지 결정하고 사용자와 상호작용한다. 보통 데이터의 변화를 감지하기 위한 옵저버를 가지고 있다. ViewModel UI를 위한 데이터를 가지고 있으며, 구성이 변경되어도 살아남는다.(ex. 화면 회전, 언어 변경 등) AsyncTask는 액티비티나 프래그먼트의 생명 주기에서 자유로울 수 없지만, 뷰모델은 뷰와 분리되어 있기 때문에 액티비티가 Destory 되었다가 다시 Create 되어도 종료되지 않고 데이터를 여전히 유지하고 있다. LiveData 관찰(Observable)이 가능한 데이터 홀더 클래스이다. 뷰에서 뷰모델의 Live Data를 관찰하게 되면 데이터가 변경될 때 내부적으로 자동으로 알려주게 된다. 또한, Live Data는 액티비티나 프래그먼트의 생명 주기를 인지한다. 즉, 액티비티가 활성화되어 있을 때에만 UI 변경 등의 기능을 동작하게 되고, Destory된 상태에서는 동작하지 않기 때문에 Memory Leak의 발생을 줄여준다. Repository 뷰 모델과 상호작용하기 위해 잘 정리된 데이터 API를 들고 있는 클래스이다. 앱에 필요한 데이터, 즉 내장 데이터베이스나 외부 웹 서버 등에서 데이터를 가져온다. 따라서 뷰모델은 DB나 서버에 직접 접근하지 않고, Repository에 접근하는 것으로 앱의 데이터를 관리한다. 결론 MVVM에 대해 처음에는 이해하기가 너무 어려웠다. 왜냐하면 간단한 기능을 가진 앱을 만들더라도 많은 클래스가 필요하고, 프로젝트의 패키지 구조가 복잡해지기 때문이다. 또한, 인터넷 상에 존재하는 대부분의 MVVM 예제는 DI가 적용된 것들이 많다. MVVM도 처음에 어려운데 DI까지 함께 한다면 정말 머리가 깨질 수도 있다. 그래서 나는 Koin을 사용한 MVVM 예제를 찾았고 이를 많이 참고했다. Dagger2에 비해서 접근하기가 훨씬 쉬우며, 사용법도 간단해서 금방 배울 수 있다고 생각한다. 아래는 내가 공부하면서 참고했던 Sample 프로젝트의 출처이다. Android Kotlin MVVM패턴으로 간단한 검색 앱 만들기 - 1. BaseView, BaseViewModel을 작성하여 MVVM의 토대 만들기 Android MVVM 패턴, ViewModel, LiveData, Databinding을 이용해 간단한 Toy App 만들기 [Android, MVVM] ViewModel, LiveData, DataBinding, Koin 을 사용한 MVVM 그래도 위의 프로젝트를 참고해서 구조를 익히고 따라해서 만들고 직접 간단하게라도 적용해본다면 MVVM에 대한 이해가 될 것이라고 생각한다. 나도 위의 3 프로젝트를 직접 따라해보면서 코딩해봤고, 혼자서 분석도 해봤다. 그래서 지금 진행 중인 프로젝트에 MVVM을 적용하고 있다. 아직 어려운 부분이 좀 많지만 그때 그때 구글링을 통해서 해결하고 있다. 이런 해결 과정도 정리해놓으면 좋을 것 같다. 아무튼, 모두 화이팅!(나도!) 참고 [Android] MVVM &amp; 안드로이드 아키텍쳐 컴포넌트 시작하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVVM","slug":"MVVM","permalink":"https://woovictory.github.io/tags/MVVM/"},{"name":"Architecture","slug":"Architecture","permalink":"https://woovictory.github.io/tags/Architecture/"}]},{"title":"[Android] MVVM Part.1","slug":"What-is-MVVM","date":"2019-06-09T13:37:20.000Z","updated":"2020-05-26T07:00:41.489Z","comments":true,"path":"2019/06/09/What-is-MVVM/","link":"","permalink":"https://woovictory.github.io/2019/06/09/What-is-MVVM/","excerpt":"","text":"[Android] MVVM Part.1 [Android] MVVM Part.2 LiveData ViewModel Databinding 선수 지식 필요. Architecture 패턴에는 일반적으로 사용하는 MVC, MVP, MVVM이 있다. 이러한 Architecture 적용으로 얻는 이점은 안정적인 서비스 개발을 할 수 있으며 유지 보수를 빠르게 할 수 있다는 것이다. 먼저, MVP Architecture부터 살펴보자. 1. MVP Presenter : View에서 요청한 정보를 Model로부터 가공해서 View로 전달하는 부분 Model과 View는 MVC와 동일하지만 사용자 입력을 View에서 받는다. 그리고 Model과 View는 각각 Presenter와 상호 작용을 하게 된다. 항상 Presenter를 거쳐 동작하는 셈이다. 그러므로 View와 Model은 서로를 알 필요가 전혀 없다. Presenter만 알면 된다. 그래서 MVC의 단점인 View와 Model의 의존성이 없어지게 된다. 정리하자면 View로 사용자의 입력이 들어온다. View는 Presenter에 작업 요청을 한다. Presenter에서 필요한 데이터를 Model에 요청한다. Model은 Presenter에 필요한 데이터를 응답한다. Presenter는 View에 데이터를 응답한다. View는 Presenter로부터 받은 데이터로 화면에 보여주게 된다. View에서 비즈니스 로직을 분리하는 부분은 성공적이다. Model 역시 분할되어 있어서 적용하기 쉽다. 하지만, View와 Presenter의 1:1 관계를 유지하는 덕분에 몇 가지 단점이 생긴다. 중복 코드 발생한다. View에 대한 의존성이 강해진다. 중복 코드? 간단한 예를 들어보겠다. 로그인과 로그아웃은 어떠한 화면에서도 호출될 수 있다. 기획상으로 가능하다면 말이다. A/B/C/D 4개의 화면이 있고, 언제든 로그인만 호출할 수 있다. 대부분은 로그인 Acitivity로 이동시키고 이를 구현하면 된다. 반대로 로그아웃이다. 단순하게 로그아웃한다고 생각해보자. 로그아웃 역시 A/B/C/D 화면에서 언제든 접근할 수 있다. MVP에서는? 로그인, 로그아웃을 처리하는 비즈니스 로직은 A/B/C/D 화면에 종속적인 Presenter 4개에서 모두 호출하게 된다. 모델에서 실제 로그인, 로그아웃 처리 로직이 있는 부분은 가져다가 사용하는 것이다. 여기서 공통 코드가 발생하게 된다. 공통 코드? MVP에서 발생하는 공통 코드를 어떻게 해결할 수 있을까? Presenter도 상속을 받아서 공통 코드를 해결 별도의 공통 로직을 가지는 새로운 클래스를 생성 Presenter 분리? 위와 같은 공통 코드를 관리할 수는 있다. MVVM은 View Model 분리의 시작 위에서 적은 Presenter를 분리하면 MVVM이 된다. View에 대한 모델을 분리하였기 때문에 ViewModel이다. 즉,ViewModel은 View에 대한 모델 분리가 있어야 한다. View에서 사용하는 중복적인 Presenter의 코드가 발생하면 이를 ViewModel 하나로 분리해주는게 가장 이상적이다. MVP의 기본 개념인 View와 Presenter의 1:1 관계 유지에서 벗어나기 위해서는 MVVM이 가장 좋은 해결책으로 보인다. 조금 더 이쁜 코드를 만들기 위해서는 최소한 View에 대한 Model은 정의해주어야 한다. 그렇게 해야 아래와 같은 처리가 가능해진다. View에 대한 종속성을 줄인다. 종속성을 줄이기 위해 ReactiveX, Databinding 등을 이용할 수 있다. View에 대한 Model 정의가 명확해야 한다. 이 ViewModel은 언제든 View에서 가져다 쓰기만 하면 되고, 불필요한 경우 해당 ViewModel만 버릴 수 있어야 한다. ViewModel에 대한 테스트가 가능해진다. View에 대한 테스트와 완전하게 분리 가능하여 비즈니스 로직이 아닌 각각의 ViewModel 테스트가 가능해진다. MVVM의 ViewModel이란? MVVM은 고민을 많이 해야 하는 구조이다. ViewModel 분리가 필요할까? 분리했을 때 얻는 이점은? 종속성은? ReactiveX, DataBinding 등을 이용해 해결할 수 있다. 테스트 코드는? 테스트 코드는 유용해야 한다. View에 대한 모델을 모두 분리한다면? 다음과 같이 구성할 수 있을 것이다. LoginViewModel : 로그인만 하는 모델 LogoutViewModel : 로그아웃만 하는 모델 UserInfoViewModel : 사용자 정보만을 가져와 가공한다. 여기까지 MVP와 MVVM에 대해 차이점과 ViewModel에 대해 조금 알아봤다. 이제는 MVVM을 알아보도록 하자. 2. MVVM Presenter 대신에 ViewModel이 존재한다. ViewModel : View를 표현하기 위해 만들어진 View를 위한 Model MVVM에서는 두 가지 디자인 패턴을 사용한다. Command 패턴과 Data binding이다. 이 두 가지 디자인 패턴을 사용함으로써 View와 ViewModel은 의존성이 완전히 사라지게 된다. View에서 입력이 들어오고 Command 패턴을 통해서 ViewModel에 명령을 내리게 되고 Data binding으로 인해 ViewModel의 값이 변화하면 바로 View의 정보가 바뀌게 된다. 정리하자면 View에 입력이 들어오면 Command 패턴으로 ViewModel에 명령을 한다. ViewModel은 필요한 데이터를 Model에 요청한다. Model은 ViewModel에 필요한 데이터를 응답한다. ViewModel은 응답 받은 데이터를 가공해서 저장한다. View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신된다. 왜 MVVM을 사용할까? 전통적인 UI 개발에서 개발자는 윈도우, 사용자 컨트롤, 페이지를 사용해서 View를 만들곤 했다. 그리고 모든 논리 로직이 들어간 코드(핸들링, 초기화 그리고 데이터 모델 등)를 뷰 클래스에 정의한다. 이러한 방법은 뷰 클래스의 크기를 늘리고 UI와 데이터 그리고 비즈니스 사이의 매우 강한 의존성을 형성한다. 이와 같은 상황에서 여러 개발자들은 동시에 같은 뷰에서 작업하기 힘들어 질 것이다. 즉, 협업하는 상황에서 같은 화면을 함께 개발하지 못하고 서로 다른 화면을 개발해야 하는 비효율적인 상황이 발생할 것이다. 또한, 다른 개발자가 코드를 바꾸면 다른 부분을 망가뜨릴 위험도 존재한다. 이처럼 모든 코드들이 한 클래스에 있는 것은 유지보수 그리고 테스트를 하는데 있어서 좋지 않다. 뷰(UI) 모델(UI 상에 보여지고 있는 데이터) 글루 코드(핸들링과 바인딩 그리고 비즈니스 로직) 글루 코드 : 서로 다른 코드를 접착시키는 코드 비즈니스 로직 : 데이터의 처리가 이루어지는 부분 MVVM에서 글루 코드는 뷰 모델이다. 그래서 애플리케이션의 구조를 더욱 간단하고 유지가능할 수 있게 만들기 위해서는 관심사의 분리에 집중해야 한다. 만약, 뷰 모델에서의 프로퍼티 값이 변하게 되면 데이터 바인딩과 노티피케이션을 통해 자동으로 새로운 값을 알려준다. 만약 사용자가 저장하기 버튼을 클릭하는 액션을 뷰에서 취했을 때, 뷰모델은 요청된 명령을 실행한다. 이 과정에서 뷰모델은 모델의 데이터를 수정하고 뷰는 데이터를 수정하지 않는다. 뷰는 모델의 존재를 모른다. 반면 뷰 모델과 모델은 뷰를 인식하지 않는다. 모델은 뷰와 뷰 모델의 존재를 모른다. MVVM에 대해 MVVM 패턴을 지켜 개발된 앱은 아래의 특징을 갖는다. 관심사의 분리 - 하나의 소프트웨어를 최대한 기능적으로 작은 단위로 나눈다 테스트가 쉬워지고 큰 프로젝트도 상대적으로 관리하기 좋다. SOLID 원칙을 지향한다. 앱이 구조적으로 약한 결합의 컴포넌트로 나눠진다. 대체적으로 위와 같은 장점에 대해서 이야기를 하지만 결국 가장 큰 목적은 유지보수가 쉽고 테스트가 용이한 코드를 만드는 것이다. View는 ViewModel에게 클릭 이벤트, 필요한 데이터 요청 등을 명시적으로 하고 ViewModel이 notify할 때까지 기다리게 된다. 동일하게 ViewModel은 Model을 통해 데이터를 요청하고 기다리게 된다. 각각의 컴포넌트간 참조를 갖지 않고 단방향(View -&gt; ViewModel -&gt; Model)의 의존성만을 갖게 된다. 정리 뷰, 뷰모델, 모델 이 셋은 서로의 존재를 몰라야 한다. -&gt; 서로 간의 의존성을 최대한 제거함으로써 유지보수가 쉽고 테스트 가능한 코드가 된다. 뷰에서 액션을 받으면 뷰모델에서 비즈니스 로직을 실행한다. 뷰 모델은 모델의 데이터를 수정한다. 뷰 모델은 데이터 바인딩과 노티피케이션을 통해 뷰를 수정한다. 뷰와 뷰 모델은 n:m의 관계이다. 오직 뷰모델만이 모델에 접근할 수 있고 뷰는 모델에 접근하지 못한다. # 참고 [번역] MVVM 디자인 패턴의 기본 이해 MVC, MVP, MVVM 비교 Android MVVM 어떻게 구현하는게 좋을까?","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"MVVM","slug":"MVVM","permalink":"https://woovictory.github.io/tags/MVVM/"},{"name":"Architecture","slug":"Architecture","permalink":"https://woovictory.github.io/tags/Architecture/"}]},{"title":"[RxJava] Chap04. 결합연산자","slug":"RxJava-Chap04-Combination","date":"2019-06-09T11:47:22.000Z","updated":"2020-05-26T07:07:00.012Z","comments":true,"path":"2019/06/09/RxJava-Chap04-Combination/","link":"","permalink":"https://woovictory.github.io/2019/06/09/RxJava-Chap04-Combination/","excerpt":"","text":"결합 연산자 생성 연산자와 변환 연산자는 1개의 데이터 흐름(Observable)을 다뤘다. 결합 연산자는 다수의 Observable을 하나로 합하는 방법을 제공한다. flatMap(), groupBy() 함수 등은 1개의 Observable을 확장해주는 반면, 결합 연산자들은 여러 개의 Observable을 내가 원하는 Observable로 결합해준다. 1. zip() 각각의 Observable을 모두 활용해 2개 혹은 그 이상의 Observable을 결합한다. 예를 들어, A, B 두 개의 Observable을 결합한다면 2개의 Observable에서 모두 데이터를 발행해야 결합할 수 있다. 그전까지는 발행을 기다린다. zip() 함수는 최대 9개의 Observable을 결합할 수 있지만 보통 2개 혹은 3개면 충분하다. 다음은 간단한 zip() 함수의 사용 예제이다. 12345678910111213141516public static void main(String[] args)&#123; executeZipInteger();&#125;private static void executeZipInteger() &#123; Observable.zip( Observable.just(100, 200, 300), Observable.just(10, 20, 30), Observable.just(1, 2, 3), (a, b, c) -&gt; a + b + c ).subscribe(Log::i); &#125;// 결과main | value = 111main | value = 222main | value = 333 2. zipWith() zipWith() 함수는 zip() 함수와 동일하지만 Observable을 다양한 함수와 조합하면서 틈틈이 호출할 수 있는 장점이 있다. 1234567891011121314public class ZipWithSample &#123; public static void main(String[] args) &#123; Observable&lt;Integer&gt; source = Observable.zip( Observable.just(100, 200, 300), Observable.just(10, 20, 30), (a, b) -&gt; a + b) .zipWith(Observable.just(1, 2, 3), (ab, c) -&gt; ab * c); source.subscribe(Log::i); &#125;&#125;// 결과main | value = 110main | value = 440main | value = 990 두 Observable을 zip() 함수로 묶고 세 번째 Observable을 다시 zipWith() 함수로 결합했다. zipWith() 함수를 호출할 때는 앞서 a와 b를 결합했기 때문에 ab로 명명했다. 3. combinLatest() 2개 이상의 Observable을 기반으로 Observable 각각의 값이 변경되었을 때 갱신해주는 함수이다. 마지막 인자로 combiner가 들어가는데 그것이 각 Observable을 결합하여 어떤 결과를 만들어주는 역할을 하는 함수이다. zip() 함수의 zipper 인자와 동일하다. 예를 들어, 첫 번째 Observable과 두 번째 Observable을 결합하는 기능을 만든다고 하면 첫 번째 Observable의 값 혹은 두 번째 Observable의 값이 변경되었을 때 그 값을 자동으로 갱신해준다. 첫 번째 Observable에서만 데이터를 발행하거나 두 번째 Observable의 데이터 흐름만 있으면 구독자에게 어떤 데이터도 발행하지 않는다. 하지만 두 Observable 모두 값을 발행하면 그때는 결과값이 나온다. 그 다음부터는 둘 중에 어떤 것이 갱신되던지 최신 결과값을 보여준다. -&gt; 이 부분이 zip() 함수와 다른 점이다. zip() 함수처럼 결합하고자 하는 첫 번째와 두 번쨰 Observable을 넣고 마지막으로 그것을 결합하는 combiner() 함수를 넣어주면 된다. 입력할 수 있는 Observable 인자의 개수는 9개이다. 4. merge() zip() 함수나 combineLatest() 함수와 비교하면 가장 단순한 결합 함수이다. 입력 Observable의 순서와 모든 Observable이 데이터를 발행하는지 등에 관여하지 않고 어느 것이든 업스트림에서 먼저 입력되는 데이터를 그대로 발행한다. 5. concat() 2개 이상의 Observable을 이어 붙여주는 함수이다. 첫 번째 Observable에 onComplete 이벤트가 발생해야 두 번째 Observable을 구독한다. 스레드를 활용한 일반적이 코드로 이와 같은 내용을 구현하기는 복잡하다. 결합할 수 있는 Observable은 최대 4개이다. 첫 번째 Observable에 onComplete 이벤트가 발생하지 않게 되면 두 번째 Observable은 영원히 대기한다. 이는 잠재적인 메모리 누수의 위험을 내포한다. 따라서 입력 Observable이 반드시 완료(onComplete 이벤트)될 수 있게 해야 한다. Observable의 중간 상태를 확인하는 방법 리액티브 프로그래밍을 할 때는 중간에 로그를 출력하는 것이 낯설게 느껴진다. 특히 함수형 프로그래밍 패러다임을 배우면서 &quot;로그나 화면 출력하는 등을 부수 효과를 발생시킨다&quot;라는 내용을 접하면 부수 효과를 최소화하려고 하는 경향이 생긴다. 하지만 부수 효과를 감내하고서라도 적절한 로그는 유지 보수성을 확보하기 위해 꼭 필요하다. RxJava에서는 Observable의 중간 결과를 간편하게 확인할 수 있는 함수들을 제공한다. 확실하지 않은 코드나 예제 코드를 실행할 때 찜찜한 부분이 있다면 doOnNext(), doOnComplete(), doOnError() 함수를 추가해보자.","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"연산자 활용","slug":"연산자-활용","permalink":"https://woovictory.github.io/tags/연산자-활용/"}]},{"title":"[RxJava] Chap04.변환연산자","slug":"RxJava-Chap04-Transform","date":"2019-06-07T15:40:00.000Z","updated":"2020-05-26T07:06:55.563Z","comments":true,"path":"2019/06/08/RxJava-Chap04-Transform/","link":"","permalink":"https://woovictory.github.io/2019/06/08/RxJava-Chap04-Transform/","excerpt":"","text":"변환 연산자 위에서 데이터 흐름(Observable)을 만들어내는 생성 연산자를 보았다면 이번에는 데이터 흐름을 원하는대로 변형할 수 있는 변환 연산자를 알아보자. 1. concatMap() flatMap() 함수와 매우 비슷하다. 하지만, concatMap() 함수는 먼저 들어온 데이터 순서대로 처리해서 결과를 낼 수 있도록 보장한다. 즉, 데이터의 순서를 보장한다. flatMap() 함수는 순서를 보장하지 않는다. flatMap() 함수는 먼저 들어온 데이터를 처리하는 도중에 새로운 데이터가 들어오면 나중에 들어온 데이터의 처리 결과가 먼저 출력될 수도 있다. 이를 인터리빙(끼어들기)라고 한다. 2.switchMap() concatMap() 함수가 인터리빙이 발생할 수 있는 상황에서 동작의 순서를 보장해준다면 switchMap() 함수는 순서를 보장하기 위해 기존에 진행중이던 작업을 바로 중단한다. 그리고 여러 개의 값이 발행되었을 때 마지막에 들어온 값만 처리하고 싶을 때 사용한다. 중간에 끊기더라도 마지막 데이터의 처리는 보장하기 때문이다. 마블 다이어그램이 조금 복잡하지만, 시간이 겹치지 않는다는 것을 유의하면 된다. 빨간색 도형의 경우 정상적으로 처리했지만, 초록색 도형을 처리하는 도중에 파란색 도형이 들어왔으므로 초록색 도형의 처리는 중단하고 파란색으로 도형을 처리한다. switchMap() 함수는 센서 등의 값을 얻어와서 동적으로 처리하는 경우에 매우 유용하다. 센서 값을 중간값보다는 최종적인 값으로 결과를 처리하는 경우가 많기 때문이다. 이럴 때는 flatMap() 함수로 매번 새로운 결과가 나왔는지 검사하지 말고 손쉽게 switchMap() 함수를 사용하자. 3. groupBy() 어떤 기준(KeySelector 인자)으로 단일 Observable을 여러 개로 이루어진 Observable 그룹(GroupedObservable)으로 만든다. 123456789101112public static void main(String[] args)&#123; String[] objs = &#123;PUPPLE, SKY, triangle(YELLOW), YELLOW, triangle(PUPPLE), triangle(SKY)&#125;; Observable&lt;GroupedObservable&lt;String, String&gt;&gt; source = Observable.fromArray(objs) .groupBy(Shape::getShape); source.subscribe(obj -&gt; &#123; obj.subscribe(val -&gt; System.out.println(\"GROUP:\" + obj.getKey() + \"\\t Value:\" + val)); &#125;); CommonUtils.exampleComplete();&#125; 원래 코틀린으로 해결하려고 했는데, 어떻게 짜야될지 몰라서 자바로 진행해본다. 코드가 조금 복잡하다. GroupedObservable 클래스는 Observable과 동일하지만 getKey() 메소드를 제공하여 구분된 그룹을 알 수 있게 해준다. source는 objs[] 배열에서 입력 데이터를 가져온다. 그룹을 구별하기 위해서 Shape.getShape() 함수를 사용한다. getShape() 함수의 내용은 다음과 같다. 1234567891011public static String getShape(String obj) &#123; if (obj == null || obj.equals(\"\")) return NO_SHAPE; if (obj.endsWith(\"-H\")) return HEXAGON; if (obj.endsWith(\"-O\")) return OCTAGON; if (obj.endsWith(\"-R\")) return RECTANGLE; if (obj.endsWith(\"-T\")) return TRIANGLE; if (obj.endsWith(\"&lt;&gt;\")) return DIAMOND; if (obj.endsWith(\"-P\")) return PENTAGON; if (obj.endsWith(\"-S\")) return STAR; return \"BALL\";&#125; source.subscribe()에 전달하는 obj는 GroupedObservable 객체이다. 그룹별로 1개씩 생성되므로 생성된 obj 별로 다시 subscribe() 함수를 호출해야 한다. val은 그룹 안에서 각 Observable이 발행한 데이터를 의미한다.(즉, GroupedObservable이 발행한 데이터 ex. “BALL - 6”) 만약, 모든 그룹을 처리하고 싶은게 아니라 특정 그룹만 처리하고 싶다면 filter() 함수를 이용해 조건을 추가해주면 된다. getKey() : 메소드는 그룹의 구분자 값을 리턴한다.(즉, Key 값) map(), flatMap(), groupBy() 비교 map() : 함수는 1개의 데이터를 다른 값이나 타입으로 변환해준다. flatMap() : 함수는 1개의 값을 받아서 여러 개의 데이터(Observable)로 확장해준다. groupBy() : 함수는 값들을 받아서 어떤 기준에 맞는 새로운 Observable 다수를 생성한다. 4. scan() reduce() 함수와 비슷하다. reduce() : Observable에서 모든 데이터가 입력된 후 그것을 종합하여 마지막 1개의 데이터만을 구독자에게 발행한다. 반면, scan() 함수는 실행할 때마다 입력값에 맞는 중간 결과 및 최종 결과를 구독자에게 발행한다. 12345678910private fun executeScan()&#123; val source = Observable.just(\"1\", \"3\", \"5\") .scan &#123; ball1: String, ball2: String -&gt; \"$ball2 ($ball1)\" &#125; source.subscribe(Log::i)&#125;// 결과main | value = 1main | value = 3 (1)main | value = 5 (3 (1)) reduce()와 다른점이 있다. 첫 번째는 source의 타입이 Maybe이 아니라 Observable이라는 것이다. reduce() 함수의 경우 마지막 값이 입력되지 않거나 onComplete 이벤트가 발생하지 않으면 구독자에게 값을 발행하지 않는다. 최악의 경우에는 값을 전혀 발해아지 않고 종료할 수도 있기 때문에 Maybe 클래스 타입으로 정의했다. 반면, scan() 함수는 값이 입력될 때마다 구독자에게 값을 발행한다. 따라서 Maybe가 아니라 Observable이다. 그리고 출력된 결과를 확인하면 main 스레드에서 실행되며 값이 입력될 때마다 발행하는 것을 확인할 수 있다.","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"연산자 활용","slug":"연산자-활용","permalink":"https://woovictory.github.io/tags/연산자-활용/"}]},{"title":"[Android] Glide 삽질 과정","slug":"Android-Glide","date":"2019-06-05T07:28:28.000Z","updated":"2020-03-01T10:24:50.365Z","comments":true,"path":"2019/06/05/Android-Glide/","link":"","permalink":"https://woovictory.github.io/2019/06/05/Android-Glide/","excerpt":"","text":"안드로이드 앱에서 이미지를 보여주는 화면이 많다. 서버로부터 받은 url 이미지를 보여줘야 할 때도 있고, local에 저장해뒀다가 보여줘야 하는 경우도 있다. 오늘 이야기할 내용은 Glide를 사용해서 SVG 이미지를 화면에 보여주는 과정에서 내가 겪은 삽집을 풀도록 하겠다. 먼저, SVG 이미지가 무엇인지 알아보자. SVG VS PNG SVG는 Scalable Vector Graphics의 약자이다. JPEG, PNG처럼 그래픽 포맷 중 하나이다. SVG는 벡터 기반으로 리사이징이 되어도 깨지지 않는다는 장점을 가지고 있다. 즉, 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다. 장점 특정 사이즈에 구애받지 않는다. 즉, 위에서 언급했듯이 어느 해상도에서든 pixelate 되지 않는다. SVG는 어떤 사이즈로든 그 모습 그대로 유지된다. 그렇기 때문에 사이즈별로 아이콘을 모두 생성해서 개발자에게 넘겨줄 필요가 없다. SVG 파일 하나로 모든 해상도를 대응할 수 있다. 작은 파일 사이즈 비트맵 이미지(PNG, JPEG) 같은 경우 파일 크기를 결정하는 주요 요소는 해상도이다. 예를 들어 5000x5000 픽셀 이미지는 항상 500x500보다 파일 사이즈가 크다. 반면, SVG 그래픽 같은 경우 파일의 크기를 결정하는 주요 요소는 바로 복잡도이다. Path가 비교적 적은 간단한 이미지는 PNG, JPEG 보다 파일 사이즈가 적을 수도 있지만 이미지를 구성하는 요소의 복잡도(레이어가 많다든지 특정 효과가 많다드지)에 따라서 파일 사이즈가 커진다. 하지만, 이런 용량 문제는 SVG Optimizing이라는 것을 하게 되면 어느 정도 해결이 된다. 작은 파일 사이즈로 인해 로딩 시간도 줄어든다는 장점 또한 있다. Bitmap과 SVG 구성요소 비트맵 그래픽 : Raster Graphics(픽셀 기반) 대표적인 포맷은 JPEG, PNG이다. 이들은 픽셀로 구성되어 있다. 예를 들어, 2x2 픽셀인 비트맵 이미지는 총 4px로 구성되어 있다. 개개인에 대한 픽셀들은 자유자재로 바꿀 수가 없고 움직일 수도 없다. 그렇기 때문에 100% 이상으로 이미지를 확대하면 Pixelate가 된다. SVG 그래픽 : 벡터 기반 픽셀로 구성되어 있지 않고 작업하고 있는 그래픽에 대한 정보로 구성되어 있다. 그렇기 때문에 어떤 사이즈로든 자유자재로 늘어나는 것이 가능하다. 이러한 이유로 인해 코드로 쉽게 적용된 스타일을 수정할 수 있다. 예를 들어 동그라미의 보더 값을 6에서 8로 바꾼다던지 색상을 그레이에서 블랙으로 바꾼다던지 또는 사이즈를 변경한다던지 등이다. 위와 같은 장점이 있기 때문에 현재 진행하고 있는 프로젝트에서 PNG보다는 SVG를 채택해서 사용하려고 노력 중이다. 디자이너가 주는 이미지는 일러스트로 그리거나 어떤 작업을 거친 후에 주는 것이 많다. 이러한 이미지들은 대부분 용량이 크다. 용량이 큰 이미지를 내가 사용하는 imageView에 그냥 세팅을 해서 보여준다면 OOM(Out Of Memory)를 겪게 될 것이다. 이미지의 용량이 커서 사용하고 있는 메모리에 로드할 수 없기 때문이다. 이 문제를 해결하는 방법은 여러 가지가 있는데, 그 중에 나는 편리하게 처리하기 위해서 Glide 라이브러리르 사용했다. 이미지 로드를 하기 위한 라이브러리는 이외에도 Picasso, Fresco 등이 있다. 나는 이 중 Glide가 사용 경험도 있고 편해서 선택을 했다. 이미지 로딩 라이브러리 중 Picasso와 Glide 비교에 관한 글이다. [안드로이드] Image Loading Library Glide 이미지 로딩 라이브러리 중 하나로써 Glide는 많은 개발자들이 사용한다. 이유는 사용법이 간편하고 다양한 기능을 지원하기 때문이다. 기본 사용법은 다음과 같다. 12345fun setImageBackground()&#123; Glide.with(context) .load(R.drawable.image_error) .into(imageView)&#125; 이제 내가 원하는 svg 이미지를 glide를 통해 적용해보려고 한다. 나는 png나 svg나 어차피 이미지이기 때문에 똑같은 방식으로 적용하면 될 것이라고 생각했다. 인생은 쉽지 않다. 쉽게 될 것이라고 생각했던 것은 큰 오산이었다… 그래서 구글의 힘을 빌려보기로 했다. android glide load svg로 검색한 결과 다음과 같이 스택 오버플로우에 많은 질문이 있는 것을 알 수 있었다. 역시 쉬운 것은 없다. 열심히 구글링을 하던 중 괜찮아 보이는 방법을 찾았다. 라이브러리 사용 GlideToVectorYou 라는 라이브러리이며 SVG 이미지를 쉽게 로드할 수 있다. 구현부분을 자세히 보면 구글의 샘플 코드를 확인할 수 있다. 단점 : with() 함수의 인자로 activity 밖에 넘기지 못한다. 구글의 샘플 코드 사용(구 버전) 스택 오버플로우의 답변 내용을 보면 구글의 샘플 코드를 확인하라는 말을 자주 볼 수 있다. 그래서 링크를 타고 들어가봤는데, 대략 4년 전에 사용되었던 방식이 있다. 단점 : 구 버전이므로 현재 버전에서는 Deprecated된 함수들이 대부분이다. 구글의 샘플 코드 사용(최신 버전) 구 버전 뿐 아니라 최신 버전에 맞게 사용할 수 있는 샘플 코드를 제공하고 있다. SVG Sample 자, ‘이런게 삽질이라고?’ 라고 생각하시는 분들이 있을 수 있다. 하지만, 내가 겪은 과정은 삽질이라고 표현할 수 있다. 이유는 처음에 SVG 이미지를 그냥 로드할 수 없다는 걸 알게되었다는 점과 이를 로드하기 위해서 어떤 방식이 있는지 찾아보는 과정, 그리고 실제로 동작하는지 확인해보기 위해서 많은 시간을 들였다. 구글의 샘플 코드를 보고 가장 먼저 의문이 드는 것은 GlideApp이다. 이게 뭘까? 직접 쳐봐도 뜨지도 않는다. 그럼 구글은 이 뜨지도 않는걸로 어떻게 해결한 것일까?? 해결 방법은 의외로 간단하다. build.gradle(Module:app)에 아래와 같은 의존성을 추가하면 된다. 12345// glideimplementation 'com.github.bumptech.glide:glide:4.8.0'implementation 'com.github.bumptech.glide:annotations:4.8.0'annotationProcessor 'com.github.bumptech.glide:compiler:4.8.0'kapt 'com.github.bumptech.glide:compiler:4.8.0' 버전은 4.8.0으로 했다. 최신 버전으로 했었는데, 변경하는 과정에서 Crash가 발생해서 4.8.0으로 하는 것이니 사용할 때는 최신 버전으로 해도 무방할 것 같다. 그리고 Clean Project -&gt; Rebuild Project 를 하면 GlideApp이 생기는 걸 확인할 수 있다. 다음에 AppGlideModule을 상속받는 MyAppGlideModule 클래스를 생성하면 된다. 12345678910111213@GlideModuleclass MyGlideModule : AppGlideModule() &#123; override fun registerComponents(context: Context, glide: Glide, registry: Registry) &#123; registry .register(SVG::class.java, PictureDrawable::class.java, SvgDrawableTranscoder()) .append(InputStream::class.java, SVG::class.java, SvgDecoder()) &#125; override fun isManifestParsingEnabled(): Boolean &#123; return false &#125;&#125; SVG 클래스를 위해서 아래와 같은 의존성을 하나 더 추가해줘야 한다. 1implementation 'com.caverock:androidsvg:1.2.1' 그리고 여기서 사용되는 클래스들은 다음과 같다. SvgDecoder SvgDrawableTranscoder SvgSoftwareLayerSetter 1.SvgDecoder link를 통해서 읽은 inputStream을 SVG 내부 표현으로 디코딩을 한다는 의미이다. 정확하지는 않지만 link 즉, url을 통해 읽어들인 다음 inputStream에 담고 이를 통해 SVG로 만든다. 만들 때는 androidsvg 라이브러리를 사용한다. 2. SvgDrawableTranscoder 1번에서 만든 SVG를 안드로이드에서 사용할 수 있는 PictureDrawable로 변환한다. 이는 Drawable 클래스를 상속받고 있기 때문에 이렇게 변환된 데이터를 안드로이드에서 사용할 수 있다. 3. SvgSoftwareLayerSetter 3번은 필수가 아닌 선택이다. 하지만, 필수적으로 사용해야 될 것 같다. 왜냐하면 리스너를 구현한 것이기 때문에 이를 통해서 내가 로드하려는 이미지가 성공적으로 로드되었는지, 실패했는지를 확인할 수 있다. 이를 통해서 내가 로드하려는 SVG 이미지가 성공적으로 로드되었는지, 로드되지 않고 실패했다면 어떤 원인인지 파악할 수 있어 디버깅하는데 더 수월하다. 여기까지 내가 삽질했던 과정을 설명했다. 사용되는 클래스에 대한 정확한 파악은 하지 못했지만, 어떻게 동작하는지는 이해가 되었다. 나의 이해를 바탕으로 작성한 글이기 때문에 사실과 다른 부분도 존재할 것이다. 이 부분에 대한 이견이 있다면 알려주시면 감사할 것 같다. 참고 왜 SVG로 갈아탔는가?","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Glide","slug":"Glide","permalink":"https://woovictory.github.io/tags/Glide/"},{"name":"svg image","slug":"svg-image","permalink":"https://woovictory.github.io/tags/svg-image/"}]},{"title":"[RxJava] Chap04","slug":"RxJava-Chap04","date":"2019-06-03T08:59:09.000Z","updated":"2020-05-26T07:06:53.509Z","comments":true,"path":"2019/06/03/RxJava-Chap04/","link":"","permalink":"https://woovictory.github.io/2019/06/03/RxJava-Chap04/","excerpt":"","text":"해당 글은 직접 책을 구매하여 공부의 목적으로 정리하는 글임을 알려드립니다. 이번에는 리액티브 연산자를 카테고리별로 알아보도록 하겠다. 이유는 연산자의 종류가 많기도 하고 카테고리로 쓰임새를 어느 정도 짐작할 수 있기 때문이다. 생성 연산자는 Observable로 데이터 흐름을 만들고 변환 연산자와 필터 연산자는 데이터 흐름을 내가 원하는 방식으로 변형한다. 결합 연산자는 1개의 Observable이 아니라 여러 개의 Observable을 조합할 수 있도록 해준다. 생성 연산자 생성 연산자의 역할은 데이터 흐름을 만드는 것이다. Observable(Observable, Single, Maybe 객체 등)을 만든다고 생각하면 된다. 앞선 챕터에서는 just(), fromXXX(), create() 함수 등을 봤고, 이번에는 다른 연산자들을 확인해보도록 하겠다. 1. interval() 일정 시간 간격으로 데이터 흐름을 생성한다. 주어진 시간 간격으로 0부터 1씩 증가하는 Long 객체를 발행한다. 두 가지의 함수 원형을 가지고 있으며, 최초 지연 시간을 조절하는 함수와 그렇지 않은 함수가 존재한다. period(일정 시간)동안 쉬었다가 데이터를 발행한다. 기본적으로 영원히 지속되기 때문에 폴링 용도로 많이 사용한다. 함수의 동작이 현재 스레드가 아닌 계산을 위한 별도의 스케줄러(스레드)에서 동작한다. 1234// 함수 원형@SchedulerSupport(SchedulerSupport.COMPUTATION)public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit) 123456789101112131415161718192021222324252627282930private fun executeInterval() &#123; /* * 시작 시간을 표시하는 유틸리티 메소드이다. * RxJava - 비동기 프로그래밍이기 때문에 시간에 대한 이해가 중요하다. * 시작 시간을 기준으로 RxJava 각 함수의 실행 시간을 측정하기 위함이다. * sleep()을 호출하는 이유는 다른 스레드에서 실행이 완료될 때까지 기다려야 하기 때문이다. * 해당 문장을 주석 처리하게 되면 기다리지 않고 바로 프로그램이 종료되는 것을 확인할 수 있다. * 이유는 메인 스레드에서 할 일이 없기 때문이다. * * */ CommonUtils.exampleStart() val source = Observable.interval(100L, TimeUnit.MILLISECONDS) .map &#123; data -&gt; (data + 1) * 100 &#125; .take(5) source.subscribe(Log::it) CommonUtils.sleep(TIME) CommonUtils.exampleComplete()&#125;// 결과RxComputationThreadPool-1 | 247 | value = 100RxComputationThreadPool-1 | 347 | value = 200RxComputationThreadPool-1 | 445 | value = 300RxComputationThreadPool-1 | 545 | value = 400RxComputationThreadPool-1 | 645 | value = 500----------------------- 2. timer() interval() 함수와 유사하지만 time() 함수는 한 번만 실행되는 함수이다. 일정 시간이 지난 후 한 개의 데이터를 발행하고 onComplete() 이벤트가 발생한다. 전반적으로 interval() 함수와 유사하다. 계산 스케줄러에서 실행되며 함수의 발행되는 데이터도 interval() 함수의 첫 번째 값인 0L이다. 보통 일정 시간이 지난 후 어떤 동작을 실행할 때 활용한다. 우리가 사용하는 타이머를 맞춘다고 생각하면 된다. 1234567891011121314151617181920private fun executeTimer() &#123; CommonUtils.exampleStart() val source = Observable.timer(500L, TimeUnit.MILLISECONDS) .map &#123; notUsed -&gt; SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\") .format(Date()) &#125; source.subscribe(Log::it) CommonUtils.sleep(1000) CommonUtils.exampleComplete() /* * timer() 함수도 메인 스케줄러가 아닌 계산 스케줄러에서 실행되기 때문에 * 계산 스케줄러가 완료될 때까지 기다리기 위해서 sleep() 함수를 호출하여 준다. * 즉, 계산 스케줄러의 동작이 완료될 때까지 메인 스케줄러가 기다리는 것이다. * 그렇지 않으면 메인 스케줄러에서 할 일이 없기 때문에 프로그램이 바료 종료된다. * */&#125;// 결과RxComputationThreadPool-1 | 708 | value = 2019/06/03 21:26:26----------------------- 3. range() 주어진 값(n)부터 m개의 Integer 객체를 발행한다. interval(), timer() 함수는 Long 객체를 발행했지만, range() 함수는 Integer 객체를 발행한다. 특정한 스케줄러에서 실행되지 않는다. 즉, 현재 스레드에서 실행한다. 반복문(for, while문)을 대체할 수 있다. 123456789101112131415161718/** range() 함수로 1부터 10까지 숫자를 생성한다.* 그리고 filter() 함수를 이용해 짝수만 걸러낸다.* 현재 쓰레드에서 실행된다.* */private fun executeRange() &#123; Observable.range(1, 10) .filter &#123; num -&gt; num % 2 == 0 &#125; .subscribe(Log::i)&#125;// 결과main | value = 2main | value = 4main | value = 6main | value = 8main | value = 10 4. intervaleRange() interval()과 range() 함수를 혼합해놓은 함수이다. interval() 함수처럼 일정한 시간 간격으로 값을 출력하지만, range() 함수처럼 시작 숫자(n)로부터 m개만큼의 값만 생성하고 onComplete 이벤트가 발생한다. interval() 함수처럼 무한히 데이터 흐름을 발행하지 않는다. 반환 타입은 Long 타입이다. 계산 스케줄러에서 실행된다. 사실 intervalRange() 함수는 interval() 함수와 다른 함수를 조합해서 만들 수 있다. 이유는 intervalRange() 함수가 직관적이지 않기 때문이다. 123456789101112131415161718/** main 스레드에서 실행되는 것이 아니기 때문에 sleep() 함수를 호출한다.* */private fun executeIntervalRange() &#123; Observable.intervalRange(1, 5, 100L, 100L, TimeUnit.MILLISECONDS) .subscribe(Log::i) CommonUtils.sleep(1000)&#125;// 결과RxComputationThreadPool-1 | value = 1RxComputationThreadPool-1 | value = 2RxComputationThreadPool-1 | value = 3RxComputationThreadPool-1 | value = 4RxComputationThreadPool-1 | value = 5 interval() 함수 -&gt; intervalRange() 함수 만들기 interval() 함수 사용 map() 함수 사용 take() 함수 사용 123456789private fun executeIntervalRangeUsingIntervalAndMapAndTake() &#123; Observable.interval(100L, TimeUnit.MILLISECONDS) .map &#123; data -&gt; data + 1 &#125; .take(5) .subscribe(Log::i) CommonUtils.sleep(1000)&#125; 5. defer() 데이터 흐름 생성을 구독자가 subscribe() 함수를 호출할 때까지 미룰 수 있다. 이때 새로운 Observable이 생성된다. Observable의 생성이 구독할 때까지 미뤄지기 때문에 최신 데이터를 얻을 수 있다. 현재 스레드에서 실행되며, 인자로는 Callable&lt;Observable&gt;를 받는다. Callable 객체이므로 구독자가 subscribe()를 호출할 때까지 call() 메소드의 호출을 미룰 수 있다. defer() 함수는 구독자가 구독할 때까지 Observable의 데이터 발행을 미루는 역할을 한다. 따라서 구독자가 subscribe()를 호출하는 시점에 최신의 데이터를 받을 수 있다. defer() 함수를 사용하지 않은 상황에서 구독자 두명이 그대로 구독을 하게 되면 같은 5에 대한 데이터를 발행하고 구독자가 받게 된다. 개념이 조금 어렵다;; 천천히 다시 볼 필요가 있다. 여기에서 다룬 Observable은 모두 차가운 Observable이다. Observable을 생성할 때 입력값이 결정되고 구독자가 subscribe() 함수를 호출하면 그때 해당 데이터 흐름을 그대로 발행한다. 즉, defer() 함수를 활용하면 subscribe() 함수를 호출할 때의 상황을 반영하여 데이터 흐름의 생성을 지연하는 효과를 보여준다. 내부적으로 구독자가 subscribe() 함수를 호출하면 그때 supplier의 call() 메소드를 호출한다. 6. repeat() 단순히 반복 실행을 하는 함수이다. 서버와 통신을 할 때 해당 서버가 살아있는지 확인(이 확인 과정을 보통 ping 혹은 heart beat라고 한다.)하는 코드를 작성할 때 주로 사용한다. 인자를 입력하지 않으면 영원히 실행된다. 따라서 반복하길 원하는 숫자만큼 인자로 전달하는게 좋다. 예제로 heart beat를 간단하게 구현해보기 서버와 연동하는 앱을 작성하다 보면 통신하는 서버가 동작하는지 확인하는 코드가 필요하다. 지속적인 통신을 해야 하는 서버의 경우 명세서에 동작 확인 코드를 작성할 것을 명시하기도 한다. 보통 일정 시간 안데 heart beat 패킷을 보내지 않으면 서버는 클라이언트와의 연결이 종료된 것으로 판단하고 연결을 해제한다. (보통 30초 간격으로 heart beat 신호를 보낸다.) 이럴 때 repeat() 함수를 활용하면 heart beat 패킷을 보내는 프로그램을 간단하게 구현할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354fun main(args: Array&lt;String&gt;)&#123; CommonUtils.exampleStart() val serverUrl: String = \"https://api.github.com/zen\" Observable.timer(2, TimeUnit.SECONDS) .map &#123; it -&gt; serverUrl &#125; .map(OkHttpHelper::get) .repeat() .subscribe(&#123; Log.it(\"Ping result: $it\") &#125;, &#123; Log.it(\"Ping result fail: $&#123;it.message&#125;\") &#125;) CommonUtils.sleep(1000)&#125;// 아래는 OkHttpHelper 클래스이다.public class OkHttpHelper &#123; private static OkHttpClient client = new OkHttpClient(); public static String ERROR = \"ERROR\"; public static String get(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); try &#123; Response res = client.newCall(request).execute(); return res.body().string(); &#125; catch (IOException e) &#123; Log.e(e.getMessage()); throw e; &#125; &#125; public static String getT(String url) throws IOException &#123; Request request = new Request.Builder() .url(url) .build(); try &#123; Response res = client.newCall(request).execute(); return res.body().string(); &#125; catch (IOException e) &#123; Log.et(e.getMessage()); throw e; &#125; &#125; public static String getWithLog(String url) throws IOException &#123; Log.d(\"OkHttp call URL = \" + url); return get(url); &#125;&#125; timer() 함수를 사용해 2초마다 반복 실행되도록 했다. 약 2초 간격으로 실행된다. 원래 timer() 함수는 한 번 호출된 후에는 종료된다. 그런데 계속 반복해서 실행되는 것을 볼 수 있다. 이유는 repeat() 함수 때문이다. repeat() 함수는 동작이 한 번 끝난 다음에 다시 구독하는 방식으로 동작한다. 그리고 다시 구독할 때마다 동작하는 스레드의 번호가 달라진다. 만약 동작하는 스레드를 동일하게 맞추고 싶다면 timer()와 repeat() 함수를 빼고 interval() 함수를 대신 넣어 호출하면 된다.","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"연산자 활용","slug":"연산자-활용","permalink":"https://woovictory.github.io/tags/연산자-활용/"}]},{"title":"[커니의 Kotlin] Chap3","slug":"kotlin-chap3","date":"2019-05-28T12:52:08.000Z","updated":"2020-05-12T15:19:11.798Z","comments":true,"path":"2019/05/28/kotlin-chap3/","link":"","permalink":"https://woovictory.github.io/2019/05/28/kotlin-chap3/","excerpt":"","text":"해당 글은 커니의 코틀린 책을 구매하여 공부하고 작성한 글입니다. 조건 확인 함수 특정 값의 일치 여부 확인 check() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalStateException 예외를 발생시킨다. require() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalArgumentException 예외를 발생시킨다. check(), require() 함수 모두 값을 확인하는 형태뿐만 아니라 조건이 일치하지 않았을 경우 수행할 작업을 함께 지정할 수 있는 형태의 함수를 지원한다. 1234567fun showMessage(isPrepared: Boolean, message: String)&#123; // isPrepared가 true가 아니면 IllegalStateException 발생. check(isPrepared) // message의 길이가 10 이상이 아니면 IllegalArgumentException 발생. require(message.length&gt;10)&#125; checkNotNull(), requireNotNull() 함수를 사용해 특정 값의 널 여부를 확인하고 널이 아닌 값을 반환받을 수 있다. 이도 위의 함수처럼 단순히 값을 확인만 하는 형태와 함께 실행할 함수를 지정하는 형태를 지원한다. 123456fun showMessage(message: String)&#123; // message 값이 널이 아닐 때에만 해당 변수에 값이 할당된다. val msg = requireNotNull(message) println(message)&#125; 명시적으로 실행 중단하기 프로그램이 실행될 때, 호출될 가능성이 없는 영역이 있다. 하지만, 예기치 못한 이유로 이 영역이 실행되면 프로그램에 부작용이 발생하게 된다. 따라서 이 같은 영역에 진입하게 되는 경우 임의로 예외를 발생시킬 수 있다. error() 함수를 이용하면 된다. 123456789fun showMessage(isPrepared: Boolean, message: String)&#123; // isPrepared가 fals일 경우 // IllegalArgumentException: Not prepared yet! 예외가 발생한다. if(!isPrepared)&#123; error(\"Not prepared yet!\") &#125; println(message)&#125; 다른 부분의 작업이 완료되어야 구현이 가능할 때, 보통 주석을 달아서 추가 작업이 필요하다고 표시하는 경우가 대부분이다. 하지만, 간혹 이런 주석을 확인하지 못하고 그냥 두면 버그가 발생하기도 한다. 이 문제를 해결하기 위해 코틀린에서는 TODO() 함수를 제공한다. 이를 통해서 NotImplementedError를 발생시켜 아직 이 부분이 완성되지 않았음을 알려준다. 123456789class Car&#123; ... // 내부 구현이 아직 완료되지 않음. // 이 함수 호출 시 NotImplementedError가 발생. fun stop()&#123; TODO(\"Stop is not implemented\") &#125;&#125; 컬렉션 생성 함수 1. 배열 특정 원소를 담고 있는 배열을 생성하기 위해서 arrayOf() 함수를 사용한다. 빈 배열을 생성하고 싶은 경우 emptyArray() 함수를 사용한다. 널 값을 포함할 수 있는 배열을 생성하고 싶은 경우, arrayOfNulls() 함수를 사용한다. 12345678910// 문자열을 포함하는 배열을 생성한다. 인자를 통해 타입 추론이 가능하다.val cities = arrayOf(\"Seoul\", \"Tokyo\")// String 타입의 빈 배열을 생성한다. // 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.val emptyStringArray = emptyArray&lt;String&gt;()// size가 3이고 널 값을 포함할 수 있는 배열을 생성한다.// 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.val nullOfArray = arrayOfNulls&lt;String&gt;(3) 자바의 원시 타입을 포함하는 배열은 코틀린의 배열과 다른 타입으로 취급되므로, 위의 함수가 아닌 각 타입에 맞는 함수를 사용해야 한다. 아래에서 소개하는 것은 자바의 원시 타입을 포함하는 배열을 생성하는 함수들이다. booleanArrayOf() : BooleanArray 를 반환하며 자바의 boolean[] 배열과 호환된다. byteArrayOf() charArrayOf() doubleArrayOf() floatArrayOf() intArrayOf() longArrayOf() shortArrayOf() 결국 동일하기 때문에 나머지는 설명을 생략했다. 2. 리스트 listOf() : 포함하는 요소를 읽을 수만 있고 수정할 수 없는 읽기 전용 리스트를 생성할 수 있다. 다른 말로 immutable 하다고 한다. listOfNotNull() : 널 값은 무시하고 널이 아닌 값으로만 리스트를 구성할 수 있다. 인자로 전달된 모든 값이 널이라면 빈 리스트를 반환한다. 12345// 인자가 null 값이므로 빈 리스트를 반환한다.val countries = listOfNotNull(null)// 널 값인 인자는 무시하므로 Seoul, Tokyo만을 요소로 갖는 리스트가 생성된다.val citiest = listOfNotNull(\"Seoul\", null, \"Tokyo\", null) 리스트에 포함된 요소를 수정할 수 있는 리스트는 mutableListOf() 함수를 사용하여 생성한다. 함수의 정의는 아래와 같다. fun mutableListOf(vararg elements: T): MutableList 인자로 받은 elements를 요소로 가지며 수정 가능한 리스트를 반환한다. fun mutableListOf(): MutableList 비어있는 수정 가능한 리스트를 반환한다. 또한, 자주 사용되는 ArrayList도 arrayListOf() 함수를 사용해 쉽게 생성할 수 있다. 이외에도 Map, Set(집합) 자료구조도 List와 비슷한 함수를 가지고 있다. 읽기만 가능한 함수와 수정도 가능한 함수까지 이름만 다르고 동일한 형태를 취하기 때문에 설명은 생략하도록 하겠다. Map : Key, value 형태를 갖는다. Set : 중복을 허용하지 않는 집합이며 순서가 없다. 스트림 함수 자바8 에서는 리스트나 맵과 같은 컬렉션에 포함된 자료를 쉽게 다룰 수 있도록 스트림 기능을 제공한다. 코틀린에서는 스트림 대신 유사한 역할을 하는 함수들을 표준 라이브러리에서 제공하며, 확장 함수 형태로 제공된다. 자바8의 스트림 기능을 사용하지 않지만, 편의상 스트림 함수라 칭하도록 하겠다. 변환 map() : 함수는 컬렉션 내 인자를 다른 값이나 타입으로 변환할 때 사용한다. mapIndexed() : 함수는 컬렉션 내 포함된 인자의 인덱스 값을 변환 함수 내에서 사용할 수 있다. mapNotNull() : 함수는 컬렉션 내 인자를 변환함과 동시에, 변환한 값이 널 값인 경우 이를 무시한다. flatMap() : 함수는 map() 함수와 달리 반환형이 Iterable이다. 따라서 하나의 인자에서 여러 개의 인자로 매핑이 필요한 경우에 사용한다. groupBy() : 함수는 컬렉션 내 인자들을 지정한 기준에 따라 분류하며, 각 인자들의 리스트를 포함하는 맵 형태로 결과를 반환한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Russia\", \"Tokyo\") // 도시 이름을 대문자로 변환. cities.map &#123; it -&gt; it.toUpperCase() &#125;.forEach &#123; println(it) &#125; // 도시의 이름을 받아서 길이로 변환. cities.map &#123; it -&gt; it.length &#125;.forEach &#123; println(\"length = $it\") &#125; // mapIndexed cities.mapIndexed &#123; index, s -&gt; \"$index 번째 도시 = $s\" &#125;.forEach &#123; println(it) &#125; // mapNotNull 길이가 5이하인 도시만 반환. // 아니면 null 반환해서 무시됨. cities.mapNotNull &#123; it -&gt; if (it.length &lt;= 5) it else null &#125;.forEach &#123; println(it) &#125; // flatMap // flatMap 에서 각 인자를 끝으로 하는 새로운 범위를 반환하였으므로, // 이 범위에 해당하는 정수들이 새롭게 스트림에 추가된다. val numbers = 1..6 numbers.flatMap &#123; number -&gt; 1..number &#125;.forEach &#123; print(\"$it\") &#125; println() // groupBy cities.groupBy &#123; city -&gt; if (city.length &lt;= 5) \"A\" else \"B\" &#125;.forEach &#123; key, cities -&gt; println(\"key= $key, cities= $cities\") &#125;&#125; 내 생각에 자주 사용할 함수들은 map(), flatMap() 이라고 생각한다. 까먹더라도 이 두 함수는 꼭 기억하자! 필터 filter() : 컬렉션 내 인자들 중 주어진 조건과 일치하는 인자만 걸러주는 역할 take() : 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다. takeLast() : take() 함수와 반대로 뒤에서부터 이 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다. takeWhile() : 첫 번째 인자부터 시작하여 주어진 조건을 만족하는 인자까지를 포함하는 리스트를 반환한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Chap04/** * created by victory_woo on 28/05/2019 * */fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"NewYork\", \"Singapore\", \"Mountain View\",\"spain\") // 1. filter cities.filter &#123; city -&gt; city.length &lt;= 5 &#125;.forEach &#123; println(it) &#125; println() // 2. take cities.take(1) .forEach &#123; println(it) &#125; println() // 3. takeLast cities.takeLast(3) .forEach &#123; println(it) &#125; println() // 4. takeWhile // spain도 문자열의 길이가 5이하지만, NewYork이 조건을 만족하지 않으므로 // 이후의 인자들을 모두 무시한다. cities.takeWhile &#123; city -&gt; city.length &lt;= 5 &#125;.forEach &#123; println(it) &#125; println() // takeLastWhile // 리스트의 뒤에서부터 접근한다. 컬렉션 내 항목의 순서는 유지된다. cities.takeLastWhile &#123; city -&gt; city.length &lt; 13 &#125;.forEach &#123; println(it) &#125;&#125;// 결과// filterSeoulTokyospain// takeSeoul// takeLastSingaporeMountain Viewspain// takeWhileSeoulTokyo// takeLastWhilespain drop() 함수라는 것이 존재하는데, 이는 take() 함수의 반대 역할을 한다. 조건을 만족하는 항목을 컬렉션에서 제외한 결과를 반환한다. take() 함수와 유사하게 dropLast(), dropWhile(), dropLastWhile() 함수를 지원한다. 사용 예제는 책을 참고하길 바란다. 다른 종류의 함수 first() : 컬렉션 내 첫 번째 인자를 반환한다. 뿐만 아니라 조건을 만족하는 첫번째 인자를 반환할 수도 있다. 조건을 만족하는 인자가 없는 경우 NoSuchElementException 예외를 발생시킨다. firstOrNull() : 예외 대신 널 값을 반환하도록 할 수 있다. last() : 함수는 first() 함수와 반대 역할을 한다. lastOfNull() : 함수도 지원한다. 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"NewYork\", \"Singapore\", \"Mountain View\", \"spain\") // 첫 번째와 마지막 인자를 반환한다. println(\"first: $&#123;cities.first()&#125;\") println(\"last: $&#123;cities.last()&#125;\") // 조건에 맞는 첫 번째, 마지막 인자를 반환한다. println(\"first 조건: $&#123;cities.first &#123; city -&gt; city.length &gt; 5 &#125;&#125;\") println(\"first 조건: $&#123;cities.last &#123; city -&gt; city.length &gt; 5 &#125;&#125;\") // 없을 경우 예외가 아닌 널 값을 반환한다. // 비어있는 도시가 있으면 찾은 첫 번째 도시를 반환하지만, 없기 때문에 예외 대신 널을 반환한다. println(cities.firstOrNull &#123; city -&gt; city.isEmpty() &#125;) println(cities.lastOrNull &#123; city -&gt; city.isEmpty() &#125;)&#125; distinct() : 함수는 컬렉션 내 포함된 항목 중 중복된 항목을 걸러낸 결과를 반환한다. 이때 항목의 중복 여부는 equals()로 판단하며, distinctBy() 함수를 사용하면 비교에 사용할 키 값을 직접 설정할 수 있다. 12345678910111213141516171819202122232425262728293031fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"NewYork\", \"Singapore\", \"Mountain View\", \"Seoul\", \"Tokyo\") // 도시 목록 중 중복된 항목을 제거한다. cities.distinct() .forEach &#123; println(it) &#125; println() // 중복된 항목을 판단할 때, 도시 이름의 길이를 판단 기준으로 사용한다. // 즉, 문자열의 길이가 같은 경우 같은 항목으로 판단. cities.distinctBy &#123; city -&gt; city.length &#125;.forEach &#123; println(it) &#125;&#125;// 결과// distinctSeoulTokyoNewYorkSingaporeMountain View// distincBySeoulNewYorkSingaporeMountain View 조합 및 합계 zip() : 두 컬렉션 내의 자료들을 조합하여 새로운 자료를 만들 때 사용한다. 두 컬렉션 간 자료의 개수가 달라도 사용할 수 있으며, 이 경우에 반환되는 컬렉션의 자료 수는 조합에 사용하는 컬렉션 중 자료의 수가 더 적은 쪽을 따라간다. 기본값으로는 조합된 결과를 Pair로 만들어주며, 원하는 경우 조합 규칙을 사용자가 정의하여 사용할 수도 있다. 12345678910111213141516171819202122232425fun main(args: Array&lt;String&gt;) &#123; val cityCodes = listOf(\"SEO\", \"TOK\", \"MTV\", \"NYC\") val cityNames = listOf(\"Seoul\", \"Tokyo\", \"Mountain View\") // 단순히 zip 함수를 호출. cityCodes.zip(cityNames) .forEach &#123; pair -&gt; println(\"$&#123;pair.first&#125; : $&#123;pair.second&#125;\") &#125; println() // 조합할 자료의 타입을 zip 함수를 통해 지정하면 해당 형태로 바꿔준다. cityCodes.zip(cityNames) &#123; code, name -&gt; \"$code($name)\" &#125; .forEach &#123; println(it) &#125;&#125;// 결과SEO : SeoulTOK : TokyoMTV : Mountain ViewSEO(Seoul)TOK(Tokyo)MTV(Mountain View) joinToString() : 함수는 컬렉션 내 자료를 문자열 형태로 변환함과 동시에, 이를 조합하여 하나의 문자열로 생성한다. 이는 컬렉션 내 자료를 직렬화할 때 매우 유용하다. 인자 없이 함수를 호출하는 경우 기본 설정을 바탕으로 컬렉션 내 자료를 문자열로 변환하며, 몇 가지 인자를 함께 전달하면 자신이 원하는 형태로 출력 문자열을 구성할 수도 있다. count() : 함수는 컬렉션 내 포함된 자료의 개수를 반환하며, 별도의 조건식을 추가하면 해당 조건을 만족하는 자료의 개수를 반환하도록 할 수 있다. 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"Mountain View\", \"NYC\", \"Singapore\") println(\"기본 joinToString = $&#123;cities.joinToString()&#125;\") println(\"인자 포함 joinToString = $&#123;cities.joinToString(separator = \" | \")&#125;\") println(\"기본 count = $&#123;cities.count()&#125;\") println(\"인자 포함 count = $&#123;cities.count &#123; cities -&gt; cities.length &lt;= 5 &#125;&#125;\")&#125;// 결과기본 joinToString = Seoul, Tokyo, Mountain View, NYC, Singapore인자 포함 joinToString = Seoul | Tokyo | Mountain View | NYC | Singapore기본 count = 5인자 포함 count = 3 reduce() : 함수는 컬렉션 내 자료들을 모두 합쳐 하나의 값으로 만들어주는 역할을 한다. joinToString() 함수는 reduce() 함수의 일종이라고 볼 수 있다. 첫 번째 자료부터 조합을 시작하며, reduceRight() 함수는 동일한 작업을 컬렉션 내 마지막 자료부터 시작한다. 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"Mountain View\", \"NYC\", \"Singapore\") // acc 에는 지금까지 조합된 결과가, s 에는 새로 조합할 자료가 들어간다. println(\"reduce 결과 = $&#123;cities.reduce &#123; acc, s -&gt; \"$acc, $s\" &#125;&#125;\") // 마지막 인자부터 조합한다. println(\"reduceRight 결과 = $&#123;cities.reduceRight &#123; s, acc -&gt; \"$s, $acc\" &#125;&#125;\")&#125;// 결과reduce 결과 = Seoul, Tokyo, Mountain View, NYC, SingaporereduceRight 결과 = Singapore, NYC, Mountain View, Tokyo, Seoul fold() : 함수는 reduce() 함수와 거의 동일한 역할을 하나, 초기값을 지정할 수 있다. fold()도 컬렉션 내 마지막 인자부터 작업을 수행하는 foldRight() 함수를 지원한다. 12345678910111213141516171819/** * * acc - 지금까지 조합된 결과가 들어간다. * s - 새로 조합할 자료가 들어간다. * */fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"Mountain View\", \"NYC\", \"Singapore\") println(cities.fold(\"초기값 지정\") &#123; acc, s -&gt; \"$acc, $s\" &#125;) println(cities.foldRight(\"마지막부터 간다.\")&#123; s, acc -&gt; \"$acc, $s\" &#125;)&#125;// 결과초기값 지정, Seoul, Tokyo, Mountain View, NYC, Singapore마지막부터 간다., Singapore, NYC, Mountain View, Tokyo, Seoul 기타 함수 any() : 함수는 컬렉션 내 단 하나의 자료라도 존재한다면 true를, 그렇지 않으면 false를 반환한다. 조건식을 전달할 경우, 해당 조건식을 만족하는 자료의 유무 여부를 반환한다. none() : 함수는 any() 함수와 반대 작업을 수행하며, 컬렉션이 비어있는지 여부를 반환한다. 마찬가지로 조건식을 전달할 경우, 해당 조건식을 만족하는 자료가 하나도 존재하지 않는지 여부를 반환한다. 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(\"Seoul\", \"Tokyo\", \"Mountain View\", \"NYC\", \"Singapore\") println(cities.any()) println(cities.any &#123; city -&gt; city.length &lt;= 1 &#125;) println(cities.none()) println(cities.none &#123; city -&gt; city.isEmpty() &#125;) // 빈 문자열을 가진 도시가 존재하지 않는지 확인한다. // 존재하지 않으므로 true 반환.&#125;// 결과truefalsefalsetrue max(), min() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내에서 각각 최대값 및 최소값을 찾아 반환한다. average() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내 자료들의 평균을 반환한다. 123456789101112fun main(args: Array&lt;String&gt;) &#123; val cities = listOf(4, 2, 5, 3, 2, 0, 8) println(\"max =&gt; $&#123;cities.max()&#125;\") println(\"min =&gt; $&#123;cities.min()&#125;\") println(\"average =&gt; $&#123;cities.average().toInt()&#125;\")&#125;// 결과max =&gt; 8min =&gt; 0average =&gt; 3 범위 지정 함수 개발을 하다 보면 특정 객체에 있는 함수를 연속해서 사용하거나 다른 함수의 인자로 전달하기 위해 변수를 선언하고 이를 다른 곳에서는 사용하지 않는 경우가 있다. 코틀린에서는 이런 경우 유용하게 사용할 수 있는 함수를 표준 라이브러리를 통해 제공한다. let() 함수 let() 함수는 이 함수를 호출한 객체를 이어지는 함수 블록의 인자로 전달한다. 정의 =&gt; fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R 이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 인자로 전달하며, block 함수의 결과를 반환한다. 불필요한 변수 선언을 방지할 수 있다. 널 값이 아닌 경우를 체크한 후 특정 작업을 수행할 때 사용할 수 있다. Nullable 객체를 다른 Nullable 객체로 변환하는 경우 단일 지역 변수의 범위를 제한하는 경우 123456789101112131415161718192021222324// 이를 통해 불필요한 변수 선언을 방지할 수 있다.TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 16f, resources.displayMetrics).toInt().let&#123; // 계산된 값을 인자로 받아서 함수에 바로 대입한다. setPadding(it,0,it,0)&#125;// message가 null이 아닐 때만 블록 안의 문장을 실행한다.fun do(message: String?)&#123; message?.let&#123; println(message) &#125;&#125;// nullable personal 객체를 nullable driversLicence 객체로 변경한다.val driversLicence: Licence? = getNullablePerson?.let&#123; licenceService.getDriversLicence(it)&#125;// 단일 지역 변수의 범위를 제한한다.val person: Person = getPerson()getPersonDao().let&#123; dao -&gt; // 변수 dao의 범위는 이 블록 안으로 제한된다. dao.insert(person)&#125; apply() 함수 이 함수를 호출하는 객체를 이어지는 함수 블록의 리시버(receiver)로 전달한다. 정의 =&gt; fun T.apply(block: T.() -&gt; Unit): T 이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 리시버로 전달하며, 함수를 호출한 객체를 반환한다. 함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하므로, 이 블록 내에서는 해당 객체 내의 프로퍼티나 함수를 직접 호출할 수 있다. 따라서 객체 이름을 명시하지 않아도 되므로 코드를 간략하게 만들 수 있다. 12345val perter = Person().apply&#123; // apply의 블록에서는 오직 프로퍼티만 사용한다. name = \"Perter\" age = 26&#125; with() 함수 인자로 받은 객체를 이어지는 함수 블록의 리시버로 전달한다. 정의 =&gt; fun &lt;T,R&gt; with(receiver: T, block: T.() -&gt; R): R 인자로 받은 객체 receiver를 이어지는 함수형 인자 block의 리시버로 전달하며, block 결과를 반환한다. 함수에서 사용할 객체를 매개변수를 통해서 받는다. Non-nullable(Null이 될 수 없는) 객체에 이 함수를 사용한다. 그리고 결과가 필요하지 않은 경우에 사용한다. 1234567891011val person: Person = getPerson()with(person)&#123; println(name) println(age)&#125;fun manipulateView(messageView: TextView)&#123; with(messageView)&#123; text = \"Hello\" gravity = Gravity.CENTER &#125;&#125; run() 함수 인자가 없는 익명 함수처럼 사용하는 형태와 객체에서 호출하는 형태를 제공한다. 정의 =&gt; fun run(block: () -&gt; R): R 함수형 인자 block을 호출하고 그 결과를 반환한다. 정의 =&gt; fun&lt;T,R&gt; run(block: T(). -&gt; R): R 이 함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하고 그 결과를 반환한다. run() 함수를 인자가 없는 익명 함수처럼 사용하는 경우, 복잡한 계산을 위해 여러 임시 변수가 필요할 때 유용하게 사용할 수 있다. run() 함수 내부에서 선언되는 변수들은 블록 외부에 노출되지 않으므로 변수 선언 영역을 확실히 분리할 수 있다. 123456789val padding = run&#123; // 이 블록 내부에서 선언하는 값들은 외부에 노출되지 않는다. val defaultPadding = TypedValue.applyDimension(...) val extraPadding = TypedValue.applyDimension(...) // 계산된 값을 반환한다. defaultPadding+extraPadding&#125; 객체에서 run() 함수를 호출하는 경우 with() 함수와 유사한 목적으로 사용할 수 있다. 단, run() 함수는 안전한 호출을 사용할 수 있으므로 널 값일 수 있는 객체의 속성이나 함수에 연속적으로 접근해야 할 때 유용하다. 123456fun printAge(person: Person?)&#123; // person을 수신 객체로 변환하여 age 값을 사용. person?.run&#123; println(age) &#125;&#125; 참고 코틀린 의 apply, with, let, also, run 은 언제 사용하는가?","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"커니의 Kotlin","slug":"커니의-Kotlin","permalink":"https://woovictory.github.io/tags/커니의-Kotlin/"}]},{"title":"[알고리즘] 투포인터 알고리즘","slug":"Two-Pointer-Algorithm","date":"2019-05-28T03:39:06.000Z","updated":"2020-05-06T02:36:00.688Z","comments":true,"path":"2019/05/28/Two-Pointer-Algorithm/","link":"","permalink":"https://woovictory.github.io/2019/05/28/Two-Pointer-Algorithm/","excerpt":"","text":"신입 개발자를 위한 Repository를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다. 알고리즘 문제를 풀다가 완전 탐색으로 해결하면 시간 초과가 나서 어떻게 풀어야 하는가 하다가 검색해보니 투 포인터 알고리즘이라는 개념이 나와서 간단하게 정리하고 넘어가겠다. 1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 것을 얻는 형태이다. 이 때문에 투 포인터 알고리즘이라고 부른다. 대표적인 문제 2003 문제는 N칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소의 합이 M이 되는 경우의 수를 구하는 것이다. 모든 경우의 수를 다 테스트해보면, 구간 합을 구간합 배열로 O(1)만에 구한다고 해도 경우의 수가 (N^2)이 된다. 따라서 문제를 풀 수 없다. 이 문제에서 각 원소는 자연수이고 M 또한 자연수인데, 이 조건이 성립하면 사용할 수 있는 알고리즘은 다음과 같다. 포인터 2개를 준비한다. 시작과 끝을 나타낼 수 있도록 start, end라고 하겠다. 맨 처음에는 start = end = 0이며, 항상 start&lt;=end 을 만족해야 한다. 이 두개의 포인터는 현재 부분 배열의 시작과 끝을 가리키는 역할을 한다. s = e일 경우 그건 크기가 0인 즉, 아무것도 포함하지 않는 부분 배열을 뜻한다. 이제 아래의 과정을 start&lt;N 인 동안 반복한다. 현재 부분합이 M 이상이거나, 이미 end = N이면 start++ 그렇지 않다면 end++ 현재 부분합이 M과 같다면 count++ 쉽게 이해하자면, start와 end를 무조건 증가시키는 방향으로만 변화시켜가면서, 도중에 부분 배열의 합이 정확히 M이 되는 경우를 세는 것이다. 그림으로 보는게 편하다. 그림을 그리기에는 시간이 좀 걸려서 내가 보고 이해한 그림을 첨부하겠다. 아래 참고한 블로그를 보면 설명을 아주 잘해주셨다. 이것만 보면 이해가 될 것이다. 대표적인 문제를 풀어봤다. 백준 2003번으로 수들의 합2 문제이다. 풀이는 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 투포인터 알고리즘 * start : 시작 * end : 끝 */public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(\" \"); int n = parse(input[0]); int m = parse(input[1]); int[] arr = new int[n + 1]; String[] num = br.readLine().split(\" \"); for (int i = 1; i &lt;= n; i++) &#123; arr[i] = parse(num[i - 1]); &#125; int start = 0, end = 0, sum = 0, count = 0; while (true) &#123; // 부분합이 m 보다 큰 경우 start 가 가리키는 원소를 빼고 // start 의 값을 증가시킨다. 즉, start 뒤로 이동. if (sum &gt;= m) &#123; sum = sum - arr[start++]; // end 가 n 에 도달하면 종료한다. &#125; else if (end == n) &#123; break; &#125; else &#123; // 위의 두 경우에 해당하지 않으면 end 는 뒤로 이동하면서 원소의 값을 // sum 에 더한다. sum = sum + arr[end++]; &#125; // 부분 합이 m 과 같다면 count 를 증가시켜준다. if (sum == m) &#123; count++; &#125; &#125; System.out.println(count); &#125; private static int parse(String str) &#123; return Integer.parseInt(str); &#125;&#125; 참고 투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"},{"name":"투포인터 알고리즘","slug":"투포인터-알고리즘","permalink":"https://woovictory.github.io/tags/투포인터-알고리즘/"}]},{"title":"[Kotlin] Object","slug":"What-is-Kotlin-Object","date":"2019-05-27T15:25:51.000Z","updated":"2020-05-12T15:19:39.089Z","comments":true,"path":"2019/05/28/What-is-Kotlin-Object/","link":"","permalink":"https://woovictory.github.io/2019/05/28/What-is-Kotlin-Object/","excerpt":"","text":"코틀린에는 static 개념이 없다. 사실 개념이 없다기 보다는 static keyword가 없기 때문에 Java의 static 개념을 코틀린에서 표현할 수 없다. 그래서 이를 어떻게 표현하는지 중점적으로 살펴보겠다. 싱글톤을 정의하는 방법 동반 객체 companion object를 이용한 팩토리 메소드 구현 익명 클래스 선언 위의 3가지를 object keyword를 이용해 표현한다. 싱글톤 코틀린에서는 object를 이용하여 클래스를 정의함과 동시에 객체를 생성할 수 있다. 말 그대로 싱글톤을 쉽게 구현할 수 있다. 이해하기 쉽게 간단한 예제를 만들었다. 123456789class SharedPreference&#123; public static SharedPreference INSTACNE=null; public SharedPreference()&#123; if(INSTACNE == null)&#123; INSTACNE = SharedPreference(); &#125; &#125;&#125; 위 코드는 자바에서 사용할 수 있는 간단한 싱글톤 패턴 구현 코드이다. 그럼 이제 코틀린에서 object를 사용해 바꿔보자. 12345678910111213141516object SharedPreference&#123; private const val NAME = \"Test\" private const val MODE = Context.MODE_PRIVATE private latedinit var preferences: SharedPreferences fun init(context: Context) &#123; preferences = context.getSharedPreferences(NAME, MODE) &#125; // 생략.&#125;fun main(args: Array&lt;String&gt;)&#123; SharedPreference.init(applicationContext)&#125; 위의 코드처럼 object로 선언하면 클래스 선언과 동시에 객체가 생성된다. 따라서 객체 이름을 통해 property나 메소드에 접근할 수 있다. object 클래스는 가장 바깥 클래스로 선언될 수도 있고, 내부에 중첩된 클래스 형태로 선언될 수도 있다. 하지만, 어떤 방식으로 선언되었던 간에 존재하는 object는 단일 객체만 존재한다. companion object 코틀린에서는 static을 지원하지 않는 대신 top-level function을 통해 같은 효과를 낼 수 있다. 단, top-level function은 class 내부에 선언된 private property에는 접근할 수 없는 제한을 받는다. 이를 해결하기 위해서 companion object라는 개념이 존재한다. 클래스의 인스턴스 생성과 상관없이 호출해야 하지만 class의 내부 정보에 접근할 수 있는 함수가 필요할 때 companion obejct를 class 내부에 선언한다. Java로 따지면 class 내부에 static 함수를 넣는다고 생각하면 된다. 1234567891011class A&#123; companion object&#123; fun print()&#123; println(\"Companion obejct call!!\") &#125; &#125;&#125;fun main(args: Array&lt;String&gt;)&#123; A.print()&#125; 이처럼 A 클래스 내부에서 선언된 companion object는 호출할 때 클래스 이름으로 바로 호출할 수 있다. (Java의 static 함수와 동일한 형태이다.) 또한, companion object는 외부 클래스의 private property에도 접근이 가능하기 때문에, factory method를 만들 때 적합하다. 1234567891011121314class User private constructor(val nickname: String)&#123; companion object&#123; fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(accountId: Int) = User(getFacebookName(accountId)) &#125;&#125;fun main(args: Array&lt;String&gt;)&#123; val subscribingUser = User.newSubscribingUser(\"jhsw0375@gmail.com\") val facebookUser = User.newFacebookUser(4) println(subscribingUser.nickname)&#125; 위에서 User 클래스는 private constructor를 가지기 때문에 외부에서 생성할 수 없다. 따라서 외부에서는 companion으로 제공되는 factory method를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다. companion object의 사용 companion object는 클래스 내부에 정의된 일반 객체이다. 따라서 아래와 같은 작업이 가능하다. companion object에 이름 명명 companion object 내부에 확장 함수나 property 정의 인터페이스 상속 12345678910class Person(val name: String)&#123; companion object Loader&#123; fun fromJSON(jsonText: String): Person = ... 생략. &#125;&#125;fun main(args: Array&lt;String&gt;)&#123; person = Person.Loader.fromJSON(\"&#123;name: 'kim'&#125;\") person = Person.fromJSON(\"&#123;name: 'lee'&#125;\")&#125; companion object에 이름을 붙일 수 있으며, 이름을 통해서 호출할 수도 있고 그냥 호출할 수도 있다. 1234567891011121314151617interface JSONFactory&lt;T&gt; &#123; fun fromJSON(jsonText: String): T&#125;class Person(val name: String)&#123; companion object: JSONFactory&#123; override fromJSON(jsonText: String): Person = ... 생략 &#125;&#125;fun loadFromText&lt;T&gt;(factory: JSONFactory&lt;T&gt;): T&#123; ... 생략.&#125;fun main(args: Array&lt;String&gt;)&#123; loadFromText(Person)&#125; 위의 코드처럼 companion object가 특정 interface를 구현할 수도 있고, 이 interface를 넘겨줄 때는 외부 class 이름을 사용한다. 123456789101112131415interface ClickListener&#123; fun onClick()&#125;fun main(args: Array&lt;String&gt;)&#123; setClickAction(object: ClickListener&#123; override fun onClick()&#123; println(\"clicked!\") &#125; &#125;)&#125;fun setClickAction(clickListener: ClickListener)&#123; clickListener.onClick()&#125; 위의 코드에서 익명 클래스는 singleton이 아니다. 따라서 호출시 매번 객체가 생성된다는 점과 익명 클래스 내에서는 외부 클래스의 변수에 접근하여 값을 수정할 수도 있다. SharedPreferences 예제 Android에서는 간단한 값을 저장하기 위해서 SharedPreferences를 사용한다. 프로그램 어디서나 이 객체를 사용할 수 있어야 하기 때문에 일반적으로 Singleton을 이용해 구현하곤 한다. 자바에서는 싱글톤을 손쉽게 구현할 수 있다. 마찬가지로 코틀린에서도 object 개념을 사용해서 간단하게 구현할 수 있다. 123456789101112131415161718192021222324object SharedPreferenceManager&#123; private const val PREF_TOKEN = \"token\" private const val NAME = \"Test\" private const val MODE = Context.MODE_PRIVATE private latedinit var preferences: SharedPreferences fun init(context: Context)&#123; preferences = context.getSharedPreferences(NAME, MODE) &#125; // 확장 함수를 사용한다. 따라서 edit(), apply() 함수를 호출할 필요가 없다. 모든 작업을 이 함수 하나로 대체할 수 있다. private inline fun SharedPreferences.edit(operation: (SharedPreferences.Editor) -&gt; Unit)&#123; val editor = edit() operation(edit) editor.apply() &#125; var token: String get() = preferences.getString(PREF_TOKEN,\"\") set(value) = preferences.edit&#123; it.putString(PREF_TOKEN, value) &#125;&#125; 간단하게 토큰을 저장하는 예제이다. 저장해서 확인해보는 과정까지 거친 코드이므로 잘 동작한다. 확장 함수를 만들어서 이를 통해 edit(), apply() 함수를 직접 호출할 필요가 없다. 작성한 함수만 사용하면 되기 때문이다. 또한, 여러 개의 함수를 만들 필요 없이 하나의 함수만 사용하면 되고 저장할 값이 필요하다면 token 처럼 만들어서 사용자 지정 get,set을 사용하여 값을 가져오고 저장하는 과정을 거치면 된다. 이 클래스를 만들기 위해서 처음에 어떻게 잘 짤 수 있을까를 먼저 고민해보았다. 그런데 바보 같은 생각이라는 걸 깨달았다. 처음부터 잘 짤 수는 없는 것이다. 완벽한 코드는 없으면 코드를 짜면서 공부를 하면서 수정하면 되는 것이다. 그러니 처음부터 완벽한 코드를 짜려고 애쓰지 않도록 마음 먹었다. 리팩토링을 하면 나의 코드를 더 발전시켜 나갈 수 있으니 말이다. 오늘은 여기까지! 참고 [Tutorial] How to use SharedPreferences in Kotlin [Kotlin] 코틀린 object","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://woovictory.github.io/tags/kotlin/"},{"name":"singleton","slug":"singleton","permalink":"https://woovictory.github.io/tags/singleton/"}]},{"title":"[알고리즘] 부분집합","slug":"Algorithm-Set","date":"2019-05-24T07:24:20.000Z","updated":"2020-05-12T06:44:47.852Z","comments":true,"path":"2019/05/24/Algorithm-Set/","link":"","permalink":"https://woovictory.github.io/2019/05/24/Algorithm-Set/","excerpt":"","text":"백준에 있는 문제 중 1182번을 풀면서 부분집합에 대한 내용이 나와서 간단하게 정리하려고 한다. 예를 들어 배열 [1,2,3]이 있다고 가정하자. 그러면 부분집합은 아래와 같다. [1] [2] [3] [1,2] [1,3] [2,3] [1,2,3] 부분 집합을 구할 수 있는 방법은 조합을 이용한 방법이 있고 재귀를 이용한 방법이 있다. 이번에는 후자인 재귀에 대해서만 알아보도록 하겠다. 두 가지 경우를 생각해보면 된다. 현재 인덱스를 포함하는 경우 현재 인덱스를 포함하지 않는 경우 위의 두 가지 경우를 visited 배열에 방문했는지 체크함으로써 분기시킬 수 있다. 두 가지 경우에 대해서 모두 확인한 후에 현재 인덱스가 n이 되면 출력한다. 출력할 때는 visited 배열의 값이 true인 원소들만 출력한다. 코드는 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; private static int n = 3; private static boolean[] visited = new boolean[n]; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3&#125;; getSet(arr, 0); &#125; private static void getSet(int[] arr, int index) &#123; if (index == n) &#123; print(arr); return; &#125; visited[index] = false; getSet(arr, index + 1); visited[index] = true; getSet(arr, index + 1); &#125; private static void print(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(visited[i])&#123; System.out.print(arr[i]+\" \"); &#125; &#125; System.out.println(); &#125;&#125;// 결과3 2 2 3 1 1 3 1 2 1 2 3 참고 부분집합 PowerSet (Java)","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"부분집합","slug":"부분집합","permalink":"https://woovictory.github.io/tags/부분집합/"},{"name":"백준","slug":"백준","permalink":"https://woovictory.github.io/tags/백준/"}]},{"title":"[RxJava] Chap03","slug":"RxJava-Chap03","date":"2019-05-22T06:47:34.000Z","updated":"2020-05-26T07:07:02.189Z","comments":true,"path":"2019/05/22/RxJava-Chap03/","link":"","permalink":"https://woovictory.github.io/2019/05/22/RxJava-Chap03/","excerpt":"","text":"연산자 ReactiveX의 연산자는 꽤 많다. 이 연산자들을 모두 안다고 하더라도 기억하기는 어렵다. 하지만, 이름을 보고 내용을 짐작할 수 있고 마블 다이어그램이 도움이 된다. 필요할 때 찾아보자. 대신, 여기서 소개하는 연산자는 자주 사용되니 꼭 알아두자! 1.map() 입력값을 어떤 함수에 넣어서 원하는 값으로 변환하는 함수이다. 입력 데이터가 있고 그것을 변환해줄 중개업자가 있다고 생각하면 좋다. map() 함수는 반환값을 확인한다. 또한, 스케줄러를 지원하지 않으므로 현재 스레드에서 실행된다. 일대일 함수 1234567891011121314151617181920212223242526272829303132333435363738fun main(args: Array&lt;String&gt;) &#123; // map을 통해 10을 곱해준 값을 반환. Observable.just(1, 2, 3, 4, 5) .map &#123; item -&gt; item * 10 &#125; .subscribe(&#123; println(it) &#125;, &#123; println(it.message) &#125;) // 메소드 참조도 가능. Observable.just(\"RED\", \"BLUE\", \"YELLOW\",\"BLACK\") .map(Test::ballToIndex) .subscribe(&#123; println(it) &#125;, &#123; println(it.message) &#125;)&#125;object Test &#123; fun ballToIndex(color: String): Int = when (color) &#123; \"RED\" -&gt; &#123; 1 &#125; \"YELLOW\" -&gt; &#123; 2 &#125; \"BLUE\" -&gt; &#123; 3 &#125; else -&gt; &#123; -1 &#125; &#125;&#125; 2.flatMap() map() 함수와 동일한 기능을 하지만 결과가 Observable로 나온다. 결과값이 Observable이므로 여러 개의 데이터를 발행할 수 있다. 일대다 함수 혹은 일대일 Observable 함수이다. 1개를 발행할 수도 여러 개를 발행할 수도 있다. 12345678910111213141516171819202122232425262728fun main(args: Array&lt;String&gt;) &#123; // Function 인터페이스를 통해 제네릭 타입을 선언. val getDoubleDiamonds : (String) -&gt; Observable&lt;String&gt; = &#123; ball: String -&gt; Observable.just&lt;String&gt;(\"$ball&lt;&gt;\", \"$ball&lt;&gt;\") &#125; // 3개의 데이터를 넣었는데 6개를 발행한다. // 일대다이고, Observable 을 반환한다. // 위에서 정의한 Function 인터페이스 사용. Observable.just(\"1\", \"2\", \"3\") .flatMap(getDoubleDiamonds) .subscribe(&#123; println(\"성공 : $it\") &#125;, &#123; println(\"실패 : $&#123;it.message&#125;\") &#125;) // 인라인을 사용. Observable.just(\"1\",\"2\",\"3\") .map &#123; ball -&gt; Observable.just(\"$ball&lt;&gt;\",\"$ball&lt;&gt;\") &#125; .subscribe&#123; println(it) &#125;&#125; Function&lt;T,R&gt; : T는 입력값을 의미하고 R은 결과 함수이다. String을 넣으면 여러 개의 String을 발행하는 Observable이 나온다. 여러 개의 데이터를 발행하는 방법은 Observable 뿐이다. 3.filter() 함수 Observable에서 원하는 데이터만 걸러내는 역할을 한다. 즉, 필요없는 데이터는 제거하고 관심있는 데이터만 filter() 함수를 통과한다. 간단한 수식을 적용하는 것과 원하는 조건을 작성할 수도 있다. 12345678910111213141516fun main(args: Array&lt;String&gt;) &#123; // 짝수만 필터링. Observable.just(1, 2, 3, 4, 5, 6, 7) .filter &#123; number -&gt; number % 2 == 0 &#125; .subscribe(&#123; println(\"result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;)&#125;// 결과result : 2result : 4result : 6 이외에도 filter() 함수와 비슷한 함수들이 존재한다. 이름만 보고 어떤 기능을 할지 짐작이 가능하다. first(default) : Observable의 첫 번째 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다. last(default) : Observable의 마지막 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다. take(N) : 최초 N개 값만 가져온다. takeLast(N) : 마지막 N개 값만 필터한다. skip(N) : 최초 N개 값을 건너뛴다. skipLast(N) : 마지막 N개 값을 건너뛴다. 사용 예제는 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768fun main(args: Array&lt;String&gt;) &#123; val source = Observable.just(100, 200, 300, 400, 500, 600) var single: Single&lt;Int&gt; // 1. first single = source.first(-1) single.subscribe(&#123; println(\"first result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 2. last single = source.last(-1) single.subscribe(&#123; println(\"last result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 3. take source.take(3) .subscribe(&#123; println(\"take result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 4. takeLast source.takeLast(3) .subscribe(&#123; println(\"takeLast result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 5. skip -&gt; 300,400,500,600 source.skip(2) .subscribe(&#123; println(\"skip result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 6. skipLast -&gt; 100,200,300 source.skipLast(3) .subscribe(&#123; println(\"skipLast result : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;)&#125;// 결과first result : 100last result : 600take result : 100take result : 200take result : 300takeLast result : 400takeLast result : 500takeLast result : 600skip result : 300skip result : 400skip result : 500skip result : 600skipLast result : 100skipLast result : 200skipLast result : 300 4.reduce() 발행한 데이터를 모두 사용하여 어떤 최종 결과 데이터를 합성할 때 활용한다. 함수형 프로그래밍의 가장 기본 연산자인 map/filter/reduce 패턴을 이루는 마지막 필수 함수이다. Observable을 이용해 들어오는 데이터를 1개씩 모아서 최종 결과를 만들어야 할 때 사용한다고 생각하면 된다. 주로 수치와 관련된 계산 문제에서 활용하면 좋다. 보통 Observable에 입력된 데이터를 필요한 map() 함수로 매핑하고, 원하는 데이터만 추출할 때는 불필요한 데이터를 걸러내는 filter() 함수를 사용한다. 또한 상황에 따라 발행된 데이터를 취합하여 어떤 결과를 만들어낼 때는 reduce 계열의 함수를 사용한다. 1234567891011121314151617181920fun main(args: Array&lt;String&gt;) &#123; val source: Maybe&lt;String&gt; = Observable.just(\"1\", \"3\", \"5\") .reduce &#123; ball1, ball2 -&gt; \"$ball2($ball1)\" &#125; source.subscribe(&#123; println(\"reduce 결과 : $it\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;) // 람다 표현식을 별도 함수로 분리. Observable.just(\"1\",\"3\",\"5\") .reduce(mergeBalls) .subscribe(&#123; println(\"reduce 함수로 분리한 결과 : $it\") &#125;,&#123; println(\"error : $&#123;it.message&#125;\") &#125;)&#125; reduce() 함수를 호출하면 인자로 넘긴 람다 표현식에 의해 결과 없이 완료될 수도 있다. 따라서 Observable이 아니라 결과가 반환할 수도 아닐 수도 있는 Maybe 객체로 리턴된다. 예제 다음과 같은 예제를 한번 작성해보자. 전체 매출 데이터를 입력한다. 매출 데이터 중 TV 매출을 필터링한다. TV 매출의 합을 구한다. 1234567891011121314151617181920212223242526272829303132333435fun main(args: Array&lt;String&gt;) &#123; // 1. 데이터 입력. // first : 상품 이름, second : 매출액. var sales = mutableListOf&lt;Pair&lt;String, Int&gt;&gt;() sales.add(\"TV\" to 2500) sales.add(\"Camera\" to 300) sales.add(\"TV\" to 1600) sales.add(\"Phone\" to 800) sales.add(\"Sofa\" to 10000) sales.add(Pair(\"TV\", 1000)) val source: Maybe&lt;Int&gt; = Observable.fromIterable(sales) // 2. 매출 데이터 중 TV 매출을 필터링한다. .filter &#123; sale -&gt; sale.first == \"TV\" &#125; // map 을 통해 sale 에서 매출액만 뽑는다. .map &#123; sale -&gt; sale.second &#125; // 3. reduce 를 통해 매출의 합을 구한다. .reduce &#123; sale1, sale2 -&gt; sale1 + sale2 &#125; // reduce 를 호출하기 때문에 Observable 이 아니라 Maybe 를 사용한다. source.subscribe(&#123; total -&gt; println(\"TV Sale: $ $total\") &#125;, &#123; println(\"error : $&#123;it.message&#125;\") &#125;)&#125;// 결과TV Sale: $ 4100","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"Observable","slug":"Observable","permalink":"https://woovictory.github.io/tags/Observable/"},{"name":"연산자","slug":"연산자","permalink":"https://woovictory.github.io/tags/연산자/"}]},{"title":"[알고리즘] 백트래킹","slug":"What-is-BackTracking","date":"2019-05-22T03:03:06.000Z","updated":"2019-06-05T07:31:16.621Z","comments":true,"path":"2019/05/22/What-is-BackTracking/","link":"","permalink":"https://woovictory.github.io/2019/05/22/What-is-BackTracking/","excerpt":"","text":"알고리즘을 푸는데 백트래킹 문제가 나왔다. 근데, 백트래킹의 정확한 의미를 잘 몰라서 간략하게 정리하려고 한다. 백트래킹 위키피디아의 정의를 보면 한정 조건을 가진 문제를 풀려는 전략이라고 나와있다. 즉, 모든 조합의 수를 살펴보는 것인데 단 조건이 만족할 때만 살펴본다. 설명을 덧붙이자면, 어떤 노드의 유망성을 점검한 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손 노드를 검색한다. 유망성은 조건을 만족하는가 아닌가를 뜻한다. 즉, 유망하지 않으면 배제를 하고 부모 노드로 돌아가서 풀이 시간이 단축될 수 있다. DFS에서 가지치기를 통해 가도되지 않는 루트는 고려하지 않고 탐색하는 완전탐색 기법 중 하나이다. 백트래킹의 대표적인 문제는 N-Queen 문제이다. 이 문제를 통해서 백트래킹을 한 번 더 이해해보자. N-Queen 크키가 NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구해보자. 4x4를 기준으로 문제를 풀어보자. 퀸이 어떻게 이동할 수 있는지만 알면 체스가 무엇인지 몰라도 된다. 퀸은 배치된 칸을 기준으로 오와 열, 대각선 이동이 가능한 말이다. 빨간색 선이 퀸이 이동할 수 있는 경로이고, 첫 번째로 배치된 퀸과 공격할 수 없도록 배치하려면 2번째 줄은 2,3번 위치에 퀸을 놓아야 조건을 만족시킬 수 있다. 첫 번째 퀸의 위치를 (1,1)로 하면 트리구조는 다음과 같다. 이 문제를 가지치기를 하지 않는 DFS로 풀었다면 유망하지 않는 즉, 조건에 위배하는 (2,1), (2,2) 지점도 검사했을 것이다. 그러면 연산 횟수가 많아져 시간복잡도도 증가했을 것이다. 그래서 백트래킹에서 가지치기를 잘해야 한다. 백트래킹은 크게 4가지 절차로 구성되어 있다. DFS 수행 - 평소와 같이 깊이 우선 탐색인 DFS를 수행하여 노드를 찾는다. 유망한 노드 검토 - 방문한 노드를 포함해서 유망한 노드이면 서브트리(하위노드)로 이동하고 그렇지 않으면 백트래킹을 수행하낟. 방문한 노드의 하위 노드로 이동하여 다시 재귀를 통해 DFS를 수행한다. 백트래킹 수행 - 방문한 노드를 가지치기를 하고 상위 노드로 백트래킹한 후 DFS를 다시 수행한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.Scanner;/** * 22/05/2019 * 완탐 : N-Queen * 백트래킹의 대표적인 문제. */public class Main &#123; private static int N = 0; private static int count = 0; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); N = sc.nextInt(); for (int i = 1; i &lt;= N; i++) &#123; int[] column = new int[N + 1]; // N행 까지 담기 위해. index -&gt; 행, value -&gt; 열. column[1] = i; // 1행 i열에 퀸을 놓음. // 1. DFS 수행. // 1행 i 열에 퀸을 놓았을 경우 dfs 로 가능한 경우를 확인한다. dfs(column, 1); &#125; System.out.println(count); &#125; private static void dfs(int[] column, int row) &#123; // row 와 N 이 같다는 말은 N 번째 행까지 퀸을 놓았다는 의미이다. // 즉, 퀸을 다 놓았다는 말! 따라서 count 를 증가시킨다. if (row == N) &#123; count++; &#125; else &#123; for (int i = 1; i &lt;= N; i++) &#123; column[row + 1] = i; // (row+1)행 i열에 퀸을 놓는다. // 2. 유망한 노드인지 판단. if (isPossible(column, row + 1)) &#123; // 3. 서브 트리로 이동.(해당 노드의 하위 노드) dfs(column, row + 1); &#125;else &#123; // 4. 백트래킹 수행. 해당 노드는 가지치기 됨. // 아니면 백트래킹. 0이면 퀸을 못놓는다는 의미. column[row+1] = 0; &#125; &#125; &#125; column[row] = 0; &#125; private static boolean isPossible(int[] column, int row) &#123; // (row+1)이 들어오는데 그 전까지 즉, row 행 전까지 검사한다. for (int i = 1; i &lt; row; i++) &#123; // i 행과 row 행의 열이 같으면 퀸을 놓을 수 없다. if (column[i] == column[row]) &#123; return false; &#125; // i 행과 row 행의 열 값이 대각선 위치에 존재하면 퀸을 놓을 수 없다. if (Math.abs(i - row) == Math.abs(column[i] - column[row])) &#123; return false; &#125; &#125; // 위의 경우가 모두 된다면 true 반환한다. return true; &#125;&#125; 참고 [알고리즘] 백트래킹 (Backtracking) 알고리즘 [알고리즘] Backtracking 이해하기 뚜벅이 강군 블로그","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"백트래킹","slug":"백트래킹","permalink":"https://woovictory.github.io/tags/백트래킹/"}]},{"title":"[개발 상식] UML","slug":"What-is-UML","date":"2019-05-13T07:18:42.000Z","updated":"2020-05-12T15:12:59.373Z","comments":true,"path":"2019/05/13/What-is-UML/","link":"","permalink":"https://woovictory.github.io/2019/05/13/What-is-UML/","excerpt":"","text":"모듈화를 함에 있어서 UML이 무엇인지, UML을 이용해 클래스 다이어그램을 작성하는 방법을 공부하기 위한 포스팅이다. UML(Unified Modeling Language) 시스템을 모델로 표현해주는 대표적인 모델링 언어. UML 다이어그램의 종류 구조 다이어그램 클래스 다이어그램, 객체 다이어그램, 복합체 구조 다이어그램, 배치 다이어그램, 컴포넌트 다이어그램, 패키지 다이어그램. 행위 다이어그램 활동 다이어그램, 상태 머신 다이어그램, 유즈 케이스 다이어그램, 상호작용 다이어그램. UML 작성 도구 http://staruml.io/ http://www.umlet.com/ 클래스 다이어그램이란 시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 대표적인 UML 구조 다이어그램이다. 목적 : 시스템을 구성하는 클래스들 사이의 관계를 표현한다. 클래스 클래스란 동일한 속성과 행위를 정의한 객체의 집합. 객체를 생성하는 설계도. 클래스는 변화의 기본 단위 디자인 패턴을 제대로 이해하려면 만들진 프로그램을 흔들어보고 어떤 것이 변화되는지를 잘 살펴봐야 한다. UML 클래스의 표현은 아래 그림과 같다. 가장 위 : 클래스 이름 중간 : 속성(클래스의 특징, 변수) 마지막 : 연산(클래스가 수행하는 책임, 메소드) 경우에 따라 속성과 연산 부분은 생략 가능. 속성과 연산의 가시화를 정의 UML에서는 접근 제어자를 사용해 나타낼 수 있다. 분석 단계와 설계 단계에서의 클래스 다이어그램은 아래와 같다. 분석 단계는 조금 더 간략하게 표시한다. 설계 단계는 보다 더 세밀하게 작성한다. 관계 UML에서 제공하는 클래스들 사이의 관계는 아래의 표와 같다. 표를 먼저 보고 각 관계의 의미에 대해서 알아보도록 하자. 서로 의미있는 클래스들의 관계에는 크게 4가지 종류가 있다. 일반적인 의미의 연결 관계인 연관(association) 관계, 전체와 부분을 나타내는 집합(aggregation) 관계, 다른 클래스의 속성을 물려받는 상속(inheritance) 관계, 그리고 한 클래스가 다른 클래스에 영향을 미치는 의존(dependency) 관계가 있다. 연관 관계와 의존 관계를 구분 짓는 가장 큰 기준은 참조하는 클래스 인스턴스의 참조를 계속 유지하고 있느냐, 아니냐이다. 아래의 코드에서 확인할 수 있다. 연관 관계 : 참조를 유지한다. 의존 관계 : 참조를 짧게 유지하고 빠르게 끊는다. 의존(dependency) 관계 일반적으로 한 클래스가 다른 클래스를 사용하는 경우. 클래스의 속성에서 참조할 때 매개변수, 인자로 사용될 때 메소드 내부의 지역 변수로 참조될 때 1 : 연관 관계 / 2,3 : 의존 관계 1234567891011121314151617public class A &#123; public A()&#123; // 생성자. &#125; public void callA()&#123; // 의존 관계 : 이 메소드 내부에서만 c의 참조를 유지한다. // 메소드 실행이 종료되면 c의 참조도 사라진다. C c = new C(); c.callC(); &#125;&#125;public class C &#123; // 생략.&#125; 위의 코드에서 확인할 수 있는 것처럼 짧은 시간 동안 이용하는 관계 UML에서는 다음과 같이 점선으로 나타낸다. 연관 관계 오랜 시간 동안 같이 할 객체와의 관계 예를 들어, 자동차와 자동차를 소유한 사람의 관계 1234567891011121314151617public class A &#123; private C c; public A() &#123; // 생성자. // 연관 : 클래스 C에 대한 참조를 계속 유지하고 있음. this.c = new C(); &#125; public void callA()&#123; this.c.callC(); &#125; &#125;public class C &#123; // 생략.&#125; 의존 관계(dependency) 클래스가 연관, 상속, 집합 관계로 엮여 있는 것은 아니지만, 한 곳이 변경되면 그것을 사용하는 다른 곳도 같이 변경해줘야 하는 관계를 표현할 때 주로 사용한다. 주의해야 할 점은 연관 관계와 달리 의존 관계의 경우에는 클래스 인스턴스의 참조를 유지하고 있지 않다는 점이다. 참조를 계속적으로 유지하게 되면 이는 연관 관계로 표현해야 한다. 주로 다음과 같은 세 가지 경우에 의존 관계로 표현한다. 한 클래스의 메소드가 다른 클래스의 객체를 인자로 받아 그 객체의 메소드를 사용한다.(가장 일반적이다.) 한 클래스의 메소드가 또 다른 클래스의 객체를 반환한다. 다른 클래스의 메소드가 또 다른 클래스의 객체를 반환한다. 이때 이 메소드를 호출하여 반환되는 객체의 메소드를 사용한다. 연관 관계(association) 한 객체가 다른 객체와 연결되어 있음을 나타낼 때 그들을 연관 관계로 지칭한다. 이 연관 관계에서 중요하게 볼 점은 연관 관계의 방향과 멀티플리시티이다. 연관 관계는 방향성을 가지며 양방향과 단방향으로 구분지을 수 있다. 단방향 연관 관계 : 한쪽은 알지만 다른 쪽은 상대방의 존재를 모른다. 화살표로 표시한다. 아래의 UML House 클래스는 Person 클래스의 존재를 알고 있지만, Person은 House 클래스의 존재를 모른다. House 클래스만 Person 클래스에 대한 참조값을 가지고 있고, Person은 House에 대한 어떠한 참조값도 가지고 있지 않는다. 양방향 연관 관계 : 연결된 클래스들이 서로의 존재를 알고 있다. 실선으로 표시한다. 아래의 UML의 의미는 House와 Person 클래스는 서로의 존재를 알고 있으며, 반드시 한 사람 이상이 House에 속해야 한다는 뜻이다. 다대다 연관 관계는 양방향 연관 관계로 표현되는 것이 적절하다. 하지만 양방향 연관 관계를 구현하는 것은 복잡하기 때문에 보통 다대다 연관 관계를 일대다 단방향 연관 관계로 변환해 구현한다. -&gt; 연관 클래스 연관 클래스 연관 관계에 추가할 속성이나 행위가 있을 때 사용한다. 연관 클래스를 일반 클래스로 변환 연관 클래스는 연관 관계가 있는 두 클래스 사이에 위치하며, 점선을 사용해 연결한다. 이 연관 클래스를 일반 클래스로 변환하여 다대다에서 일대다 연관 관계로 변환한다. 일반화 관계 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에는 일반화 관계가 존재한다. 객체지향 개념에서는 일반화 관계를 상속 관계(IS-A)라고 한다 부모 클래스 추상적인 개념이며 위의 그림에서 가전제품에 해당. 자식 클래스에게 공통 속성이나 기능을 제공한다. ex) 제조번호, 제조 회사 같은 공통 속성과 turnOn/Off 같은 공통 기능을 두고 자식 클래스에서 상속받아 구현할 수 있다. 자식 클래스 구체적인 개념이며 아래의 제품들에 해당. 추상 클래스 추상 메소드를 하나 이상 갖는 클래스 추상 메소드 부모 클래스에서 구현부 없이 선언부만 있는 함수 ex) turnOn/Off는 자식 클래스에서 구현함에 따라 달라지기 때문에 부모 클래스에서 추상 메소드로 선언한다. 일반적인 클래스와 달리 객체를 생성할 수 없다. UML에서의 표현 이탤릭체 사용. 집합 관계 연관 관계의 특별 경우로 전체와 부분의 관계를 명확하게 명시하고자 할 때 사용한다. aggregation(집합)과 composition(구성)을 구분하는 기분은 lifeCycle이 같느냐, 같지 않느냐이다. lifeCycle이란 클래스 인스턴스의 생명주기를 말하는 것으로 생성에서 소멸까지의 과정이다. 집합 관계(aggregation) 한 객체가 다른 객체를 포함하는 것 부분을 나타내는 객체를 다른 객체와 공유할 수 있다. 전체를 가리키는 클래스 방향에 빈 마름모 표시 전체 객체의 lifeCycle과 부분 객체의 lifeCycle은 독립적이다. 즉, 전체 객체가 사라진다 해도 부분 객체는 사라지지 않는다. 예시 : 생성자에서 참조값을 인자로 받아 필드 세팅 123456789101112public class Computer&#123; private MainBoard mb; private CPU c; public Computer(MainBorad mb, CPU c)&#123; this.mb = mb; this.c = c; // 집합 연관 : 부분과 전체의 관계 // 부분이 되는 객체를 외부에서 생성하여 넘겨 받는다. // 따라서 Computer 클래스가 없어져도 부분이 되는 객체들은 사라지지 않는다. &#125;&#125; 합성 관계(Composition) 부분 객체가 전체 객체에 속하는 관계 부분을 나타내는 객체를 다른 객체와 공유할 수 없다. 전체를 가리키는 클래스 방향에 채워진 마름모로 표시 전체 객체의 lifeCycle과 부분 객체의 lifeCycle은 의존적이다. 즉, 전체 객체가 없어지면 부분 객체도 없어진다. 예시 : 생성자에서 필드에 대한 객체를 생성한다. 12345678910111213public class Computer&#123; private MainBoard mb; private CPU c; // 생성자 public Computer()&#123; this.mb = new MainBoard(); this.c = new CPU(); // 합성 : 집합 관계 중에서도 강한 집합체의 의미를 갖는다. // 부분을 이루는 객체가 없이는 전체가 아무런 의미를 갖지 못한다. // Computer 클래스가 사라져 버리면 내부에서 생성된 MainBoard, CPU도 같이 사라진다. &#125;&#125; aggregation과 composition을 쉽게 설명하면 모자와 안경을 쓴 사람을 생각해보자. 이 사람을 구성하고 있는 요소에는 눈,팔,다리와 같이 사람이 죽으면 같이 없어지는 요소들이 있고, 안경,모자와 같이 바꿔 사용할 수 있는 요소들이 있다. 즉, 눈,팔,다리는 사람과 lifeCycle이 같은 Composition 관계이고 안경이나 모자는 Aggregation 관계인 것이다. 인터페이스와 실체화 관계 인터페이스란 책임이며, 어떤 객체의 책임이란 객체가 해야 하는 일 또는 객체가 할 수 있는 일이다. 즉, 객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 본다. 공통되는 능력이 있는 것들을 대표하는 관점 UML에서의 인터페이스 표현 빈 삼각형과 점선을 이용 객체 지향 개념에서는 실체화 관계를 can do this 관계라고 한다. 12345678910public interface Flyable&#123; // 생략.&#125;public class Plane implements Flyable&#123; // 생략.&#125;public class Bird implements Flyable&#123; // 생략.&#125; 참고 [UML] 클래스 다이어그램 작성법 UML - 기본편 ( 기본 표기 형식 및 관계 표현법 )","categories":[{"name":"개발 상식","slug":"개발-상식","permalink":"https://woovictory.github.io/categories/개발-상식/"}],"tags":[{"name":"UML 작성","slug":"UML-작성","permalink":"https://woovictory.github.io/tags/UML-작성/"},{"name":"클래스 다이어그램","slug":"클래스-다이어그램","permalink":"https://woovictory.github.io/tags/클래스-다이어그램/"}]},{"title":"[Android] 백그라운드 실행 정책 Oreo","slug":"Android-Background-Policy2","date":"2019-05-12T08:58:56.000Z","updated":"2020-03-01T10:28:41.957Z","comments":true,"path":"2019/05/12/Android-Background-Policy2/","link":"","permalink":"https://woovictory.github.io/2019/05/12/Android-Background-Policy2/","excerpt":"","text":"안드로이드 Oreo(8.0) 버전에서 등장한 백그라운드 실행 제한을 확인해보도록 하겠다. 안드로이드에서 백그라운드 실행은 상용 서비스에서 많이 사용되는 부분이기도 하고 꼭 알아야 하는 부분이라서 공부하면서 정리하려고 한다. 1. Oreo 버전 백그라운드 제한 개요 앱이 백그라운드에서 실행될 때마다 디바이스의 리소스(예:RAM, 배터리)를 사용한다. 이는 사용자들에게 좋지 못한 경험을 제공한다. 예를 들어 백그라운드 작업으로 인해 디바이스의 배터리 수명이 저하되거나 비디오 시청, 게임, 카메라 사용과 같은 사용자의 디바이스 성능 저하가 발생할 수 있다. 동시에 실행되는 앱이 많은 수록 시스템에 많은 부하가 걸린다. 추가적인 앱이나 서비스가 백그라운드에서 실행 중이면 시스템에 추가적인 부하가 걸리고 사용자 환경이 나빠질 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 Android Oreo 버전에서는 사용자가 앱과 직접적으로 상호작용하지 않을 때 이 앱이 수행할 수 있는 작업을 제한한다. 두 가지 방식으로 제한된다.(여기서는 백그라운드 서비스 제한만 살펴보도록 하겠다.) 백그라운드 서비스 제한 : 앱이 유휴 상태인 경우 백그라운드 서비스의 사용이 제한된다. 이 기능은 사용자에게 잘 보이는 포그라운드 서비스에는 적용되지 않는다. 브로드캐스트 제한 : 제한된 예외의 경우, 앱이 암시적 브로드캐스트에 등록하기 위해 자체 매니페스트를 사용할 수 없다. 그렇지만 앱이 런타임에 브로드캐스트에 등록할 수 있으며, 특정 앱을 대상으로 하는 명시적 브로드캐스트에 등록하기 위해 매니페스트를 사용할 수 있다. 기본적으로 이와 같은 제한은 Oreo 버전을 대상으로 하는 앱에만 적용된다. 하지만, 안드로이드 개발자라면 모든 버전을 고려해서 개발해야 하기 때문에 피할 수 없는 부분임이 분명하다. 그렇기 때문에 반드시 알고 넘어가야 한다. 추가적으로 이전에 살펴본 Service는 백그라운드에서 동작하는 컴포넌트이다. 하지만, Oreo 처럼 백그라운드 작업을 제한하게 된다면 우리가 원하는 작업을 수월하게 진행할 수 없다. 이 부분을 어떻게 해결할 수 있는지 고민해야 할 필요가 있다. 대부분의 경우, 앱은 JobScheduler 작업을 사용해 이 제한을 해결할 수 있다. JobScheduler를 통해 앱이 실행되지 않을 때 작업을 수행하면서도, 사용자 환경에 영향을 미치지 않는 방식으로 이러한 작업을 예약할 수 있는 여지를 제공할 수 있다. 하지만, JobScheduler 역시 제한이 걸리는 점이 존재한다. 이 부분은 WorkManager 부분에서 공부하면서 살펴보자. 2. 백그라운드 실행 변화 앞선 포스팅에서 확인한 내용을 한번 더 정리하고 넘어가려 한다. 그리고 위에서 설명한 것처럼 사용자의 디바이스 배터리 수명을 개선하고 더 좋은 사용자 경험을 제공하기 위해 안드로이드는 몇가지 백그라운드 정책들을 변화시켜왔다. 도즈모드와 앱 대기상태(Doze And App Standby) : 화면이 꺼지고 충전 상태가 아니며 대기 상태일 때 애플리케이션의 행동을 제한한다. 백그라운드 상태에서 위치 서비스 제약 : 백그라운드 상태에 있는 앱이 사용자의 현재위치를 검색할 수 있는 빈도를 제한한다. 백그라운드 서비스 제약 : 보이지 않는 CPU/Network 사용과 실행중인 백그라운드 서비스들을 제한한다. 가장 최근에는 사용자가 사용하지 않는 앱에서 사용할 수 있는 기기 리소스를 제한할 수 있는 앱 대기 버킷(App Standby Buckets)과 앱이 좋지 않는 행동을 보이는 경우 백그라운드에서 시스템 리소스에 대한 앱의 접근을 제한하도록 사용자에게 경고하는 앱 제한(App Restrictions)과 배터리 절약 개선(Battery Saver improvements) 정책이 추가되었다. 3. Oreo 버전 백그라운드 실행 제한. 위에서 언급한 것처럼 백그라운드에서 실행 중인 서비스가 디바이스의 리소스를 사용할 수 있으며, 그 결과로 사용자 경험이 악화될 가능성이 있다. 이러한 문제를 줄이기 위해 Oreo 버전부터 시스템은 여러가지 제한을 서비스에 적용한다. 먼저, 이를 이해하기 전에 애플리케이션이 Foreground인지 Background인지 명확하게 파악해야 한다. 아래와 같은 경우 애플리케이션이 Foreground에 있는 것으로 간주한다. 액티비티가 시작되거나 일지 중지되거나 상관없이 액티비티가 가시적일 경우. Foreground Service가 있는 경우. Foreground 애플리케이션이 서비스를 갖는 애플리케이션에 바인딩하거나 콘텐츠 프로바이더를 사용하여 앱에 연결할 때. 예를 들어 다른 앱이나 시스템이 아래의 내용에 바인딩하면 애플리케이션이 Foreground에 있는 것이다. IME Wallpaper Service Notification listener Voice 또는 text 서비스 자동차에서 스트리밍을 듣는 음악 앱(Android Auto일 때) 위의 조건들을 만족하지 못한다면 애플리케이션이 Background에 있는 것으로 간주된다. 바인드된 서비스는 영향을 받지 않는다. 이러한 규칙은 바인드된 서비스에는 어떠한 영향도 미치지 않는다. 앱이 바인드된 서비스를 정의하는 경우, 해당 앱이 Foreground에 있는 없든 간에 다른 구성요소들이 이 서비스에 바인드할 수 있다. 앱이 Foreground에 있는 동안에는 이 앱이 Foreground 및 Background 서비스를 자유롭게 생성하고 실행할 수 있다. 앱이 백그라운드로 이동하더라도 몇 분 동안은 앱이 서비스를 생성하고 사용하는 것이 여전히 허용된다. 이 기간이 끝나게 되면 앱이 유휴 상태로 간주된다. 이때 마치 앱이 서비스의 Service.stopSelf() 메소드를 호출한 것처럼 시스템이 앱의 백그라운드 서비스를 중지시킨다. 어떠한 상황에서는 백그라운드 앱이 몇 분 동안 임시 허용 목록이란 곳에 들어가기도 한다. 앱이 허용 목록에 있는 동안에는 제한 없이 서비스를 시작할 수 있으며 백그라운드 서비스도 실행이 허용된다. 사용자에게 보이는 다음과 같은 작업을 앱이 처리하는 경우에 앱이 허용 목록에 들어간다. 우선순위가 높은 Firebase Cloud Messaging(FCM) 메시지 처리 SMS/MMS 메시지와 같은 브로드캐스트 수신 알림에서 PendingIntent 실행 많은 경우 앱이 백그라운드 서비스를 JobScheduler 작업으로 대체할 수 있다. Android 8.0 이전에는 Foreground 서비스를 생성하는 일반적인 방법은 Background 서비스를 생성한 후 이 서비스를 Foreground 서비스로 승격시키는 것이었다. Android 8.0에서는 좀 복잡하며 시스템은 백그라운드 앱이 Background 서비스를 생성하는 것을 허용하지 않는다. 이 때문에 Android 8.0에서는 새 서비스를 Foreground에서 시작하는 새로운 메소드 Context.startForegroundService()를 소개한다. 시스템이 서비스를 생성한 후, 앱은 5초 이내에 해당 서비스의 startForeground() 메소드를 호출하여 새 서비스의 알림을 사용자에게 표시해야 한다. 앱이 이 시간 내에 startForeground() 를 호출하지 않으면 시스템이 서비스를 중단하고 앱을 ANR로 선언하게 된다. 5. 사례와 해결 방법 백그라운드 실행 제한으로 인해 원하는 작업을 하는게 조금 어려워졌다. 개발자는 백그라운드 실행을 구현하기 위해 사용할 도구를 결정하려면 원하는 것을 명확하게 이해하고 어떤 제한 사항을 가지고 있어야 한다. 공식 문서에 나와있는 Guide to background Processing을 참고해서 알아보도록 하자. 개요 안드로이드 앱은 UI 처리, 사용자와 상호작용, LifeCycle 이벤트 수신 등을 담당하는 Main Thread가 존재한다. Main Thread에서 너무 많은 작업이 발생하면 앱이 끊기거나 느려져서 사용자 경험이 좋지 않다. 즉, 사용자가 불편함을 느낄 수 있다. 비트맵 디코딩, 디스크 접근 또는 네트워크 요청 수행과 같은 시간이 오래 걸리는 실행 및 작업을 별도의 백그라운드 스레드에서 수행해야 한다. 일반적으로 몇 밀리초 이상 걸리는 것은 모두 백그라운드 스레드에 위임해야 한다. 이러한 작업 중 일부는 사용자가 앱을 활발하게 사용하는 동안 수행되어야 한다. 백그라운드 스레드에서 작업을 실행하고 앱을 사용하는 동안 기본 UI 스레드에서 작업을 실행하는 방법 그리고 두 스레드 간 통신 방법에 대해서는 다른 글을 참고하면 좋다. 애플리케이션은 또한 사용자가 백엔드 서버와 정기적으로 동기화하거나 앱 내에서 새로운 컨텐츠를 가져오는 등 앱을 사용하지 않을 때에도 실행해야 하는 일부 작업이 필요할 수 있다. 또한 애플리케이션은 사용자가 앱과 상호작용을 완료한 후에도 서비스가 즉시 실행되도록 요구할 수 있다. 이와 같은 경우를 해결하기 위해서 백그라운드 처리에 대한 고민이 필요하다. 백그라운드 처리의 과제 백그라운드 작업은 RAM 및 배터리와 같은 기기의 제한된 리소스를 소비한다. 올바르게 사용하지 않을 경우 사용자에게 좋지 않은 경험을 제공할 수 있다. 안드로이드는 배터리를 극대화하고 좋은 앱 동작을 위해 앱 또는 Foreground Service Notification이 사용자에게 보이지 않을 때 백그라운드 작업을 제한한다. 다음은 위에서 언급한 버전별 백그라운드 정책의 변화를 보여준다. Android 6.0 : Doze 모드와 App Standby(앱 대기) 기능 도즈 모드는 화면이 꺼져 있고 기기가 정지해 있을 때 앱 동작을 제한한다. 앱 대기에서는 사용하지 않는 애플리케이션을 네트워크 접근, 작업 및 동기화를 제한하는 특수 상태로 전환한다. Android 7.0 : 암시적 브로드캐스트 리시버를 제한하고 개선된 도즈모드를 제공한다. Android 8.0 : 백그라운드에서 위치를 파악하거나 캐시된 Wake lock을 해제하는 등 추가적인 백그라운도 동작 제한이 있다. Android 9.0 : 앱 이용 패턴에 따라 자원에 대한 앱 요청이 동적으로 우선되는 App Standby Buckets를 소개했다. 결국 내가 해야 할 작업을 정확히 이해하고 백그라운드 작업을 버전별 정책에 맞도록 개발하는 것이 중요하다. 작업에 맞는 적합한 방법을 선택하자. 아래의 예시를 확인해보고 생각해보자. 작업이 연기될 수 있거나 당장 일어날 필요가 있는가? 예를 들어, 사용자가 버튼을 클릭하는 것에 대응하여 네트워크에서 데이터를 가져와야 하는 경우 이 작업은 즉시 수행되어야 한다. 그러나 서버에 로그를 업로드하려면 앱의 성능이나 사용자 기대에 영향을 미치지 않고 작업을 연기할 수 있다. 작업이 시스템에 상태에 따라 달라지는가? 장치에 전원 연결, 인터넷 연결 등과 같은 특정 조건을 충족할 때만 작업을 실행하기를 원할 수 있다. 예를 들어, 사용자의 앱은 주기적으로 저장된 데이터를 압축해야 할 수 있다. 사용자에게 영향을 주지 않도록 하려면 장치가 충전되고 유휴 상태일 때만 이 작업을 수행하기를 원할 것이다. 작업이 정확한 시간에 실행되어야 하는가? 일정 관리 앱의 경우, 사용자가 특정 시간에 발생할 이벤트에 대해서 미리 알림을 설정하도록 할 수 있다. 사용자는 정확한 시간에 알림을 볼 수 있을 것으로 예상한다. 다른 경우, 앱은 작업이 실행될 때 정확하게 신경을 \b쓰지 않을 수 있다. 앱에는 &quot;작업 A가 먼저 실행되야 하고, 그 다음에 작업 B가 실행되어야 하며 다음에는 작업 C가 실행되어야 한다.&quot;와 같은 일반적인 요구 사항이 있을 수 있다. 하지만, 특정 시간에 실행되기 위해서는 작업이 필요하지 않다. WorkManager 모든 OS 백그라운드 실행 제한을 고려하여 백그라운드 실행에 권장되는 솔루션이다. 장치 또는 애플리케이션이 재시작되더라도, 작업이 연기될 수 있거나 작업이 실행될 것으로 예상되는 경우 WorkManager를 사용할 수 있다. 작업 조건(네트워크 가용성, 배터 등)이 만족될 때, 지연 가능한 백그라운드 작업을 멋지게 실행할 수 있다. 장점으로는 작업(일회성 또는 반복성)을 예약하거나 작업을 결합(체이닝)할 수 있다. 또한 장치가 유휴상태이거나 충전 중일 때 특정 이벤트를 트리거하거나 콘텐츠 프로바이더가 변경될 때 실행하는 것과 같은 실행 제한 조건을 적용할 수 있다. 한 가지 예로 로그를 압축하여 서버에 업로드 해야 하는 경우라면 두 가지 작업 요청을 만들어 수행할 수 있다. 파일을 압축한다. -&gt; 이 단계에서 장치가 충전 중이어야 한다는 제한 조건을 추가할 수 있다. 서버에 업로드 한다. -&gt; 이 요청의 경우 네트워크가 사용 가능할 때만 작업이 실행되도록 네트워크 연결 제한 조건을 추가해야 한다. 두 작업을 모두 큐에 넣은 뒤 WorkManager와 함께 필요한 리소스가 충족할 때 작업을 수행하도록 할 수 있다. 또 다른 장점으로는 전원 관리 기능을 존중하는 것이다. WorkManager는 제약 조건이 충족되며, Doze가 해제된다면 주어진 작업을 실행할 것이다. 자세한 내용은 다음 포스팅에서 정리할 예정이다. Foreground Service 앱에서 음악, 비디오 재생 또는 탐색과 같이 앱을 종료하거나 화면을 꺼도 지연되지 않고 사용자가 시작한 작업을 완료해야 하는 경우 Foreground Service를 사용해야 한다. Foreground Service를 사용한다는 것은 중요한 일을 하고 있으므로 죽여서는 안된다는 것을 시스템에 알린다. 그리고 Notification Bar에 띄워서 Foreground Service가 수행 중임을 표시해야 한다. Alarm Manager 정확한 시간에 작업을 실행해야 하고 사용자와 상호 작용이 포함되며 지연될 수 없는 경우 사용하면 된다. Alarm Manager는 사용자가 지정한 시간에 필요한 경우 사용자의 앱을 실행한다. 그러나 작업이 정확한 시간에 실행될 필요가 없다면 WorkManager가 더 나은 방법이다. WorkManager는 시스템 자원의 균형을 더 잘 맞출 수 있다. 예를 들어, 매 시간마다 작업을 실행해야 하지만 특정 시간에 작업을 실행할 필요가 없는 경우, WorkManager를 사용하여 반복 작업을 설정하면 된다. 또한, 알람이 발생하면 작업을 짧은 시간내에 끝내야 한다. 네트워크에 접근하지 못할 수도 있다.(도즈모드나 앱 대기 버킷 때문에) 네트워크가 필요하거나 시간이 오래 걸리는 작업을 수행하려면 위에서 언급한 WorkManager를 사용해야 한다. 알람이 울릴 때마다 장치는 저전력 모드를 벗어나 부분적 wake-lock을 유지하므로 시간이 지남에 따라 배터리 수명에 상당한 영향을 줄 수 있다. Download Manager 사용자가 앱을 통해서 시간이 오래 걸리는 Http 다운로드를 수행하고 있다면 Download Manager를 사용하면 된다. 클라이언트는 URI를 앱 프로세스 외부에 있을 수 있는 특정 대상 파일로 다운로드하도록 요청할 수 있다. Download Manager는 백그라운드에서 다운로드를 수행하여 Http 상호 작용을 관리하고 실패 후 또는 연결 변경 및 시스템 재부팅 전반에 걸쳐 다운로드를 재시도 한다. 요약하면 아래와 같다. 파일을 다운로드 할 때 다운로드 매니저를 사용하면 될 것으로 예상이된다. 하지만, 다운로드 같은 경우 백그라운드에서 동작하고 시간이 오래 걸릴 수도 있기 때문에 백그라운드 정책에 위반될 상황이 생길 수도 있을 것 같다. 하지만, 다운로드 매니저가 내부적으로 어떻게 구현되어있는지 모르기 때문에 아직 확신할 수 없다. 관련 내용을 조금 더 찾아봐야 할 것 같다. 참고 새로운 안드로이드 백그라운드 실행 정책 Guide to background processing - 공식 문서","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"Oreo","slug":"Oreo","permalink":"https://woovictory.github.io/tags/Oreo/"},{"name":"백그라운드 실행 정책","slug":"백그라운드-실행-정책","permalink":"https://woovictory.github.io/tags/백그라운드-실행-정책/"}]},{"title":"[Android] 버전별 백그라운드 정책","slug":"Android-Background-Policy","date":"2019-05-12T02:49:28.000Z","updated":"2020-03-01T10:28:44.634Z","comments":true,"path":"2019/05/12/Android-Background-Policy/","link":"","permalink":"https://woovictory.github.io/2019/05/12/Android-Background-Policy/","excerpt":"","text":"백그라운드 작업이 필요한데, 그 전에 구글에서 제한하고 있는 백그라운드 작업에 대해서 알아보려고 한다. 1. 버전별 백그라운드 정책 변천사 안드로이드는 큰 업데이트마다 배터리를 관리하기 위한 여러 기능들을 포함해왔다. 아래의 내용을 확인해보자. 롤리팝 5.0 : Job Scheduler의 등장. 작업을 미루거나 스케쥴링 할 수 있도록 함. 마시멜로우 6.0 : 도즈 모드 및 앱 대기모드 등장. 디바이스 또는 앱이 장시간 사용중이 아닐 때 즉, 화면이 꺼지고 충전중이 아닐 때, 네트워크의 접근을 제한하고 백그라운드 작업을 유예하기 시작. 누가 7.0 : 개선된 도즈모드 화면이 꺼지고 움직이지 않을 때 도즈모드의 하위 제약 조건이 적용되기 시작. 오레오 8.0 : 백그라운드 제약 백그라운드 서비스와 위치 갱신을 제약하기 시작. 파이 9.0 : 앱 대기 버킷, 배터리 세이버 개선. Oreo 버전 이상을 대상으로 업데이트 할 때 아래의 체크리스트를 확인하여 백그라운드 작업을 설정할 수 있다. 현재 사용하고 있는 방법 오레오 이상에서 사용해야 하는 방법 JobScheduler JobScheduler Firebase JobDispatcher Firebase JobDispatcher Background Service JobScheduler Foreground Service Foreground Service와 해당 서비스를 종료해야 할 액션(stopService) WorkManager 라이브러리가 현재는 Alpha 단계이기 때문에 위의 방법들로 개발해야 하지만 정식 버전이 출시된다면 거의 모든 경우를 WorkManager로 해결할 수 있을 것 같다. 기대해보자~ 2. 올바른 앱을 만드는 전략 백그라운드에서 수행하는 작업은 지연 가능할만한 작업들로 만든다. Foreground Service를 사용할 때는 노티피케이션을 반드시 제공하여 사용자가 서비스를 중지할 수 있도록 한다. 알람, 네트워크 및 FCM 메시지와 같은 OS 기반의 작업에서는 이와 관련된 전원 관리 제한사항에 대한 문서 내용을 확인해보자. 참고 안드로이드 버전별 백그라운드 정책 백그라운드 실행 제한 - 공식문서","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"백그라운드 정책","slug":"백그라운드-정책","permalink":"https://woovictory.github.io/tags/백그라운드-정책/"}]},{"title":"[안드로이드] Service","slug":"What-is-Service","date":"2019-05-12T01:31:56.000Z","updated":"2020-05-26T07:05:30.062Z","comments":true,"path":"2019/05/12/What-is-Service/","link":"","permalink":"https://woovictory.github.io/2019/05/12/What-is-Service/","excerpt":"","text":"1. Service란? Service는 안드로이드 Application을 구성하는 4대 컴포넌트 중 하나이다. Activity처럼 사용자와 상호 작용을 하는 컴포넌트는 아니다. 때문에 UI가 존재하지 않으며 Background에서 동작하는 컴포넌트이다. Service가 실행되고 있는 상태라면 안드로이드 OS에서는 해당 Process를 왠만하면 죽이지 않도록 방지하고 관리하게 된다. 그렇기 때문에 메모리 부족이나, 특별한 경우를 제외하고는 Background 동작을 수행하도록 설계되었다. 2. Service는 왜 필요할까? 'Android Application을 구성하기 위해서 Service는 왜 필요할까?'라고 생각을 할 수 있다. 그 이유는 Activity 즉, 사용자가 보고 있는 화면이 종료된 상태에서도 동작하기 위해서 만들어졌고, 개발자는 구현을 해야 한다. 예를 들어서 Mp3 플레이어 같은 기능을 활용하는 경우가 될 수 있다. Mp3 플레이어는 화면이 종료된 상태에서도 계속 노래를 재생해야 하기 때문에 Background에서도 동작하도록 만들어야 한다. 따라서 Service를 사용해 구현하면 된다. 파일 다운로드 같은 경우에도 사용할 수 있다. 애플리케이션이 실행 중이지 않을 때도 작업해야 하는 경우에도 사용할 수 있다.(애플리케이션이 실행 중일 때만 작업해야 하는 경우 스레드 사용을 권장한다.) 주의 Service가 Background에서 동작을 수행하는 컴포넌트라고 해서 Main Thread에서 실행되는 것이라고 생각하지 않을 수도 있다. 명심해야 할 점은 Android 4대 컴포넌트들은 모두 Main Thread에서 실행된다. 따라서 CPU 자원을 많이 소모하거나 네트워크 통신과 같은 시간이 오래 걸리는 작업은 별도의 Thread를 만들어서 처리해야 한다. 이 부분은 아래에서 ANR과 함께 설명하겠다. 3. Service 사용 방법 2가지 방법이 있으면 startService()와 bindService()이다. startService() - 시작 타입의 서비스 서비스를 상속받는 클래스를 작성하며, 정적 리시버와 유사하게 매니페스트 파일에 등록한다. 한 번 시작되면 백그라운드에서 무한정 실행된다. 작업을 완료하면 서비스가 종료된다. 간단한 작업들만 수행한다. 호출한 곳에 결과값을 반환하지 않고 계속해서 서비스한다.(음악 재생, 파일 다운로드 등) 하나의 프로세스 안에서 동작하며, 패키지내 컴포넌트들과 유기적으로 통신하는 역할을 한다. 생명 주기 : onCreate() -&gt; onStartCommand() -&gt; 실행 -&gt; onDestroy() -&gt; stopService() bindService() - 연결 타입의 서비스 클라이언트 - 서버와 같이 동작하며 호출자(액티비티)에서 서비스에게 어떤 것을 요청하고 서비스는 요청을 처리한 후 결과값을 반환한다. (서비스가 서버의 역할을 수행.) 액티비티가 사라지면 서비스도 자동적으로 destroy되면서 없어진다. 하나의 서비스가 다수의 액티비티와 연결될 수 있다. 프로세스 내에서 다른 컴포넌트들과 서로 유기적으로 통신을 하며 또한, 어플 내의 기능을 외부에 제공하는 경우에 많이 사용된다. 즉, 다른 프로세스들 간에서도 Data 공유 및 통신이 유기적으로 가능하다. 생명 주기 : onCreate() -&gt; onBind() -&gt; 실행 -&gt; onUnbind() -&gt; onDestory() -&gt; stopService() intentService 내부적으로 handlerThread가 동작하는 서비스 루퍼가 message Queue에 들어온 요청에 대해 순차적으로 처리한다. Queue가 비게 되면 자동으로 서비스가 종료된다. 동시에 처리하는게 아니므로 성능은 조금 떨어지지만 순차적 실행이 보장된다. 4. Service 사용시 주의사항. Android는 Linux 기반의 프로그램이다. 프레임워크 단에는 Linux로 구현되어 있다. 메모리 관리 또한 Linux 정책을 따르며 Linux Kernel에 의해서 관리된다. 결국 여러 프로세스들을 커널에서 관리한다고 짐작할 수 있다. 또한 하나의 프로세스 안에는 애플리케이션, 안드로이드 4대 컴포넌트, 스레드 등을 구성하고 있다. 즉, 4대 컴포넌트의 운명 또한 리눅스 커널에 달려있다는 걸 의미한다. 만약, 메모리 부족이나 과부하 등과 같은 현상이 발생했을 때 리눅스 커널이 프로세스를 강제로 종료시킬 수 있다. 여기서 주의해야 할 점이 있다. 바로 모든 컴포넌트들이 Main Thread 안에서 실행된다는 점이다. 안드로이드에서 Main Thread는 UI 작업을 처리하는 Thread이다. 따라서 Main Thread에서는 네트워크 작업이나 시간이 오래 걸리는 작업을 하게 되면 앱의 반응성이 낮아질 수 있다. 사용자의 불편함을 방지하고나 시스템이 ANR 상태로 전환시킬 수 있다. Service 역시 Main Thread에서 동작하기 때문에 시간이 오래 걸리는 작업을 할 경우에는 별도의 작업 Thread를 만들어서 동작을 처리해야 한다. 그리고 작업 결과를 UI Thread에 반영하기 위해서 쓰레드 간 통신 방법을 이용해 반영해야 한다. 쓰레드간 통신 방법은 다음의 글을 참고하면 보면 될 것 같다. 쓰레드간 통신 방법 추가적인 내용들은 빠른 시일 내에 공부해서 포스팅할 예정이다. 참고 [Android] 서비스(Service) 전반적인 개념 안드로이드/Android Service 사용법","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Service","slug":"Service","permalink":"https://woovictory.github.io/tags/Service/"},{"name":"4대 컴포넌트","slug":"4대-컴포넌트","permalink":"https://woovictory.github.io/tags/4대-컴포넌트/"}]},{"title":"[Android] Work Manager","slug":"What-is-WorkManager","date":"2019-05-12T01:29:10.000Z","updated":"2020-05-26T07:05:38.853Z","comments":true,"path":"2019/05/12/What-is-WorkManager/","link":"","permalink":"https://woovictory.github.io/2019/05/12/What-is-WorkManager/","excerpt":"","text":"이번에 공부할 내용은 WorkManager이다. 백그라운드를 다루는 안드로이드의 새 버전들의 출시로 인해, 백그라운드 다루기는 이전보다 더 복잡해져다. 그래서 구글은 JetPack의 일부로 이러한 백그라운드 작버을 도와주기 위해 WorkManager를 출시했다. 먼저, 왜 만들어지게 되었고, 왜 필요한지를 알 필요가 있다고 생각한다. 사용하는 것도 중요하지만 내가 왜 사용하는지 이유를 알고 쓰는게 더 중요하기 때문이다. 아래와 같은 3개의 구성으로 나누도록 하겠다. 메모리 현재 존재하는 백그라운드 처리 방법 WorkManager 1. 메모리 안드로이드 커널은 리눅스 커널을 기반으로 해서 만들어졌다. 안드로이드 커널과 모든 리눅스 커널들의 가장 큰 차이점은 스왑 공간(Swap Space)가 없다는 것이다. 리눅스의 스왑공간은 램이 꽉 찼을 때 사용된다. 시스템은 더 많은 메모리 리소스를 필요로 하지만 램이 꽉 찼을 때, 메모리 상의 비활성 페이지를 스왑 공간으로 이동시킨다. 스왑공간은 램의 용량이 작은 디바이스에 도움이 되긴 하지만, 램의 용량을 늘리는 것을 대체할 수는 없다. 스왑공간은 램보다 Access time이 훨씬 느린 하드 드라이브에 위치하기 때문이다. 안드로이드에서는 스왑공간 같은 개념이 없다. 시스템의 메모리가 다 소진되었을 때, OOM 킬러를 이용해 프로레스스 강제 종료시켜버린다. OOM 킬러는 Visible 상태와 소모된 메모리의 양에 기반하여 프로세스를 정리하여 여유 메모리를 확보한다. 모든 프로세스는 액티비티 매니저가 부여한 자신의 oom_adj 점수를 가지고 있다. 이 점수는 애플리케이션의 상태(Foreground, Background, Background Service 등등)의 조합이다. 아래는 모든 oom_adj 값을 보여준다. 12345678910# Define the oom_adj values for the classes of processes that can be# killed by the kernel. These are used in ActivityManagerService. setprop ro.FOREGROUND_APP_ADJ 0 setprop ro.VISIBLE_APP_ADJ 1 setprop ro.SECONDARY_SERVER_ADJ 2 setprop ro.BACKUP_APP_ADJ 2 setprop ro.HOME_APP_ADJ 4 setprop ro.HIDDEN_APP_MIN_ADJ 7 setprop ro.CONTENT_PROVIDER_ADJ 14 setprop ro.EMPTY_APP_ADJ 15 프로세스의 oom_adj의 값이 클수록 커널의 OOM 킬러에게 정리당하기 쉽다. OOM 킬러는 현재 사용 가능한 여유메모리 크기와 oom_adj 임계값을 기반으로 구성한 규칙을 사용한다. 즉, OOM 킬러의 조건은 아래와 같다. 여유 메모리 공간의 크기가 X보다 작을 때, oom_adj 값이 Y보다 큰 프로세스를 정리하라! 즉, 앱이 메모리를 적게 소비할수록 프로세스가 정리되지 않고 중요한 내용을 다룰 기회가 더 많아진다는 것이다. 두번째로 중요한 내용은 애플리케이션의 상태에 대해 이해하는 것이다. 그래서 앱이 백그라운드에 진입했을 때에도 뭔가를 지속적으로 하고 싶다면 서비스 컴포넌트를 사용해야 한다. 서비스는 UI를 제공하지 않고, 백그라운드에서 오래 걸리는 동작을 수행할 수 있도록 하는 4대 컴포넌트 중 하나이다. 서비스를 사용해야 했던 이유는 아래와 같다. 시스템에게 이 프로세스가 오래 걸리는 작업이 있음을 알려주고, 그에 맞는 oom_adj 점수를 얻도록 하기 위함이다. 안드로이드 애플리케이션의 4대 컴포넌트 중 하나이다. 서비스를 별개의 프로세스에서 실행시킬 수 있다. 사용했을 때의 이점이 있기 때문에 좋아 보인다. 하지만, 서비스 사용의 단점이 있다. 프로세스가 계속 실행되고 있는 것이므로 배터리를 엄청나게 소모한다. 마시멜로우 버전부터 도즈 모드(Doze)가 도입되었다. 누가 버전에서 더 발전되었고 오레오 버전에서 더욱 강화되었다. 도즈 모드는 사용자가 디바이스의 스크린을 끄고 나면 네트워크 통신, Sync, GPS, 알람, 와이파이 스캔 등을 비활성화 시켜버린다. 사용자가 스크린을 켜거나 디바이스를 충전기에 연결할 때까지 유지된다. 그리고 중요하지 않은 일을 수행하는 앱의 개수를 줄임으로써 디바이스의 배터리를 절약하도록 한다. 또한, 오레오 버전으로 타게팅된 앱이 백그라운드 서비스 생성을 허가받지 않은 채로 startService() 메소드를 호출하려고 하면 백그라운드 서비스 제한이 있어서 IllegalStateException 예외를 던진다. '그럼 오레오 버전으로 타게팅 하지 않으면 되잖아?'라고 생각할 수 있다. 구글의 정책을 살펴보도록 하자. 2018년 8월 : 새로 출시되는 앱들은 반드시 API 26(Oreo 8.0) 이상 2018년 11월 : 기존 앱들도 API 26(Oreo 8.0) 이상. 2019년 이후 : 매년 targetSdkVersion 요구사항이 향상될 것이다. 안드로이드가 매년 새로운 버전을 낼 때마다, 모든 앱들은 해당 API 레벨 이상을 타겟팅 해야 한다. 이를 통해 알 수 있는 것은 백그라운드 작업을 위해 더 이상 서비스를 사용하지 않게 될 것이라는 것이다. 2. 현재 존재하는 백그라운드 처리 방법 AlarmManager와 BroadcastReceiver 사용 지정한 타이밍에 시스템에서 알림이 오고 여기에 맞춰 백그라운드 작업을 수행할 수 있었다. 하지만, 킷캣(K, API 19) 버전에서는 알림이 미뤄지거나 한 번에 몰아서 오는 등 정확한 실행을 보장하지 않게 된다. BroadcastReceiver를 통해서 기기의 부팅, 네트워크 연결 등의 디바이스 이벤트를 시스템으로부터 전파받아서 특정 작업을 수행해왔는데 누가(N, API 24)버전에서 특정 인텐트에 대한 동작이 제한되고, 오레오(O, API 26)버전에서 암시적 브로드캐스트 리시버 등록을 차단하는 등 제한이 추가되고 있다. 그래서 대안책이 Job을 사용하는 것이다. JobScheduler 사용 롤리팝(L, API 21) 버전에서 JobScheduler를 제공한다. 부정확해진 Alarm Manager의 대안이기도 했고, 결국 백그라운드 작업을 배제할 수 없었기 때문이다. 하지만, API 2에서 사용할 수 있다는 제약으로 인해 API 21 이전과 이후 버전을 나누어 AlarmManager와 JobScheduler를 각각 사용해서 구현해야 하는 번거로운 문제가 생겼다. JobDispatcher 사용 이후에 구글은 Firebase JobDispatcher를 제공하기 시작했다. JobDispatcher는 진저브레드(G, API 9) 버전 이상을 지원한다. 그리고 내부적으로 AlarmManager와 JobScheduler를 선택해준다. 이를 통해서 개발자가 하는 일은 한 가지로 줄었으나, 구글 플레이 서비스에 의존하게 되어 아마존/주욱 제조사 디바이스에서는 기능을 사용할 수 없다. 결국, 구글 플레이 서비스를 지원하지 않는 디바이스에서는 AlarmManager와 JobScheduler를 각각 사용해서 구현해야 한다. JobIntentService 사용 다른 대안으로 JobIntentService를 사용하는 방법이 있다. 하지만, 정확한 시간에 작업이 수행되지 않기 때문에 오레오에서 Job을 빨리 수행하는데는 도움이 되지 않는다. Android-Job(Evernote) 라이브러리(Third party library) 사용 이는 자동으로 안드로이브 버전에 따라 AlarmManager, JobScheduler, JobDispatcher들 중 어떤 것을 사용할지 결정해주는 라이브러리이다. WorkManager를 제외하고 생각한다면 가장 좋은 라이브러리라고 평가받고 있다. 하지만, Evernote가 새로운 가이드 안을 발표했다. 안드로이드 버전에 따라 백그라운드 API가 수시로 변경되어서 버전별로 분기가 필요하고 복잡한 API 사용이 힘들었을텐데 앞으로 Evernote는 Android Job 라이브러리를 배포하여 개발자들에게 편의를 제공해왔지만 더 이상 지원하지 않고 WorkManager 사용을 권장한다는 내용이다. 결국, 현재 실행 중인 안드로이드 버전에 따라서 백그라운드 서비스 API를 다르게 호출시키고 관리해야 한다. 디바이스의 안드로이드 버전과 구글 플레이 서비스 여부에 따라 백그라운드 서비스를 지원하기 까다롭다. 그래서 Google I/O에서 WorkManager라는 해결책을 제공해주었다. 3. WorkManager 2018년 Google I/O에서는 안드로이드의 백그라운드 작업을 도와줄 WorkManager가 공개되었다. WorkManager는 Android JetPack의 아키텍처의 구성 요소이다. WorkManager는 다음과 같은 특징을 갖는다. 실행이 보장된다. 또한 제약 조건을 가지고 실행할 수 있다. 예를 들어, 네트워크 연결시에만 처리되는 작업을 추가하면 네트워크가 연결되면 반드시 실행된다. 장치의 상태를 존중한다. 도즈 모드에 진입하면 일을 처리하기 위해 기기를 깨우거나 하지 않는다. 실행 중인가, 대기 중인가, 완료되었는가 등의 상태 조회가 가능하다. 작업 A의 결과에 따라 B 또는 C를 선택하여 처리하고 D를 이어서 처리하는 등의 작업 연결 처리가 가능하다.(체이닝) 첫 번째 특징과 비슷하며 기회주의적이다. 즉, 어떤 제한 조건이 충족되었을 때 즉시 실행된다. WorkManager는 내부적으로 아래의 그림과 같이 동작한다. API의 버전에 맞게 AlarmManager와 JobScheduler를 사용하고 개발자가 Firebase JobDispatcher 의존성을 추가했다면(즉, 구글 플레이 서비스 사용이 가능하다면)JobDispatcher를 적극 사용한다. 개발자는 WorkManager를 사용함으로써 상황에 맞는 고민이나 별도의 구현 없이 앱의 종료나 기기의 재부팅된 경우에도 항상 장치에 맞는 가장 적합한 방법을 사용하여 백그라운드 작업을 처리할 수 있게 된다. 그러나 WorkManager가 항상 최선은 아니다. 앱의 종료 여부와 상관없이 수행되어야 하는 작업, 즉 앱의 프로세스 수명과 별도로 살아남기 위한 작업에 사용하는 것을 추천한다. 예를 들어 이미지를 서버에 업로드해야 하거나, 데이터를 분석하고 이를 데이터베이스에 저장해야 하는 작업에는 WorkManager를 사용하는 것이 좋다. 그러나 사용자가 현재 보고 있는 UI를 빠르게 변경해야 하는 작업이나 물건 구입 과정에서의 결제 진행 등 즉시 처리해야 하는 작업은 WorkManager를 사용하지 않는 것이 좋다. WorkManager의 작업은 반드시 실행되지만 그 처리가 상황에 따라 지연되거나 도중에 중단될 경우 다시 실행될 수 있다는 것을 꼭 기억해야 한다. 적절한 상황에서는 WorkManager는 AlarmManager나 JobScheduler, JobDispatcher를 대체하는 훌륭한 백그라운드 작업 처리 방법이다. 다음에는 WorkManager를 사용해보는 시간을 갖도록 하겠다. 참고 WorkManager로 안드로이드 하위 버전부터 오레오 버전까지 백그라운드 작업 통합 [안드로이드] WorkManager에 관하여 새로운 안드로이드 백그라운드 작업 처리법 : WorkManager","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"},{"name":"WorkManager","slug":"WorkManager","permalink":"https://woovictory.github.io/tags/WorkManager/"}]},{"title":"[안드로이드] ViewModel 초기화 - 1","slug":"How-to-initialize-of-viewModel","date":"2019-05-11T15:45:47.000Z","updated":"2020-05-12T11:30:54.403Z","comments":true,"path":"2019/05/12/How-to-initialize-of-viewModel/","link":"","permalink":"https://woovictory.github.io/2019/05/12/How-to-initialize-of-viewModel/","excerpt":"","text":"이번 포스팅에서 다룰 주제는 Android Architecture Components 중 하나인 ViewModel이다. 해당 안드로이드 앱 개발을 하다보면 겪는 문제 중 하나는 생명주기와 관련된 것이다. 그 중에서 액티비티와 프래그먼트의 생명주기는 많은 상태와 여러 가지 케이스에 따른 복잡함으로 예전부터 지금까지도 우리에게 까다로운 존재임이 분명하다. 예를 들면, 런타임에 화면 방향이 전환되거나 언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우를 다루려면 세심한 처리가 필요하다. 이러한 변경이 일어나는 경우, 안드로이드는 실행 중인 액티비티를 종료하고 메모리에서 제거한 후 다시 생성하기 때문에 이 과정에서 액티비티에 종속된 UI 데이터를 유지하는 것은 손이 많이 가는 작업이다. 화면 회전에 대한 해결책 액티비티가 종료되기 직전 호출되는 onSaveInstanceState() 콜백에서 액티비티의 상태 또는 데이터를 저장할 수 있지만 직렬화할 수 없는 객체는 저장할 수 없다. 왜냐하면 이 방법은 애초에 많은 양의 데이터를 저장하기 위해 디자인되지 않았기 때문이다. 이번에 공부하면서 처음 본 방법이 또 있다. 유보된 프래그먼트(Retained Fragment)를 사용하는 방법이다. UI가 없는 워크(헤드리스) 프래그먼트 개념을 도입해 이곳에서 UI에 필요한 데이터를 관리하고 프래그먼트를 setRetainInstance(true)로 설정함으로써 액티비티 재생성시, 프래그먼트를 메모리에 유지(즉, 소멸시키지 않고 유보)시키는 것이다. 이때 프래그먼트는 액티비티에서 분리(onDetach)된 후 새로운 액티비티로 다시 호스팅(onAttach)될 뿐 소멸과 생성을 반복하지 않는다. 하지만, 프래그먼트 도입은 또 다른 **엣지 케이스(일정한 범위를 넘었을 때, 발생하는 문제)**를 다뤄야 한다는 점에서 새로운 고난의 장을 여는 것을 의미하기도 한다. 그리고 이곳이 데이터를 보관하기에 적합한 곳인가? 혹은 오버 엔지니어링이 아닐까?라는 논쟁의 여지가 존재했다. 프래그먼트 이슈에 지친 개발자들은 프래그먼트 없이 개발하기와 같은 방법론에 매료될 정도로, 프래그먼트는 혼란스러움을 대표했다. ViewModel로 해결하기.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://woovictory.github.io/tags/ViewModel/"}]},{"title":"[개발상식]객체 지향 디자인의 5대 원칙","slug":"What-is-SOLID","date":"2019-05-10T03:27:56.000Z","updated":"2020-05-12T15:12:51.702Z","comments":true,"path":"2019/05/10/What-is-SOLID/","link":"","permalink":"https://woovictory.github.io/2019/05/10/What-is-SOLID/","excerpt":"","text":"좋은 객체지향 설계를 위해서 다음의 5가지 원칙을 따르는 것이 좋고, 이 원칙들을 기반으로 디자인 패턴이 되기 때문에 알아두면 확실하게 도움이 된다. 객체지향의 5대 원칙의 앞글자를 따서 SOLID라고 부르기도 한다. 1. SRP SRP(Single Responsibility Principle)는 단일 책임 원칙이라고 한다. 모든 클래스는 단 하나의 책임을 갖는다. 다시 말해서 클래스를 변경할 이유는 오직 하나여야 한다는 뜻이다. 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄 작용에서 자유로울 수 있다. 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이의 이점이 생긴다. 간단한 예를 들면, 계산기 클래스가 있을 때, 계산을 하는 책임과 GUI를 나타내는 책임은 서로 분리되어야 한다. 계산기 클래스에 GUI를 나타내는 부분까지 있을 경우, 이는 SRP를 위반한다. Before Code 123456789101112131415// 현재 UserSettingService 클래스에는 두 개의 책임이 있다.// 1. 변경// 2. 접근 권한에 대한 부분public class UserSettingService&#123; public void changeEmail(User user)&#123; if(checkAccess(user))&#123; // do someting &#125; &#125; public boolean checkAccess(User user)&#123; // user check &#125;&#125; After Code 123456789101112131415161718// 현재 UserSettingService 클래스의 두 개의 책임을 둘로 나눈다.// 1. 변경(UserSettingService.class)// 2. 접근 권한에 대한 부분(SecurityService.class)public class UserSettingService&#123; public void changeEmail(User user)&#123; if(SecurityService.checkAccess(user))&#123; // do something. &#125; &#125;&#125;public class SecurityService&#123; public static boolean checkAccess(User user)&#123; // Check user access. &#125;&#125; 2. OCP OCP(Open-Closed Principle)는 개방 폐쇄 원칙이라고 한다. 기능을 확장하거나 변경하는 것에 대해서는 개방되어야 하지만, 수정에 대해서는 폐쇄되어야 한다. 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 한다는 의미이다. 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 하며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 한다는 뜻이다. 중요 매커니즘은 추상화와 다형성이다. 예를 들자면, 캐릭터를 하나 생성한다고 가정하자. 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴 구현을 하위 클래스에 맡긴다면 캐릭터 클래스의 수정은 필요없고(수정에 대해 폐쇄) 움직임의 패턴만 재정의하면 된다.(확장에 대한 개방) OCP 원칙이 깨질 때의 주요 현상 다운 캐스팅을 한다. 12345678public void drawCharacter(Character character)&#123; if(character instanceof Missile)&#123; // 타입 확인. Missile missile = (Missile) character; // 다운 캐스팅. missile.drawSpecific(); // 미사일일 경우 drawSpecific() 호출. &#125;else&#123; character.draw(); // 미사일 외의 경우는 draw() 호출. &#125;&#125; 비슷한 if-else 블록이 존재한다. 1234567891011121314151617181920212223public class Enemy extends Character&#123; private int pathPattern; public Enemy(int pathPattern)&#123; this.pathPattern = pathPattern; &#125; public void draw()&#123; if(pathPattern == 1)&#123; x +=5; y +=5; &#125;else if(pathPattern == 2)&#123; x +=10; y +=10; &#125;else if(pathPattern == 3)&#123; x +=15; y +=15; &#125;else&#123; x +=20; y +=20; &#125; &#125;&#125; OCP는 자주 사용되는 문법이 인터페이스라고 보면 된다. Before Code 1234567891011121314// 음악을 재생하는 클래스.class SoundPlayer&#123; void play()&#123; System.out.print(\"play wav\"); // wav 재생. &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; SoundPlayer sp = new SoundPlayer(); sp.play(); &#125;&#125; SoundPlayer 클래스는 기본적으로 wav 파일을 재생할 수 있다. 하지만 다른 포맷의 파일, 예를 들어 mp3 파일을 재생하도록 요구사항이 변경된다면 어떻게 될까? 이 요구사항을 만족시키기 위해서 SoundPlayer 클래스의 play() 메소드를 수정해야 한다. 그러나 이와 같은 소스 코드 변경은 OCP 원칙에 위배되는 행위다. 인터페이스를 이용해 OCP 원칙을 지켜보자. 먼저 변해야 하는 것이 무엇인지 정의한다. 위의 예에서는 play() 메소드가 변해야 한다. 따라서 play() 메소드를 인터페이스로 분리한다. 1234567891011121314151617interface playFile()&#123; public void play();&#125;class Wav implements playFile()&#123; @Override public void play()&#123; System.out.print(\"Play wav\"); &#125;&#125;class Mp3 implements playFile()&#123; @Override public void play()&#123; System.out.print(\"Play Mp3\"); &#125;&#125; 재생하고자 하는 파일 클래스(Wav, Mp3)를 만들어 playFile 인터페이스와 play() 메소드를 재정의하도록 설계한다. 123456789101112131415161718192021class SoundPlayer&#123; private playFile file; public void setFile(playFile file)&#123; this.file = file; &#125; public void play()&#123; this.play(); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; SoundPlayer sp = new SoundPlayer(); sp.setFile(new Wav()); // 원하는 재생 파일 선택. sp.serFile(new Mp3()); sp.play(); &#125;&#125; SoundPlayer 클래스에서는 playFile 인터페이스를 멤버 변수로 만든다. 그 후 SoundPlayer의 play() 함수는 인터페이스를 상속받아 구현된 클래스의 play() 함수를 실행시키게 한다. main() 함수에서 setFile() 함수를 이용해 우리가 재생하고자 하는 파일의 객체를 지정해준다. 이와 같은 설계를 디자인 패턴에서는 Strategy Pattern(전략 패턴)이라고 한다. 디자인 패턴은 추후에 공부할 필요가 있을 것 같다. 아무튼 결과적으로 SoundPlayer 클래스의 변경 없이 재생되는 파일을 바꿀 수 있으므로 위 코드는 OCP 원칙을 만족하게 된다. OCP 원칙을 적용한 설계는 변경에 유연하므로 유지보수 비용을 줄여주고 코드의 가독성 또한 높아지는 효과를 얻을 수 있다. 3. LSP LSP(Liskov Substitution Priciple)는 리스코프 치환 원칙이라고 한다. 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. 쉽게 말하면, 자식 클래스는 언제나 자신의 부모 클래스를 교체할 수 있다는 원칙이다. 즉, 부모 클래스와 자식 클래스 사이의 행위에는 일관성이 있어야 한다는 원칙이다. 상속 관계에서는 일반화 관계(IS-A)가 성립해야 한다. 일반화 관계에 있다는 것은 일관성이 있다는 것이다. 따라서 리스코프 치환 원칙은 일반환 관계에 대해 묻는 것이라 할 수 있다. 이해를 돕기 위해 도형을 예로 하는 설명이 있다. 도형 클래스와 사각형 클래스가 있고, 사각형 클래스는 도형 클래스를 상속한다. (1). 도형은 둘레를 가지고 있다. (2). 도형은 넓이를 가지고 있다. (3). 도형은 각을 가지고 있다. 일반화 관계(일관성인지 확인하는 방법은 단어를 교체해보면 알 수 있다. 도형 대신 사각형을 넣어보자.) (1). 사각형은 둘레를 가지고 있다. (2). 사각형은 넓이를 가지고 있다. (3). 사각형은 각을 가지고 있다. 이상한 부분이 보이지 않는다. 따라서 도형과 사각형 사이에는 일관성이 있다고 할 수 있다. 그럼 원이라는 도형에 대해서 생각해보자. 원 클래스 역시 도형 클래스의 상속을 받는다고 가정하고 (1) ~ (3)의 도형 단어 대신 원을 대입해보자. (1). 원은 둘레를 가지고 있다. (2). 원은 넓이를 가지고 있다. (3). 원은 각을 가지고 있다. 원의 경우에는 (3)번 문장이 어색하다는 것을 알 수 있다. 따라서 도형 클래스는 LSP 원칙을 만족하지 않는 설계라고 할 수 있다. (3) 문장에 대해서 일반화 관계가 성립하도록 수정되어야 한다. 4. ISP ISP(Interface Segregation Priciple)는 인터페이스 분리 원칙이라고 한다. 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다. 즉, 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야 한다는 의미이다. 클라이언트는 자신이 사용하지 않는 메소드에 의존하지 않아야 한다. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않는 편이 낫다. 하나의 일반적인 인터페이스보다는 차라리 여러 개의 구체적인 인터페이스가 낫다는 개념을 갖는다. 한 가지 예를 들어보자. 우리는 스마트폰으로 전화, 웹서핑, 사진 촬영 등 다양한 기능을 사용할 수 있다. 그런데 전화를 할 때에는 웹 서핑, 사진 촬영 등 다른 기능은 잘 사용하지 않는다. 따라서 전화 기능과 웹 서핑 기능, 사진 촬영 기능은 각각 독립된 인터페이스로 구현하여, 서로에게 영향을 받지 않도록 설계해야 한다. 이렇게 설계된 소프트웨어는 ISP를 통해 시스템 내부의 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다. Before Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 하나의 인터페이스를 모든 클라이언트가 구현하고 있다.public interface ArticleService&#123; void list(); void write(); void delete();&#125;public class UiList implements ArticleService&#123; @Override public void list()&#123; &#125; @Override public void write()&#123; &#125; @Override public void delete()&#123; &#125;&#125;public class UiWist implements ArticleService&#123; @Override public void list()&#123; &#125; @Override public void write()&#123; &#125; @Override public void delete()&#123; &#125;&#125;public class UiDist implements ArticleService&#123; @Override public void list()&#123; &#125; @Override public void write()&#123; &#125; @Override public void delete()&#123; &#125;&#125; After Code 123456789101112131415161718192021222324252627282930313233// 각각의 클라이언트별로 interface를 구분한다.public interface ArticleListService&#123; void list();&#125;public interface ArticleWriteService&#123; void write();&#125;public interface ArticleDeleteService&#123; void delete();&#125;public class UiList implements ArticleListService&#123; @Override public void list()&#123; &#125;&#125;public class UiWist implements ArticleWriteService&#123; @Override public void write()&#123; &#125;&#125;public class UiDist implements ArticleDeleteService&#123; @Override public void delete()&#123; &#125;&#125; 5.DIP DIP(Dependency Inversion Principle)는 의존성 역전 원칙이라고 한다. 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다. 고수준 모듈 : 어떤 의미있는 단일 기능을 제공하는 모듈 바이트 데이터를 읽어와 암호화하고 결과 바이트 데이터를 쓴다. 저수준 모듈 : 고수준 모듈의 기능을 구현하기 위해 필요한 개별 기능 = 좀 더 작은 모듈 파일에서 바이트 데이터를 읽어온다. AES 알고리즘으로 암호화한다. 파일에 바이트 데이터를 쓴다. 중간에 interface와 같은 추상화를 통해서 고수준 모듈과 저수준 모듈이 모두 추상 타입에 의존하게 만든다. 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙이다. 설명하는 말들이 어렵다. 모듈도 나오고 이런 추상 타입도 나온다… 쉽게 설명하면 DIP를 만족한다는 것은 의존 관계를 맺을 때, 구체적인 클래스보다는 인터페이스나 추상 클래스와 관계를 맺는다는 것을 의미한다. 이와 같은 말은 변화하기 어려운 것, 변화가 거의 없는 것에 의존하라고 한다. 의미는 변화하기 어려운 부분들을 추상화하여 인터페이스나 추상 클래스로 참조함으로써 DIP를 지킬 수 있다는 뜻이다. 예를 들어 핸드폰의 경우 전화를 하거나 문자를 보내거나 앱을 실행하는 것 자체는 변하기 어렵지만 브랜드의 가격, 모델 명등은 변하기 쉽다. 따라서 변하기 어려운 것은 추상화하여 인터페이스나 추상 클래스로 만들어 참조하면 DIP를 만족하게 될 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person&#123; private String name; private int age; private Phone phone; // getter/setter 생략.&#125;// Phone은 추상 클래스.public abstract class Phone&#123; private String phoneNumber; public String getPhoneNumber()&#123; return phoneNumber; &#125; public void setPhoneNumber(String phoneNumber)&#123; this.phoneNumber = phoneNumber; &#125; public abstract void call(String phoneNumber); public abstract void turnOn(); public abstract void turnOff();&#125;// 아래와 같이 상속받아 구현한다.public class GalaxyS7 extends Phone&#123; @Override public void call(String phoneNumber)&#123; System.out.println(\"Call to \"+phoneNumber); &#125; @Override public void turnOn()&#123; System.out.println(\"Turn on GalaxyS7\"); &#125; @Override public void turnOff()&#123; System.out.println(\"Turn off GalaxyS7\"); &#125;&#125; 만약 갤럭시 핸드폰이 아니라 LG의 G 시리즈나 아이폰 등도 Phone 클래스를 상속받아서 구현하여 Person의 인스턴스 객체의 속성으로 설정함으로서 의존성을 역전시켜 DIP 원칙을 만족할 수 있다. 객체지향 설계 5대 원칙을 공부해봤는데 DIP는 아직 이해가 잘 가지 않는 것 같다. 의존성은 결합도를 낮추는게 목표라고 생각한다. 그래서 느슨한 결합을 만들고 그 과정에서 인터페이스나 추상 클래스를 사용하는 것으로 이해가 된다. 이 부분은 아직 이해가 더 필요한 부분이니 차근 차근 공부해서 보충해나가자. 참고 객체지향 디자인의 5원칙(SOLID 원칙) [소프트웨어/SOLID] 의존 역전 원칙(DIP) SOLID 원칙 객체지향 개발 5대 원리: SOLID 객체지향 설계 5대 원칙 - SOLID","categories":[{"name":"개발 상식","slug":"개발-상식","permalink":"https://woovictory.github.io/categories/개발-상식/"}],"tags":[{"name":"객체지향 5대 원칙","slug":"객체지향-5대-원칙","permalink":"https://woovictory.github.io/tags/객체지향-5대-원칙/"},{"name":"SOLID","slug":"SOLID","permalink":"https://woovictory.github.io/tags/SOLID/"},{"name":"개발상식","slug":"개발상식","permalink":"https://woovictory.github.io/tags/개발상식/"}]},{"title":"[안드로이드] koin part.1","slug":"Android-koin","date":"2019-05-08T00:49:36.000Z","updated":"2020-03-01T10:25:03.501Z","comments":true,"path":"2019/05/08/Android-koin/","link":"","permalink":"https://woovictory.github.io/2019/05/08/Android-koin/","excerpt":"","text":"2019.07.19 기준으로 프로젝트에서 사용하던 koin의 버전을 올리니 에러가 발생했다. 이유는 버전이 업데이트 되면서 사용방법이 조금 바뀐 것이다. 바뀐 부분을 적어보겠다. 의존성 주입이라 함은 클래스(모듈) 간의 결합도를 낮추기 위해서 외부에서 객체 생성을 주입하는 것이다. 이러한 방법의 장점은 결합도를 낮추기 때문에 테스트 가능한 코드를 작성할 수 있다는 점과 유지보수가 편하다는 점을 생각할 수 있다. 그러면 의존성 주입을 위한 라이브러리 중 Dagger2와 koin이 있는데 전자는 학습 비용이 크다. 아직 나에게는 어려움이 많아서 먼저 koin을 공부하고 추후에 Dagger2를 사용하려고 한다. Koin 먼저 아래와 같은 의존성을 gradle에 추가해야 한다. koin_version = 2.0.1 123456// Koin AndroidX Scope featureimplementation \"org.koin:koin-androidx-scope:$koin_version\"// Koin AndroidX ViewModel featureimplementation \"org.koin:koin-androidx-viewmodel:$koin_version\"// Koin for Unit teststestImplementation \"org.koin:koin-test:$koin_version\" 1. 모듈 정의 Koin은 코틀린을 위한 의존성 관리 라이브러리이다. Dagger2에 비해서 간단한 코드로 구성할 수 있다. 알고 있어야 할 용어는 아래와 같다. module : Koin 모듈을 정의할 때 사용한다. factory : 객체를 가져올 Factory 패턴을 선언하며 inject할 때마다 새로운 객체를 가져오도록 한다. single : 앱이 살아있는 동안 전역적으로 사용 가능한 객체를 생성한다. bind : 생성할 객체를 다른 타입으로 바인딩하고 싶을 때 사용한다. get : 주입할 각 컴포넌트끼리의 의존성을 해결하기 위해 사용한다. 타입 추론을 통해 컴포넌트 내에서 이미 생성된 객체를 참조하게 된다. applicationContext : context를 주입한다. 다음과 같은 두 개의 클래스가 있다. 12345678910111213class BusinessService&#123; var name: String = \"Lee\" fun changeName(afterName: String) &#123; name = afterName &#125;&#125;class Controller(val service: BusinessService)&#123; fun print()&#123; println(service.name) &#125;&#125; 모듈 정의는 다음과 같다. single로 선언하였으므로, 앱 내에서 전역적으로 하나의 객체만 생성해서 사용한다. 1234val appModules = module&#123; single &#123; BusinessService() &#125; single &#123; Controller(get()) &#125;&#125; 2. 초기화 초기화는 정말 간단하다. 하지만, 변경된 사항이 있다. 1.X.X 버전에서 초기화 방식은 다음과 같다. 123456class MyApplication : Application()&#123; override fun onCreate()&#123; super.onCreate() startKoin(applicationContext, appModules) &#125;&#125; 2.X.X로 버전을 올리고 나서 초기화 방식은 이렇게 바뀌었다. 사실, 2.X.X 버전부터 바뀐 것인지 1.X.X 버전에서 변경된 것인지는 모르겠다… 123456789class MyApplication : Application()&#123; override fun onCreate()&#123; super.onCreate() startKoin&#123; androidContext(this@MyApplication) modules(appModules) &#125; &#125;&#125; 바뀐 부분은 startKoin 부분이다. androidContext와 modules를 명시적으로 호출해주고 있는 것을 확인할 수 있다. 이제 의존성 주입이 잘 동작하는지 확인해보자. 확인을 위해서 Activit에 작성해 에뮬레이터를 켜봐도 된다. 또는 실행해서 확인해봐도 되는데, 필자는 UnitTest를 해보도록 하겠다. 위에서 추가한 Koin Test 라이브러리를 사용해보겠다. gradle에 라이브러리를 추가해야 사용할 수 있다는 걸 명심해야 한다. 12345678910111213141516171819202122232425262728class SimpleTest : KoinTest&#123; // inject를 통해서 의존성을 주입받는다. val service : Business by inject() val controller : Controller by inject() @Test fun myTest()&#123; startKoin&#123; modules(appModules) &#125; service.changeName(\"Victory\") controller.print() val service2 : Business by inject() val controller2 = Controller(service2) val controller3 = Controller(get()) controller2.print() controller3.print() println(service.hashCode() == service2.hashCode()) &#125;&#125;// 결과VictoryVictoryVictorytrue by inject()는 항상 지연 초기화를 사용한다. 즉, 객체를 사용하는 시점에 생성하므로 성능상 이점을 가질 수 있다. single 로 객체를 생성하였기 때문에 주입 받은 객체는 동일한 객체이다. 따라서 Victory가 찍히는 것을 확인할 수 있고, 코드 마지막에 hashCode() 함수로 확인해보니 같은 객체임을 알 수 있다. 다른 객체를 생성하고 싶다면 factory를 사용하면 된다. 지금까지 모듈을 정의하고 정의된 모듈을 주입하는 것까지 공부해보고 간단하게 작성해봤다. 나에게 의존성 주입이라는 것이 처음에 어려웠다. 하지만, Koin을 통해서 차근 차근 이해하다보니 겁 먹었던 것에 비해 이해가 수월했다. 실제로 사용해보면서 느껴봐야 알겠지만, 확실히 사용하기 편하다는 느낌을 받았다. 테스트 가능한 코드를 작성할 수 있다는게 의존성 주입의 장점 중 하나인데, 빨리 공부를 좀 더 해서 테스트 코드까지 작성해보는 게 가까운 미래의 목표 중 하나이다. # 참고 Kotlin 안드로이드 의존성 주입 라이브러리 Koin을 소개합니다. Kotlin에서 Dagger2 쓰기 힘드니? 그럼 넌 Koin이야","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"DI","slug":"DI","permalink":"https://woovictory.github.io/tags/DI/"},{"name":"koin","slug":"koin","permalink":"https://woovictory.github.io/tags/koin/"}]},{"title":"[커니의 Kotlin] Chap2","slug":"kotlin-chap2","date":"2019-05-07T08:15:30.000Z","updated":"2020-05-12T15:19:09.908Z","comments":true,"path":"2019/05/07/kotlin-chap2/","link":"","permalink":"https://woovictory.github.io/2019/05/07/kotlin-chap2/","excerpt":"","text":"# 코틀린의 특징 # 클래스 1. 데이터 클래스 자료를 저장하는 클래스를 만드는 과정을 단순하게 해준다. 자료를 구성하는 프로퍼티만 선언하면 컴파일러가 equlas(), hashcode(), toString(), copy() 함수를 자동으로 생성해준다. 코틀린에서 ==는 자바의 equals() 메소드와 같은 동작을 한다. 즉, 값을 비교한다. 12345678// 주 생성자에서 데이터 클래스에 포함되는 프로퍼티를 함께 선언한다. data class Person(val name: String, val age: Int)fun main(args: Array&lt;String&gt;)&#123; val lee = Person(\"lee\", 26) val park = Person(\"park\",23) val lim = Person(\"lee\",26)&#125; 2. 한정 클래스 한정 클래스(seald class)는 enum 클래스를 확장한 개념이다. 이를 상속하는 클래스는 한정 클래스로 정의되는 여러 종류 중 하나로 취급된다. 한정 클래스를 상속하는 클래스는 일반적으로 클래스 내에 중첩하여 선언한다. 외부에 선언할 수도 있다. 한정 클래스로 정의된 클래스의 종류에 따라 다른 작업을 처리해야 할 때 유용하다. 123456789101112sealed class MobileApp(val os: String)&#123; class Android(os: String, val packageName: String) : MobileApp(os) class iOS(os: String, val bundleId: String) : MobileApp(os)&#125;fun whoAmI(app: MobileApp) = when(app)&#123; is MobileApp.Android -&gt; println(\"$&#123;app.os&#125;\") is MobileApp.iOS -&gt; println(\"$&#123;app.os&#125;\") // 모든 경우를 처리했으므로 else를 쓰지 않아도 된다.&#125; 한정 클래스에 새로운 클래스를 추가했고, 한정 클래스를 상속한 클래스의 종류에 따라 다른 동작을 처리해야 한다고 가정해보자. 새로 추가된 유형인 WindowsMobile 클래스를 처리하지 않으면 컴파일 에러가 발생하므로 새로운 유형에 대한 처리가 누락되는 것을 방지할 수 있다. 따라서 동작을 처리하는 것의 누락을 방지할 수 있다는 이점을 가지고 있다. 3. 프로퍼티의 사용자 getter/setter 프로퍼티에는 내부에 저장된 필드의 값을 가져오거나 설정할 수 있도록 getter/setter를 내부적으로 구현하고 있다. 이는 단순히 필드의 값을 반환하거나 설정하도록 구현되어 있다. 사용자 지정 getter/setter의 구현을 원하는대로 변경할 수 있으며, 특정 객체의 값에 따른 다양한 정보를 속성 형태로 제공할 때 유용. get(), set(value) 사용. 1234567// 나이에 따른 성인 여부를 속성 형태로 제공하는 예시.class Person(val age: Int, val name: String)&#123; val adult : Boolean get() = age&gt;=19 // 19세 이상이면 성인으로 간주한다.&#125; 사용자 지정 setter를 사용하면 프로퍼티 내 필드에 설정되는 값을 제어할 수 있으나, 읽고 쓰기가 모두 가능한 프로퍼티(var)에서만 사용할 수 있다. 1234567891011class Person(val age: Int, val name: String)&#123; val adult : Boolean get() = age&gt;=19 var address: String = \"\" set(value)&#123; field = value.subString(0..9) &#125; // 사용자 지정 setter를 사용해 인자로 들어온 문자열의 앞 10자리만 필드에 저장한다.&#125; # 함수 1. 명명된 인자 명명된 인자(named parameter)를 사용함으로써 함수를 호출할 때 매개변수의 순서와 상관없이 인자를 전달할 수 있다. 또한, 매개변수의 수가 많아지더라도 각 인자에 어떤 값이 전달되는지 쉽게 구분할 수 있다. 12345678910111213fun drawCircle(x: Int, y: Int, radius: Int)&#123; // 생략&#125;fun main(args: Array&lt;String&gt;)&#123; drawCircle(x = 10,y = 5,radius = 25) // 순서를 바꿔도 명명된 인자를 통해서 순서를 바꿔도 동일하게 호출할 수 있다. drawCircle(y = 5,x = 10,radius = 25) // 인자 중 일부에만 사용할 수도 있다. drawCircle(10,5,radius = 25)&#125; 2. 매개변수 함수의 매개변수에 기본값을 지정할 수 있으며, 이때 지정하는 값을 기본 매개변수라고 한다. 유용하게 사용할 수 있다. 123456789// 반지름의 기본값으로 25를 갖는다.fun drawCircle(x: Int, y: Int, radius:Int = 25)&#123; // 생략.&#125;fun main(args:Array&lt;String&gt;)&#123; // 반지름을 지정하지 않았으므로 원의 반지름은 기본 값인 25로 지정된다. drawCircle(10,5)&#125; 3. 단일 표현식 표기 Unit 타입을 제외한 타입을 반환하는 함수라면 함수의 내용을 단일 표현식을 사용하여 정의할 수 있다. 12345678910// 기본 형태.fun sum(a: Int, b: Int) : Int &#123; return a+b&#125;// 단일 표현식.fun sum(a: Int, b: Int) : Int = return a+b// 반환 타입도 생략 가능.fun sum(a: Int, b: Int) = return a+b 3. 확장 함수 확장 함수를 사용하여 상속 없이 기존 클래스에 새로운 함수를 추가할 수 있다. 확장 함수를 추가할 대상 클래스는 리시버 타입(receiver type)이라 부르며, 이 리시버 타입 뒤에 점(.)을 찍고 그 뒤에 원하는 함수의 형태를 적는 방식으로 정의한다. 확장 함수 구현부에서는 this를 사용하여 클래스의 인스턴스에 접근할 수 있으며 이를 리시버 객체(receiver object)라 부른다. 123456789101112131415161718fun main(args: Array&lt;String&gt;)&#123; val foo = \"Foo\" val foobar = foo.withBar() println(foobar)&#125;// String 클래스에 withPostfix() 함수 추가.// this를 사용하여 인스턴스에 접근할 수 있다.private fun String.withPostfix(postFix: String) : String&#123; return \"$this$postFix\"&#125;// this를 사용하여 인스턴스에 접근할 수 있으므로, 앞에서 정의한 확장 함수를 사용할 수 있다.fun String.withBar() = this.withPostfix(\"Bar\")// 결과FooBar 확장 함수를 호출하는 모습이 클래스 내 정의된 함수의 경우와 똑같다 할지라도, 이는 클래스 외부에 정의하는 함수이다. 리시버 객체에서는 클래스 내 public으로 정의된 프로퍼티나 함수에만 접근할 수 있다. 확장 함수는 리시버 타입에 직접 추가되는 함수가 아니다. 리시버 타입과 확장 함수의 인자를 인자로 받는 새로운 함수를 만들고, 확장 함수를 호출하면 이 새로운 함수가 호출되는 형태이다. 4. 연산자 오버로딩 사용자 정의 타입에 한해 연산자 오버로딩을 지원한다. 각 연산자별로 사전 정의된 함수를 재정의하는 방식으로 연산자 오버로딩을 사용할 수 있다. operator 키워드를 사용하며, 기존의 연산자를 재정의하는 것만 허용된다. 연산자 재정의는 방법이 동일하기 때문에 사용자가 원하는 형태를 직접 구현하면 된다. 아래에 단항 연산자를 기준으로 예를 들어보겠다. 1234567891011121314class Volume(var left: Int, var right: Int)&#123; // 단항 연산자 '-'를 재정의한다. operator fun unaryMinus(): Volume&#123; this.left = -this.left this.right = -this.right return this &#125; &#125;var voulme = Volume(50,50)// Volume 클래스 내 left, right 값이 반전되어 할당된다.var v1 = -volume 주의할 점은 비교 연산자의 경우에는 다른 연산자와 달리 각 연산자가 모두 동일한 함수에 할당된다. 따라서 해당 함수가 반환하는 값의 크기에 따라 해당 연산자의 참, 거짓 여부를 판단한다. comparTo 함수의 반환형은 항상 Int 어야 한다. # 람다 표현식 람다 표현식을 통해 훨씬 간편하고 직관적인 문법을 사용할 수 있다. 특히 익명 클래스를 간결하게 표현할 때 유용하게 사용할 수 있다. 중괄호를 사용하여 앞뒤를 묶어준다. 12345// 람다 표현식을 사용한 리스너 선언.button.setOnClickListener(&#123;v: View -&gt; doSomething()&#125;)// 인자 타입 생략 가능.button.setOnClickListener(&#123;v -&gt; doSomething()&#125;) 람다 표현식에서 하나의 메소드만 호출한다면 멤버 참조를 이용해 더 간략하게 표현할 수 있다. 123456789fun doSomething(v: View)&#123; // 생략.&#125;// doSomething() 함수 하나만을 호출하고 있다.button.setOnClickListener(&#123;v -&gt; doSomething(v)&#125;)// 멤버 참조를 사용해 doSomething() 함수에 바로 대입할 수 있다.button.setOnClickListener(::doSomething) 코틀린에서는 프로퍼티도 멤버 참조를 지원한다. 12345678910111213141516class Person(val name: String, val age: Int)&#123; // 성인 여부를 표시하는 프로퍼티 val adult = age&gt;19&#125;fun printAdults(people: List&lt;Person&gt;)&#123; // 필터링 조건을 람다 표현식을 사용해 대입. people.filter(&#123;people -&gt; people.adult&#125;) .forEach&#123; println(\"Name= $&#123;it.name&#125;) &#125; // 멤버 참조를 사용해 adult 프로퍼티를 바로 대입한다. people.filter(Person::adult) .forEach&#123; println(\"Name= $&#123;it.name&#125;) &#125;&#125; 람다 표현식의 유용한 기능 함수가 단 하나의 함수 타입 매개변수를 가질 경우, 인자 대입을 위한 괄호를 생략하고 바로 람다 표현식을 사용할 수 있다. 12345// setOnClickListener의 마지막 인자로 함수 타입을 대입한다.button.setOnClickListener(&#123;v -&gt; doSomething()&#125;)// 다른 인자가 없으므로, 괄호 없이 바로 외부에 람다 표현식을 사용할 수 있다.button.setOnClickListener &#123; v -&gt; doSomething() &#125; 또한, 람다 표현식 내 매개변수의 개수가 하나인 경우 매개 변수 선언을 생략할 수 있으며, 참조가 필요한 경우 it을 사용할 수 있다. 1button.setOnClickListener&#123; doSomething(it) &#125; 여러 개의 매개 변수를 갖는 람다 표현식에서 사용하지 않는 매개변수는 이름 대신 _를 사용하여 사용하지 않는 매개변수라는 것을 명시할 수 있다. 12345var dialog = AlertDialog.Builder(this) // dialog 매개 변수를 사용하지 않아 _로 표시 .setNegativeButton(\"Cancel\") &#123;_, which -&gt; doCancel(which)&#125; .create() 인라인 함수 람다 표현식을 사용하면, 함수를 인자로 넘길 수 있는 고차 함수(higher-order function)에 들어갈 함수형 인자를 쉽게 표현할 수 있다. 인라인 함수를 사용하면 함수의 매개변수로 받는 함수형 인자의 본체를 해당 인자가 사용되는 부분에 그대로 대입하므로 성능 하락을 방지할 수 있다. 123456789// 인자로 받은 함수를 내부에서 실행하는 함수.inline fun doSomething(body: () -&gt; Unit)&#123; println(\"onPreExecute()\") body() println(\"onPostExecute()\")&#125;// 인라인 함수 호출.doSomething&#123; println(\"do Something()\") &#125; 인라인 함수는 컴파일 과정에서 아래와 같이 변환된다. 1234println(\"onPreExecute()\")// 인자로 전달된 함수 본체의 내용이 그대로 복사된 것을 확인할 수 있다.println(\"do Something()\")println(\"onPostExecute()\") # 여타 특징 타입 별칭 복잡한 구조로 구성된 타입을 간략하게 표현할 수 있다. typealias를 사용한다. 클래스나 함수와 마찬가지로 타입을 인자로 받을 수도 있으며, 함수형 타입에도 타입 별칭을 지정할 수 있다. 12345678// List&lt;Person&gt;을 PeopleList라는 이름을 갖는 타입 별칭으로 선언.typealias PeopleList = List&lt;Person&gt;fun sendMessage(people: PeopleList)&#123; people.forEach&#123; // 메시지 전송. &#125;&#125; 타입 별칭을 사용해 새롭게 선언한다고 해서 이 타입에 해당하는 새로운 클래스가 생성되는 것은 아니다. 타입 별칭으로 선언된 타입은 컴파일 시점에 모두 원래 타입으로 변환되므로 실행 시점의 부하가 없다는 장점이 있다. 분해 선언 각 프로퍼티가 가진 자료의 값을 한번에 여러 개의 값(val) 혹은 변수(var)에 할당할 수 있다. 이 기능을 분해 선언이라고 부른다. 123456data class Person(val age: Int, val name: Strig)val person = Person(\"Lee\",26)// 사람 객체에 포함된 필드의 값을 한번에 여러 값에 할당한다.val (ageOfPerson, nameOfPerson) = person 분해 선언은 프로퍼티가 가진 자료의 값을 어떻게 전달할까? 이를 알아보기 위해 해당 코드가 어떻게 컴파일되는지 아래에서 알아보자. 12val ageOfPerson: Int = person.component1()val nameOfPerson: String = person.component2() 이처럼 분해 선언을 사용하면 내부적으로 각 값에 component1(), component2() 함수의 반환값을 할당한다. 프로퍼티의 수가 늘어나면 3,4, … 와 같이 함수 뒤의 숫자가 증가하는 형태, 즉 componentN() 형태의 함수를 추가로 사용하게 된다. 분해 선언을 사용하려면 클래스에 프로퍼티의 수만큼 componentN() 함수가 있어야 하며, 이 함수들을 포함하고 있는 클래스에만 분해 선언을 사용할 수 있다. 아래는 분해 선언을 기본으로 제공하는 클래스들이다. data class로 선언된 클래스 kotlin.Pair kotlin.Triple kotlin.collections.Map.Entry 특히, 맵 자료구조를 사용할 때 유용하다. 123456789101112val cities: Map&lt;String, String&gt; = ... // 도시 정보를 저장하고 있는 맵// 맵 내 각 항목의 키와 값을 별도로 선언하여 사용한다.// 따라서 keySet()과 같은 함수가 필요없어진다.for((cityCode, name) in cities)&#123; println(\"$cityCode = $name\")&#125;// 람다 표현식 내 매개변수에서도 분해 선언을 사용할 수 있다.cities.forEach&#123; cityCode, name -&gt; println(\"$cityCode = $name\")&#125; 분해 선언을 지원하는 클래스를 제외한 개발자가 작성한 클래스에서 분해 선언을 사용하고 싶다면, 해당 클래스 내에 별도로 componentN() 함수를 프로퍼티의 선언 순서 및 타입에 알맞게 추가해줘야 한다. componentN() 함수를 선언할 때는 앞에 operator를 붙여 줘야 한다. 123456789101112131415class Person(val age: Int, val name: String)&#123; // 첫 번째 프로퍼티의 값 반환. operator fun component1() = this.age // 두 번째 프로퍼티의 값 반환. operator fun component2() = this.name&#125;val person = Person(\"lee\",26)// 분해 선언 사용.val (age,name) = person// 사용하지 않는 변수 혹은 값은 _로 표시한다.// 따라서 아래는 name 만 사용하는 경우이다.val (_, name) = person","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"커니의 Kotlin","slug":"커니의-Kotlin","permalink":"https://woovictory.github.io/tags/커니의-Kotlin/"}]},{"title":"[안드로이드] DI?","slug":"What-is-DI","date":"2019-05-04T13:08:42.000Z","updated":"2020-05-26T07:00:33.086Z","comments":true,"path":"2019/05/04/What-is-DI/","link":"","permalink":"https://woovictory.github.io/2019/05/04/What-is-DI/","excerpt":"","text":"의존성 주입이란 안드로이드 개발을 시작한 지 얼마 되지 않았다면 추천하지 않는다고 한다. 왜냐하면 그만큼 러닝 커브가 높고 학습 곡선이 높기 때문에 쉽게 이해가 되지 않는다고 한다. 하지만, 중급 개발자 혹은 지금보다 성장하고 싶은 개발자라면 알아두면 유용한 내용이라고 한다. 그래서 나는 지금보다 더 성장하고 중급 개발자 이상이 되고 싶어서 공부하면서 내용을 정리하려고 한다. # Dependency Injection Dependency Injection의 의미는 의존성 주입이다. 줄여서 DI라고도 한다. 의존성이란? 코드에서 두 모듈간의 연결 두 클래스 간의 관계 즉, 의존성이 크다는 것은 모듈 간의 결합도가 높다는 것을 의미한다. 의존성이 미치는 영향은? 하나의 모듈이 변경됨에 따라 결합된 다른 모듈이 영향을 받게 된다. 두 개의 모듈일 때는 괜찮지만 최악의 경우 모듈이 100개, 1000개, …n개일 때 하나의 모듈 변경으로 인해 n-1개의 모듈(즉, 한개를 제외한 모든 모듈)이 영향을 받는다고 생각해보자. 정말 최악이다. 그리고 나머지 모듈이 제대로 동작하는지에 대한 검증이 필요할 수도 있다. 그럼 시간과 비용도 모듈의 개수인 n 만큼…?? 결합도가 높으면 독립성이 떨어진다. 반대로 결합도가 낮으면 독립성이 높아진다. 의존성 주입의 목적 가장 큰 목적은 모듈을 Testable하게 만들 수 있다는 점이다. 즉, 독립된 모듈에 대한 테스트 코드를 작성할 수 있다. 하나의 모듈이 변경되어도 다른 모듈들이 영향을 받지 않는다. 따라서 유지보수가 용이하다. new를 이용한 생성자를 없애자. 모듈 내에서 다른 모듈을 초기화하면 결합도가 높아지므로 객체 생성은 다른 곳에서 하고 생성된 객체를 참조하자. 객체 생성을 외부에서 하면 클래스의 독립성이 높아지고 이에 따라서 클래스를 테스트 가능하게 할 수 있으며 재사용을 할 가능성도 높아진다. 결론 : 의존성 주입은 두 개 이상의 모듈(클래스)간의 결합도를 낮추기 위해 외부에서 객체 생성(new)하고 주입하는 것이다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"DI","slug":"DI","permalink":"https://woovictory.github.io/tags/DI/"},{"name":"의존성 주입","slug":"의존성-주입","permalink":"https://woovictory.github.io/tags/의존성-주입/"},{"name":"Dependency Injection","slug":"Dependency-Injection","permalink":"https://woovictory.github.io/tags/Dependency-Injection/"}]},{"title":"[커니의 Kotlin] Chap1.2","slug":"kotlin-chap1-2","date":"2019-05-03T11:47:16.000Z","updated":"2020-05-12T15:19:06.645Z","comments":true,"path":"2019/05/03/kotlin-chap1-2/","link":"","permalink":"https://woovictory.github.io/2019/05/03/kotlin-chap1-2/","excerpt":"","text":"1부에 이어서 작성… # 특징들 생성자 생성자 부분은 자바와 비교했을 때 조금 다른 면이 있다. 다음은 기본 생성자의 정의이다. init 블록을 사용해 기본 생성자를 대체한다. 생성자에 인자가 필요한 경우 인자처럼 받을 수 있다. 이를 주 생성자라고 부른다. 12345678910111213class Test&#123; init&#123; // 기본 생성자에서 수행할 작업. &#125;&#125;class Test(a : Int)&#123; init&#123; println(\"$a\") &#125;&#125; 생성자의 인자를 통해 클래스 내부의 프로퍼티에 값을 할당할 수 있다. 생성자의 인자를 통해 프로퍼티 선언을 대신한다. 따라서 추가로 프로퍼티 선언이 필요 없다. 1class Test(val a: Int, val b: Char) 생성자의 인자에서 프로퍼티 선언이 함께 이루어지고, 값 할당 또한 생성자 호출과 동시에 수행되므로 짧은 코드를 확인할 수 있다. 주 생성자 외에 다른 형태의 생성자가 필요한 경우 constructor 키워드를 사용해 선언할 수 있다. 123456789class Test(val a: Int, val b: Char)&#123; // a 값만 인자로 받는 추가 생성자. // 기본 생성자를 반드시 호출해야 한다. constructor(a: Int) : this(a,0) // 두 인자의 값을 모두 0으로 지정하는 생성자. constructor() : this(0,0)&#125; 이처럼 추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.(상속과 this를 사용해서!) 추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다. 따라서 프로퍼티 선언이 필요한 경우 주 생성자에서 이를 처리해야 한다. 생성자 앞에 접근 제한자를 붙여 가시성을 변경할 수 있다. 123456class Test private constructor(val a: Int, val b: Char)&#123; private constructor(a: Int) : this(a,0) constructor(): this(0,0)&#125; 생성자는 중요한 개념이므로 추후 더 추가할 예정. 함수 메소드를 함수로 표현한다. void -&gt; Unit이며 반환 값이 없음을 의미한다. 또한, 반환 값이 없는 함수는 Unit을 생략할 수 있다. 123456789class Test&#123; fun foo(): Unit&#123; // Unit 생략 가능. &#125; fun bar(): Int&#123; return 1 &#125;&#125; 상속 및 인터페이스 구현 클래스의 상속과 인터페이스 구현을 구분하지 않고 콜론(:)으로 통일한다. 클래스를 상속받는 경우 반드시 부모 클래스의 생성자를 호출해야 하며, 부모 클래스의 생성자는 super 키워드를 사용해 호출한다. 12345678910111213141516171819class MyView : View&#123; constructor(context: Context) : super(context)&#123; &#125; constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)&#123; // 뷰 초기화 &#125; // 생성자가 여럿일 경우 this 키워드를 사용해 자기 자신의 생성자를 호출할 수 있다. constructor(context: Context) : this(context,null)&#123; &#125; constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)&#123; // 뷰 초기화 &#125;&#125; 오버라이드 시 어노테이션을 사용하지 않고 override 키워드를 사용한다. open 키워드를 사용해 클래스 혹은 함수의 상속 여부를 결정할 수 있다. open 키워드가 있으면 상속 가능. open 키워드가 없으면 상속 불가능(Java의 final과 비슷) this 해당 키워드를 사용한 클래스 자신을 지칭할 때 사용한다. 해당 위치에서 가장 가까운 범위의 클래스를 의미한다. 따라서 클래스 내에서 다른 클래스나 인터페이스의 객체를 동적으로 생성하여 사용하는 경우 키워드를 사용하는 위치에 따라 this가 의미하는 클래스가 달라질 수 있다. 따라서 this@{클래스이름} 처럼 명확하게 표시해준다. 동반객체 동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있으면서 인스턴스 생성 없이 호출할 수 있는 함수를 작성할 수 있다. 어디서든 접근이 가능하다. 즉, 자바의 static 메소드, static 멤버와 같은 역할을 한다고 볼 수 있다. 왜냐하면 코틀린은 클래스 내에 정적 필드나 정적 함수를 둘 수 없다. 그러한 개념이 없기 때문이다. 대신에 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트를 정의할 수 있는데, 이를 동반 객체라고 한다. 싱글톤 단 하나의 인스턴스만 생성되도록 제약을 둔 패턴으로 코틀린에서 object를 사용해 간편하게 선언할 수 있다. 12345678910object Singleton&#123; val a = \"a\" fun aa()&#123; println(\"aa call!\") &#125;&#125;val aValue = Singleton.aSingleton.aa() 코틀린에서의 특징만 살펴보도록 하겠다. 다 정리하기에는 시간이 오래 걸릴 듯 싶어서이다… 시간이 생긴다면 정리하지 않은 특징도 추구하도록 하겠다. :) is 연산자 자료형을 확인하기 위해 사용한다. 자바의 instanceOf 연산자와 동일한 기능을 한다. 특정 타입이 아닌 경우를 확인하기 위해서는 !is로 확인하면 된다. 12345678fun Test(obj : Any)&#123; if(obj is Int)&#123; &#125;else if(obj is Float)&#123; &#125; ...&#125; as 연산자 특정 변수를 원하는 자료형으로 변환하기 위한 연산자이다. 123fun porcessNumber(number: Number)&#123; val foo : Int = number as Int&#125; 스마트 캐스트 자료형 추론이 가능할 경우 캐스팅 없이 해당하는 자료형으로 객체를 사용할 수 있도록 하는 기능이다. 값을 검사하는 시점과 사용하는 시점 사이에 값이 변하지 않았다는 것이 보장되는 경우에만 지원된다. 따라서 언제든지 값이 변할수 있는 var는 스마트 캐스트가 지원되지 않는다. 범위 특정 범위를 순회하거나 해당 범위 내에 특정 항목이 포함되어 있는지 확인할 때 사용한다. … 연산자를 사용. 123456// 0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.val myRange : IntRange = 0..10for(i in myRange)&#123; println(i)&#125; 인덱스 순환을 위한 범위를 생성할 때는 until 함수를 사용하면 된다. 가장 마지막 값을 포함하지 않는다. 범위 내에 특정 항목이 있는지 확인할 때는 in 연산자를 사용한다. 12345678910// 0&lt;=N&lt;10val myRagne : IntRange = 0 until 10// 0&lt;=N&lt;=10val myRange2 : IntRange = 0..10// 5가 myRange2 내에 포함되어 있는지 확인.val foo : Boolean = 5 in myRange2 // true 반환// 5가 myRange 내에 포함되지 않는지 확인.val bar : Boolean = 5 !in myRange // false 반환 downTo() 함수를 이용해 항목들의 순서가 반대로 정렬된 범위를 생성한다. 시작과 끝을 포함한다. 기본적으로 1씩 감소 시킨다. step() 함수를 사용하여 감소/증가 폭을 변경할 수 있다. 123456789for(i in 5 downTo 1)&#123; print(i)&#125;// 결과 : 54321for(i in 5 downTo 1 step 2)&#123; // 2씩 감소시킨다. print(i)&#125;// 결과 : 531 예외 사용법은 자바와 동일하다. 하지만, 코틀린에서는 값을 반환할 수 있다. checked exception(뭐지? 검색해보자.)을 따로 검사하지 않는다. 즉, 대부분의 예외를 try-catch문으로 감싸 처리해야 했던 자바와 달리 코틀린에서는 이를 선택적으로 사용할 수 있다. 123456789fun readFromJson(fileName : String) : String&#123; // IOException을 발생시킬 수 있는 코드 ...&#125;fun process()&#123; // try-catch문을 사용하지 않아도 된다. val json : String = readFromJson(\"foo.json\")&#125; # 널안정성 코틀린은 컴파일 단계에서 발생하는 널 포인터 예외가 발생할 문제를 해결하기위해 모든 타입에 명시적으로 널 허용 여부를 함께 표기한다. 코틀린의 중요한 특징 중 하나라고 생각한다. 널 허용 여부 표기 널 값을 가질 수 있도록 하려면 명시적으로 타입 뒤에 ? 를 붙여주어야 한다. 널 값을 허용하지 않는 변수를 초기화하지 않거나, null을 대입하면 컴파일 오류를 발생시킨다. 함수의 파라미터나 반환 값에도 동일하게 적용된다. 12345val a : String? = nullval b : String = \"b\"val name : String // 오류 : 값이 초기화 되지 않음.val address : String = null // 오류 : null을 허용하지 않는 변수에 null 대입 불가. 엘비스(?:) 연산자 널 값을 허용하지 않는 값 혹은 변수에 널 값을 반환할 수 있는 함수의 결과를 대입해야 하는 경우 엘비스 연산자를 이용해 편리하게 처리할 수 있다. 널 값을 대신하는 방법으로 ?:를 사용한다. 널 여부를 확인하는 작업을 별도로 하지 않아도 되므로 자바에 비해서 간편하게 함수의 로직을 작성할 수 있다. 값 반환 대신 예외를 발생시킬 수도 있다. 123foo ?: bar// foo가 null이 아닐 경우에는 foo를 반환// foo가 null일 경우에는 bar를 반환 안전한 호출(?.) 연산자 널 값 확인을 위해 자바에서 if문으로 검사하던 것을 간편화 할 수 있다. 간단한 로직의 경우 상관이 없지만 복잡해질수록 if문의 향연이 펼쳐질 수 있다. 안전한 호출 연산자를 사용하여 널 값 확인과 값 접근/함수 호출을 한 번에 할 수 있다. 이 연산자를 사용하는 객체가 널 값이 아닌 경우에만 연산자 뒤의 문장을 수행한다. 널 값일 경우에는 뒤의 문장을 수행하지 않고 null 값을 반환한다. 따라서 널 값인 객체의 프로퍼티를 참조하거나 함수를 호출하는 일을 방지할 수 있다. 12345// bar가 null이 아닐 경우에만 해당 값인 baz를 대입. 그렇지 않은 경우 null을 foo에 대입val foo = bar?.baz// foo가 null이 아닐 경우에만 bar() 함수 호출.foo?.bar() as? 연산자 자바에서 지원되지 않는 자료형으로 변환을 시도할 가능성이 있는 부분을 try-catch 블록으로 감싸서 처리한다. 코틀린에서는 as? 연산자를 사용해 간편하게 해결할 수 있다. 자료형 변환이 실패할 경우 예외를 발생시키는 대신 널 값을 반환한다. 12345val foo : String = \"foo\"// 자료형 변환에 실패하므로 bar로 null 값이 할당된다.// 따라서 bar는 Int?를 통해 널 값을 허용하도록 선언한다.val bar : Int? = foo as? Int 엘비스 연산자를 사용해 변환에 실패했을 때의 기본값을 지정할 수 있다. 변환된 값을 받은 자료형의 널 허용 여부를 수정할 필요가 없으므로 유연하게 대처할 수 있다. 12// 자료형 변환에 실패하는 경우 기본 값을 0으로 지정.val bar : Int = foo as? Int ?: 0 널 값이 아님을 명시하기 : 비 널 값 보증 널 값을 포함할 수 있는 타입을 널 값을 포함하지 않는 타입으로 변환하여 사용할 수 있다. 보증하려는 항목 뒤에 !!을 붙여 사용한다. 비 널 값 보증을 사용했지만 실제로 객체나 값에 널 값이 들어가 있을 경우 널 포인ㅌ 예외가 발생하므로 유의해서 사용해야 한다. 12345678// 값 foo는 널 값을 포함할 수 있는 타입.val foo : Foo? = ...// 값 foo는 널 값을 포함하지 않음을 보증.val nonNullFoo : Foo = foo!!// 값 foo가 널 값이 아님을 보장하면서 bar() 함수 호출.foo!!.bar() 비 널 값 보증 사용 주의 비 널 값 보증은 아래처럼 중첩해서 사용하는 것을 권장하지 않는다. contact.address와 address.line2 중 하나라도 널 값이라면 널 포인터 예외가 발생한다. 하지만 에러 로그에서 라인만 알 수 있을 뿐, 어느 요소로 예외가 발생했는지 알 수 없다. 따라서 비 널 값 보증은 중첩되는 호출 단계보다는 하나의 호출 단계에만 사용할 것을 권장한다. 1234val contact : Contact = ...// address와 line2 모두 널 값이 아님을 보장.val line : String = contact.address!!.line2!! lateinit 키워드 초기화 없이 변수만 선언할 수 있다. (var에만 사용할 수 있다.) 즉, 초기화를 나중에 한다는 의미이다. 초기화를 하지 않은 채로 사용하려고 하면 널 포인터 예외가 발생하기 때문에 초기화 작업을 반드시 해야 한다. 초기화가 되었는지 확인하는 방법이 있다. 12345678910class MainActivity: Activity()&#123; lateinit var api : Api fun process()&#123; // lateinit 키워드를 사용한 변수가 초기화 되었는지 확인한다. if (::api.isInitialized) &#123; ... &#125; &#125;&#125; 주의! 코틀린에서는 값을 반환하는 구문들이 있다. for, while, when, try-catch, if 등등이 있다. 이러한 구문들이 값을 반환한다는 특징을 알고 코드를 더 편리하게 짤 수 있으므로 알아두면 좋을 것 같다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"커니의 Kotlin","slug":"커니의-Kotlin","permalink":"https://woovictory.github.io/tags/커니의-Kotlin/"}]},{"title":"[안드로이드] ViewModel","slug":"What-is-ViewModel","date":"2019-05-02T09:34:38.000Z","updated":"2020-05-26T07:00:49.955Z","comments":true,"path":"2019/05/02/What-is-ViewModel/","link":"","permalink":"https://woovictory.github.io/2019/05/02/What-is-ViewModel/","excerpt":"","text":"# ViewModel ViewModel 클래스는 라이프 사이클을 고려하여 UI 관련된 데이터를 저장하고 관리하기 위해 설계되었다. 화면 전환과 같이 설정이 변경되는 상황에서도 data가 계속 남아있을 수 있도록 해준다. 안드로이드 프레임워크는 Activity, Fragment와 같은 UI 컨트롤러의 라이프사이클(즉, 생명주기)을 관리한다. 프레임워크는 사용자의 특정한 동작이나 완전히 예상치 못한 장치의 이벤트에 대한 응답으로 UI 컨트롤러를 파괴(Destroy)하고 재생성(re-create)하는 것을 결정하기도 한다.(액티비티가 종료되고 재생성되는 경우가 해당된다.) 시스템이 UI 컨트롤러를 파괴, 재생성하면 그 안에 저장해두었던 UI 관련 데이터들은 모두 사라진다. 예를 들어, 앱에는 사용자의 목록과 같은 데이터가 포함되어 있을 수 있다. 갑자기 설정이 변경되어 Activity가 재 생성될 때, 새로운 Activity 인스턴스는 사용자의 목록을 다시 불러와야 한다. 단순한 데이터를 다룰 때에는 Activity의 onSaveInstanceState() 함수를 이용해 Bundle 객체에 저장하고 onCreate() 함수에서 Bundle 객체에 저장된 데이터를 불러올 수 있다. 하지만, 이 경우에는 bitmap과 리스트 형식의 많은 양의 데이터가 아닌 직렬화, 역직렬화가 가능한 작은 데이터에 적합하다. 즉, 잠재적으로 데이터의 양이 많다면 적절한 방법이 아니다. 또 다른 문제는 UI 컨트롤러가 자주 비동기 호출을 만들어서 반환하는데 다소 시간이 걸릴 수 있다는 것이다. 잠재적인 메모리 누수를 피하기 위해 UI 컨트롤러는 Destroy 된 후에 시스템이 instance를 정리하기 전에 비동기 호출을 관리할 필요가 있다. 이런 관리 작업은 엄청난 유지보수를 필요로 하고, 상태 변화로 인해 객체를 재생성하는 경우, 이미 만들어진 객체를 다시 호출해야 하므로 리소스가 낭비된다. Activity, Fragment와 같은 UI 컨트롤러는 사용자에게 UI 데이터를 보여주고, 사용자 액션에 반응하고, 권한 요청과 같은 OS의 요청을 처리하는 용도로 사용된다. 데이터베이스나 네트워크로부터 데이터를 불러오는 동작은 UI 컨트롤러에서 수행하면 클래스의 크기가 커지게 된다. 따라서 UI 컨트롤러에 과도한 책임이 할당되면 클래스가 단일화되어 테스트가 매우 어려워질 수 있다. 그래서 ViewModel을 사용함으로써 UI 컨트롤러의 로직으로부터 UI 로직과 데이터 소유권을 분리할 수 있는 매우 효과적인 방법이다. # ViewModel 예시. Google의 Android Architecture Components(이하 AAC)에서 UI 컨트롤러들을 위한 헬퍼 클래스인 ViewModel을 제공한다. ViewModel 객체는 자동으로 화면 회전 같은 상태 변화동안 자동으로 유지되고 새로운 액티비티 또는 프래그먼트에서도 데이터를 즉시 사용할 수 있다. MainViewModel 1234567891011121314public class MainViewModel extends ViewModel&#123; private MutableLiveData&lt;List&lt;User&gt;&gt; userList; public LiveData&lt;List&lt;User&gt;&gt; getUsers()&#123; if(userList == null)&#123; userList = new MutableLiveData&lt;List&lt;User&gt;&gt;(); loadUsers(); &#125; return userList; &#125; private void loadUsers()&#123; // Do an asynchronous operation to fetch userList. &#125;&#125; MainActivity 1234567891011public class MainActivity extends AppCompatActivity&#123; public void onCreate(Bundle savedInstanceState)&#123; // Create a ViewModel the first time the system calls an activity's onCreate() method. // Re-created activities receive the same MyViewModel instance created by the first activity. MainViewModel viewModel = ViewModelProviders.of(this).get(MainViewModel.class); viewModel.getUsers().observe(this, userList -&gt;&#123; // update UI &#125;) &#125;&#125; 만약 액티비티가 재생성이 된다면 처음 만들어진 MainViewModel 인스턴스를 받게 된다. 이 인스턴스를 호출한 액티비티 또는 프래그먼트가 destroy 되어 메모리 해제가 되기 전까지 데이터를 유지하고 있어서 데이터를 보관하고 있다가 화면 회전 같은 상태 변화가 발생해도 데이터를 유지하게 된다. 안드로이드 프레임워크는 내부적으로 class, ViewModel의 Map을 관리하므로 이미 존재하는 ViewModel의 레퍼런스를 가져올 때마다 그 인스턴스를 반환하게 된다. ViewModel을 소유한 액티비티가 종료되면 프레임워크는 자동으로 ViewModel 객체의 onCleared() 메소드를 호출할 것이다. 그렇다면 우리는 이 함수를 오버라이드하여 리소스를 해제하면 된다. ViewModel 인스턴스는 뷰나 LifecycleOwners의 특정 인스턴스보다 오래 유지되도록 설계되었다. 이런 설계는 ViewModel 인스턴스가 뷰나 Lifecycle 인스턴스를 모르기 때문에 ViewModel에 대해 더 쉽게 테스트를 작성할 수 있게 해준다. ViewModel 인스턴스는 LiveData 인스턴스와 같은 LifecycleObservers를 포함할 수 있다. 하지만, LiveData와 같은 라이프사이클 기반의 Observable 클래스의 변화를 관찰해서는 안된다. 만약, ViewModel이 시스템 서비스를 찾는 등의 이유로 Application Context가 필요하다면, AndroidViewModel 클래스를 상속받아서 생성자에서 Application 객체를 받도록 구현할 수 있다. 주의 : ViewModel 인스턴스는 반드시 뷰, Lifecycle, Activity 참조를 가지고 있는 어떤 클래스도 참조를 유지하면 안된다. 이유는 메모리 누수가 발생할 수 있기 때문이다. # ViewModel 생명주기. ViewModel의 생명주기는 ViewModelProvider에 전달된 Lifecycle에 생명주기 범위가 지정된다. 즉, 주어진 액티비티가 살아있는 동안 ViewModel 객체는 메모리에 계속 남아있는다. 액티비티의 경우에는 finish될 때, 프래그먼트의 경우에는 액티비티로부터 detached될 때까지이다. 위의 그림에서 ViewModel의 스코프를 확인할 수 있다. 그림은 Activity가 화면 회전되었을 때의 생명주기를 나타낸다. 화면이 회전해도 상태 변경이 되는 상황에서도 살아 있음을 보여준다. Fragment의 기본 생명주기에 따른 ViewModel의 생존시간도 동일하다. 일반적으로 ViewModel 인스턴스를 Activity의 시작점인 onCreate()에서 요청할 것이다. onCreate() 함수는 상황에 따라 여러 번 호출될 수 있지만, ViewModel 객체는 최초 요청부터 Activity가 소멸될 때까지 메모리에 유지된다. # 의문점?! A 액티비티에서 ViewModel 객체를 생성하면 scope는 A 액티비티의 생명주기를 따르낟. 만약, B 액티비티에서 ViewModel에 저장된 값을 재사용하고 싶다면?? B 액티비티에서 ViewModelProviders로 객체를 다시 구해오면 A 액티비티에서 만든 객체가 아닌 새로운 객체를 만들어낸다. how to reuse the same ViewModel on different activites 위의 글을 보면 싱글톤 팩토리로 동작하는 custom ViewModel Factory를 전달하여 다른 액티비티에서도 동일한 ViewModel 인스턴스를 받을 수 있는 방법이 있다. 하지만, 다른 액티비티의 생명주기에서 ViewModel 객체를 유지하는 것은 안티패턴이다. RxJava와 다르게 생명주기에 따라 데이터를 보관/관리 해주는 LiveData의 장점을 버리는 방식이라고 생각된다. 따라서 ViewModel의 객체를 유지시키는 것이 아닌 DataSource나 Repository를 싱글톤으로 유지하는 것이 더 추천되는 방식이다. https://stackoverflow.com/questions/49364550/ ViewModel의 객체를 유지시키는 방식이 아닌 Other data layers(data source, data source를 관리하는 Repository)를 싱글톤 객체로 만들어 데이터를 유지시켜 다른 Activity들에서 새로운 ViewModel 객체를 만들어 Repository를 통해 보관중이 데이터를 가져오는 방식이다. # Fragment 간 데이터 공유. 하나의 액티비티 안에서 2개 이상의 프래그먼트 간에 데이터를 주고 받는 구조는 흔한 경우다. 이럴 때는 프래그먼트의 scope를 사용하는 것이 아닌 프래그먼트들을 감싸고 있는 액티비티의 scope를 전달하면 된다. 즉, 프래그먼트들이 액티비티 scope의 ViewModel을 서로 공유하도록 구현하면 된다. 1234567891011121314151617181920212223242526272829303132public class SharedViewModel extends ViewModel &#123; private final MutableLiveData&lt;Item&gt; selected = new MutableLiveData&lt;Item&gt;(); public void select(Item item) &#123; selected.setValue(item); &#125; public LiveData&lt;Item&gt; getSelected() &#123; return selected; &#125;&#125;public class MasterFragment extends Fragment &#123; private SharedViewModel model; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); itemSelector.setOnClickListener(item -&gt; &#123; model.select(item); &#125;); &#125;&#125;public class DetailFragment extends Fragment &#123; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class); model.getSelected().observe(this, &#123; item -&gt; // Update the UI. &#125;); &#125;&#125; ViewModelProvider를 얻을 때, 두 프래그먼트 모두 getActivity() 메소드를 이요하고 있다. 같은 Activity를 이용하여 같은 ViewModel 객체를 요청하므로 동일한 객체가 얻어진다. 이 접근 방법은 다음과 같은 이점이 존재한다. Activity가 각 Fragment간 데이터 전달 시에 추가적인 작업을 할 필요가 없다. 각 Fragment는 ViewModel 외에 다른 객체나 상태에 대해 더 알 필요가 없다. 그러므로 다른 Fragment가 사라지더라도 정상적으로 동작할 것이다. 각 Fragment는 다른 Fragment의 라이프사이클을 신경쓰지 않고, 자신의 라이프사이클 대로 작업을 수행할 수 있다. # 참고 Android Architecture Components ViewModel이란? [안드로이드] Architecture Component 1 - ViewModel 공식문서 번역","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"},{"name":"ViewModel","slug":"ViewModel","permalink":"https://woovictory.github.io/tags/ViewModel/"}]},{"title":"[안드로이드] LiveData","slug":"What-is-LiveData","date":"2019-04-30T01:55:52.000Z","updated":"2020-05-26T07:00:31.886Z","comments":true,"path":"2019/04/30/What-is-LiveData/","link":"","permalink":"https://woovictory.github.io/2019/04/30/What-is-LiveData/","excerpt":"","text":"MVVM을 이해하기 위해 알아보는 LiveData 추후 더 자세한 내용을 정리할 예정. # LiveData란? 직역하면 살아있는 데이터? 이렇게 생각할 수 있다. LiveData는 LifeCycle을 알고 있는 DataType이라고 생각하면 좋다. 이처럼 LifeCycle을 알고 있으면 필요할 때 변경하고 필요하지 않을 때 변경하지 않을 수 있다. 또한, LiveData는 Observer 패턴을 따른다. 즉 데이터의 변경이 일어났을 때 콜백으로 받아 처리할 수 있다. 이렇게 데이터의 변경이 일어날때마다 콜백을 실행하는데 LifeCycle을 알고 있기 때문에 필요하지 않을 때는 콜백이 실행되지 않는다. 예를 들어 Activity에 선언되어 있는 LiveData의 경우 Activity가 Start, Resume 상태일 때는 콜백을 실행하지만 다른 액티비티로 넘어가 있는 onStop 등의 상태일 때는 실행되지 않는다. postValue : 간단히 데이터가 변경된다. 이렇듯 onStart, onResume의 상태일 때 A와 B를 받는 옵저버 콜백은 실행되지만 onStop일 때 C와 D일 때는 실행되지 않고(옵저버 되지 않음) 다시 액티비티가 실행되면 가장 최신의 데이터인 D를 실행한다.(옵저버 됨) 이렇듯 LiveData를 사용하면 RxJava나 Interface Callback을 사용할 때 보다 더 깔끔하게 처리할 수 있다. # 간단한 예제 12345678910111213class UserProfileViewModel : ViewModel()&#123; // MutableLiveData란 변경할 수 있는 LiveData 형이다. // 일반적인 LiveData형은 변경할 수 없고 오로지 데이터의 변경값만을 소비하는데 반해 // MutableLiveData는 데이터를 UI Thread와 Background Thread에서 선택적으로 바꿀 수 있다. private val _post = MutableLiveData&lt;User&gt;() // _post로 선언된 MutableLiveData를 post를 통해 발행한다. // 이렇듯 ViewModel에서만 _post를 변경할 수 있기 때문에 보안에 더 좋다. val post : LiveData&lt;User&gt; get() = _post&#125; 위와 같은 데이터를 Activity에서 받으려면 1234567891011121314class PostActivity() : AppCompatActivity()&#123; override fun onCreate(savedInstanceState : Bundle?)&#123; ... // 위의 ViewModel에서 post LiveData를 Observe한다. // 첫 번째 인자는 UI이며 해당 인자로 어떤 UI Thread를 사용할 지 결정한다. // 두 번째는 Observe 콜백이다. postViewModel.post.observe(this, Oberserver&#123; post -&gt; postTitle.text = post?.title &#125;) &#125;&#125; LiveData 콜백을 실행하는 방법은 아래처럼 두 가지가 있다. 1234// MutableLiveData에ㅓ setValue, postValue 실행 하는 경우post.setValue(post) // UI Thread 즉, Main Thread에서 실행post.postValue(post) // Background Thread에서 실행 사실 LiveData를 더 잘쓰려면 데이터바인딩과 함께 사용해야 좋은 효과를 낼 수 있다. 왜냐하면 위에서처럼 Observe 패턴을 이용해서 UI를 직접 변경해줄 필요 없이 xml 상에서 깔끔하게 처리할 수 있다. 123&lt;TextView .... android:text=\"@&#123;viewModel.post.title&#125;/&gt; 이처럼 아주 깔끔하게 선언할 수 있다 이제 title이 변경되는대로 TextView UI는 알아서 변경이 된다. 그렇다면 LiveData Observer UI(Activity, Fragment)가 사라진다면? 더 이상 새로운 데이터를 발행하지 않는다. rx로 따지면 Dispose가 필요없다. 즉, 데이터를 더 이상 발행하지 않기 때문에 알아서 구독을 해지하는 것으로 생각이 든다. # LiveData 변형하기 간단하게 살펴보고 추후에 자세하게 살펴보도록 하겠다. Map LiveData의 변경을 다른 LiveData에게 알려주는 메소드. 1234val userLiveData : LiveData&lt;User&gt; = ...val userNameLiveDat = Transformations.map(userLiveData, user -&gt; &#123; return \"$&#123;user.firstName&#125;, $&#123;user.lastName&#125;\" // String을 리턴한다.&#125;) UserLiveData의 변경사항을 Observe해서 map 함수를 통해서 원하는 값으로 변경한 뒤 String을 리턴한다. 즉, 새로운 LiveData를 리턴하는게 아니라 데이터만 변경한다. SwitchMap LiveData의 변경사항을 받아서 다른 LiveData를 발행한다. 일반적으로 RoomDatabase를 LiveData로 쓸 때 많이 사용된다고 한다. 12345678val userIdLiveData : MutableLiveData = ...val userLiveData : LiveData = Transformations.switchMap(userIdLiveData, id -&gt; repository.getUserById(id)) // LiveData를 리턴한다.fun setUserId(userId : String)&#123; this.userIdLiveData.setValue(userId)&#125; SwitchMap은 데이터의 인자값에 따라 다른 LiveData를 발행한다. repository.getUserById(id)는 RooDatabase에서 ID 값에 따라 유저값을 가져오며 return 값이 LiveData이다. 즉, 인자 값에 따라서 다른 데이터 소스(LiveData)를 보낼 수 있다. MediatorLiveData 여러 데이터 소스를 한 곳에서 Observe할 때 사용한다. 123456val liveData1:LiveData = ...val liveData2: LiveData = ...val liveDataMerger:MediatorLiveData = new MediatorLiveData&lt;&gt;() liveDataMerger.addSource(liveData1, value -&gt; liveDataMerger.setValue(value)) liveDataMerger.addSource(liveData2, value -&gt; liveDataMerger.setValue(value)) 예를 들어 Fragment별로 LiveData가 있고 이걸 Activity 한 곳에서 Crashlytics에 기록한다거나 Toast 메시지를 띄울 때 Fragment의 LiveData를 Activity의 MediatorLiveData를 통해 사용할 수 있다. LiveData는 많은 기능이 있는 것 같다. 하지만 혼자 쓰기 보다는 DataBinding, ViewModel과 함께 MVVM 패턴에서 사용될 때 효과가 더욱 두드러질 것 같다는 생각이 든다. LiveData와 관련된 자세한 내용을 추후에 공부해서 올릴 예정이다. 앞으로도 열심히하길~ # 참고 Jetpack Android — LiveData 알아보기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"},{"name":"LiveData","slug":"LiveData","permalink":"https://woovictory.github.io/tags/LiveData/"}]},{"title":"[RxJava] Chap02","slug":"RxJava-Chap02","date":"2019-04-29T02:30:14.000Z","updated":"2020-05-26T07:07:03.780Z","comments":true,"path":"2019/04/29/RxJava-Chap02/","link":"","permalink":"https://woovictory.github.io/2019/04/29/RxJava-Chap02/","excerpt":"","text":"이번에는 Observable의 개념에 대해서 알아보도록 하겠다. 책을 보면 RxJava는 Observable에서 시작해서 Observable로 끝난다고 해도 과언이 아니라고 한다. 그렇다면 과연 어떤 것인지 공부해보자. Observable 소개 Observable 클래스 옵저버 패턴 정적팩토리 함수 팩토리 함수들 Observable 소개 Observable은 데이터 흐름에 맞게 알림을 보내 구독자가 데이터를 처리할 수 있도록 한다. RxJava에서는 Observable이 중요한 개념이다. Maybe 클래스 : reduce(), firstElement() 함수와 같이 데이터가 발행될 수 있거나 혹은 발행되지 않고도 완료되는 경우를 의미한다. Flowable 클래스 : 데이터가 발행되는 속도가 구독자가 처리하는 속도보다 현저하게 빠른 경우 발생하는 배압(Back Pressure) 이슈에 대응하는 기능을 추가로 제공한다. 위와 같은 클래스들은 이번 Chapter에서는 공부하지 않고 다음 Chapter에서 공부할 예정이다. 이번에는 Observable에 대해서 파헤쳐보자. Observable 클래스 Observable은 옵저버 패턴을 구현한다. 옵저버 패턴이라 함은 객체의 상태 변화를 관찰하는 관찰자(옵저버) 목록을 객체에 등록한다. 그리고 상태 변화가 있을 때마다 메소드를 호출하여 객체가 직접 목록의 각 옵저버에게 변화를 알려준다. 라이프 사이클은 존재하지 않으며 보통 단일 함수를 통해 변화만 알린다. 옵저버 패턴의 대표적인 예로는 사용자가 버튼을 누르면 버튼에 미리 등록해 둔 onClick() 메소드를 호출해 원하는 처리를 하는 것이다. 안드로이드에서는 onClick() 이벤트를 처리하는 것이 딱 이 예와 같다고 볼 수 있다. RxJava의 Observable은 세 가지의 알림을 구독자에게 전달한다. onNext() : Observable이 데이터의 발행을 알린다. 기존의 옵저버 패턴과 동일하다. onComplete() : 모든 데이터의 발행을 완료했음을 알린다. onComplete 이벤트는 단 한번만 발생하며, 발생한 후에는 onNext 이벤트가 발생해서는 안된다. onError() : Observable에서 어떠한 이유로 에러가 발생했음을 알린다. onError 이벤트가 발생하면 이후에 onNext나 onComplete 이벤트가 발생하지 않는다. 즉, Observable의 실행을 종료한다. Observable을 생성할 때는 직접 인스턴스를 만들지 않고 정적 팩토리 함수를 호출한다. 여기서 말하는 정적 팩토리 함수가 뭘까…?? 옵저버 패턴 여기쯤에 옵저버 패턴 공부 좀 하고 넣으면 될 것 같다. 아니면 새로운 글을 만들어서 디자인 패턴의 옵저버 패턴을 공부하면 괜찮을 듯 하다. # 정적팩토리 함수 # 팩토리 함수들 RxJava에서 제공하는 팩토리 함수들을 살펴볼 예정이다. 알아보고 직접 사용해보면서 사용법을 익혀보자. Observable을 만드는 함수들이다. 1. just() 함수 데이터를 발행하는 가장 쉬운 방법은 기존의 자료구조를 사용하는 것이다. just() 함수는 인자로 넣은 데이터를 차례로 발행하려고 Observable을 생성한다. 실제 데이터의 발행은 subscribe() 함수를 호출해야 시작한다. 한 개의 값을 넣을 수도 있고 인자로 여러 개의 값을 넣을 수도 있다. 주의해야 할 점은 최대 10개까지의 데이터를 넣을 수 있다는 것이다. 그리고 타입은 모두 같아야 한다. 데이터 내용을 바꾸지 않고 그대로 발행한다. 2. subscribe() 함수와 Disposable 객체 RxJava는 내가 동작시키기 원하는 것을 사전에 정의해둔 다음 실제 그것이 실행되는 시점을 조절할 수 있다. 이때 사용하는 것이 subscribe() 함수이다. Observable은 just() 등의 팩토리 함수로 데이터 흐름을 정의한 후 subscribe() 함수를 호출해야 실제로 데이터를 발행한다. RxJava는 선언형 프로그래밍 앞선 Chap01에서도 설명했지만 한 번 더 보도록 하겠다. RxJava는 선언형 프로그래밍을 지향한다. 선언형 프로그래밍은 명령형 프로그래밍의 반대말이다. 즉, 어떤 방법(How)으로 동작하는지가 아니라 프로그래밍할 대상이 무엇(What)인지 알려주는 것을 의미한다. 예를 들어 명령형 프로그래밍 언어에서는 실행할 알고리즘과 동작을 구체적으로 명시한다. 하지만 선언형 프로그래밍은 목표를 명시할 뿐 실행할 알고리즘을 명시하지 않는다. 다시 subscribe() 함수에 관한 이야기로 돌아와보자. subscribe() 함수의 주요 원형 중 하나를 설명하겠다. 1Disposable subscribe() 위의 인자가 없는 subscribe() 함수는 onNext()와 onComplete() 이벤트를 무시하고 onError 이벤트가 발생했을 때만 OnErrorNotImplementedException를 던진다.(throw) 따라서 Observable로 작성한 코드를 테스트하거나 디버깅할 때 활용한다. 이외에도 함수의 원형은 여러 가지 존재한다. 관련된 부분은 문서를 참고하길 바란다. 모든 함수 원형은 Disposable 인터페이스의 객체를 리턴한다. Disposable은 RxJava의 구독 객체에 해당한다. Disposable 인터페이스의 함수 dispose()는 Observable에게 더 이상 데이터를 발행하지 않도록 구독을 해지하는 함수이다. Observable 계약(Observable Contract)에 따르면 Observable이 onComplete 알림을 보냈을 때 자동으로 dispose()를 호출해 Observable과 구독자의 관계를 끊는다. 따라서 onComplete 이벤트가 정상적으로 발생했다면 구독자가 별도로 dispose()를 호출할 필요가 없다. isDisposed() : Observable이 데이터를 발행하지 않는지(구독을 해지했는지) 확인하는 함수이다. 위에서 언급했듯, onComplete 이벤트가 정상적으로 발생했다면 구독자가 별도로 dispose() 하지 않아도 구독이 해제된다. 3. create() just()는 데이터를 인자로 넣으면 자동으로 알림 이벤트가 발생하지만, create() 함수는 onNext, onComplete, onError 같은 알림을 개발자가 직접 호출해야 된다. 개발자가 무언가를 하는 느낌이 강하다. 데이터 발행을 위해서 onNext()를 호출해야 한다. 모든 데이터를 발행한 후 onComplete()를 호출해야 한다. 12345678910111213val sourceInt : Observable&lt;Int&gt; = Observable.create &#123; it.onNext(100) it.onNext(200) it.onNext(300) it.onNext(400) it.onComplete() // 데이터 발행 완료.&#125;sourceInt.subscribe(System.out::println)// 람다식 활용.sourceInt.subscribe &#123; println(\"data : $it\") &#125; onNext() 함수를 이용해 차례로 데이터를 발행했다. 그리고 onComplete() 함수를 호출하여 데이터 발행을 완료한다. 람다식을 활용하면 메소드의 원형을 알 필요도 없고 가독성도 훨씬 높아진다. subscribe() 함수를 호출하지 않으면 데이터 발행이 안된다. 메소드 레퍼런스와 람다 표현식을 사용하면 좋다. 이유는 함수의 원형을 알지 않아도 되므로 가독성이 높아진다. 4. fromArray() just(), create()는 단일 데이터를 다룬다. 단일 데이터가 아닐 때는 fromXXX() 함수를 사용하면 된다. 배열에 들어있는 데이터를 세분화할 때 fromArray() 함수를 사용하면 된다. 숫자 뿐 아니라 사용자 정의 클래스 객체도 넣을 수 있다. 기본 타입인 int[] 배열을 RxJava에서 인식시키기 위해서는 Integer[] 배열로 변환해야 한다. 자바 8의 Stream API에서 제공하는 방법을 사용하면 된다. toIntegerArray() 함수는 int[] 배열 각각의 요소를 Integer로 변환해 Integer[] 배열의 스트림으로 만들어 반환한다. 그리고 최종적으로 스트림을 Integer[] 배열로 만들어준다. 123456789fun main(args : Array&lt;String&gt;)&#123; val array : IntArray = intArrayOf(1,2,3,4) executeIntFromArray(array)&#125;private fun executeIntFromArray(array: IntArray) = Observable.fromArray(IntegerArray(array)).subscribe &#123; for (i in array) &#123; println(\"array : $i\") &#125;&#125; 5. fromIterable() Iterable 인터페이스는 반복자를 반환한다. 이터레이터 패턴을 구현한 것으로 다음에 어떤 데이터가 있는지와 그 값을 얻어오는 것만 관여할 뿐 특정 데이터 타입에 의존하지 않는 장점이 있다. hasNext(), next() 메소드가 있다. 자바의 많은 컬렉션 클래스가 Iterable 인터페이스를 구현한다. 123456789101112131415161718192021private fun executeFromIterable() &#123; val list: MutableList&lt;String&gt; = ArrayList() list.add(\"Lee\") list.add(\"Park\") list.add(\"Kim\") Observable.fromIterable(list).subscribe &#123; println(it) &#125; val orderQueue: BlockingQueue&lt;Order&gt; = ArrayBlockingQueue(100); orderQueue.add(Order(\"ORD-1\")) orderQueue.add(Order(\"ORD-2\")) orderQueue.add(Order(\"ORD-3\")) Observable.fromIterable(orderQueue).subscribe &#123; order -&gt; println(order.mid) &#125;&#125;// Order 데이터 클래스.data class Order(val mid: String) 6. fromCallable() 동시성 API인 Callable 인터페이스 Callable 객체와 fromCallable() 함수를 이용해 Observable을 만들 수 있다. 실행 결과를 리턴한다. Executor 인터페이스의 인자로 활용되기 때문에 잠재적으로 다른 스레드에서 실행되는 것을 의미한다. 7. fromFuture() Future 인터페이스도 동시성 API로 비동기 계산의 결과를 구할 때 사용한다. 잘 모르는 내용이기 때문에 더 공부하고 추가하도록 하겠다… ^^; 8. fromPublishe() fromXXX() 계열의 마지막 함수. 자바 9의 표준인 Flow API의 일부. 기존의 RxJava와 비교했을 때 패키지 이름이 다르다. Observable.create()와 마찬가지로 onNext()와 onComplete() 함수를 호출할 수 있다. # Single 클래스 Single 클래스는 오직 1개의 데이터만 발행하도록 한정한다. 결과가 유일한 서버 API를 호출할 때 유용하게 사용할 수 있다. 데이터 하나가 발행과 동시에 종료(onSuccess) 된다는 점이다. onNext()와 onComplete() 함수가 onSuccess() 함수로 통합된 것으로 보면 된다. 따라서 Single 클래스의 라이프 라이클 함수. onSuccess() onError() 1. just() 함수 Observable과 거의 같은 방법으로 활용할 수 있다. Single 클래스는 하나의 데이터만 발행하기 때문에 조심해서 사용해야 한다. 예제 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private fun executeFromObservableToSingle() &#123; println(\"==Single 예제==\") // 1. 기존 Observable 에서 Single 객체로 변환하기. val source: Observable&lt;String&gt; = Observable.just(\"Hello Single\") Single.fromObservable(source).subscribe &#123; it -&gt; println(it) &#125; // 2. Single() 함수를 호출해 Single 객체 생성하기. // Observable 에서 값이 발행되지 않을 때, 인자로 넣은 기본 값을 대신 발행한다. Observable.just(\"Hi Single\") .single(\"default value\") .subscribe &#123; it -&gt; println(it) &#125; // 3. first() 함수를 호출해 Single 객체 생성하기. // 하나 이상의 데이터를 발행하더라도 첫 번째 데이터 발행 후 onSuccess 이벤트가 발생한다. val colors: Array&lt;String&gt; = arrayOf(\"Red\", \"Blue\", \"White\") Observable.fromArray(colors).map &#123; return@map it[0] &#125; .first(\"d\") .subscribe &#123; it -&gt; println(it) &#125; // 4. empty Observable 에서 Single 객체 생성하기. // 첫 번째 데이터 발행 후 onSuccess 이벤트가 발생. // Observable 에서 값이 발행되지 않을 때도 기본값을 갖는 single 객체로 변환할 수 있다. Observable.empty&lt;String&gt;() .single(\"default value\") .subscribe &#123; it -&gt; println(it) &#125; // 5. take() 함수에서 single 객체 생성하기. // Single 이기 때문에 take() 함수에 인자로 1보다 큰 값을 넣으면 에러 발생. Observable.just(Order(\"ORD-5\"), Order(\"ORD-6\")) .take(1) .single(Order(\"default value\")) .subscribe &#123; it -&gt; println(it) &#125;&#125;data class Order(val mid: String) &#123; // toString 오버라이드. override fun toString(): String &#123; return \"Order ID : $mid\" &#125;&#125; # Maybe 클래스 최대 데이터 하나를 가질 수 있지만 데이터 발행 없이 바로 데이터 발생을 완료할 수도 있다. Single 클래스 : 1개 완료 Maybe 클래스 : 0 혹은 1개 완료 Maybe 클래스는 Single 클래스에 onComplete 이벤트가 추가된 형태이다. 차례대로 onSuccess, onError, onComplete 이벤트에 해당한다. Observable의 특정 연산자를 통해 생성할 때가 많다. # 뜨거운 Observable Observable에는 뜨거운 Observable과 차가운 Observable이 있다. 차가운 Observable just(), fromIterable() 함수를 호출해도 옵서버가 subscribe() 함수를 호출하여 구독하지 않으면 데이터를 발행하지 않는다. 예) 웹 요청, 데이터베이스 쿼리와 파일 읽기 등. 원하는 URL이나 데이터를 지정하면 그때부터 서버나 데이터베이스 요청을 보내고 결과를 받는다. 앞서 봤던 것들이 차가운 Observable이다. 앞으로 공부함에 있어서 별도의 언급이 없으면 차가운 Observable! 뜨거운 Observable 구독자의 존재 여부와 관계없이 데이터를 발행한다. 따라서 여러 구독자를 고려할 수 있다. 구독자로서는 Observable에서 발행하는 데이터를 처음부터 모두 수신할 것으로 보장할 수 없다. 예) 마우스 이벤트, 키보드 이벤트, 시스템 이벤트, 센서 데이터와 주식 가격 등. 온도, 습도 센서의 데이터를 처리하는 앱이라면 최근의 온도, 습도 정보만 사용자에게 표시하면 된다. 요약하면, 차가운 Observable은 구독자가 구독하면 준비된 데이터를 처음부터 발행한다. 하지만 뜨거운 Observable은 구독한 시점부터 Observable에서 발행한 값을 받는다. 구독자가 여러명? 위에서 뜨거운 Observable은 여러 구독자를 고려할 수 있다고 한다. 무슨 뜻일까? 예를 들어 서버에 요청한 결과로 반환된 JSON 문서를 파싱해 원하는 속성을 추추란다고 해보자. 날씨 정보, 지역 정보, 시간 정보를 반환하는 경우 RxJava에서는 위의 세 가지 정보를 구독자라고 생각하면 편리하다. 데이터의 원천은 한 곳이지만 내가 최종적으로 원하는 결과 데이터가 여러 종류일 때는 각각을 구독자로 생각하면 좋다. # Subject 클래스 차가운 Observable -&gt; 뜨거운 Observable Observable의 속성과 구독자의 속성이 모두 있다. Observable처럼 데이터를 발행할 수도 있고 구독자처럼 발행된 데이터를 바로 처리할 수도 있다. 1. AsyncSubject 클래스 Observable에서 발행한 마짐막 데이터를 얻어올 수 있는 Subject. 즉, 완료되기 전 마지막 데이터에만 관심이 있으며 이전 데이터는 무시한다. 처음 구독자가 subscribe() 함수를 호출한다. 이후에 Red, Green 원이 발행된 후 두 번째 구독자가 subscribe() 함수를 호출한다. 마지막으로 Blue 원이 발행되고 데이터 발행을 완료한다.(onComplete 이벤트) 이때 완료되기 전까지는 구독자에게 데이터를 전달하지 안하가 완료됨과 동시에 첫 번째와 두 번째 구독자에게 마지막 데이터를 발행하고 종료한다. 123456789101112131415161718192021222324252627282930313233343536private fun executeAsyncSubject()&#123; val subject : AsyncSubject&lt;String&gt; = AsyncSubject.create() // 정적 팩토리 함수인 create()로 객체 생성. subject.subscribe&#123; data -&gt; println(\"Subscriber #1 =&gt; $data\") &#125; // 구독. subject.onNext(\"1\") subject.onNext(\"3\") // onNext()를 호출하여 데이터 발행. subject.subscribe&#123; data -&gt; println(\"Subscriber #2 =&gt; $data\") &#125; // 두 번째 구독. subject.onNext(\"5\") subject.onComplete() // 데이터를 발행한 후에는 마지막으로 onComplete() 호출. // onComplete() 함수를 호출한 후에 구독했을 경우. // Observable과 마찬가지로 onComplete 함수 호출 이후에 onNext 이벤트를 무시한다. subject.onNext(\"12\") subject.subscribe&#123; data -&gt; println(\"Subscriber #3 =&gt; $data\") &#125; subject.subscribe&#123; data -&gt; println(\"Subscriber #4 =&gt; $data\") &#125;&#125;// 결과Subscriber #1 =&gt; 5Subscriber #2 =&gt; 5Subscriber #3 =&gt; 5Subscriber #4 =&gt; 5 또한, AsyncSubject 클래스는 구독자로도 동작할 수 있다. 12345678910111213private fun executeAsyncSubject2()&#123; val source : Observable&lt;Float&gt; = Observable.just(10.1f,13.4f,12.5f) val subject : AsyncSubject&lt;Float&gt; = AsyncSubject.create() subject.subscribe&#123; data -&gt; println(\"Subscriber # =&gt; $data\") &#125; source.subscribe(subject) // subject가 source 즉, Observable을 구독.&#125;// 결과Subscriber # =&gt; 12.5 2. BehaviorSubject 클래스 구독자가 구독을 하면 가장 최근 값 혹은 기본값을 넘겨주는 클래스이다. 예를 들어 온도 센서에서 값을 받아온다면 가장 최근의 온도 값을 받아오는 동작을 구현할 수 있으며 처음 온도를 얻을 때는 초깃값(0)을 반환하기도 한다. 마블 다이어그램처럼 처음에 발행한 값이 없다면 기본값을 발행해서 구독자가 받게 된다. 그 다음부터는 발행한 최근 값을 받는다. 1234567891011121314151617181920private fun executeBehaviorSubject() &#123; val subject: BehaviorSubject&lt;String&gt; = BehaviorSubject.createDefault(\"6\") subject.subscribe &#123; data -&gt; println(\"Subscriber #1 =&gt; $data\") &#125; subject.onNext(\"1\") subject.onNext(\"3\") subject.subscribe &#123; data -&gt; println(\"Subscriber #2 =&gt; $data\") &#125; subject.onNext(\"5\") subject.onComplete()&#125;// 결과Subscriber #1 =&gt; 6Subscriber #1 =&gt; 1Subscriber #1 =&gt; 3Subscriber #2 =&gt; 3Subscriber #1 =&gt; 5Subscriber #2 =&gt; 5 3. PublishSubject 클래스 구독자가 subscribe() 함수를 호출하면 값을 발행하기 시작한다. 가장 평범한 Subject 클래스. 오직 해당 시간에 발생한 데이터를 그대로 구독자에게 전달한다. 123456789101112131415161718private fun executePublishSubject() &#123; val subject: PublishSubject&lt;String&gt; = PublishSubject.create() subject.subscribe &#123; data -&gt; println(\"Subscriber #1 =&gt; $data\") &#125; subject.onNext(\"1\") subject.onNext(\"3\") subject.subscribe &#123; data -&gt; println(\"Subscriber #2 =&gt; $data\") &#125; subject.onNext(\"5\") subject.onComplete()&#125;// 결과Subscriber #1 =&gt; 1Subscriber #1 =&gt; 3Subscriber #1 =&gt; 5Subscriber #2 =&gt; 5 마블 다이어그램과 코드를 함께 보면 이해가 조금 더 수월하다. 첫 번째 구독자가 subscribe() 함수를 호출하면 Subject가 발행한 1,3 이라는 데이터를 전달받는다. 이 후 두 번째 구독자가 subscribe() 함수를 호출하고 Subject가 발행한 5라는 데이터는 두 구독자 모두가 전달받는다. 두 번째 구독자는 구독한 이후에 발행된 데이터인 5만 전달받는다. 4. ReplaySubject 클래스 Subject 클래스의 목적은 뜨거운 Observable을 활용하는 것인데 차가운 Observable 처럼 동작하기 때문이다. -&gt; 아직 무슨 말인지 정확히 이해가 가지 않는다…ㅜ 구독자가 새로 생기면 항상 데이터의 처음부터 끝까지 발행하는 것을 보장해준다. 그러므로 모든 데이터 내용을 저장해두는 과정 중 메모리 누수가 발생할 가능성을 염두에 두고 사용할 때 주의해야 한다. 123456789101112131415161718192021private fun exectueReplaySubject()&#123; val subject : ReplaySubject&lt;String&gt; = ReplaySubject.create() subject.subscribe &#123; data-&gt; println(\"Subscriber #1 =&gt; $data\") &#125; subject.onNext(\"1\") subject.onNext(\"3\") subject.subscribe &#123; data -&gt; println(\"Subscriber #2 =&gt; $data\") &#125; subject.onNext(\"5\") subject.onComplete()&#125;//결과Subscriber #1 =&gt; 1Subscriber #1 =&gt; 3Subscriber #2 =&gt; 1Subscriber #2 =&gt; 3Subscriber #1 =&gt; 5Subscriber #2 =&gt; 5 첫 번째 구독자는 Observable을 구독한 이후에 발행한 1과 3을 전달받는다. 두 번째 구독자는 subscribe() 함수를 호출하면 지금까지 발행된 1과 3을 바로 전달받는다. 그리고 마지막으로 Subject 클래스가 5를 발행하면 두 구독자 모두 해당 값을 전달받는다. # ConnectableObservable 클래스 차가운 Observable을 뜨거운 Observable로 변환한다.(Subject 처럼) Observable을 여러 구독자에게 공유할 수 있으므로 원 데이터 하나를 여러 구독자에게 동시에 전달할 때 사용한다. subscribe() 함수를 호출해도 아무 동작이 일어나지 않는다. connect() 함수는 호출한 시점부터 subscribe() 함수를 호출한 구독자에게 데이터를 발행한다. publish() : Observable을 ConnectableObservable로 변환. 여러 구독자에게 데이터를 발행하기 위해 connect() 함수를 호출하기 전까지 데이터 발행을 유예할 수 있다. connect() 함수를 호출해야 그때까지 구독했던 구독자 모두에게 데이터를 발행한다. connect() 함수를 호출한 이후에 구독한 구독자에게는 구독 이후에 발생한 데이터부터 발행한다. ConnectableObservable로 바꿔놓으면 구독자를 동시에 대기시킬 수 있다. -&gt; 구독자 1,2,3을 subscribe() 해놓고 마지막에 connect()를 하면 동시에 같은 데이터를 받을 수 있다. 이것이 뜨거운 Observable의 성격! connect()한 이후에 subscribe()를 하게 되면 앞서 발행되었던 데이터를 받을 수 없다. -&gt; 이도 마찬가지로 뜨거운 Observable의 성격이다. 최신의 데이터만 필요하거나 앞서 발행되었던 데이터는 불필요한 경우에 활용될 수 있다. # 참고 뜨거운 Observable 만들기 RxJava 프로그래밍","categories":[{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/categories/RxJava/"}],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"https://woovictory.github.io/tags/안드로이드/"},{"name":"RxJava","slug":"RxJava","permalink":"https://woovictory.github.io/tags/RxJava/"},{"name":"Observable","slug":"Observable","permalink":"https://woovictory.github.io/tags/Observable/"},{"name":"연산자","slug":"연산자","permalink":"https://woovictory.github.io/tags/연산자/"}]},{"title":"[Android] Parcelable 쉽게 하자.","slug":"Android-Parcelable-kotlin","date":"2019-04-23T15:07:13.000Z","updated":"2020-03-01T10:27:21.392Z","comments":true,"path":"2019/04/24/Android-Parcelable-kotlin/","link":"","permalink":"https://woovictory.github.io/2019/04/24/Android-Parcelable-kotlin/","excerpt":"","text":"Kotlin Plugin 사용 안드로이드에는 다음과 같이 4개의 컴포넌트가 존재한다. Activity Service Broadcast Receiver Content Provider 각 컴포넌트들은 독립적이며 상호 통신을 위해 Intent라는 일종의 메시지 객체를 사용한다. 나는 보통 액티비티 간 데이터 전달에 자주 사용한다. 그런데, 데이터 하나를 전달하는 게 아니라 객체를 전달해야 하는 상황이 있다. 이 경우에는 보내고자 하는 객체를 직렬화해서 Intent에 담아서 보내면 된다. 직렬화 하는 방법에는 아래와 같이 2가지가 존재한다. Serializable Parcelable 개발자 입장에서는 Serializable이 훨씬 간편하지만 성능상으로 따져봤을 때는 Parcelable이 성능이 좋다. 이유는 직렬화 관련된 블로그 포스팅을 보면 도움이 될 것 같다. 그래서 나는 성능이 조금 더 좋은 Parcelable을 사용하려고 한다. 하지만 사용자가 정의해서 사용해야 하기 때문에 많은 데이터를 갖고 있는 객체를 직렬화 하려면 모두 작성하기 번거롭다. 그래서 우리는 Plugin을 사용해보려 한다. Android Studio를 처음 켰을 때 우측 하단의 Configure 버튼을 누른다. 그 중에서 Plugin을 누른다. 우리가 원하는 Parcelable을 검색한다. 가장 많이 다운로드 받은 코틀린 버전을 설치한다. 위의 과정까지 진행했다면 안드로이드 스튜디오를 껐다가 켜준다. 그리고 추후 과정은 다음과 같다. 직렬화 하려는 객체의 클래스로 돌아가서 Command+N을 누른다.(맥북 기준) 그러면 Parcelable이 생긴 것을 확인할 수 있다. 이걸 눌러서 직렬화할 때 필요한 값들을 생성시킬 수 있다. 이렇게 Android studio에서 Plugin을 설치함으로써 직렬화를 번거롭지 않게 하는 방법에 대해서 알아봤다. 참고 Kotlin Parcelable 플러그인 사용하기 Easy Parcelable in Kotlin","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://woovictory.github.io/tags/android/"},{"name":"직렬화","slug":"직렬화","permalink":"https://woovictory.github.io/tags/직렬화/"},{"name":"plugin","slug":"plugin","permalink":"https://woovictory.github.io/tags/plugin/"},{"name":"kotlin","slug":"kotlin","permalink":"https://woovictory.github.io/tags/kotlin/"}]},{"title":"[커니의 Kotlin] Chap1.1","slug":"kotlin-chap01","date":"2019-04-12T04:19:22.000Z","updated":"2020-05-12T15:19:08.042Z","comments":true,"path":"2019/04/12/kotlin-chap01/","link":"","permalink":"https://woovictory.github.io/2019/04/12/kotlin-chap01/","excerpt":"","text":"코틀린을 공부하면 정리하는 포스팅. # 코틀린의 특징 간결한 문법 문장 끝에 세미 콜론(;)을 넣지 않는다. new 키워드를 사용하지 않고 객체를 생성한다. 타입 추론을 지원하므로 타입을 명시하지 않아도 된다. 널 안정성 널 값의 허용 여부를 명확히 구분하며 컴파일 단계에서 검사한다. 12345var a : String? = null// 널 값 허용.var b : String = \"b\"// 널 값 허용하지 않음. 가변/불변 구분 val(값) : 값을 한번 할당하고 나면 그 후에 값을 변경할 수 없는 변수. 자바의 final 변수와 유사. var(변수) : 할당된 값을 자유자재로 바꿀 수 있는 변수. 변수의 가변/불변과 유사하게 컬렉션 자료형에 대해서도 가변/불변 여부를 구분한다. 객체에 할당된 값이 아닌 컬렉션 내에 포함된 자료들을 추가,삭제할 수 있는지 여부를 구분한다. 불변의 경우 삽입,삭제,수정을 위한 함수가 없다. 1234567891011var a : String = \"a\"val b : String = \"b\"a = \"aa\" // 가변이므로 가능.b = \"bb\" // 불변이므로 불가능.val immutable : List&lt;String&gt; = listOf(\"a\",\"b\") // 불변 리스트.val mutable : MutableList&lt;String&gt; = mutableListOf(\"a\",\"b\") // 가변 리스트.immutable.add(\"c\") // add() 함수가 정의되어 있지 않음.mutable.add(\"c\") // add()와 같은 자료를 수정할 수 있는 함수가 정의되어 있음. 람다표현식 지원 람다 표현식을 기본으로 제공. 123view.setOnClickListener&#123; Toast.makeText(it.context, \"Click\", Toast.LENGTH_SHORT).show()&#125; 스트림API 지원 코틀린 표준 라이브러리를 통해 컬렉션 내 자료를 다루는 데 유용한 스트림 API를 지원한다. 완벽한 자바 호환성 자바에서 코틀린을 사용할 수 있고, 반대로 코틀린에서 자바 코드를 사용할 수 있다. # 주요 문법 값 및 변수 선언 12345678910var a : String = \"a\" // String 타입의 a 선언.var b = \"b\"// 타입을 명시하지 않아도 타입을 추론한다.var c : String// 선언 시 초기화를 하지 않으면 타입을 꼭 붙여야 한다.c = \"c\"// 자료 할당. 함수 선언 Unit은 자바의 void와 유사하다. 반환 타입이 없음을 의미한다. 생략 가능하다. 12345678910111213fun sum(a : Int, b : Int) : Int&#123; return a+b&#125;fun greet(str : String) : Unit&#123; println(str)&#125;// Unit 반환 타입을 생략한 경우.fun greet(str : String) &#123; println(str)&#125; 클래스 및 인터페이스 선언 12345678910111213// Classclass V&#123; var a : Stnig = \"a\" fun A()&#123; &#125;&#125;// interfaceinterface I&#123; fun C()&#125; 조건문 123456789101112// if-elseif(a&gt;b)&#123; return a&#125;else&#123; return b&#125;// when. 자바의 switch문과 같음.when(count)&#123; 1 -&gt; println(\"$count item\") else -&gt; println(\"else item\")&#125; 반복문 for-each만은 지원한다. while, do-while문은 자바와 사용법이 똑같다. 1234val items = listOf(\"a\",\"b\")for(item in items)&#123; println(item)&#125; # 기본 자료형 코틀린은 모든 타입을 객체로 표현. 원시 타입과 래퍼 클래스를 구분하지 않는다. 원시 타입을 모두 객체로 처리하면 비효율적일 수 있다. 코틀린에서는 코드를 작성하는 시점에 원시 타입과 래퍼를 구분하지 않지만, 컴파일 단계를 거치면서 가장 효율적인 타입으로 변환된다. 값이나 변수의 타입으로 사용되는 경우 : 원시 타입으로 변환 컬렉션의 타입 인자로 사용되는 경우 : 래퍼로 변환 1234567var a : Int = ...var b : List&lt;Int&gt; = ...// java에서는 아래와 같이 바뀐다.int a = ...List&lt;Integer&gt; b = ... 숫자 숫자를 표현하는 모든 자료형은 Number 클래스를 상속한다. 현재 숫자에 해당하는 문자를 반환하는 toChar() 함수를 추가로 제공한다. Long 타입은 혼동 방지를 위해 대문자 리터럴 표기만 지원한다. 문자 자바에서는 문자에 해당하는 아스키 코드를 char에 숫자 형태로 대입할 수 있었지만, 코틀린에서는 문자만 대입할 수 있으며, 숫자를 대입할 경우 컴파일 에러가 발생한다. toChar()를 사용해서 다른 자료형의 값을 문자 자료형에 대입한다. 1234val code : Int = 65// code에 해당하는 문자를 할당.val ch : Char = code.toChar() 논리 자바와 동일하게 사용하며, Boolean을 사용한다. 문자열 자바와 거의 동일하게 사용된다. 문자열의 특정 문자에 접근하기 위해 charAt() 대신 get() 혹은 대괄호([])와 인덱스를 사용해서 접근한다. 문자열 템플릿을 사용해 템플릿 문자열 내에 직접 인자를 대입한다. 인자로 값이나 변수 대신 표현식을 넣을 경우 표현식을 중괄호로 구분하면 된다. 12345678910val foo : String = \"Victory\"val ch1 : Char = foo.get(0) // Vval ch2 : Char = foo[1] // i// 문자열 템플릿.val length : Int = 300val lengthText : String = \"Length : $length meters\"val text : String = \"Length : $&#123;foo.lenght&#125; !\" 배열 배열은 타입 인자를 갖는 Array 클래스로 표현한다. arrayOf()는 코틀린 표준 라이브러리에 포함되어 있으며, 입력받은 인자로 구성된 배열을 생성. 자바의 원시 타입은 코틀린 배열 클래스의 타입 인자로 사용할 수 없다. 자바 원시 타입을 인자로 갖는 배열을 표현하기 위해서 각 원시 타입에 대응하는 특수한 클래스를 제공한다. 1234567val words : Array&lt;String&gt; = arrayOf(\"a\",\"b\",\"c\",\"d\")// 원시 타입의 배열.val intArr : IntArray = intArrayOf(1,2,3,4,5)// 래퍼 타입 배열.val IntArr : Array&lt;Int&gt; = arrayOf(1,2,3,4,5) 가변 인자에 배열을 전달하는 경우에 스프레드 연산자(*)를 사용한다. 123456fun go(varag args : String)&#123;&#125;val strArr : Array&lt;String&gt; = arrayOf(\"a\",\"b\",\"c\")go(*strArr) // 스프레드 연산자 사용. # 컬렉션 JVM을 기반으로 하는 코틀린에서 컬렉션은 자바에서 제공하는 클래스들을 그대로 사용한다. 이때, 타입 별칭을 사용해 컬렉션 내 다른 클래스와의 일관성을 유지한다. 컬렉션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분하며 인터페이스를 통해 사용 가능한 함수를 제한하는 방식으로 구현되어 있다. Collection, List 인터페이스에는 자료를 조회하는 함수만 포함되어 있으므로 자료가 할당되면 수정이 불가능하다. 그 대신, 각 인터페이스를 상속한 MutableCollection, MutableList 인터페이스에 자료를 수정하는 함수가 포함되어 있다. Set, Map도 동일한 규칙이 지정되며 아래 표와 같다. 자료구조 자료 수정 불가 자료 수정 가능 List kotlin.collections.List kotlin.collections.MutableList Map kotlin.collections.Map kotlin.collections.MutableMap Set kotlin.collections.Set kotlin.collections.MutableSet 다음은 컬렉션을 쉽게 생성하는 함수를 나타낸다. listOf, setOf, mapOf는 자료의 수정이 불가능하다.(불변) 함수명 자료 수정 가능 여부 반환 타입(실제 타입) listOf() X kotlin.collections.List arrayListOf() O kotlin.collections.ArrayList(java.util.ArrayList) SetOf() X kotlin.collections.Set hashSetOf() O kotlin.collections.HashSet(java.util.HashSet) linkedSetOf() O kotlin.collections.LinkedHashSet(java.util.LinkedHashSet) sortedSetOf() O kotlin.collections.TreeSet(java.util.TreeSet) mapOf() X kotlin.collections.Map hashMapOf() O kotlin.collections.HashMap(java.util.HashMap) linkedMapOf() O kotlin.collections.HashMap(java.util.LinkedHashMap) sortedMapOf() O kotlin.collections.LinkedHashMap(java.util.SortedMap) 배열의 특정 원소에 접근하는 방법과 동일하게 컬렉션 내 항목에 접근할 수 있다. 123456val immutableList : List&lt;String&gt; = listOf(\"a\",\"b\")// get(0)과 동일.val firstItem : String = immutableList[0]// 불변이므로 컴파일 에러 발생.immutableList[0] = \"c\" 맵은 숫자 대신 키 값을 넣어 항목에 접근할 수 있다. 12345678910111213val immutableMap : Map&lt;String, Int&gt; = mapOf(Pair(\"A\",65), Pair(\"B\",66))// 키 \"A\"에 해당하는 값 - get(\"A\")와 동일val code : Int = immutableMap[\"A\"]// 불변이므로 값 할당시 컴파일 에러 발생.immutableMap[\"C\"] = 67val mutableMap : HashMap&lt;String, Int&gt; = hashMapOf(Pair(\"A\",65),Pair(\"B\",66))// 가변이므로 가능.mutableMap[\"C\"] = 67// 조금 더 간단하게 Pair 표현val map : Map&lt;String, Int&gt; = mapOf(\"A\" to 65, \"B\" to 66) # 클래스 및 인터페이스 클래스 및 인터페이스 선언 클래스 및 인터페이스를 선언하는 방식은 자바와 거의 유사하다. 접근 제한자를 지정하지 않는 경우 기본은 public이다. 선언된 내용이 없으면 클래스와 인터페이스는 몸체만 선언할 수 있다. new를 사용하지 않고 인스턴스를 생성한다. 12345678910111213141516class A&#123;&#125;class B // class 몸체.interface C&#123;&#125;interface D // interface 몸체.// new 키워드 사용 없이 인스턴스 생성.val foo : Foo = Foo()val bar : Bar = Bar(1) 추상 클래스는 자바와 동일한 선언 방법이지만, 인스턴스를 생성하는 형태가 다르다. 인터페이스를 선언하거나, 인터페이스의 인스턴스를 만드는 방법은 추상 클래스와 매우 유사하다. 추상 클래스에서는 인스턴스를 생성 시 생성자를 사용하지만, 생성자가 없는 인터페이스는 인스턴스 이름만 사용한다. 1234567891011121314151617181920212223242526272829// 추상 클래스의 선언.abstract class Foo&#123; abstract fun bar()&#125;// 추상 클래스의 인스턴스 생성.// object: [생성자] 형태로 선언.val foo = object: Foo()&#123; override fun bar()&#123; // 함수 구현. &#125;&#125;// 인터페이스 선언.interface Bar&#123; fun baz()&#125;// 인터페이스의 인스턴스 생성.// object: [인터페이스 이름] 형태로 선언.val bar = object: Bar&#123; override fun baz()&#123; // 함수 구현. &#125;&#125; 프로퍼티 프로퍼티는 자료를 저장할 수 있는 필드와 이에 상응하는 getter/setter 메소드를 함께 제공하며, 자바의 필드와 유사한 형태로 선언한다. 클래스의 멤버로 사용하는 프로퍼티는 초기값을 명시적으로 지정해야 한다. 그렇지 않을 경우 컴파일 에러 발생. 단, 생성자에서 프로퍼티의 값을 할당한다면 선언 시 값을 할당하지 않아도 된다. 프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당할 수 없는 경우에는 lateinit 키워드를 사용하여 프로퍼티의 값이 나중에 할당될 것임을 명시한다. lateinit 키워드는 var 프로퍼티에만 사용 가능하다. 반드시 초기화 작업을 해야 한다. 프로퍼티에 초기값을 할당하는 시점에서 해당 프로퍼티의 타입을 추론할 수 있다면 타입 선언 생략 가능. 123456789class Person&#123; val name : String? = null // 값을 읽을 수만 있는 val, getter만 있음. var address : String? = null // 값을 읽고 쓰는게 모두 가능한 var, getter/setter 모두 있음. lateinit var gender : String? // 선언 시점에 값을 할당하지 않아도 컴파일 에러가 발생하지 않음. var age = 20&#125; lateinit 키워드를 사용했는데 초기화를 하지 않으면 Uninitialized PropertyAccessException 예외가 발생하한다. 컴파일 단계에서는 확인이 불가능하므로 lateinit 키워드를 사용할 경우 반드시 초기화 여부를 확인하는 것이 좋다. 12345678lateinit var name : String// lateinit 키워드를 사용한 프로퍼티가 초기화 되었는지 확인할 수 있다.if(::name.inInitialized)&#123; println(\"초기화 O\")&#125;else&#123; println(\"초기화 X\")&#125; 접근 제한자 제한자가 없으면 public으로 간주한다. internal 접근 제한자를 제공한다. 단순히 같은 패키지에 있으면 접근이 가능했던 자바의 패키지 단위 제한과 달리 internal 접근 제한자는 동일 모듈 내에 있는 클래스들로의 접근을 제한한다. 외부 모듈에서는 이 접근 제한자로 선언된 요소에 접근할 수 없다. 제한하는 모듈의 범위 IntelliJ IDEA 모듈 Maven / Gradle 프로젝트 하나의 Ant 태스크 내에서 함께 컴파일 되는 파일들.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://woovictory.github.io/tags/Kotlin/"},{"name":"커니의 Kotlin","slug":"커니의-Kotlin","permalink":"https://woovictory.github.io/tags/커니의-Kotlin/"}]},{"title":"[알고리즘] Anagrm","slug":"Algo-Anagram","date":"2019-04-06T06:32:04.000Z","updated":"2020-05-12T06:44:25.451Z","comments":true,"path":"2019/04/06/Algo-Anagram/","link":"","permalink":"https://woovictory.github.io/2019/04/06/Algo-Anagram/","excerpt":"","text":"# Anagram이란? 동일한 알파벳을 재배열하여 만들 수 있는 문장이나 단어를 말한다. 예를 들면, listen silent 두 단어는 애너그램이다. 개념은 간단하다. 사실 풀이도 간단하게 풀 수 있다. 중요한 점 알파벳의 위치만 바꿔서 단어를 만들기 때문에 두 단어 사이에는 결국 같은 알파벳이 존재하게 된다. 이 점을 활용하여 두 단어를 알파벳 순으로 정렬해서 같은지 아닌지 비교하여 문제를 풀 수 있다. 12345678910111213141516171819202122private static boolean isAnagram(String a, String b) &#123; // 대소문자를 구분하지 않기 때문에 문자열의 문자를 모두 대문자로 바꾼다. // 그리고 String을 char 배열로 변환한다. char[] char_a = a.toUpperCase().toCharArray(); char[] char_b = b.toUpperCase().toCharArray(); // 알파벳 순으로 정렬한다. Arrays.sort(char_a); Arrays.sort(char_b); // 다시 문자열에 할당한다. String str_a = new String(char_a); String str_b = new String(char_b); // 그러면 정렬도 했으니 같은 문자열이 담겨 있게 된다. // 같은 문자열일 경우 애너그램이라고 할 수 있으므로 true를 리턴한다. if (str_a.equals(str_b)) &#123; return true; &#125; return false; &#125; 참고 애너그램","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"Anagram","slug":"Anagram","permalink":"https://woovictory.github.io/tags/Anagram/"},{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"}]},{"title":"[알고리즘] 그래프 탐색 Part2. BFS","slug":"Algo-BFS","date":"2019-04-02T02:25:23.000Z","updated":"2020-05-12T06:44:28.384Z","comments":true,"path":"2019/04/02/Algo-BFS/","link":"","permalink":"https://woovictory.github.io/2019/04/02/Algo-BFS/","excerpt":"","text":"# 그래프 탐색이란 그래프 탐색에 대해서는 DFS 글에서도 확인할 수 있다. [알고리즘] DFS # 너비 우선 탐색 너비 우선 탐색(Breadth-First Search)은 BFS라고 부른다. (이하 BFS라고 하겠다.) 루트 노드(혹은 다른 임의의 노드)에서 시작해 인접한 노드를 먼저 탐색하는 방법. 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다. 즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다. 사용하는 경우 : 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다. Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우 깊이 우선 탐색의 경우 : 모든 친구 관계를 다 살펴봐야 할지도 모른다. 너비 우선 탐색의 경우 : Ash와 가까운 관계부터 탐색. BFS가 DFS보다 좀 더 복잡하다. BFS의 특징 직관적이지 않은 면이 있다. BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다. BFS는 재귀적으로 동작하지 않는다. 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다는 것이다. 이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다. BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 큐(Queue)를 사용한다. 즉, 선입선출 원칙으로 탐색 일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작한다. BFS의 탐색 과정 a 노드(시작 노드)를 방문한다.(방문한 노드 체크) 큐에 방문된 노드를 삽입한다.(enqueue) 초기 상태의 큐에는 시작 노드만 저장 즉, a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다. 큐에서 꺼낸 노드를 방문한다. 큐에서 꺼낸 노드와 인접한 노드들을 모두 방문한다. 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다.(dequeue) 큐에 방문된 노드를 삽입한다.(enqueue) 큐가 소진될 때까지 계속한다. BFS의 구현 구현 방법 자료 구조인 큐(Queue)를 사용. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.*;import java.util.*;/** * created by victory_woo on 02/04/2019 * DFS와 BFS 복습 */public class BOJ1260_RE &#123; private static final String SPACE = \" \"; private static ArrayList&lt;Integer&gt;[] a; private static boolean[] visit; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(SPACE); int n = convert(input[0]); // 정점의 개수 int m = convert(input[1]); // 간선의 개수 int start = convert(input[2]); // 시작할 정점 번호 // 배열 초기화. a = new ArrayList[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; a[i] = new ArrayList&lt;&gt;(); &#125; for (int j = 0; j &lt; m; j++) &#123; String[] inputs = br.readLine().split(SPACE); int u = convert(inputs[0]); int v = convert(inputs[1]); // 양방향 그래프일 경우 양쪽 다 추가해준다. a[u].add(v); a[v].add(u); &#125; // 방문할 정점이 여러 개인 경우 정점 번호가 가장 작은 것부터 탐색하기 위해서 정렬한다. for (int i = 1; i &lt;= n; i++) &#123; Collections.sort(a[i]); &#125; visit = new boolean[n + 1]; bfs(start); System.out.println(); &#125; private static int convert(String command) &#123; return Integer.parseInt(command); &#125; private static void bfs(int start) &#123; LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); visit[start] = true; queue.add(start); while (!queue.isEmpty()) &#123; int x = queue.remove(); // 큐에서 정점을 뺀다. System.out.print(x + SPACE); for (int y : a[x]) &#123; // 방문한 적이 있는지 체크한다. if (!visit[y]) &#123; // 해당 정점을 방문한 적이 없다면 방문했다고 true 로 체크한다. // 그리고 해당 정점을 큐에 넣는다. visit[y] = true; queue.add(y); &#125; &#125; &#125; &#125;&#125;// 입력5 5 35 45 21 23 43 1// 출력 결과3 1 4 2 5 BFS의 시간 복잡도 N : 정점의 개수, E : 간선의 개수 인접 리스트로 표현된 그래프 : O(N+E) 인접 행렬로 표현된 그래프 : O(N^2) DFS와 마찬가지로 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다. 참고 [알고리즘] 너비 우선 탐색(BFS)이란 [그래프] DFS와 BFS 구현하기 :: 마이구미","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"그래프 탐색","slug":"그래프-탐색","permalink":"https://woovictory.github.io/tags/그래프-탐색/"},{"name":"BFS","slug":"BFS","permalink":"https://woovictory.github.io/tags/BFS/"},{"name":"너비 우선 탐색","slug":"너비-우선-탐색","permalink":"https://woovictory.github.io/tags/너비-우선-탐색/"}]},{"title":"[알고리즘] 그래프 탐색 Part3. DFS","slug":"Algo-DFS","date":"2019-04-01T14:07:30.000Z","updated":"2020-05-12T06:44:30.616Z","comments":true,"path":"2019/04/01/Algo-DFS/","link":"","permalink":"https://woovictory.github.io/2019/04/01/Algo-DFS/","excerpt":"","text":"목차 그래프 탐색이란 깊이 우선 탐색 # 그래프 탐색이란 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것 Ex) 특정 도시에서 다른 도시로 갈 수 있는지 없는지, 전자 회로에서 특정 단자와 단자가 서로 연결되어 있는지 등등 # 깊이 우선 탐색 깊이 우선 탐색(Depth-First Search)은 DFS라고도 부른다.(이하 DFS라고 하겠다.) 루트 노트(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다. 미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다. 즉, 넓게(wide) 탐색하기 전에 깊게(deep) 탐색하는 것이다. 사용하는 경우 : 모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다. DFS가 BFS보다 좀 더 간단하다. 단순 검색 속도 자체는 BFS에 비해서 느리다. DFS의 특징 자기 자신을 호출하는 순환 알고리즘의 형태를 가지고 있다. 전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다. 이 알고리즘을 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다는 것이다. 이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다. DFS 탐색 과정 a 노드(시작 노드)를 방문한다. 방문한 노드는 방문했다고 표시한다. a와 인접한 노드들을 차례로 순회한다. a와 인접한 노드가 없다면 종료한다. a와 이웃한 노드 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다. b를 시작 정점으로 DFS를 다시 시작하여 b의 이웃 노드들을 방문한다. b의 분기를 전부 완벽하게 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안된 정점을 찾는다. 즉, b의 분기를 전부 완벽하게 탐색한 뒤에야 a의 다른 이웃 노드를 방문할 수 있다는 뜻이다. 정점을 모두 방문했으면 종료한다. 아직 방문이 안된 정점이 있으면 그 정점을 시작 정점으로 DFS를 시작한다. DFS의 구현 구현 방법은 2가지가 있다. 순환 호출 이용 즉, 재귀 함수 호출. 명시적인 스택 사용 명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업한다. 만약 어떤 정점에서 더 방문할 노드가 없다면 자신을 불렀던 정점으로 돌아간다. 이 과정을 구현하기 위해 스택(Stack)을 사용한다. 방문하는 순서대로 정점을 스택에 쌓고, 방문이 끝나면 스택에서 pop하는 형태로 구현이 가능하다. 재귀 함수 또한 스택 메모리 공간에 쌓아 올려지는 구조를 띄므로 재귀 함수를 사용하여도 이것을 구현할 수 있다. DFS의 시간 복잡도 DFS는 그래프(정점의 수:N, 간선의 수:E)의 모든 간선을 조회한다. 인접 행렬로 표현된 그래프 : O(N^2) 없는 간선도 저장한다. 인접 리스트로 표현된 그래프 : O(N+E) 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다. 보통은 E &lt;&lt; N^2 이기 때문에 인접 리스트를 사용한다. DFS 구현 인접 리스트를 사용하여 구현한다. 재귀 함수 호출을 사용한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.io.*;import java.util.*;/** * created by victory_woo on 02/04/2019 * DFS와 BFS 복습 */public class BOJ1260_RE &#123; private static final String SPACE = \" \"; private static ArrayList&lt;Integer&gt;[] a; private static boolean[] visit; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(SPACE); int n = convert(input[0]); // 정점의 개수 int m = convert(input[1]); // 간선의 개수 int start = convert(input[2]); // 시작할 정점 번호 // 배열 초기화. a = new ArrayList[n + 1]; visit = new boolean[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; a[i] = new ArrayList&lt;&gt;(); &#125; for (int j = 0; j &lt; m; j++) &#123; String[] inputs = br.readLine().split(SPACE); int u = convert(inputs[0]); int v = convert(inputs[1]); // 양방향 그래프일 경우 양쪽 다 추가해준다. a[u].add(v); a[v].add(u); &#125; // 방문할 정점이 여러 개인 경우 정점 번호가 가장 작은 것부터 탐색하기 위해서 정렬한다. for (int i = 1; i &lt;= n; i++) &#123; Collections.sort(a[i]); &#125; dfs(start); &#125; private static int convert(String command) &#123; return Integer.parseInt(command); &#125; private static void dfs(int x) &#123; // 방문한 적이 있다면 종료한다. if (visit[x]) &#123; return; &#125; visit[x] = true; // 방문한 순서 출력 System.out.print(x+\" \"); for (int y : a[x]) &#123; if (!visit[y]) &#123; dfs(y); &#125; &#125; &#125;&#125;입력5 4 55 44 34 21 5출력 결과5 1 4 2 3 참고 [알고리즘] 깊이 우선 탐색(DFS)이란 [Algorithm] DFS 깊이탐색","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/tags/알고리즘/"},{"name":"그래프 탐색","slug":"그래프-탐색","permalink":"https://woovictory.github.io/tags/그래프-탐색/"},{"name":"DFS","slug":"DFS","permalink":"https://woovictory.github.io/tags/DFS/"},{"name":"깊이 우선 탐색","slug":"깊이-우선-탐색","permalink":"https://woovictory.github.io/tags/깊이-우선-탐색/"}]},{"title":"[알고리즘] 그래프 탐색 Part1. 개요","slug":"Algo-What-is-DFS","date":"2019-04-01T01:12:18.000Z","updated":"2020-05-12T06:44:41.702Z","comments":true,"path":"2019/04/01/Algo-What-is-DFS/","link":"","permalink":"https://woovictory.github.io/2019/04/01/Algo-What-is-DFS/","excerpt":"","text":"# 그래프 탐색 그래프를 탐색하는 방법에는 널리 사용되는 두 가지 방식이 있다. DFS는 깊이 우선 탐색(Depth-First Search)이다. BFS는 너비 우선 탐색(Breadth-First Search)이다. 먼저 그래프라는 자료구조에 대한 지식이 있어야 한다. 그래프 자료 구조의 일종이다. 그래프는 정점과 간선의 집합이다. 용어 정점(Vertex) : 노드라고도 부른다. 간선(Edge) : 정점 간의 관계를 나타낸다. 두 정점을 이어준다. 자기 자신을 이을 수도 있다.(루프) 간선에 방향이 있기도 하고 없기도 하다. 가중치가 있기도 하고 없기도 하다. 경로(Path) : 정점 A에서 B로 가는 경로 사이클 : 정점 A에서 다시 A로 돌아오는 경로 단순 경로 / 단순 사이클 : 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클을 의미한다. 특별한 말이 없으면 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다. 방향 있는 그래프 : 간선에 방향이 존재한다. A -&gt; C는 있지만 C -&gt; A는 없다. 방향 없는 그래프 : A - C와 같이 간선에 방향이 없다. 이는 A -&gt; C와 C -&gt; A를 나타낸다. 양방향 그래프라고도 한다. 간선 여러개 : 두 정점 사이에 간선이 여러 개일 수도 있다. 두 간선은 서로 다른 간선이다. 최소 비용을 구할 때는 가중치가 적은 것을 선택하면 된다. 루프 : 간선의 양 끝 점이 같은 경우다. A -&gt; A 가중치(Weight) : 간선에 가중치가 있는 경우를 말한다. A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등. 가중치가 없는 경우에는 1이라고 생각하면 된다. 차수(Degree) : 정점과 연결되어 있는 간선의 개수를 말한다. 그래프의 표현 정점 : 변수 하나로 개수를 표현하면 된다. 간선 : 무엇과 무엇이 연결되어 있는지를 저장해야 한다. (그래프를 저장하는 방식.) 그래프를 구현하는데 있어서 다음과 같은 두 가지 방식을 사용할 수 있다. 참고로 무방향 그래프를 기준으로 설명하겠다. 그래프를 저장하는 방식 인접 행렬 인접 리스트 먼저, 인접 행렬은 정점(V)이 N개 일때, NxN의 2차원 배열로 나타낼 수 있다. 인접 행렬을 일반적으로 a라고 이름을 짓는다. a[1][5] = 1의 의미는 정점 1과 정점 5의 간선이 연결되어 있다는 뜻이다. 무방향이기 때문에 a[5][1] 또한 1이다. 빨간색 줄을 통해서 확인할 수 있다. 인접 행렬의 값이 1이라면, 정점 간의 간선이 존재한다는 것이고, 0이라면 존재하지 않는다는 것이다. (현재 위의 예에서는 가중치가 없지만, 가중치를 넣을 때는 1 대신 가중치를 넣으면 된다.) 123456789int[][] a = new int[N+1][N+1];for(int i=0;i&lt;m;i++)&#123; int v1 = sc.nextInt(); int v2 = sc.nextInt(); a[v1][v2] = 1; a[v2][v1] = 1;&#125; 이번에는 인접 리스트를 확인해보자. 인접행렬은 2차원 배열의 행과 열을 통해 정점 간의 간선을 표현했는데, 인접 리스트는 이와 다르다. 1에 연결되어 있는 간선들을 A[1]에 저장하고, A[2]에는 2에 연결되어 있는 간선을 저장한다. 12345678910111213ArrayList&lt;Integer&gt;[] a = (ArrayList&lt;Integer&gt;[]) new ArrayList[N+1];for(int i=0;i&lt;=N;i++)&#123; a[i] = new ArrayList&lt;&gt;();&#125;for(int i=0;i&lt;M;i++)&#123; int v1 = sc.nextInt(); int v2 = sc.nextInt(); a[v1].add(v2); a[v2].add(v1);&#125; 같은 목적이지만 배열과 리스트를 통해 다르게 저장함으로써 큰 차이를 볼 수 있다. 인접 행렬은 크기가 정점과 간선의 개수와 상관없이 정점 갯수 x 정점 갯수이기 때문에 공간 복잡도가 O(V^2)이다. 하지만, 인접 리스트는 필요한 공간만 쓰기 때문에 O(V+E)가 된다. 인접 행렬보다는 인접 리스트를 사용하는게 훨씬 효율적이다. # DFS 한 우물만 깊게 파다가 막히면 그제서야 돌아가서 다른 우물을 파는 성향이 있다고 할 수 있다. 모든 정점을 1번씩 방문한다. 먼저 정점 하나를 선택한다. 그리고 그 정점의 아직 방문하지 않은 인접한 정점 중 하나를 선택해 방문한다. 0이 인접한 1을 방문하면 그 다음번에는 0에 인접한 다른 정점들보다 1에 인접한 정점들이 우선적으로 방문된다. 0번 정점에서 시작한다. 인접한 정점이 여러 개라면 그 중 번호가 제일 작은 것부터 방문한다. 빨간색이 지금 막 방문한 노드이고 녹색은 이전에 방문한 노드, 파란색은 아직 방문하지 않은 노드이다. 일단 처음 방문한 0번 노드와 인접한 노드는 1,2번이다. 이 중에서 더 작은 번호의 1번 노드를 방문한다. 그 다음에 2번 노드를 방문하는게 아니라 주체가 바뀌어서 1번 노드의 인접한 0,3,5번 노드 중 하나를 방문할 계획이다. 0번은 이미 방문했으니 3,5번 중 하나를 다음에 방문한다. 번호가 더 작은 3번 노드를 방문한다. 위의 그림처럼 더 작은 번호의 3번 노드를 방문한다. 다음에는 선택지가 하나밖에 없다. -&gt; 4번 노드 역시 선택지는 5번 노드밖에 없다. 5번 노드에서 더 이상 방문할 인접 노드가 없다. 모두 방문했기 때문. 이때는 5번 노드에서 추가로 다른 노드를 방문하지 않고, 자기를 불렀던 4번 노드로 돌아가서 4번 노드의 인접한 노드들 중 아직 방문하지 않은 정점을 찾아 방문해야 한다. 4번에서도 그게 없다면, 4번을 불렀던 3번으로 돌아가고 이와 같은 과정을 반복해서 0번 노드까지 돌아가게 된다. 0번 노드의 인접한 정점 중 아직 방문하지 않은 나머지 정점 2번 노드를 방문한다. 2번 노드는 마찬가지로 6번 노드를 방문한다. 6번 노드는 7번 노드를 이어서 방문한다. 여기서 또 7번 노드는 더 이상 방문할 곳이 없다. 이제 6번 노드로 돌아가서 6번 노드의 인접한 다른 정점인 8번 노드를 방문한다. 8번 노드를 방문하고 나면 아무리 돌아가도 더 이상 남아 있는 노드 중 방문할 정점이 없다. 이러면 탐색이 종료된 것이고, 시작점인 0번 노드와 직/간접적으로 연결되어 있는 모든 노드를 탐색한 것이다. 이 과정에서 만약 어떤 정점에서 더 방문할 노드가 없다면 자신을 불렀던 정점으로 돌아간다. 이걸 구현하기 위해서 스택(Stack)을 사용한다. 방문하는 순서대로 정점을 스택에 쌓고, 방문이 끝나면 스택에서 pop하는 형태로 구현이 가능하다. 재귀 함수 또한 스택 메모리 공간에 쌓아 올려지는 구조를 띄므로 재귀 함수를 사용하여도 이것을 구현할 수 있다. 시간 복잡도 인접 행렬을 사용하는 경우 : O(V^2) 인접 리스트를 사용하는 경우 : O(V+E) - 정점과 간선의 개수 합이다. # BFS 역시 모든 정점을 한 번씩 순회한다. DFS와 대립되는 성질을 갖고 있으며, 사용되는 곳도 매우 다르다. BFS 역시 컴포넌트의 개수를 세거나 각 컴포넌트의 크기를 구하는데는 사용 가능하다. DFS가 한 우물만 계속 파다가 끝을 보고 나서야 다른 곳으로 옮기는 데 반해, BFS는 모든 곳을 똑같이 조금씩 조금씩 판다. dfs와 동일한 그래프를 사용한다. 맨 처음에 0번 정점부터 방문을 시작한다. DFS와 다르게 0번 정점과 인접한 정점들부터 무조건 먼저 다 방문된다. 그 다음은 바로 전 단계에서 방문한 1,2번 정점들로부터 인접한 3,5,6,8번 정점들이 반드시 먼저 방문된다. 마지막으로 4,7번 정점이 방문된다. 각 단계의 정점들은 그 안에서 방문 순서가 바뀔 수는 있지만, 다른 단계와는 방문 순서가 절대 뒤섞이지 않는다. 0번 노드, 즉 시작점을 방문한 것을 0단계라 하고 그 다음부터 1,2,3 단계라고 부를 때, K단계에 방문하는 정점들은 시작점으로부터 최단거리가 k이다. 최단 거리 : 여기서는 가중치가 없으니까 A와 B의 최단거리는 A에서 B로 이동하는데 필요한 최소 개수의 간선이라고 보면 된다. DFS에 스택이 필요했던 것과 대조적으로 BFS는 큐가 필요하다. BFS는 먼저 방문한 노드들부터 본다. 먼저 시작점을 큐에 넣고 방문했다고 표시한다. 그리고 큐가 비어있지 않을 때까지 방문을 시도한다. 큐에서 지금 나온 정점의 인접한 노드들 중 아직 방문하지 않은 애들을 다시 큐에다 넣어준다. 이런 식으로 먼저 방문한 노드들부터 차례대로 방문해 나간다. 모든 가중치가 1인 경우에 최단 거리를 찾는 알고리즘이 된다. 최단 거리를 찾는 문제일 때, 모든 가중치가 1이라면 BFS를 사용한다. 마치며… 음, 아직 뭔가 감이 잡히진 않는다. 그래프를 탐색할 때 DFS와 BFS의 차이점은 알겠고 개념도 알겠는데 문제를 풀 때 어떻게 구현해야 하는지 잘 모르겠다. 다음 포스팅에서 직접 구현해보면서 정리해보도록 하겠다. 참고 깊이 우선 탐색(Depth-First Search) (수정 2019-02-17) 너비 우선 탐색(Breadth-First Search) (수정 2018-11-22)","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://woovictory.github.io/tags/DFS/"},{"name":"그래프","slug":"그래프","permalink":"https://woovictory.github.io/tags/그래프/"},{"name":"탐색","slug":"탐색","permalink":"https://woovictory.github.io/tags/탐색/"}]},{"title":"[Java] Array VS ArrayList","slug":"Java-Diff-Array-ArrayList","date":"2019-03-26T03:54:58.000Z","updated":"2020-04-22T07:47:23.778Z","comments":true,"path":"2019/03/26/Java-Diff-Array-ArrayList/","link":"","permalink":"https://woovictory.github.io/2019/03/26/Java-Diff-Array-ArrayList/","excerpt":"","text":"정렬과 관련된 알고리즘 문제를 풀고 있었다. 문제는 좌표 정렬하기이다. 비교적 간단한 문제이지만 Array와 ArrayList 모두 사용해서 풀 수 있는 문제이다. 하지만, 실행 시간이 다르다. 왜 다른지 찾아보기로 했다. 배열(Array) 배열의 크기는 한번 정하면 변경할 수 없다. ex) int[] arr = new int[10]; 배열 초기화 시에 메모리에 할당되어 ArrayList보다 빠른 속도를 가진다. 다차원이 가능하다. ArrayList 크기가 가변적이다. 저장하는 데이터의 수에 따라서 크기가 변한다. 데이터 추가는 add(), 삭제는 remove()를 사용한다. 데이터 추가, 삭제 시 메모리를 재할당하기 때문에 속도가 배열보다 느리다. # 참고 [JAVA] Array와 ArrayList 차이와 사용법 [자료구조/List] 자바 배열(Array)과 ArrayList 차이점 및 활용","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"배열","slug":"배열","permalink":"https://woovictory.github.io/tags/배열/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://woovictory.github.io/tags/ArrayList/"},{"name":"차이","slug":"차이","permalink":"https://woovictory.github.io/tags/차이/"},{"name":"자바","slug":"자바","permalink":"https://woovictory.github.io/tags/자바/"}]},{"title":"[Java] 기초","slug":"java-data-structure","date":"2019-03-25T03:27:02.000Z","updated":"2020-04-22T07:47:20.621Z","comments":true,"path":"2019/03/25/java-data-structure/","link":"","permalink":"https://woovictory.github.io/2019/03/25/java-data-structure/","excerpt":"","text":"자바를 사용해 알고리즘을 풀 때 유용하게 사용되는 것들을 정리합니다. # 입력 자바에서 입력을 받는 방법은 아래와 같이 두 가지가 존재합니다. Scanner 클래스 사용 BufferedReader 객체 사용 # Scanner 가장 간단하게 입력 받을 수 있는 방법. BufferedReader보다 나중에 등장했다. 123456789101112131415161718192021 // Scanner 객체 생성Scanner sc = new Scanner(System.in); // 숫자를 입력.int number = sc.nextInt(); // 공백을 포함시키지 않고 입력을 받는다.String word1 = sc.next(); // 공백을 포함해서 입력을 받는다.String word2 = sc.nextLine(); // 문자열을 입력받아서 문자열의 첫번째 문자에 접근할 수 있다.char ch = sc.next().charAt(0); String str = \"Hello\";str.charAt(0); // 'H' str.charAt(1); // 'e'str.charAt(2); // 'l'str.charAt(3); // 'l'str.charAt(4); // 'o' str.charAt() : charAt()을 이용해서str 문자열에 존재하는 문자에 접근할 수 있습니다. () 안에는 인덱스를 이용해서 접근합니다. charAt() : index를 사용해 문자열에서 문자 하나에 접근할 수 있다. 문자열 입력 sc.next() : 문자열에 개행문자나, 공백이 존재하면 무시하고 문자열만 입력받는다. sc.nextLine() : 문자열에 공백이 존재하면 포함시켜서 그대로 입력받습니다. 한 줄 단위로 입력받기 때문에 개행문자도 한 줄로 인식합니다. 장점 Scanenr는 사용하기 편리하다. 세분화 시켜서 데이터를 입력 받을 수 있다는 점입니다. sc.nextInt() : Int형 데이터를 입력받습니다. sc.nextDouble() : Double형 데이터를 입력받습니다. sc.nextBoolean() : Boolean형 데이터를 입력받습니다. sc.next() : String형 데이터를 입력받지만, 공백을 포함한 문자열에서 공백은 포함하지 않고, 공백 전까지만 입력받습니다. sc.nextLine() : String형 데이터를 입력받지만, 공백을 포함한 문자열에서 공백을 포함해서 입력받습니다. 단점 BuffredReader보다 속도가 느리다는 단점이 존재한다. # BufferedReader Scanner보다 속도가 훨씬 빠르다. 사용법이 Scanner보다 선언할 게 많다. 123// BufferedReader 객체 선언BufferedReader br = new BufferedReader(new InputStreamReader(System.in));int number = Integer.parseInt(br.readLine()); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); readLine()는 데이터를 읽어오는 함수이고, String 리턴 값을 가진다. InputStreamReader는 입력을 character 단위로 읽어 들인다. 키보드로 입력하는 글자 한개에 해당된다고 할 수 있습니다. 하지만 한 글자가 아닌 줄 단위의 문자열을 입력으로 받으려면 불편하다. 어떻게 해야 할까?? 정답은 BufferedReader이다. BufferedReader는 InputStreamReader에 버퍼링 기능을 추가한 것으로 데이터를 사용자가 요청할 때마다 매번 읽어오기 보다는 일정량 사이즈로 한번에 읽어온 후 Buffer에 보관합니다. 그리고 사용자가 요구할 때 버퍼에서 읽어오게 합니다. 결국 BufferedReader를 이용하면 속도를 향상시키고 시간의 부하를 줄일 수 있게 됩니다. StringTokenizer Scanner의 경우 nextInt()는 입력하면 자동으로 공백 다음의 숫자를 받는다. 입력받은 String에서 구분자를 통해서 구분하기 위해서 사용한다. 기본 설정은 공백을 기준으로 문자열을 나눈다. split() 함수와 비슷하다. nextTokne() 함수를 사용해 입력 값을 공백으로 구분하여 순서대로 호출할 수 있다. Scanner의 경우 그냥 nextInt를 입력하면 알아서 공백 다음 숫자를 받기 때문에 어려움 없이 사용할 수 있지만, 이 부분에서도 BufferedReader를 사용할 경우에는 조금 다른 방식을 취해야합니다. StringTokenizer를 이용하는 방식입니다. 이름과 같이 String을 특정 구분자값을 통해 분리하는 함수입니다. 기본적으로는 공백을 기준으로 문자열을 가릅니다. split()함수와 비슷하다고 생각하면 됩니다. 사용법은 어렵지 않다. 아래와 같다. 12345BufferedReader br = new BufferedReader(new InputStreamReader(System.in));StringTokenizer st = new StringTokenizer(br.readLine());int test = Integer.parseInt(st.nextToken());int number = Integer.parseInt(st.nextToken()); # 결론 Scanner 버퍼 크기 : 1024 chars 입력하는 데이터 타입에 따라 다르게 입력받을 수 있다. 동기화되지 않는다. 예외를 숨긴다. BufferedReader 버퍼 크기 : 8192 chars 문자열을 읽고 원하는 타입으로 바꾸기 위해 형 변환을 진행한다. 동기화가 된다. 예외 발생시 IOException 처리를 던진다. 큰 파일을 읽을 때는 버퍼 크기가 크므로 BufferedReader이 좋습니다. 동기화라는 것에 대해서 조금 살펴보았습니다. 이 부분은 운영체제(즉, OS) 분야에서 다루는 내용이지만, 꼭 알아야 하는 내용이기도 합니다. 저는 아직 OS 공부를 하지 않았지만, 공부하면서 찾아본 내용과 예전 학교 수업시간에 들었던 내용을 떠올리면서 정리했습니다. BufferedReader는 멀티 쓰레드에 안전하고, Scanner는 안전하지 않다. 라는 말이 있습니다. 그것이 위에서의 3번의 경우입니다. 멀티 쓰레드의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유하기 때문에 서로의 작업에 영향을 줄 수 있습니다. 예를 들어, A 쓰레드가 작업 중입니다. 그러던 중 B 쓰레드에게 넘깁니다. B 쓰레드에서 공유 데이터를 변경하고 A 쓰레드에 다시 제어권을 넘긴다면 예기치 않은 결과가 나올 수 있습니다. 제대로 된 처리를 위해서는 A 쓰레드가 작업이 끝날 때까지 다른 쓰레드가 영향을 주지 않아야 합니다. 그리하여 멀티 쓰레드를 활용하는 소켓 예제에서는 대부분 BufferedReader를 많이 사용한다고 합니다. # Pair 두 자료형 T1과 T2를 묶어서 사용할 수 있도록 해주는 역할을 합니다. 같은 자료형 뿐만 아니라 서로 다른 자료형 T1과 T2를 묶어서 사용할 수 있도록 해주는 역할을 합니다. 즉, 두 객체를 하나의 객체로 취급할 수 있도록 묶어주는 클래스입니다. # 구현 항상 두 개를 묶어서 사용하고, 첫 번째 자료는 first, 두 번째 자료는 second로 접근할 수 있습니다. C++ 언어에서는 STL이라는 Standard Template Library를 이용해서 사용할 수 있지만, 자바에서는 제공되지 않아서 직접 구현해서 사용해야 하는 것으로 알고 있습니다. 자바는 기본적으로 반환 결과를 2개 이상 제공하지 않습니다. 그래서 2개 이상의 결과를 반환 받기 위해서는 객체나 배열의 형태를 보이게 됩니다. C++에서는 pair가 존재하지만, 자바에서는 없는 것으로 알고 있습니다. 여러가지 자료를 찾아보다가 밑에 코드를 찾았습니다. 12345678910111213class Pair&lt;L,R&gt; &#123; final L left; final R right; public Pair(L left, R right) &#123; this.left = left; this.right = right; &#125; static &lt;L,R&gt; Pair&lt;L,R&gt; of(L left, R right)&#123; return new Pair&lt;L,R&gt;(left, right); &#125;&#125; # Tuple Tuple이란 여러 개의 자료형을 묶을 수 있는 클래스입니다. tuple은 pair와 같지만 두 개가 아니라 여러 개를 묶을 수 있습니다. .first, .second, .third …가 아니고 get을 이용해서 인덱스로 접근해야 합니다. 구현 자바에서는 pair와 tuple이 존재하지 않기 때문에 구현해서 사용해야 합니다. 1234567891011121314151617181920public class Tuple&lt;X,Y&gt;&#123; private X x; private Y y; public Tuple(X x, Y y)&#123; this.x = x; this.y = y; &#125; public X getX()&#123; // get을 이용해서 접근 return x; &#125; public Y getY()&#123; // get을 이용해서 접근 return y; &#125; public void setX(X x)&#123; // set을 이용해서 값을 설정 this.x = x; &#125; public void setY(Y y)&#123; // set을 이용해서 값을 설정 this.y = y; &#125;&#125; # BigInteger Java에서 정수를 계산할 때, byte,short,int,long등의 기본 데이터 타입의 범위를 초과하는 경우가 있습니다. 이런 경우에, BigInteger Class를 사용하는 방법이 있습니다. 기본 자료형 크기 이상의 정수가 필요하다면 BigInteger Class를 사용할 수 있습니다. BigInteger Class는 숫자의 크기에 제한 없이 무한대의 정수를 저장할 수 있습니다. math 클래스에 포함되어 있습니다. 즉, 범위는 무한대 객체 생성 방법 12BigInteger a = new BigInteger(\"100000\");BigInteger b = new BigInteger(\"1000\"); 연산 1234567891011System.out.println(\"a+b = \" + a.add(b)); // 더하기System.out.println(\"a-b = \" + a.subtract(b)); // 빼기System.out.println(\"a*b = \" + a.multiply(b)); // 곱하기System.out.println(\"a/b = \" + a.divide(b)); // 나누기(몫)System.out.println(\"a%b = \" + a.remainder(b)); // 나머지System.out.println(\"gcd(a,b) = \" + a.gcd(b)); //a와 b의 최대공약수System.out.println(\"ZERO = \" + BigInteger.ZERO); // 0System.out.println(\"ONE = \" + BigInteger.ONE); // 1System.out.println(\"TEN = \" + BigInteger.TEN); // 10System.out.println(\"a^10 = \" + a.pow(10)); // a 제곱 비교 compareTo - int type의 변수를 사용 1234567891011BigInteger a = sc.nextBigInteger(); // 무한대의 정수를 입력받을 수 있다.BigInteger b = sc.nextBigInteger(); // 무한대의 정수를 입력받을 수 있다. int c = a.compareTo(b);if (c &lt; 0) &#123; // a가 b보다 작을 경우 System.out.println(\"&lt;\");&#125; else if (c == 0) &#123; // a와 b가 같은 경우 System.out.println(\"==\");&#125; else &#123; // a가 b보다 클 경우 System.out.println(\"&gt;\");&#125;System.out.println(\"compareTo = \" + c); equals - boolean type의 변수를 사용 1234567boolean e = a.equals(b);if(e)&#123; System.out.println(\"==\");&#125; else&#123; System.out.println(\"!=\");&#125;System.out.println(\"equals = \" + e); 주의할 점 Q. 생성자의 매개변수를 문자형으로 전달해야 하는 이유는? A. 숫자형으로 표현할 수 있는 범위를 벗어났기 때문에 문자형으로 표현하는 것입니다. # BigDecimal BigDecimal은 무한한 크기의 부동 소수점 숫자 즉, 실수를 다루기 위해 사용됩니다. 이유는 컴퓨터의 특성으로 인해서 float이나 double은 실수 연산시 정확한 결과가 나오지 않기 때문입니다. 하지만, BigDecimal을 사용하면 계산은 번거롭지만 정확한 결과를 얻을 수 있습니다. BigInteger와 유사한 방식으로 숫자를 다룹니다. 12345678910111213BigDecimal b1 = new BigDecimal(\"0.3\");BigDecimal b2 = new BigDecimal(\"0.4\");System.out.println(b1.add(BigDecimal.valueOf(0.5)));System.out.println(b1.multiply(b2));System.out.println(b1.divide(b2, BigDecimal.ROUND_UP));System.out.println(b1.divide(b2, 5, BigDecimal.ROUND_UP));Scanner sc = new Scanner(System.in);BigDecimal a = sc.nextBigDecimal();int b = sc.nextInt(); System.out.println(a.pow(b).toPlainString()); BigDecimal의 자주 사용되는 메소드 123456789101112131415float floatValue() //값을 float형으로 반환double doubleValue() //값을 double형으로 반환BigInteger toBigInteger() //값을 BigInteger로 반환 (소수점 아래는 날아감)BigDecimal add(BigDecimal augend) //덧셈 + 연산BigDecimal subtract(BigDecimal subtrahend) //뺄셈 - 연산BigDecimal multiply(BigDecimal multiplicand) //곱셈 * 연산BigDecimal divide(BigDecimal divisor) //나눗셈 / 연산BigDecimal remainder(BigDecimal divisor) //나머지 % 연산 일반 실수형을 계산할 때는 아래와 같은 오차가 발생합니다. 123456789101112131415double d1 = 1.0;double d2 = 0.1;for(int i=0; i&lt;5; ++i)&#123; d1 += d2; System.out.println(d1);&#125; 결과 : 1.11.20000000000000021.30000000000000031.40000000000000041.5000000000000004 BigDecimal의 생성자는 여러가지가 있지만, 가장 정확한 계산을 위해서는 문자열을 인자로 하는 생성자를 이용해야 합니다. 실수형 인자를 사용하면 정확한 계산의 의미가 없어집니다. 1234567891011121314151617double d1 = 1.0;double d2 = 0.1; BigDecimal bd1 = new BigDecimal(String.valueOf(d1));BigDecimal bd2 = new BigDecimal(String.valueOf(d2)); for(int i=0; i&lt;5; ++i)&#123; bd1 = bd1.add(bd2); System.out.println(bd1.toString());&#125; 결과 :1.11.21.31.41.5 그리고 BigDecimal의 값을 출력하려면 setScale(scale, roundingMode)로 단위 및 라운딩 모드를 설정하거나 toString() 또는 toPlainString() 메소드를 사용한다. toString() 메소드는 과학적 표기를 사용할 수 있지만, toPlainString() 메소드는 그렇지 않습니다. 과학적 표기란? 0.1^10의 과학적 표기는 1E-10 그렇지 않은 일반 표기는 0.0000000001 # BufferedWriter 일반적으로 출력할 때 System.out.prinlnt() 사용 테스크 케이스가 작을 때는 속도 차이가 미미하다. 하지만 테스트 케이스가 매우 커지면 속도 차이가 확연하다고 한다. 언제 사용하고 언제 사용하지 않을까? 출력이 많은 경우 : BuffredWriter 사용. 출력이 적은 경우 : System.out.println() 사용. bw(BuffredWriter 객체)의 사용이 끝나면 flush()나 close() 함수를 이용해 객체를 반환해줘야 한다. 반환하지 않으면 출력이 제대로 이뤄지지 않을 수도 있다. 1234BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));bw.writer(\"Hello \\b\");bw.flush();bw.close(); # EOF 알고리즘 문제를 풀다 보면 EOF 문제에 대해 봉착하는 경우가 있습니다. EOF(End Of File) : 파일 끝을 의미하며, 데이터 소스로부터 더 이상 읽을 데이터가 없음을 나타냅니다. 알고리즘 문제를 풀다보면 입력 부분의 기준이 없는 문제를 본 적이 있을 것입니다. 자바에서는 입력 클래스가 Scanner,BufferedReader 2가지로 구성됩니다. # Scanner 클래스의 EOF 처리 방법 12345678Scanner sc = new Scanner(System.in);while(sc.hasNextLine())&#123; sc.nextLine();&#125;while(sc.hasNextInt())&#123; sc.nextInt();&#125; # BufferedReader의 EOF 처리 방법 1234567BufferedReader br = new BufferedReader(new InputStreamReader(System.in);String input = \"\";while((input = br.readLine()) != null) &#123; //......&#125; # 배열 12345int[] array1 = new int[10];int[] array2;array2 = Arrays.copyOf(array1,10);Arrays.sort(array1); Arrays.copyOf(array1,10) : arrya1을 길이 10으로 해서 똑같이 복사하는 함수입니다. Arrays.sort(array1) : array1을 정렬해주는 함수입니다. 자바 컬렉션 프레임워크 중의 하나로 볼 수 있습니다. # 입력 속도 비교 Scanner와 BufferedReader의 입력 받는 속도를 비교해본다. 1. Scanner를 이용해 100만까지의 데이터를 입력받는다. 123456789101112131415161718import java.util.Scanner;public class inputExam &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int t; sc.nextLine(); long st1 = System.currentTimeMillis(); for(int i=0;i&lt;1000000;i++)&#123; t= sc.nextInt(); &#125; System.out.println(\"소요 시간 : \"+(System.currentTimeMillis() - st1)+\"ms\"); sc.close(); &#125;&#125;// 결과소요시간 : 2441ms 소요 시간 : 2.5초 빠른 것 같지만 실제 알고리즘 문제에서 수의 범위는 천만~1억에 이르는 경우도 종종 있다. 다른 연산도 있기 때문에 빠른 속도라고는 할 수 없다. 2. BufferedReader를 이용해 100만까지의 데이터를 입력받는다. 123456789101112131415161718import java.util.Scanner;public class inputExam &#123; public static void main(String[] args) &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); bf.readLine(); int t; long st2 = System.currentTimeMillis(); for(int i=0;i&lt;1000000;i++)&#123; t = Integer.parseInt(bf.readLine()); &#125; System.out.println(\"소요 시간 : \"+(System.currentTimeMillis() - st2)+\"ms\"); &#125;&#125;// 결과소요 시간 : 4ms 소요 시간 : 0.4초 한 줄을 통째로 입력 받는 방식이기 때문에 1 2 3 4 … 과 같이 한 줄로 입력이 들어올 때 Scanner에 비해 훨씬 성능이 높다. 문제를 풀 때 코드의 문제가 없는데 시간 초과가 난다면 문제의 범위를 다시 확인해보고 입력 방식을 알맞게 바꾸면 해결할 수 있을 것이다. # BufferedReader 추가 이야기! 12345BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));String s = bf.readLine(); // 1int a = bf.read(); // 2int b = Integer.parseInt(bf.readLine()); // 3 1번 : 입력받을 값이 String일 때 2번 : 입력받을 값이 int일 때 3번 : int 값 + enter 까지 입력받을 때 알고리즘 사이트에서 대부분의 데이터 입력은 한줄씩 띄워진 상태로 입력이 들어옵니다. 따라서 int b를 입력받은 방법처럼 일단 스트링으로 개행문자(엔터)까지 포함해 통째로 받아온 다음 형 변환을 통해 저장합니다. 또한 new BufferedReader(new InputStreamReader(System.in),1024); 이렇게 버퍼 사이즈를 직접 지정할 수도 있는데, 아무것도 지정하지 않을 시 디폴트 사이즈 버퍼를 갖습니다. 어지간한 문제는 디폴트 사이즈로 충분하다고 하네요… ㅎㅎ;","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[소수 구하기] 에라토스테네스의 체","slug":"Algo-Get-the-Prime","date":"2019-03-24T05:09:02.000Z","updated":"2020-05-12T06:44:33.576Z","comments":true,"path":"2019/03/24/Algo-Get-the-Prime/","link":"","permalink":"https://woovictory.github.io/2019/03/24/Algo-Get-the-Prime/","excerpt":"","text":"소수를 구하는 방법은 여러가지가 있다. 하지만 시간이 덜 거리고 빠르게 찾을 수 있는 방법이 있다면 사람들은 그 방법을 사용하지 않을까? 맞다. 사람들은 짧은 시간이 걸리는 것을 선호한다. 세상의 공짜란 없듯이 짧은 시간이 걸리는 방법은 구현 방법이 기존보다는 조금 어렵다. 그렇다면 어떤 방법인지 알아보자. 소수란? 1과 자기 자신으로만 나누어 떨어지는 수를 소수라고 한다. 즉, 자기 자신보다 작은 수들로 나누어봐서 하나라도 나누어 떨어지는 수가 존재하면 소수가 아니라는 뜻이다. 에라토스테네스의 체 소수의 개념을 간단하게 알아봤으니 에라토스테네스의 체 방법을 알아보자. 120까지의 모든 소수를 구한다고 가정해보자. 2부터 120까지 수를 배열에 모두 넣는다. 소수가 아닌 수들을 모두 체크해버린다. 2를 제외한 모든 2의 배수를 체크한다. 3을 제외한 모든 3의 배수를 체크한다. 4를 제외한 모든 4의 배수를 체크한다. 이와 같은 방식으로 소수가 아닌 수들을 체크한다. 그러면 배열에서 체크되지 않은 수들은 소수만 남게 된다. 생각보다 그렇게 어렵지 않고 간단하게 이해하고 구현할 수 있다. # 첫 번째 방법 12345678910111213141516171819202122232425262728293031323334public class Main &#123; private static final String NEW_LINE = \"\\n\"; private static final String SPACE = \" \"; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] input = br.readLine().split(SPACE); int m = Integer.parseInt(input[0]); int n = Integer.parseInt(input[1]); int[] arr = new int[n + 1]; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 2; j &lt;= n; j ++) &#123; // 자신과 같지 않고 0으로 나누어 떨어지면 소수가 아니다. if(arr[j] !=i &amp;&amp; arr[j] % i == 0)&#123; arr[j] = 0; // 소수가 아닌 경우 0을 넣는다. &#125; &#125; &#125; for (int i = m; i &lt;= n; i++) &#123; if (arr[i] != 0) &#123; bw.write(i + NEW_LINE); &#125; &#125; bw.flush(); bw.close(); br.close(); &#125;&#125; 위의 방식으로 구하면 에라토스테네스의 체 방식을 이용하지 않는 방식보다 시간이 오래 걸린다. 그러면 우리가 이 방식을 사용하는 의미가 없지 않는가?? 이제 에라토스테네스의 체를 이용해 최상의 소수 구하기 프로그램을 만들어보자. # 두 번째 방법 체크할 때 모든 수를 다 돌면서 체크할 필요 없이 체크할 배수만큼만 반복문을 돌게 하는 것이다. 그리고 이미 0으로 체크되어버린 수의 배수는 확인하지 않는다. 왜냐하면 어떤 수가 소수가 아니라면 그 수의 배수도 소수가 아니기 때문이다. ex) 2를 제외한 2의 배수를 체크한다. 2,4,6,8,10,12,14 … 4를 제외한 4의 배수를 체크한다. 4,6,8,12,16,… 이미 2의 배수를 체크할 때 체크가 되어 있기 때문에 건너뛸 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; private static final String NEW_LINE = \"\\n\"; private static final String SPACE = \" \"; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] input = br.readLine().split(SPACE); int m = Integer.parseInt(input[0]); int n = Integer.parseInt(input[1]); boolean[] check = new boolean[n + 1]; // 에라토스테네스의 체에서 0과 1은 제외하고 시작하기 때문에 체크한다. check[0] = check[1] = true; for (int i = 2; i &lt;= n; i++) &#123; // 체크되어 있으면 건너뛴다. // 체크가 되어 있다는 뜻은 소수가 아니라는 뜻이다. if (check[i]) &#123; continue; &#125; // 해당 수의 배수만큼 반복문을 돌면서 체크한다. for (int j = i + i; j &lt;= n; j += i) &#123; // 소수가 아닌 것들을 true로 체크한다. check[j] = true; &#125; &#125; for (int i = m; i &lt;= n; i++) &#123; if (!check[i]) &#123; bw.write(i + NEW_LINE); &#125; &#125; bw.flush(); bw.close(); br.close(); &#125;&#125; 이 경우 결과는 매우 짧은 시간이 나오는 것을 확인할 수 있었다. 앞으로 소수를 구할 때는 에라토스테네스의 체 방식을 이용하자. 참고 소수 구하기 최적의 알고리즘 (2) - 에라토스테네스의 체","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"소수 구하기","slug":"소수-구하기","permalink":"https://woovictory.github.io/tags/소수-구하기/"},{"name":"에라토스테네스의 체","slug":"에라토스테네스의-체","permalink":"https://woovictory.github.io/tags/에라토스테네스의-체/"}]},{"title":"[알고리즘] 정렬 알고리즘 Part2","slug":"Algo-Shell-Sort","date":"2019-03-22T16:05:14.000Z","updated":"2020-05-12T06:44:37.729Z","comments":true,"path":"2019/03/23/Algo-Shell-Sort/","link":"","permalink":"https://woovictory.github.io/2019/03/23/Algo-Shell-Sort/","excerpt":"","text":"저번에 살펴봤던 기본적인 정렬 알고리즘에 이어 이번에는 조금 어려운 정렬 알고리즘을 살펴보자. 물론 이번 것도 어려운 것은 아니지만 상대적으로 비교해봤을 때 저번 정렬 알고리즘들보다 어렵다! # 쉘 정렬 삽입 정렬을 보완한 알고리즘이다. 삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠르다는 것에 착안한 것이다. 삽입 정렬의 최대 문제점 : 요소들이 삽입될 때, 이웃한 위치로만 이동한다. 다시 말해서 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야 제자리로 갈 수 있다. 삽입 정렬과 다르게 쉘 정렬은 전체의 리스트를 한 번에 정렬하지 않는다. 그래서 요소들이 멀리 떨어진 위치로 이동할 수 있다. 기본 로직은 아래와 같다. 먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류한다. 연속적이지 않은 여러 개의 부분 리스트를 생성한다. (실제로 여러 개의 부분 리스트가 생기고 이것들을 병합하는 것이 아니라, 단순히 gap 값으로 간격을 주어 부분 리스트가 만들어진 것처럼 구현한다. ) 각 부분 리스트를 삽입 정렬을 이용하여 정렬한다. 모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복한다. 위의 1~4번까지의 과정을 리스트의 개수가 1이 될 때까지 반복한다. 기본 로직은 이렇지만 사실 잘 와닿지 않는다. 한 번 더 살펴보자. 정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때, k를 간격(gap)이라고 한다. 간격(gap) 즉 k의 초기값 : (정렬할 값의 개수) / 2 생성된 부분 리스트의 개수는 gap과 같다. 각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다. 간격은 홀수로 하는 것이 좋다. (간격을 정하는 방법은 여러가지다.) 간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다. 간격 k(gap)가 1이 될 때까지 반복한다. 장점 연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 더 큰 거리를 이동한다. 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다. 부분 리스트는 어느 정도 정렬된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 쉘 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 정렬된 상태이므로 삽입 정렬보다 더욱 빠르게 수행된다. 알고리즘이 간단해서 쉽게 구현이 가능하다. 시간 복잡도 평균 : O(N^1.5) 최악의 경우 : O(N^2) 장점 연속적이지 않은 부분 리스트에서 자료의 교환을 진행하여 더 큰 거리를 이동한다. 기존의 삽입 정렬에서는 한 칸씩 이동하며 비교를 하여 key 값의 자리를 찾았기 때문에 먼 거리를 이동할 경우 그만큼 반복 비교 연산이 많이 일어나는 단점이 있었다. 더 큰 거리를 이동함으로써 교환되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높아진다. 최종 자리를 더 빨리 찾아감으로써 연산의 횟수를 줄이는데 기여할 수 있다. 삽입 정렬은 어느 정도 정렬이 된 배열에서 더 빠르게 동작한다는 것을 앞의 포스팅에서 살펴봤다. 이 점을 토대로 한 번에 정렬을 끝내는 것이 아니라 부분 리스트를 구성해 조금씩 정렬된 상태를 만들어가는 것이므로 삽입 정렬에 비해 속도가 점점 더 빠르게 수행된다. # 합병 정렬 존 폰 노이만 선생님이 제안한 방법. 일반적인 방법으로 구현했을 때 이 정렬은 안정 (stable) 정렬에 속하며, 분할 정복 알고리즘의 하나이다. 분할 정복(divide and conquer) 방법 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략. 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다. 오름 차순을 기준으로 정렬한다. 기본 로직은 다음과 같다. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.(리스트의 길이가 1이 될때까지 반으로 잘게 나눈다.) 그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 나눠 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 구체적으로 다시 설명해보면 다음과 같다. 최종 목표는 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 것이다. 합병 정렬은 다음의 단계들로 이루어진다. 분할(Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다. 정복(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출(재귀 호출)을 이용하여 다시 분할 정복 방법을 적용한다. 결합(Combine) : 정렬된 부분 배열을 하나의 배열에 합병한다. 합병 정렬의 과정 추가적인 리스트가 필요하다. 각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다.(재귀 호출) 합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 합병(Merge)하는 단계이다. 장점 안정적인 정렬 방법이다. stable하다. 데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. -&gt; O(n logn)으로 동일. 만약 레코드를 연결 리스트(LinkedList)로 구성하면 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다. 제자리 정렬(in-place sorting)을 구현할 수 있다. 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다. 단점 만약 레코드를 배열로 구성하면, 임시 배열이 필요하다. 메모리 낭비를 초래할 수 있다. 제자리 정렬(in-place sorting)이 아니다. 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다. 시간 복잡도 크기가 N인 배열을 반으로 쪼개면서 분할한다. 한 번 분할하면 N/2, N/2 -&gt; 2개가 생기고, 그 다음 분할하면 N/4, N/4, N/4, N/4 -&gt;4개 이처럼 분할 과정은 매번 반씩 감소하므로 밑이 2인 log N만큼 반복해야 크기가 1인 배열로 분할 할 수 있다. 각 분할별로 합병을 진행하므로 합병 정렬의 시간 복잡도는 O(NlogN)이다. 평균 : NlogN 최악 : NlogN 최상 : NlogN 다음의 글을 참고하자. -&gt; 병합 정렬의 시간복잡도 # 퀵 정렬 오름차순을 기준으로 정렬한다. '찰스 앤터니 리처드 호어’가 개발한 정렬 알고리즘이다. 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 갖는다. Merge Sort와 달리 퀵 정렬은 리스트를 비균등하게 나눈다. 분할 정복 방법(Divide and Conquer) 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략. 분할 정복 방법은 순환 호출(재귀 호출)을 이용하여 구현한다. 기본 로직은 다음과 같다. 리스트 안에서 하나의 원소를 선택한다. 이 원소를 피봇이라고 한다. 피봇을 기준으로 왼쪽에는 피봇보다 작은 원소들을 옮기고 오른쪽에는 피봇보다 큰 원소들을 옮긴다. 피봇을 제외한 왼쪽 부분 집합과 오른쪽 부분 집합을 다시 정렬한다. 분할된 부분 집합에 대해 순환 호출을 이용하여 정렬을 반복한다. 부분 집합에 대해서도 다시 피봇을 정하고 피봇 기준으로 2개의 부분 집합으로 나누는 과정을 반복한다. 부분 집합이 더 이상 분할이 불가능할 때까지 반복한다. 리스트의 크기가 0이나 1이 될 때까지 반복한다. 퀵 정렬에서 알아야 할 개념 분할(Divide) : 정렬할 자료들을 피봇을 중심으로 좌, 우 2개의 부분집합으로 나누는 것을 말한다. 정복(Conquer) : 부분집합의 원소들 중에서 피봇보다 작은 원소들은 왼쪽, 큰 원소들을 오른쪽 부분집합으로 정렬하는 과정이다. 부분 집합의 크기가 더 이상 나눌 수 없을 때까지(부분 집합의 원소가 1개 이하) 분할, 정복 과정이 반복된다. 피봇 : 기준 값(일반적으로 전체 원소 중 가운데에 위치한 원소) L : 왼쪽에서 오른쪽으로 움직이며 피봇보다 큰 원소를 찾아 L로 지정. R : 오른쪽에서 왼쪽으로 움직이며 피봇보다 작은 원소를 찾아 R로 지정. 장점 속도가 빠르다. 시간 복잡도가 O(NlogN)을 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다. 추가 메모리 공간을 필요로 하지 않는다. 퀵 정렬은 O(NlogN) 만큼의 메모리를 필요로 한다. 단점 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다. 퀵 정렬의 불균형 분할을 방지하기 위해 피봇을 선택할 때 리스트를 더욱 균등하게 분할할 수 있는 데이터를 선택한다. Ex) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값을 피봇으로 선택한다. 시간 복잡도 평균, 최선 : O(NlogN) 최악 : O(N^2) 일반적으로는 O(NlogN)의 성능을 나타내지만, 피봇이 항상 최솟값이나 최댓값으로 잡힙다면 최악의 성능인 O(N^2) 나온다. 이미 정렬된 리스트에 대해서 첫 번째 원소 혹은 마지막 원소를 피봇으로 선택할 경우 최악의 성능을 맛 볼 수 있다. 그래서 중간 값을 피봇으로 선택하는 것이 시간 복잡도가 최악의 경우인 O(N^2)을 피할 수 있는 방법이기도 하다. 느낀 점 정렬 알고리즘은 크게 보면 두 가지 분류로 나눌 수 있을 것 같다. 단순(구현이 간단)하지만 비효율적인 방법 삽입 정렬, 선택 정렬, 버블 정렬 복잡하지만 효율적인 방법 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬 이 중에서 퀵 정렬이 가장 어려웠다. 개념을 이해하고 코드를 보는데 이해가 되지 않았다. 여러 사람들이 정리한 블로그를 참고해서 코드를 보니까 조금씩 구현이 달라서 방향을 잡지 못했다. 그래서 2개의 블로그를 참고해서 코드를 돌려보면서 실제로 디버깅을 해보니까 이해가 확실히 갔다. 생각보다 정렬 알고리즘이 재미있었다. 기억력이 오래 갔으면 좋겠지만 아닐 수도 있으니 빠른 시일 내에 복습을 해야겠다. 참고 [알고리즘] 셸 정렬(shell sort)이란 &lt;셸 정렬(shell sort)&gt; 기본 개념 및 알고리즘 퀵 정렬(Quick Sort) - C언어/자료구조 자바로 구현하는 퀵정렬 (Quick Sort) 알고리즘 [알고리즘] 퀵 정렬(quick sort)이란","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"정렬","slug":"정렬","permalink":"https://woovictory.github.io/tags/정렬/"},{"name":"쉘 정렬","slug":"쉘-정렬","permalink":"https://woovictory.github.io/tags/쉘-정렬/"},{"name":"퀵 정렬","slug":"퀵-정렬","permalink":"https://woovictory.github.io/tags/퀵-정렬/"},{"name":"병합 정렬","slug":"병합-정렬","permalink":"https://woovictory.github.io/tags/병합-정렬/"}]},{"title":"[정렬] 정렬 알고리즘 Part1","slug":"Algo-Select-Sort","date":"2019-03-20T08:04:04.000Z","updated":"2020-05-12T06:44:35.859Z","comments":true,"path":"2019/03/20/Algo-Select-Sort/","link":"","permalink":"https://woovictory.github.io/2019/03/20/Algo-Select-Sort/","excerpt":"","text":"정렬 알고리즘은 개발자 면접을 보기 위해서 꼭 필요한 내용이다. 하나씩 정리해보고 숙지해보자. 정렬 알고리즘은 다음과 같이 간단하게 나눠볼 수 있다. 단순하지만 비효율적인 방법 선택 정렬, 삽입 정렬, 버블 정렬 복잡하지만 조금 더 효율적인 방법 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬 Q. 정렬은 왜 사용할까? 탐색을 빠르게 하기 위해서 정렬을 한다. 하지만 정렬 방법은 많고 이 중에서 제일 빠른 걸 사용해야 한다. 같은 시간 복잡도를 갖더라도 요소에 따라 달라질 수 있으니 알아보자. # 선택 정렬 기본이 되는 정렬 중 하나이다. 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라서 최소 선택 정렬(오름차순으로 정렬)과 최대 선택 정렬(내림차순으로 정렬)이 있다. 기본로직은 아래와 같다. 정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후 배열의 값 중 가장 작은 값을 찾는다. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다. 다음 인덱스에서 위의 과정을 반복한다. 쉽게 설명하면 기준이 되는 수와 나머지 수를 비교해서 가장 작은 수를 앞으로 계속 보내는 정렬이다. 간단하지만 매우 비효율적이다. 최악의 경우, 최선의 경우, 평균적인 경우 모두 시간 복잡도 : O(N^2)을 갖는다. 장점 데이터의 양이 적을 때 좋은 성능을 나타냄 적은 값을 선택하기 위해서는 비교는 여러번 수행되지만 교환횟수가 적다. 단점 100개 이상의 자료에 대해서는 속도가 급격히 떨어져 적절히 사용되기 힘들다. # 버블 정렬 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘을 갖는다. 인접한 2개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다. 선택 정렬과 기본 개념이 유사함. 기본 로직은 아래와 같다. 버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를 … n-1번째 자료와 n번째 자료를 비교하여 교환하면서 자료를 정렬한다. 1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동한다. 이렇기 때문에 2회전에서는 맨 끝에 있는 자료가 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다. 쉽게 설명하면 현재 원소와 다음 원소를 비교해서 큰 원소를 뒤로 보내는 정렬이다. 최악의 경우, 최선의 경우, 평균적인 경우 모두 시간 복잡도 : O(N^2)을 갖는다. 이미 정렬된 데이터에 대해서 검사하는데는 O(N)으로 간단하게 할 수 있다. 장점 구현이 쉽다. 이미 정렬된 데이터를 정렬할 때 가장 빠르다. 단점 다른 정렬에 비해 정렬 속도가 느리다. 역순배열을 정렬할 때 가장 느리다. 정말 비효율적이라 거의 쓰이지 않는다. # 삽입 정렬 삽입 정렬의 기본 개념은 손안의 카드를 정렬하는 방법과 유사하다. 새로운 카드를 기존의 정렬된 카드 사이에 올바른 자리를 찾아 삽입한다. 새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다. 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘. 매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다. 기본 로직은 아래와 같다. 오름차순을 기준으로 정렬한다. 기준이 되는 인덱스는 두 번째 자료부터 시작한다. 이 기준이 되는 인덱스를 Key라고 하겠다. Key가 들어갈 자리를 찾는게 핵심이다. Key는 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료들을 뒤로 옮기고 지정한 자리에 Key 자료를 삽입하여 정렬한다. 즉, 두 번째 자료는 첫 번째 자료와 비교하고 세 번째 자료는 두 번째와 첫 번째 자료 … 이런 방식으로 비교해서 기준이 되는 자료가 들어갈 위치를 찾는다. 최종적으로 Key가 들어갈 위치를 찾았다면 자료들을 한칸씩 뒤로 이동시키고 그 자리에 삽입한다. 쉽게 말하면 기준이 되는 인덱스의 앞쪽(왼쪽)을 검사하여 기준이 되는 인덱스가 들어갈 자리를 찾아서 삽입하는 정렬이다. 최악의 경우 : O(N^2) - 자료가 역순으로 정렬되어 있을 경우/작은 값이 뒤에 몰려있을 경우 최선의 경우 : O(N) - 이동없이 1번의 비교만 이루어질 경우 평균적인 경우 : O(N^2) 장점 stable한 정렬 방법 적은 수를 정렬할 경우 알고리즘 자체가 간단해서 다른 복잡한 정렬 방법보다 유리할 수 있다. 대부분의 수가 이미 정렬되어 있는 경우에 매우 효율적이다. 단점 비교적 많은 수들의 이동을 포함한다. 비교할 수가 많고 크기가 클 경우에 적합하지 않다. 결론 위에서 살펴본 정렬 알고리즘들은 비교적 구현이 간단하다. 그리고 이해하기도 어렵지 않다. 하지만 속도가 느리다는 단점이 존재한다. 다음에는 이보다 속도가 좋은 정렬 알고리즘을 살펴보도록 하겠다. stable과 unstable stable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌지 않는 경우 unstable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌는 경우 다음의 예를 한 번 생각해보자. ex) 5, 4, 8, 8, 5, 3, 1, 10, 6 숫자가 있고 순서를 부여해보자. ex 5(1), 4(2), 8(3), 8(4), 5(5), 3(6), 1(7), 10(8), 6(9) ()안의 숫자는 해당 노드(수)가 들어온 순서를 뜻한다. 만약 정렬할 시에 key 값을 기준으로 정렬을 하되, 같은 key 값을 가진 노드는 들어온 순서에 따라 다시 정렬되어야 한다면 어떻게 할 것인가? 다음 결과와 같이 최종적으로 정렬된 정보가 바로 stable한 것이다. 정렬된 결과는 다음과 같다. ex) 1(7), 3(6), 4(2), 5(1), 5(5), 6(9), 8(3), 8(4), 10(8) 선택 정렬 : unstable ex) 5(1), 4(2), 5(3), 2(4), 3(5) 위에서 5(1)과 2(4)를 교환한다. ex) 2(4), 4(2), 5(3), 5(1), 3(5) 위의 결과가 나온다. 처음의 순서를 유지하지 않게 된다. 이러한 이유로 선택 정렬은 stable한 결과를 보장할 수 없기 때문에 unstable하다고 한다. 버블 정렬 : stable 삽입 정렬 : stable 참고 [Algorithm]선택정렬 예제(selection sort) 정렬 기본 stable과 unstable에 대하여 [JAVA] Insertion Sort (삽입정렬) 기술면접 list - 알고리즘","categories":[{"name":"알고리즘","slug":"알고리즘","permalink":"https://woovictory.github.io/categories/알고리즘/"}],"tags":[{"name":"정렬","slug":"정렬","permalink":"https://woovictory.github.io/tags/정렬/"},{"name":"선택 정렬","slug":"선택-정렬","permalink":"https://woovictory.github.io/tags/선택-정렬/"},{"name":"삽입 정렬","slug":"삽입-정렬","permalink":"https://woovictory.github.io/tags/삽입-정렬/"},{"name":"버블 정렬","slug":"버블-정렬","permalink":"https://woovictory.github.io/tags/버블-정렬/"}]},{"title":"[2018 회고]","slug":"2018-Review","date":"2019-03-01T15:23:37.000Z","updated":"2019-06-13T05:44:34.061Z","comments":true,"path":"2019/03/02/2018-Review/","link":"","permalink":"https://woovictory.github.io/2019/03/02/2018-Review/","excerpt":"","text":"2019년이 되고 3달이나 지났다. 회고라는 걸 해본 적이 없지만 지인의 회고를 보고 영감을 받아서 작성하겠다고 마음을 먹었다. 2018년은 나에게 힘들고 아프면서 많은 걸 경험하게 해줬다. 이 회고는 내가 2018년 동안 어떤 걸 했고, 어떤 걸 느꼈는지 내가 내린 선택과 결과를 잊지 않기 위해 작성할 예정이다. 그리고 2019년에는 어떤 마음 가짐과 목표를 세우\u001c고 달려나갈지 생각하기 위함이다. 2019.03.05 기준으로 다시 작성한다. 왜냐하면 캠프 끝난 기념으로 제주도 여행을 갔다 왔기 때문이다…ㅎㅎ 즐겁게 놀고 잘 쉬다가 왔으니 새로운 마음가짐으로 회고를 할 예정이다. 미유박스 서울시 공모전 SK 스마트 관광 공모전 회사 생활 부스트 캠프 # 미유박스 SOPT 22기 앱잼을 했던 프로젝트 미유박스이다. 솝트 22기에 다시 안드로이드 파트원으로 지원하면서 세웠던 목표는 수상과 성장 두 가지로 요약할 수 있다. 왜냐하면 전기수에 Lang이라는 프로젝트에서 부족한 실력으로 인해서 결과물을 내지 못했던 경험이 있기 때문에 더 잘하고 싶다는 욕심이 생겼다. 미유박스는 사전 팀빌딩 없이 네트워킹을 통해 들어가게 되었다. 수상을 하고 싶다는 목표를 가지고 참여했지만, 안드로이드 개발자는 나를 포함해 2명 뿐이었다. 자신감이 하락하는 소리가 들린다. 그래도 포기는 너무 이른 생각이었다. 2주 동안 정말 치열하고 재미있게 프로젝트를 진행했다. 밤 새는 걸 못하던 나는 앱잼 기간동안 잠도 많이 줄여야 했고 합숙하는 동안은 거의 매일 같이 밤 새고 아침에 잠 들었다. 그래도 팀원들과 즐거운 분위기 속에서 개발을 했기 때문에 힘들다는 생각은 적게 할 수 있었다. 노력의 결과로 우리 팀은 대상이라는 명예를 얻을 수 있었다. 이 상은 나에게 있어서 의미가 컸다. 내가 노력한 결과로 상을 받은 경험을 처음이었기 때문이다. 좋은 분위기를 이끌어준 팀원들과 함께 노력한 결과가 수상으로 이어져서 기분이 정말 좋았다. 기능은 많지 않았지만 앱을 안정적으로 만들고 결제 기능을 테스트용으로 구현할 수 있어서 좋은 경험을 했다. 이를 통해서 내가 느꼈던 점은 다음과 같다. 안드로이드 개발자로서 &quot;자신감&quot;을 얻을 수 있었고, 전보다 성장했음을 느낄 수 있었다. 안드로이드 개발에 대한 &quot;흥미&quot;를 일깨워 줄 수 있는 경험이 되었다. 미유박스는 앞으로의 내 행보에 발판을 마련해준 중요한 경험이 되었다. 앞으로도 미유박스 팀은 꾸준하게 오래 보는 사이가 되었으면 좋겠다. ^_^ # 서울시 공모전 미유박스에서 같이 개발했던 형의 소개로 일정에 없던 공모전에 참여하게 되었다. 공모전을 준비해 본 경험이 없어서 하고 싶은 마음은 계속 있었다. 그러던 와중에 좋은 기회가 생겼다. 아는 형을 제외하고는 다 처음 보는 사이였다. 프로젝트의 기획 단계는 마무리가 되었고 디자인과 개발만 시작하면 되는 시점이었다. 그래서 뭔가 날로 먹는 느낌이 강해서 찜찜했지만 개발을 시작하면서 그 생각은 사라졌다. 너무 여유를 부렸던 탓인지 개발 속도는 진전이 없었다. 나는 공모전을 해보고 싶었고 상을 받고 싶은 욕심이 있었기 때문에 빨리 개발을 진행할 수 있도록 분위기를 유도했다. 그래도 어느정도 진전이 있었다. 같이 하기로 했던 한 분이 좋은 기회로 인턴에서 정직원으로 전환이 되었다고 했다. 그래서 그 분을 대체할 분을 데리고 오셨고 기분 좋게 개발을 하는가 싶었다. 인생은 고난의 연속이라고 했던 누군가의 말이 생각났다. 대타로 들어오신 분이 사정이 있어서 빠지게 되었다. 그래서 기능 한개가 비어버리게 되었고, 이 부분까지 내가 맡아서 개발을 진행했다. 덕분에 내가 처음에 맡았던 기능 + 대타 분이 떠나서 구현해야 하는 기능을 신경 써야 했다. 또 하필, 이 기간은 내가 3~4달 동안 위워크에 있는 회사에서 잠깐 일했던 기간이기도 했다.(이 얘기는 밑에서 등장한다.) 그래서 회사에 갔다가 퇴근하고 공모전을 하면서 하루에 4~5시간 밖에 못 잤던 걸로 기억한다. 너무 힘들었지만 공모전을 한다고 결정한 나에게 포기하는 모습을 보여주고 싶지 않았다. 그래서 시간을 할애해서 정말 열심히 했다. 내가 선택한 일에 대해서 후회하고 싶지 않았던 마음과 공모전을 하고 싶었던 나의 버킷 리스트를 잘 실천하고 싶은 두 개의 마음이 나를 열심히 하게 한 원동력이 된 것 같다. 좋은 결과를 얻지는 못했지만, 재미있는 사람들과 공모전을 하면서 즐거웠다. 짧고 치열한 기간에 개발을 하자고 팀원들한테 얘기하면서 쪼았지만 잘 따라서 마무리를 해준 것을 고맙게 생각하고 있다. 서울시 공모전을 하면서 느낀 점 내가 내린 결정에 대해서 후회하지 않고, 책임감을 가지고 일을 진행해야 한다는 걸 배웠다. 개발적인 부분을 다른 사람한테 설명하기 위해서는 내가 많은 지식을 알고 있어야 한다는 걸 알았다. Git을 조금 더 능숙하게 다룰 줄 알았다면 더 편하게 협업을 하지 않았을까를 깨닫게 되었다. # KB App Challenge 아마 지금 와서 2018년도에 했던 일들을 다시 하라고 한다면 나는 못할 것 같다. 내가 활동하던 SOPT에서 주최한 KB App Challenge였다. KB의 클라우드 관련 신기술인 클래용을 활용하여 유스 고객을 타겟으로 하여 금융 관련 지식들을 라이브 방송을 통해 알려주고 포인트를 쌓을 수 있는 애플리케이션의 프로토 타입을 개발했다. 프로젝트 기간이 2주였기 때문에 기획을 빨리 픽스하고 개발에 도입했다. 안드로이드 개발은 80% 정도 혼자 진행했다. 회사를 다니면서 퇴근하면 바로 종각역 근처에 위치한 패스트 파이브로 향했다. 2주 동안 짧고 치열하게 프로젝트를 완성시키고 최종 발표를 했다. 최종 발표는 KB 본사 건물에서 진행했고, KB 회장님을 비롯하여 임직원분들이 오셔서 우리가 진행한 프로젝트를 보고 평가해주셨다. 훌륭한 팀원들 덕분에 2등을 할 수 있었다. 아마도 최우수상이었던 걸로 기억한다. 100만원 상금을 받고 5명이서 20만원씩 나눴다. 뜻깊은 경험도 하고 평생 만날 기회가 없을 KB 회장님도 직접 뵙고 사진도 찍고 상금까지 얻을 수 시간이었다. KB 프로젝트를 하며 느낀 점 앱 개발자로서 UI를 더 생각해보고 신경쓸 수 있었다. 그래서 UI를 만들 때 전보다 개선된 걸 느낄 수 있었다. 기존에 사용했던 기술이 아닌 색다른 기술을 사용해 볼 수 있어서 좋았다. 결국은 Youtube Player API를 사용했지만, 영상 재생을 구현하는 방법에 대해서 고민해 볼 수 있는 좋은 시간이었다. [ KB App Challenge 사진 ] 나는 눈에 띄는 파란색 니트를 입고 가운데서 사진을 찍었다. 재밌었다. :) # SK 스마트 관광 공모전 공모전을 하고 싶었던 나의 소망이 좀 이상했다. 한 번에 3개씩 하겠다는게 아니었는데 어쩌다 보니 1개는 먼저 진행했고 2개가 기간이 겹치는 문제가 발생했다. ㅠ_ㅠ 앞의 KB가 끝나자마자 바로 SK 스마트 관광 공모전을 시작했다. 미유박스(자주 등장한다.ㅎㅎ)를 함께 진행했던 팀원들과 다른 사람 몇명을 추가해서 공모전을 진행했다. 팀원이 14명이었다. 지금 생각해도 너무 많았던 것 같다. 그래서 우리 팀의 목표는 무조건 1등이었다. 왜냐하면 1등은 상금이 1천만원이었기 때문이다. 14명이서 나누면 약 70만원 가량의 상금을 얻을 수 있었다. 생각만 해도 행복하다.ㅎ0ㅎ 앞에서 진행했던 KB 프로젝트와 회사 생활로 인해서 DMZing(우리 프로젝트 애플리케이션 이름이다.)의 초기 기획 단계에 많이 참여하지 못한 점이 아쉽고 미안하다. 아무튼 나는 마감 기간이 2주 정도 남았을 때 개발에 들어갔다. 안드로이드 개발을 할 때 운이 없는 건지 팀 프로젝트를 할 때 계속 두 명이서 진행했다. 힘들었다. . . ㅠㅠ 2주 동안 치열하게 잠을 줄여가면서 개발에 몰두했고 마무리를 잘해서 Google Play Store에도 올리는 경험을 했다. 이번 프로젝트에서 내가 하고 싶었던 건 중복을 없애고 재사용을 하는 것과 효율적으로 코드를 작성해보는 것이었다. 하지만, 기간이 짧기도 했고 시간이 많지 않아서 2개의 목표는 달성하지 못했다. 운이 좋게도 본선에 진출해서 최종 발표를 할 수 있는 기회를 얻었다. 기획과 디자인을 담당했던 친구들이 가서 발표를 하고 마무리를 잘 해줬다. 그리고 12월 00일에 최종 결과 발표가 있었다. 우리는 시간이 되는 사람들끼리 모여서 최종 결과를 받기 위해서 종각 근처의 콘랩으로 향했다. 대상을 받을거라고 김칫국을 마시던 우리는 장려상을 받고 아쉬워 했다. 그래도 함께 열심히 노력한 과정을 알기 때문에 빨리 잊어버렸다. 100만원이라는 상금을 받고 14명이 나눠 가졌다. 대략 7만원 정도씩 가질 수 있었다. 나는 받았던 상금을 모으고 일했던 돈을 보태서 아이폰XS로 핸드폰을 바꿨다. 좋은 기회가 있어서 생각보다 저렴하게 구매했고 지금 만족하면서 잘 쓰고 있다. 갓기용님에게 항상 감사하고 있다.ㅎㅎ SK 스마트 관광 프로젝트를 하면서 느낀점 바쁘게 사는 건 좋지만 너무 빡빡한 일정은 좋지 않다는 것을 느꼈다. 여유가 없었기 때문에 회고를 할 수 있는 시간이 없었다. 그리고 KB 프로젝트와 SK 관광 프로젝트가 겹쳤기 때문에 한 가지에 집중하기 힘들어서 능률이 떨어지는 느낌을 받았다. 여유를 어느 정도 가지고 프로젝트나 일을 할 때는 한가지에 집중하는게 중요하다는 걸 깨달았다. Store에 실제로 올리면서 개인 정보 취급 방침이 필요하다는 걸 알게 되었고, APK 파일을 추출하는 법에 대해서도 알 수 있었다. 개발자로서 꼭 필요한 경험을 할 수 있었다. # 회사 생활 4학년 1학기를 깔끔하게 마무리하고 2학기는 6학점만 남겨놓았다. 그래서 OCU라는 인터넷 강의를 2개 잡고 2학기에는 학교를 다니지 않았다. 이 기간 동안 무엇을 할까 고민을 많이 했다. 취업 준비를 해야 하는 시기가 맞지만, 나는 아직 취업 준비를 하고 싶지 않았다. 휴식을 취하고 싶었고, 돈을 벌고 싶은 마음이 있었다. 그래서 알바를 할까 생각을 했지만, 시간 낭비를 하지 않고 관련된 업무를 하면서 돈을 벌 수 있는 기회를 찾았다. 그러던 와중에 아는 지인이 다니는 회사를 추천받았다. 간단하게 말해서 인공지능에게 필요한 학습 데이터를 가공하는 업무였다. 타이틀은 거창하고 인턴이었지만 나는 단순 업무를 하는 아르바이트라고 생각했다. 9월에 입사를 했고 회사를 다니는 동안 시간을 틈틈히 쪼개서 위에서 언급했던 KB 프로젝트와 SK 스마트 관광 프로젝트 2개를 진행했다. 계약 기간이 12월 30일까지였기 때문에 나는 12월 30일에 퇴사를 했다. 3개월에서 4개월 정도의 짧은 기간이었지만 좋은 사람들을 만나고 회사를 다니면서 혼자 시간을 쪼개서 여러 가지를 할 수 있었다. 그리고 돈도 벌 수 있었다. 회사를 다니면서 많은 업무를 하지는 않았다. 처음부터 단순 업무라고 들었기 때문이다. 시간을 낭비했다고 생각하기도 하지만 내가 선택한 결정에 대해서 후회는 없다. 돈을 벌 수 있었고 더 바쁘게 생활하기도 했어서 오히려 나한테 자극을 줄 수 있는 시간이었다. 퇴사를 하면서 다음 회사는 &quot;내가 진짜 원하는 업무를 할 수 있는 회사에 들어가자&quot;라는 목표를 세웠다. 회사를 다니면서 내가 느낀 점 첫 번째는 스타트업이라도 너무 작은 스타트업보다는 어느 정도 규모가 있는 스타트업이 좋을 것 같다는 점을 느꼈다. 규모가 너무 작으면 체계도 잘 잡혀있지 않은 것 같다. 두 번째는 식비나 교통비를 지원해주는 회사가 좋은 회사라는 것이다. 월급을 받지만 식비와 교통비로 지출이 생기기 때문에 돈 모으기가 힘들었다. 마지막에는 도시락을 싸서 다녔지만 아무래도 식비+교통비를 지원해준다면 꿈의 회사가 아닐까하는 생각이 들었다. 마지막으로 내가 진짜 원하는 업무를 하는 회사에 들어가서 재미있게 개발을 하자는 마음을 가지게 되었다. # 부스트 캠프 후기 in 2019 2018년은 프로젝트를 연달아서 쉬는 기간 없이 3개를 진행했다. 발전이 없고 프로젝트만 계속 한 느낌?!을 받았다. 회고를 작성하지도 않았고 리뷰를 하지도 않았다. 심지어 프로젝트에 대한 정리도 하지 않았다. 아마 그래서 발전이 없었고 계속 같은 자리에 머물러 있는 것 같다는 느낌을 받았다. 이 상태로 있다가는 성장하는 개발자가 되지 못할 것 같았다. 그래서 나는 지금보다 한 단계 성장하고 다른 경험을 해보고 싶어서 부스트 캠프에 지원하게 되었다. 부스트 캠프는 네이버 계열사 중 하나인 커넥트 재단에서 진행하는 캠프이다. 내가 부스트 캠프에 지원하게 된 이유는 다음과 같은 것들을 얻고 싶어서다. 현업에서 일하는 튜터님의 멘토링을 받고 좋은 조언들을 얻을 수 있다는 점 코드 리뷰를 통해서 코딩할 때 안좋은 습관을 없애고 실력을 쌓을 수 있다는 점 같은 분야를 공부하는 다른 개발자들을 만나보고 싶다는 점 자극을 받고 싶다는 점 위의 4가지 이유로 인해서 부스트 캠프에 지원하게 되었다. 나는 지원서를 제출하고 1차 합격 메일을 받았다. 다음 절차는 온라인 테스트였다. 주말에 진행되었으며 안드로이드 관련 문제와 간단한 알고리즘 문제가 나왔다. 공부했던 부분에서 문제가 나와서 수월하게 풀 수 있었으며 알고리즘도 다행히 내가 풀 수 있는 수준이라고 생각을 해서 테스트를 잘 마무리 할 수 있었다. 테스트를 보고 나서 합격 여부를 모른채로 일단 면접 준비를 했다. 취업한 선배들의 말을 들어보니 합격 통지를 받고 면접까지의 기간이 길지 않아서 바로 준비하는게 좋다고 했다. 그래서 나는 테스트를 보고 다음날부터 면접에 대한 준비를 했다. 온라인 테스트를 합격하고 면접 날짜가 나왔다. 사전에 면접 준비를 어느 정도 했기 때문에 떨리지 않았지만, 어떤 질문이 들어올지 예측할 수 없었다. 일단은 온라인 테스트 문제와 지원서를 기반으로 준비했다. 같이 지원하고 면접까지 붙은 학교 선배 및 후배와 함께 면접 준비를 했다. 혼자 준비한 것보다 확실히 도움이 많이 되었다. 모의 면접을 통해서 긴장감을 풀 수 있었고 말할 때 태도나 말투를 고칠 수 있었다. 또한, 예상치 못한 질문을 듣고 부족한 부분을 더 공부할 수 있었다. 준비한 결과 부스트 캠프에 최종 합격을 할 수 있었다. 캠프를 하면서 \b내가 지원할 때 부스트 캠프를 통해서 얻고 싶었던 것들을 하나씩 얻고 배울 수 있었다. 일단, 첫번째로 현업에서 일하시는 튜터님의 멘토링을 받을 수 있었다. 우리는 초반에 프로젝트 아키텍처 설계를 MVP 패턴으로 잡았다. 그리고 Model, View, Presenter의 의존성을 분리해서 개발을 시작했다. 그리고 튜터링을 받았는데 설계부터 잘못되었다는 평가를 받았다. 기존에는 뷰를 먼저 그리고 필요한 데이터를 그 때 그 때 작성했다. 이렇게 하면 변경 사항이 자주 발생하고 수정할 때도 굉장히 귀찮은 작업을 거치게 된다. 튜터링을 받은 내용은 요구사항 명세서를 만들고 먼저 화면에 그릴 데이터를 고려하고 설계하는 것이다. 로직을 하나도 신경쓰지 않고 사용자게에 보여질 화면에 필요한 데이터를 설계한다. MVP 패턴을 사용하므로 비즈니스 로직을 처리할 Repository 인터페이스를 설계한다. 2번에서 생성한 Repository 인터페이스를 구현한다. Presenter 구현 및 View 인터페이스 설계 View 인터페이스 구현 위와 같은 순서로 작업을 진행하는 것이 좋다는 피드백을 받았다. 기존에 개발해왔던 것과는 반대의 프로세스였다. Data를 먼저 고려하고 최종적으로 View는 가장 마지막에 구현하는 것이었다. 처음에는 이 프로세스가 적응이 되지 않고 왜 이렇게 하는지 이해가 잘 가지 않았다. 하지만, 계속 하다보니 적응이 되었고 요구사항 명세서를 잘 작성해 놓으니 추후에 유지보수나 수정할 때 손이 많이 가지 않았다. 덕분에 능률이 조금 더 오를 수 있었다. 또한, 관심사의 분리(SOC)를 하는데에도 도움이 많이 되었다. MVP 패턴을 사용하다보니 Model, View, Presenter 각각이 하는 역할이 명확해서 분리하는 것이 필요했다. 말은 쉽지만 실제로 개발을 하다보니 서로 의존성이 생기는 문제가 발생했다. 이 문제는 위의 요구사항 명세서 작성을 통해서 역할을 명확하게 분리할 수 있었고 의존성을 낮출 수 있게 되었다. 두번째는 코드리뷰였다. 지금까지 살면서 남의 코드를 봐온 적은 있지만 코드 리뷰를 해본 적이 없었고, 내 코드를 누군가가 리뷰해 준 적도 없었다. 내 첫 코드 리뷰는 엉망이라고 할 수 있다. 접근제어자는 막 갖다 붙였고, 전역 변수, 지역 변수도 구분할 줄 몰랐다. 그래서 조언을 받고 반성을 하면서 코드를 짤 때 생각을 많이 하고 짜는 습관을 가지게 되었다. 내가 짠 코드에 대해서 왜 이렇게 짰는지 생각해 볼 수 있는 습관을 가지게 된 것이 좋았다. 세번째는 같은 분야의 다른 개발자들을 만날 수 있었다는 점이다. 물론 SOPT를 통해서 많이 만났지만, 새로운 사람들을 만난다는 건 좋은 경험이었다. 처음 보는 사람들과 팀을 이루었다. 처음에는 굉장히 어색했지만, 시간이 지나면서 친해졌고 일상 이야기 뿐 아니라 개발적인 부분도 함께 공유하고 이야기 할 수 있어서 좋았다. 캠프에도 적응할 수 있어서 긴장이 많이 풀렸다. 또한, 내가 모르는 부분들도 많이 알게 되었고 전보다 시야가 넓어졌다. 마지막으로 다른 사람들을 통해서 많은 자극을 받을 수 있었다. 아마도 SOPT에서만 계속 있었다면 발전이 없고 그 자리에 머물러 있었을 것이라고 생각한다. 부스트 캠프에는 전국에서 안드로이드 개발에 관심이 있는 사람들이 모인 자리인 만큼 잘하는 사람들이 굉장히 많았다. 그 속에서 나는 남과 비교하면서 내 자신을 깎아내리기도 했었다. 하지만 시간이 조금 지나면서 부정적인 생각을 없애버렸고 그 사람들로부터 자극을 받기 시작했다. 이 자극은 나한테 큰 도움이 됐다. 앞으로 어떤 걸 공부해야 할지 방향을 잡을 수 있었고, 내게 부족한 점들을 확인할 수 있는 시간이었다. 부스트 캠프를 하면서 좋았던 점은 좋은 팀원들, 튜터님과 함께 프로젝트를 진행하고 잘 마무리할 수 있었던 점이다. 한달이라는 기간 동안 싸우지 않고 프로젝트 동안 의견 충돌도 많지 않았다. 또한, 좋은 튜터님들을 알아 갈 수 있었던 것도 굉장히 좋았다. 안드로이드 개발자라면 모를 수 없는 박상권을 실제로 보고 좋은 이야기도 많이 들으면서 값진 경험을 할 수 있었다. 그리고 조금 아쉬운 점은 캠프 동안 매일 기록하지 못했다는 것이다. 초반에는 기록할 시간이 있었지만 개발을 시작하고 나서는 시간적인 여유가 부족해서 기록을 하지 못했다. 그래도 부스트 캠프는 나에게 있어서 한 단계 성장할 수 있게 만들어준 발판이었다. 2019년의 시작은 힘들었지만, 추진력을 주었기에 감사한 마음이다. 2019년도에는 끝까지 포기하지 않고 최선을 다하는 마음가짐을 가지고 꼭 취업을 하는게 목표다. 그리고 체력 관리도 필수적인 것 같다. 꾸준한 운동도 꼭 할 계획이다. 참고 KB금융, 대학생과 함께하는 ‘KB App Challenge’ 개최","categories":[],"tags":[{"name":"회고","slug":"회고","permalink":"https://woovictory.github.io/tags/회고/"},{"name":"2018","slug":"2018","permalink":"https://woovictory.github.io/tags/2018/"},{"name":"부스트 캠프 후기","slug":"부스트-캠프-후기","permalink":"https://woovictory.github.io/tags/부스트-캠프-후기/"}]},{"title":"18일차 [자바] Primitive Type","slug":"Java-Why-is-needed-primitive-type","date":"2019-02-07T06:13:10.000Z","updated":"2020-04-22T07:47:01.690Z","comments":true,"path":"2019/02/07/Java-Why-is-needed-primitive-type/","link":"","permalink":"https://woovictory.github.io/2019/02/07/Java-Why-is-needed-primitive-type/","excerpt":"","text":"자바로 프로젝트를 진행하고 있다. 하지만, 자바에 대한 개념이 약해서 예전에 정리했던 자료들을 보면서 익히고 있고 프로젝트를 하면서 어느정도 손에 익었다고 생각이 된다. 아직까지는 자바가 강세이긴 한 것 같다…ㅜ 조금 더 자바에 대해 공부하기 위해 이펙티브 자바책도 사서 공부해봐야겠다. 그럼 이제 본론으로 들어가서 자바에서는 자료형을 크게 두 가지로 나눌 수 있다. 기본 자료형(Primitive Type)과 참조 자료형(Reference Type. 여기서는 Wrapper Class)이 존재한다. 기본 자료형 : char, byte, short, int 등등 참조 자료형 : Integer, Byte 등등 그럼 자바에서 Primitive Type과 NonPrimitve Type을 만들어 놓은 이유는 무엇일까?? 효율성을 위해서라고 한다. Primitive Type의 변수는 값을 직접 포함한다. 참조형 타입의 변수는 메모리 내의 다른 곳에 저장된 객체를 참조하는 참조이다. Wrapper Type의 값을 사용해야 할 때마다 JVM은 객체를 메모리에서 찾아 값을 가져와야 한다. 반면에 값이 포함된 객체에 대한 참조 대신 변수 자체에 값이 포함되어 있는 Primitive Type에는 메모리에 접근할 필요가 없다. 객체인 Wrapper는 힙 영역에 저장된다. Primitive는 단지 &quot;값&quot;이기 때문에 스택 영역에 들어간다. 힙의 래핑된 Primitive의 경우 스택에 있는 값과 Wrapper 객체에 대한 참조가 둘 다 필요하기 때문에 더 효율적이다. 흠… 아직까지 무슨 말인지 모르겠다… 위에서 찾아본 바로는 효율성을 위해서 존재하는 것이 가장 이해가 간다. 또 다른 의견으로는 메모리 및 CPU 처리 측면에서 Primitive Type이 더 가볍고 효율적이라는 의견도 존재한다. +추가 의견으로는 객체 생성, 힙 할당이 너무 비싸고 성능상의 불이익이 있기 때문이라고 한다. int, float 등의 Primitye Data Type이 가장 많이 사용되므로 Object로 만드는 것은 엄청난 성능 저하일 것이다. 참고 사이트 why are there Primitive datatype in Java? [duplicate] When we have wrappers classes, why primitives are supported?","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"18일차 [디자인 패턴] 팩토리 패턴","slug":"Design-Pattern-Factory-Pattern","date":"2019-02-07T02:41:13.000Z","updated":"2020-05-12T11:30:06.784Z","comments":true,"path":"2019/02/07/Design-Pattern-Factory-Pattern/","link":"","permalink":"https://woovictory.github.io/2019/02/07/Design-Pattern-Factory-Pattern/","excerpt":"","text":"신입 개발자를 위한 Repository를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다. 안드로이드에서 Fragment를 생성할 때 클래스의 인스턴스 즉, 객체를 만드는 상황에서 new를 통해서 바로 생성하지 않고 newInstatnce()라는 메소드를 통해서 만든다. 이와 관련된 이유는 이전 포스팅을 참고하도록 하고 이런 방식을 팩토리 메소드?를 사용한다고 한다. 이것을 보고 팩토리 패턴에 대해 찾아보기로 하였다. 팩토리 패턴(Factory Pattern) 모든 팩토리 패턴에서는 객체 생성을 캡슐화한다. 팩토리 메소드 패턴과 추상 팩토리 패턴이 존재한다. 팩토리 메소드 패턴 : 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정한다. 추상 팩토리 패턴 : 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다. 추상 팩토리 패턴에는 팩토리 메소드 패턴이 포함될 수 있다. 디자인 원칙 중 '추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하지 않도록 만든다.'에 기인한 패턴이다. 팩토리 패턴의 핵심은 클래스의 인스턴스를 만드는 것을 서브클래스에서 결정하도록 한다는 것이다. 즉, new 키워드를 사용하는 부분을 서브클래스에 위임함으로서 객체 생성을 캡슐화하고 구상 클래스에 대한 의존성이 줄어든다는 이점을 얻을 수 있다. 특히 구상 클래스에 대한 의존성이 줄어드는 것은 의존성 뒤집기 원칙(Dependency Inversion Principle:DI)에 기인하는데, DI는 자바 진영에서 널리 쓰이고 있는 Spring 프레임워크의 핵심 개념 중 하나이다. 싱글톤 패턴과 더불어 가장 유명하고 널리 쓰이는 디자인 패턴 중 하나라고 할 수 있다. 팩토리 메소드 패턴 위에서 언급했듯이, 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하도록 하는 것이다. 팩토리 메소드 패턴은 팩토리 메소드는 객체를 생성해서 반환하는 것을 말한다. 즉, 결과값이 객체인 것이다. 이점은 뭘까? 클래스의 변경사항이 생겼을 때 얼마나 다른 클래스에게도 영향을 줄 것인가가 결합도이다. 팩토리 메소드 패턴은 직저버 사용하는 객체를 생성하지 않고 팩토리 메소드 클래스를 통해 객체를 대신 새애성하고 그 객체를 반환 받아 사용하기 때문에 효율적인 코드 제어를 할 수 있을 뿐더러 결합도를 낮춰 유지보수가 용이하다. 예시 아이언맨 수트에 빗대어 예제를 설명하려고 한다. 아이언맨의 각 수트들은 각각의 고유한 기능들을 가지고 있기 때문에 특정 상황에 맞춰서 토니 스타크가 착용하는 수트도 달라지게 된다.(너무 간지…ㅎ) 우주 탐사를 할 때에는 스페이스 아머, 심해 탐사 시에는 하이드로 아머, 그리고 시네마틱 유니버스에서 나왔던 헐크버스터 등을 예로 들 수 있다. 위와 같이 특정 상황을 입력으로 보고 입력에 따라 다른 수트 클래스를 만들어야 하는 상황을 코드로 표현하면 아래와 같다.(사실 코드로 표현하지 않아도 된다. 하지만, 나는 컴공이니까…!) 123456789101112131415Suit suit = null;switch(type)&#123; case(\"space\"): suit = new SpaceSuit(); break; case(\"hydro\"): suit = new HydroSuit(); break; case(\"stealth\"): suit = new StealthSuit(); break; default: suit = new CombatSuit();&#125; 이제 각 상황에 맞게 수트를 생성할 수 있게 되었고, 아이언맨도 활약을 할 수 있게 되었다. 하지만, 위와 같이 코드를 작성하게 되면 변경이나 확장할 요소가 생길 시 매번 코드를 추가, 제거해주어야 한다는 문제가 발생한다. 이로 인해 아이언맨도 활약할 시간이 지체된다. 위의 문제는 객체 인스턴스를 생성하는(new 키워드를 사용하는) 부분을 별도의 인터페이스로 분리하면 해결할 수 있다. 이렇게 생성자를 별도의 인터페이스로 분리하여 객체를 만들어내는 공장(factory)으로 이용하는 것이 팩토리 메소드 패턴이다. 이제 위 코드에서 인스턴스를 생성하는 부분을 인터페이스로 분리해보자. UML 각가의 suit 클래스들은 Suit 추상 클래스를 상속받아 getName() 메소드를 구현하고 SuiitFactory 추상 클래스를 상속받은 TypeSuitFactory에서는 type별로 수트 인스턴스를 생성하도록 하는 createSuit 메소드를 구현하도록 한다. Suit 추상 클래스 1234// Suit 추상 클래스public abstract class Suit&#123; public abstract String getName();&#125; Suit 추상 클래스를 구현한 각각의 수트 클래스들 1234567891011121314151617181920212223242526272829303132333435// SpaceSuitpublic class SpaceSuit extends Suit&#123; @Override public String getName()&#123; return \"SpaceSuit\"; &#125;&#125;// HydroSuitpublic class HydroSuit extends Suit&#123; @Override public String getName()&#123; return \"HydroSuit\"; &#125;&#125;// StealthSuitpublic class StealthSuit extends Suit&#123; @Override public String getName()&#123; return \"StealthSuit\"; &#125;&#125;// CombatSuitpublic class CombatSuit extends Suit&#123; @Override public String getName()&#123; return \"CombatSuit\"; &#125;&#125; Suit 팩토리 추상 클래스 123public abstract class SuitFactory&#123; public abstract Suit createSuit(String type);&#125; Suit 팩토리 추상 클래스를 구현한 Suit 팩토리 구현 클래스 12345678910111213141516171819202122public class TypeSuitFactory extends SuiFactory&#123; @Override public createSuit(String type)&#123; Suit suit = null; switch(type)&#123; case(\"space\"): suit = new SpaceSuit(); break; case(\"hydro\"): suit = new HydroSuit(); break; case(\"stealth\"): suit = new StealthSuit(); break; default: suit = new CombatSuit(); &#125; return suit; &#125;&#125; Test를 해보자. 123456789101112131415161718public static void main(String[] args)&#123; TypeSuitFactory typeSuitFactory = new TypeSuitFactory(); Suit suit1 = typeSuitFactory.createSuit(\"stealth\"); Suit suit2 = typeSuitFactory.createSuit(\"space\"); Suit suit1 = typeSuitFactory.createSuit(\"\"); System.out.println(suit1.getName()); System.out.println(suit2.getName()); System.out.println(suit3.getName());&#125;/*결과StealthSuitSpaceSuitCombatSuit*/ 인스턴스 생성을 서브 클래스로 위임한 결과이다. 최종 메인 메소드에서는 new 키워드를 사용하여 인스턴스를 생성한 부분이 없는 것을 확인할 수 있다. 이를 통해 메인 프로그램에서는 어떤 객체가 생성되었는지 신경 쓸 필요 없이 반환된 객체만 사용하면 되고 슈트 클래스에서 변경이 발생해도 메인 프로그램이 변경되는 것은 최소화할 수 있다. 추상 팩토리 패턴 다음은 추상 팩토리 패턴에 관한 예시이다. 위의 정의에서 추상 팩토리 패턴은 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다고했다. 즉, 연관된 서브 클래스를 그룹화할 수 있고 이것은 이 그룹을 자유롭게 교체할 수 있는 패턴이라고 할 수 있다. UML SuitAbstractFactory 인터페이스를 작성하고 이를 상속받아 각 슈트를 생성하는 팩토리 클래스를 구성한다. 그리고 SuitFactory에서는 이 팩토를 파라미터로 받아 최종적으로 생성된 슈트 객체를 반환하게 된다. 추상 팩토리 인터페이스 1234public interface SuitAbstractFactory&#123; // Suit는 위에서 정의한 추상 클래스 public Suit CreateSuit();&#125; Suit 팩토리 클래스 123456789101112131415161718192021222324252627public class CombatFactory implements SuitAbstractFactory&#123; @Override public Suit createSuit()&#123; return new CombatSuit(); &#125;&#125;// Spacepublic class SpaceFactory implements SuitAbstractFactory&#123; @Override public Suit createSuit()&#123; return new SpaceSuit(); &#125;&#125;// Stealthpublic class StealthFactory implements SuitAbstractFactory&#123; @Override public Suit createSuit()&#123; return new StealthSuit(); &#125;&#125;// 생략 팩토리 클래스를 파라미터로 받는 구현 클래스 12345public class SuitFactory&#123; public static Suit getSuit(SuitAbstractFactory suitAbstractFactory)&#123; return suitAbstractFactory.createSuit(); &#125;&#125; Main에서 구현 12345678910111213141516public static void main(String[] args)&#123; Suit suit1 = SuitFactory.getSuit(new CombatFactory()); Suit suit2 = SuitFactory.getSuit(new SpaceFactory()); Suit suit3 = SuitFactory.getSuit(new StealthFactory()); System.out.println(suit1.getName()); System.out.println(suit2.getName()); System.out.println(suit3.getName());&#125;/*결과CombatSuitSpaceSuitStealthSuit*/ 위 결과 코드와 같이 슈트별 팩토리 클래스를 파라미터로 넘겨 각 슈트 객체를 반환 받아 사용할 수 있다. 이렇게 되면 팩토리 클래스 교체만으로 조금 더 유연하게 기능의 수정, 확장에 대처할 수 있게 된다. 코드 상으로는 if-else 구문을 제거하여 조금 더 깔끔하게 코드를 구성할 수 있다. 나의 이해 CombatFactory는 SuitAbstractFactory 인터페이스를 구현하고 있다. 각 수트 Factory 클래스는 전부 SuitAbstractFactory 인터페이스를 구현하고 있는 셈이다. 결국 부모는 SuitAbstractFactory가 되고, 자식은 각 Suit Factory들이 된다. SuitFactory.getSuit() 문장을 보면 getSuit() 함수의 파라미터로 SuitAbstractFactory 타입의 클래스를 넘길 수 있다. 하지만, 잘 생각해보면 SuitAbstractFactory를 구현한 자식 클래스도 넘길 수 있다. 코드처럼 new CombatFactory()를 넘기면 부모 클래스를 구현한 자식인 CombatFactory는 부모 타입으로 전달될 수 있다. 그리고 createSuit() 메소드를 호출하게 되는데 이는 파라미터로 전달받은 객체의 createSuit() 메소드를 호출하게 된다. 우리가 파라미터로 전달받은 객체는 CombatFactory이다. 그러므로 CombarFactory의 createSuit() 메소드를 호출하고 new CombatSuit()를 통해 객체를 생성하게 된다. 결국 CombatSuit 클래스의 객체를 얻을 수 있으며 getName() 함수를 통해 확인하면 CombatSuit가 출력되는 걸 확인할 수 있다. 참고 사이트 팩토리 메소드 패턴(Factory Method Pattern) 디자인패턴:팩토리 패턴(FACTORY PATTERN) [Design_Pattern] 팩토리 메서드 패턴(Factory Method Pattern)","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Factory Pattern","slug":"Factory-Pattern","permalink":"https://woovictory.github.io/tags/Factory-Pattern/"}]},{"title":"17일차 [안드로이드] 프래그먼트에 대해","slug":"Android-Why-is-Need-default-constructor-of-fragment","date":"2019-02-06T13:21:09.000Z","updated":"2020-03-01T10:26:15.916Z","comments":true,"path":"2019/02/06/Android-Why-is-Need-default-constructor-of-fragment/","link":"","permalink":"https://woovictory.github.io/2019/02/06/Android-Why-is-Need-default-constructor-of-fragment/","excerpt":"","text":"안드로이드에서 Fragment는 거의 필수적으로 사용된다고 볼 수 있다. Activity 위에서 부분 화면을 나타내는데 Fragment는 아주 효율적으로 사용할 수 있다. 그렇다면 Fragment를 어떻게 만들어서 구현을 하는가에 대해서 생각해 볼 필요가 있을 것이다. 일반적으로 나는 Fragment를 사용할 때 아래와 같이 코드를 작성하였다. 123456789public class MyFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup viewGroup, Bundle savedInstanceState)&#123; View view = inflater.from(viewGroup.context).inflate(R.layout.fragment_my.xml, viewGroup, false); return view &#125;&#125; 위의 코드가 내가 지금까지 Fragment를 사용할 때 작성해왔던 코드이다. 하지만, 최근에 들어서 코드 리뷰를 통해서 이렇게 Fragment를 작성하는게 맞을까란 이야기를 들었다. 보통 관용적으로 newInstance()라는 함수를 사용해서 만들게 되는데 이것과 기본 생성자를 키워드로 찾아보라고 하셨다. 그래서 어떻게? 그래서 어떻게?라니 바로 키워드를 잡고 찾아보기 시작했다. 먼저, newInstance()라는 키워드를 가지고 찾아보니 생성자에 관한 이야기도 함께 설명하는 글을 꽤 찾을 수 있었다. Fragment를 만들 때는 생성자를 오버로딩 하지 않고 생성 시 필요한 파라미터가 생기면 Bundle 객체에 담아서 setArgument() 함수를 호출하는 방식을 사용하는 것이 일반적이다. 왜냐하면 안드로이드에 의해서 Fragment가 복원될 때는 Fragment의 기본 생성자를 호출하기 때문에 오버로딩된 생성자의 호출이 보장되지 않는다. 그렇기 때문에 아래와 같은 코드를 사용하며 이 코드는 관용적으로 Fragment를 생성할 때 사용하는 코드가 되었다. 12345678910111213141516171819202122232425262728public static class DetailsFragment extends Fragment &#123; /** * Create a new instance of DetailsFragment, initialized to * show the text at 'index'. */ public static DetailsFragment newInstance(int index) &#123; DetailsFragment f = new DetailsFragment(); // Supply index input as an argument. Bundle args = new Bundle(); args.putInt(\"index\", index); f.setArguments(args); return f; &#125; public int getShownIndex() &#123; return getArguments().getInt(\"index\", 0); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; TextView textView = new TextView(getActivity()); text.setText(String.valueOf(getShownIndex())); return textView; &#125; &#125; 생성자를 만들지 않거나, 기본 생성자를 만들고 아무짓도 하지 않는 것이다. 생성자를 명시하지 않는다면 Java는 자동적으로 기본 생성자를 만든다. 하지만, 기본 생성자를 명시하지 않고 오버로딩된 생성자만 명시하게 되면 Fragment fragment = new Fragment(); 문장을 호출했을 때 에러를 겪게 된다. 그러니 기본 생성자를 사용하도록 하자.(대신 구현은 구현부는 비워놓는다.) 또한, 위에서 설명했던 것처럼 프래그먼트가 복구될 때는 기본 생성자를 호출하기 때문에 오버로딩된 생성자의 호출은 보장되지 않는다. 그래서 저장하거나 넘겨야 할 값이 존재한다면 newInstance() 함수에 파라미터로 전달하고 이 함수 안에서 Bundle 객체를 통해서 파라미터로 넘어온 값을 저장한다. 그리고 복원될 때는 getArguments() 함수를 통해서 값을 복원하면 된다. 참고 왜 Fragment는 기본 생성자를 사용해야만 하는가? 팩토리 메소드를 사용할 때 빈 기본 생성자가 필요한 이유","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Fragment","slug":"Fragment","permalink":"https://woovictory.github.io/tags/Fragment/"}]},{"title":"13일차 [안드로이드] 데이터바인딩","slug":"Android-What-is-DataBinding-1","date":"2019-02-04T02:45:42.000Z","updated":"2020-03-01T10:26:33.476Z","comments":true,"path":"2019/02/04/Android-What-is-DataBinding-1/","link":"","permalink":"https://woovictory.github.io/2019/02/04/Android-What-is-DataBinding-1/","excerpt":"","text":"데이터바인딩은 우리의 일상을 편하게 해주었다. 그러면 어떤 것을 편하게 해주었는지 먼저 살펴보고 시작해보자. 데이터바인딩을 사용하면 findViewById()를 호출하지 않아도 자동으로 xml에 만든 View들을 만들어준다. RecyclerView에 각각의 item을 set해주는 작업도 xml에서 다 써주면 알아서 값이 들어간다. 값이 바뀌면 알아서 바뀐 값으로 View를 변경하게 할 수도 있고 기타 등등 유용하게 활용 할만한게 많다. 서론 새로운 화면을 추가해야 한다. 그러면 안드로이드 스튜디오를 켜고 xml을 만들고 레이아웃 화면을 구성해야 한다. 다음과 같이 TextView 5개와 Button 1개, RecyclerView 1개가 있는 View를 만들어 보도록 하겠다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" &gt; &lt;TextView android:id=\"@+id/tvText1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvText2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvText3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvText4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvText5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;Button android:id=\"@+id/btnSample\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"button\" /&gt; &lt;/LinearLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/rcContent\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; xml을 만들었으니 Activity에서 View를 이어주는 작업을 해야한다. 아래와 같은 작업을 할 수 있다. 123456789101112131415161718192021TextView tvText1;TextView tvText2;TextView tvText3;TextView tvText4;TextView tvText5;Button btnSample;RecyclerView rcContent;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.basic_activity);tvText1 = (TextView) findViewById(R.id.tvText1);tvText2 = (TextView) findViewById(R.id.tvText2);tvText3 = (TextView) findViewById(R.id.tvText3);tvText4 = (TextView) findViewById(R.id.tvText4);tvText5 = (TextView) findViewById(R.id.tvText5);btnSample = (Button) findViewById(R.id.btnSample);rcContent = (RecyclerView) findViewById(R.id.rcContent); 위의 작업을 할 경우 우리는 제일 먼저 findViewById() 노가다를 진행한다. 지금 만들려는 레이아웃은 몇 개 안되는 뷰이지만 만약 10개, 100개 그리고 그 이상이라면 그만큼 노가다 코드를 작성하게 될 것이다. 그래서 이러한 노가다 코드를 줄일 수 있도록 도와주는 라이브러리인 버터 나이프가 있다. 자바에서는 버터 나이프를 이용해서 노가다 코드를 줄일 수 있었고, 코틀린에서는 Kotlin-extensions를 이용해서 findViewById를 하지 않아도 xml의 id를 바로 객체화시켜서 Activity에서 사용할 수 있었다. 아래는 버터 나이프를 이용한 축약된 형태의 코드 모습이다. 12345678910111213141516171819202122@BindView(R.id.tvText1)TextView tvText1;@BindView(R.id.tvText2)TextView tvText2;@BindView(R.id.tvText3)TextView tvText3;@BindView(R.id.tvText4)TextView tvText4;@BindView(R.id.tvText5)TextView tvText5;@BindView(R.id.btnSample)Button btnSample;@BindView(R.id.rcContent)RecyclerView rcContent;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);setContentView(R.layout.butterknife_activity);ButterKnife.bind(this); 하지만 데이터바인딩을 사용한다면 어떻게 될까??? 12 위의 화면은 오류가 아니다. 따로 View를 정의하고 우리가 이어줄 필요가 없다는 것이다. Databinding을 사용한다면 우리는 아무 소스코드를 적지 않아소 Databinding이 알아서 다 해준다. 최소사항 Android 2.1(API 7) 이상 Android Plugin for Gradle 1.5.0-alpha 1 이상 Android Studio 1.3 이상 아주 아주 아주 옛날의 환경으로 작업하고 있지 않는 이상 지금 쓰는 환경에서 무리 없이 바로 사용할 수 있다. 설정 build.gradle(Module:app) 에서 위와 같이 enabled만 true로 설정해주면 끝난다. xml Databinding을 사용하기 위해서는 xml의 최상위에 태그를 감싸준다. 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"activity\" type=\"app.woovictory.databindingsample.MainActivity\"/&gt; &lt;/data&gt; &lt;android.support.constraint.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Hello World!\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt; &lt;/android.support.constraint.ConstraintLayout&gt;&lt;/layout&gt; Java Activity에서 항상 해주던 setContentView() 대신에 **DatabindingUtil.setContentView()**를 이용해서 layout xml을 이어준다. 12345678ActivityMainBinding binding;@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState);binding = DataBindingUtil.setContentView(this, R.layout.databinding_activity);binding.setActivity(this); xml의 파일 이름을 기준으로 ~~~Binding 클래스가 새로 생성된다. 여기서는 xml의 이름이 activity_main.xml이기 때문에 ActivityMainBinding 클래스가 새로 생성되었다. Binding 클래스 이름의 생성은 파스칼 표기법 기준으로 변경된다. 예를 들어, woo_activity.xml -&gt; WooActivityBinding 클래스를 생성시킨다. 그리고 xml에서 layout 태그 안에 태그 안에 태그를 추가하고 activity라는 변수 이름을 할당해주면 위에서와 같이 binding.setActivity(this)처럼 Activity와 xml을 이어줄 수 있다. View를 사용하고자 할 때는 binding 변수에서 아래와 같이 사용할 수 있다. View의 이름은 카멜표기법 기준으로 변경된다. @+id/tv1_text 의 뷰는 tv1Text으로 이름이 변경되어 사용할 수 있다. Click Event 사용자가 어떤 버튼을 클릭하면 아래의 함수를 실행하도록 하려고 한다. 123public void onButtonClick(View view)&#123; Toast.makeText(this, \"Button Click\", Toast.LENGTH_SHORT).show();&#125; 기본 버튼에 setOnClickListener()를 달아서 클릭이벤트를 받아주도록 할 것이다. 1234567//btnSample.setOnClickListener(this);btnSample.setOnClickListener(new View.OnClickListener() &#123;@Overridepublic void onClick(View view) &#123;onButtonClick(view);&#125;&#125;); 위에 주석 처리된 것처럼 setOnClickListener(this)를 했다면 implements View.OnClickListener를 하고 함수를 오버라이드 하고 그 안에서 onButtonClick() 함수를 호출했을 것이다. 버터나이프 버터나이프에서는 @OnClick(R.id.xxx)만 함수에 넣어주면 된다. 1234@OnClick(R.id.btnSample)public void onButtonClick(View view) &#123;Toast.makeText(this, \"Button Click\", Toast.LENGTH_SHORT).show();&#125; 버터 나이프는 아주 간단하게 이벤트를 처리할 수 있다. 데이터바인딩 데이터바인딩은 xml에서 클릭되면 실행하고자 하는 함수를 지정해준다. 12345&lt;Button android:id=\"@+id/btn2\" android:onClick=\"@&#123;activity.onButtonClick2&#125;\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 위에서는 android:onClick 에서 activity라는 곳에 있는 onButtonClick2() 함수를 실행하도록 설정해두었다. 여기서 activity라는 것은 xml에서 선언해 둔 변수를 가리킨다. 1234567891011&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\"&gt; &lt;data&gt; &lt;variable name=\"activity\" type=\"app.woovictory.databindingsample.MainActivity\"/&gt; &lt;/data&gt; // 생략 xml에서 태그를 이용해서 그 안에서 각각 사용하고자 하는 변수를 태그를 이용해서 정의해주면 사용할 수 있다. 1234567891011121314public class MainActivity extends BaseActivity&lt;ActivityMainBinding&gt; &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding.setActivity(MainActivity.this); &#125; public void onButtonClick2(View view)&#123; Toast.makeText(this, \"Click222\",Toast.LENGTH_LONG).show(); &#125;&#125; 위의 예제는 데이터바인딩을 수행하는 부분을 BaseActivity로 빼두어서 설정하는 코드가 보이지 않는다. 하지만, 바인딩 하는 부분이 수행된다. Java 파일에서는 이 변수가 어떤 값을 넣어줄건지 지정해주어야 한다. setActivity() 함수는 자동으로 생성된 함수이다. 우리가 xml에서 activity라는 변수를 만들었다면 자동으로 setActivity()가 생성되어서 binding.setActivity(this) 처럼 사용할 수 있는 것이다. setActivity(this)가 xml에서의 activity라는 변수를 이 Class로 지정하겠다는 의미인 것이다. 즉, xml의 activity 변수는 MainActivity Class와 연결되고 MainActivity의 변수 혹은 함수를 참조할 수 있음을 의미한다. MVP 패턴을 사용한다면 presenter를, MVVM 패턴을 사용한다면 ViewModel을 활용해서 클릭 이벤트에 맞는 동작을 수행하도록 지정하면 된다. 이에 대한 나의 생각은 조금 다르다. MVP 패턴은 View에서 발생한 이벤트를 Presenter에게 위임하여 View는 단순히 View 그 자체를 그리는 것에만 초점을 맞추어 관심사를 분리한 것으로 볼 수 있다. View에서 발생한 이벤트 혹은 요청한 이벤트가 데이터를 불러오거나 가공하는 로직이 포함된다면 Presenter에게 위임하여 처리하는 것이 맞다고 생각을 한다. 그리고 View에서 발생한 이벤트가 단순히 화면 전환과 같은 이벤트라면 View에서 처리해도 마땅하다고 생각을 한다. 함수 이름을 지정할 때 기존에는 @{activity.함수이름()}으로 해도 문제가 없었지만 언젠가부터 이 방법은 deprecated 되었다고 나온다고 한다. 그래서 @{activity::함수이름()}으로 사용하도록 구글 문서에서 안내하고 있다. RecyclerView 리스트 그렇다면 이제 RecyclerView를 이용해서 리스트 목록을 만드는 작업을 해보려고 한다. 기본적으로 1:1 카카오톡의 채팅방과 같이 사용자의 사진, 이름, 그리고 여기서는 나이로 구성되어 있는 화면을 만들어보겠다. 먼저, item을 구성하는 xml을 정의해야 한다. 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:gravity=\"center_vertical\" android:orientation=\"horizontal\" android:padding=\"8dp\"&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=\"@+id/ivProfile\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"8dp\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/tvName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvAge\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 또한, 리스트에서 쓰일 사용자 User 클래스도 생성해준다. 1234567891011121314151617181920212223242526package app.woovictory.databindingsample;public class User &#123; String name; int age; String imageUrl; public User(String name, int age, String imageUrl) &#123; this.name = name; this.age = age; this.imageUrl = imageUrl; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public String getImageUrl() &#123; return imageUrl; &#125;&#125; 실제로는 서버에서 사용자의 목록을 받아오겠지만 여기서는 샘플 데이터를 이용해서 활용할 수 있도록 구성한다. ViewHolder 각각의 item view를 보여주기 위해서 ViewHolder에서 View를 만들어주는 작업을 한다. 기본 12345678910111213public class UserViewHolder extends RecyclerView.ViewHolder &#123; TextView tvName; TextView tvAge; ImageView ivProfile; public UserViewHolder(View itemView) &#123; super(itemView); tvName = (TextView) itemView.findViewById(R.id.tvName); tvAge = (TextView) itemView.findViewById(R.id.tvAge); ivProfile = (ImageView) itemView.findViewById(R.id.ivProfile); &#125;&#125; 버터나이프 123456789101112131415public class UserViewHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.tvName) TextView tvName; @BindView(R.id.tvAge) TextView tvAge; @BindView(R.id.ivProfile) ImageView ivProfile; public UserViewHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this,itemView); &#125;&#125; 데이터바인딩 123456789public class UserViewHolder extends RecyclerView.ViewHolder &#123; DatabindingItemBinding binding; public UserViewHolder(View itemView) &#123; super(itemView); binding = DataBindingUtil.bind(itemView); &#125;&#125; 위에서 순서대로 기본 -&gt; 버터 나이프 -&gt; 데이터바인딩을 차례대로 살펴보면 코드의 길이가 짧아지는 것을 확인할 수 있다. 그렇다. 데이터바인딩을 사용하면 개발자가 작성해야 할 코드의 양이 줄어든다!! item 세팅 onBindView() 함수에서 각각의 position에 맞는 User 클래스의 내용에 따라 뷰의 내용을 넣어주는 작업을 해준다. 기본/버터나이프 1234567891011121314public void onBindView(UserViewHolder holder, int position) &#123; User user = getItem(position); String name = user.getName(); holder.tvName.setText(name); int age = user.getAge(); holder.tvAge.setText(Integer.toString(age)); String imgUrl=user.getImgUrl(); ImageUtil.loadImage(holder.ivProfile,imgUrl, ContextCompat.getDrawable(getContext(),R.drawable.no_pic));&#125; 데이터바인딩 123456public void onBindView(UserViewHolder holder, int position) &#123; User user = getItem(position); holder.binding.setUser(user);&#125; 원래는 기본이나 혹은 버터나이프에서는 각각의 holder의 view에 사용자 정보를 넣어주는 작업을 해주었지만 데이터바인딩에서는 그럴 필요가 없다. setUser() 라는 함수를 보고 유추해 볼 수 있다. item_user.xml에서 user라는 변수를 만들어주었고, 그 변수에 setUser()라는 데이터바인딩에 의해서 생성된 함수를 통해서 position에 따른 user 객체를 할당해준다는 것을 알 수 있다. 12345678&lt;layout&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"app.woovictory.databindingsample.User\" /&gt; &lt;/data&gt; onBindView()에서 값을 넣어주는 대신에 setUser()를 통해서 User 객체를 user 변수에 할당해준다. 그리고 데이터바인딩을 통해서 xml에서 값을 넣어준다. 123456789101112&lt;TextView android:id=\"@+id/tvName\" android:text=\"@&#123;user.name&#125;\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tvAge\" android:text=\"@&#123;Interger.toString(user.age)&#125;\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"8dp\" /&gt; android:text에 @{user.필드이름}을 넣어주는 것만으로 user의 정보를 가져와서 다시 TextView에 넣어주는 작업을 해 줄 필요가 없는 것이다. @BindingAdapter 그런데 여기서 드는 의문이 하나 있다. User 정보 중에 imageUrl이라는 필드는 “http://~~~.png” 처럼 이미지가 저장되어 있는 주소 값으로 되어 있다. 이 값을 TextView에 넣는다면 이미지 url만 출력되는 원하지 않는 결과를 볼 것이다. 이럴 때 BindingAdapter를 사용하면 해결할 수 있다. 어노테이션으로 @BindingAdapter와 같이 정의해준다. 나는 이미지를 Setting하기 위해서 다음과 같이 정의한다. 1234@BindingAdapter(\"app:imageUrl\")public static void loadImage(ImageView imageView, String url)&#123; ImageUtil.loadImage(imageView, url);&#125; 그러면 UserAdapter에서 onBindView() 함수가 binding.setUser(user)를 호출하면서 데이터바인딩 작업이 수행된다. 그리고 xml에서 정의한 다음의 문장을 수행하게 된다. 12345&lt;de.hdodenhof.circleimageview.CircleImageView android:id=\"@+id/ivProfile\" android:layout_width=\"40dp\" app:imageUrl=\"@&#123;user.imageUrl&#125;\" android:layout_height=\"40dp\" /&gt; 그러면 xml에서 @BindingAdapter로 정의된 부분을 찾아서 해당 View의 id와 @{user.imageUrl} 을 가지고 @BindingAdapter가 정의된 함수의 파리미터로 값을 전달하게 된다. loadImage 함수를 호출하면서 파라미터로 id와 user.imageUrl에 담긴 url 값을 넘긴다. +@BindinAdapter와 @BindinConversion은 유용하게 사용할 수 있다. 이와 관련된 내용은 추후 구글 공식 문서를 통해서 내용을 추가할 예정이다. +Observable 참고 [안드로이드/Android]DataBinding - Goodbye 버터나이프 Hello 데이터바인딩[박상권의 삽질블로그]","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"DataBinding","slug":"DataBinding","permalink":"https://woovictory.github.io/tags/DataBinding/"}]},{"title":"11일차 [안드로이드] AAC - Room 실습","slug":"Android-AAC-Room","date":"2019-01-31T13:32:55.000Z","updated":"2020-03-01T10:27:59.544Z","comments":true,"path":"2019/01/31/Android-AAC-Room/","link":"","permalink":"https://woovictory.github.io/2019/01/31/Android-AAC-Room/","excerpt":"","text":"Room은 Android Architecture Components(AAC) 중 하나이다. Room에 대해서 저번에 살펴봤지만, 헷갈리고 개념이 정립되어 있지 않아 다시 정리하려고 한다. 이번에는 개념적인 부분보다는 실제로 어떻게 사용을 할 수 있는지에 초점을 맞추려고 한다. Room의 3가지 주요 구성요소 RoomDatabase : 데이터베이스의 holder를 구성하며 관계형 데이터에 대한 연결을 해준다. 조건 RoomDatabase를 extends하는 클래스는 abstract 클래스이다. annotaion으로 eneities(Table 구조와 mapping되는 clas)를 포함해야 한다. 클래스 내부에 DAO(Data Access Object)를 포함해야 한다. Entity : 데이터베이스 내의 테이블을 나타낸다. Dao : 데이터베이스에 접근하는 데 사용되는 함수를 정의한다.(Query를 포함한다.) Entity Entity는 object이자 데이터베이스의 테이블을 나타낸다. Entity 파일의 특징은 class의 변수들이 column이 되어 데이터베이스의 테이블로 된다는 것이다. ColumnInfo로 필드의 이름을 설정하지 않는다면 필드의 이름과 같은 Column 이름으로 생성된다. 이때, 실제 table로 만들고 싶지 않은 필드에는 @Ignore 어노테이션을 선언한다. Annotation 속성 @Entity(name = “word_table”) : Entity의 테이블 명을 선언한다. @PrimaryKey : 모든 Entity는 PrimaryKey가 필요하다.(값을 구별하기 위한 식별자) @ColumnInfo(name = “word”) : 테이블에서 word라는 이름으로 데이터베이스 column 사용 Entity에는 getter 함수가 필수적으로 존재해야 하고 변수들은 public 형태여야 한다. @Embeded : 필드로 object를 갖는 경우 사용한다. Annotaion과 관련된 속성은 구글 공식 문서를 참고하거나 블로그의 다른 글을 참고하면 좋을 것 같다. 5일차 [안드로이드] Room DAO 만들기 DAO는 SQL 쿼리를 지정하고 메소드 호출을 연결한다. 쿼리는 별도의 스레드에서 동작하며 메인 스레드에서 동작하지 않는다.(UI - Thread에서는 동작하면 앱에 에러가 난다.) Interface class 혹은 abstract class로 사용한다. @Dao 어노테이션을 지정한다. Dao에서는 데이터베이스에 있는 테이블에서 사용할 쿼리를 지정하고 메소드와 연결을 한다. 단순히 정의만 해놓는다. 주의 AppDatabase object를 생성하는 코드는 비용이 많이 들기 때문에 Singleton으로 구현해야 한다. Room Database 만들기 Room Database는 SQLite 데이터베이스 상위에 있는 데이터베이스 계층을 말한다. Room은 DAO를 이용하여 데이터베이스의 쿼리를 실행한다. 기본적으로 UI 성능 저하를 피하기 위해서 Room에서는 main thread에서 쿼리를 실행할 수 없다. LiveData는 필요할 때 백그라운드 스레드에서 쿼리를 비동기적으로 자동 실행하여 규칙을 적용한다. Room 클래스는 abstract 여야 하며, RoomDatabase를 상속받아야 한다. 일반적으로 RoomDatabase 객체를 생성하는 코드는 비용이 많이 들기 때문에 싱글톤으로 구현해 하나의 객체만 유지한다. 어노테이션 @Database(entities = {Word.class}, version = 1) : Room Database를 정의한다. entities는 데이터베이스에 사용될 Entity를 나타낸다. version는 추후 데이터베이스의 변경 사항이 있을 시 변경해야 할 사항이다. Repository 만들기 Repository는 여러 데이터에 대한 접근을 할 수 있는 class이다. 주로 로컬 데이터(앱 내장 데이터)를 가져올 지 네트워크에서 데이터를 가져올 지를 다룬다. Dao의 멤버 변수와 word를 넣을 list 변수를 만들어 준다. AsyncTask를 만들어서 Database에 insert 하는 작업을 수행한다. 이유는? UI - Thread에서 수행할 경우 오류가 발생한다. ViewModel? 내가 참고한 예제에서는 ViewModel을 사용하였다. 하지만, ViewModel에 대한 이해가 잘 되지 않아서 사용하지 않고 예제를 조금 다른 방식으로 수정하였다. 그래도 일단, ViewModel이 무엇인지 간단하게 살펴보자. ViewModel의 역할은 UI에 데이터를 제공하고 변경된 사항들을 업데이트 해준다. 그리고 ViewModel 저장소(Repository)와 UI(Fragment / Activity) 사이에 통신 역할을 한다. 이것은 저장소와 UI를 분리하여 각자의 역할을 명확하게 할 수 있다. 주의 ViewModel에 context를 저장하면 안된다. -&gt; 이유는 디바이스가 회전할 때 Activity가 제거되었다가 다시 생성되는데 이때, ViewModel은 제거된 것을 참조하기 때문에 메모리 누수가 발생한다. 그래서 application을 사용하기 위해 extends로 AndroidViewModel을 사용한다. ViewModel은 프로세스 종료 후 남아있지 않기 때문에 onSaveInstanceState() 함수를 대체하지 않는다. LiveData?? LiveData는 중요한 개념 중 하나이다. 여기서는 간단하게 Room에서 어떻게 사용되는지만 보고 추후에 공부할 예정이다. observer라는 것을 만들어 실제 변경이 일어나면 UI에 적용한다. ViewModel에서 데이터베이스 호출 없이 코드를 쉽게 테스트할 수 있다. 예제는 Github에 있으니 확인할 수 있다. 참고 Android Room with a View - Java (Android) Room Persistence Library 실습 -2","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Room","slug":"Room","permalink":"https://woovictory.github.io/tags/Room/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"}]},{"title":"10일차 [데이터베이스] 데이터베이스 기초 ","slug":"DatabaseBasic","date":"2019-01-30T02:08:34.000Z","updated":"2020-05-12T06:43:49.173Z","comments":true,"path":"2019/01/30/DatabaseBasic/","link":"","permalink":"https://woovictory.github.io/2019/01/30/DatabaseBasic/","excerpt":"","text":"안드로이드에서 Room을 이용하면 내부 DB를 사용할 수 있고, 간단한 쿼리문도 사용할 수 있다. 여기까지는 문제가 없는데, 내가 서버, DB 용어와 개념을 몰라서 이해가 잘 안간다. 그래서 간단하게 찾아서 공부하기 위해 작성된 글이다. 데이터베이스란?? 여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합을 말한다. 자료 항목의 중복을 없애고 자료를 구조화하여 저장함으로써 자료 검색과 갱신의 효율을 높인다. 논리적으로 연관된 하나 이상의 자료의 모음으로 그 내용을 고도로 구조화함으로써 검색과 갱신의 효율화를 꾀한 것이다. 몇 개의 자료 파일을 조직적으로 통합하여 자료 항목의 중복을 없애고 자료를 구조화하여 기억시켜 놓은 자료의 집합체라고 할 수 있다. 왜 사용하는가? 데이터베이스란 다수의 사용자가 사용하는 데이터들의 공유와 운영을 위해 저장해 놓는 공간을 말한다. 프로그램을 만들다 보면 프로그램 사용자들에 의해 생성된 데이터, 프로그래머가 필요에 의해 프로그램에 넣어 놓은 데이터 등 필연적으로 많은 데이터들이 생성되어지게 된다. 여기서 데이터베이스를 사용하지 않으면 이 데이터들은 프로그램을 종료하는 순간 전부 날아가게 되는 불행한 상황을 맞이하게 된다. 따라서, 이런 현상을 방지하기 위해 데이터들을 데이터베이스에 넣고 보관하는 방법을 사용하는 것이다. 기초 용어 엔티티(Entity) : 사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체이다. 예를 들어, 사원 번호가 1206이고 김창섭인 사원, 과목 코드가 CS372인 운영체제 등이 있다. 이렇게 실체가 있는 것 뿐만 아니라 추상적인 것도 있다. 프로젝트 번호가 P101인 프로젝트, 학과 번호가 D316인 학과는 추상적인 개념의 엔티티가 될 수 있다. 스키마(Schema) : 데이터를 설명하는 데이터. 메타데이터(Metadata)라고도 한다. 예를 들어 홍길동, 1994-06-27이라는 데이터가 있을 경우에는 이를 이름, 생년원일이라는 스키마로 설명할 수 있다. Database 용어 Table(Relation) : 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위를 말한다. 예로 부서에 관한 정보를 저장하는 부서 Relation(혹은 부서 Table)이 있다. 한 릴레이션은 데이터베이스에 표현되는 한 엔티티에 관한 정보를 저장하는 데 사용된다. 식별자(identifier) : 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각을 구분할 수 있는 논리적인 개념이다. 식별자의 특징 유일성 : 하나의 릴레이션에서 모든 행은 서로 다른 키 값을 가져야 한다. 최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다. 튜블(Tuple) : 테이블에서 행을 의미한다. 같은 말로 레코드(Record) 혹은 로우(Row)라고 하기도 한다. 튜플은 릴레이션에서 같은 값을 가질 수 없다. 카디날리티(Cardinality) : 튜플의 수 어트리뷰트(Attribute) : 테이블에서 열을 의미한다. 같은 말로 칼럼(Column)이라고도 한다. 디그리(Degree) : 어트리뷰트의 수를 의미한다. 도메인(Domain) : Relation에서 각각의 속성(Attribute)들이 취할 수 있는 같은 타입의 원자 값들의 집합이다. Key 키(Key) : 한 Relation에서 각각의 Tuple(행)을 유일하게 식별하기 위해 사용하는 하나 혹은 그 이상의 속성들(Attribute)의 집합이다. 유일성과 최소성 유일성 : 하나의 키로 어떠한 행을 바로 찾아낼 수 있는 성질. ex) 주민등록번호 최소성 : 레코드(튜플)을 식별하는데 꼭 필요한 속성들로만 구성되어 있는 성질. ex) {주민등록번호+학번}은 최소성을 만족시키지 않는다. 주민등록번호로만 tuple(행)을 구분할 수 있기 때문이다. 후보키(Cadidate Key) 릴레이션을 구성하는 속성들 중에서 튜블을 유일하게 식별할 수 있는 속성들의 부분집합을 의미한다. 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다. 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다. ex) &lt;학생&gt; 릴레이션에서 '학번’이나 '주민번호’는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키가 될 수 있다. 즉, 기본키가 될 수 있는 키들을 후보키라고 한다. 기본키(Primary Key) 후보키 중에서 선택한 주키(Main key) 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성 Null 값을 가질 수 없다.(개체 무결성의 첫 번째 조건) 기본 키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.(개체 무결성의 두 번째 조건) ex) &lt;학생&gt; 릴레이션에서는 '학번’이나 '주민번호’기 기본키가 될 수 있고, &lt;수강&gt; 릴레이션에서는 ‘학번’+'과목명’으로 조합해야 기본키가 만들어 질 수 있다. 왜냐하면 &lt;수강&gt; 릴렝션에서는 ‘학번’ 속성과 ‘과목명’ 속성은 개별적으로 기본키로 사용할 수 없다. 다른 튜플들과 구별되지 않기 때문이다. 1004 학번을 가진 학생이 영어와 전산 과목을 수강하고 있다고 하면 학번만으로는 특정 튜플을 유일하게 구별할 수 없다. 그리고 영어 과목을 수강하는 학생들은 한명이 아니라 여러 명이 될 수 있기 때문에 유일하게 구별할 수 없다. 대체키(Alternate Key) 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말한다. 보조키라고도 한다. ex) &lt;학생&gt; 릴레이션에서 '학번’을 기본키로 정의하면 '주민번호’는 대체키가 된다. 슈퍼키(Super Key) 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다. 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족시키지 못한다. ex) &lt;학생&gt; 릴레이션에서는 ‘학번’, ‘주민번호’, ‘학번’+‘주민번호’+‘성명’ 등으로 슈퍼키를 구성할 수 있다. 또한, 여기서 최소성을 만족시키지 못한다는 말은 ‘학번’+‘주민번호’+'성명’가 슈퍼키인 경우 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, ‘성명’ 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못한다. 즉, 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성 있는 키로 사용할 수 없다. 이것을 최소성을 만족하지 못한다고 한다. 외래키(Foreign Key) 관계(Relation)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성이다. 외래키는 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용된다. 외래키로 지정되면 참조하는 테이블의 기본키에 없는 값은 입력할 수 없다.(참조 무결성 조건) ex) &lt;수강&gt; 릴레이션이 &lt;학생&gt; 릴레이션을 참조하고 있으므로 &lt;학생&gt; 릴레이션의 '학번’은 기본키이고, &lt;수강&gt; 릴레이션의 '학번’은 외래키이다. 즉, 각 릴레이션의 입장에서 속성은 기본키가 되기도 하고, 외래키가 되기도 한다. ex) &lt;수강&gt; 릴레이션의 '학번’에는 &lt;학생&gt; 릴레이션의 '학번’에 없는 값은 입력할 수 없다. 쿼리 문법의 세 종류와 각 문법 SQL(Structured Query Language) 관계형 데이터베이스에서 사용하는 표준 질이 언어를 말한다. 사용 방법이나 문법이 다른 언어(Java, C, C#)보다 단순하다. 모든 DBMS에서 사용 가능하다. 인터프리터 언어 대소문자를 구별하지 않는다. 데이터 정의 언어(DDL) 데이터베이스 검색, 등록, 삭제, 갱신을 하기 위해 사용하는 데이터베이스 언어 데이터베이스의 검색 및 업데이트 등 데이터 조작을 위해 사용 데이터베이스의 스키마를 정의, 생성, 수정하는 기능 테이블 생성, 컬럼 추가, 타입 변경, 각종 제약조건 지정, 수정 등 SQL문 내용 create 데이터베이스 객체를 생성 drop 데이터베이스 객체를 삭제 alter 기존에 존재하는 데이터베이스 객체를 다시 정의 데이터 조작 언어(DML) 관계형 데이터베이스의 구조를 정의한다. 쌍, 속성, 관계 인덱스 파일 위치 등 데이터베이스 고유의 특성을 포함한다. 데이터베이스의 테이블에 있는 내용을 직접 조작하는 기능 테이블의 레코드(튜플)을 CRUD(Create, Retrieve, Update, Delete) SQL문 내용 insert 데이터베이스 객체에 데이터를 입력 delete 데이터베이스 객체에 데이터를 삭제 update 데이터베이스 객체 안의 데이터 수정 select 데이터베이스 객체 안의 데이터 조회 데이터 제어 언어(DCL) 데이터베이스에서 데이터에 대한 액세스를 제어하기 위한 데이터베이스 언어 또는 데이터베이스 언어 요소 박탈, 연결, 권한 부여, 질의, 자료 삽입, 갱신, 삭제 등 데이터베이스의 테이블에 접근 권한이나 CRUD 권한을 정의하는 기능 특정 사용자에게 테이블의 조회권한 허가 / 금지 등 SQL문 내용 grant 데이터베이스 객체에 권한을 부여 revoke 이미 부여된 데이터베이스 객체 권한을 취소 CRUD CRUD(Create, Retrieve, Update, Delete) 이름 조작 SQL create 생성 insert read(retrieve) 읽기(인출) select update 갱신 update delete 삭제 delete Create : 데이터베이스 객체 생성 insert into 새로운 레코드를 추가 Update : 데이터베이스 객체 안의 데이터를 수정 update 특정 조건의 레코드의 컬럼 값을 수정 Delete : 데이터베이스 객체의 데이터 삭제 delete 특정 조건의 레코드를 삭제 Retrieve : 데이터베이스 객체 안의 데이터 검색 select 조건을 만족하는 레코드를 찾아 특정 컬럼 값을 표시(모두 표시 : *) 예제 1.select 명령문 SELECT 컬럼명 FROM 테이블명 WHERE 조건절; ex) Q : 국가 코드가 'KOR’으로 되어 있는 도시의 이름을 구하시오. A : SELECT Name FROM City WHERE CountryCode=‘KOR’; Q : 인구가 500만 이상인 도시들의 이름을 구하시오 A : SELECT Name FROM City WHERE Population &gt; 5000000; 2. insert into 명령문 INSERT INTO 테이블명(컬럼명) VALUES(값); ex) 주의 : 각각의 필드와 대응 시켜줘서 insert를 시켜주어야 한다. INSERT INTO City (ID, Name, CountryCode, District, Population) values (10000, “Sample”, “KOR”, “Seoul”, 1000000); 주의 : 아래의 경우에는 모든 컬럼 값들이 일일히 필드와 대응되면 생략이 가능하다. INSERT INTO City values(20000, &quot;SampleTest , “KOR”, “Busan”, 2000000); 결과 확인 // ID가 20000인 레코드 출력 SELECT * FROM City WHERE ID = 20000; // ID가 20000인 레코드 출력 SELECT * FROM City WHERE ID = 10000; 3. update 명령문 UPDATE 테이블명 SET 컬럼명=값, … WHERE 조건절; ex) // ID가 10000인 레코드의 name을 &quot;SampleUSA&quot;로 변경 UPDATE City SET Name = “SampleUSA” WHERE ID = 10000; 결과 확인 // ID가 10000인 레코드 출력 SELECT * FROM City WHERE ID = 10000; 4. delete 명령문 DELETE FROM 테이블명 WHERE 조건절; ex) // ID가 20000이며 Population이 2000000인 레코드를 삭제 DELETE FROM City WHERE (ID = 20000) AND (Population = 2000000); // ID가 10000이며 Population이 1000000인 레코드를 삭제 DELETE FROM City WHERE (ID = 10000) AND (Population = 1000000); 결과 확인 // ID가 10000인 레코드 출력 SELECT * FROM City WHERE ID = 10000; // ID가 20000인 레코드 출력 SELECT * FROM City WHERE ID = 20000; 참고 [DataBase] 키(Key)의 개념 및 종류 데이터베이스 용어 및 기초 개념 정리(DBMS, Key관련 용어, 테이블 관련 용어 등) [DB기초] DataBase 개념 및 용어 설명 [DB] SQL 기초","categories":[{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://woovictory.github.io/categories/데이터베이스/"}],"tags":[{"name":"데이터베이스","slug":"데이터베이스","permalink":"https://woovictory.github.io/tags/데이터베이스/"}]},{"title":"9일차 [안드로이드] ConstraintLayout","slug":"Android-What-is-ConstraintLayout","date":"2019-01-29T16:05:45.000Z","updated":"2019-01-30T02:10:50.443Z","comments":true,"path":"2019/01/30/Android-What-is-ConstraintLayout/","link":"","permalink":"https://woovictory.github.io/2019/01/30/Android-What-is-ConstraintLayout/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"8일차 [안드로이드] MpAndroidChart","slug":"Android-MpAndroidChart","date":"2019-01-29T06:57:06.000Z","updated":"2020-03-01T10:25:09.979Z","comments":true,"path":"2019/01/29/Android-MpAndroidChart/","link":"","permalink":"https://woovictory.github.io/2019/01/29/Android-MpAndroidChart/","excerpt":"","text":"MpAndroidChart는 그래프 라이브러리 중 하나이다. 가장 널리 알려져 있고, Github의 star가 가장 많은 그래프 라이브러리이다. 라이브러리를 선택할 때 중요하게 생각해야 할 점 중의 하나로는 star가 많은 것을 선택하라고 한다. 그 이유는 star가 많은 것은 그만큼 오픈 소스 라이브러리 활동이 활발하여 오류에 대한 수정이나 기능 추가 같은 활동들이 활발하기 때문이라고 한다. 그래서 나는 안드로이드에서 그래프를 그리기 위해 MpAndroidChart 라이브러리를 사용했다. 종류 종류는 Github에서도 확인할 수 있듯이 엄청 다양하다. 그 중에서 나는 LineChart를 이용해서 원하는 데이터를 표현하려고 했다. 한국말로는 꺾은선 그래프라고도 하며, 이를 이용해서 데이터를 간단하게 표시할 수 있다. LineaChart 말고도 다양한 그래프들이 존재한다. 예를 들면, BarChart, PieChart 등등이 있다. 삽질 후기 그렇다면 내가 원하는 데이터를 그래프에 표시하기 위해서 삽질했던 후기를 정리하고자 한다. ##1. 데이터 생성** 그래프에서 표현하고자 하는 데이터를 생성해야 한다. 데이터는 Entry라고 하는 라이브러리에서 제공하는 타입으로 만들면 된다. 기본적으로 x, y의 Float(실수)형 데이터를 넣어서 만들 수 있다. 12345List&lt;Entry&gt; entires = new ArrayList&lt;&gt;();entries.add(new Entry(0,1f));entries.add(new Entry(1,2f));entries.add(new Entry(2,3f));entries.add(new Entry(3,4f)); entries를 이용해 LineDataSet을 생성한다. 12345678910LineDataSet lineDataSet = new LineDataSet(entries, \"Emotion\");// entries와 지정할 label을 생성자에 넘겨준다.lineDataSet.setLineWidth(2); // 선 굵기lineDataSet.setCircleRadius(6); // 곡률lineDataSet.setCircleColor(ContextCompat.getColor(mContext, R.color.graphColor)); // LineChart에서 Line Circle Color 설정lineDataSet.setCircleHoleColor(ContextCompat.getColor(mContext, R.color.graphColor)); // LineChart에서 Line Hole Circle Color 설정lineDataSet.setColor(ContextCompat.getColor(mContext, R.color.graphColor)); // LineChart에서 Line Color 설정// 그리고 기타 설정 등도 할 수 있다. LineDataSet을 담는 LineData를 만들어준다. 여러 개의 라인 데이터가 들어갈 수 있다. 12345LineData lineData = new LineData(lineDataSet);// 라인 데이터의 텍스트 컬러 / 사이즈를 설정할 수 있다.// 물론 나는 사용하지 않았다.lineData.setValueTextColor(ContextCompat.getColor(getContext(), R.color.black));lineData.setValueTextSize(9); 또한, 추가적으로 x축, y축에 대한 label과 텍스트, 갯수 등을 설정할 수 있다. 12345// x축 설정view.setLineData(lineData);xAxis = view.getXAxis(); // x축에 대한 정보를 View로부터 받아온다.xAxis.setPosition(XAxis.XAxisPosition.BOTTOM); // x축 표시에 대한 위치 설정으로 아래쪽에 위치시킨다.xAxis.setTextColor(R.color.black); // x축 텍스트 컬러 설정 y축에 대한 설정은 왼쪽과 오른쪽 따로 제공하고 있기 때문에 각각 가져와서 사용하지 않는 방향은 비활성화 하는 것이 좋다. 12345678910// y축 설정yLAxis = view.getYLeftAxis(); // y축 왼쪽 데이터 가져오기.yLAxis.setTextColor(R.color.black); // y축 텍스트 컬러 설정// y축 오른쪽 비활성화yRAxis = view.getYRightAxis();yRAxis.setDrawLabels(false);yRAxis.setDrawAxisLine(false);yRAxis.setDrawGridLines(false); 위에는 기본적인 설정과 같다. 그리고 구글에 검색하면 쉽게 찾아볼 수 있는 글이다. 이제 x축과 y축을 사용하고 싶은 데이터로 custom하게 사용하는 방법을 정리하려고 한다. 먼저, x축에 내가 원하는 요일들을 설정하기 위해서 아래와 같은 클래스를 만들어준다. IAxisValueFormatter 인터페이스를 구현한다. 123456789101112public class GraphAxisValueFormatter implements IAxisValueFormatter&#123; private String[] mValues; // 생성자 초기화 GraphAxisValueFormatter(String[] values)&#123; this.values = values; &#125; @Override public String getFormattedValue(float value, AxisBase axis)&#123; return mValues[(int) value]; &#125;&#125; 위와 같은 클래스를 만든다. 그리고 아래와 같이 custom 클래스를 지정하여줌으로써 x축의 데이터를 재가공한다. 12xAxis.setValueFormatter(new GraphAxisValueFormatter(mDays));// mDays는 요일을 가지고 있는 String 배열 그렇다면 y축의 데이터를 재가공하기 위해서는 어떻게 하면될까?? 방법은 x축과 똑같다. 12345678910111213public class GraphYAxisValueFormatter implements IAxisValueFormatter &#123; private String[] mEmojis; // 생성자 초기화 GraphYAxisValueFormatter(String[] values) &#123; this.mEmojis = values; &#125; @Override public String getFormattedValue(float value, AxisBase axis) &#123; return mEmojis[(int) value]; &#125;&#125; y축의 데이터를 재가공하기 위해서 custom하게 만든 클래스를 지정하면 된다. 12yLAxis.setValueFormatter(new GraphYAxisValueFormatter(mEmojis));// mEmojis는 이모지를 가지고 있는 배열 2. y축 데이터 재가공 y축에 icon 삽입 y축의 데이터를 재가공 하기 위해서 일단 y축의 이미지를 넣어야 한다는 생각으로 접근을 했다. 그래서 구글링을 통해서 MpAndroidChart에 이미지 혹은 icon을 삽입한 그래프를 찾아보았다. 일단, LineChart는 찾아볼 수 없었고, BarChart, PieChart에서는 손가락 안에 꼽을 수 있을 정도로 발견할 수 있었다. 라이브러리 커스텀 그래서 라이브러리를 파헤쳐서 커스텀을 해보자는 마음을 먹었다. (어리석은 생각이었다.) 그래서 BarChart를 통해 이미지를 넣은 것을 보고 이를 토대로 LineChart를 커스텀하기로 마음을 먹었지만, LineChart에서는 이미지를 그릴 수 있는 메소드를 찾지 못했다. y축 데이터에 이모지에 대한 유니코드 삽입 두 개의 방법이 실패하고 제일 처음 생각했지만, 위에서 언급하지 않았던 방법인 이모지에 대한 유니코드 값을 넣어서 간단하게 구현해보는 방법이다. 처음에 이모지에 대한 유니코드를 넣어서 확인해보았는데, 적용이 되지 않아서 실패라고 생각을 했었다. 하지만, 갓자이너 여자친구의 도움으로 다른 사이트를 알았다. 이 사이트에서 이모지에 대한 유니코드 값을 얻어서 그래프의 y축에 데이터를 재가공하였더니 이모지가 정상적으로 들어가는 것을 확인할 수 있었다. :) 3. 중복과 간격 문제 위의 2번까지의 과정을 해결하고 나니 내가 원하는 데이터로 재가공하여 그래프를 표현할 수 있게 되었다. 하지만, y축의 이모지 데이터가 중복해서 나오는 현상을 마주하게 되었다… 이 문제는 도대체 왜 그러는 것일까라는 의문을 가지고 구글링을 하고 커스텀을 위한 Class에서 return 하기 전에 로그 값을 찍는데 value가 float이라서 int로 캐스팅하는 과정에서 값이 손실되어서 같은 인덱스가 여러 번 참조되어 중복되는 것이라고 판단을 하게 되었다. 그래서 이를 해결할 수 있는 방법이 무엇이 있을까 생각해보고 이 라이브러이의 issue 탭에서 실마리를 찾아보고자 했다. 아니나 다를까 비슷한 문제를 직면한 사람을 찾을 수 있었다. 또한, 이에 대한 답변도 존재했다. 답변은 다음과 같았다. y축의 Max / Min 값을 지정하고 증가 간격(세분성) 설정을 true로 지정하고 세분 간격을 1.0f로 설정해주었다. 그리고 빌드를 해보니 내가 원하는 것처럼 이모지가 하나씩 증가하면서 나타나는 것을 확인할 수 있었다. 느낀점 외부 라이브러리를 사용할 때는 정말로 star가 많은 것을 사용하자. 분명 내가 직면한 문제를 먼저 경험한 개발자들이 있을 것이다. issue 탭에서 문제와 답을 찾을 수 있으니 포기는 휴지통에 버리자. 참고","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Graph Library","slug":"Graph-Library","permalink":"https://woovictory.github.io/tags/Graph-Library/"},{"name":"MpChart","slug":"MpChart","permalink":"https://woovictory.github.io/tags/MpChart/"}]},{"title":"6일차 [Java] Singleton","slug":"Java-Singleton-Pattern","date":"2019-01-26T03:52:38.000Z","updated":"2020-04-22T07:47:28.202Z","comments":true,"path":"2019/01/26/Java-Singleton-Pattern/","link":"","permalink":"https://woovictory.github.io/2019/01/26/Java-Singleton-Pattern/","excerpt":"","text":"싱글톤 패턴을 사용함에 있어서 효율적인 holder에 의한 방식을 사용해서 구현했는데, 이 방법이 나오기까지 전의 방법들을 까먹어서 설명하기 힘들었다. 그래서 다시 상기하고자 간단하게 정리를 하려고 한다. 이전에 정리한 싱글톤 패턴에 관한 글이 궁금하다면 참고하면 좋겠다. 1. Eager initialization(이른 초기화 방식) Singleton의 가장 기본적인 Eager initialization 방식이다. 먼저, 클래스 내에 전역 변수로 instance 변수를 생성하고 private static을 사용하여 인스턴스화에 상관없이 접근이 가능하면서 동시에 private 접근 제어 키워드를 사용해 EageInitialization.instance로 바로 접근 할 수 없도록 한다. 또, 생성자에도 pirvate 접근 제어 키워드를 붙여 다른 클래스에서 new EageInitialization(); 방식으로 새로운 인스턴스를 생성하는 것을 방지한다. 오로지 정적 메소드인 getInstance() 메소드를 이용해서 인스턴스를 접근하도록 하여 유일무이한 동일 인스턴스를 사용하는 기본 싱글톤 원칙을 지키게 한다. 이른 초기화 방식은 싱글톤 객체를 미리 생성해 놓는 방식이다. 항상 싱글톤 객체가 필요하거나 객체 생성 비용이 크게 들어가지 않는 경우에 사용한다. 12345678910111213public class EagerInitialization&#123; // private static으로 선언(전역 변수) private static EagerInitialization instance = new EagerInitialization(); // private한 생성자 private EagerInitialization()&#123; &#125; public static EagerInitialization getInstance()&#123; return instance; &#125;&#125; 장점 : static으로 생성된 변수에 싱글톤 객체를 선언했기 때문에 클래스 로더에 의해 클래스가 로딩될 때 싱글톤 객체가 생성된다. 또 클래스 로더에 의해 클래스가 최초 로딩될 때 객체가 생성됨으로 Thread-safe하다. 단점 : 싱글톤 객체 사용 유무와 관계 없이 클래스가 로딩되는 시점에 항상 싱글톤 객체가 생성되고, 메모리를 잡고 있기 때문에 비효율적이다. 2. Lazy initialization(늦은 초기화 방식) Eager initialization(이른 초기화 방식)과 정반대로 클래스가 로딩되는 시점이 아닌 클래스의 인스턴스가 사용되는 시점에서 싱글톤 인스턴스를 생성한다. 즉, 사용 시점까지 싱글톤 객체 생성을 미루기 때문에 사용하기 전까지 메모리를 점유하지 않는다. getInstacne() 메소드 안에서 instance가 null인 경우에만 new LazyInitialization()으로 싱글톤 객체를 할당한다. 12345678910111213141516public class LazyInitialization&#123; private static LazyInitialization instance; // 생성자 private LazyInitialization()&#123; &#125; public static LazyInitialization getInstanc()&#123; if(instance == null)&#123; intance = new LazyInitialization(); &#125; return instance; &#125;&#125; 장점 : 싱글톤 객체가 필요할 때 인스턴스를 얻을 수 있다. Eager initialization 방식의 단점을 보완한 수 있다.(메모리 누수!) 단점 : 만약 multi-thread 환경에서 어려 곳에서 동시에 getInstance() 메소드를 호출할 경우 인스턴스가 두 번 생성될 여지가 있다. 즉, multi-thread 환경에서는 싱글톤 철학이 깨질 수 있는 위험이 있다. 3. Thread safe Lazy initializtion(스레드 안전 늦은 초기화) Lazy initializtion 방식에서는 multi-thread 환경에서 thread-safe 하지 않다는 단점을 보완하기 위해서 멀티 스레드에서 스레드들이 동시 접근하는 동시성을 synchronized 키워드를 이용해 해결한다. 1234567891011121314public ThreadSafeLazyInitialization&#123; private static ThreadSafeLazyInitialization intance; // 생성자 private ThreadSafeLazyInitialization()&#123; &#125; public static synchronized ThreadSafeLazyInitialization getInstance()&#123; if(instance == null)&#123; intance = new ThreadSafeLazyInitialization(); &#125; return instance; &#125;&#125; 장점 : 위에서 언급한 듯이 Lazy initialization 방식에서 thread-safe 하지 않은 점을 보완한다. 단점 : synchronized 키워드를 사용할 경우 자바 내부적으로 해당 영역이나 메소드를 lock, unlock 처리하기 때문에 많은 cost가 발생한다. 대략 100배 정도 비효율적이라고 한다. 따라서 많은 thread들이 getInstance()를 호출하게 되면 프로그램 전반적인 성능 저하가 발생한다. 3-1. Thread safe Lazy initialization + Double-checked locking 기법 위에서 Thread safe Lazy initialization을 보았다. 많은 스레드들이 동시에 synchronized 처리된 메소드를 접근하면 성능저하가 발생된다고 했다. 이를 좀 더 완화하기 위해서 Double-checked locking 기법을 사용한다. 12345678910111213141516171819public class ThreadSafeLazyInitialization&#123; private static ThreadSafeLazyInitialization instance; // 생성자 private ThreadSafeLazyInitialization()&#123; &#125; public static ThreadSafeLazyInitialization getInstance()&#123; // Double-checked locking if(instance == null)&#123; synchronized (ThreadSafeLazyInitialization.class)&#123; if(instance == null)&#123; instance = new ThreadSafeLazyInitialization(); &#125; &#125; &#125; return instance; &#125;&#125; 첫 번째 if문에서 instance가 null인 경우 synchronized 블록에 접근하고 한 번 더 if문으로 instance가 null인지 유무를 체크한다. 2번 모두 다 instance가 null인 경우에 new를 통해 인스턴스화 시킨다. 그 후에 instance가 null이 아니기 때문에 synchronized 블록을 타지 않는다. 이런 DCL 기법을 통해 성능 저하를 보완할 수 있다. 4. Initialization on demand holder idiom(holder에 의한 초기화) 이 방법은 클래스 안에 클래스(Holder)를 두어 JVM의 Class Loader 매커니즘과 Class가 로드되는 시점을 이용한 방법이다. Lazy initialization 방식을 가져가면서 Thread간 동기화 문제를 동시에 해결할 수 있다. 로직은 InitializationOnDemandHolderIdiom 클래스에는 SingleTonHolder 클래스의 변수가 없기 때문에 InitializationOnDemandHolderIdiom 로딩시 SingleTonHolder 클래스를 초기화하지 않는다. 중첩 클래스(static으로 선언됨.) SingleTonHolder는 getInstance 메소드가 호출되기 전에는 참조되지 않으며, 최초로 getInstance() 메소드가 호출될 때 SingleTonHolder.instance를 참조하는 순간 클래스 로더에 의해 Class가 로딩되며 초기화되며, 싱글톤 객체를 생성하여 리턴한다. 또한, SingleTonHolder 안에 선언된 instance가 static이기 때문에 클래스 로딩 시점에 한 번만 호출된다. 그리고 final을 사용하기 때문에 다시 값이 할당되지 않도록 한다. 123456789101112131415public class InitializationOnDemandHolderIdiom&#123; private InitializationOnDemandHolderIdiom instante; // 생성자 private InitializationOnDemandHolderIdiom()&#123; &#125; public static class SingleTonHolder&#123; public static final InitializationOnDemandHolderIdiom INSTANCE = new InitializationOnDemandHolderIdiom(); &#125; public static InitializationOnDemandHolderIdiom getInstance()&#123; return SingleTonHolder.INSTANCE; &#125;&#125; 현재까지 가장 많이 사용되는 방법으로 알려져 있다. 그만큼 지금까지 나온 방법 중 가장 효율적인 방법이라고 한다. 참고 [Design_Pattern] Singleton(싱글톤)의 고도화","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"5일차 [안드로이드] Room","slug":"Android-Room-Basic","date":"2019-01-25T07:08:11.000Z","updated":"2020-04-25T13:54:10.383Z","comments":true,"path":"2019/01/25/Android-Room-Basic/","link":"","permalink":"https://woovictory.github.io/2019/01/25/Android-Room-Basic/","excerpt":"","text":"[2020.02.11 기준으로 수정과 동시에 내용을 추가하고 있습니다.] [2020.03.27 기준으로 글을 새롭게 작성하고 있습니다. 따라서 새로 작성되는 포스팅이 완료되면 해당 포스팅은 삭제될 예정입니다.] 작성중인 글 : Room 개념편 [2020.04.25 기준 홍보 내용 추가] 현재 신입 개발자를 위한 Repository를 운영하고 있습니다. 💻 신입 개발자로서 준비를 하기 위해 지식을 정리하는 공간 👨‍💻이며, 운영체제, 자바, 네트워크, 데이터베이스 등의 내용이 정리되어 있습니다. 계속해서 꾸준히 추가 중이니 한번씩 들러서 봐주시면 감사하겠습니다. 또한, 도움이 된다면 Star를 꾹~ 눌러주시면 저에게 큰 힘이 됩니다 :) Android Architecture Component 중 하나인 Room에 대해 알아보려고 한다. [ORM] Room을 알아보기 전에 ORM이 무엇인지 살펴보자. ORM이란 Object Relational Mapping으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것이다. [Room] Room은 SQLite의 기능을 최대한 활용하는 동시에 데이터베이스를 원활하게 접근할 수 있도록 SQLite 위에 추상화 계층을 제공 라이브러리라고 생각하면 된다. 적은 양의 정형화된 데이터를 처리하는 애플리케이션은 로컬에서 해당 데이터를 유지함으로써 큰 이점을 얻을 수 있다. ex) 관련 데이터를 캐시하는 것 이렇게 하면 장치가 네트워크에 액세스할 수 없는 경우에도 사용자가 오프라인 상태일 때 해당 콘텐츠를 계속 탐색할 수 있다. 이후에 장치가 다시 온라인 상태가 되면 사용자가 시작한 모든 콘텐츠 변경 내용이 서버에 동기화된다. [사용해보기] gradle에 의존성을 추가한다. 먼저, build.gradle 파일의 dependencies에 추가해준다.그래야지 Room을 사용할 수 있다. roomVersion은 사용하는 시점에 맞는 버전을 사용하면 된다. 123//roomimplementation \"android.arch.persistence.room:runtime:$roomVersion\"kapt \"android.arch.persistence.room:compiler:$roomVersion\" [3가지 주요 컴포넌트] Room은 엔티티(Entity), 데이터 접근 객체(Data Access Object), 룸 데이터 베이스(Room Database) 이렇게 총 3가지 구성요소로 나뉜다. Database 데이터베이스 홀더를 포함하고 앱의 지속적이고 관계가 있는 데이터에 대한 기본 연결을 위한 기본 액세스 지점 역할을 한다. @Database로 어노테이션된 클래스는 다음의 조건을 만족해야 한다. RoomDatabase를 상속받는 클래스는 추상 클래스이어야 한다. 어노테이션 내에 데이터베이스와 연관된 (즉, 데이터베이스에 들어갈 테이블) 엔티티의 목록을 포함한다. 파라미터가 0개인 추상 메소드를 포함하고 @Dao로 어노테이션된 클래스를 반환한다. 런타임에 Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()를 호출하여 데이터베이스 인스턴스를 얻을 수 있다. 12345678910// User and Book are classes annotated with @Entity.@Database(version = 1, entities = &#123;User.class, Book.class&#125;)abstract class AppDatabase extends RoomDatabase()&#123; // BookDao is a class annotated with @Dao. abstract public BookDao bookDao(); // UserDao is a class annotated with @Dao. abstract public UserDao userDao(); // UserBookDao is a class annotated with @Dao. abstract public UserBookDao userBookDao();&#125; 데이터베이스에서 쿼리를 직접 실행하는 대신 Dao 클래스를 만드는 것이 좋다. Dao 클래스를 사용하면 보다 논리적인 계층에서 데이터베이스 통신을 추상화할 수 있다. 이 계층은 직접 sql 쿼리를 실행하는 것에 비해 테스트를 더 쉽게 할 수 있다. Room은 애플리케이션이 컴파일 되는 동안 Dao 클래스의 모든 쿼리를 확인하여 쿼리 중 문제가 있는 경우 즉시 사용자에게 알려준다. Entity 데이터베이스 내에서 테이블을 나타낸다. room을 사용할 때 관련 필드 집합을 엔티티들로 정의한다. 각 엔티티에 대해 항목(아이템)을 보관하기 위해 연결된 데이터베이스 객체 내에 테이블이 생성된다. 데이터베이스 클래스의 엔티티 array를 통해 엔티티 클래스를 참조해야 한다. 12345678@Entitypublic class User&#123; @PrimaryKey public int id; public String firstName; public String lastName;&#125; 필드를 유지하려면, 룸은 필드에 접근할 수 있어야 한다. 필드를 public으로 만들거나, getter / setter를 제공할 수 있다. getter / setter method를 사용한다면 룸에서 JavaBeans 규칙을 기반으로 한다.[멤버 변수는 private형을 지정하여 선언한다.] 주의 엔티티에는 빈 생성자 (해당 DAO 클래스가 각 지속 필드를 액세스할 수 있는 경우) 또는 매개 변수에 엔티티 필드와 일치하는 유형과 이름이 포함된 생성자가 있을 수 있다. 룸은 일부 필드만 수신하는 생성자와 같이 전체 또는 부분 생성자를 사용할 수도 있다. User a Primary Key 각 Entity는 최소 하나 이상의 필드를 기본키로 지정해야 한다. 필드가 하나만 있는 경우에도 @PrimaryKey 어노테이션을 사용하여 필드에 주석을 달 필요가 있다. 또한, 룸에서 엔티티에 자동으로 ID를 할당하도록 하려면 @PrimaryKey의 autoGenerate 속성을 설정할 수 있다.(기본은 false. ex: index가 자동으로 증가하는 경우와 같은) 엔티티가 복합 PrimaryKey가 있는 경우 @Entity 어노테이션의 primaryKeys 속성을 사용할 수 있다. 12345@Entity(primaryKeys = &#123;\"firstName\", \"lastName\"&#125;)public class User&#123; public String firstName; public String lastName;&#125; 기본적으로 룸은 클래스 이름을 데이터베이스 테이블 이름으로 사용한다. 만약 테이블이 다른 이름을 가지게 하고 싶다면, @Entity 어노테이션의 tableName 속성을 설정하면 된다. 1234@Entity(tableName = \"users\")public class User&#123; ///&#125; 주의 : SQLite의 테이블 이름은 대소문자를 구분하지 않는다. tableName 속성과 비슷하게 룸은 필드 이름을 데이터베이스의 column 이름으로 사용한다. 만약 column 이름을 다르게 하고 싶다면 @ColumnInfo 어노테이션을 추가하면 된다. 1234567891011@Entity(tableName = \"users\")public class User&#123; @PrimaryKey public int id; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName;&#125; Ignore fields 기본적으로 룸은 엔티티에 정의된 각 필드에 대한 Column을 생성한다. 엔티티에 지속하고 싶지 않은 필드가 있는 경우 @Ignore를 사용하여 필드에 어노테이션을 추가할 수 있다. 123456789101112@Entity(tableName = \"users\")public class User&#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; 상위 엔티티에서 필드를 상속하는 경우, 일반적으로 @Entity 특성의 ignoredColumns 속성을 더 쉽게 추가해서 사용할 수 있다. 1234567@Entity(ignoredColumns = \"picture\")public class RemoteUser extends User &#123; @PrimaryKey public int id; public boolean hasVpn;&#125; Provide table search support 추가 예정~~ DAO(Data Access Object) 데이터베이스에 접근할 수 있는 메소드를 포함하며, 데이터 접근 객체이다. 인터페이스로서 쿼리를 사용하는 메소드를 정의한다. 룸을 사용해 앱의 데이터에 접근하려면 DAO를 사용한다. 각 DAO에는 앱의 데이터베이스에 대한 추상적 액세스를 제공하는 방법이 포함되어 있으므로(interface내에 쿼리와 함께 함수만 정의) 이 Dao 객체들은 룸의 주요 구성요소를 형성한다. 쿼리 builder나 직접적인 쿼리 대신 DAO 클래스를 사용하여 데이터베이스에 접근하여 데이터베이스 구조의 다양한 구성 요소를 분리할 수 있다. 또한, DAO를 사용하면 애플리케이션을 테스트할 때 데이터베이스 접근을 쉽게 할 수 있다. DAO는 인터페이스 또는 추상 클래스일 수 있다. 추상 클래스인 경우 선택적으로 RoomDatabase를 유일한 매개 변수로 사용하는 생성자를 가질 수 있다. Room은 Compile time에 각 DAO 구현을 생성한다. Define methods for convenience DAO 클래스를 사용하여 나타낼 수 있는 여러가지 편리한 쿼리가 있다. 1. Insert DAO 메소드를 작성하고 @Insert로 어노테이션을 지정할 때, Room은 단일 트랜잭션의 데이터베이스에 모든 매개변수를 삽입하는 구현을 생성한다. 1234567891011@Daopublic interface MyDao&#123; @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUsers(User... users); @Insert public void insertBothUsers(User user1, User user2); @Insert public void insertUsersAndFriends(User user, List&lt;User&gt; friends);&#125; @Insert 메소드는 매개 변수를 1개만 받으면 삽입된 항목의 새 rowId인 long 타입의 값을 반환할 수 있다. 매개변수가 배열 또는 집합인 경우 Long[] 또는 List을 대신 반환해야 한다. @Insert에 onConflict 속성을 지정할 수 있다. 테이블에 Entity를 삽입할 때 같은 값인 경우, 충돌이 발생하는데 이 충돌을 어떻게 해결할지를 정의할 수 있다. 위에서는 Replace로 지정하여 충돌 발생 시 새로 들어온 데이터로 교체한다. 2. update update 방법은 테이터베이스에서 매개 변수로 지정된 엔티티 집합을 수정한다. 각 엔티티의 기본 키와 일치하는 조회를 사용한다. 12345@Daopublic interface MyDao &#123; @Update public void updateUsers(User... users);&#125; 일반적으로 필요하진 않지만, update를 사용하면 데이터베이스에서 업데이트된 행 수를 나타내는 int 값을 반환할 받을 수 있다. 3. Delete Delete 방법은 매개 변수로 지정된 엔티티 집합을 데이터베이스에서 제거한다. 기본키를 사용하여 삭제할 엔티티를 찾는다. 12345@Daopublic interface MyDao&#123; @Delete public void deleteusers(User... users);&#125; update와 비슷하게 삭제를 하면 데이터베이스에서 제거된 행 수를 나타내는 int 값을 반환할 수 있다. 4. Query @Query는 DAO 클래스에서 사용되는 주석이다. 데이터베이스에서 읽기 / 쓰기 작업을 수행할 수 있다. 각 @Query 메소드는 Compile time에 확인되므로 쿼리에 문제가 있으면 Runtim Error 대신 Compile Error가 발생한다. 또한, 룸은 반환된 객체의 필드 이름이 쿼리 응답의 해당 열 이름과 일치하지 않는 경우 룸은 다음 두 가지 방법 중 하나로 경고를 표시한다. 일부 필드 이름만 일치하는 경우 경고를 표시한다. 필드 이름이 일치하지 않으면 오류가 발생한다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT * FROM user\") public User[] loadAllUsers();&#125; 모든 사용자를 load하는 간단한 쿼리이다. Compile time에 룸은 사용자 테이블의 모든 Column을 쿼리한다는 것을 알고 있다. 쿼리에 구문 오류가 있거나 사용자 테이블이 데이터베이스에 없는 경우, Room은 앱 컴파일 시 적절한 메시지가 포함된 오류를 표시한다. 5. Passing parameters into the query 대부분의 경우 특정 연령보다 나이가 많은 사용자만 표시하는 등의 필터링 작업을 수행하려면 매개 변수를 쿼리에 전달해야 한다. 다음에서 확인할 수 있다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT * FROM user WHERE age &gt; :minAge\") public User[] loadAllUsersOlderThan(int minAge);&#125; 이 쿼리를 컴파일할 때, Room은 :minAge bind 매개 변수와 minAge 메소드 매개변수를 일치시킨다. Room은 매개 변수 이름을 사용하여 매치를 수행한다. 일치하지 않는 경우 앱 컴파일 시 오류가 발생한다. 다음과 같이 여러 매개변수를 전달하거나 조회에서 여러 번 참조할 수도 있다. 123456789@Daopublic interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\") public User[] loadAllUsersBetweenAges(int minAge, int maxAge); @Query(\"SELECT * FROM user WHERE first_name LIKE :search \" + \"OR last_name LIKE :search\") public List&lt;User&gt; findUserWithName(String search);&#125; 6. Returning subsets of columns 대부분의 경우 엔티티의 몇 가지 필드만 있으면 된다. 예를 들어 UI는 사용자에 대한 모든 세부 정보가 아니라 사용자의 성과 이름만 표시할 수 있다. 앱의 UI에 표시되는 열만 가져오면 리소스가 절약되고 쿼리가 더 빨리 완료된다. Room을 사용하면 결과 Column 집합을 반환될 개체로 매핑할 수 있는 쿼리에서 Java 기반 개체를 반환할 수 있다. 12345678// Java Objectpublic class NameTuple &#123; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName;&#125; Query 메소드에서 이 자바 객체를 사용할 수 있다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT first_name, last_name FROM user\") public List&lt;NameTuple&gt; loadFullName();&#125; Room은 쿼리가 first_name, last_name 열에 대한 값을 반환하고 이러한 값을 NameTuple 클래스의 필드에 매핑할 수 있음을 이해한다. 따라서 룸에서 적절한 코드를 생성할 수 있다. 쿼리가 너무 많은 열을 반환하거나 NameTuple 클래스에 없는 열을 반환하면 룸에 경고가 표시된다. 7. Passing a collection of arguments 일부 쿼리는 런타임까지 알 수 없는 정확한 수의 매개 변수를 사용하여 많은 매개 변수를 전달해야 할 수 있다. 예를 들어, regions의 하위 집합에서 모든 사용자에 대한 정보를 검색할 수 있다. Room은 매개변수가 집합을 나타내는 시점을 파악하고 제공된 매개변수 수에 따라 런타임에 매개변수를 자동으로 확장한다. 12345@Daopublic interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user WHERE region IN (:regions)\") public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions);&#125; 8. Observable queries 쿼리를 수행하며 데이터가 변경될 때 앱의 UI가 자동으로 업데이트 되는 경우가 많다. 이를 수행하기 위해서는 쿼리 메소드 description에 LiveData 유형의 반환 값을 사용한다. Room은 데이터베이스가 업데이트될 때 LiveData를 업데이트하는데 필요한 모든 코드를 생성한다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT first_name, last_name FROM user WHEHE region IN (:regions)\") public LiveData&lt;List&lt;User&gt;&gt; loadUserFromRegionsSync(List&lt;String&gt; regions);&#125; 9. Reactive queries with RxJava 추가 예정~~ [연습해보기] Entity : database의 row와 mapping되는 class. 즉, table의 구조를 나타내는데 Database에서 entities 함수를 통해 접근할 수 있다. @Ignore를 붙이지 않는한 DB에 지속적으로 유지된다. entity는 empty 생성자나, 부분 field만 갖는 생성자, full field에 대한 생성자 모두를 가질 수 있다. DAO : database를 접근하는 함수들이 정의되는 class or interface이다. @Database로 정의된 class는 내부에 인자가 없고 @Dao annotation이 되어 있는 class를 return하는 abstract 함수를 포함하고 있다. 아래의 예제는 하나의 entity와 하나의 Dao를 갖는 형태이다. 1234567891011121314// User.java@Entitypublic class User&#123; @PrimaryKey private int uid; @ColumnInfo(name = \"first_name\") private String firstName; @ColumnInfo(name = \"last_name\") private String lastName; // 생략&#125; 123456789101112131415161718// UserDao.java@Daopublic interface UserDao&#123; @Query(\"SELECT * FROM user\") List&lt;User&gt; getAll(); @Query(\"SELECT * FROM user WHERE uid IN (:userIds)\") List&lt;User&gt; loadAllByIds(int[] userIds); @Query(\"SELECT * FROM user WHERE first_name LIKE :first AND \" + \"last_name LIKE :last LIMIT 1\") User findByName(String first, String last); @Insert void insertAll(User... users); @Delete void delete(User user);&#125; 12345// AppDatabase.java@Database(entities = &#123;User.class&#125;, version = 1)public abstract class AppDatabase extends RoomDatabase&#123; public abstract UserDao userDao();&#125; 위 3개의 class가 완성되면 아래와 같이 DB의 instance를 얻을 수 있다. 1AppDatabase db = Roo.databaseBuilder(getApplicationContext(), AppDatabase.class, \"database-name\").build(); AppDatabase object를 생성하는 코드는 비용이 많이 들기 때문에 싱글톤으로 구현해야 한다. Entities @Database의 annotation에 속성으로 포함된 entitiy는 실제 @Entity annotation을 붙인 class로 만들어야 한다. 이는 각 table로 생성되며, 실제 colume으로 만들고 싶지 않은 field가 있다면 @Ignore를 붙인다. 1234567891011@Entityclass User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125; Field는 public 형태이어야 하며, private으로 할 경우 getter와 setter를 java beans convention에 따라 만들어야 한다. Primary Key column이 하나라도 PK는 지정되어야 한다. @PrimaryKey annotation을 이용하거나 복합 PK의 경우 @Entity 속성으로 primarykeys를 이용한다. 또한, Id를 autogenerate하려면 @PrimaryKey 속성에 autoGenerate 속성(true)을 넣는다. 추가적으로 class 이름은 table 명이 된다. table 명을 바꾸고 싶다면 @Entity 속성으로 tableName을 넣으면 된다. 만약 field 이름을 column으로 쓰고 싶지 않다면 @ColumnInfo로 표기해야 한다. 12345678910111213141516171819202122232425262728293031// 복합 PK 사용시@Entity(primaryKeys = &#123;\"firstName\", \"lastName\"&#125;)class User&#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;// 테이블 이름을 직접 지정할 때@Entity(tableName = \"users\")class User&#123; // 생략&#125;// Column을 직접 지정할 때@Entity(tableName = \"users\")class User&#123; @PrimaryKey public int uid; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; Indices and uniqueness Indext는 아래와 같이 만들 수 있다.(결합 index도 생성 가능) 12345678910111213141516@Entity(indices = &#123;@Index(\"name\"),@Index(value = &#123;\"last_name\",\"address\"&#125;)&#125;)public class Users &#123; @PrimaryKey public int uid; public String firstName; public String address; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; Unique 제약 조건은 아래와 같이 표기할 수 있다. 예제) 결합 조건에 대한 unique index 12345678910111213141516@Entity(indices = &#123;@Index(value = &#123;\"first_name\", \"last_name\"&#125;, unique = true)&#125;)public class Users &#123; @PrimaryKey public int uid; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name = \"last_name\") public String lastName; @Ignore Bitmap picture;&#125; foreignKey도 설정할 수 있다. 123456789101112@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = \"id\", childColumns = \"user_od\"))public class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = \"user_id\") public int useerId;&#125; Nested objects Entity 클래스가 field로 object를 갖는 경우 @Embeded를 사용한다. 단, 해당 table에는 Embeded된 클래스의 column도 똑같은 하나의 column으로 취급된다. 12345678910111213141516171819class Address&#123; public String street; public String state; public String city; @ColumnInfo(name = \"post_code\") public int postCode;&#125;@Entityclass User&#123; @PrimaryKey public int id; public String firstName; @Embeded public Address address;&#125; 즉, 위 예제에서 User table에는 id, firstName, street, state, city, post_cde 컬럼이 존재한다. Embeded 안에서 embeded를 가질 수 있으며, 만약 column 이름이 중복되는 경우 prefix를 사용하여 unique하게 column 이름을 설정한다. DAO(Data Access Objects)(DAOs) Dao는 abstract class나 interface가 될 수 있다. RoomDatabase를 인자로 받는 생성자를 만드는 경우에만 abstract class가 될 수 있다. Room은 절대로 main thread에서 query 작업을 하지 않는다. allowMainThreadQueries()를 호출하더라도 불가능하다. LiveData는 return하는 비동기 query의 경우에는 가능하다.(어차피 background에서 수행되므로) - 무슨 말이지…? Insert @Insert로 표기하며, single transaction으로 처리된다. 1234567891011@Daopublic interface MyDao &#123; @Insert(onConflict = OnConflictStrategy.REPLACE) public void insertUsers(User... users); @Insert public void insertBothUser(User user1, User user2); @Insert public void insertUsersAndFriends(User user, List&lt;User&gt; friends);&#125; @Entity로 정의된 class만 인자로 받거나, 그 class의 collection 또는 array만 인자로 받을 수 있다. 또한, 인자가 하나인 경우 long type의 return(insert된 값의 rowId)을 받을 수 있고, 여러 개인 경우 long[], List을 받을 수 있다. Update Update를 사용하여 Entity set을 update 한다. return 값으로 변경된 rows 수를 받을 수 있다. update는 PK 기준으로 한다. 12345@Daopublic interface MyDao&#123; @Update public void updateUsers(User... user);&#125; Delete Delete를 사용하여 Entity set을 delete 한다. return 값으로 변경된 rows 수를 받을 수 있다. 삭제 key는 PK를 기준으로 한다. 12345@Daopublic interface MyDao&#123; @Delete public void deleteUsers(User... users);&#125; Query @Query를 사용하여 DB를 조회할 수 있다. compile time에 return되는 object의 field와 sql 결과로 나오는 column의 이름이 맞는지 확인하여 일부가 match되면 warning, match 되는게 없다면 error를 보낸다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT * FROM user\") public User[] loadAllUsers();&#125; select문에 parameter가 들어가야 하는 경우 아래와 같이 넣을 수 있다. 12345@Daopublic interface MyDao&#123; @Query(\"SELECT * FROM user WHERE age &gt; :minAge\") public User[] loadAllUsersOlderThan(int minAge);&#125; 아래와 같이 여러 개의 parameter도 사용할 수 있다. 1234567@Dao public interface MyDao &#123; @Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\") public User[] loadAllUsersBetweenAges(int minAge, int maxAge); @Query(\"SELECT * FROM user WHERE first_name LIKE :search \" + \"OR last_name LIKE :search\") public List&lt;User&gt; findUserWithName(String search); &#125; 만약 일부 컬럼만 조회하고 싶다면 따로 return class를 만들어서 요청할 수 있다. 1234567891011121314// return 받을 class를 정의public class NameTuple&#123; @ColumnInfo(name = \"first_name\") public String firstName; @ColumnInfo(name=\"last_name\") public String lastName;&#125;@Daopublic interface MyDao&#123; @Query(\"SELECT first_name, last_name FROM user\") public List&lt;NameTuple&gt; loadFullName();&#125; 또한, 정해지지 않은 개수의 parameter가 넘어가야 하는 경우 아래와 같이 수행 가능하다. 12345@Dao public interface MyDao &#123; @Query(\"SELECT first_name, last_name FROM user WHERE region IN (:regions)\") public List&lt;NameTuple&gt; loadUsersFromRegions(List&lt;String&gt; regions); &#125; 기타 등등의 기능들을 포함하고 있다. 하지만, 아래는 필요에 따라 찾아보면서 기능을 사용하면 될 것 같다. Using tye converters Room은 primitive type(원시 타입 ex. int, String 등등)과 그 wrapping 타입만 지원한다. 하지만, 그 외에 type을 사용할 경우 TypeConverter를 사용하여 type을 치환해야 한다. 예를 들어, DB에서는 timestamp로 되어 있고, java code에서는 Date class로 되어 있는 경우 우선 아래와 같이 converter를 만든다. 1234567891011public class Converters&#123; @TypeConverter public static Date fromTimestamp(Long value)&#123; return value == null? null : new Date(value); &#125; @TypeConverter public static Long dateToTimestamp(Date date)&#123; return date == null? null : date.getTime(); &#125;&#125; 이 두개의 converting 함수는 서로 converting 해주고 있다. @TypeConverters를 이용하여 적용할 곳에 넣는다. 12345678910111213141516171819202122// AppDatabase.java@Database(entities = &#123;User.java&#125;, version= 1)@TypeConverters(&#123;Converters.class&#125;)public abstract class AppDatabase extends RoomDatabase&#123; public abstract UserDao userDao();&#125;// User.java@Entitypublic class User&#123; ... private Date birthday;&#125;// UserDao.java@Daopublic interface UserDao&#123; ... @Query(\"SELECT * FROM user WHERE birthday BETWEEN :from AND :to\") List&lt;User&gt; findUsersBornBetweenDates(Date from, Date to);&#125; @TypeConverter를 지정하는 위치에 따라 scope이 달라진다. 예제처럼 Database에 넣으면 Dao와 entity 모두 영향을 받는다. Dao나 Entity, POJO에 넣을 수도 있고, Entity의 특정 field, Dao의 특정 method or 특정 parameter에 넣을 수 있다. Database migration database migration이 필요한 경우 entity class에 수정 항목을 반영해야 한다. 또한 데이터를 날리지 않기 위해서 mirgration을 할 수 있는 방법을 제공한다. migration을 등록하면, runtime에 migration을 수행하며 정해놓은 순서대로 migration이 가능하다. migration을 등록할 때는 시작 버전과 끝 버전을 넣어야 한다. 1234567891011121314Room.databaseBuilder(getApplicationContext(), MyDb.class, \"database-name\").addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();static final Migration MIGRATION_1_2 = new Migration(1,2)&#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(\"CREATE TABLE `Fruit` (`id` INTEGER, \" + \"`name` TEXT, PRIMARY KEY(`id`))\"); &#125;&#125;;static final Migration MIGRATION_2_3 = new Migration(2, 3) &#123; @Override public void migrate(SupportSQLiteDatabase database) &#123; database.execSQL(\"ALTER TABLE Book \" + \" ADD COLUMN pub_year INTEGER\"); &#125; &#125;; migration 코드가 없으면 Room은 DB를 그냥 rebuild한다.(기존 데이터는 날아간다.) 또한, migration에 들어가는 query는 상수에 넣지말고, 직접 넣는게 migration 로직을 유지하는데더 좋다. migration이 끝나고 나면, schema에 대한 유효성을 확인을 하고, 문제가 있을 경우 mismatch된 부분에 정보를 담은 exception을 발생 시킨다. 참고 Android Architecture Components #6 - Room Defining data using Room entities Save data in a local database using Room","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Room","slug":"Room","permalink":"https://woovictory.github.io/tags/Room/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"AAC","slug":"AAC","permalink":"https://woovictory.github.io/tags/AAC/"}]},{"title":"4일차 [Git] Issue 탭 이용하기","slug":"Etc-Git-Issue-Use","date":"2019-01-23T16:00:24.000Z","updated":"2020-05-12T11:31:11.015Z","comments":true,"path":"2019/01/24/Etc-Git-Issue-Use/","link":"","permalink":"https://woovictory.github.io/2019/01/24/Etc-Git-Issue-Use/","excerpt":"","text":"부스트 캠프를 하면서 오늘이 4일차이다. 지금까지 배운 것은 데일리 스크럼을 하면서 오늘의 상태와 할 것들을 상기하는 시간을 갖는다. 정말 간단하게 하면서 5~10분 정도로 진행한다. 그리고 항상 어제 저녁에 작성했던 snippet을 보면서 어제는 어떤 일을 했고, 오늘은 어떤 일을 할지 다시 한번 생각한다. snippet [오늘 완료 업무] 기능 정의서 세분화 WBS 파일 git 업로드 팀 Repository issue 탭 추가 [내일 업무] 피드백 반영 안드로이드 기본 구조 세팅 위와 같은 업무들을 작성한다. 보통 스니펫은 6시 퇴근이라고 가정한다면 5시? 정도에 회의를 통해서 스니펫을 공유하는 작업을 거친다. 우리는 지금 슬랙에 채널을 이용해서 공유하고 있다. 그 다음으로는 Github을 이용한 협업 능력이다. 일단 지금까지 Github을 사용하면서 나는 Github flow를 바탕으로 협업을 진행했다. 그리고 부스트 캠프를 통해서 Git flow를 알게 되었고, 공부도 진행했다. 공부하면서 느낀 점은 Git은 정말 지옥이라는 점과 많은 명령어가 존재한다는 점이다. [Git에 대한 공부는 앞에 포스팅을 참고하면 된다. 제목이 #일차가 붙은 것들이다.] 어떤 회사에서는 Jira 라는 애자일 프로세스 툴을 사용해서 이슈를 관리하고 이슈마다 나오는 티켓? 번호를 기준으로 해서 피쳐를 나누고 개발을 한다고 한다. 하지만, 유료이고 설치가 조금 까다롭다고 해서 우리는 Jira를 사용하지 않고 다른 방법을 사용하기로 했다. Issue 발행 Issue는 모든 것이 이슈라고 불릴 수 있다. 새로운 추가될 기능, 개선 해야할 기능, 버그 등등 모든 것이 이슈라고 볼 수 있다. 모든 활동 내역에 대해서 이슈를 등록하고 그 이슈 기반으로 작업을 하게 된다. 우리는 Github의 issue 탭을 사용해서 이를 기반으로 feature 브랜치를 생성해서 작업할 예정이다. Issue Template 이슈 템플릿을 사용해서 형식을 지정하여 사용할 수 있다. .github/ 디렉토리 밑에 ISSUE_TEMPLATE.md 파일에 템플릿을 지정해서 사용할 수 있다. 우리는 issue 템플릿은 사용하지 않는다. Issue 작업 다음 예제의 사진을 통해서 등록된 issue를 살펴보자. Assignees : 해당 작업의 담당자 Labels : 해당 작업의 성격을 지정한다. Milestone : 해당 작업이 속한 파트 다른 것들은 이해하기 쉽지만 Milestone은 생소하다. Milestone은 이번 출시 버전이 1.0.0일 경우 해당 버전이든 이슈(작업) 기능 강화, 새 기능추가, 버그 기타 등등 모든 이슈를 Version 1.0.0 Milestone이라는 항목에 추가하면 위 그림처럼 Version 1.0.0에 대한 전체적인 상황을 한 눈에 볼 수가 있는 장점이 있다. 1. Issue 생성 일단, 우리는 먼저 Github의 issue 탭에 들어가서 기능 정의서를 기반으로 issue를 생성한다. 이슈는 스토리_기능의 형태로 이슈를 생성했다. 기본 기능들을 미리 이슈 탭을 이용해서 기능을 정리한 것이다. 이슈를 생성할 때 자동으로 번호가 발급되는데 이 번호를 사용해서 feature 브랜치를 생성할 것이다. 2. 브랜치 생성 이제 발급된 이슈 번호를 기준으로 feature 브랜치를 생성하면 된다. Git flow에 따라서 develop 브랜치에서 feature 브랜치를 딴다. 1git checkout -b feature_#033_util_sharedpreference develop 위의 명령어는 develop으로부터 feature_#033_util_sharedpreference라는 브랜치를 생성하고 그 브랜치로 이동하는 것을 의미한다. 3. 작업 수행 후 commit 코드를 수정하거나 클래스를 만드는 등의 작업을 수행하고 커밋을 해준다. 1git commit -a -m &quot;#003_feat_쉐어드 프리퍼런스 구현&quot; 위의 명령어는 git add와 git commit을 합친 형태이다. 메시지도 위와 같은 형식을 지켜서 작성한다. 4. 원격 저장소로 push 작업 이제 commit도 완료했으니 원격 저장소(origin)으로 push를 하면 된다. 1git push origin feature_#033_util_sharedpreference 5. PR &amp; Merge 이제 Merge를 해달라는 Pull Request를 작성한다. PR의 이름은 Feature #033 util SharedPreference로 작성한다. 내용은 PR Template을 이용하여 개요와 작업 사항, 사용 방법 등을 작성한다. 그리고 작성자와 라벨을 달고 리뷰어를 설정한 뒤 PR를 날린다. 코드 리뷰를 받는다. 수정 사항이 있다면 코드를 수정하고 다시 push를 날린다. 여기서 resolved #이슈번호로 작성하면 merge될 때 해당 issue는 자동으로 삭제된다.(아주 간편한 기능!!!) 그러면 수정 사항에 대해서 링크가 나오고 위와 같이 답글을 달아준다. 그리고 코드 리뷰가 완료되고 리뷰어가 approve를 해주면 자신이 merge를 한다. 그리고 해당 브랜치는 더는 필요가 없다고 판단되면 Delete branch 버튼을 통해서 Remote에 있는 브랜치 삭제 해주면 된다. 참고 GitHub로 프로젝트 관리하기 Part1 - 이슈 발급 부터 코드리뷰까지","categories":[{"name":"Git","slug":"Git","permalink":"https://woovictory.github.io/categories/Git/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://woovictory.github.io/tags/etc/"}]},{"title":"3일차 [Git] Git-Flow","slug":"Etc-Git-Flow-2","date":"2019-01-23T08:51:47.000Z","updated":"2020-05-12T11:31:24.037Z","comments":true,"path":"2019/01/23/Etc-Git-Flow-2/","link":"","permalink":"https://woovictory.github.io/2019/01/23/Etc-Git-Flow-2/","excerpt":"","text":"어제 Git-Flow를 공부하면서 기초 개념과 용어에 대한 혼란이 너무 많이 왔었다. 오늘이 3일차인데, 아직 Git에서 헤매는 부분이 너무 많다. 오늘의 일정은 아래와 같은 일정이었다. 이런 일정을 snippet이라는 용어로 부른다. [오늘의 업무] Daily Scrum [매일의 상태를 체크] 코드 컨벤션 구체화 Git 과제 완료 github 초기 설정 기능 정의서 정리 오늘의 업무를 일찍 끝내서 남은 시간은 Git을 공부하는데 투자했다. 먼저, 간단한 용어를 정리하고 Git-Flow에 대한 내용을 정리할 예정이다. Git vs Github Git은 대표적인 분산 버전 관리 시스템으로, 사용자의 프로젝트에 포함된 파일의 변경 사항을 관리하고 추적하는 도구이다. Github은 Git을 사용하는 프로젝트를 지원하는 웹 호스팅 서비스이다. #Git Pointer HEAD 현재 Branch가 가리키는 가장 최근 Commit Master Branch 가장 기본이 되는 Branch Master branch는 Git에서 기본으로 생성해준다. origin 원격 Repository를 뜻하는 Alias Alias이므로 이름을 변경할 수 있다. origin/master 원격 Repository의 Master branch origin/HEAD 원격 Repository가 바라보는 버전 Gitflow Workflow nvie.com의 빈센트 드리센이 제안한 것이다. 대형 프로젝트에도 적용할 수 있는 좀 더 엄격한 작업 절차를 갖는다. Gitflow Workflow의 핵심 컨셉은 master와 develop, 두 개의 메인 브랜치를 이용한다는 것이다. master branch : 릴리즈 이력을 관리하기 위해 사용. 즉, 배포 가능한 상태만을 관리한다. develop branch : 기능 개발을 위한 브랜치들을 병합하기 위해 사용. (모든 기능이 추가되고 버그가 수정되어 배포 가능한 상태라면 ‘master’ 브랜치에 merge 한다.) 평소에는 이 브랜치를 기반으로 개발을 진행한다. 1.중앙 원격 저장소, 자신의 원격 저장소, 로컬 저장소의 개념 중앙 원격(remote) 저장소 여러 명이 같은 프로젝트를 관리하는 데 사용하는 그룹 계정의 중립된 원격 저장소 Organization을 만들어 사용할 수 있다. Organization의 사용자와 저장소는 팀으로 관리되고 저장소의 권한 설정도 팀으로 관리한다. 자신의 원격(remote) 저장소 remote repository라고 불린다. 파일이 Github 전용 서버에서 관리되는 원격 저장소 로컬(local) 저장소 local repository라고 불린다. 내 PC에 파일이 저장되는 개인 전용 저장소, 지역 저장소의 개념이다. 2. 프로젝트 참여자는 git clone 명령으로 로컬 저장소를 만든다. git clone 명령으로 중앙 원격 저장소(remote repository)를 복제하여 자신의 로컬 저장소(local repository)를 만들 수 있다. 프로젝트 참여자는 clone 한 이 로컬 저장소에서 작업을 수행하면 된다. 123// 터미널에서 자신이 원하는 디렉토리로 이동한 후 clone 명령어 입력git clone [중앙 remote repository URL] git clone 명령은 아래의 명령들을 포함한 작업이다. 123456// 해당 디렉토리를 빈 Git 저장소로 만드는 작업git init// 현재 작업 중인 Git 저장소에 팀의 중앙 원격 저장소를 추가한다. 이름을 origin으로 짓고 긴 서버 주소(URL) 대신 사용한다. 마치 별명과 같다.git remote add origin [중앙 remote repository URL]// 중앙 원격 저장소(origin)의 master 브랜치 데이터를 로컬에 가져오기만 하는 작업git fetch origin master fetch와 pull의 차이 fetch : 원격 저장소의 데이터를 로컬에 가져오기만 하는 작업 pull : 원격 저장소의 데이터를 가져와 자동으로 병합까지 하는 작업 즉, 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우에는 fetch 명령어를 사용한다. pull = fetch + merge 3.먼저 할 일은 Develop 브랜치를 만드는 것이다. 방법[1] : GUI 도구를 이용한 생성(이 방법을 추천) ‘master’ 브랜치를 기준으로 develop 브랜치를 만든다. 여기서는 Pull Request를 이용할 것이기 때문에 GUI 도구를 이용한 생성 방법을 사용한다.[이 방법을 추천한다고 한다!!] Github 페이지에서 Branch:master를 클릭한 후 새로 생성할 브랜치의 이름을 develop으로 적는다. [이때, branch를 생성할 수 있는 사용자는 Owner 권한이 있는 사용자] 새로 생성한 develop branch를 default branch로 설정해야 한다. develop branch를 default branch로 설정하는 이유는? Git-flow에서 평소에는 develop branch를 기반으로 개발을 진행하기 때문에 git push origin some-feature(내 로컬 저장소의 some-feature branch를 중앙 원격 저장소로 올리는 명령)를 한 후, Github 페이지에서 해당 some-feature branch에 대해 merge를 할 때 중앙 원격 저장소의 ‘master’ branch가 아닌 default로 설정되어 있는 develop에 병합하도록 설정하기 위함이다. 방법[2] : 팀 구성원 중 한 명이 자신의 로컬 저장소에 빈 develop 브랜치를 만들고 중앙 저장소로 푸쉬 이 경우는 팀원 중 한 명이 자신의 로컬 저장소에 빈 develop branch를 생성한다. git branch develop 그 다음, 중앙 원격 저장소(origin)에 develop branch를 푸시한다. git push -u origin develop 12345# develop 브랜치 생성git branch develop# 중앙 원격 저장소 origin으로 develop branch pushgit push -u origin develop 그런 다음 Github 페이지에서 자신이 push한 ‘develop’ branch를 병합해달라는 Pull Request를 날린다. 프로젝트 관리자는 해당 pull request를 merge 하여 새로운 ‘develop’ branch를 중앙 원격 저장소에 생성한다. 그 다음에는 방법[1]과 같은 방법으로 develop branch를 default branch로 설정한다. 4. 팀 구성원 모두가 Gitflow workflow를 적용할 준비를 한다. 이제 팀 구성원들은 중앙 저장소를 복제하고(처음에 clone 했으면 넘어가도 좋다.), 중앙 저장소와 연결된 개발 브랜치를 만들어야 한다. checkout -b develop origin/develop```1234567891011121314151617181920212223이제 팀 구성원 모두가 이 워크플로우를 적용하기 위한 준비가 되었다. 다음 단계로 넘어가보자.## 5. 설명을 위해 현재 로컬에서 작업 중인 branch 위치를 표시한다.중앙 원격 저장소에는 master, develop branch가 있고, 자신의 로컬 저장소에도 master, develop branch와 로그인 기능을 구현한 feature/login branch가 있다고 가정한다. 또한, 현재는 master branch에서 작업 중이라고 가정하고 아래와 같이 작업 중인 위치를 표시한다.(Gitflow Workflow에서는 대부분의 작업이 **develop** branch에서 이루어진다.)&lt;img src=&quot;/img/github-collaboration-9.png&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;## 6. 새로운 기능 개발을 위해 격리된 branch를 만든다.로컬 저장소에서 branch를 따고, 코드를 수정하고, 변경 내용을 커밋한다. 이때, &apos;master&apos; branch에서 기능 개발을 위한 브랜치를 따는 것이 아니라 우리가 앞서 설정에서 default branch로 설정한 &apos;**develop**&apos; branch에서 따야한다.```gitgit checkout -b [branch name] develop# 아래의 두 명령어를 합하면 위와 같다.git branch [branch name] develogit checkout [branch name] 7. 로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 푸시한다. 새로 만든 브랜치(feature/login branch)에 새로운 기능에 대한 내용을 커밋한다. 123456$ git commit -a -m &quot;Write commit message&quot;# 위의 명령어는 아래의 두 명령어를 합한 것$ git add . # 변경된 모든 파일을 스테이징 영역에 추가$ git add [some-file] # 스테이징 영역 some-file 추가$ git commit -m &quot;Write commit message&quot; # local 작업 작업 폴더에 history 하나를 쌓는다. [commit] 커밋을 완료했다면, 내가 작업한 내용을 포함한 브랜치(feature/login branch)를 중앙 원격 저장소에 올린다. $git push origin feature/login branch 이는 로컬 저장소의 백업 역할을 할 뿐만 아니라, 다른 팀 구성원들이 나의 작업 내용과 진도를 확인할 수도 있어 좋은 습관이라 할 수 있다. 방법[1] : 팀이 pull request를 이용하는 경우 로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 push한 후, 프로젝트 관리자에게 자신의 기여분을 반영해 달라는 pull request를 보낸다. = 새로 만든 기능 개발용 브랜치도 중앙 저장소에 올려서 팀 구성원들과 개발 내용에 대한 의견(코드 리뷰)등을 나눌 수 있다. 이후에는 모든 팀원이 변경한 코드 내용을 확인하고 마지막으로 확인한 팀원 또는 프로젝트 관리자가 변경 내용을 중앙 원격 코드 베이스에 병합(merge)하는 작업을 한다. 이는 일종의 로컬 저장소 백업 역할을 하기도 한다. Pull Request란? 기능 개발을 끝내고 master에 바로 병합(merge)하는 것이 아니라, 브랜치를 중앙 원격 저장소에 올리고 병합(merge)해달라고 요청하는 것이다. GUI 도구를 이용한 pull request Github 페이지에서 Pull Request 버튼을 이용하면, 어떤 branch를 제출할 지 정할 수 있다. 기능을 구현한 branch(여기서는 feature/login branch)를 프로젝트의 중앙 원격 저장소의 develop branch에 병합해 달라고 요청한다. GUI 도구를 이용한 merge Github 페이지에서 Pull Request 버튼을 누른 후, File changed 탭에서 변경 내용을 확인한다. Conversation 탭으로 이동하여 Confirm merge를 하면 중앙 원격 코드 베이스(‘develop’ branch)에 병합된다. 위에서 ‘develop’ branch를 default branch로 설정했기 때문에 자동으로 ‘develop’ branch로 merge 도니다. 충돌이 일어난 경우는 팀원들과 합의 하에 충돌 내용을 수정한 후 병합을 진행한다. 방법[2] : 팀이 pull request를 이용하지 않는 경우 기능 브랜치를 병합하기 전에 반드시 자신의 로컬 저장소 develop branch에 중앙 원격 저장소의 변경 내용을 반영해서 최신 상태로 만들어야 한다. 또한 자신이 직접 새로운 기능에 대한 병합을 할 때, ‘master’ branch에 병합하지 않도록 주의해야 한다. 1234567# -u 옵션 : 새로운 기능 브랜치와 동일한 이름으로 중앙 원격 저장소의 브랜치로 추가한다.// 로컬의 기능 브랜치를 중앙 원격 저장소(origin)에 올린다.$ git push -u origin feature/login branch// -u 옵션으로 한 번 연결한 후에는 옵션 없이 아래의 명령만으로 기능 브랜치를 올릴 수 있다.$ git push origin feature/login branch 8. 중앙 원격 저장소와 자신의 로컬 저장소를 동기화하기 위해 로컬 저장소의 branch를 develop branch로 이동한다. // 로컬 저장소의 branch를 develop branch로 이동 $git checkout develop 9. 중앙 원격 저장소의 코드 베이스에 새로운 커밋이 있다면 다음과 같이 가져온다. 중앙 원격 저장소(origin)의 메인 코드 베이스(‘develop’ branch)가 변경되었으므로, 프로젝트에 참여하는 모든 개발자가 자신의 로컬 저장소를 동기화해서 최신 상태로 만들어야 한다. $git pull origin develop 중앙 원격 저장소(origin)의 변경 내용을 develop 브랜치에 반영해서 동기화한다. 10. 새로운 기능을 추가하기 위해서 그 작업에 대한 branch를 생성하여 작업한다. 중앙 원격 저장소와 동기화된 로컬 저장소의 ‘develop’ branch에서 새로운 작업에 대한 branch를 생성하여 다른 작업을 한다. 앞에서 했던 것과 동일하게 하면 된다. local에서 완성한 이전 작업 브랜치는 삭제한다. $git branch -d feature/login 11. 배포하기 만약 develop 브랜치에서 버전 1.2에 대한 기능이 모두 구현이 완료 되었으면 배포를 위한 전용 브랜치를 사용하여 배포 과정을 캡슐화 한다. 이렇게 함으로써 한 팀이 해당 배포를 준비하는 동안 다른 팀은 다음 배포를 위한 기능 개발을 계속할 수 있다. 이게 Gitflow의 장점이라고 생각한다. 버전 번호를 부여한 새로운 ‘release’ branch는 develop branch로부터 생성한다. 12// develp 브랜치로부터 release 브랜치(release-1.2)를 생성$git checkout -b release-1.2 develop 이렇게 release 브랜치를 만드는 순간부터 배포 사이클이 시작된다. release 브랜치에서는 배포를 위한 최종적인 버그, 수정, 문서 추가 등 릴리즈와 직접적으로 관련된 작업을 수행한다. 직접적으로 관련된 작업들을 제외하고는 release 브랜치에 새로운 기능을 추가로 병합하지 않는다. release 브랜치에서 배포 가능한 상태가 되면(배포 준비가 완료되면) 배포 가능한 상태 : 새로운 기능을 포함한 상태로 모든 기능이 정상적으로 동작하는 상태를 말한다. ‘master’ 브랜치에 병합한다.(이때, 병합한 커밋에 release 버전 태그를 부여!) 배포를 준비하는 동안 release 브랜치가 변경되었을 수 있으므로 배포 완료 후 ‘develop’ 브랜치에도 병합한다. 작업했던 release 브랜치는 삭제한다. 이때, 다음 번 배포(release)를 위한 개발 작업은 ‘develop’ 브랜치에서 계속 진행해 나간다. 방법[2] : 팀이 pull request를 이용하는 경우 팀이 풀 리퀘스트를 통한 코드 리뷰를 하는 방식을 사용한다면 release 브랜치를 그대로 중앙 원격 저장소에 push 한 후 다른 팀원들의 리뷰나 확인 과정을 거쳐 'master’와 ‘develop’ branch에 병합한다. 12. 버그 수정하기 배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우(버그 발견…!), ‘master’ 브랜치에서 직접 브랜치[hotfix 브랜치]를 만들어 필요한 부분만을 수정한 후 다시 ‘master’ 브랜치에 병합하여 이를 배포해야 한다. ‘develop’ 브랜치에서 문제가 되는 부분을 수정하여 배포 가능한 버전을 만들기에는 시간도 많이 소요되고 안정성을 보장하기도 어렵기 때문이다. 1234567891011121314151617181920212223242526272829// hotfix 브랜치(hotfix-1.2.1)를 &apos;master&apos; 브랜치에서 분기(유일함)$ git chekcout -b hotfix-1.2.1 master/*문제가 되는 부분만을 빠르게 수정한다.*//* 필요한 부분을 수정한 후 &apos;master&apos; 브랜치로 이동한다. */$git checkout master// &apos;master&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.$git merge --no-ff hotfix-1.2.1// 병합한 커밋에 새로운 버전 이름으로 태그를 부여한다.$git tag -a 1.2.1// &apos;master&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.$git push origin master/* &apos;hotfix&apos; 브랜치의 변경 사항을 &apos;develop&apos; 브랜치에도 적용 */// develop 브랜치로 이동한다.$git checkout develop// &apos;develop&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.$git merge --no-ff hotfix-1.2.1// &apos;develop&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.$git push origin develop// -d 옵션 : hotfix-1.2.1에 해당하는 브랜치를 삭제한다.$git branch -d hotfix-1.2.1 배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, ‘master’ 브랜치에서 hotfix 브랜치를 분기한다.(‘hotfix’ 브랜치만 master에서 바로 딸 수 있다.) 문제가 되는 부분만을 빠르게 수정한다. 다시 ‘master’ 브랜치에 병합(merge)하여 이를 안정적으로 다시 배포한다. 그리고 중앙 원격 저장소(origin)에 올린다.(push) 새로운 버전 이름으로 태그를 매긴다. hotfix 브랜치에서의 변경 사항은 ‘develop’ 브랜치에도 병합(merge)한다. 이 develop 브랜치도 중앙 원격 저장소(origin)으로 push한다. 작업했던 hotfix 브랜치는 삭제한다. 추가 기능 fast forward : merge할 때 default로 지정된 방식인데, default로 merge를 할 경우 커밋 이력들이 표시된다. git checkout -b feature/login develop git commit git commit git checkout develop git merge feature/login 을 수행하면 feature/login에서 수행했던 2번의 커밋 이력이 develop에 merge할 때 develop의 이력에 같이 표시된다. non fast forward : 참고 [GitHub] GitHub로 협업하는 방법[3] - Gitflow Workflow","categories":[{"name":"Git","slug":"Git","permalink":"https://woovictory.github.io/categories/Git/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://woovictory.github.io/tags/etc/"}]},{"title":"2일차 [Git] Github-Flow","slug":"Etc-Github-Flow","date":"2019-01-22T08:00:40.000Z","updated":"2020-05-12T11:31:14.892Z","comments":true,"path":"2019/01/22/Etc-Github-Flow/","link":"","permalink":"https://woovictory.github.io/2019/01/22/Etc-Github-Flow/","excerpt":"","text":"어제 Git-Flow를 공부해보았는데, 헷갈리는 부분이 너무 많다. 그래서 Github-Flow 방법에 대해서도 헷갈리는 부분이 많아 잘 정리된 블로그를 보고 공부했다. &quot;사전 과제 Repository를 fork 떠서 수정하고 PR 날려주세요.&quot;라는 메일을 받았다. 나는 Github을 사용하고 이런 비슷한 방식으로 프로젝트를 진행해왔지만 이게 이 방식이 맞는지도 모르고 있었다. Pull Request 협업을 하다보면 Pull Request를 보내서 코드 리뷰를 거쳐 원격 저장소에 merge가 된다. 분명 중요하다. Pull Request를 위해서 아래와 같은 절차를 거쳤다. Fork clone, remote 설정 branch 생성(안할 수도 있음) 수정 작업 후 add, commit, push Pull Reqeust 생성 코드 리뷰, Merge Pull Request Merge 이후 branch 삭제 및 동기화 Fork 타켓 프로젝트의 저장소를 자신의 저장소로 Fork 한다. Clone, remote 설정 fork로 생성한 본인 계정의 저장소에서 clone or download 버튼을 누르고 표시되는 url을 복사한다. Mac 기준에서 터미널을 켠다. 자신의 컴퓨터에서 작업을 하기 위해서 지정한 디렉토리로 가서 Fork한 저장소를 로컬에 Clone하기 위해서 아래의 명령어를 실행한다. 1git clone https://github.com/wayhome25/blog.github.io.git 이제, 로컬 저장소에 원격 저장소를 추가한다. 위 작업과 동일하게 github 저장소에서 clone or download 메뉴를 통해서 확인한 url을 사용한다. 원본 프로젝트 저장소 (직접 추가 필요) fork한 로컬 프로젝트 (origin이라는 별명으로 기본으로 추가되어 있다. 따로 추가할 필요 없음) 123456# 원본 프로젝트 저장소를 원격 저장소로 추가# 보통 upstream 사용$ git remote add real-blog(별명) https://github.com/원본계정/blog.github.io.git# 원격 저장소 설정 현황 확인방법$ git remote -v branch 생성 자신의 로컬 컴퓨터에서 코드를 추가하는 작업은 branch를 만들어서 진행한다. 개발을 하다보면 코드를 여러 개로 복사해야 하는 일이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는데, 이렇게 독립적으로 개발하는 것이 브랜치다. 12345678910git branch develop mastergit checkout develop# 하나의 명령어로 축약 가능git checkout -b develop# 이제 2개의 브랜치가 존재한다.git branch* masterdevelop 수정 작업 후 add, commit, push 자신이 사용하는 코드 편집 툴을 활용하여 수정 작업을 진행한다. 작업이 완료되면 add, commit, push를 통해서 자신의 github repository(origin)에 수정사항을 반영한다. 12345# add, commit 같이 수행git commit -a -m &quot;Modify code&quot;# pushgit push origin develop push 진행 시에 branch 이름을 명시해주어야 한다. 위의 명령어는 develop 브랜치의 수정 내역을 origin으로 푸시한다는 것이다. Pull Request 생성 push 완료 후 본인 계정의 github 저장소에 들어오면 Compare &amp; pull request 버튼이 활성화 되어 있다. 해당 버튼을 선택하여 메시지를 작성하고 PR을 생성한다.(날린다.) 코드 리뷰, Merge Pull Request PR을 받은 원본 저장소 관리자는 코드 변경 내역을 확인하고 Merge 여부를 결정하기 전에 Review를 남긴다. 팀의 정책에 따라 Review가 1개 이상이면 Merge를 하는 등의 조건이 있을 수 있다. Merge 이후 동기화 및 branch 삭제 원본 저장소에 Merge가 완료되면 로컬 코드와 원본 저장소의 코드를 동기화 한다. 작업하던 로컬의 branch를 삭제한다. 12345678# 코드 동기화git pull real-blog(remote 별명)## exgit pull upstream# 브랜치 삭제(develop 브랜치 삭제)git branch -d develop(브랜치 별명) 나중에 추가로 작업할 일이 있으면 git pull real-blog명령을 통해 원본 저장소와 동기화를 먼저 진행하고, 세번째부터 일곱번째 작업을 반복한다. 느낀 점 지금까지 내가 했던 방식이 Github-Flow 방법이라는 것을 알게 되었다. 원격 저장소를 자신의 개인 저장소로 fork 하는 방식으로 간단하게 사용할 수 있는 방법이다. 어제 공부했던 브랜치 전략은 Git-Flow로 브랜치를 나누어서 작업을 진행하는 것인데, 조금 더 복잡하다. 참고 git 초보를 위한 풀리퀘스트(pull request) 방법","categories":[{"name":"Git","slug":"Git","permalink":"https://woovictory.github.io/categories/Git/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://woovictory.github.io/tags/etc/"}]},{"title":"1일차 [Git] Git-Flow","slug":"Etc-Git-Flow","date":"2019-01-21T12:35:23.000Z","updated":"2020-05-12T11:31:19.984Z","comments":true,"path":"2019/01/21/Etc-Git-Flow/","link":"","permalink":"https://woovictory.github.io/2019/01/21/Etc-Git-Flow/","excerpt":"","text":"Git-Flow 전략에 대해서 알아볼 예정이다. 기존에 사용하던 방법은 이름을 몰랐고 그냥 프로젝트 팀원한테 배웠던 방식을 사용했다. 이름은 나중에 찾아보니 Github-Flow였다. Git-Flow를 알아보기 전에 Github-Flow가 무엇인지 알고 넘어가보자. Github-Flow 기본적으로 Git Repository를 살펴보면 Repository는 Upstream Repository(이하 Upstream Repository), Origin Remote Repository(이하 Origin Repository), Local Repository 이렇게 3가지 부분으로 구성된다. Upstream Repository : 개발자들이 공유하는 저장소로 최신 소스코드가 저장되어 있는 원격 저장소. Origin Repository : Upstream Repository를 Fork한 원격 개인 저장소. Local Repository : 내 컴퓨터에 저장되어 있는 개인 저장소. 위 그림은 Git Repository 구성과 워크플로우를 설명하고 있다. Local Repository에서 작업을 완료한 후 작업 브랜치를 Origin Repository에 push한다. 그리고 Github에서 Origin Repository에 push한 브랜치를 Upstream Repository로 merge하는 Pull Request를 생성하는 코드리뷰를 거친 후 merge 한다. 다시 새로운 작업을 할 때 Local Repository에서 Upstream Repository를 pull 한다. 이런 워크 플로우를 두는 데에는 한 가지 이유가 있다고 한다. 그 이유는 개발자들의 실험정신(?)을 펼치기 위해서이다. 모두가 공유하고 있는 Repository에서 실험하기에는 위험이 있다고 생각하고, Forked한 Repository를 두면 부담 없이 실험들을 해볼 수 있다고 한다. 무엇보다 이런 구조로 가져갔을 때 개발자가 해야 할 작업들이 중앙집중식 워크플로우보다 일이 늘거나 크게 복잡해지지도 않는다고 한다. Git-Flow Git-Flow를 사용했을 때 작업을 어떻게 하는지 살펴보기 전에 먼저 Git-Flow에 대해서 간단히 살펴보도록 하겠다. Git-Flow에는 5가지 종류의 브랜치가 존재한다. 항상 유지되는 메인 브랜치들(masger, develop)과 일정 기간 동안반 유지되는 보조 브랜치들(feature, release, hotfix)이 있다. master : 제품으로 출시될 수 있는 브랜치(배포하기 위함) develop : 다음 출시 버전을 개발하는 브랜치(이쪽으로 merge함) feature : 기능을 개발하는 브랜치(기능별로 feature를 나눔) release : 이번 출시 버전을 준비하는 브랜치 hotfix : 출시 버전에서 발생한 버그를 수정하는 브랜치 Git-flow 위 그림을 일반적인 개발 흐름으로 살펴보자. 처음에는 master와 develop 브랜치가 존재한다. 물론 develop 브랜치는 master에서부터 시작된 브랜치이다. develop 브랜치에서는 상시로 버그를 수정한 커밋들이 추가된다. 새로운 기능 추가 작업이 있는 경우 develop 브랜치에서 feature 브랜치를 생성한다. feature 브랜치는 언제나 develop 브랜치에서부터 시작하게 된다. 기능 추가 작업이 완료되었다면 feature 브랜치는 develop 브랜치로 merge 된다. develop에 이번 버전에 포함되는 모든 기능이 merge 되었다면 QA를 하기 위해 develop 브랜치에 수정된다. QA를 무사히 통과했다면 release 브랜치를 master와 develop 브랜치로 merge 한다. 마지막으로 출시된 master 브랜치에서 버전 태그를 추가한다. 그렇다면 우아한 형제들의 안드로이드 개발팀에서는 어떻게 Git-Flow를 지키는지 살펴보도록 하자. ##작업을 할 때 지켜야할 서로 간의 약속** 작업을 시작하기 전에 JIRA 티켓을 생성한다. 하나의 티켓은 되도록 하나의 커밋으로 한다. 커밋 그래프는 최대한 단순하게 가져간다. 서로 공유하는 브랜치의 커밋 그래프는 함부로 변경하지 않는다. 리뷰어에게 꼭 리뷰를 받는다. 자신의 Pull Request는 스스로 merge 한다. 우아한 형제들 Git-Flow 아래에는 우아한 형제들에서 실제로 어떻게 작업하는지 알아보겠다. 아래의 Repository와 Branch는 앞으로 설명을 할 때 나오기 때문에 알아두고 가면 한결 수월하게 볼 수 있을 것이다. Repositories upstream(Upstream Repository) : 중앙 원격 저장소 origin(Origin Repository) : 내 원격 저장소 Branches feature-user(사용자 관련 기능을 구현하는 feature branch) bfm-100_login_layout(사용자 관련 기능 중 레이아웃 작업 branch) 1.티켓 처리하기 앞서 '작업을 할 때 지켜야 할 서로 간의 약속’에서 **하나의 티켓은 되도록 하나의 커밋으로 한다.**라고 했다. 그래서 기능을 구혀하기 전에 여러 개의 티켓으로 작업을 먼저 나누게 된다. 나눠진 티켓 중 로그인 레이아웃 생성이라는 티켓이 있고 이 티켓을 처리한다고 가정하고 살펴보겠다. upstream/feature-user 브랜치에서 작업 브랜치(bfm-100_login_layout)를 생성한다. git checkout -b bfm-100_login_layout --track upstream/feature-user 작업 브랜치에서 소스코드를 수정한다. 작업 브랜치에서 변경 사항을 커밋한다. git commit -m &quot;BFM-100 로그인 화면 레이아웃 생성&quot; 만약 커밋이 불필요하게 여러 개로 나뉘어져 있다면 squash?를 한다.(커밋 2개를 합쳐야 한다면) git rebase -i HEAD~2 작업 브랜치를 upstrea/feature-user에 rebase 한다. 작업 브랜치를 origin에 push한다. Github에서 bfm-100_login_layout 브랜치를 feature-user 브랜치에 merge하는 Pull Request를 생성한다. 같은 feature를 개발하는 동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다. 만약 혼자 featur를 개발한다면 1~2명의 동료에게 리뷰 승인을 받은 후 Pull Request를 merge 한다. 위의 절차에서 4,5번 작업을 수행하는 이유는 커밋 그래프를 단순하게 가져가고 의미있는 커밋들로 관리하기 위함이다. 4번 작업을 예로 들면, ‘BFM-100 로그인 화면 레이아웃 생성’ 작업을 할 때 로그인 화면의 레이아웃을 생성한 커밋 하나와 view의 약간의 간격을 조정한 커밋 하나, 그리고 view의 id를 변경한 커밋하나, 이렇게 3개의 커밋으로 분리된 상태이다. 이 3개의 커밋이 그 의미를 나눌 필요가 없거나 코드 리뷰를 도와주지도 못한다면 커밋을 분리하는 것은 불필요하다고 판단하고 하나의 커밋으로 합치게 된다. 물론 항상 하나의 커밋으로 합쳐야만하는 것은 아니다. 하나의 티켓에 대한 작업이라도 커밋이 분리되어 있는게 낫다고 생각이 든다면 2개 이상의 커밋으로 나눌 수도 있다. 그러나 대부분은 티켓을 더 작게 나누지 못한 경우일 가능성이 높다. 2. develop 변경사항을 feature로 가져오기(Optional) 작업을 할 때 브랜치의 수명은 되도록 짧게 가져가는게 좋지만, feature 브랜치에서 기능을 완료하는데 해야 할 작업들이 많아서 오래 걸리는 경우들이 있다. 그러다 보면 develop에 추가된 기능들이 필요한 경우가 종종 생기게 된다. 그럴 때는 feature 브랜치에 develop의 변경사항들을 가져와야 한다. feature-user 브랜치에 upstream/develop 브랜치를 merge 한다. upstream/develop의 변경사항이 merge된 feature-user를 upstream에 push 한다. 3. 완료된 기능을 이번 출시 버전에 포함시키기 드디어 feature-user 브랜치에서 작업하던 기능이 완료되었다. 이젠 feature 브랜치를 이번 출시 버전에 포함시키기 위해서 develop에 merge해야 한다. develop 브랜치에 upstream/feature-user 브랜치를 merge 한다. upstream/feature-user 기능이 merge된 develop를 upstream에 push 한다. 4. QA 시작하기 이번 버전에 포함되어야 할 기능들이 모두 완료되었다. 이제부터 출시 담당자가 해야 할 일이 많다. 출시 담당자는 QA를 시작하기 위해 먼저 release 브랜치를 develop 브랜치로부터 따서 생성하고 upstream에 push하여 release 브랜치를 공유한다. release-1.0.0 브랜치를 생성한다. release-1.0.0 브랜치를 upstream에 push 한다. 5. QA 중 버그 수정하기 개발을 완료한 후 QA 중 버그가 발생하지 않으면 좋겠지만 항상 생각치 못한 예외 상황들이 발생하게 된다. 예외 상황이 발생할 때마다 버그 티켓이 하나씩 생성되는데 이 티켓들을 모두 해결해야만 앱을 출시할 수 있다. 버그 티켓들도 티켓이기 때문에 '1. 티켓 처리하기’와 같은 방법으로 처리한다. release 브랜치에서 버그 티켓에 대한 브랜치를 생성한다. 버그를 수정한다. 버그 티켓에 대해 생성한 브랜치를 작업 브랜치라 하고 작업 브랜치에서 버그 수정 사항을 커밋한다. 작업 브랜치를 origin[ develop? ]에 push 한다. Github에서 bfm-101_bug_login_id_max_length 브랜치를 release-1.0.0에 merge 하는 Pull Request를 생성한다. 동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다. 6. 앱출시 발생하는 버그들을 모두 수정했다면 이젠 출시를 준비할 때이다. release 브랜치를 master 브랜치와 develop 브랜치에 merge하고 마지막으로 master 브랜치에서 버전 태그를 달아준다. release 브랜치를 최신 상태로 갱신한다. release 브랜치를 develop 브랜치에 merge 한다. develop 브랜치를 upstream에 push 한다. release 브랜치를 master 브랜치에 merge 한다. 1.0.0 태그를 추가한다. master 브랜치와 1.0.0 태그를 upstream에 push 한다. 중앙집중식 워크플로우 중앙집중식에서 개발자 두 명이 중앙저장소를 clone하고 각자 수정하는 상황을 생각해보자. 한 개발자가 자신이 한 일을 커밋하고 나서 아무 문제 없이 서버에 push한다. 그러면 다른 개발자는 자신의 일을 커밋하고 push 하기 전에 첫 번째 개발자가 한 일을 먼저 Merge 해야 한다. Merge를 해야 첫 번째 개발자가 작업한 내용을 덮어쓰지 않는다. 이런 개념은 Subversion과 같은 중앙집중식 버전 관리 시스템에서 사용하는 방식이고 Git에서도 당연히 이런 워크플로우를 사용할 수 있다. 팀이 작거나 이미 중앙집중식에 적응한 상황이라면 이 워크플로우에 따라 git을 도입하여 사용할 수 있다. 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다. A와 B가 동시에 같은 부분을 수정하는 상황을 생각해보자. A가 먼저 작업을 끝내고 수정한 내용을 서버로 push한다. B도 마찬가지로 작업을 끝내고 수정한 내용을 서버로 push 하려 하지만 서버가 바로 받아주지 않는다. 서버에는 A가 수정한 내용이 추가되었기 때문에 push 하기 전에 Fetch로 받아서 Merge 한 후 Push 할 수 있다 이런 개념을 개발자에게 익숙해서 거부감 없이 도입할 수 있다. 참고 우린 Git-flow를 사용하고 있어요 회고 Github-flow가 편하다는 생각이 아직 사라지지 않는다. 왜냐하면 git-flow는 브랜치가 많고 git의 명령어들이 많이 나와서 헷갈리는 부분이 너무 많다. 하지만 여러 사람이 협업할 때 브랜치를 기능별로 나눠서 하게 되기 때문에 효율이 좋은 것 같다. 아직 헷갈리는 부분이 많아서 자료를 조금 더 참고해서 공부해야겠다.","categories":[{"name":"Git","slug":"Git","permalink":"https://woovictory.github.io/categories/Git/"}],"tags":[{"name":"etc","slug":"etc","permalink":"https://woovictory.github.io/tags/etc/"}]},{"title":"[안드로이드] MVP 따라하기 11","slug":"Android-MVP-Step11","date":"2019-01-19T08:30:01.000Z","updated":"2020-05-26T07:05:19.115Z","comments":true,"path":"2019/01/19/Android-MVP-Step11/","link":"","permalink":"https://woovictory.github.io/2019/01/19/Android-MVP-Step11/","excerpt":"","text":"Repository Repository 정의는 Memory cache를 할 수 있으며, Remote/Local 데이터를 불러오게 된다. SQLite 사용 시에는 Loaders 사용으로 비동기식 데이터를 쉽게 로드할 수 있는 방법을 사용하고, RxJava 등의 방법을 사용할 수 있다. [이 경우는 이번 글에서 다루지 않는다.] 변경할 Repository 형태는 구글이 설명하는 다음의 방법이다. 배운 점 Model을 생성해서 Presenter에서 Repository에 데이터를 요청하고 Repository는 Remote / Local DataSource로부터 데이터를 받아서 Repository에게 넘기고 받은 것을 다시 Presenter에 넘겨서 처리하고 있다. MVP를 처음 배울 때는 '별 거 아니네’라고 생각했다. 하지만, 리싸이클러뷰가 들어있는 하나의 화면을 작성하는데 파일은 많아지고 인터페이스 선언도 많아진다. 그러면서 상속을 받고 이곳 저곳을 왔다 갔다 한다. 너무 복잡스럽다고 생각했지만, 프로젝트의 규모가 조금 커지면 유지 보수에 훨씬 쉬울 것이라는 생각이 들었다. 인터페이스 부분만 수정하고 이를 구현하는 함수만 수정하면 되기 때문이다. 그렇지만 아직 테스트 코드에 용이하다는 것은 직접 해보지 않아서 잘 모르겠다. 부캠하면서 배운다면 조금 더 알 수 있지 않을까 하는 기대를 걸어본다. 참고 Android MVP 무작정 따라하기 - Google Architecture Model(영상 포함)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 10","slug":"Android-MVP-Step10","date":"2019-01-19T05:11:31.000Z","updated":"2020-03-01T10:25:39.925Z","comments":true,"path":"2019/01/19/Android-MVP-Step10/","link":"","permalink":"https://woovictory.github.io/2019/01/19/Android-MVP-Step10/","excerpt":"","text":"구글 Architecture에서 설명하는 모델 정의를 살펴보려고 한다. 가장 기본적인 Model 정의 Clean 코드를 위한 정의 위와 같이 구분할 수 있는데 기본적인 Model을 정의해야 Clean 코드도 적용해 볼 수 있다. 그래서 이번에 Google Architecture의 가장 기본적인 Model 정의를 살펴보겠다. Model 구글에서 설명하는 Model은 ios viper라는 개념과 동일하다고 생각하면 될 것 같다. 원래는 Google Architecture clean 코드까지 viper 적용이라고 보이지만 viper와 유사한 형태이다. Interactor에서 Google Repository 역할을 처리하게 된다. 비슷하지만 용어도 다르고, 실제 구성이 다르다… Google Architecture Model 구글에서 설명하고 있는 Model 정의는 아래와 같다. Repository : 로컬/서버 중 어떤 데이터를 불러올지 정의하고, 메모리 캐시를 포함한다. Remote data source : 서버에서 데이터를 받아온다. Local data source : 로컬에서 데이터를 받아온다. 가장 기본적으로는 위와 같다. 로컬/서버에서 받아오는 데이터는 Repository에서 캐시 처리할 수 있다. 필요에 따라서 캐리를 하고, 이를 Presenter에 다시 콜백을 해주게 된다. RxJava로 구성을 하면 async / await 형태로 만들어지므로 return Observable/Flowable의 형태가 만들어질 수 있다고 한다… [RxJava는 잘 모르는 내용이다.] 그래서 가장 basic MVP는 아래의 그림을 가진다. 여기에서 Repository가 왼쪽과 같이 표현될 수 있다. Presenter와 Repository 사이의 데이터를 가공할 수 있는 Loader가 추가될 수도 있고, Clean 코드를 위한 Domain Layout이 포함될 수도 있다. 이런 Loader와 Domain Layout 정의는 Clean 코드를 위한 정의이다. 필요할 경우 추가하여 사용이 가능하다. TODO MVP 모델의 정의는 다음과 같은 형태로 생성된다. Presenter 생성하는 위치에서 Repositroy 생성 Presenter에서 Model(Repository) 포함(setter) Presenter에서 Model(Repository) 호출 Model(Repository)는 Remote/Local의 데이터를 선택하고 이를 캐시 데이터 호출이 완료되면 Loader 또는 Presenter에서 세팅한 Listener에 값을 전달 추가로 Loader의 정의는 아래와 같다. Repository interface 정의 LoadImageCallback을 통해서 성공했을 대와 오류 났을 때를 구분하여 Listener을 추가한다. RxJava를 사용할 때는 다음이 필요하지 않다. 12345678910public interface ImageSource&#123; interface LoadImageCallback&#123; void onImageLoaded(List&lt;PhotoItem&gt; photoItem); void onDataNotAvailable(); void onLoadFai(int code, String message); &#125; void getImageItems(int page, LoadImageCallback loadImageCallback);&#125; ImageSource를 상속받아서 Repository의 Remote/Local DataSource 구분을 하면 된다. Repository Repository은 싱글톤을 통해서 생성하면 된다. 생성자를 통해 Remote/Local DataSource 생성을 하여 사용할 수 있다. kotlin에서는 object class 생성을 통해 처리할 수 있다. 12345678910111213141516171819public class ImageRepository implements ImageSource&#123; private ImageRemoteDataSource imageRemoteDataSource; public static ImageRepository getInstance()&#123; return LazyHolder.imageSampleRepository; &#125; private ImageRepository()&#123; imageRemoteDataSource = ImageRemoteDataSource.getInstance(); &#125; private static class LazyHolder&#123; private static final ImageRepository imageSampleRepository = new ImageRepository; &#125;&#125; Remote/Local DataSource 서버/로컬 데이터 소스를 정의할 수 있다. 여기에서는 Local SQLite/Realm DB를 사용하여 구성할 수 있고, Retrofit을 사용하여 서버 데이터를 불러올 수 이다. 역시 DataSource interface 상속을 통해서 정리하면 된다. 1234567891011121314151617181920212223public class ImageRemoteDataSource implements ImageSource &#123; private static ImageRemoteDataSource INSTANCE; private final FlickrService flickrService; private ImageRemoteDataSource() &#123; flickrService = RetrofitCreator.createRetrofit().create(FlickrService.class); &#125; public static ImageRemoteDataSource getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new ImageRemoteDataSource(); &#125; return INSTANCE; &#125; @Override public void getImageItems(int page, final LoadImageCallback loadImageCallback) &#123; // 생략 &#125;&#125; 참고 Android MVP 무작정 따라하기 - Google Architecture의 Model","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 9","slug":"Android-MVP-Step9","date":"2019-01-19T04:40:29.000Z","updated":"2020-03-01T10:25:37.429Z","comments":true,"path":"2019/01/19/Android-MVP-Step9/","link":"","permalink":"https://woovictory.github.io/2019/01/19/Android-MVP-Step9/","excerpt":"","text":"이번에는 MVP 패턴에서 사용할 수 있는 다양한 Model을 살펴보겠다. Model이란? Model은 Data를 말한다. 단순 데이터가 아닌 데이터를 관리/수집/수정 등을 하게 되는 부분이다. 데이터를 Cache해야 한다면 이 모델에서 Cache 할 수도 있고, 그냥 단순 데이터 전달만 할 수도 있다. Google Architecture의 Model Google Architecture는 아래와 같은 그림으로 설명할 수 있다. 각각의 역할은 아래와 같다. Respositroy : Remote/Local을 구분하며, Memory cache를 포함 Remote : 서버를 통한 데이터를 불러온다. Local : 단말기 상의 SQL, Realm 등을 통한 데이터를 불러온다. 구현한 모델은? 현재까지 MVP에서 정의한 모델은 단순 리턴을 하며, Model만 구분을 해두었다. 싱글톤을 통해서 데이터 클래스에 접근하도록 만들었다. 데이터 형태에 따서 여러 개가 만들어질 수도, 단일 클래스로 생성될 수도 있다. 1234567891011121314151617public class SampleImageData &#123; private SampleImageData() &#123;&#125; private static SampleImageData sampleImageData; public static SampleImageData getInstance() &#123; if (sampleImageData == null) &#123; sampleImageData = new SampleImageData(); &#125; return sampleImageData; &#125; public ArrayList&lt;ImageItem&gt; getImages(Context context, int size) &#123; ArrayList&lt;ImageItem&gt; items = new ArrayList&lt;&gt;(); // 생략 return items; &#125;&#125; 위와 같이 자바로 하나의 클래스에 싱글톤으로 만들 수 있다. 가장 기본적인 형태의 모델이다. 코틀린으로 작성할 경우 Object로 작성하면 된다. Presenter에서는 위에서 작성한 모델은 Presenter에서 세팅하는 주체는 View이다. Presenter 초기화하는 대상이 View이기 때문에 View를 초기화함과 동시에 Model을 초기화하게 된다. 123456presenter = MainPresenter().apply &#123; view = this@MainActivity imageData = ImageData adapterModel = imageAdapter adapterView = imageAdapter&#125; 위와 같이 초기화를 진행하고, Presenter에서 다음과 같이 사용하게 된다. getItems()를 토애서 데이터를 불러오고 이를 사용하게 된다. 123456789@Overridepublic void loadItems(Context context, boolean isClear) &#123; ArrayList&lt;ImageItem&gt; items = sampleImageData.getImages(context, 10); if (isClear) &#123; adapterModel.clearItem(); &#125; adapterModel.addItems(items); adapterView.notifyAdapter();&#125; 참고 Android MVP 무작정 따라하기 - Model 정의하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 8","slug":"Android-MVP-Step8","date":"2019-01-18T11:58:46.000Z","updated":"2020-03-01T10:25:35.238Z","comments":true,"path":"2019/01/18/Android-MVP-Step8/","link":"","permalink":"https://woovictory.github.io/2019/01/18/Android-MVP-Step8/","excerpt":"","text":"이번에는 8번째 시간이다. ㅎㅎ 지난번에 태환님의 동영상 강의를 보면서 AdapterContract 정의를 했고, 이어서 OnClickListener 정의를 해보려고 한다. AdapterContract View - OnClickListener 정의 OnClickListener 정의는 AdapterContract View에 추가 정의를 통해 간단하게 구현할 수 있다. 기존에 AdapterContact.View에는 다음과 같이 정의했다. 1234567interface ImageAdapterContract &#123; interface View&#123; fun notifyAdapter() &#125;&#125; 여기에 setOnClickListener(OnClickListener listener) 정의를 추가함으로써 Presenter에서 바로 Adapter의 OnClickListener 이벤트를 전달받고, 이를 처리할 수 있게 된다. 이유는 간단하다. AdapterModel / AdapterView를 Presenter에서 들고 있기 때문에 굳이 View에서 이런 이벤트를 받을 필요는 없다. 역시나 귀찮은 부분이 따르므로 아래이 그림과 같이 추가될 수 있다. AdapterContract View를 통해서 초기화하는 이유는?? AdapterContract.View에서 OnClick을 초기화하고, 이를 ViewHolder에서 정의하는 이유는 다음과 같다. 이미 Presenter에서 AdapterView/AdapterModel을 알고 있다. 실제 View/Model을 한 번에 가지고 있는 Adapter이기 때문에 이를 굳이 View에서 처리할 필요는 없다. 위와 같은 이유로 다시 View에서 setOnClickListener을 하고 이 이벤트를 받아서 Presenter에 넘겨서 처리를 하는 것보다는 바로 Presenter가 받아서 이를 처리하고, View 이벤트를 분리하는게 편리하기 때문이라고 한다. 그래서 이 방법은 배워보도록 하겠다. 해당 View에서도 onClick 처리를 할 수 있지만, Presenter에서 onClick을 들고 있기 때문에 Presenter에서 다양한 이벤트 처리를 바로 할 수 있기 때문에 한 단계 줄여서 바로 Presenter setOnClickListener를 만들어주고 그걸 Adapter에 등록을 시켜주면 onClick이 발생을 했을 때, 이외 처리가 좀 더 간단하게 만들어질 수 있다. 배운 점 Presenter가 View, adapterView, adapterModel을 가지고 있고, context도 보유하고 있으므로 여기서 onClick을 처리할 수 있는 것이다. 굳이 View에서 처리하지 않아도 된다는 뜻인 셈이다. ImageAdapterContract.View에 var onClickFunc : ((Int) -&gt; Unit)? 을 선언해준다. 이는 코틀린의 특성 중 하나로 변수에 바로 사용할 함수를 담는 것이다. 이렇게 하면 Adapter는 ImageAdapterContract.View를 구현하기 때문에 Adapter에서는 onClickFunc 변수를 오버라이드 한다. 그리고 onBindViewHolder의 역할을 ImageViewHolder의 onBind에서 처리하고 있으므로 onClick에 대한 이벤트 처리도 ImageViewHolder에 위임하여 처리를 넘겨준다. [이 부분도 어댑터에서 진행하는 부분이다.] 12345678910fun onBind(item: ImageItem, position: Int)&#123; ImageAsync(context,imageView).execute(item.resource) textView.text = item.title itemView.setOnClickListener &#123; onClickFunc?.invoke(position) // int를 변수로 넘겨줘야 하기 때문에 // null이 아닌 경우를 체크하고 int인 position을 넘겨준다. &#125; &#125; 그러면 itemView에 대한 클릭이 발생했을 때, onClickFunc은 null이 아닌 경우를 체크하고 position을 넘겨준다. 넘어간 position은 아래와 같은 코드를 통해서 받는다. 12345678910111213141516 override var adapterView: ImageAdapterContract.View? = null set(value) &#123; field = value // 아래 부분 중요 field?.onClickFunc = &#123; onClickListener(it)&#125; // 위와 같이 지정을 해주면 onClick이 발생하면 아래의 함수가 동작한다. &#125;// onClick시 아래 함수 동작 private fun onClickListener(position: Int)&#123; adapterModel.getItems(position).let &#123; view.showToast(it.title) &#125; &#125; set block 안에서 position을 it으로 받아서 onClickListener 함수를 호출한다. onClickListener는 다시 adapterModel에게 getItem을 요청한다. 1override fun getItems(position: Int): ImageItem = imageList[position] 위와 같은 로직으로 Adapter에서 onClick 이벤트를 처리할 수 있다. 조금 복잡하지만, 익숙해진다면 로직을 분리할 수 있는 장점과 결합도를 낮출 수 있을 것 같다. 참고 Android MVP 무작정 따라하기 - Adapter OnClick 정의하기(동영상)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 7","slug":"Android-MVP-Step7","date":"2019-01-18T09:05:31.000Z","updated":"2020-03-01T10:25:31.973Z","comments":true,"path":"2019/01/18/Android-MVP-Step7/","link":"","permalink":"https://woovictory.github.io/2019/01/18/Android-MVP-Step7/","excerpt":"","text":"다음을 정리 이전 영상을 보면서 배웠던 내용은 View -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; View -&gt; Adapter을 정의하였다. 오늘은 아래 그림과 같이 View -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; Adapter View/Model을 바로 갱신하게 된다. 그래서 Activity/Fragment의 View를 한 단계 더 분리하고, 이를 좀 더 편하게 관리하기 위함이다. 생각해보기 MVP를 공부하면서 이번에는 AdapterContract를 분리해서 그 안에 View와 Model을 만들었다. 이렇게 함으로써 View를 거쳐서 Adapter에 접근해야 하는 과정을 줄이고 Presenter에서 Adapter로 바로 update하거나 notify 하도록 함으로써 결합도를 낮출 수 있었다. 하지만 내가 아직 이해가 잘 되지 않는 부분이 있다. 123456789101112131415161718private lateinit var presenter : MainPresenterprivate lateinit var imageAdapter : ImageAdapteroverride fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) toolbar.setOnClickListener(this) imageAdapter = ImageAdapter(this) recycler_view.adapter = imageAdapter presenter = MainPresenter().apply &#123; view = this@MainActivity imageData = SampleImageData adapterModel = imageAdapter adapterView = imageAdapter &#125; 이 부분은 View에서 Presenter를 사용하는 부분이다. View에서 데이터를 Presenter에게 요청하기 위함이다. 여기서 adapterModel = imageAdapter 이 부분이 나한테는 관건이었다. 분명 adapterModel은 MainPresenter에 정의되어 있고 타입은 ImageAdapterContract.View이다. 그런데 imageAdapter를 대입함으로써 초기화를 진행하고 있다. 깊게 생각해보고 구조를 손으로 그려보니 이해가 갔다. ImageAdapter는 ImageAdapterContract.View, ImageAdapterContract.Model을 상속 받고 있다. 즉, ImageAdapterContract가 부모 또는 상위가 되는 것이고 그를 상속받는 ImageAdapter는 자식 또는 서브가 되는 것이다. 그래서 자식은 상속을 통해서 부모의 메소드를 사용할 수 있는 것처럼 부모 객체에 자식 객체를 대입함으로써 자식 객체의 메소드에 접근할 수 있는 것이라고 생각을 했다. 혹시나 나의 생각이 잘못되었다면 메일이나 댓글을 부탁한다. 참고 Android MVP 무작정 따라하기 - Adapter Contract 정의하기 2번째(동영상)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 6","slug":"Android-MVP-Step6","date":"2019-01-18T03:05:53.000Z","updated":"2020-03-01T10:25:28.273Z","comments":true,"path":"2019/01/18/Android-MVP-Step6/","link":"","permalink":"https://woovictory.github.io/2019/01/18/Android-MVP-Step6/","excerpt":"","text":"이번에는 Adapter에 대한 Contract 정의하는 방법을 살펴보려 한다. 여기서는 Adapter에 대한 Contract를 정의하고 이를 상속받아서 사용하는 방법을 정리해보겠다. Adapter Contract 정의란? 이전 글에서 Activity/Fragment에서 사용할 Contract을 정의하고, 분리해보았다. 하지만 아래와 같이 처리한다. 복잡해보이지만 정리하면 아래와 같다. View : Presenter에게 데이터를 요청 Presenter : Model에게 데이터를 요청 Model : 데이터를 Presenter로 전달 Presenter : Model로부터 전달받은 데이터를 View에게 전달 View : View에서 가지고 있던 Adapter에게 데이터를 추가하고, notify를 처리 Presenter에서 직접 data를 전달하지 않으면? MVP 방식을 분리만 하면 위에서 설명한 그림과 같이 동작한다. 그럼 단점은 무엇일까?? 단점 Presenter에서 Adapter의 데이터를 저장하고 불러오는 모든 부분에 항상 View가 함께 해야 한다. Presenter에서 Adapter에 데이터를 세팅하는 경우 View에서 이를 전달받아 Adapter에 저장 사용자의 onClick 시에 필요한 데이터를 Adapter로부터 전달받아야 하므로 필요한 함수(getItem)가 만들어져야 한다. 위와 같은 상황이 아니더라도 모두 View에서 이를 대신 받아서 전달해야 한다. 그럼 복잡도를 낮추려는 목적이 사라짐과 동시에 복잡도가 높아지고 귀찮아진다. 그래서 좀 더 좋은 방법은?? 좀 더 좋은 방법은 GDE 스티브님의 글에서 소개된 방법이다. 이 글은 아래에 참고 링크를 걸어두었으니 나중에 확인해보자! 다음과 같이 Adapter에 대한 Contract를 다시 생성해준다. 123456789interface AdapterContract&#123; interface View&#123; &#125; interface Model&#123; &#125;&#125; Contract을 Adapter에 상속받아 구현 View/Model을 구분해서 Contract을 생성하였으니, Adapter에서 이를 상속받아서 구현해준다. 123class SampleAdapter : RecyclerView.Adapter(), AdapterContract.View, AdapterContract.Model&#123; // 생략&#125; Presenter에서는? Presenter에서는 AdapterContract.View와 AdapterContract.Model을 구현한다. 123456789101112class SamplePresenter implements SampleContract.Presenter&#123; private AdapterContract.View adapterView; private AdapterContract.Model adapterModel; public void setAdapterView(AdapterContact.View adapterView)&#123; this.adapterView = adapterView &#125; public void setAdapterModel(AdapterContract.Model adapterModel)&#123; this.adapterModel = adapterModel &#125;&#125; 이렇게 구현해주면 이후에는 adapterVie/adapterModel을 통해서 직접 Adapter를 접근하게 된다. 기존에서와 같이 View를 통해서 접근할 필요성이 없어진다. 그래서 다시 그리면 아래와 같다. 참고 Android MVP 무작정 따라하기 - Adapter Contract 정의하기 Adapter, 누구냐 넌? — Data? View?","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 5","slug":"Android-MVP-Step5","date":"2019-01-17T00:32:11.000Z","updated":"2020-03-01T10:25:25.437Z","comments":true,"path":"2019/01/17/Android-MVP-Step5/","link":"","permalink":"https://woovictory.github.io/2019/01/17/Android-MVP-Step5/","excerpt":"","text":"이번에는 참고하는 블로그의 태환님께서 영상 올리신걸 참고하여 Presenter를 분리하는 방법을 배웠다. 이를 기반으로 코틀린 주요 코드를 작성했지만, 현재(2019.01.30) 자바를 이용해 프로젝트를 진행하고 있고, MVP를 적용해야 하기 때문에 한 번 더 공부를 해서 주요 코드를 작성하고자 한다. Java의 주요 코드 MainContractor 정의 MainContractor는 View와 Presenter에 대한 인터페이스를 정의한다. 이해하는데 용이하게 하기 위한 용도이다. View 인터페이스에는 Presenter로부터 가공된 데이터를 받고 UI를 갱신하는 로직이 필요하다. Presenter 인터페이스에는 View로부터 이벤트를 받고 데이터를 가공하는 로직이 필요하다. 그리고 View로 데이터를 넘겨줘야 한다. 123456789101112131415161718public interface MainContractor&#123; interface View&#123; void addItems(ArrayList&lt;ImageItem&gt; list, Boolean isClear); void notifyAdapter(); &#125; interface Presenter&#123; void attachView(View view); void detachView(); void setSampleImageData(SampleImageData data); void loadItems(Context context, Boolean isClear); &#125;&#125; MainPresenter 주요 코드 Presenter는 View를 들고 있는다. View에게 가공된 데이터를 넘기기 위해서 View를 들고 있는 것이다. 또한, 여기서는 데이터를 세팅하는 과정까지 포함하고 있다. 12345678910111213141516private MainContractor.View view;private SampleImageData sampleImageData;@Overridepublic void attachView(MainContractor.View view)&#123; this.view = view;&#125;@Overridpublic void detachView()&#123; view = null;&#125;@Overridepublic void setSampleImageData(SampleImageData sampleImageData) &#123; this.sampleImageData = sampleImageData;&#125; MainPresenter의 loadItems 코드 그리고 loadItems는 View에서 Presenter의 loadItems 함수를 호출한다. 그러면 Presenter에서는 이미지 데이터를 가져와서 view의 addItems와 notifyAdapter 함수를 호출함으로써 View에게 update된 데이터를 넘겨준다. 123456@Override public void loadItems(Context context, Boolean isClear) &#123; ArrayList&lt;ImageItem&gt; imageItemList = sampleImageData.getSampleList(context, 10); view.addItems(imageItemList, isClear); view.notifyAdapter(); &#125; MainActivity 주요 코드 MainActivity에서는 Presenter를 들고 있다. 그리고 Presenter의 loadItems 함수를 호출한다. 그러면 Presenter에서는 데이터를 가공하고 View에게 전달하는 로직을 가지고 있다. 아래는 loadItems()를 호출하는 부분이다. 123456mMainPresenter = new MainPresenter();mMainPresenter.attachView(MainActivity.this);mMainPresenter.setSampleImageData(SampleImageData.getInstance());mMainPresenter.loadItems(this, false); UI 갱신을 위한 주요 코드 UI 갱신을 위한 부분은 addItems()와 notifyAdapter() 부분이다. 이 함수는 결국 Presenter에 loadItems()를 호출하고 Presenter가 View에게 데이터를 전달하고 View에서 UI 갱신이 일어나는 과정이다. 123456789101112@Overridepublic void addItems(ArrayList&lt;ImageItem&gt; items, boolean isClear) &#123; if (isClear) &#123; imageAdapter.clear(); &#125; imageAdapter.setImageItems(items);&#125;@Overridepublic void notifyAdapter() &#123; imageAdapter.notifyDataSetChanged();&#125; Kotlin의 주요 코드 MainContract 정의 Kotlin에서 사용 가능한 interface 정의를 다음과 같이 한다. var view, var ImageData를 정의한다. 12345678910111213141516interface MainContract&#123; interface View&#123; // View의 UI 갱신을 위한 메소드 fun updateItems(items : ArrayList&lt;ImageItem&gt;, isClear : Boolean) fun notifyAdapter() &#125; interface Presenter&#123; var view : view var imageDat : SampleImageData // Model에 접근하기 위한 메소드 fun loadItems(context : Context, isClear : Boolean) &#125;&#125; MainPresenter 정의 그리고 lateinit을 통해서 변수를 선언한다. 자바에서는 이때 setView/getView가 자동으로 생성된다. 12lateinit override var view: MainContract.Viewlateinit override var imageData: ImageData 그리고 loadItems을 아래와 같이 생성한다. updateItems와 notifyAdapter을 각각 호출해주어서 UI를 갱신한다. 123456override fun loadItems(context: Context, isClear: Boolean) &#123; imageData.getSampleList(context, 10).let &#123; view.updateItems(it, isClear) view.notifyAdapter() &#125;&#125; MainActivity 정의 1234567891011privaet lateinit var presenter : MainPresenteroverride fun onCreate(savedInstancesState: Bundle?)&#123; presenter = MainPresenter().apply&#123; view = this@MainActivity imageData = SampleImageData &#125; presenter.loadItems(context, false)&#125; 그리고 presenter로부터 View에 대한 콜백을 다음과 같이 처리한다. 123456789101112override fun updateItems(items: ArrayList&lt;ImageItem&gt;, isClear: Boolean) &#123; imageAdapter?.apply &#123; if (isClear) &#123; imageList?.clear() &#125; imageList = items &#125;&#125;override fun notifyAdapter() &#123; imageAdapter?.notifyDataSetChanged()&#125; 느낀점 MVP로 나아가기 위해서 조금씩 걸어가고 있다. 하지만 아직 어려운 건 사실이다. 익숙해지기 위해서는 더 많이 코드를 짜보고 생각을 해봐야 할 것 같다. MVC가 보기에는 편하다. 몇 줄 적지 않았던 코드는 길게 늘어났고, 클래스도 많아졌다. 아직 MVP라고 하기엔 거리가 멀지만 단순히 생각해보면 Activity에서 Model을 분리했다?? 라는데 아니라고 보일지도 모른다. 그래도 최소한 View/Model 간의 결합도를 낮출 수 있고, View/Model에 대한 테스트도 가능하다. 참고 Android MVP 무작정 따라하기 - Presenter 분리하기(동영상)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 4","slug":"Android-MVP-Step4","date":"2019-01-16T13:36:24.000Z","updated":"2020-03-01T10:25:21.989Z","comments":true,"path":"2019/01/16/Android-MVP-Step4/","link":"","permalink":"https://woovictory.github.io/2019/01/16/Android-MVP-Step4/","excerpt":"","text":"이번에는 MVP 따라하기 4번째 시간이다. 저번 글에서 Android MVP 적용하는 방법 중 구글에서 추천하는 Presenter / View 인터페이스를 Contract 인터페이스에 선언해서 사용하는 방법을 다루었다. 이번에는 Presenter/PresenterImpl을 구현하는 방법을 살펴보려고 한다. Presenter interface 구현하기 전에 이전 글에서는 구글에서 추천하는 방법인 Contract을 통해서 interface을 구현하는 방법을 살펴보았고, 구글의 MVP 패턴 적용하는 방법을 살펴보았다. 여기서는 많이 사용되는 2번째 방법을 소개하려 한다. Presenter : interface로 구현하며, View를 포함 PresenterImpl : Presenter interface를 상속받아서 구현 이번 글에서도 기존과 같은 방식으로 접근하지만 interface 생성하는 방법을 달리하였다. Present interface 구현 구글은 Contract을 통해서 View/Presenter의 interface 2개를 작성하였지만, 다음의 방법은 Presenter에 View interface만을 작성하였다. 그래서 구현하면 아래와 같다. 12345678910interface SamplePresenter&#123; // Presenter 구현 void loadItem(); interface View&#123; // 해당 Presenter에서 사용할 View 구현 void updateView(List&lt;Items&gt; items); &#125;&#125; PresenterImpl 구현 다음과 같이 implements를 통해서 상속받고, 이를 아래와 같이 구현한다. 다만 이름은 implements의 구현체의 이름으로 Impl을 사용한다. 123456789class SamplePresenterImpl(val view : SamplePresenter.View) : SamplePresenter&#123; // 상속받은 interface 구현 override fun loadItem()&#123; // ... val list = ArrayList&lt;String&gt;() view.updateView(lise) &#125;&#125; View 구현 SamplePresenter인 SamplePresenterImpl을 초기화하여 사용한다. 사용법은 Contract을 통한 생성과 동일하다. 12345678910111213141516171819class SampleActivity extends AppCompatActivity implements SamplePresenter.View &#123; private SamplePresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); presenter = new SamplePresenterImpl(this); presenter.loadItem(); &#125; @Override public void updateView(List&lt;Items&gt; items) &#123; // UI 갱신 &#125;&#125; Presenter interface가 없는 경우 추가로 Presenter interface을 사용하지 않는 경우이다. Presenter에 대한 interface을 사용하지 않기 때문에 View에 대한 interface만을 정의한다. 123interface SampleView&#123; fun updateView(var items : List&lt;Items&gt;)&#125; 그리고 다음과 같이 Presenter를 구현한다. 12345678class SamplePresenter(val view : SampleView)&#123; fun loadItem()&#123; // ... val list = ArrayList&lt;String&gt;() view.updateView(list) &#125;&#125; 그리고 다음과 같이 View의 사용이 가능하게 된다. 123456789101112131415class SampleActivity : AppCompatActivity, SampleView&#123; private var presenter : SamplePresenter override fun onCreate(var savedInstanceState : Bundle)&#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) presenter = SamplePresenter(this) presenter.loadItem() &#125; override fun updateView(var items : List&lt;Items&gt;)&#123; // UI 갱신 &#125;&#125; 참고 Android MVP 무작정 따라하기 - Presenter/View 생성하기 Other","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 3","slug":"Android-MVP-Step3","date":"2019-01-16T11:34:22.000Z","updated":"2020-03-01T10:25:19.262Z","comments":true,"path":"2019/01/16/Android-MVP-Step3/","link":"","permalink":"https://woovictory.github.io/2019/01/16/Android-MVP-Step3/","excerpt":"","text":"이번에는 Presenter와 View를 나누는 방법에 대해서 정리해보겠다. Presenter의 정의는? View : Presenter에서 전달받은 View의 이벤트이다. Presenter : View에서 전달된 이벤트에 대한 처리를 한다.(View와 무관한 처리만 한다.) Presenter를 구분하는 방법들 View에 대한 interface만 정의하는 방법 interface View : View에 대한 interface만 정의 Presenter : interface 정의 없이 함수를 생성하여 사용 View : interface View를 상속받아서 정의 Google architecture를 따른다. Contract : View와 Presenter에 대한 interface을 작성 Presenter : Contract.Presenter을 상속받아서 구현 View : Contract.View을 상속받아서 구현 PresenterImpl을 구현 Presenter : Presenter와 View에 대한 interface을 구현 PresenterImpl : Presenter을 상속받아서 구현 View : Presenter.View을 상속받아서 구현 위와 같이 구현하는 방법은 크게 3가지 정도로 나뉠 수 있다. 정답은 없고 편한 방법과 다른 사람과 공유했을 때의 장/단점을 따져서 작성하면 좋겠다. interface 정의시의 장점은 처음 보는 사람이 파익이 쉽다이고, 단점은 여기나 interface 정의가 너무 많다는 것이 될 수 있습니다. 결국, View와 Presenter 간의 통신을 위한 리스너 역할의 interface view에 대한 정의는 처리가 되어야 한다. Googl Architecture을 따르면 구글에서 정의하는 Presenter의 생성 방법은 다음과 같다. Presenter의 생성은 View가 아닌 실제 View가 만들어지는 시점의 Activity/Fragment/View 등에서 생성을 하고 해당 Presenter에 setView를 실행한다. setView가 호출되는 시점에 자기 자신(this)을 setPresenter 함수를 통해서 실제 Presenter가 사용되어야 할 View에 전달한다. View에서는 setPresenter을 통해서 전달받은 Presenter을 가지고 이후 loadItem, OnClickLstener 등의 처리를 한다. 여기서 의문점 Activity만 있는 경우는?? Activity만 있는 경우인데 별도의 View를 생성해야 하는가? 그냥 자기 자신이 받아도 되는가? 의문에 대한 대답 구글이 제안하는 방법대로라면 - 별도의 View가 있다고 생각하는게 좋겠죠? 코드의 통일성을 위해서 - 자기 자신이 받는 것은 없다고 보면 된다. 정리하자면 결국 자기 자신이 new Presenter을 처리할 수 있어야 한다. 그럼 setPresenter라는 메소드가 필요하지 않게 된다. Activitiy/Fragment/View 등에서 필요한 경우 Presenter을 생성하고, 자기 자신이 사용할 수 있어야 한다. 그럼 어떻게? 위와 같은 문제점에 대한 제안된 방법은 아래와 같다. Activity/Fragment/View에서 필요한 Presenter을 직접 생성 setView를 전달한다. loadItem을 직접 호출 View을 통해서 처리 결과에 다른 View을 갱신한다. Contract 구현하기 이번에는 구글의 Contract 정의를 따를 예정이므로 Contract를 구현한다. Contract를 사용하는 이유는 간단하다. View와 Presenter을 각각 정의하기 위함이며, 이해를 돕기 위한 이유도 있다. 하나의 interface에 View/Presenter을 정의하고, 이를 각각의 View와 Presenter에서 정의하는 방식이다. 먼저 View와 Presenter을 각각 다음과 같이 구현할 수 있다. 12345678910public interface SampleContract&#123; interface View&#123; // View method &#125; interface Presenter&#123; // Presenter method void setView(View view); &#125;&#125; Presenter 상속 정의 Presenter는 다음과 같은 방식으로 구현한다. SampleContract.Presenter을 상속받아서 구현하며, SampleContract.View을 가지게 된다. 1234567class SamplePresenter : SampleContract.Presenter&#123; private var view : SampleContract.View? = null override fun setView(view : SampleContract.View)&#123; this.view = view &#125;&#125; View 상속 정의 SampleContract.View를 상속받으면 다음과 같이 정의해주면 된다. 1234567891011121314151617181920class SampleActivity extends AppCompatActivity implements SampleContract.View &#123; private SampleContract.Presenter presenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); presenter = new SamplePresenter(); presenter.setView(this); presenter.loadItem(); &#125; @Override public void updateView(List&lt;Items&gt; items) &#123; // UI 갱신 &#125;&#125; 참고 Android MVP 무작정 따라하기 - Presenter/View 생성하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 2","slug":"Android-MVP-Step2","date":"2019-01-16T10:43:15.000Z","updated":"2020-03-01T10:25:15.787Z","comments":true,"path":"2019/01/16/Android-MVP-Step2/","link":"","permalink":"https://woovictory.github.io/2019/01/16/Android-MVP-Step2/","excerpt":"","text":"이번에는 Android MVP 따라하기 두번째 Step으로 MVC 구조를 알아보려 한다. MVC 구조로 작성된 코드를 하나씩 MVP 구조로 변경하기 위함이다. MVC 구조 MVC는 MVP 이전의 구조 중 하나이다. Model, View, Control의 약자로 주로 웹에서 사용되는 구조이다. 그래서 Android에 적용된 구조는 조금 다른 형태로 표현된다. MVC는? Model, View, Control의 약자이다. MVC는 주로 웹에서 사용하고, 가장 널리 사용되는 구조 중 하나이다. MVC 구조에서의 입력은 모두 Control에서 발생하게 되는 구조이다. 이벤트가 발생한 Control에 의해 모듈의 정의와 View의 용도가 결정된다. Model : 데이터를 가진다. View : 사용자에게 보일 화면을 표현한다. Control : 사용자로부터 입력을 받고, 이를 모델에 의해 View를 정의하게 된다. Control : 사용자 이벤트 발생 Control : 사용자 이벤트가 발생하였는데 갱신이 필요한지 Model에 확인 Model : 데이터 갱신이 필요하다는 이벤트 발생 View : Model 또는 Control로부터 갱신 필요 여부 이벤트를 받는다. View : Model에서 실제 필요한 데이터를 받아와 View를 갱신 위와 같은 5단계 정도로 나열할 수 있을 것이다. 하지만 Android에서는? Android에서는 View와 Control이 Activity/Fragment 같은 View들이 모두 가지고 있다. 예를 들면 아래와 같은 코드가 될 수 있다. 123456789101112131415161718public class MainActivity extends AppCompactActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // ... FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 데이터 갱신 요청 // Model에 접근해서 최신 데이터를 요청 // ex) ArrayList&lt;String&gt; getItems() // 전달받은 ArrayList를 통해 View를 갱신 &#125; &#125;); &#125;&#125; 하나의 화면 안에서 Control인 setOnClickListener이 발생하고, 이를 View에서 모두 처리하는 형태이다. Web에서 적용된 MVC 패턴은 View와 Control이 모두 분리된 상태를 말한다. 하지만, 안드로이드는 위와 같다. 그래서 그림으로 정리해보면 아래와 같을 수 있다. 간단하게 정리해보면 아래와 같다. Activity에서 사용자 이벤트 발생 Model로부터 데이터 갱신이 필요한지 확인 Model로부터 전달받은 데이터를 통해 View 갱신 여부 판단 View에서 UI 갱신 처리 한 화면에서 모든 데이터를 처리함으로써 얻는 장점 Android에서 흔하게 사용되는 MVC는 Class 하나로 처리가 가능한 구조가 만들어지게 된다. 그렇기에 정리만 잘하면 한눈에 코드 파악이 가능할 수 있지만, 어느 정도 범주를 벗어나면 코드 파악이 어렵다. 함수 분리가 안되어 있다면 더욱 그렇다. 그렇기에 함수 분리 또는 Class 분리를 적절하게 해야 복잡도가 낮아질 수 있다. 예를 들면 아래와 같이… 123boolean isLast()&#123; return itemList.size() &gt;=100;&#125; 그 외에도 공통으로 분리될 수 있어 보이는 setVisibility()도 여러 번 Visible/Gone이 발생한다면 당연히 함수로 분리한다. 그렇기에 코드 분리만 잘해도 사실 MVC 패턴으로 코드 작성은 문제가 없다.(고 한다… 나는 계속 MVC로 프로젝트를 작성했다.) 장점 개발 기간이 짧을 수 있다. 생각보다 개발 기간이 짧을 수 있다. 생각해야 할 부분도 많지 않고, 그냥 Android Activity에서 모든 걸 동작하게 처리만 해주면 되므로, 개발 기간이 짧을 수 있다. 코드만 읽을 수 있다면 누구나 쉽게 파악 가능 그리고 처음 보는 사람도 별도의 패턴을 구분하지 않고, 쉽게 파악이 가능하다. 단점 코드의 양이 증가 하나의 Class 안에서 모든 걸 할 수 있다. 그로 인해 하나의 Class에서 수백 ~ 수천 줄이 넘는 코드를 발견할 수 있다. 스파게티 코드 가능성 복사 / 붙여넣기가 많아지고, 코드 분리가 안되어 있다면 스파게티 코드처럼 빙빙 꼬여 있는 모습을 볼 수 있다. 그렇기에 복잡도는 증가한다. 결국 처음 설계부터 중요하고, 분리도 잘해야 한다. 유지 보수의 어려움 개발 기간이 짧다는 말은 그만큼 코드를 막 작성할 수 있다는 말이고, 코드의 정체성이 혼란이 생길 수 있다. 꾸준하게 이런 일이 발생하게 되면 쓰레기 코드의 양 증가를 동시에 가져오게 된다. 이러한 이유들로 유지 보수 역시 어려워지게 된다. View와 Model의 결합도가 높다. MVC는 View와 Model간의 결합도가 높다. 대부분의 코드를 View에서 Model을 직접 호출하여 사용하게 된다. 그렇기에 View와 Model 간의 결합도가 높아지게 되고, 테스트 코드 작성에도 어려움이 발생한다. 테스트 코드 작성이 어렵다. MVC는 대부분 UI에서 모든 걸 할 수 있기 때문에 테스트 코드 작성이 어려워지게 된다. 작성을 한다고 하더라도 UI 위주의 테스트 코드 작성이 가능하다. 하지만 UI는 변화가 자주있는 곳 중에 하나이다. UI가 아닌 모델까지 변경이 된다면… 참고 Android MVP 무작정 따라하기 - MVC 구조 이해하기","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] MVP 따라하기 1","slug":"Android-MVP-Step1","date":"2019-01-16T09:02:32.000Z","updated":"2020-03-01T10:25:13.165Z","comments":true,"path":"2019/01/16/Android-MVP-Step1/","link":"","permalink":"https://woovictory.github.io/2019/01/16/Android-MVP-Step1/","excerpt":"","text":"서론 지금까지 안드로이드 개발을 하면서 아키텍처 패턴을 적용해서 개발을 해본 적이 없다. MVC, MVP, MVVM이 잘 알려져 있는데, 굳이 이 범주에 포함시켜 보자면 MVC로 개발을 진행했던 것 같다. 이번에 부스트캠프를 하는데, 어떤 교육을 받는 과정이 아니라 실무 프로젝트 중심으로 진행한다고 한다. 그래서 내가 배워보고 싶은 것들은 내가 노력하고 시간을 투자해서 공부하고 배워야 할 것 같다. 그 과정에서 어려운 것이 있다면 멘토님들한테 질문을 해보자. 안드로드에서 테스트 코드를 작성하기 위한 방법 중 하나로 MVP를 선택해서 사용한다고 한다. 또한 Model, View, Presenter 간의 상호 의존성을 떨어트리기 위한 용도도 있다고 한다. MVP란? 서론이 조금 길었다. 그렇다면 MVP란 무엇일까? MVP를 알기 위해서는 MVP의 각 단어의 역할과 목적이 중요하다. Model : Data와 관련된 처리를 담당 Data의 전반적인 부분을 model에서 담당하고, 네트워크, 로컬 데이터 등을 포함한다. View : 사용자의 실질적인 이벤트가 발생하고, 이를 처리 담당자인 Presenter로 전달한다. 완전한 View의 형태를 가지도록 설계한다. 계산을 하거나 데이터를 가져오는 등의 행위는 Presenter에서 처리하도록 한다. Presenter : View에서 전달받은 이벤트를 처리하고, 이를 다시 View에 전달한다. View와는 무관한 Data등을 가지고, 이를 가공하고 View에 다시 전달하는 역할 MVP 구조 MVP의 기본 패턴 MVP를 처음 접해보고 이제 시작하는 나로서는 그냥 빙글 빙글 돌려놓은 듯한 느낌을 받았다. 이를 아래와 같은 그림처럼 표현할 수 있다. 이를 순서대로 나열하면 아래와 같다. View : View에서 터치 이벤트 발생 View -&gt; Presenter : Presenter로 이벤트 전달 Presenter : View에서 요청한 이벤트 처리 Presenter -&gt; View : 처리한 결과를 View로 전달 View : 처리된 결과를 바탕으로 UI를 갱신 위와 같은 형태를 가지며 1~5번까지 처리가 완료되면 이후 같은 동작이 계속적으로 일어난다. 일반 코드라면 하나의 액티비티 파일 안에서 모두 처리가되니까 눈으로 보긴 편하다. 따라갈 필요도 없고, 함수만 따라다니면 보기도 쉽기 때문이다. 그래서 MVP를 빙글 빙글 돌려놓은 것 아닐까? 라는 답이 나올 수 밖에 없다. MVP에 모델을 더하면? 위에서 기본적으로 작성한 MVP에 모델을 더하면 아래와 같이 표현이 가능하다. View : View에서 터치 이벤트 발생 View -&gt; Presenter : Presenter에 이벤트 전달 Presenter : 이벤트의 형태에 따라 캐시 데이터를 가져오거나 Model에 요청 Presenter -&gt; Model : Presenter에서 데이터를 요청 받음 Model : 데이터를 로컬 또는 서버에서 가져온다. Presenter : 전달 받은 데이터를 가공 Presenter -&gt; View : 가공한 데이터를 View에 전달 Vie : Presenter로부터 전달받은 데이터를 View에 갱신 상황에 따라서 Presenter는 Model을 사용할 수도 사용하지 않을 수도 있지만 기본 형태는 위와 같다. 참고 Android MVP 무작정 따라하기 - Intro","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"MVP","slug":"MVP","permalink":"https://woovictory.github.io/tags/MVP/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[안드로이드] View 함수 Testing","slug":"Android-View-Lifecycle-Test","date":"2019-01-14T13:19:50.000Z","updated":"2020-03-01T10:26:46.513Z","comments":true,"path":"2019/01/14/Android-View-Lifecycle-Test/","link":"","permalink":"https://woovictory.github.io/2019/01/14/Android-View-Lifecycle-Test/","excerpt":"","text":"예전에는 안드로이드에서 액티비티 파일을 만들고 xml 파일에 View, ViewGroup들을 정의하고, Activity의 생명주기 함수나 혹은 프래그먼트의 생명주기 함수가 호출되는 것이 가장 중요한 개념이 아닐까 생각했었다. 하지만, 이런 Activity, Fragment의 View, ViewGroup들이 결국 화면에 그려지기 위해서는 분명 화면에 그리는 함수들이 존재할 것이다. 나는 이 개념과 함수들을 부스트 캠프를 준비하면서 알게 되었다. 안드로이드에서 ViewGroup이나 View를 화면에 그릴 때, View Lifecycle의 개념이 중요하다. 이 개념을 아직 완벽하게 이해하진 못했지만, ViewGroup의 성능 측정을 위해서 실험을 하였다. View와 관련된 개념은 이전에 공부한 포스팅에 내용을 추가할 예정이다. 그리고 성능 측정을 위해서 LinearLayout, RelativeLayout, ConstraintLayout의 세가지 ViewGroup을 Custom하여 테스트해보았다. 3개의 ViewGroup의 View 함수들이 어떻게 호출되는지 확인하기 위해서 간단한 CustomView를 만들었다. 이 예제는 박상권님의 블로그를 참고했으며, 참고 링크는 아래에 기재해두었다. CustomView 만들기 CustomView가 사용되는 경우는 같은 형식의 버튼이 3개라면 하나의 레이아웃 소스 코드를 복사해서 3번 붙여넣기 하면 만들 수 있다. 만약 버튼이 100개라면 100번 정도 복사 / 붙여 넣기 작업을 반복하면 된다. 그런데, padding 값이나 margin값을 바꾸고 싶다면? 100개의 버튼에 대해서 똑같은 작업을 반복하는 지옥에 빠지게 된다.(상상만 해도 끔찍하다.) 이러한 경우 CustomView를 만들어서 이를 재사용하는 것이 좋다. 예제로 로그인 버튼 형태의 레이아웃을 유지하고 아이콘과 텍스트만 변경하도록 구성해보겠다. 위와 같이 custom하게 만든 속성을 이용해서 배경색, 아이콘 이미지, 텍스트, 텍스트 색상 등을 지정할 수 있다. 복잡한 레이아웃 구성도 하나의 CustomView로 만들어 준뒤 해당 CustomView를 재사용하면 편리하고 유용하게 화면을 구성할 수 있다. 1. layout xml파일 생성하기 CustomView의 기본으로 사용될 layout xml 파일을 만든다. 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout android:id=\"@+id/bgLinear\" xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"55dp\" android:background=\"@color/kakao_color\" android:layout_gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/symbolLinear\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"20dp\" android:src=\"@drawable/kakao\"/&gt; &lt;TextView android:id=\"@+id/textLinear\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:gravity=\"center\" android:text=\"카카오톡 로그인\" android:textColor=\"@color/text_color\" android:textStyle=\"bold\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; 2. attrs.xml 설정 custom하게 만들어 줄 atrribute를 설정해준다. 해당 파일은 value -&gt; attrs.xml 파일을 만들고 이 안에 내용을 추가해준다. 추가해주는 속성은 CustomView를 사용할 xml에서 속성을 지정하기 위함이다. 즉, 내가 넣고자 하는 속성을 넣어서 마음대로 만들 수 있다는 뜻이다. 이 attr 속성을 보았을 때 4가지를 나중에 속성값으로 받아서 적용할 수 있게 할 것이다. 이 attr은 나중에 app:text=&quot; … &quot; 로 쓰일 수 있으며 “가나다라” 같은 직접적인 String과 @string/exam 같은 reference를 넣어줄 수도 있다. 3. CustomView 만들기 CustomView의 생성자를 모두 만들고 그 안에서 initView, getAttrs 함수를 호출한다. [주의할 사항은 꼭 커스텀 뷰의 생성자를 모두 생성해야 하는 것이다.] 12345678910constructor(context: Context, attrs: AttributeSet) : this(context) &#123; initView() getAttrs(attrs)&#125;constructor(context: Context, attrs: AttributeSet, defStyle: Int) : this(context, attrs) &#123; initView() getAttrs(attrs, defStyle)&#125; initView()에서는 미리 만들어둔 xml 파일을 할당하고 각각의 view를 설정해준다. inflate를 통해서 xml 파일을 view 객체로 메모리에 올린다. 그리고 addView(view)를 해준다. 123456private fun initView()&#123; var inflaterService : String = Context.LAYOUT_INFLATER_SERVICE var inflater : LayoutInflater = context.getSystemService(inflaterService) as LayoutInflater var view = inflater.inflate(R.layout.login_button_linear, this, false) addView(view)&#125; getAttrs() 함수를 통해서 attrs.xml 파일에 선언해둔 attribute를 가지고 오는 작업을 수행한다. 그리고 setTypeArray() 함수로 넘겨준다. 123456789private fun getAttrs(attrs : AttributeSet, defStyle: Int)&#123; var typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton, defStyle,0) setTypeArray(typedArray)&#125;private fun getAttrs(attrs: AttributeSet)&#123; var typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton) setTypeArray(typedArray)&#125; setTypeArray() 함수를 통해서 attrs.xml 파일에 정의한 속성을 적용해서 layout이 가지고 있는 view에게 값을 설정해주는 작업을 수행한다. 123456789101112131415private fun setTypeArray(typedArray: TypedArray)&#123; var backgroundResourceId = typedArray.getResourceId(R.styleable.LoginButton_bg, R.color.naver_color) bgLinear.setBackgroundResource(backgroundResourceId) var symbolResourceId = typedArray.getResourceId(R.styleable.LoginButton_symbol, R.drawable.naver) symbolLinear.setImageResource(symbolResourceId) var textColor = typedArray.getColor(R.styleable.LoginButton_textColor, 0) textLinear.setTextColor(textColor) var textString = typedArray.getString(R.styleable.LoginButton_text) textLinear.text = textString typedArray.recycle()&#125; 느낀점 뷰를 화면에 그릴 때는 View의 Lifecycle이 중요하다. 이는 우리가 구성한 뷰를 사용자의 화면에 보여주기 때문이다. 그리고 렌더링되는 속도는 뷰를 그리는 것과 연관이 되어있다. 그렇다면 View의 Lifecycle을 한 번 더 살펴보자. 실제로 RelativeLayout이나 LinearLayout보다는 ConstraintLayout이 뷰의 계층을 줄여주고 훨씬 효율적으로 뷰를 구성할 수 있다고 한다. 이로 인해서 얻을 수 있는 이점은 무엇이 있을까 생각해봐야 한다. 뷰의 계층을 수평적으로 만들 수 있다. 이로 인해 findViewById를 호출하는 횟수도 감소시킬 수 있다. View Lifecycle 함수들의 호출 횟수를 줄일 수 있다. Linear LiearLayout을 상속받은 CustomView Relative RelativeLayout을 상속받은 CustomView Constraint ConstraintLayout을 상속받은 CustomView 결론 RelativeLayout이 Linear나 ConstraintLayout보다 onMeasure() 함수가 2배 정도 많이 호출되는 것을 확인할 수 있었다. 아마도 RelativeLayout이 자신의 크기를 측정하고 자식의 크기를 측정하는 과정이 필요하기 때문에 2배 호출되는 것으로 생각하고 있다. RelativeLayout은 뷰를 구성할 때 상대적인 위치를 고려해서 배치하거나 상하좌우에 배치시킬 때 나는 주로 이용했었다. 하지만, 복잡한 레이아웃을 구성할 때 RelativeLayout을 사용한다면 View의 계층이 깊어지게 되고 이로 인해서 View의 크기를 측정하는 과정이 길어지면서 결국에는 렌더링 속도에 영향을 미치는 좋지 않을 결과를 초래할 것이다. 그래서 앞으로는 ConstraintLayout을 사용해보면서 익히고 주로 사용해볼 생각을 하고 있다. 사실, 제대로 테스트를 진행하기 위해서는 커스텀 뷰그룹 안에 커스텀 뷰를 넣어야 한다. 하지만 나는 커스텀 뷰 그룹 안에 TextView, ImageView를 그대로 넣었다.[이 부분은 나중에 다시 테스트 할 예정] 참고 [Android] View에 대한 기본 지식 및 ViewGroup 성능 측정 삽질기 [안드로이드/Android]CustomView를 만들어서 재사용하기 https://developer.android.com/training/custom-views/create-view?hl=ko https://developer.android.com/guide/topics/ui/custom-components?hl=ko#custom","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"라이브러리","slug":"라이브러리","permalink":"https://woovictory.github.io/tags/라이브러리/"}]},{"title":"[디자인 패턴] 브릿지 패턴","slug":"DesignPattern-Bridge","date":"2019-01-13T14:40:31.000Z","updated":"2020-05-12T11:30:09.999Z","comments":true,"path":"2019/01/13/DesignPattern-Bridge/","link":"","permalink":"https://woovictory.github.io/2019/01/13/DesignPattern-Bridge/","excerpt":"","text":"브릿지 패턴 구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한다. 즉, 기능과 구현에 대해서 두 개를 별도의 클래스로 구현을 한다.","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[]},{"title":"[안드로이드] 안드로이드 면접 4","slug":"Android-For-Interview-4","date":"2019-01-07T05:26:19.000Z","updated":"2020-03-01T10:24:45.868Z","comments":true,"path":"2019/01/07/Android-For-Interview-4/","link":"","permalink":"https://woovictory.github.io/2019/01/07/Android-For-Interview-4/","excerpt":"","text":"안드로이드 백그라운드 액티비티 생명주기 프래그먼트 생명주기 Content Provider VS Content Resolver 안드로이드 백그라운드 안드로이드 UI는 기본적으로 싱글 스레드 모델로 작동하므로, 이 영향을 고려해서 개발하지 않으면 애플리케이션의 성능이 저하될 수 있다. 따라서 메인 스레드에서 긴 작업을 하는 것을 피하기 위해 여분의 스레드를 사용해야 한다. 다른 스레드에서 UI 스레드로 접근할 수 있도록 안드로이드에서 제공하는 스레드 간 통신 방법을 알아보자. # 소개 안드로이드의 애플리케이션을 실행하면 시스템은 메인 액티비티를 메모리로 올려 프로세스를 만들며, 이 때 메인 스레드가 자동으로 생성된다. 메인 스레드는 안드로이드의 주요 컴포넌트를 실행하는 곳이자 UI를 그리거나 갱신하는 일을 담당할 수 있는 유일한 스레드이므로 이를 UI 스레드라고 부른다. 안드로이드 화면을 구성하는 뷰나 뷰 그룹을 하나의 스레드에서만 담당하는 원칙을 싱글 스레드 모델이라고 한다. 싱글 스레드 모델의 규칙은 다음과 같다. 메인 스레드(UI 스레드)를 블럭하지 말 것. 안드로이드 UI 툴킷은 오직 UI 스레드에서만 접근할 수 있도록 할 것. 이런 싱글 스레드 모델의 영향을 고려하지 않으면 애플리케이션의 성능이 저하될 수 있다. 긴 시간이 걸리는 작업을 메인 스레드에서 담당하면 애플리케이션의 반응성이 낮아질 수 있고, 급기야 사용자의 불편함을 방지하고자 시스템이 애플리케이션을 ANR 상태로 전환시킬 수도 있다. 따라서 시간이 걸리는 작업을 하는 코드는 여분의 스레드를 사용하여 메인 스레드에서 분리해야 하고, 자연스럽게 메인 스레드와 다른 스레드가 통신하는 방법이 필요하게 된다. 다른 스레드에서 메인 스레드로 접근하기 위해 Looper와 Handler를 사용할 수 있으며, 안드로이드는 Java의 Thread를 좀 더 쉽게 사용할 수 있도록 래핑한 HandlerThread. 더 나아가 Thread나 Message Loop 등의 작동 원리를 크게 고려하지 않고도 사용이 가능한 AsyncTask 등의 클래스를 제공한다. 그럼 먼저 Thread-Looper-Handler의 개념을 이해하고 다음 내용을 알아보자. Looper와 Handler의 사용 목적 왜 안드로이드는 메인 스레드에서만 UI 작업이 가능하도록 제한할까? 메인 스레드가 아닌 스레드가 병렬적으로 실행되고 있을 때, 메인 스레드와 다른 스레드, 두 개 이상의 스레드가 동시에 같은 텍스트 뷰에 setText()를 시도하는 경우를 생각하면 간단하다. 위의 그림처럼 둘 중 어느 스레드의 setText()가 적용될지 예측할 수 없고, 사용자는 둘 중 하나의 값만을 볼 수 있어 다른 한 스레드의 결과는 버려진다. 이같이 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해서 Looper와 Handler를 사용하게 된다. Looper와 Handler의 작동 원리 안드로이드 면접 3에서도 살펴보았지만, 더 보도록 하겠다. 먼저 스레드와 Looper, Handler가 어떻게 작동하는지 보자. 메인 스레드는 내부적으로 Looper를 가지며 그 안에는 Message Queue가 포함된다. Message Queue는 스레드가 다른 스레드나 혹은 자기 자신으로부터 전달받은 Message를 기본적으로 FIFO(선입선출) 형식으로 보관하는 Queue이다. Looper는 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다. Handler는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다. Handler Handler는 스레드의 Message Queue와 연계하여 Message나 Runnable 객체를 받거나 처리하여 스레드 간의 통신을 할 수 있도록 한다. Handler 객체는 하나의 스레드와 해당 스레드의 Message Queue에 종속된다. 새로 Handler 객체를 만든 경우 이를 만든 스레드와 해당 스레드의 Message Queue에 바인드 된다. 다른 스레드가 특정 스레드에게 메시지를 전달하려면 특정 스레드에 속한 Handler의 post나 sendMessage 등의 메소드를 호출하면 된다. 앞서 Message Queue는 전달받은 Message를 선입선출 형식으로 보관한다고 설명했지만, 전달 시점에 다른 메소드를 사용하여 Queue의 맨 위로 보내거나 원하는 만큼 Message나 Runnable 객체의 전송을 지연시킬 수도 있다. 자주 쓰이는 Handler의 메소드는 아래 글을 참고하자. 참고 글 외부, 혹은 자기 스레드로부터 받은 메시지를 어떤 식으로 처리할지는 handleMessage() 메소드를 구현하여 정리한다. sendMessage()나 post()로 특정 Handler에게 메시지를 전달할 수 있고, 재귀적인 호출도 가능하므로 딜레이를 이용한 타이머나 스케줄링 역할도 할 수 있어 편리하다. Looper와 Message Queue Looper는 무한히 루프를 돌며 자신이 속한 스레드의 Message Queue에 들어온 Message나 Runnable 객체를 차례로 꺼내서 이를 처리할 Handler에 전달하는 역할을 한다. 메인 스레드는 Looper가 기본적으로 생성돼 있지만, 새로 생성한 스레드는 기본적으로 Looper를 가지고 있지 않고, 단지 run 메소드만 실행한 후 종료하기 때문에 메시지를 받을 수 없다. 따라서 기본 스레드에서 메시지를 전달받으려면 prepare() 메소드를 통해 Looper를 생성하고, loop() 메소드를 통해 Looper가 무한히 루프를 돌며 Message Queue에 쌓인 Message나 Runnable 객체를 꺼내 Handler에 전달하도록 한다. 이렇게 활성화된 Looper는 quit()이나 quitSafely() 메소드로 중단할 수 있다. quit() 메소드가 호출되면 Looper는 즉시 종료되고, quitSafely() 메소드가 호출되면 현재 Message Queue에 쌓인 메시지들을 처리한 후 종료된다. Message와 Runnable Message Message란 스레드 간 통신할 내용을 담는 객체이자 Queue에 들어갈 일감의 단위로 Handler를 통해 보낼 수 있다. 일반적으로 Message가 필요할 때 새 Message 객체를 생성하면 성능 이슈가 생길 수 있으므로 안드로이드가 시스템에 만들어 둔 Message Pool의 객체를 재사용한다. obtain() 메소드는 빈 Message 객체를, obtain(Handler h, int what …)은 목적 Handler와 다른 인자들을 담은 Message 객체를 리턴한다. Runnable 새 스레드는 Thread() 생성자로 만들어서 내부적으로 run()을 구현하던지, Thread(Runnable runnable) 생성자로 만들어서 Runnable 인터페이스를 구현한 객체를 생성하여 전달하던지 둘 중 하나의 방법으로 스레드를 만들 수 있다. 후자에서 사용하는 것이 Runnable로 스레드의 run() 메소드를 분리한 것이다. 따라서 Runnable 인터페이스는 run() 추상 메소드를 가지고 있으므로 상속받은 클래스는 run() 코드를 반드시 구현해야 한다. 앞서 언급한대로 Message가 int나 Object 같이 스레드 간 통신할 내용을 담는다면 Runnable은 실행할 run()메소드와 그 내부에서 실행될 코드를 담는다는 차이점이 있다. HandlerThread Looper에서 언급했듯이 안드로이드의 스레드는 Java의 스레드를 사용하기 때문에 안드로이드에서 도입한 Looper를 기본으로 가지지 않는다는 불편함이 있다. 이같은 불편함을 개선하기 위해 생성할 때 Looper를 자동으로 보유한 클래스를 제공하는데, 이것이 바로 HandlerThread이다. HandlerThread는 일반적인 스레드를 확장한 클래스로 내부에 반복해서 루프를 도는 Looper를 가진다. 자동으로 Looper 내부의 Message Queue도 생성되므로 이를 통해 스레드로 Message나 Runnable을 전달받을 수 있다. AsyncTask AsyncTask는 스레드나 메시지 루프 등의 작동 원리를 잘 몰라도 하나의 클래스에서 UI 작업과 background 작업을 쉽게 할 수 있도록 안드로이드에서 제공하는 클래스이다. 캡슐화가 잘되어 있기 때문에 사용시 코드 가독성이 증대되는 장점이 있으며, 태스크 스케줄을 관리할 수 있는 콜백 메소드를 제공하고 필요할 때 쉽게 UI 갱신도 가능하며 작업 취소도 쉽다. 따라서 리스트에 보여주기 위한 데이터 다운로드 등 UI와 관련된 독립된 작업을 실행할 경우 AsyncTask로 간단하게 구현할 수 있다. AsyncTask 구조 그러나 AsyncTask를 사용해서 스케줄링할 수 있는 작업 수의 제한이 있고, 몇 초 정도의 짧은 작업에서만 이상적으로 동작한다는 한계가 있다. 또한, 안드로이드의 버전 별로 병렬 처리 동작이 다르므로 허니콤 이후 버전에서 멀티 스레드로 병렬적인 동작을 원한다면 AsyncTask를 실행할 때 AsyncTask.THREAD_POOL_EXECUTOR 스케줄러를 지정해야 한다. 한편, 앞서 살펴본 Handler와 Looper를 사용한다면 동작 원리를 고려해야 하며 구현을 직접해야 하고 코드가 복잡해져서 가독성을 저해한다는 단점이 있지만 그만큼 개발 범위가 자유롭다. 또한 UI 스레드에서만 작업하지 않아도 되므로 보다 많은 자율성을 가지고 코드를 제어하기를 원한다면 Handler나 HandlerThread 사용을 고려해보는 것도 좋다. 무엇을 사용할지는 개발자가 어떤 기준을 가지고 개발하는지에 따라 다르다. 그럼에도 나는 AsyncTask를 사용할 것 같다. 왜냐하면 핸들러는 스레드 안에서 실행되어야 할 코드와 UI 접근을 위한 코드가 각각 다른 위치에서 구현을 한다. 그러므로 가독성이 떨어진다. 하지만, AsyncTask는 하나의 클래스 안에 스레드로 동작하는 부분과 화면을 갱신하는 부분을 함께 구현해놓을 수 있다. 이 때문에 스레드를 사용하는 하나의 작업단위가 하나의 클래스로 만들어질 수 있게 되므로 가독성이 훨씬 좋아지게 된다. 간단한 예제는 아래 블록를 참고하자^0^ AsyncTask 예제 Content Provider VS Content Resolver Content Provider : 어플리케이션 내에서 사용할 수 있는 데이터를 공유하기 위한 컴포넌트 ex) 연락처, 이미지 등(카카오톡) Content Resolver : 앱이 Content Provider를 접근할 때에는 Content Resolver를 통해서 접근하게 됨. 기본적으로 CRUD 함수들 제공 -&gt; 다른 앱의 데이터베이스를 조작할 수 있음 ex) contentResolver.query() XML 기반 레이아웃이 중요한 이유 동작을 제어하는 코드로부터 분리시킬 수 있고, UI의 구조를 시각화하기 더 쉽기 때문이다. 소스로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 재컴파일 해야 하는 번거로움이 있다. Manifest 애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야 한다. Vector Vs Bitmap Vector : 리사이징이 되어도 전혀 깨지지 않는다. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심 ex)SVG Bitmap : 픽셀로 구성되어 있다. 자유자재로 바꿀 수가 없고 움직일 수도 없다. ex)PNG, JPEG 참고 안드로이드 백그라운드 잘 다루기 Thread, Looper, Handler [Android] AsyncTask","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드 기초","slug":"안드로이드-기초","permalink":"https://woovictory.github.io/tags/안드로이드-기초/"},{"name":"면접 질문","slug":"면접-질문","permalink":"https://woovictory.github.io/tags/면접-질문/"}]},{"title":"[안드로이드] 안드로이드 면접 3","slug":"Android-For-Interview-3","date":"2019-01-07T01:56:36.000Z","updated":"2020-03-01T10:24:47.299Z","comments":true,"path":"2019/01/07/Android-For-Interview-3/","link":"","permalink":"https://woovictory.github.io/2019/01/07/Android-For-Interview-3/","excerpt":"","text":"화면이 회전하면 액티비티의 생명주기는? 펜딩인텐트란? 안드로이드에서 Task와 Process의 차이점 A 앱에서 B 앱의 액티비티를 부를 경우 화면 렌더링 속도를 개선하는 방법 Thred간 통신 방법 ANR 화면이 회전하면 액티비티의 생명주기는? 안드로이드 애플리케이션을 사용하다 보면 화면이 가로 모드를 지원하는 애플리케이션들이 많다. 이런 경우 우리가 사용하는 액티비티의 생명주기는 어떻게 되는 것일까??? 일단, 화면이 회전하면 뷰의 크기를 재측정하고 다시 달라진 크기대로 새롭게 그려야 된다. 먼저, onPause가 호출되고 onStop, onDestroy가 진행된 후 다시 onCreate, onStart, onResume 순서로 진행된다. 따라서 현재 액티비티를 destroy 시키고 새로 만들기 때문에 기존의 데이터는 사라지게 된다. 그런데 우리가 사용하는 애플리케이션에서는 지워지지 않는데? onDestroy가 호출되기 전에 액티비티는 onSaveInstanceState를 호출하게 되는데 이때 저장되어야 할 데이터를 Bundle 객체에 저장해두었다가 다시 onCreate가 호출되면 파라미터로 날아온 Bundle에서 이전 데이터를 받아 복구할 수 있다. 이 과정을 통해 화면이 회전되어도 데이터를 유지할 수 있는 것이다. 펜딩인텐트란? 펜딩 인텐트(Pending Intent)는 인텐트의 일종이다. 컴포넌트에서 다른 컴포넌트에게 작업을 요청하는 인텐트를 사전에 생성시키고 만든다는 점과 특정 시점에 자신이 아닌 다른 컴포넌트들이 펜딩 인텐트를 사용하여 다른 컴포넌트에게 작업을 요청시키는데 사용된다는 점이 일반적인 인텐트와의 차이점이다. 수행시킬 작업 및 인텐트와 그것을 수행하는 주체를 지정하기 위한 정보를 명시할 수 있는 기능의 클래스라고 보면 된다. 쉬운 예제는 아래와 같다. A한테 이 B인텐트를 C 시점에 실행하라고 해. 지금은 실행하지 말고. 이 클래스의 인스턴스는 getActivity (Context, int, Intent, int), getActivities (Context, int, Intent [], int), getBroadcast (Context, int, Intent, int) 및 getService(Context, int, Intent, int) 가 반환 하는 객체를 다른 응용 프로그램으로 전달 할 수 있으므로 앱 개발자가 명시하는 작업을 수행 할 수 있다. Pending Intent를 다른 응용 프로그램에 제공하면 다른 응용 프로그램이 자신과 동일한 권한과 ID로 지정된 것처럼 작업을 수행할 수 있는 권한이 부여된다. 따라서 Pending Intent를 작성하는 방법에 주의해야 한다. 예를 들어, 제공하는 기본적인 인텐트는 컴포넌트 이름이 자신이 가진 컴포넌트들 중 하나를 명시적으로 지정해야 하며, 궁극적으로 그곳으로 보내지는 것을 보장해야 한다. 사용되는 몇가지 사례 사용자가 Notification을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(NotificationManager가 인텐트를 실행) 사용자가 AppWidget을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(홈 스크린이 인텐트를 실행) 미래의 특정 시점에 실행되는 인텐트를 선언함(안드로이드의 AlarmManager가 인텐트를 실행) 안드로이드 앱을 구현할 때, 인터넷으로부터 파일을 다운로드 하는 로직은 대부분 서비스에서 이루어지도록 구성한다. 그런데 서비스는 액티비티와 달리 화면에 나타나지 않는다. 따라서 서비스는 다운로드의 진행중이라는 사실 및 진행 정도를 화면 상단에 위치한 노티피케이션의 상태바(Status bar)를 통해서 표현한다. 다운로드가 현재 진행 중이라는 상황을 표시하는 아이콘 등으로 말이다. 그리고 다운로드가 완료된 후에는 아이콘으로 다운로드 완료의 상태를 보여주게 된다. 사용자가 상태바의 아이콘을 확인하고 안드로이드 화면의 상태바를 누르면서 나타나는 바를 잡아 아래로 끌어당기면 나타나는 화면을 노티피케이션 리스트 또는 확장 메시지라 한다. 그리고 만약 서비스가 이 Notification List에 다운로드 완료를 표시를 추가해놓았고, 사용자가 이것을 클릭하면 노티피케이션은 사전에 서비스에서 작성한 펜딩 인텐트를 사용하여 다운로드된 파일을 읽을 수 있는 앱을 호출하고 다운로드 완료된 파일을 호출된 앱에서 재생 혹은 보여주게 된다. 펜딩 인텐트는 안드로이드 App의 각각의 컴포넌트들이 펜딩 인텐트를 생성할 수 있도록 다음과 같은 메소드를 제공한다. 아래의 메소드를 통해 펜딩 인텐트를 사용하고자 하는 컴포넌트 유형을 지정해야 한다는 뜻이다. getActivity(Context, int, Intent, int) getBroadcast(Context, int, Intent, int) getService(Context, int, Intent, int) 여기서 Context는 현재 App의 Context이다. # Example 노래를 재생하는 중이고 이것이 상태바에 Notification으로 보여질 때 사용자가 이 Noti를 클릭하면 Notification은 이전에 전달받은 Pending Intent를 실행한다. Pending Intent가 getActivity()에 의해 생성된 것이며 감싸고 있는 intent 또한 특정 화면을 실행시키는 intent라면 이것이 그대로 실행되어 노래 화면이 뜨게 된다. 이때 주의할 점은 Activity는 새로운 테스크를 생성하여 그곳에 쌓이게 된다. 마치 Intent의 flag가 NEW_TASK로 설정된 것처럼 실행되기 때문에 유의해야 한다. 하나의 Activity만 생성되도록 보장하기 위해선 AndroidManifest 파일에 lanunchMode = “singleTop” 으로 설정해주어야 한다. 안드로이드에서 Task와 Process의 차이점 애플리케이션 컴포넌트가 처음 시작될 때 실행 중인 다른 컴포넌트가 없으면 안드로이드 시스템은 프로세스를 새로 생성시킨다. 기본적으로 애플리케이션의 컴포넌트들은 같은 프로세스의 기본 스레드에서 실행된다. 이후의 컴포넌트들이 시작할 때는 이미 생성된 프로세스 내에서 시작되며 컴포넌트별로 별도의 프로세스에서 실행되도록 할 수도 있고 어느 프로세스에서든 추가적인 스레드를 생성하여 작업할 수 있다. Manifest 파일에서 android:process 특성을 설정함으로써 다른 프로세스에 해당 컴포넌트를 실행시킬 수 있다. 안드로이드 시스템에서 메모리가 부족할 경우 우선순위가 낮은 프로세스부터 종료시킨다. 우선순위는 Foregorund, Visible, Service, Background, Cached 프로세스 순이다. 눈에 보이는 프로세스는 Foreground와 Service 프로세스이며 Visible은 다이얼로그가 뜨는 경우 뒤에 액티비티가 가려지지만 사용자에게 보이는 경우에 해당한다. Service는 사용자가 볼 수는 없지만 프로세스에 필요한 작업은 진행하기에 그 다음 우선순위를 가지며 Background는 뒤로 밀려난 프로세스이기에 종료될 수 있다. 마지막 Cached 프로세스는 컴포넌트가 없는 빈 프로세스이지만 다음에 실행할 때 로드 시간을 절약하기 위해 캐시된 상태이다. Task는 각 애플리케이션마다 사용하는 Activity들을 Stack 구조로 저장 및 관리하는 컬렉션이다. 따라서 사용자가 화면의 전환 흐름을 자연스럽게 경험하도록 보장한다. 또한 Task는 다른 애플리케이션이나 프로세스에 속하는 Activity를 같은 Task에 저장시킴으로써 사용자로 하여금 하나의 애플리케이션에서 작동하는 듯한 경험을 하도록 한다. 단말기에서 사용중인 애플리케이션 리스트를 보는 것이 Task 단위로 보여지는 것이다. 하지만 실질적으로 Activity는 다른 프로세스 상에서 돌아가는 컴포넌트이며 프로세스간 통신을 통해 정보를 주고 받는 것이다. A 앱에서 B 앱의 액티비티를 부를 경우 Task에는 해당 애플리케이션에 속한 컴포넌트뿐만 아니라 다른 애플리케이션 컴포넌트도 쌓일 수 있다. 다른 애플리케이션의 컴포넌트를 실행하는 방법으로 PackageManager의 getLaunchIntentForPackage()가 있고 Intent에 setComponent()를 사용하는 방법이 있는데 전자의 경우 항상 새로운 Task를 생성하여 그곳에서 컴포넌트를 실행시키며 후자의 경우 현재의 Task에서 컴포넌트를 실행시키게 된다. 이 부분은 추후 공부를 더 해볼 예정. 화면 렌더링 속도를 개선하는 방법 기본적으로 View의 움직임이 어색하거나 스크롤이 버벅거리거나 렌더링이 느린 경우는 뷰를 그리는 속도가 16ms 보다 오래걸리는 현상이다. 초당 60 프레임의 속도로 화면을 그려주어야 사람의 시각에 어색함이 없이 보이는데 그리는 시간이 이보다 오래 걸릴 경우 버벅이는 문제가 발생할 수 있다. 따라서 렌더링이 느리다면 2가지를 의심해 봐야 한다. View Hierarchy가 너무 많은지 의심해 볼 것. View는 그려지기 전에 Measure, Layout, Draw의 3단계를 계층적으로 실행한다. 만약 계층이 매우 길고 복잡하다면 당연히 View가 그려지는 시간 또한 오래 걸릴 것이기 때문이다. 계층을 줄이려 ConstraintLayout과 FlexboxLayout를 적극 사용한다면 줄일 수 있을 것이다. onDraw()에서 오버드로우 현상이 일어나는지 확인할 것. onDraw() 함수 안에서 객체 생성을 하였는지, 오래 걸리는 작업을 실행하지 않는지 확인하여 문제가 되는 로직을 수정하거나 제거할 것이다. # ConstrainLayout? ConstrainLayout은 뷰의 상하좌우를 주변 또는 부모 뷰와 연관을 지어 위치시킬 수 있다. bias를 통해 비율적으로 배치시킬 수도 있고, chain을 사용하여 마치 그룹화한 것처럼 사용도 가능하다. 또한 ratio를 사용하여 너비와 높이를 비율대로 설정할 수도 있는 등 매우 유연한 배치가 가능하다. ConstrainLayout의 가장 큰 장점은 View Hierarchy를 수평적으로 평평하게 만든다. 최대 8 계층으로 구성되어 있는 RelativeLayout 구조를 하나의 계층으로 줄일 수 있는 효과를 볼 수 있다. # FlexBoxLayout? 태그와 같은 항목이 하나의 뷰 안에 일렬로 즐비할 경우 한 줄이 가득 차면 다음 줄로 View를 정렬시키는 기능이 필요할 때 사용할 수 있는 Layout이다. FlexBoxLayout은 부모 레이아웃의 너비에 따라 자식 뷰를 여러 행에 걸쳐 동적으로 맞추는 기능을 제공한다. 기존에는 LinearLayout을 통해 구현 가능하긴 하지만 ScrollView와 같이 사용하면서 View의 너비를 일일이 계산하여 다음 행으로 배치시키는 코드를 직접 구현하는 방식으로 커스텀을 해야했다. FlexBoxLayout을 사용하면 이러한 작업을 자동으로 처리해주기에 잘못된 구현으로 인해 오버헤드가 발생하는 문제를 방지할 수 있다. Thred간 통신 방법 Android의 UI를 담당하는 쓰레드는 메인 쓰레드(UI 쓰레드)인데, 오랜 시간이 걸리는 작업을 메인 쓰레드에서 수행할 경우 앱의 성능이 저하된다. 따라서 여분의 쓰레드를 사용하여 작업을 수행해야 하고, 이 결과를 반영하기 위해 메인 쓰레드와의 통신이 필요하게 된다. 그래서 메인 쓰레드에 접근하는 방법은 Looper와 Handler를 이용하면 된다. 그리고 UI 작업을 메인 쓰레드에서만 담당하는 이유는 두 개 이상의 쓰레드를 사용할 때의 동기화 이슈를 차단하기 위함이다. Android는 Java의 쓰레드를 좀 더 쉽게 사용할 수 있도록 래핑한 HandlerThread, AsyncTask를 제공한다. 1. Looper 메인 쓰레드는 내부적으로 Looper를 가지며 그 안에는 Message Queue가 포함된다. Message Queue는 쓰레드가 다른 쓰레드나 혹은 자기 자신으로부터 전달받은 Message를 보관하는 Queue(FIFO)이다. Looper는 무한 루프를 돌며 자신이 속한 쓰레드의 Message Queue에서 Message 객체를 차례로 꺼내서 Handler가 처리하도록 전달한다. 메인 쓰레드는 기본적으로 Looper가 생성되어 있으나, 새로 생성한 쓰레드는 새로운 Looper를 생성해주어야 한다. Android는 Looper가 기본적으로 생성되어 있는 HandlerThred를 제공한다. Message Queue에 저장되는 객체 문자와 필드로 구성된 Message 객체 Runnable 객체 2. Handler Looper로부터 받은 Message를 실행, 처리하거나 다른 쓰레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 쓰레드 간의 통신 장치이다. 일반적으로 UI 갱신을 위해 사용된다. (뷰나 뷰 그룹에서 제공하는 메소드는 단일 스레드 모델(Thread-Unsafe) ANR ANR은 Android Not Responding의 약자로 오랜 시간이 걸리는 작업을 메인 쓰레드에서 담당하면 앱의 반응성이 낮아질 수 있고, 사용자의 불편함을 방지하고자 시스템이 ANR 상태로 전환시킬 수 있다. 따라서 시간이 걸리는 작업은 여분의 쓰레드를 사용해야 하고, 이 작업 결과를 반영하기 위해 메인 쓰레드와 통신하는 방법이 필요하다. # ANR상태 예시 -&gt; input 이벤트에 5초 안에 반응하지 않을 경우(Activity) -&gt; BroadcastRecevier가 10초 이내로 실행하지 않을 경우(UI가 없는 브로드캐스트 리시버와 서비스도 실행 주체가 메인 쓰레드이기 때문에) # ANR대처 방법 -&gt; 시간이 걸리는 긴 작업은 쓰레드로 처리 -&gt; Progress bar로 진행 상황을 보여주어 사용자를 기다리게 한다. 참고 안드로이드 면접 3","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"안드로이드 기초","slug":"안드로이드-기초","permalink":"https://woovictory.github.io/tags/안드로이드-기초/"},{"name":"면접 질문","slug":"면접-질문","permalink":"https://woovictory.github.io/tags/면접-질문/"}]},{"title":"[안드로이드] 딥링크","slug":"Android-What-is-DeepLink","date":"2019-01-06T09:40:16.000Z","updated":"2020-03-01T10:26:29.765Z","comments":true,"path":"2019/01/06/Android-What-is-DeepLink/","link":"","permalink":"https://woovictory.github.io/2019/01/06/Android-What-is-DeepLink/","excerpt":"","text":"Applink? Deeplink?? DeepLink 딥링크는 인텐트 필터의 일종으로 사용자들이 직접적으로 안드로이드 앱 내의 액티비티에 접근하는 것을 허용한다. 다른 앱에서 또는 웹브라우저에서의 링크를 클릭했을 때 해당 링크의 scheme을 보고 앱을 실행하게 되며, 해당 링크를 처리하는 2개 이상의 앱이 있다면 사용자에게 다이얼로그를 띄워 앱을 실행할 수 있도록 유도한다. AppLink 앱링크는 인증된 웹 사이트 URL을 기반으로 하는 딥링크이다. 링크 클릭시 앱이 설치되어 있다면 즉시 열어서 보여주고 없다면 웹으로 이동한다. 다이얼로그는 나타나지 않는다. 참고 딥링크와 앱링크의 차이점","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Deep Link","slug":"Deep-Link","permalink":"https://woovictory.github.io/tags/Deep-Link/"}]},{"title":"[안드로이드] View 함수","slug":"Android-View-Functions","date":"2019-01-06T07:13:04.000Z","updated":"2020-03-01T10:26:49.463Z","comments":true,"path":"2019/01/06/Android-View-Functions/","link":"","permalink":"https://woovictory.github.io/2019/01/06/Android-View-Functions/","excerpt":"","text":"안드로이드 앱 개발을 하면서 layout이나 button 같은 UI 관련 클래스들은 모두 View를 상속 받아서 생성된다. 이 중에 ViewGroup은 button이나 ImageView 같은 것과는 다르게 자식 뷰를 가질 수 있으며 이를 배치하는 역할을 한다. 자신만의 button이나 view를 만들고 싶다면 View 클래스를 상속받아서 필요한 메소드를 오버라이드 하면된다. 자신만의 layout을 만들고 싶다면 ViewGroup 클래스를 상속받아서 필요한 메소드들을 오버라이드 하면된다. Custom View는 View 클래스를 상속하여 만든다. Custom Layout은 ViewGroup 클래스를 상속하여 만든다. View가 그려지는 과정 뷰는 포커스를 얻으면 레이아웃을 그리도록 요청한다. 이때 레이아웃의 계층 구조 중 루트 뷰를 제공해야 한다. 따라서 그리기는 루트노드에서 시작되어 트리를 따라 전위 순회 방식으로 그려진다. [전위 순회 방식 : 루트-&gt;왼쪽-&gt;오른쪽] 부모 뷰는 자식 뷰가 그려지기 전에(즉, 자식 뷰 뒤에) 그려지며 형제 뷰는 전위 방식에 따라 순서대로 그려진다. 레이아웃을 그리는 과정은 측정(measure) 단계와 레이아웃(layout) 단계를 통해 그려지게 된다. measure(int widthMeasureSpec, int heightMeasureSpec) 부모 노드에서 자식 노드를 경유하며 실행되며, 뷰의 크기를 알아내기 위해 호출된다. 이것은 뷰의 크기를 측정하는 것은 아니며 실제 크기 측정은 onMeasure(int, int)를 통해 이루어진다. measure(int, int)의 내부에서 onMeasure(int, int)를 호출함으로써 뷰의 크기를 알아낸다. 측정 과정에서는 부모 뷰와 자식 뷰간의 크기 정보를 전달하기 위해 2가지의 클래스를 사용한다. ViewGroup.LayoutParams 자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청하는데 사용된다. ViewGroup의 sub class에 따라 다른 ViewGroup.LayoutParams의 sub class가 존재할 수 있다. 예를 들어 ViewGroup의 sub class인 RelativeLayout의 경우 자신만의 ViewGroup.LayoutParams의 sub class는 자식 뷰를 수평적으로 또는 수직적으로 가운데 정렬을 할 수 있는 능력이 있다. 숫자 MATCH_PARENT WRAP_CONTENT ViewGroup.MeasureSpec 부모 뷰가 자식 뷰에게 요구 사항을 전달하는데 사용된다. UNSPECIFIED : 부모 뷰는 자식 뷰가 원하는 치수대로 결정한다. EXACTLY : 부모 뷰가 자식 뷰에게 정확한 크기를 강요한다. AT MOST : 부모 뷰가 자식 뷰에게 최대 크기를 강요한다. layout(int l, int t, int r, int b) 부모 노드에서 자식 노드를 경유하며 실행되며 뷰와 자식 뷰들의 크기와 위치를 할당할 때 사용된다. measure(int, int)에 의해 각 뷰에 저장된 크기를 사용하여 위치를 지정한다. 내부적으로 onLayout()을 호출하고 onLayout()에서 실제 뷰의 위치를 할당하는 구조로 되어있다. measure()와 layout() 함수는 내부적으로 각각 onMeasure()와 onLayout() 함수를 호출한다. 이것은 final로 선언된 measure()와 layout() 대신 onMeasure()와 onLayout()을 구현(override)할 것을 장려하기 위해서이다. 뷰의 measure()함수가 반환할때, 뷰의 getMeasureWidth()와 getMeasureHeight()값이 설정된다. 만약 자식 뷰 측정값의 합이 너무 크거나 작을 경우 다시 measure() 함수를 호출하여 크기를 재측정한다. View Lifecycle Constructor 모든 뷰는 생성자에서부터 출발한다. 생성자에서 초기화를 진행하고, default 값을 설정한다. 뷰는 초기설정을 쉽게 세팅하기 위해서 AttributeSet이라는 인터페이스를 지원한다. 먼저, attrs.xml 파일을 만들고 이것을 부름으로써 뷰의 설정값을 쉽게 설정할 수 있다. onAttachedToWindow 부모 뷰가 addView(childView) 함수를 호출하고 나서 자식 뷰는 윈도우에 붙게 된다.(attached) 이때부터 뷰의 id를 통해 접근할 수 있다. onMeasure 뷰의 크기를 측정하는 단계이다. 매우 중요한 단계이며, 대부분의 경우 레이아웃에 맞게 특정크기를 가져야 한다. 여기에는 두 단계의 과정이 있다. (1) 뷰가 원하는 사이즈를 계산한다. (2) MeasureSpec에 따라 크기와 mode를 가져온다. 123456protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec);&#125; MeasureSpec의 mode를 체크하여 뷰의 크기를 적용한다. 12345678int width;if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize;&#125; else if (widthMode == MeasureSpec.AT_MOST) &#123; width = Math.min(desiredWidth, widthSize);&#125; else &#123; width = desiredWidth;&#125; onLayout 이 단계에서 뷰의 크기와 위치를 할당한다. onDraw 뷰를 실제로 그리는 단계이다. Canvas와 Paint객체를 사용하면 필요한 것을 그리게 된다. Canvas 객체는 onDraw 함수의 파라미터로 제공된다. Canvas 객체를 이용하여 뷰의 모양을 그리고 Paint 객체를 이용하여 뷰의 색을 그린다. 여기서 주의할 점은 onDraw() 함수를 호출시 많은 시간이 소요된다는 점이다. Scroll 또는 Swipe 등을 할 경우 뷰는 다시 onDraw()와 onLayout() 함수를 다시 호출하게 된다. 따라서 함수 내에서 객체 할당을 피하고 한 번 할당된 객체를 재사용할 것을 권장한다. View Update View Lifecycle을 보면 뷰를 다시 그리도록 유도하는 invalidate()와 requestLayout() 함수를 볼 수 있다. 이것은 런타임에 뷰를 다시 그릴 수 있게 한다. 각각의 사용 용도는 아래와 같다. invalidate() : \b단순히 뷰를 다시 그릴 때 사용한다. 예를 들어 뷰의 text 또는 color가 변경되거나 touch interactivity가 발생할 때 onDraw() 함수를 재호출하면서 뷰를 업데이트한다. requestLayout() : onMeasure() 부터 다시 뷰를 그린다. 뷰의 사이즈가 변경될 때 그것을 다시 측정해야 하기 때문에 Lifecycle을 onMeasure() 부터 순회하면서 뷰를 그린다. Animation 뷰의 animation은 frame 단위의 프로세스이다. 예를 들어 뷰가 점점 커질 때 뷰를 한 단계씩 차례대로 커지도록 할 것이다. 그리고 각 단계마다 invalidate()를 호출하여 뷰를 그릴 것이다. 대표적으로 애니메이션에 사용하는 클래스는 ValueAnimator이다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"View","slug":"View","permalink":"https://woovictory.github.io/tags/View/"}]},{"title":"[Java] 마커인터페이스","slug":"Java-What-is-Marker-interface","date":"2019-01-04T06:35:44.000Z","updated":"2020-04-22T07:46:55.388Z","comments":true,"path":"2019/01/04/Java-What-is-Marker-interface/","link":"","permalink":"https://woovictory.github.io/2019/01/04/Java-What-is-Marker-interface/","excerpt":"","text":"직렬화할 때 사용하는 방법 중에 Serializable과 Parcelable 두 개가 있다. 그 중에서 Serializable을 공부하던 중 이것이 마커 인터페이스라고 부르는 것을 보았다. 그래서 생긴 의문은 도대체 마커 인터페이스는 무엇인가 마커 인터페이스 자바의 마커 인터페이스는 일반적인 인터페이스와 동일하지만 사실상 아무 메소드도 선언하지 않은 인터페이스를 말한다. 예를 들면 아래와 같다. 123public interface SomethingObject&#123;&#125; 얼핏 보기엔 난해한 코드이다. 인터페이스만 있고 메소드가 없으니 어디에다 쓸지도 난해하다. 자바로 코딩을 하다보면 저런 인터페이스가 종종 있다. 자바의 대표적인 마커 인터페이스로는 위에서 언급한 Serializable, Cloneable과 흔히 알지는 못하지만 Spring에서 event 리스너를 사용한다면 종종 보이는 EventListener라는 인터페이스도 있다. 뭔가 대단한 것처럼 보일수도 있지만 실질적으로는 간단하다. 대부분의 경우에는 단순한 타입 체크라고 할 수 있다. 자바의 대표적인 마커 인터페이스인 Serializable를 살펴보자. 123public interface Serializable&#123;&#125; 메소드가 한개도 선언되어 있지 않다. Serializable 인터페이스 같은 경우에는 직렬화를 할 수 있다는 뜻이다. 즉, 이 인터페이스를 구현하지 않은 클래스의 경우에는 직렬화를 하지 못한다. 1234567891011public void serializableTest() throws IOException, ClassNotFoundException &#123; File f= new File(\"a.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(f)); objectOutputStream.writeObject(new SomeObject(\"wonwoo\", \"test@test.com\"));&#125;class SomeObject &#123; private String name; private String email; //생성자 및 기타 메서드 생략&#125; 위 코드를 실행하면 아래와 같은 에러가 발생한다. 1java.io.NotSerializableException: me.wonwoo.SomeObject 이는 직렬화를 할 수 있는 Serializable을 구현하지 않았기 때문이다. 그렇다면 직렬화를 할 수 있도록 Serializable 인터페이스를 구현해보자. 1234class SomeObject implements Serializable &#123; private String name; private String email;&#125; 간단하게 구현할 수 있다. 인터페이스의 메소드도 없으니 구현할 메소드도 필요 없다. 그냥 선언만 해주면 된다. 그럼 위에서 사용했던 writeObject() 메소드 안을 들여다 보자. writeObject() 메소드 안에는 writeObject0()가 존재한다. 이 메소드 맨 아래에 보면 다음과 같은 코드가 있다. 12345678910111213141516171819//... if (obj instanceof String) &#123; writeString((String) obj, unshared);&#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared);&#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared);&#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared);&#125; else &#123; if (extendedDebugInfo) &#123; throw new NotSerializableException( cl.getName() + \"\\n\" + debugInfoStack.toString()); &#125; else &#123; throw new NotSerializableException(cl.getName()); &#125;&#125;//... 이 코드에는 if문이 꽤 있다. 보면 String은 Serializable을 구현했으니 되고 배열도 Serializable 할 수 있고 Enum도 Serializable를 구현했으니 되고 다음으로는 Serializable가 되어있는지 체크하는 부분이다. 만약 Serializable가 없다면 에러로 처리한다. 위에서 보았듯이 간단하게 Serializable가 선언되었는지 안되어 있는지 체크 정도만한다. 실질적으로 뭘 하는 건 아니다. 그래서 마커 인터페이스라고 부른다. 마커 인터페이스는 어노테이션으로도 대체 가능하다. 만약 @SomeAnnotation이라는 어노테이션이 있다면 아래와 같이 가져와서 체크하면 된다. 1final SomeAnnotation someAnnotation = someObject.getClass().getAnnotation(SomeAnnotation.class); 그럼 마커 인터페이스와 마커 어노테이션의 차이를 살펴보자. 마커 인터페이스 같은 경우에는 컴파일 시점에 발견할 수 있다는 큰 장점이 있다. 그리고 또한 적용 범위를 좀 더 세밀하게 지정할 수 있다. 만약 어노텡션 자료형을 선언할 때 target에 ElementType.TYPE라고 지정해서 사용한다고 하면 ElementType.TYPE은 클래스 뿐만 아니라 인터페이스에도 적용 가능하다. 그런데 특정한 인터페이스를 구현한 클래스에만 적용할 수 있어야 하는 마커가 필요하다고 가정해보자. 마커 인터페이스를 쓴다면 그 특정 인터페이스를 상속하도록 선언만 하면 된다. 그럼 마커를 상속한 모든 자료형은 자동으로 그 특정 인터페이스의 하위 자료형이 된다. 그렇다면 마커 어노테이션의 장점은 뭘까? 마커 어노테이션은 유연하게 확장이 가능하다. 어노테이션을 만들어 사용한 뒤에도 계속적으로 더 많은 정보를 추가할 수 있는 것이 큰 장점이다. 예를 들어, 어떤 어노테이션을 만들고 배포를 한 뒤에 뭔가 더 정보를 추가하고 싶다면 새로 추가된 요소들에 대해 default 값을 갖게 하면 하위 호환성도 지킬 수 있으면 처음에는 마커 어노테이션으로 시자갷ㅆ다가 나중에는 기능이 많은 어노테이션으로 진화 가능하다. 하지만 인터페이스 경우에는 메소드를 만드는 순간 하위 호환성이 깨지므로 마커 어노테이션처럼 지속적인 진화는 불가능하다. 마커 어노테이션과 마커 인터페이스 중 둘 중 어느게 낫다고 할 수 없다. 각각의 쓰임새가 다르기 때문이다. 위에서 언급했듯이 새로운 메소드가 없이 자료형을 정의하고 싶다면 마커 인터페이스를 이용해야 하고 클래스나 인터페이스 이외의 마커를 달아야 하고 앞으로도 더 많은 추가 정보가 있다고 생각하면 마커 어노테이션을 사용하면 된다. 참고 자바의 마커 인터페이스","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] Reflection","slug":"Java-What-is-Reflection","date":"2019-01-04T06:14:43.000Z","updated":"2020-04-22T07:46:59.192Z","comments":true,"path":"2019/01/04/Java-What-is-Reflection/","link":"","permalink":"https://woovictory.github.io/2019/01/04/Java-What-is-Reflection/","excerpt":"","text":"안드로이드 개념을 공부하던 중 직렬화라는 개념에 대해서 공부를 했다. 직렬화란 메모리에 올라가 있는 정보를 byte 단위의 코드로 나열하는 것이다. 이를 통해서 객체와 같은 정보를 전달할 수 있게 하는 것이다. 직렬화를 가능하게 하는 방법 중에는 Serializable과 Parcelable을 구현하는 2가지 방법이 존재한다. 그 중 Serializable은 구현은 상당히 쉬우나 속도가 느리다는 단점이 있다. 속도가 느린 이유는 내부적으로 Reflection을 사용하기 때문에 필요없는 쓰레기 객체들을 만들어내고 이를 제거하기 위해 GC가 동작해서 비용이 발생하게 된다. 그렇다면 여기서 말하는 Reflection은 무엇일까?? Reflection 객체를 통해 클래스의 정보를 분석해 내는 프로그래밍 기법을 말한다. 리플렉션은 구체적인 클래스 타입을 알지 못해도 컴파일된 바이트 코드를 통해 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해주는 자바 API를 말한다. 이게 무슨 의미일까? 구체적인 클래스 타입을 알지 못하면 메소드를 실행할 수 없나? 아래 코드를 살펴보자. 123456789101112public class Car&#123; public void drive()&#123; // Do anything. &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Object car = new Car(); car.drive(); // 컴파일 에러 &#125;&#125; 위에 코드 블록에서 컴파일 에러가 나는 이유는 모든 클래스의 조상 클래스인 Object라는 타입으로 Car 클래스의 인스턴스를 담을 수는 있지만 사용 가능한 메소드는 Object의 메소드와 변수들 뿐이기 때문이다. 그러니까 car 인스턴스의 메소드는 사용하지 못하는 것이다. 이런 식으로 구체적인 타입의 클래스를 모를 때 사용하는게 리플렉션이다. 그렇다면 또 의문이 생긴다. 역시 의문을 가지는 것은 아주 좋다. 내가 만드는 프로그램의 코드 흐름인데, 내가 사용할 클래스의 타입과 이름을 모르는 경우가 있을까? 그렇다. 일반적으로는 만나기 힘든 경우이다. 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르는 경우가 있다. 내가 지금 작성하는 코드가 나중에 어떤 기능이 추가되어서 어떻게 필요에 따라 사용될지 모르는 경우 같은 것이다. 이럴 때는 실행할 시점, 그러니까 런타임에 지금 실행되고 있는 클래스를 가져와서 실행을 해야 되는 것이다. 즉, 설계할 때는 사용될 클래스가 어떤 타입인지 모르지만 리플렉션을 이용해서 코드를 일단 작성하고 실행 시점에 확인해서 활용할 수 있도록 하는 메커니즘이다. 그렇다면 어떻게 이게 가능한 것일까?? 자바 클래스 파일은 바이트 코드로 컴파일 되어 static한 영역에 위치하게 된다. 때문에 클래스 이름만 알고 있다면 언제든, 이 영역을 뒤져서 클래스에 대한 정보를 가져올 수 있는 것이다. 아래는 가져올 수 있는 정보들이다. ClassName Clas Modifiers(public, private, synchronized 등) Package Info Superclass Implemented Interfaces Constructors MethodsFields Annotations 간단한 예제 String 클래스의 풀패스를 통해 String이 가지고 있는 모든 메소드를 출력하는 간단한 예제이다. 12345678try &#123; Class c = Class.forName(\"java.lang.String\"); Method m[] = c.getDeclaredMethods(); for (int i = 0; i &lt; m.length; i++) System.out.println(m[i].toString());&#125; catch (Throwable e) &#123; System.err.println(e);&#125; 리플렉션을 사용하기 위한 3가지 스텝 클래스 Class 객체를 얻는다. 123Class c1 = Class.forName(\"java.lang.String\");Class c2 = int.class;Class c3 = Integer.Type; getDeclaredMethods()와 같은 메소드를 호출하여 클래스 내에 정의된 메소드를 모두 가져올 수 있다. 1Method[] m = c1.getDeclaredMethods(); 리플렉션 API를 사용하여 정보를 조작 및 얻기. 123Class c = Class.forName(\"java.lang.String\");Method m[] = c.getDeclaredMethods();System.out.println(m[0].toString()); 첫번째 메소드의 이름을 출력하게 된다. 사용해보기 instanceof 연산자 모의실험 해보기 클래스 정보를 얻고 나면 클래스 객체에 대한 정보도 얻을 수 있다. Class.isInstance 메소드는 instanceof 연산자를 시뮬레이팅 할 수 있다. 12345Class cls = Class.forName(\"java.lang.String\");boolean b1 = cls.isInstance(3);Log.e(TAG, \"b1=\"+b1);//b1=falseboolean b2 = cls.isInstance(\"Test\");Log.e(TAG, \"b2=\"+b2);//b2=true b1에는 String 클래스인 cls가 3과 같은 타입이 아님을 알려주고 b2에는 String 클래스인 cls가 Test와 같은 타입임을 알려준다. 클래스의 메소드 찾기 리플렉션의 가장 기본적이고 가장 주용한 사용범 중 하나가 바로 클래스에 정의된 메소드를 찾는 것이다. 메소드를 찾는 것 뿐만 아니라 메소드가 가지고 있는 파라미터 타입, Exception 타입, 반환 타입 등을 알아낼 수 있다. 12345678910111213141516171819202122232425try &#123; Class cls = Class.forName(\"java.lang.String\"); Method methods[] = cls.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; Log.e(TAG, \"메소드 이름 = \" + m.getName()); Log.e(TAG, \"정의된 클래스이름 = \" + m.getDeclaringClass()); Class pvec[] = m.getParameterTypes(); for (int j = 0; j &lt; pvec.length; j++) &#123; Log.e(TAG, \"인자 #\" + j + \" \" + pvec[j]); &#125; Class evec[] = m.getExceptionTypes(); for (int j = 0; j &lt; evec.length; j++) &#123; Log.e(TAG, \"익셉션 #\" + j + \" \" + evec[j]); &#125; Log.e(TAG,\"return type = \" + m.getReturnType()); Log.e(TAG,\"-----\"); &#125;&#125;catch (Throwable e) &#123; Log.e(TAG,e.toString());&#125; 생성자 정보 얻기 메소드를 찾는 방법과 비슷하다. 참고로 생성자는 반환 타입이 없다. 1234567891011121314151617181920try &#123; Class cls = Class.forName(\"java.lang.String\"); Constructor ctorlist[] = cls.getDeclaredConstructors(); for (int i = 0; i &lt; ctorlist.length; i++) &#123; Constructor ct = ctorlist[i]; Log.e(TAG,\"생성자 이름 = \" + ct.getName()); Log.e(TAG,\"정의된 클래스이름 = \" + ct.getDeclaringClass()); Class pvec[] = ct.getParameterTypes(); for (int j = 0; j &lt; pvec.length; j++)&#123; Log.e(TAG,\"param #\" + j + \" \" + pvec[j]);//생성자 파라미터 &#125; Class evec[] = ct.getExceptionTypes(); for (int j = 0; j &lt; evec.length; j++)&#123; Log.e(TAG,\"exc #\" + j + \" \" + evec[j]);//익셉션 타입 &#125; Log.e(TAG,\"-----\"); &#125;&#125;catch (Throwable e) &#123; Log.e(TAG,e.toString()); 클래스 필드 찾기 클래스에 정의된 데이터 필드 또한 찾는게 가능하다. 접근 제어자(modifier)를 알 수 있다. 그리고 private 필드도 찾을 수 있다. 12345678910111213141516try &#123; Class cls = Class.forName(\"java.lang.String\"); Field fieldlist[] = cls.getDeclaredFields(); for (int i = 0; i &lt; fieldlist.length; i++) &#123; Field fld = fieldlist[i]; Log.e(TAG,\"필드명 = \" + fld.getName()); Log.e(TAG,\"정의된클래스 = \" + fld.getDeclaringClass()); Log.e(TAG,\"필드타입 = \" + fld.getType()); int mod = fld.getModifiers(); Log.e(TAG,\"접근제어자 = \" + Modifier.toString(mod)); Log.e(TAG,\"-----\"); &#125;&#125;catch (Throwable e) &#123; Log.e(TAG,e.toString());&#125; 메소드 이름으로 실행하기 메소드 이름으로 특정 메소드를 실행하는 것이다. 123456789101112131415try &#123; Class cls = Class.forName(\"java.lang.String\"); String data = \"Hello World\";//테스트용 데이터 Method lengthMethod = cls.getMethod(\"length\");//length()메소드를 찾는다. int length = (int) lengthMethod.invoke(data);//data.length() 수행 Log.e(TAG, \"length=\" + length); //length=11 출력 Method substringMethod = cls.getMethod(\"substring\", int.class, int.class); //두개의 int타입이 있는 substring메소드를 가져옵니다. String subStr = (String) substringMethod.invoke(data,0, 5); //data.substring(0,5)와 같은 효과 Log.e(TAG,\"subStr=\"+subStr);//Hello 출력&#125; catch (Throwable e) &#123; Log.e(TAG, e.toString());&#125; 자 그러면 의문이 생긴다. 앞에서 private한 메소드도 찾았는데 실행은 못시킬까?? 결론부터 말하자면 가능하다. 1234567public class A&#123; public static final String TAG = A.class.getSimpleName(); public void show()&#123; Log.e(TAG,\"Hello I am Private method\"); &#125;&#125; 123456789try &#123; A a = new A(); //메소드가 private하여 a.show() 찾을 수가 없음 Method showMethod = a.getClass().getDeclaredMethod(\"show\"); showMethod.setAccessible(true); //접근 가능! showMethod.invoke(a);&#125;catch (Exception e)&#123; Log.e(TAG,e.toString());&#125; 위에서 A라는 클래스에서 private한 메소드인 show()를 선언하면 다른 클래스에서는 이 클래스로 만든 인스턴스로는 show() 메소드에 접근이 불가능하다. 하지만 리플렉션은 이를 가능하게 해준다. getMethod() 메소드는 public한 메소드를 가지고 오며, getDeclaredMethod()는 private한 메소드를 포함한 클래스에 선언된 모든 메소드를 가지고 온다. setAccessible을 true로 설정하여 private한 메소드에 접근할 수 있다. 리플렉션으로 오브젝트 생성하기 리플렉션으로 오브젝트를 생성하는 예는 아래와 같다. 12345678910111213141516public class Person &#123; public static final String TAG = Person.class.getSimpleName(); String name; int age; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public void sayMyName()&#123; Log.e(TAG,String.format(\"Hello! My name is %s and I'm %d years old\",name, age) ); &#125;&#125; 1234567891011try &#123; Class personClass = Class.forName(\"com.charlezz.reflection.Person\"); Constructor personConstructor = personClass.getConstructor(String.class, int.class); Person person = (Person) personConstructor.newInstance(\"Charles\",20); person.sayMyName(); //Hello! My name is Charles and I'm 20 years old 출력&#125;catch (Throwable e) &#123; Log.e(TAG,e.toString());&#125; Constructor.newInstance를 이용하여 new 생성자와 같이 객체를 생성할 수 있다. 필드의 값 변경하기 필드의 값 또한 리플렉션을 이용한다면 변경시킬 수 있다. 1234567891011try &#123; Class cls = Class.forName(\"com.charlezz.reflection.Person\"); Field ageField = cls.getField(\"age\"); Person person = new Person(\"Charles\", 20); Log.e(TAG,\"person.age = \" + person.age);//person.age = 20 ageField.setInt(person, 10); Log.e(TAG,\"person.age = \" + person.age);//person.age = 10&#125;catch (Throwable e) &#123; Log.e(TAG,e.toString());&#125; set~~() 메소드를 이용하여 필드의 값을 변경시킬 수 있다. 결론 실제로 리플렉션은 비용이 큰 작업이므로 신중하게 사용해야 한다. 나는 안드로이드 애플리케이션 개발을 하면서 리플렉션을 사용해 본 적은 없지만 이렇게 개념적인 부분을 알게 되어서 너무 좋았다. 참고할 자료들이 많아서 개념을 잘 잡을 수 있었다. 참고 자바의 리플렉션 안드로이드와 Java의 Reflection","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Reflection","slug":"Reflection","permalink":"https://woovictory.github.io/tags/Reflection/"}]},{"title":"[디자인패턴] 싱글톤 패턴","slug":"Android-What-is-Singleton-Pattern","date":"2019-01-03T15:35:28.000Z","updated":"2020-05-12T11:32:54.963Z","comments":true,"path":"2019/01/04/Android-What-is-Singleton-Pattern/","link":"","permalink":"https://woovictory.github.io/2019/01/04/Android-What-is-Singleton-Pattern/","excerpt":"","text":"싱글톤 패턴 싱글톤 패턴은 애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴을 말한다. 생성자가 여러번 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.[자바에서는 생성자를 private으로 선언해서 생성 불가능하게 하고 getInstance()로 받아서 사용한다.] 따라서, 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이라고 말할 수 있다. (인스턴스가 필요할 때 똑같은 인스턴스를 만들어 내는 것이 아니라, 동일(기존) 인스턴스를 사용하게 한다.) 싱글톤 패턴을 쓰는 이유 고정된 메모리 영역을 얻으면서 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지할 수 있다. 또한 싱글톤으로 만들어진 클래스의 인스턴스는 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉽다. DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러 개 생성해서 사용해야 하는 상황에서 많이 사용한다. (쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등) 안드로이드 앱 같은 경우 각 액티비티나 클래스별로 주요 클래스들을 일일이 전달하기가 번거롭기 때문에 싱글톤 클래스를 만들어 어디서나 접근하도록 설계하는 것이 편하다. 인스턴스가 절대적으로 한개만 존재하는 것을 보증하고 싶은 경우 사용. 두 번째 이용시부터는 객체 로딩 시간이 현저하게 줄어 성능이 좋아지는 장점. 싱글톤 패턴의 문제점 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 개방-폐쇄 원칙을 위배하게 된다.(= 객체지향 설계 원칙에 어긋난다.) [객체 지향 설계 원칙 찾아보기] 따라서 수정이 어려워지고 테스트하기도 어려워진다. 또한 멀티 쓰레드 환경에서 동기화 처리를 안하면 인스턴스가 두 개가 생성된다던지 하는 경우가 발생할 수 있다. 즉, 싱글톤이 Thred-safe 하지않을 수 있다. 불필요한 오버헤드가 생길 수 있다. 멀티쓰레드에서 안전한(Thred-safe) 싱글톤 클래스, 인스턴스 만드는 방법 1. Thread safe Lazy initialization(게으른 초기화) 12345678910111213141516public class SingleTon&#123; private static SingleTon instance; private SingleTon()&#123; // private한 생성자 &#125; public static synchronized SingleTon getInstance()&#123; if(instance == null)&#123; instance = new SingleTon(); &#125; return instance; &#125; &#125; 위의 방식은 private static으로 인스턴스 변수를 만들고 private 생성자로 외부에서 생성할 수 있는 여지를 막았으며 synchronized 키워드를 사용해서 thread-safe하게 만들었다. 하지만 synchronized 특성상 비교적 큰 성능 저하가 발생하므로 권장하는 방법은 아니다. synchronized 키워드는 100배 정도 성능 저하를 가져온다고 한다. 때문에 싱글톤 패턴으로 만들어진 클래스의 인스턴스에 volatile 키워드를 사용하여 멀티 쓰레드의 가시성 문제를 해결하여 모든 객체에 대해 synchronized 키워드가 불리는 것을 막아 성능을 향상시킨다. 2. Thread safe lazy initialization + Double-checked locking 게으른 초기화의 성능 저하를 완화시키는 방법 123456789101112131415161718public class SingleTon &#123; private volatile static SingleTon instance; private SingleTon()&#123;&#125; public static SingleTon getInstance()&#123; if(instance == null)&#123; synchronized (SingleTon.class) &#123; if(instance == null) instance = new SingleTon(); &#125; &#125; return instance; &#125;&#125; getInstance()에 synchronized를 사용하는 것이 아니라 첫 번째 if문으로 인스턴스의 존재 여부를 체크하고 두 번째 if문에서 다시 한 번 체크할 때 동기화시켜서 인스턴스를 생성하므로 thread-safe하면서도 처음 생성 이후에 synchronized 블록을 타지 않기 때문에 성능 저하를 완화했다. 이렇게 volatile 키워드를 사용하는 것과 두 번 체크하는 기법을 double-checked locking이라고 한다. 그러나 완벽한 방법은 아니다. 이 방법은 메소드에서 synchronized를 빼면서 동기화 오버헤드를 줄여보고자 하는 의도로 설계된 방법이다. instance가 null인지 체크하고 null일 경우에만 동기화 블록에 진입하게 된다. 그래서 최초 객체가 생성된 이후로는 동기화 블록에 진입하지 않기 때문에 효율적인 방법이라고 생각할 수 있다. 하지만 아주 안좋은 케이스로 정상 동작하지 않을 수 있다. 예를 들어, Thread A와 Thread B가 있다고 하자. Thread A가 instance의 생성을 완료하기 전에 메모리 공간에 할당이 가능하기 때문에(static이기 때문에 Class가 로딩될 때 메모리에 할당됨) Thread B가 할당된 것을 보고 instance를 사용하려고 하나 생성과정이 모두 끝난 상태가 아니기 때문에 오동작할 수 있다는 것이다. 물론 이런 확률은 적겠지만 혹시 모를 문제를 생각하여 사용하지 않는 것이 좋다. 3. Initialization on demand holder idiom (holder에 의한 초기화) 클래스안에 클래스(Holder)를 두어 JVM의 Class loader 매커니즘과 Class가 로드되는 시점을 이용한 방법이다. 123456789101112public class Something &#123; private Something() &#123; &#125; private static class LazyHolder &#123; public static final Something INSTANCE = new Something(); &#125; public static Something getInstance() &#123; return LazyHolder.INSTANCE; &#125;&#125; 개발자가 직접 동기화 문제에 대해 코드를 작성하고 문제를 회피하려 한다면 프로그램 구조가 그만큼 복잡해지고 비용 문제가 생길 수 있고 특히 정확하지 못한 경우가 많다.(100%가 아닐 수 있다…ㅎ) 그런데 위의 3번 방법은 JVM의 클래스 초기화 과정에서 보장되는 원자적 특성을 이용하여 싱글톤의 초기화 문제에 대한 책임을 JVM에게 떠넘긴다. holder 안에 선언된 INSTANCE가 static이기 때문에 클래스 로딩 시점에 한번만 호출될 것이며 final 키워드를 사용해 다시 값이 할당되지 않도록 만든 방법이다. 로직을 설명하면 다음과 같다. 위의 Something 클래스에는 LazyHolder 클래스의 변수가 없기 대문에 Something 클래스 로딩시 LazyHolder 클래스를 초기화하지 않는다. LazyHolder 클래스는 Something 클래스의 getInstance() 메소드에서 LazyHolder.INSTANCE를 참조하는 순간 Class가 로딩되며 초기화가 진행된다. Class를 로딩하고 초기화하는 시점은 thread-safe를 보장하기 때문에 volatile이나 synchronized 같은 키워드가 없어도 thread-safe 하면서 성능도 보장하는 아주 훌륭한 방법이라고 할 수 있다. 가장 많이 사용하고 일반적인 방법이다. Java volatile이란?? 멀티 쓰레드 환경에서 싱글톤을 문제 없이 구현하는 방법 중에 하나로 나왔던 Double-checked locking 즉, DCL 방법이 있었다. 물론 좋은 방법은 아니었지만 여기서 나온 volatile라는 키워드가 궁금했다. Java volatile이란? volatile 키워드는 Java 변수를 Main Memory에 저장하겠다라는 것을 명시하는 것이다. 매번 변수의 값을 Read할 때마다 CPU cache에 저장된 값이 아닌 Main Memory에서 읽는 것이다. 또한 변수의 값을 Write할 때마다 Main Memory에까지 작성하는 것이다. 왜(Why) 필요할까? volatile 변수를 사용하고 있지 않는 멀티 쓰레드 애플리케이션에서는 Task를 수행하는 동안 성능 향상을 위해서 Main Memory에서 읽은 변수 값을 CPU cache에 저장하게 된다. 만약에 멀티 쓰레드 환경에서 Thread 변수 값을 읽어올 때 각각의 CPU에 저장된 값이 다르기 때문에 변수 값 불일치 문제가 발생하게 된다. Example SharedObject를 공유하는 두 개의 Thread가 있다. Thread-1는 counter 값을 더하고 읽는 연산을 한다.(Read&amp;Write) Thread-2는 counter 값을 읽기만 한다.(Only Read) 123public class SharedObject&#123; public int counter = 0;&#125; Thread-1는 counter 값을 증가시키고 있지만 CPU cache에만 반영되어 있고 실제로 Main Memory에는 반영이 되지 않는다. 그렇기 때문에 Thread-2는 counter 값을 계속 읽어오지만 0을 가져오는 문제가 발생한다.(변수 값의 불일치 문제) 어떻게(How) 해결할까?? volatile 키워드를 추가하게 되면 Main Memory에 값을 저장하고 읽어오기 때문에 변수 값 불일치 문제를 해결할 수 있다. 123public class SharedObject&#123; public volatile int counter = 0;&#125; 이러한 volatile 키워드는 멀티 쓰레드 환경에서 하나의 Thread만 read&amp;write 하고 나머지 Thread가 read하는 상황에서 가장 최신의 값을 보장한다. 그렇다면 항상 volatile이 옳은 방법일까?? 아래의 예시를 확인해보자. Thread-1이 값을 읽어 1을 추가하는 연산을 진행한다. 추가하는 연산을 했지만 아직 Main Memory에 반영되기 전 상황이다. Thread-2이 값을 읽어 1을 추가하는 연산을 진행한다. 추가하는 연산을 했지만 아직 Main Memory에 반영되기 전 상황이다. 두 개의 Thread가 1을 추가하는 연산을 하여 최종 결과가 2가 되어야 하는 상황이지만 각각 결과를 Main Memory에 반영하게 된다면 1만 남는 상황이 발생하게 된다. 하나의 Thread가 아닌 여러 Thread가 write하는 상황에서는 적합하지 않다. 여러 Thead가 write하는 상황이라면 synchronized를 통해 변수 read &amp; write의 원자성(atomic)을 보장해야 한다. volatile 성능은? volatile는 변수의 read와 write를 Main Memory에서 진행하게 된다. CPU cache보다 Main Memory가 비용이 더 크기 때문에 변수 값 불일치를 보장해야 하는 경우에만 volatile를 사용하는 것이 좋다. 요약 volatile : Main Memory에 값을 read &amp; write 하는 키워드 상황? 하나의 Thread만 write하고 나머지 Thread가 read하는 상황인 경우 변수의 값이 최신의 값으로 읽어와야 하는경우(최신의 값을 보장) 주의할 점 : 성능에 어느 정도 영향을 줄 수 있다. 이유 : CPU cache보다 Main Memory 접근이 비용이 더 크기 때문이다. 참고 싱글톤 패턴(Singleton pattern)을 쓰는 이유와 문제점 Multi Thread 환경에서의 올바른 Singleton http://superfelix.tistory.com/83 Java volatile이란?","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://woovictory.github.io/categories/Design-Pattern/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"https://woovictory.github.io/tags/Singleton/"}]},{"title":"[안드로이드] 직렬화에 관해서","slug":"Android-What-is-serialization","date":"2019-01-03T12:46:29.000Z","updated":"2020-03-01T10:26:20.650Z","comments":true,"path":"2019/01/03/Android-What-is-serialization/","link":"","permalink":"https://woovictory.github.io/2019/01/03/Android-What-is-serialization/","excerpt":"","text":"직렬화란? 역직렬화란? Serializable Parcelable 직렬화란? 직렬화는 메모리 내에 존재하는 정보를 보다 쉽게 전송 및 전달하기 위해 byte 코드 형태로 나열하는 것이다. 여기서 메모리 내에 존재하는 정보는 즉 객체를 말한다. JVM(Java Virtual Machine)의 메모리에 상주 되어있는 객체 데이터를 바이트 형태로 변환하는 기술 따라서 직렬화는 주로 객체들을 통째로 파일로 저장하거나 전송하고 싶을 때 사용한다. 나는 안드로이드 앱 개발을 할 때 액티비티간의 데이터를 전달할 때 인텐트를 사용하고 이 인텐트에 전달할 데이터를 추가한다. 복잡한 클래스의 객체를 이동하려는 경우에는 Serializable 또는 Parcelabe을 사용하여 직렬화하여 인텐트에 추가해서 데이터를 이동하면 된다. 역직렬화란? byte로 변환된 Data를 원래대로 Object나 Data로 변환하는 기술을 역직렬화라고 한다. 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태 Serializable Java에서는 Value Object를 쉽게 직렬화 하기위해 Serializable이라는 interface가 있다. 이는 Marker Interface로서 단순히 implement하는 것만으로도 JVM에게 직렬화가 가능하다는 것을 알려주기 때문에 사용하는게 매우 쉬운 편이다. Serializable은 Android SDK가 아닌 표준 Java의 인터페이스이다. 이 인터페이스를 구현한 클래스의 객체는 이제 한 액티비티에서 다른 액티비티로 이동할 준비가 된다. 다음 코드를 보자. 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.Serializable;public class Person implements Serializable &#123; private String firstName; private String lastName; private int age; public Person(String firstName, String lastName, int age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Serializable은 해당 클래스가 직렬화 대상이라고 알려주기만 할뿐 어떠한 메소드도 가지지 않는 단순한 마커 인터페이스이므로 사용자는 매우 쉽게 사용할 수 있다. 사용방법이 쉽다는 것은 곧 시스템적인 비용이 비싸다는 것을 의미한다. Serializable은 내부에서 Reflection을 사용하여 직렬화를 처리한다. Reflection은 프로세스 동작 중에 사용되며 처리 과정 중에 많은 추가 객체를 생성한다. 이 많은 쓰레기들은 가비지 컬렉터의 타깃이 되고 가비지 컬렉터의 과도한 동작으로 인하여 성능 저하 및 배터리 소모가 발생한다. Parcelable Parcelable은 직렬화를 위한 또 다른 인터페이스이다. Serializable과는 달리 표준 Java가 아닌 Android SDK의 인터페이스이다. Parcelabledms Reflection을 사용하지 않도록 설계되엇다. Serializable과는 달리 직렬화 처리 방법을 사용자가 명시적으로 작성하기 때문에 자동으로 처리하기 위한 Reflection이 필요없다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import android.os.Parcel;import android.os.Parcelable;public class Person implements Parcelable &#123; private String firstName; private String lastName; private int age; public Person(String firstName, String lastName, int age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; &#125; public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.firstName); dest.writeString(this.lastName); dest.writeInt(this.age); &#125; protected Person(Parcel in) &#123; this.firstName = in.readString(); this.lastName = in.readString(); this.age = in.readInt(); &#125; public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel source) &#123; return new Person(source); &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;;&#125; 마커 인터페이스인 Serializable과는 달리 Parcelable은 구현해야 하는 필수 메소드를 포함하기 때문에 클래스에 보일러 플레이트 코드가 추가된다. 이는 클래스를 이해하기 어렵고 새로운 기능을 추가하기 힘들게 만든다. 또한 코드의 추가로 클래스가 복잡해질수록 유지 보수가 어려워지는 원인이 된다. Parcelable의 사용법은 조금 어렵다. 필수적으로 정의해야 하는 메소드가 두 가지가 있다. describeContent() Parcel\b 객체에 내용을 기술한다. FileDescriptor 같은 특별한 객체가 들어가면 이 부분을 통해서 알려줘야 한다. 보통은 0을 리턴한다. writeToParcel(Parcel out, int flag) 직렬화시 container 역할을 하는 Parcel안에 데이터를 넣는 작업을 한다. 이 두가지 메소드를 정의해야함과 동시에 CREATOR라는 static field(정적 필드)를 반드시 가지고 있어야 한다. 이는 선언과 동시에 초기화 되어야 한다. CREATOR 객체는 나중에 역직렬화 시 사용된다. CREATOR 구현에는 다음의 두 가지 메소드를 구현해야 한다. createFromParcel(Parcel source) parcel된 데이터를 다시 원래대로 객체로 변환시켜 주는 작업을 한다. newArray(int size) 전달하는 객체가 배열일 경우 즉, Parcel.createTypeArray()를 호출했을 때 불리며 배열을 다시 할당하기 위해 사용한다. parcelable은 이러한 분해와 조립을 돕는다. 이 과정에서 순서가 있고 직렬화될 변수들을 직접 세팅하여 빠른 속도를 낸다. Serializable이 시스템 비용을 발생한다면 Parcelable은 구현과 유지, 보수에 드는 사용자의 노력을 비용으로 지불해야 한다. Parcelable VS Serializable 인터넷에서는 Parcelable과 Serializable을 비교하는 정보들을 많이 찾을 수 있다. 인터넷에서 쉽게 접할 수 있는 접근법과 다른 접근법이 존재하기에 여기에 적으려고 한다. 이 글의 참고는 아래에 적어놓았다. Parcelable이 Serializable보다 빠르다. 많이 볼 수 있는 위의 결과는 Parcelable이 Serializable보다 10배 이상 빠르다는 것을 보여준다. 일부분도 그렇게 생각한다고 한다. 다른 의견 두번째 의견은 기본 사용법에 의한 Serializable은 Parcelable보다 느리다는 것이다. 이 말의 뜻을 잘 살펴보면 다음과 같다. Parcelable은 위에서 설명한 것처럼 하나의 클래스 객체만을 위한 특별한 사용자 정의 코드를 작성해야만 한다. 사용자가 정의한 코드의 도움으로 Parcelable은 Serializable과는 달리 쓰레기를 생성할 이유가 없고 그 결과 성능도 더 좋다. 그러나 기본 사용법에 의한 Serializable은 Java의 자동 직렬화 프로세스를 사용한다. 이 과정은 분명 Parcelable과 같은 수고로움은 없지만 처리 과정에서 많은 쓰레기를 만들어낸다. 따라서 더 나쁜 결과를 보여주게 된다. 지금부터 조금 다른 방법으로 Serializable을 사용해 볼 것이다. Serializable에서 자동으로 처리되는 직렬화 프로세스는 사용자가 구현한 writeObject(), readObject() 메소드로 대체될 수 있다. 사용자가 구현한 직렬화 메소드와 함께 Serializable 접근 방식을 사용하려면 다음의 메소드를 반드시 구현해야 한다. 12345678private void writeObject(java.io.ObjectOutputStream out) throws IOException; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException; 마치 Parcelable의 사용법처럼 Serializable의 writeObject()와 readObject() 메소드에는 해당 클래스에 맞는 처리 로직을 포함시킬 수 있다. 제대로 수행된다면 기본 사용법에 의한 Serializable 방식에서 발생하는 쓰레기가 더 이상 생성되지 않을 것이다. 이 글 원본 작성자가 테스트한 결과는 놀랍다고 한다. 특정 클래스 처리 로직을 구현한 Serializable은 Parcelable보다 쓰기 속도가 3배 이상, 읽기의 경우 1.6배 더 빠르다고 한다. 잠깐! 기본 사용법에 의한 Serializable보다 Parcelable이 빠르다고 했다. 그 이유를 살펴보면 Serializable은 내부적으로 리플렉션을 사용해서 이로 인해 많은 오브젝트 생성과 그에 따라 잦은 GC의 동작으로 인해 애플리케이션의 성능을 낮추는 배터리를 소모한다. 그렇다면 Parcelable은 왜 더 빠른 것일까?? Parcelable은 IPC(프로세스간 통신)을 이용하기 때문이다. 프로세스들 사이에서 서로 데이터를 주고 받는 것을 IPC라고 한다. 프로세스간의 메모리 영역은 서로 공유할 수 없기에 Parcelable 인터페이스는 커널 메모리를 통해 데이터를 다른 프로세스로 전달하는 통로를 만들어준다. 잠깐! 위에서 등장하는 보일러플레이트 코드는 무엇일까??? IT 업계에서 보일러 플레이트는 변경없이 재사용할 수 있는 저작품을 의미하며 보일러 플레이트 코드는 재사용이 가능한 코드를 의미한다. 이 보일러 플레이트라는 단어는 철강 업계에서 유래되었는데 증기 보일러 내에 사용되는 커다란 압연 강판을 보일러 플레이트라고 불었으며 “강철처럼 튼튼하다.” &quot;반복적으로 재사용이 가능할 정도로 강력하다&quot;라는 의미가 있다고 한다. 참고 [Java] writeObject 와 readObject 는 무엇인가? - 참고해야할 자료 즉, 추후 공부해야할 내용들 Android : Parcelable vs Serializable Parcelable vs Serializable , 정말 Serializable은 느릴까?","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"직렬화","slug":"직렬화","permalink":"https://woovictory.github.io/tags/직렬화/"},{"name":"Serializable","slug":"Serializable","permalink":"https://woovictory.github.io/tags/Serializable/"},{"name":"Parcelable","slug":"Parcelable","permalink":"https://woovictory.github.io/tags/Parcelable/"}]},{"title":"[안드로이드] Retrofit","slug":"Android-What-is-retrofit","date":"2019-01-03T09:14:23.000Z","updated":"2020-03-01T10:26:23.276Z","comments":true,"path":"2019/01/03/Android-What-is-retrofit/","link":"","permalink":"https://woovictory.github.io/2019/01/03/Android-What-is-retrofit/","excerpt":"","text":"안드로이드 통신 라이브러리 요약 저는 안드로이드 앱을 개발하면 서버와 통신을 하기 위해서 편리한 방법인 Retrofit은 사용했다. 하지만 이러한 편리함을 알기 전에 왜 이렇게 편리하게 사용하는지 살펴보아야 할 것 같다. 초기에 안드로이드에서의 통신이라면 HttpClient를 사용하는 것이었다. HttpClient라고 해도 DefaultHttpClient라고 불리는 Apache HTTP Client와 AndroidHttpClient라는 Http Client 변종 등이 사용되고 있었다. 하지만, HttpClient에는 몇 가지 버그가 있어 2011년에는 Google의 Android Develpoers의 블로그에서 HttpUrlConnection이 권장되고 나서 이쪽이 주로 사용되고 있었다. 그후, Volley는 사용법이 복잡했던 HttpUrlConnection의 대안으로 Google이 만들었다는 것도 있고 표준 라이브러리로 사용되었다. Square의 OkHttp도 인기가 높고, 많이 사용되어왔다. 하지만 Android 5.1에서 HttpClient가 Deprecated된 후, HTTPClient에 의존하는 Volley도 Deprecated되었다. Square에서 만들어진 라이브러리인 OkHttp와 그 래퍼인 Retrofit은 단 하나 선택 같은 상태가 되었다. Retrofit Retrofit은 OkHttp의 상위 구현체로 enqueue와 excute를 사용하여 동기, 비동기 처리를 지원한다. 이러한 비동기 처리를 쉽게 지원하는 volley, retrofit 중에 무엇을 사용할지 고민했으나 인터페이스 내에 어노테이션으로 HTTP 메소드를 정의하여 그 행위를 알아보기 쉽게 표현하여 가독성이 높은 Retrofit을 사용했다. 추가적으로 Retrofit은 플러그인 형태로 클라이언트와 직렬화를 위한 convert를 선택할 수 있어 유지보수에 편하다. 반면에 volley는 이미지 캐시, 요청에 우선순위를 부여하는 등 추가적인 기능이 있지만 직렬화를 직접 세팅해줘야하고 멀티파트 업로드 시에도 리퀘스트의 재정의가 필요하다. 이렇듯 추가적인 기능이 더 많은건 volley이지만 간편하고 유지보수에 능하며 좀 더 REST api에 적합한 라이브러리라 생각되어 Retrofit을 사용했다. Retrofit을 사용한 이유? 서버와 통신을 하려면 Http 통신을 해야한다. 기본적으로 HttpUrlConnection을 이용한 네트워크 통신이 있지만 매번 connection 설정, input / output stream 생성 및 할당 등 반복적인 작업이 발생한다. 이것을 도와주는 라이브러리가 Okhttp이다. 나는 Okhttp의 존재를 알기만 했고 사용해보지는 않았다. Retrofit의 장점은 속도, 편의성, 가독성이 있다. 가장 비교하기 좋은 Okhttp는 사용시 대개 Asynctask를 통해 비동기로 실행하게 되는데 Asynctask가 성능상 느리다는 이슈가 있었다. Retrofit에서는 Asynctask를 사용하지 않고 자체적인 비동기 실행과 스레드 관리를 통해 속도를 훨씬 빠르게 끌어올렸다. 약 3~10배 차이가 난다고 한다. 또한 Okhttp에서도 쿼리스트링, request, response 설정 등 반복적인 작업이 필요한데, Retrofit에서는 이런 과정을 모두 라이브러리에 넘겨서 처리하도록 하였다. 따라서 사용자는 함수 호출시에 파라미터만 넘기면 되기에 훨씬 작업량이 줄어들고 사용하기 편리하다. 마지막으로 가독성이 매우 좋다. interface 내에 annotation을 사용하여 호출할 함수를 파라미터와 함께 정의해놓고, 네트워크 통신이 필요한 순간에 구현없이 해당 함수를 호출하기만 하면 통신이 이루어지기에 코드를 읽기가 매우 편하다. Asynctask를 쓰지 않기에 불필요하게 코드가 길어질 필요도 없으며, 콜백 함수를 통해 결과가 넘어오도록 되어있어 매우 직관적인 설계가 장점이다. 네트워크 통신에 Volley라는 라이브러리도 있지만 몇가지 문제점이 있었다. StringRequest 생성시 파라미터 값을 encoding해주어야 하는 불편함과 통신 실패시 ErrorResponse 안에 ResponseBody가 담기지 않는 문제가 있다. 구현 방법 application 클래스를 상속받은 ApplicationController라는 클래스를 만들고 싱글톤으로 구현하여 onCreate() 내부에 레트로핏 빌더를 이용해 클라이언트와 컨버터를 설정하고 인터페이스를 선택한다. application 클래스를 상속받은 이유는? 메인 액티비티의 통신 부 이전에 retrofit에 대한 세팅을 하기 위해 상속받았다. application 클래스는 애플리케이션 컴포넌트들이 공통으로 사용하는 공유 클래스이다. 해당 클래스를 상속받아 구현한 클래스의 onCreate 메소드는 시스템의 진입점이 되어 가장 먼저 실행된다. 동기와 비동기란? 데이터를 받는 방식인 동기와 비동기. 이 둘의 개념에 대해서 알고 넘어가자. 동기(synchronous : 동시에 일어나는) 동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속인데, 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 즉시 주어져야 한다. 요청과 결과가 한 자리에서 동시에 일어남 A 노드와 B 노ㄷ 사이의 작업 처리 단위를 동시에 맞추겠다. 동기적 일처리 방식 : 순차적으로 일을 스스로 끝내 나가는 방식 비동기(Asynchronous : 동시에 일어나지 않는) 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을거라는 약속이다. 요청한 결과가 그 자리에서 결과가 주어지지 않는다. 노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다. 비동기적 일처리 방식 : 해야할 일을 위임하고 기다리는 방식 동기와 비동기는 상황에 따라서 각각의 장단점이 존재한다. 동기방식은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고, 비동기방식은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있다. 동기와 비동기 방식의 예는 아래의 블로그를 참고하자. 공부해서 남주자 참고 동기와 비동기의 개념과 차이 동기와 비동기 프로그래밍 (Asynchronous-synchronous)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Network","slug":"Network","permalink":"https://woovictory.github.io/tags/Network/"},{"name":"Retrofit","slug":"Retrofit","permalink":"https://woovictory.github.io/tags/Retrofit/"}]},{"title":"[안드로이드] Image Loading Library","slug":"Android-ImageLoadingLibrary","date":"2019-01-03T06:19:02.000Z","updated":"2020-03-01T10:24:53.459Z","comments":true,"path":"2019/01/03/Android-ImageLoadingLibrary/","link":"","permalink":"https://woovictory.github.io/2019/01/03/Android-ImageLoadingLibrary/","excerpt":"","text":"앱을 만들면서 ImageView에 사진을 띄우고자 하는 경우가 많았다. 안드로이드 앱 안의 drawable 폴더의 리소스를 보여주는 경우 안드로이드 디바이스 안에 저장되어 있는 사진을 보여주는 경우(갤러리 혹은 기타 내부 사진) 이미지 URL을 로드해서 보여주는 경우 위의 1,2번 같은 경우는 안드로이드 기기 내부의 리소스를 불러오는 작업이므로 예외사항도 적고 실제 구현도 복잡하지 않다. 하지만 3번과 같은 경우는 http 클라이언트나 서버 통신을 이용해 ImageView에 보여주어야 하는 경우이다. 나는 이 같은 경우에서 Glide라는 라이브러리를 사용했는데, 사용할 때는 사용법이 쉬웠지만, 내부 동작이나 원리가 무엇인지 몰랐다. 그래서 Glide의 내부 동작 및 원리를 공부하고 이와 비슷한 Picasso와의 비교도 해보겠다. 기본 사용방법 기본적인 사용방법은 Picasso, Glide가 거의 똑같은 방식이다. Picasso 1Picasso.with(context).load(\"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg\").into(imageView) Glide 1Glide.with(context).load(\"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg\").into(imageView) 다만, with() 함수에서 Picasso는 Context만을 지원하는 반면에 Glide는 Context 뿐만 아니라 다른 객체들도 사용할 수 있다. 즉, Picasso에 비해서 Glide의 with() 함수가 더 많은 인자를 받아서 사용할 수 있어서 많은 곳에서 사용할 수 있다는 장점이 있다. Picasso Glide 기본 Bitmap 포맷 1920x1080의 이미지를 768x432 크기의 ImageView에서 각각 로드한 경우 보여지는 이미지는 아래와 같다. 그림을 잘 보면 Glide의 이미지 화질이 Picasso보다 좋지 않음을 확인할 수 있다. 이유는 Picasso는 Bitmap 포맷은 ARGB_8888로 사용하고 Glide는 Bitmap 포맷을 RGB_565를 사용한다. RGB_565는 ARGB_8888에 비해서 화질은 떨어지지만 메모리의 용량을 50% 적게 사용한다는 이점을 가지고 있다. 아래 그림은 Picasso와 Glide의 메모리 사용량을 비교한 그래프이다. (8MB 정도는 기본적으로 애플리케이션에서 사용하는 메모리 사용량이고 그 이상이 각각 이미지로딩 라이브러리에서 사용하는 메모리 사용량이다.) 만약 메모리 용량보다 이미지의 화질이 더 중요하다고 생각한다면 Picasso를 사용하거나 Glide의 Bitmap 포맷을 ARGB_8888로 변경하여 사용할 수 있다. 이는 GlideModule을 상속받는 클래스를 하나 지정해서 기본 포맷을 ARGB_8888로 설정하고 이 GlideModule을 매니페스트에 등록시켜주면 된다. CustomGlideModule.java 123456789101112131415public class SelphoneGlideModule implements GlideModule&#123; @Override public void applyOptions(Context context, GlideBuilder builder) &#123; // 포맷을 ARGB_8888로 변경 builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); &#125; @Override public void registerComponents(Context context, Glide glide) &#123; glide.register(SelphoneImage.class, InputStream.class, new SelphoneGlideUrlLoader.Factory()); &#125;&#125; AndroidManifest.xml 1234&lt;!-- Glide모듈을 Custom하게 변경 --&gt;&lt;meta-data android:name=\"kr.co.selphone.library.glide.SelphoneGlideModule\" android:value=\"GlideModule\" /&gt; 만약 Glide의 기본 Bitmap 포맷을 ARGB_8888로 변경했다면 Glide는 이전에 비해 2배 정도 더 많은 메모리를 사용하는 것을 확인할 수 있다. 이제는 같은 Bitmap 포맷을 사용하는데도 Picasso가 Glide보다 훨씬 많은 메모리 사용량을 보이고 있다.[왜 그럴까…?] 그 이유는 Glide와 Picasso의 캐시 정책이 다르기 때문이다. Picasso는 1920x1080 크기의 원본 이미지를 메모리로 가져와서 GPU에서 실시간으로 리사이징해서 768x432의 ImageView에 할당한다. 하지만 Glide는 바로 768x432크기로 이미지를 메모리로 가져와서 ImageView에 할당시키기 때문에 메모리 사용량이 적은 것이다. 만약, Picasso에서도 Glide와 같은 방식을 취하고 싶다면 resize() 함수를 이용하면 된다. 12345Picasso .with(context) .load(\"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg\") .resize(768,432) .into(imageView) ImageView의 크기를 매번 적어주기 번거롭거나 알아오기 귀찮다면 fit() 함수를 사용하면 같은 효과를 볼 수 있다. 12345Picasso .with(context) .load(\"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg\") .fit() .into(imageView) 위 방법을 사용할 경우 Picasso, Glide 모두 같은 메모리 사용량을 보일 것이다. 이미지 캐시 그 전에 캐싱은 명령어들과 데이터들을 기억장치 또는 캐시를 저장하는 디스크에 일시적으로 저장하는 기술을 말한다. 이미지를 캐시하는 방식에서도 기본적인 정책은 Glide와 Picasso가 다르다. 위의 예시처럼 1920x1080 이미지를 768x432 크기의 ImageView에 로드하는 경우 Glide는 768x432 크기의 이미를 캐시하는 반면, Picasso는 1920x1080의 원본 이미지를 캐시하게 된다. 만약 1920x1080 이미지를 다시 384x216 크기의 ImageVIew로 로드한다고 할 경우 Picasso는 이미 원본 이미지를 캐시해서 그대로 가지고 있지만 Glide는 또 하나의 384x216 크기의 이미지 파일을 캐시하게 된다. Glide는 같은 이미지를 다른 크기의 ImageView에 로드한다는 이유로 2번의 이미지 다운로드와 리사이징 작업이 필요하게 된다.(내 생각에는 비효율적이라고 생각한다.) 만약 Glide에서 원본 크기의 이미지를 캐시하도록 설정하고 싶은 경우 아래와 같이 캐시 정책을 추가해주면 된다. 12345Glide .with(context) .load(\"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg\") .diskCacheStrategy(DiskCacheStrategy.ALL) .into(imageView) 위의 정책을 적용하고 난 뒤부터는 모든 Glide를 이용하여 로드할 때 원본 이미지를 가져와서 캐시하게 된다. Glide는 이미지를 최대한 빨리 로드해주는데에 최적화 되어있기 때문에 이러한 정책을 기본적으로 적용하고 있다. 원본 이미지를 가져오는 정책과 이를 로드하는 속도는 반비례 관계에 있기 때문에 이미지 로딩 속도와 캐시에 관련해서는 원하는 방향에 맞게 설정해주면 좋다. 추가 함수 사용방법 비교 Resize 12345// Picasso.resize(300,200)// Glide.override(300,200) Center Crop 12345// Picasso.centerCrop()// Glide.centerCrop() PlaceHolder와 Error이미지 1234567// Picasso.placeHolder(R.drawable.placeholder).error(R.drawable.imageNot)// Glide.placeHolder(R.drawable.placeholder).error(R.drawable.imageNot) 한글이 포함된 URL처리 Picasso에서는 URL에 한글이 포함되어 있으면 ANR(Application Not Responsding)을 발생하며 앱을 종료시킨다. 그러나 Gliude는 URL에 한글이 포함되어도 아무 문제가 없다. Glide에서만 가능한 기능 GIF Glide에서는 ImageView에 GIF 파일을 로드할 수 있다. 하지만 GIF를 빈번하게 사용하면 많은 메모리 사용량을 보이기 때문에 적절하게 GIF를 사용해야 한다. Thumbnail 기능 용량이 큰 이미지의 경우 thumbnail() 함수를 이용하여 우선 10% 만큼만 가져와서 흐릿하게나마 먼저 보여주고 그 다음 전체 이미지를 로드해서 사용자에게 좀더 쾌적한 UI를 제공해줄 수 있다. [%는 사용자가 지정할 수 있다.] Custom Animation Picasso에서는 단순이 fade in 기능의 애니메이션만을 지원하는 반면, Glide에서는 .animate(ViewPropertyAnimation.Animator)을 이용하여 여러 애니메이션을 보여줄 수 있다. Custom load 기본적으로 Image Resource, URL, 휴대폰 내장 이미지를 로드하는 기능 외에도 Custom Model을 만들어서 이를 로드하는 기능도 지원하고 있다. 더 복잡한 내용 안드로이드에서 비트 맵 캐싱에 대한 부분은 까다롭다. 그래서 우리는 이미지의 비트맵 포맷을 편리하게 캐싱해주는 Glide를 사용한다. Glide도 비트 맵 캐싱에 관한 작업을 수행하므로 이와 관련있다. Glide는 디스크 캐시와 메모리 캐시를 사용한다. 잠깐! 이미지 로드 라이브러리 중에서 Fresco에 대해서 간단하게 알고 넘어가자. facebook에서 공개한 이미지 라이브러리. 널리 알려져 있는 UIL, Glide, Picasso 와 비교하여 가장 최근에 공개되었다. 다만, 아직 최근에 공개된 라이브러라서 레퍼런스가 많지 않고 Fresco의 ImageView를 사용해야한다는 것이 단점이다. 참고 [안드로이드/Android]Picasso와 Glide 비교분석 글라이드, 비트맵 캐싱 정책 안드로이드 이미지캐시(메모리캐시, 디스크캐시)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Glide","slug":"Glide","permalink":"https://woovictory.github.io/tags/Glide/"},{"name":"Picasso","slug":"Picasso","permalink":"https://woovictory.github.io/tags/Picasso/"}]},{"title":"[안드로이드] SP와 DP의 차이","slug":"Android-Diff-of-DP-SP","date":"2019-01-03T05:30:22.000Z","updated":"2020-03-01T10:29:10.467Z","comments":true,"path":"2019/01/03/Android-Diff-of-DP-SP/","link":"","permalink":"https://woovictory.github.io/2019/01/03/Android-Diff-of-DP-SP/","excerpt":"","text":"스크린의 실제 단위 PX px은 화면을 구성하는 최소 단위이다. px 단위는 화면의 전체 화면 크기와 상관없이 지정한 수치만큼 표시되는 절대적 표시 단위이므로 안드로이드에서는 px보다는 DP 단위를 사용하면 좋다. DPI DPI는 Dots Per Inch로 1인치에 들어가는 픽셀을 나타내는 단위이다. 예를 들어 100DPI는 1인치당 픽셀이 100개가 포함된다는 것을 의미한다. 개수가 많을수록 고밀도이며 안드로이드에서 주요 DPI는 아래와 같다. ldpi : 120dpi mdpi : 160dpi(기본) hdpi : 240dpi xhdpi : 320dpi xxhdpi : 480dpi xxxhdpi : 640dpi 안드로이드의 기준 DPI는 160DPI이다. 160 DPI인 경우 밀도 독립단위 DP와 PX이 같은 크기를 갖는다. 즉, 160DPI에서는 1dp는 1px이 된다. DP(Density-Independent Pixels)는 UI 레이아웃을 정의할 때 레이아웃 치수나 위치를 지정하기 위해 사용하는 단위이다. 픽셀 독립 단위이며 화면의 크기가 달라도 동일한 비율로 보여주기 위해 안드로이드에서 정의한 단위이며 큰 화면, 작은 화면에 상관없이 같은 크기로 나타난다. SP(Scale-Independent Pixels)는 UI 레이아웃을 정의할 때 텍스트의 크기를 지정하기 위해 사용하는 단위이다. 안드로이드 설정 화면에서 사용자는 안드로이스 시스템 전체에서 보여지는 텍스트의 크기를 선택하여 설정할 수 있는데 SP는 해당 설정에 영향을 받는다. 예를 들어, 시스템 설정에서 텍스트 크기를 &quot;최대 크케&quot;로 설정하게 되면 UI 레이아웃을 정의할 때 SP로 크기를 지정해놓은 TextView의 텍스트 크기가 영향을 받아 커진다. 반면에 TextView의 텍스트 크기를 DP로 설정하게 되면 시스템 설정의 텍스트 크기 값의 변화에 상관없이 일정한 크기를 유지한다. 그래서 디자인 명세에 따라서는 텍스트 크기의 값의 단위를 SP를 사용하는 것이 아니라 DP를 사용하는 것이 좋을 경우도 있을 것이다. 다시 말해, 언제나 일관성 있게 화면에서 똑같은 텍스트 크기를 표현하고자 하는 경우에는 SP가 아닌 DP 단위를 사용하도록 한다. 참고 [안드로이드] SP와 DP의 차이 초보 디자이너를 위한 안드로이드 DP(Dip), PX, DPI의 개념","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"DP","slug":"DP","permalink":"https://woovictory.github.io/tags/DP/"},{"name":"SP","slug":"SP","permalink":"https://woovictory.github.io/tags/SP/"}]},{"title":"[안드로이드] ListView vs RecyclerView","slug":"Android-Diff-of-ListView-and-RecyclerView","date":"2019-01-03T00:53:38.000Z","updated":"2020-05-06T02:36:28.980Z","comments":true,"path":"2019/01/03/Android-Diff-of-ListView-and-RecyclerView/","link":"","permalink":"https://woovictory.github.io/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/","excerpt":"","text":"신입 개발자를 위한 Repository를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다. 우리가 사용하는 앱 중에서 가장 많이 등장하는 것은 무엇일까?? 그 중의 하나는 바로 리스트라고 해도 과언이 아닐 것이다. 사용자에게 리스트 즉, 목록을 보여주는 것이 가장 많이 등장한다. 그렇다면 이 리스트를 구현하는 방법에는 무엇이 있을까?? ListView ListView는 이름에서도 알 수 있듯이 리스트 즉, 목록을 구현하는데 사용된다. ListView는 안드로이드에 임베디드 되어 있는 코드로 동작하며, API level 1부터 존재했다. 1234567891011121314151617@Overridepublic View getView(final int position, View convertView, ViewGroup parent) &#123; Holder holder = new Holder(); View rowView = inflater.inflate(R.layout.item_list, null); holder.tv = (TextView) rowView.findViewById(R.id.text); holder.img = (ImageView) rowView.findViewById(R.id.image); holder.tv.setText(result[position]); holder.img.setImageResource(imageId[position]); rowView.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Toast.makeText(context, \"You Clicked \" + result[position], Toast.LENGTH_LONG).show(); &#125; &#125;); return rowView;&#125; 위의 형태는 가장 일반적인 ListView의 getView() 접근 방법이다. 하지만 위와 같이 동작하게 되면 getView() 즉, ListView의 재사용성이 떨어지게 된다. 재사용이라는게 getView()는 현재 화면상에 아이템이 보일 때 호출되는 함수이다. 예를 들어, 아이템이 20개가 있고 이를 스크롤한다고 가정하면 스크롤 시에도 getView() 함수는 계속해서 호출된다. 12Holder holder = new Holder();View rootView = inflater.inflate(R.layout.item_list, null) 또한, 위의 코드는 별도의 null 처리가 없으므로 스크롤을 할 때마다 inflate를 통해서 View의 create가 발생하고 findViewById도 함께 호출된다. [이러한 부분들이 비효율적이다.] 리스트의 특성상 하나의 View만 있으면 이 View가 연속적으로 사용이 가능한 형태가 만들어지면 되는데 ListView는 이러한 것이 강제적이지 않아서 힘들다. 그래서 ViewHolder의 개념이 등장하게 된다. 구글의 권장 사항이라 강제적이지는 않다. 다만 위와 같이 inflate와 findViewById를 리스트뷰에서 연속적으로 발생시키면 메모리와 성능에 악영향을 미칠 수 있다. 그래서 ViewHolder 패턴을 사용하는 것을 권장한다. ListView에 ViewHolder 패턴을 적용한다면? 아래는 ViewHolder 패턴을 적용한 코드이다. convertView == null일 경우에만 inflate와 findViewById가 호출되어 view가 생성된다. 그리고 rootView의 setTag를 호출하여 생성된 ViewHolder를 임시 저장해둔다. 메모리에 문제가 없다면 최초 1회만 생성되고 이후 else 문을 통해서 getTag()를 호출하여 ViewHolder를 꺼내와서 ViewHolder에 접근이 가능한 형태가 만들어지게 된다. 1234567891011121314151617181920212223242526272829303132@Overridepublic View getView(final int position, View convertView, ViewGroup parent) &#123; // 최초에 convertView가 null이므로, inflate를 처리한다 if (convertView == null) &#123; // 전역으로 생성한 rootView에 inflate rootView = inflater.inflate(R.layout.item_list, null); // ViewHolder을 생성 Holder holder = new Holder(); holder.tv = (TextView) rowView.findViewById(R.id.text); holder.img = (ImageView) rowView.findViewById(R.id.image); // setTag : holder 임시 저장 rootView.setTag(holder); &#125; else &#123; // rootView에 convertView를 셋팅 rootView = convertView; // rootView에서 holder을 꺼내온다 holder = (Holder) rootView.getTag(); &#125; holder.tv.setText(result[position]); holder.img.setImageResource(imageId[position]); rowView.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Toast.makeText(context, \"You Clicked \" + result[position], Toast.LENGTH_LONG).show(); &#125; &#125;); return rootView;&#125; 위와 같이 구현하는 것이 ListView에 ViewHolder 패턴을 적용하는 것이라고 보면 된다. 하지만 강제적이지 않아서 구현하는 것이 귀찮은 작업이 된다. 그리고 커스텀이 많고 하나의 리스트에 다양한 ViewHolder를 만들기가 쉽지 않다. 예를 들면 다음과 같은 경우이다. 123사진이 포함된 ViewHolder텍스트만 있는 ViewHolder오른쪽이 스크롤 되는 ListView가 포함된 ViewHolder 물론 우리는 ViewHolder 패턴을 이해하고 만들면 괜찮지만, 대부분의 개발자들은 귀찮을 것을 싫어한다… ㅎㅎ [내 생각^.^] 그래서 구글은 귀찮음을 해소하기 위해 RecyclerView라는 것을 만들어서 내놓았다. ListView의 장/단점 장점 ListView는 간단하게 리스트를 만드는 부분에 있어서는 장점을 가지고 있다. [ex) 텍스트만 있는 리스트] 간단한 아이템 형태를 만드는 경우에는 빠르게 적용이 가능한 ArrayAdapter를 제공한다. 단점 아이템의 애니메이션 처리가 쉽지 않다. 리스트에는 한 개 이상의 View가 필요한 경우가 있지만 커스텀으로 작업하기 쉽지 않다. ViewHolder 패턴을 강제적으로 사용하지 않으므로 고비용의 findViewById가 매번 호출될 수 있다. RecyclerView 롤리팝(5.0) 버전이 ListView보다 유연하고 성능이 향상된 RecyclerView와 함께 발표되었다. 기존의 ListView는 커스터마이징 하기에 힘들었고, 구조적인 문제로 성능상의 문제도 있어다. RecyclerView는 ListView의 문제를 해결하기 위해 개발자에게 더 다양한 형태로 커스터마이징 할 수 있도록 제공되었다. RecyclerView와 ListView의 가장 큰 차이점은 LayoutManager와 ViewHolder 패턴의 의무적인 사용, Item에 대한 뷰의 변형이나 애니메이션할 수 있는 개념이 추가된 것이다. Create Lists creating Lists and Cards에 정의된 List 표현이다. widget인 RecyclerView는 LayoutManager를 통해서 View를 그리는 방법을 정의한다. RecyclerView.Adapter에서는 Data의 ViewHolder 정의에 따라서 UI가 선택되고 이를 표현하게 된다. 강제적인 ViewHolder의 적용으로 View의 재사용을 가능하게 해준다. 많은 데이터를 리스트 형태로 제공이 가능하다. RecyclerView.ItemAnimator을 이용하여 Item의 Animator를 이용할 수 있다. LayoutManager를 통해서 아이템의 배치 방법을 다양하게 적용할 수 있다. 주요 클래스 Adapter : 기존의 ListView에서 사용하는 Adapter와 같은 개념으로 데이터와 아이템에 대한 View 생성 ViewHolder : 재활용 View에 대한 모든 서브 뷰를 보유 LayoutManager : 아이템 항목을 어떻게 배치하는가를 결정 ItemDecoration : 아이템 항목에서 서브뷰에 대한 처리 ItemAnimation : 아이템 항목이 추가, 삭제되거나 정렬될 때 애니메이션 처리를 할 수 있다. Adapter 리스트뷰는 데이터가 어디서 왔느냐에 따라 BaseAdapter를 상속한 ArrayAdapter(배열로부터 데이터를 가져올 때 사용), CursorAdapter(DB로부터 데이터를 가져올 때 사용), SimpleAdapter(XMl 등으로부터 가져올 때 사용)를 구분하여 사용한다. 하지만 RecyclerView는 Universal한 Adapter를 사용하여 데이터 소스를 처리한다. 이것은 리싸이클러뷰의 유연성을 보여준다. 다음의 3가지 인터페이스를 구현해야 한다. onCreateViewHolder(ViewGroup parent, int viewType) : 뷰 홀더를 생성하고 뷰를 붙여주는 부분이다. onBindViewHolder(CustomViewHolder holder, int position) : 재활용 되는 뷰가 호출하여 실행되는 메소드, 뷰 홀더를 전달하고 어댑터는 position의 데이터를 결합시킨다. getItemCount() : 데이터의 개수 반환 getItemCount() -&gt; onCreateViewHolder() -&gt; onBindViewHolder() 순으로 호출된다. 리스트뷰가 사용했던 getView() 메소드는 매번 호출되면서 null 처리를 해주는 귀찮은 작업을 해줘야했다면, onCreateViewHolder는 새롭게 생성될 때만 호출된다. ViewHolder 리스트뷰에서는 뷰홀더 패턴을 권장했다. UI를 수정할 때마다 부르는 findViewById()를 뷰홀더 패턴을 이용해 한번만 호출함으로써 리스트뷰의 지연을 초래하는 무거운 연산을 줄여주었다. 이 문제를 리싸이클러뷰에서는 뷰홀더 패턴을 항상 사용하도록(강제하도록) 함으로써 해결했다. 하지만 실제로 앱의 퍼포먼스를 향상시켜주지만 최신의 디바이스는 뷰홀더 패턴을 사용하지 않은 리스트뷰나 리싸이클러뷰의 성능 차이는 미세하다. 단지 차이점은 리싸이클러뷰는 뷰홀더 패턴이 강제되는 것일 뿐이다. 이전의 리스트뷰는 선택적이었지만 성능 차이가 너무 컸기 때문에 변화된 것으로 생각된다. 간과하기 쉬운 중요한 점은 뷰홀더 패턴을 사용한 리스트뷰와 리싸이클러뷰의 성능은 같다. LayoutManager 리스트뷰는 수직 스크롤만 가능하다. 리스트뷰를 수평으로 사용할 수는 없었다. 그것을 구현하기 위한 몇가지 방법이 있지만 리스트뷰는 그렇게 동작하도록 디자인 되지 않았다고 한다. 그러나 이제 리싸이클러뷰에서는 수직뿐만 아니라 수평 스크롤 또한 지원한다. 뿐만 아니라 더 다양한 타입의 리스트들을 지원하고, 커스텀할 수 있도록 해준다. 많은 타입의 리스트를 사용학 위해서 LayoutManager를 사용하면 된다. LayoutManager의 종류 LinearLayoutManager Vertical(가로) / Horizontal(세로) 형태로 아이템을 배치한다. GridLayoutManager 한 줄에 1개 이상의 이미지를 표시할 수 있지만 아이템의 크기는 줄의 첫 번째 아이템의 크기에 따라서 달라질 수 있다.(고정시에는 모두 고정) StaggeredGridLayoutManager 그리드 형태의 아이템에 크기를 다양하게 적용할 수 있다. Custom LayoutManager 3개의 레이아웃 매니저를 상속받아 구현할 수 있다. Item Decoration 리스트뷰에서는 XML에 파라미터를 추가함으로써 쉽게 divide할 수 있었다. 리싸이클러뷰에서는 RecyclerView.ItemDecoration 클래스를 통해 divider를 원하는 아이템에 추가할 수 있도록 되었다. 조금 복잡해졌지만 동적인 데코레이팅이 가능해졌다. Item Animator Material Design에 대해 조명된 이후로 리스트에서의 애니메이션을 무궁무진한 가능성을 가지게 되었다. 리스트뷰에서는 아이템의 삽입이나 삭제에 특별한 애니메이션이 없었다. 하지만 리싸이클러뷰에서는 RecyclerView.ItemAnimator 클래스를 통해 애니메이션을 핸들링 할 수 있게 되었다. 이 클래스를 통해서 아이템의 삽입, 삭제, 이동에 대한 커스터마이징이 가능하고, 또한 DefaultItemAnimator가 제공되므로 커스터마이징이 필요 없이 사용할 수도 있다. notifyItemChanged(int position), notifyItemInserted(int position), notifyItemRemoved(int position)을 ItemAnimator을 통해 특정 아이템에 대한 애니메이션을 발생시킬 수 있습니다. 클릭 이벤트 처리 터치 이벤트를 통해 사용자가 아이템을 클릭했는지 롱클릭 했는지를 직접처리 RecycleView.OnItemTouchListener은 리싸이클러뷰의 터치 이벤트를 감지한다. 좀 복잡하지만 개발자에게 터치 이벤트를 인터셉트하는 제어권한을 주게 되었다. 안드로이드 공식 문서에서는 터치 이벤트를 인터셉트함으로서 리싸이클러뷰에게 전달하기 전에 조작함으로써 유용하게 사용될 수 있다고 한다.(ListView에서 아이템을 클릭시 콜백 받을 수 있는 리스너는 RecyclerViewd에는 존재하지 않음.) 즉, RecyclerView에는 Click 이벤트에 대한 처리를 자체적으로 할 수 없다. 그래서 onClickListener를 달아줘야 하는 문제가 발생한다. 내가 사용하는 방법으로는 RecyclerView를 사용하는 액티비티에서 View.OnClickListener를 상속받고 그 액티비티의 Context를 RecyclerView.Adapter에서 만든 함수에게 넘긴다. 이 함수는 액티비티에서 받은 Context(여기에 View.OnClickListener이 포함되어 있음)를 Adapter 클래스의 View.OnClickListener 타입의 변수인 ItemClick을 초기화한다. 123fun onItemClikc(l : View.OnClickListener)&#123; ItemClick = l&#125; 그러면 Adapter는 ClickListener 정보를 받아서 onCreateViewHolder에서 만든 View를 리턴하기 전에 그 View에게 onClickListener를 붙여주면 된다. 1234567override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): HomeFilterViewHolder &#123; var view = LayoutInflater .from(parent.context).inflate(R.layout.home_course_filter_list, parent, false) view.setOnClickListener(onItemClick) return HomeFilterViewHolder(view) &#125; DiffUtil DiffUtil은 데이터의 변화를 감지하여 뷰를 갱신하는 클래스이다. areItemsTheSame, areContentsTheSame, getChangedPayload 등을 오버라이딩하여 데이터간 변화를 감지한다. RecyclerView.Adapter에서 notifyItemMoved, notifyItemRangeChanged, notifyItemRangeInserted, notifyItemRangeRemoved 등이 호출되면 DiffUtil에서 해당 범위의 데이터의 변화를 감지하고 뷰를 선택적으로 갱신함으로써 비용이 큰 notifyDataSetChanged 대신 효율적으로 사용될 수 있다. 추가적인 DiffUtil 클래스의 메소드를 확인하고 싶다면 아래 글을 참고하자. about RecyclerView 정리 그럼 간단하게 ListView와 RecyclerView의 차이점을 표 형식으로 정리해서 보겠다. 아래의 표는 블로그를 참고했으며 참고 링크는 아래에 적어놓았다. 다음 세가지를 비교/정리 ListView 리스트뷰에서는 BaseAdapter를 상속받은 ArrayAdapter나 CursorAdapter 등을 사용한다. ViewHolder 패턴을 선택적으로 구현하기 때문에 구현하지 않는 경우 각각의 View를 그릴 때마다 findViewById()를 호출하기 때문에 성능 저하 문제가 발생한다. getView() 메소드에서 뷰를 그릴 때마다 findViewById()를 매번 호출하여 성능이 저하된다. ListView+ViewHolder 리스트뷰에서 ViewHolder 패턴을 구현한다면 성능에 관해서는 RecyclerView와 비슷하지만 기존의 ListView는 뷰 커스텀 작업에 대한 유연성이 떨어진다. RecyclerView 리싸이클러뷰는 ViewHolder 패턴의 사용을 강제하고 Adapter 클래스를 직접 구현하기 때문에 뷰 커스텀 작업에 대한 유연성이 ListView보다 더욱 쉽고 편하다. 참고 리사이클러 뷰 RecyclerView 정리 [안드로이드] RecyclerView란? (RecyclerView와 ListView 차이) [안드로이드] RecyclerView ( ListView와 차이 ) Android - ViewHolder 패턴","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"https://woovictory.github.io/tags/RecyclerView/"},{"name":"ListView","slug":"ListView","permalink":"https://woovictory.github.io/tags/ListView/"}]},{"title":"[안드로이드] SharedPreference","slug":"Android-SharedPreference","date":"2019-01-02T10:26:08.000Z","updated":"2020-03-01T10:27:01.355Z","comments":true,"path":"2019/01/02/Android-SharedPreference/","link":"","permalink":"https://woovictory.github.io/2019/01/02/Android-SharedPreference/","excerpt":"","text":"SharedPreference 간단한 값 저장에 DB를 사용하기에는 복잡하기 때문에 SharedPreference를 사용하면 적합하다. Key-Value 쌍으로 데이터를 저장한다. 간단한 데이터를 읽고 쓰기에 유용하다. 자동 로그인, 앱 초기 설정값, 다시보지 않기 등에 사용된다. 애플리케이션에 파일 형태로 저장된다. data/data/패키지명/shared_prefs/SharedPreference이름.xml 위치에 저장된다. 애플리케이션이 삭제되기 전까지 보존된다. 애플리케이션이 삭제되면 저장된 정보가 날라간다. 사용법 객체 생성 및 데이터 저장 1234567private val USER_NAME : String = \"Woo\"val pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)val editor : SharedPreference.Editor = pref.eidt()editor.putString(\"key\", \"value\")editor.putInt(\"intKey\",2)editor.commit() getSharedPreference() getSharedPreference() 함수를 통하여 SharedPreference 객체를 얻는다. 첫 번째 인자 USER_NAME은 해당 SharedPreference의 이름이다. 특정 이름으로 생성할 수 있고 해당 이름으로 xml 파일이 생성된다. 두 번째 인자는 mode이고 읽기/쓰기 권한과 관련된 mode라고 생각하면 된다. editor 객체 얻기 editor 객체를 통해서 데이터의 읽기, 쓰기 작업을 수행한다. 데이터 저장 putString() : key-value 형태로 데이터를 저장한다. 위에서는 intKey라는 key 값으로 2라는 int형 value를 저장하고 있다. 작업이 완료되었을 때는 반드시 editor.commit()을 수행한다. 데이터 꺼내오기 및 삭제하기 1234private val USER_NAME : String = \"Woo\"val pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)pref.getString(\"key\",\"\") 위의 코드에서는 getString()을 통해서 원하는 데이터를 Key 값을 이용해서 찾아 꺼낼 수 있다. 그리고 해당 Key로 저장된 값이 없다면 default로 지정한 &quot; &quot; 값이 꺼내지게 된다. 1234567private val USER_NAME : String = \"Woo\"val pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)val editor : SharedPreference.Editor = pref.eidt()pref.remove(\"key\")pref.clear()pref.commit() pref.remove() : Key값으로 삭제할 데이터를 찾아서 삭제한다. pref.clear() : USER_NAME으로 된 객체의 모든 정보(데이터)를 삭제한다. 이렇게 SharePreference를 사용하면 간단한 데이터를 저장하야 사용할 수 있고 자동 로그인과 같은 기능을 구현할 수 있다. 즉, 간단한 값을 저장하여 계속 유지되도록 하고 싶을 때 사용하기 좋다. 저는 SharedPreference를 Object 즉, static하게 만들어서 어디서든 접근할 수 있도록 사용하고 있다. 이렇게 구현해야 저장한 값을 어디서든 불러와서 사용할 수 있기 때문이다. 추가 - 객체 저장하기 12345678910111213// 데이터 저장var mPref : SharedPreference = getPreference(MODE_PRIVATE)var eidtor : SharedPreference.Editor = mPref.editor()var gson = Gson()var json : String = gson.toJson(MyObject) // gsont을 json 형식으로 변환editor.putString(\"MyObject\", json) // json 객체 저장editor.commit()// 데이터 꺼내오기var gson = Gson()var json : String = mPref.getString(\"MyObject\",\"\")var obj : MyObject = gson.fromJson(json, MyObject::class.java)// fromJson 함수를 통해서 json 객체를 꺼내와서 MyObject 클래스의 형태처럼 gson으로 저장한다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"SharedPreference","slug":"SharedPreference","permalink":"https://woovictory.github.io/tags/SharedPreference/"}]},{"title":"[안드로이드] 런타임 퍼미션","slug":"Android-Permission-MarshMellow","date":"2019-01-02T09:29:08.000Z","updated":"2020-03-01T10:27:19.141Z","comments":true,"path":"2019/01/02/Android-Permission-MarshMellow/","link":"","permalink":"https://woovictory.github.io/2019/01/02/Android-Permission-MarshMellow/","excerpt":"","text":"1. Runtime Permission 안드로이드 버전 6.0 즉, MarshMellow 이전 버전에서는 사용자가 앱을 설치하는 시점에 한번만 동의를 받으면 그 이후에는 문제없이 해당 권한들을 사용할 수 있었다. 즉, 앱을 설치할 때 필요한 권한들에 대한 동의를 얻는 것이다. 사용자가 해당 권한을 이 앱에서 사용하는 것에 대해서 꺼림직해 하거나 마음에 들지 않는다면 앱을 사용하지 않는 방법이 유일하다. 그로 인해 수많은 피싱앱이 생겼고, 일부 앱에서는 과도한 권한을 요구하는 경우도 있었다. 하지만 안드로이드 6.0 마시멜로우 버전 이상에서는 권한 허용 여부를 묻지 않는다. 앱에서 해당 권한이 필요할때마다 사용자로부터 권한을 허가받도록 변경되었다. 또한, 사용자가 권한을 허가했더라도 사용자는 설정화면(설정 &gt; 애플리케이션 &gt; 앱이름 &gt; 권한)을 통해 언제든지 권한을 허용/거부할 수 있다. 그래서 우리는 해당 권한이 실행될 때마다 권한을 사용할 수 있는지 확인해야 하고, 권한을 사용할 수 없는 경우에는 사용자로부터 권한을 허가받는 기능을 추가해주어야 한다. 2. 모든 권한을 다 체크해야 하는가? 그렇다면 모든 권한을 다 체크해야 할까? 아니다. 우리가 AndroidManifest.xml에서 선언한 모든 권한에 대해서 허가를 받아올 필요는 없다. 구글이 정의한 Normal Permission과 Dangerous Permission 중 Dangerous Permission에 대해서만 권한을 체크해주면 된다. Normal Permission and Dangerous Permission Normal Permission과 Dangerous Permission에 대한 내용은 위의 링크를 참고하면 된다. 그러면 우리는 Dangerous Permission에 대해서만 체크하고 허가를 받으면 된다. 아래는 Dangerous Permission과 permissions groups 표이다. 이외의 Permission들은 체크하지 않아도 된다. 참고 [안드로이드/Android]6.0 마시멜로우 권한체크하고 최적화하기 안드로이드 개발자 문서","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Permission","slug":"Permission","permalink":"https://woovictory.github.io/tags/Permission/"},{"name":"MarshMellow","slug":"MarshMellow","permalink":"https://woovictory.github.io/tags/MarshMellow/"}]},{"title":"[안드로이드] 인텐트","slug":"Android-What-is-Intent","date":"2019-01-02T08:28:41.000Z","updated":"2020-03-01T10:26:25.105Z","comments":true,"path":"2019/01/02/Android-What-is-Intent/","link":"","permalink":"https://woovictory.github.io/2019/01/02/Android-What-is-Intent/","excerpt":"","text":"Intent란? 안드로이드 어플리케이션을 구성하는 4가지 기본 요소에는 Activity, Service, Broadcast Receiver, Content Provider가 있다. 인텐트는 이러한 어플리케이션 구성요소 즉, 컴포넌트간에 작업 수행을 위한 정보를 전달하는 역할을 한다. 인텐트를 가장 손쉽게 사용한 예로는 액티비티간 화면 전환을 들 수 있다. 즉 인텐트는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 명시적으로 표시되기도 하고, 속성들이 암시적으로 표시되기도 한다. 또한 호출된 컴포넌트 B가 호출한 컴포넌트 A로 어떠한 결과를 전달할 때도 인텐트가 사용된다. 어떠한 컴포넌트를 호출하느냐에 따라서 사용되는 대표적인 메소드는 다음과 같은 것들이 존재한다. startActivity() : 새로운 액티비티 화면을 띄울 때 사용 startService(), bindService() : 서비스와 관련된 메소드 broadcastIntent() : 브로드캐스팅을 수행할 때 인텐트의 기본 구성 요소로는 액션(Action)과 데이터(Data)가 존재한다. 액션은 수행할 기능이며, 데이터는 액션이 수행될 대상 데이터을 의미한다. 12// 예를 들어 아래의 코드가 있다고 하자.var intent = Intent(Intent.ACTION_DIAL, Uri.parse(data)) 액션은 ACTION_DIAL 즉, 전화 다이얼을 걸라는 액션이며, data 값을 uri로 파싱한 Uri.pars(data)라는 것은 액션이 수행할 data 즉 전화번호일 것이다. &quot;요약하면 Uri로 파싱한 전화번호 data를 대상으로 전화다이얼을 걸어라&quot;라는 뜻이고 이 뜻을 인텐트에 담아 안드로이드 시스템에게 전달하면 되는 것이다. 인텐트 동작 순서 Componenet가 ActivityManager에게 다른 컴포넌트의 실행을 요청 ActivityManager는 패키지 정보를 가지고 있는 PacakageManager에게 컴포넌트 정보 요청 유요한 컴포넌트임을 확인하면 컴포넌트를 실행 여기서 실행을 요청할 때 컴포넌트의 정보가 Intent이다. Intent는 IPC 통신을 위한 직렬화 객체로 Parcelable을 통해 직렬화 되어 있다. 즉, 이 객체는 다른 프로세스로 전달하기 위한 데이터 그 자체이다. 활성화 될 컴포넌트 정보 + 활성화 될 컴포넌트에게 전달할 데이터 activity의 경우 startActivity() service의 경우 startService() Broadcast Recevier의 경우 sendBroadcast() 외부 패키지에서 접근하려면 이어야 한다. Intent의 종류 안드로이드의 4대 컴포넌트가 상호 통신을 위해 사용하는 인텐트는 크게 두가지로 나뉜다. 명시적 인텐트 인텐트에 클래스 객체네 컴포넌트 이름을 지정하여 호출될 대상을 확실히 알 수 있는 경우에 사용하는 것을 명시적 인텐트라고 한다. 주로 애플리케이션 내부에서 사용한다. 간단하게 현재 액티비티에서 SecondActivity로 화면 전환을 하는 코드는 아래와 같다. 123456789101112class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) button.setOnClickListener&#123; // 주의해서 볼 코드 var intent = Intent(this@MainActivity, SecondActivity::class.java) startActivity(intent) &#125; &#125;&#125; 새로운 인텐트 객체인 intent를 생성하면서 this@MainActivity 즉, getContext와 같은 현재 액티비티 정보가 담겨있는 정보와 SecondActivity 즉, 호출할 컴포넌트를 파라미터로 넘겨준다. 그리고 startActivity()에 인텐트 객체인 intent를 파라미터로 넘겨주면 새로운 화면인 SecondActivity가 실행된다. startActivity()는 새로 띄우는 액티비티로부터 받는 응답을 처리할 필요가 없을 때 간단하게 사용된다. 이에 반해 **startActivityForResult()**의 경우 새로 띄운 액티비티로부터 받는 응답을 처리할 경우에 사용된다. 암시적 인텐트 인텐트의 액션과 데이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다. 즉 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다. 특정 컴포넌트에서 암시적 인텐트를 받기 위해서는 매니페스트 파일에서 요소와 함께 어플리케이션 컴포넌트 각각에 대해서 하나 이상의 인텐트 필터를 선언해야 한다. 각각의 컴포넌트는 action, data, category를 기반으로 해서 자신이 받길 원하는 인텐트의 유형을 명시해야 한다. 안드로이드 시스템은 전달되는 암시적 인텐트가 매니페스트에 존재하는 인텐트 필터 중의 하나와 매칭되는 경우 해당 컴포넌트로 암시적 인텐트를 전달해준다. 암시적 인텐트를 사용하는 대표적인 경우로 문서 편집기를 예로 들 수 있다. 카카오톡으로 친구가 자신의 자소서를 봐달라며 PDF 파일을 첨부했다. 우리는 그 PDF를 클릭하여 열기를 하면 해당 안드로이드 폰에 PDF를 편집하거나 보여줄 수 있는 많은 애플리케이션들이 서로 자기가 그 PDF 파일을 보여줄 수 있다고 손을 든다. 그러면 안드로이드 시스템에서는 ‘PDF를 열 수 있는 앱들이 이렇게 많은데 어떤거 선택할래?’ 라고 애플리케이션을 선택할 수 있는 위젯을 띄워준다. 이런 일련의 과정을 가능하게 하는 녀석이 암시적 인텐트이다. 그럼 왜 암시적 인텐트를 사용할까?? 위의 예에서 우리는 친구의 자소서 PDF 파일을 열려고 한다. 여기서 PDF 파일을 열기 위해 이미 많은 PDF 리더 앱들이 존재한다. 그런데 굳이 우리가 PDF 리더를 만드는 것은 현실적으로 좋은 방법이 아니다. 따라서 이미 기존에 어떤 기능들을 지원하는 앱들이 있는 경우에 암시적 인텐트를 사용해서 그 앱들을 사용하면 되는 것이다. 1234567// 네이버 페이지var intent = Intent(Intent.ACTION_VIEW, Uri.parse(\"http://m.naver.com\"))startActivity(intent)// 전화 걸기var intent = Intent(Intent.ACTION_VIEW, Uri.parse(\"tel:010-0000-0000\"))startActivity(intent) 위와 같이 암시적 인텐트는 보통 액션(Action)과 데이터(data)라는 속성으로 구성되어 있다. 이 두 가지 속성 말고도 Category, Type, Component, Extras라는 속성을 가진다. 여기서 Component라는 속성을 지정할 경우 컴포넌트 클래스 이름을 명시적으로 지정하게 되는데 이 경우가 명시적 인텐트에 속하게 된다. 결국 암시적 인텐트는 Component 속성을 제외한 나머지 속성들로 구성되며, 이러한 속성들에 부합하는 컴포넌트가 실행된다.[호출할 대상들이 달라질 수 있다.] 안드로이드 폰에서 위의 코드 중 네이버에 접속하는 코드를 실행한 결과 화면은 아래와 같다. 이와 같이 암시적 인텐트는 그 속성에 부합하는 컴포넌트가 여러 개 있을 때 선택할 수 있도록 해준다. Intent Flag 안드로이드 애플리케이션 개발을 하다가 Activity에 대해 중복을 방지하거나 다른 상황에 대처할 때 Flag에 대해 잘 관리를 한다면 Activity에 대한 이해를 할 수 있고 관리 또한 용이하게 할 수 있다. 안드로이드 태스크란?(Android Task, Activity Stack) Task는 애플리케이션에서 실행되는 액티비티를 보관하고 관리하며 Stack 형태의 연속된 Activity들로 이루어진다. LIFO(Last In First Out) 즉, 후입 선출 형태로 나중에 적재된 액티비티일수록 가장 먼저 사용된다. 만약 1-&gt;2-&gt;3 페이지 순으로 액티비티를 이동했을 때 실행 순서대로 Task에 push 했다가 back 버튼을 누르면 3-&gt;2-&gt;1 페이지 순으로 Task에서 pop 시켜 돌아간다. 서로 다른 애플리케이션 간의 이동에도 Task를 이용해 사용자 경험(UX)를 유지시켜준다. 최초 적재 액티비티는 Root Activity라고도 하며 애플리에키션 런처로부터 시작된다. 마지막으로 적재되는 액티비티는 Top Activity라고 하며 현재 화면에 활성화 되어 있는 액티비티를 말한다. Task 내에는 서로 다른 애플리케이션의 액티비티들이 포함될 수 있어 애플리케이션에 경계 없이 하나의 애플리케이션인 것처럼 보이게 해준다. Task의 Stack내에 존재하는 액티비티들은 모두 묶여서 background와 foreground로 함께 이동한다. 홈버튼 클릭 : task interrupt -&gt; background 홈버튼 롱클릭 : recent task -&gt; foreground Flag를 사용하여 Task 내의 액티비티의 흐름을 제어할 수 있다. 어피니티란?(Android Affinity) 애플리케이션 내의 액티비티들은 하나의 어피니티(affinity : 친화력)을 가지고 있다. AndroidManifest 파일에서 요소의 taskAffinity 속성을 사용해 개별 affinity가 지정 가능하다. FLAG_ACTIVITY_NEW_TASK 플래그를 가진 인텐트 객체로부터 호출된 allowTaskReparenting 속성을 true로 가지고 있는 액티비티에 한해 affinity가 동작한다. 위 조건이 만족한 상황에서 시작된 액티비티는 자신과 동일한 어피니티를 갖는 태스크가 있을 경우 해당 태스크로 이동한다. 즉, [b] 어피니티를 가진 A 액티비티가 호출되어 해당 테스크에 속해있을 때 [b] 어피니티를 가진 태스크가 호출되면 A 액티비티는 [b] 어피니티를 가진 태스크로 이동한다. 어피니티에 의해 테스크가 이동된 후에 back 버튼으로 반환시 원래 해당하던 테스크로 돌아간다. 하나의 애플리케이션내에서 하나 이상의 기능을 갖는 애플리케이션이 존재할 경우 각 액티비티별로 다른 어피니티를 지정해 관리할 수 있다. Flag를 사용하는 방법은 AndroidManifest 파일에서 사용하는 방법과 Intent 코드로 사용하는 방법이 있다. AndroidManifest에서 사용하기 안드로이드의 launchMode 속성을 사용하여 적용할 수 있다. 원하는 액티비티에 속성을 추가하여 적용하면 된다. launchMode에서 사용 가능한 속성은 다음과 같이 4가지만 가능하다. standard : 스택 중 어느 곳에나 위치 가능하며 여러 개의 인스턴스가 생성 가능하다. singleTop : 스택 중 어느 곳에나 위치 가능하며 여러 개의 인스턴스가 생성 가능하고 호출한 activity와 현재 최상위 activity가(top activity) 동일한 경우 최상위 activity가 재사용된다.(기존 최상위 activity는 pop) singleTask : 루트 액티비티로만 존재하며 하나의 인스턴스만 생성 가능하다. (타 task에서 동일 activity 사용 불가) 다른 액티비티 실행시 동일 Task 내에서 실행이 가능하다. singleInstance : 루트 액티비티로만 존재하며 하나의 인스턴스만 생성 가능하고 태스크 내에 해당 액티비티 하나만 속할 수 있어 다른 액티비티를 실행시키면 새로운 Task가 생성되어 (FLAG_ACTIVITY_NEW_TASK와 동일) 그 Task 내에 포함된다. 소스 코드에서 플래그를 사용하고 싶을 때는 Intent에 addFlags(), setFlags() 메소드를 사용한다. FLAG_ACTIVITY_NEW_TASK : 동일 affinity의 task가 있으면 그곳에 실행되고 아니면 새로운 task를 실행한다.[실행은 액티비티를 만들어 테스크에 넣는 것을 의미] FLAG_ACTIVITY_SINGLE_TOP : 호출되는 액티비티가 최상위에 존재할 경우에는 해당 액티비티를 다시 생성하지 않고 존재하던 액티비티를 재사용한다. [실행시 재사용 액티비티의 실행은 onPause(), onNewIntent(), onResume() 순으로 호출된다.] [B]를 single top 설정 : [A][B] 상태에서 [B] 호출 시 =&gt; [A][재사용된 B] [A]를 single top 설정 : [B][A] 상태에서 [B] 호출 시 =&gt; [B][A][B] FLAG_ACTIVITY_NO_HISTORY : 해당 액티비티는 재활성화시(back 키를 눌러 다시 활성화될 때) pop된다. [B]를 no history 설정 : [A][B][A] 상태에서 back 키 사용시 [A]가 pop되고 [B] 역시 no history에 의해 pop =&gt; [A] 만 남음. FLAG_ACTIVITY_REORDER_TO_FRONT : activity 호출 시 이미 같은 activity가 task 내에 있으면 같은 activity는 pop시키고 해당 activity가 push 된다. [A]를 reorder to front 설정 : [A][B] 상태에서 [A] 호출 시 같은 activity인 [A]가 pop되고 =&gt; [B][A] FLAG_ACTIVITY_CLEAR_TOP : 해당 task에 있는 모든 activity를 pop시키고 해당 activity가 root activity로 task에 push된다. [A]를 clear top 설정 : [A][B] 상태에서 [A] 호출시 모두 pop되고 =&gt; [A] 단, 해당 플래그는 액티비티를 모두 onDestroy()시킨 후 새롭게 onCreate()시키기 때문에 [A]를 유지하려면 FLAG_ACTIVITY_SINGLE_TOP 플래그와 함께 사용하면 된다. 추가적인 플래그는 아래의 안드로이드 개발자 문서를 참고하자. 추가 정보 Clear Task Task를 오랫동안 사용하지 않고 방치해두면 시스템은 Root Activity를 제외한 모든 액티비티를 Clear 시킨다. 이러한 동작은 Activity의 속성을 수정하여 제어할 수 있다. alwaysRetainTaskState Task의 Root Activity에 true로 설정되어 있다면 상단에 언급되었던 동작은 발생하지 않으며 Task는 오랜 시간 이후에도 Stack에 있는 모든 Activity를 유지한다. clearTaskOnLaunch 이 속성이 true로 설정되어 있으면 alwaysRetainTaskState과 정반대로 사용자가 Task를 떠났다가 다시 돌아올 때마다 항상 Stack은 Root Activity로 정리된다. finishOnTaskLaunch 이 속성은 clearTaskOnLaunch와 유사하지만 전체 Task가 아닌 단일 Activity에서 동작한다. 그리고 그것은 Root Activity를 포함한 어떤 Activity가 사라지는 원인이 될 수도 있다. true로 설정되어 있을 때, Activity는 현재 Sessing 동안 Task의 일부만 유지한다. 만일 사용자가 해당 Task를 벗어났다가 다시 돌아오면 더 이상 존재하지 않는다. 참고 인텐트 (intent 명시적, 암시적) 인텐트란 무엇인가? 내가 누군지 말해줘! - 인텐트 필터 안드로이드/Android 태스크란? (Task, Activity Stack) 어피니티란? (Android Affinity) 플래그란? (Android Flag) 안드로이드 Intent Flag 정리(Activity 관리)","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"인텐트","slug":"인텐트","permalink":"https://woovictory.github.io/tags/인텐트/"},{"name":"Intent","slug":"Intent","permalink":"https://woovictory.github.io/tags/Intent/"}]},{"title":"[안드로이드] Fragment","slug":"Android-What-Is-Fragment","date":"2019-01-02T03:31:10.000Z","updated":"2020-03-01T10:26:27.828Z","comments":true,"path":"2019/01/02/Android-What-Is-Fragment/","link":"","permalink":"https://woovictory.github.io/2019/01/02/Android-What-Is-Fragment/","excerpt":"","text":"Fragment란?? Fragment란 하나의 Activity가 여러 개의 분할된 화면을 가지도록 만들기 위해 고안된 개념이다. 다양한 크기의 화면을 가진 모바일 환경이 늘어나고 태블릿의 큰 화면에 대한 Activity의 비효율성이 부각되었다. 이처럼 하나의 디스플레이 화면 안에서 다양한 화면을 보여주고 싶은 니즈를 충족시키기 위해 등장한 것이 Fragment이다. Fragment를 사용하면 다른 Activity에서도 재사용할 수 있다는 장점이 있다. 또한 전체 화면인 Activity에서 부분 화면을 만드는 데 주로 사용된다. Fragment는 항상 Activity 위에 올라가 있어야 한다. 자체 생명주기를 갖지만, Activity의 생명주기에 종속적이다. Activity가 소멸되면 그 위의 Fragment도 소멸된다. 안드로이드 4대 컴포넌트(Activity, Service, Broadcast Receiver, Content Provider)들은 인텐트를 이용하여 상호 간에 통신을 진행한다. 하지만 Fragment는 안드로이드의 4대 컴포넌트에 속하는 구성 요소가 아니다. 따라서 인텐트를 사용하여 값을 전달할 수 없다. 그래서 Fragment 간에 값을 전달하고 상호 통신을 하기 위해서 고안된 것이 Bundle이라는 것이다. Fragment는 Bundle이라는 객체를 통해서 Fragment 간의 데이터 전달을 수행한다. 추가 내용 Fragment는 자신이 속한 Activity와만 통신을 해야하며, 항상 자신이 속한 Activity를 통해서 다른 Fragment나 Activity와 통신해야 한다. Fragment와 Activity가 통신할 수 있는 방법에는 3가지 방법이 있다. Bundle - Acticity는 Fragment를 생성 후, 데이터를 넣은 bundle을 전달할 수 있다. Fragment는 onActivityCreated() 메소드에서 bundle을 받게 된다. Method - Activity는 Fragment의 메소드를 호출할 수 있다. Listener - Fragment는 interface를 사용하여 Activity에서 리스너 이벤트를 발생시킬 수 있다. 하나의 Activity에 속하는 다수의 Fragment가 동시에 동작 가능하다. Activity는 한 화면을 다 차지해야 하는데 Fragment는 화면 일부만 점유해도 동작 가능하기 때문에 화면을 분할하여 부분마다 독립적인 유저 인터페이스를 구현할 수 있다. Activity의 일부분을 차지하는 각각의 Fragment는 자신만의 유저 인터페이스를 보여주고, 사용자의 입력에 반응한다. 기기의 화면 크기나 화면 방향 등에 따라 달라지는 Activity의 레이아웃에 맞추어 Fragment의 레이아웃을 재배열하거나 결합할 수 있다. 예를 들어 태블릿에서는 Activity에 두 개의 Fragment를 추가한 유저 인터페이스를 보여주지만 핸드폰에서는 Activity당 하나의 Fragment를 추가한 유저 인터페이스를 보여준다. Fragment’s LifeCycle Fragment는 생명 주기를 갖지만, Activity의 생명주기에 종속적인 특성이 있다. onAttach() Fragment가 Activity에 추가될 때 한번 호출된다. 하지만 아직 완벽하게 생성된 것은 아니다. Fragment가 Activity에 대한 참조를 얻기 위해 사용되어진다. onCreate() 본격적으로 Fragment가 Activity의 호출을 받아 생성되는 시점이다. Fragment의 생명주기는 Activity의 생명주기에 종속적이라고 앞에서 언급했다. 이 단계에서는 Activity도 생성 중에 있는 시기이기 때문에 Activity에 있는 컨트롤을 참조하거나 Fragment의 요소들을 초기화할 때 불안정한 경우가 있다. Activity의 onCreate()에서는 view, UI 작업을 할 수 있지만, Fragment의 onCreate()에서는 할 수 없다. Activity의 onCreate 메소드가 아직 완료된 시점이 아니라서 유저 인터페이스와 관련있는 것을 제외한 Fragment에서 사용되는 리소스들이 초기화된다. Fragment가 paused 또는 stop 되었다가 다시 resume되었을 때 유지하고 싶은 Fragment의 컴포넌트들을 여기서 초기화 해주어야 한다. setRetainInstance(true)를 호출하여 Fragment의 인스턴스를 유지하도록 할 수 있다. 이 때 다음의 세가지가 기존과 달라진다. Activity가 재생성되어도 Fragment가 유지되기 때문에 onCreate는 호출되지 않는다. onDestroy()가 호출되지 않지만, Activity로부터 Fragment가 detach될 때 onDetach()는 호출된다. onAttach(Activity)와 onActivityCreated(Bundle)는 호출된다. onCreateView(LayoutInflater, ViewGroup, Bundle) Fragment에 속한 각종 View나 viewGroup에 대한 UI 바인딩 작업을 할 수 있다. Fragment의 유저 인터페이스가 화면에 그려지는 시점에 호출된다. XML 레이아웃을 inflate하여 Fragment를 위한 View를 생성하고 Fragment 레이아웃의 root에 해당되는 View를 Activity에게 리턴해야 한다. inflate? inflate는 XML 레이아웃에 정의된 뷰나 레이아웃을 읽어서 메모리상의 view 객체를 생성해주는 것이다. onActivityCreated() Activity에서 Fragment를 모두 생성하고(View 생성) 난 다음에 호출된다. Activity에서 onCreate() 다음에 호출되는 메소드이다. Activity와 Fragment가 드디어 연결되는 시점이다. Activity와 Fragment의 View가 모두 생성된 시점이라 findViewById()를 사용하여 View 객체에 접근하는게 가능하다. onStart() Fragment가 사용자에게 보여지기 전에 호출되는 함수이다. Fragment가 속한 Activity가 start 된 것과 관련있음. onResume() Fragment가 비로소 화면에 보이는 단계이다. 사용자에게 focus를 잡은 상태. 사용자와의 상호 작용이 가능하다. Fragment가 속한 Activity가 resume된 것과 관련있음. Fragment가 사용되지 않을 때 호출되는 함수들 onPause() Activity가 pause되어 Fragment는 사용자와의 상호작용을 중지한다. Fragment가 중지되는 시점을 정의한다. Fragment의 정지가 반드시 Fragment의 소멸을 의미하는 것은 아니지만 다시 해당 Fragment로 돌아온다는 보장도 없기 때문에 이 시점에서 남겨두어야 하거나 보존해야 할 자료들을 저장한다. onStop() Activity에 의해 stop되었거나 Fragment의 수행이 Activity에 의해 수정되었을 경우로 Fragment는 더 이상 보이지 않게 되며, Fragment 기능은 중지한다. Fragment가 destroy될 때 다음 순서대로 호출된다. onDestroyView() Fragment가 화면에서 보이지 않고 View의 현재 상태가 저장된 후 호출된다. Fragment의 View들을 제거(destroy)한다. Back Stack을 사용했다면, 해당 Fragment로 돌아올 때 onCreateView()가 호출된다. onCreateView에서 초기화했던 UI들을 여기서 해제하면 된다. onDestroy() Fragment를 더 이상 사용하지 않을 때 호출된다. Activity와 연결이 끊어진 상태는 아니지만 Fragment는 동작하지 않는다. Fragment를 제거하기 직전. 시스템에서 onDestory()가 항상 호출되는 것을 보장해주지 않는다. onDetach() onDetach가 호출된 후, Fragment를 비로소 제거하고 Activity와의 연결도 해제한다. Framgnet의 View hierarchy가 더 이상 존재하지 않게 된다. 부모 Activity가 즉, 종속된 Activity가 생명주기를 완전하게 마치지 않고 종료되었다면 onDetach()는 호출되지 않을 수도 있다. 액티비티와 프래그먼트 차이 위에서 언급했듯이 태블릿이 등장하면서 큰 화면에 대한 액티비티의 비효율성이 부각되었다. 태블릿의 큰 화면에 여러 액티비티를 보여주기 위해 나온 것이 프래그먼트이다. 하나의 액티비티에 여러 레이아웃을 배치하여 구성할 수도 있지만 프래그먼트를 사용하면 다른 액티비티에서도 재사용이 가능하고 자체 생명주기를 가지기에 생명주기에 따라 다양한 구현이 가능하다. 또한 자체 입력 이벤트를 가지기에 다이나믹한 인터렉션이 가능하다. 프래그먼트의 생명주기는 액티비티의 생명주기에 종속적이기에 액티비티에서 onCreate()가 호출되면 프래그먼트에서는 onActivityCreated()가 호출되고 액티비티에서 onPause()가 호출되면 프래그먼트도 onPause()가 된다. 프래그먼트에서 액티비티와 통신을 하려면 getActivity()를 호출하면 액티비티 객체를 사용할 수 있으며 프래그먼트에서 발생하는 이벤트는 onAttach()에서 _interfactionListener_를 호출하고 액티비티에서 이것을 구현함으로써 이벤트에 대한 처리와 프래그먼트간 통신이 가능하다. 액티비티를 관리하는 스택이 있듯이 프래그먼트에도 백스택이라는 스택 구조가 존재하며 이것은 액티비티가 관리한다. FragmentTransaction 객체의 addToBackStack() 함수를 사용하여 프래그먼트를 백스택에 저장하면 사용자가 뒤로가기 버튼을 눌렀을 때 프래그먼트의 이전 상태로 되돌려주는 기능을 제공할 수 있다. 참고 액티비티와 프래그먼트 차이","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Fragment","slug":"Fragment","permalink":"https://woovictory.github.io/tags/Fragment/"}]},{"title":"[Java] RunTime Error vs Compile Error","slug":"Java-Type-of-Error","date":"2019-01-02T01:58:48.000Z","updated":"2020-04-22T07:46:51.440Z","comments":true,"path":"2019/01/02/Java-Type-of-Error/","link":"","permalink":"https://woovictory.github.io/2019/01/02/Java-Type-of-Error/","excerpt":"","text":"자바를 공부하며 항상 등장하는 말은 컴파일과 런타임이다. 하지만 두 용어에 대한 개념이 확실하지 않아 이번 기회에 정리하고 넘어가겠다. Run time : 어떤 프로그램이 실행되는 동안의 Time을 말하며, 이와 대조되는 개념으로는 Compile time, Link time 등이 있다. Runtime Error : 어떤 프로그램이 실행되는 동안에 발생하는 에러를 말한다. 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 경우가 있다. ex) NullPointerException Complie time : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정을 말한다. Compile Error : 주로 문법상의 오류가 많다.(빨간 줄이 나타나는 경우 컴파일 에러이다. 대부분의 IDE들이 빨간줄 표시로 잡아준다.) 컴파일 에러가 발생하는 경우는 주로 오타, 중괄호의 짝이 맞지 않는 경우, 중복된 변수명 등이 원인이 될 수 있다. 프로그램이 컴파일이 에러 없이 완료되더라도 해당 프로그램 실행 시에 에러가 없을 것을 보장할 수 없다. 즉, 컴파일 에러가 발생하지 않더라도 런타임 에러가 발생할 수 있다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://woovictory.github.io/tags/Error/"},{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Compile Error","slug":"Compile-Error","permalink":"https://woovictory.github.io/tags/Compile-Error/"},{"name":"Runtime Error","slug":"Runtime-Error","permalink":"https://woovictory.github.io/tags/Runtime-Error/"}]},{"title":"[Java] Static","slug":"Java-static-concept","date":"2018-12-31T02:52:46.000Z","updated":"2020-04-22T07:47:30.539Z","comments":true,"path":"2018/12/31/Java-static-concept/","link":"","permalink":"https://woovictory.github.io/2018/12/31/Java-static-concept/","excerpt":"","text":"Static이라는 키워드는 보통 변수나 메소드 앞에서 사용한다. non-static 멤버와 static 멤버의 차이 1234567class StaticSample&#123; int n; // non-static 필드 void g()&#123;...&#125; // non-static 메소드 static int m; // static 필드 static void f() &#123;...&#125; // static 메소드&#125; non-static 멤버 공간적 특성 : 멤버는 객체마다 별도로 존재한다. 인스턴스 멤버라고 부른다. 시간적 특성 : 객체 생성 시에 멤버가 생성된다. 객체가 생성될 때 멤버도 생성된다. 객체 생성 후 멤버 사용이 가능하다. 객체가 사라지면 멤버도 사라진다. 공유의 특성 : 공유되지 않는다. 멤버는 객체 내에 각각의 고유한 공간을 유지한다. static 멤버 공간적 특성 : 멤버는 클래스당 하나가 생성된다. 멤버는 객체 내부가 아닌 별도의 공간에 생성된다. 클래스 멤버라고 부른다. 시간적 특성 : 클래스 로딩 시에 멤버가 생성된다. 객체가 생기기 전에 이미 생성된다. 객체가 생기기 전에도 사용이 가능하다.(즉, 객체를 생성하지 않고도 static 멤버를 사용할 수 있다.) 객체가 사라져도 static 멤버는 사라지지 않는다. 멤버는 프로그램이 종료될 때 사라진다. 공유의 특성 : 동일한 클래스의 모든 객체들에 의해 공유된다. Static 변수 1234567public class HouseLee&#123; String lastName = \"이\"; public static void main(String[] args) &#123; HousePark pey = new HouseLee(); HousePark pes = new HouseLee(); &#125;&#125; 위와 같이 이씨 집안을 나타내는 클래스가 있다. 위의 클래스는 객체를 생성할 때 마다 객체 변수인 lastName을 저장하기 위한 메모리를 별도로 할당한다. 하지만, 이 경우 HouseLee 클래스의 lastName은 어떤 객체이던지 동일한 값인 &quot;이&quot;이어야 할 것이다. 이렇게 항상 값이 변하지 않는 경우라면 static을 사용하여 메모리의 낭비를 줄일 수 있는 이점을 가지고 있다. 다음은 static 변수를 이용해서 위의 코드를 바꾼 것이다. 1234567public class HouseLee&#123; static String lastName = \"이\"; public static void main(String[] args) &#123; HousePark pey = new HouseLee(); HousePark pes = new HouseLee(); &#125;&#125; 위와 같이 lastName 변수에 static 키워드를 붙이면 자바는 메모리 할당을 딱 한번만 하게 되어 메모리 사용에 이점을 가지게 된다. 만약 HouseLee 클래스의 lastName 값이 변경되지 않기를 바란다면 final 키워드를 사용하면 된다. final 키워드는 한 번 값이 설정되면 그 값을 변경하지 못하게 한다. (상수처럼) 이를 변경하려고 하면 예외가 발생한다. static을 사용하는 또 한가지 이유로 공유의 개념을 들 수 있다. static으로 선언된 변수는 같은 클래스의 객체들이 하나의 static 변수를 두고 공유한다. 즉, static으로 설정하면 같은 곳의 메모리 주소만을 바라보기 때문에 static 변수의 값을 공유하게 되는 것이다. 123456789101112131415public class Counter &#123; int count = 0; Counter() &#123; this.count++; System.out.println(this.count); &#125; public static void main(String[] args) &#123; Counter c1 = new Counter(); Counter c2 = new Counter(); &#125;&#125;// 결과11 위의 코드를 살펴보자. c1,c2 객체 생성 시 count 값을 1씩 증가시키더라도 c1과 c2의 count는 각각 별도의 메모리 공간을 가리키고 있기 때문에 2가 아닌 1 1이 나오게 되는 것이다. 그렇다면 static 변수를 이용해서 이를 해결해보자. 123456789101112131415public class Counter &#123; static int count = 0; Counter() &#123; this.count++; System.out.println(this.count); &#125; public static void main(String[] args) &#123; Counter c1 = new Counter(); Counter c2 = new Counter(); &#125;&#125;// 결과12 count라는 변수는 static으로 선언되어 객체들이 static 변수를 공유하게 된다. 따라서 증가된 결과값이 나오게 된다. 보통 변수의 static 키워드는 프로그래밍 시 메모리의 효율보다는 두번째처럼 공유하기 위한 용도로 훨씬 많이 사용하게 된다. static method static이라는 키워드가 메소드 앞에 붙으면 이 메소드는 static 메소드가 된다. 그럼 아래의 코드를 살펴보자. 1234567891011121314151617public class Counter &#123; static int count = 0; Counter() &#123; this.count++; &#125; public static int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; Counter c1 = new Counter(); Counter c2 = new Counter(); System.out.println(Counter.getCount()); &#125;&#125; main 메소드에서 getCount() 메소드는 Counter.getCount() 와 같이 인스턴스를 만들지 않고 클래스를 통해 호출할 수 있다.(접근할 수 있다.) getCount() 메소드는 static 메소드이고 이와 같은 static 멤버는 클래스당 하나만 존재하기 때문에 클래스 이름으로 바로 접근할 수 있다. 클래스명.static멤버 주의해야 할 점은 non-static 멤버는 클래스명.non-static멤버 방식으로 접근할 수 없다. static 메소드 안에서는 인스턴스 변수 접근이 불가능하다. 위의 코드는 static 변수이기 때문에 static 메소드 안에서 접근이 가능한 것이다. 보통 static method는 유틸리티성 메소드를 작성할 때 많이 사용된다고 한다. 예를 들어, 오늘의 날짜 구하기, 숫자에 콤마 추가하기 등의 메소드를 작성할 때에는 클래스 메소드를 사용하는 것이 유리하다. 또한, static 메소드는 오직 static 멤버만 접근할 수 있다. static 메소드는 객체가 생성되지 않은 상황에서도 사용이 가능하므로 객체에 속한 인스턴스 메소드, 인스턴스 변수 등을 사용할 수 없다. static 멤버들만 사용이 가능하다. 그러나 인스턴스 메소드는 static 멤버들을 모두 사용할 수 있다. 123456789101112class StaticMethod &#123; int n; void f1(int x) &#123; n = x; &#125; // 정상 void f2(int x) &#123; n = x; &#125; // 정상 static int m; static void s1(int x) &#123; n = x; &#125; // 컴파일 오류. static 메서드는 non-static 필드 사용 불가 static void s2(int x) &#123; f1(3); &#125; // 컴파일 오류. static 메서드는 non-static 메서드 사용 불가 static void s3(int x) &#123; m = x; &#125; // 정상. static 메서드는 static 필드 사용 가능 static void s4(int x) &#123; s3(3); &#125; // 정상. static 메서드는 static 메서드 호출 가능&#125; 마지막으로 static 메소드에서는 this 키워드를 사용할 수 없다. this는 호출 당시 실행 중인 객체를 가리키는 레퍼런스이다. 따라서 객체가 생성되지 않은 상황에서 클래스 이름을 이용하여 호출이 가능한 static 메소드는 this를 사용할 수 없다. 123456789class StaticAndThis&#123; int n; static int m; void f1(int x)&#123; this.n = x;&#125; // 정상 void f2(int x)&#123; this.m = x;&#125; // non-static 메소드에서 static 멤버 접근 가능 static void s1(int x)&#123; this.n = x;&#125; // 컴파일 오류. static 메소드에서는 this 사용 불가.&#125; 주의 실제 static 멤버의 생성 시점은 JVM(자바 가상 기계)에 따라 다르다. 그러나 일반적으로 static 멤버가 포함된 클래스가 로딩하는 시점에 static 멤버가 생성된다고 볼 수 있다. JVM은 많은 경우 처음부터 필요한 대부분의 클래스를 로딩하기 때문에 static 멤버의 생성 시점은 JVM이 시작되는 시점이라고 할 수 있다. 싱글톤 패턴 디자인 패턴 중 하나인 싱글톤에 대해서 알아보자. 우리는 지금 static이라는 키워드에 대해서 알고 있기 때문에 어렵지 않게 접근할 수 있다. Singleton은 단 하나의 객체만을 생성하게 강제하는 패턴이다. 즉 클래스를 통해 생성할 수 있는 객체는 Only One. 즉, 한 개만 되도록 만드는 것이 싱글톤이다. 다음의 예를 보자. 12345678910class Singleton &#123; private Singleton() &#123; &#125;&#125;public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton singleton = new Singleton(); &#125;&#125; 위와 같은 코드를 작성하면 컴파일 에러가 발생한다. 왜냐하면 Singleton 클래스의 생성자에 private 키워드로 외부 클래스에서 Singleton 클래스의 생성자로의 접근을 막았기 때문이다. 이렇게 생성자를 private으로 만들어 버리면 외부 클래스에서 Singleton 클래스를 new를 이용하여 생성할 수 없게 된다. new를 이용하여 무수히 많은 객체를 생성한다면 싱글톤의 정의에 어긋난다. 그래서 일단 new로 객체를 생성할 수 없도록 private 접근 제어자를 이용해서 막은 것이다. 다음 코드를 보자. 1234567891011121314class Singleton &#123; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return new Singleton(); &#125;&#125;public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); &#125;&#125; 위의 코드는 이제 getInstance라는 static 메소드를 이용하여 Singleton 객체를 돌려받을 수 있다. 하지만 getInstance를 호출할 때마다 새로운 객체가 생성되게 된다. 하지만 그렇다면 싱글톤 패턴이 아니다. 어떻게 해야할까?? 12345678910111213141516171819202122class Singleton &#123; private static Singleton one; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(one==null) &#123; one = new Singleton(); &#125; return one; &#125;&#125;public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton1 == singleton2); &#125;&#125;// 결과true Singleton 클래스에 one이라는 static 변수를 두고 getInstance 메소드에서 one 값이 null인 경우에만 객체를 생성하도록 하여 one 객체가 단 한번만 만들어지도록 했다. getInstance의 동작원리 최초 getInstance가 호출되면 one이 null이므로 new에 의해서 객체가 생성이 된다. 이렇게 한번 생성이 되면 one은 static 변수이기 때문에 모든 객체가 공유한다. 따라서 객체가 생성된 이후로는 null이 아니게 된다. 그런 후에 다시 getInstance 메소드가 호출되면 이제 one은 null이 아니므로 이미 만들어진 싱글톤 객체인 one을 항상 리턴하게 된다. main 메소드에서 getInstance를 두번 호출하여 각각 얻은 객체가 같은 객체인지 확인해보았다. 결과는 역시 &quot;true&quot;가 나온다. 싱글톤 패턴은 static에 대한 이해를 하고 있다면 어렵지 않은 패턴 중 하나이다. 위의 예제로 든 싱글톤은 Thread Safe 하지는 않다. 쓰레드 환경에서 안전한 싱글톤을 만드는 방법은 추후에 공부해보자. 참고 정적 변수와 메소드 java static 멤버와 static 메소드","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Static","slug":"Static","permalink":"https://woovictory.github.io/tags/Static/"}]},{"title":"[네트워크] HTTP와 HTTPS","slug":"Network-Diff-Of-HTTP-HTTPS","date":"2018-12-28T13:35:54.000Z","updated":"2020-05-12T15:08:10.561Z","comments":true,"path":"2018/12/28/Network-Diff-Of-HTTP-HTTPS/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-Diff-Of-HTTP-HTTPS/","excerpt":"","text":"HTTP의 문제점 HTTP는 다음과 같은 문제점을 갖는다. HTTP는 평문 통신이기 때문에 도청이 가능하다. 통신 상대를 확인하지 않기 때문에 위장이 가능하다. 완전성을 증명할 수 없기 때문에 변조가 가능하다. 위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다. TCP/IP는 도청 가능한 네트워크이다. TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로도 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다. 1번 문제를 보완하는 방법은 다음과 같다. 통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다. 콘텐츠를 암호화 말 그대로 HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다. 통신 상대를 확인하지 않기 때문에 위장이 가능하다. HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 Request를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 엑세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다. 리퀘스트를 보낸 곳의 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다. 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다. 통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다. 어디에서 누가 리퀘스트 했는지 확인할 수 없다. 의미없는 리퀘스트도 수신한다. -&gt; DoS 공격을 방지할 수 없다. 2번 문제를 보완하는 방법은 다음과 같다. SSL로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 증명서를 제공하고 있다. 증명서는 신뢰할 수 있는 써드 파티로부터 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다. SSL의 작동 과정 클라이언트가 SSL로 암호화된 페이지를 요청한다.(일반적으로 https://가 사용된다.) 서버는 Public Key와 인증서를 함께 전송한다. 인증서가 신용있다고 판단한 CA(Certificate Authority)로부터 서명된 것인지 판단한다. 클라이언트는 Public Key를 사용해서 랜덤 대칭 암호화키와 URL, http 데이터를 암호화하여 서버로 전송한다. 서버는 Private Key를 이용하여 랜덤 대칭 암호화키와 URL, http 데이터를 복호화한다. 서버는 요청받은 URL에 대한 응답을 랜덤 대칭 암호화키를 이용해서 암호화해서 클라이언트로 전송한다. 클라이언트는 대칭 키를 이용해서 http 데이터를 복호화하고 데이터를 이용한다. SSL의 인증과 암호화 과정을 통해 3번 문제 또한 해결할 수 있다. 완전성을 증명할 수 없기 때문에 변조가 가능하다. 여기서 완전성이란 정보의 정확성을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 으해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Main-in-the-Middle)이라고 부른다. 3번 문제를 보완하는 방법은 2번 문제를 보완하는 방법으로도 해결이 가능하다. MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 HTTPS를 사용해야 한다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다. HTTPS HTTPS는 HTTP 통신하는 소켓 부분은 SSL or TLS라는 프로토콜로 대체한 것이다. HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서는 SSL과 통신하고 SSL이 TCP와 통신하게 된다. HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 모두 사용한다.(두 개를 혼합한 하이브리드 암호화 시스템) 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식아. [공통키, 공개키, 대칭키 암호화 방식이 뭘까…?] 모든 웹 페이지에서 HTTPS를 사용하지 않는다. 그 이유는 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 많이 필요로 하기 때문이다. 통신할 때마다 암호화를 하면 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 Request 수가 줄어들게 된다. 따라서 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다. 그러나! 개인정보를 주고 받지 않아도 SSL을 이용해야 한다. 어느 사이트에 접속하는지, 어떤 행동을 하는지 공개될 수 있다. 모든 사용자의 행동 및 정보는 보호받아야 할 권리가 있다. 예를 들어, A 사이트에서 로그인 페이지로 넘어갈 때 해커가 가짜 로그인 페이지로 보낼 수 있는 확률도 존재한다. 참고","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"HTTP","slug":"HTTP","permalink":"https://woovictory.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://woovictory.github.io/tags/HTTPS/"}]},{"title":"[네트워크] 흐름/혼잡/오류 제어 기법","slug":"Network-Erro-Flow-Control","date":"2018-12-28T10:19:04.000Z","updated":"2020-05-12T15:08:07.225Z","comments":true,"path":"2018/12/28/Network-Erro-Flow-Control/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-Erro-Flow-Control/","excerpt":"","text":"TCP의 가장 큰 특징은 신뢰성이다. 이러한 신뢰성을 구성해 주는 방법인 흐름 제어, 혼잡 제어, 오류 제어에 대해 알아보도록 하자. 흐름 제어 송신(호스트) &lt;&gt; 수신(호스트) 흐름 제어는 수신측과 송신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다. 만약 송신측의 전송량이 수신측의 처리량보다 많은 경우, 전송된 패킷은 수신측의 큐를 넘어서 손실될 문제가 발생할 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다. 흐름 제어 방법 정지-대기(Stop and Wait) 매번 전송한 패킷에 대해 응답을 받아야만 그 다음 패킷을 전송할 수 있다. 구조가 간단한 대신, 하나를 주고 하나를 받기 때문에 비효율적이다. 슬라이딩 윈도우(Sliding Window) 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다. 이처럼 슬라이딩 윈도우 기법을 통하여 송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜으로써 흐름제어를 수행한다. 윈도우는 전송, 수신 스테이션 양쪽에서 만들어진 버퍼(Buffer)의 크기이다. 윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수) 슬라이딩 윈도우 기법은 Stop and Wait 기법의 비효율성을 개선한 기법이다. ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다. 위와 같은 구조에서 데이터 0과 1을 전송했다고 가정하면 슬라이딩 윈도우의 구조는 아래와 같이 변한다. 윈도우의 크기는 전송한 데이터 프레임만큼 왼쪽 경계가 줄어들게 된다. 이때 수신측에서 ACK라는 프레임을 받게 된다면 전송측은 0과 1 데이터를 정상적으로 받았음을 알게 되고, 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다. 조금 더 자세한 설명 # 전송측 윈도우 # 수신측 윈도우 혼잡 제어 송신(호스트) &lt;&gt; 라우터(네트워크) 혼잡 제어는 송신측의 데이터 전달과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다. 송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다. 만약, 한 라우터에게 데이터가 몰릴 경우 다시 말해 혼잡할 경우, 라우터는 자신에게 온 데이터를 모두 처리할 수 없다. 그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다. 따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서는 보내는 데이터의 전송 속도를 강제로 줄이게 된다. 혼잡 제어 방법 AIMD AIMD(Additive Increase / Multiplicative Decrease)라고 불리며, 합 증가 / 곱 감소라고 부른다. 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간내에 보내는 패킷의 수)를 1씩 증가시켜 가면서 전송하는 방법이다. 만일 패킷 전송을 실패하거나 일정한 시간을 넘으면 패킷 전송 속도를 절반으로 줄이게 된다. 이 방식은 공평한 방식이다. 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 평형 상태로 수렴하게 되는 특징이 있다. 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하며 오랜 시간이 걸리게 되고 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다. 이러한 문제점들을 해결하기 위한 방법은 다음부터 소개될 것이다. 슬로우 스타트(Slow Start) AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있다. Slow Start 방식은 AIMD 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window size가 2배가 된다. 따라서 전송 속도는 AIMD와는 다르게 지수 함수꼴로 증가하게 된다. 대신 혼잡 현상이 발생하면 Window Size를 1로 떨어뜨리게 된다. 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으므로 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다. 초기 혼잡 Window Size 1로 전송 = 전송 호스트는 하나의 패킷만 전송 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송 수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 4로 하여 전송 수신 호스트로부터 수신응답을 수신하면 윈도위의 크기를 8로 하여 전송 미리 정해진 임계 값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다. Slow Start란 이름을 사용하지만, 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다. 전송되어지는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다. 혼잡 회피(Congestion Avoidance) 윈도우의 크기가 임계 값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게 된다. 이는 데이터를 전송함에 있어서 조심하는 단계이다. 전송한 데이터에 대한 ACK를 받으면 윈도우의 크기를 1씩 증가시킨다. 전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다. 수신 호스트로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우 타임아웃의 발생 네트워크에 혼잡이 발생했다고 인식 -&gt; 윈도우의 크기를 즉, 세그먼트의 수를 1로 줄임 -&gt; 동시에 임계 값을 패킷 손실이 발생하였을 때의 윈도우 크기의 반으로 줄임 빠른 회복(Fast Recovery) 빠른 회복은 Congestion이 발생했을 때 Window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이는 AIMD의 AI 즉, Additive Increase 하는 방법이다. Fast Recovery를 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다. 빠른 재전송(Fast Retransmission) 3개의 연속된 중복 ACK를 수신하는 경우에 패킷의 손실로 간주하여 타임아웃이 발생하기 전에 해당 패킷을 재전송한다. 그리고 이러한 현상이 일어난 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 반으로 줄인다. TCP Reno N개의 중복 ACK 발생 시 ssthresh(slow start threshold)값을 Congestion Window(cwnd) 사이즈의 반으로 줄여 빠른 복구(Fast Recovery)를 수행하여 선형적 증가를 하게 되며, TCP Time Out에 이르면 Slow Start를 시작한다. TCP Tahoe N개의 중복 ACK 발생 시 바로 Slow Start를 시작한다. TCP Tahoe와 TCP Reno는 ssthresh(slow start threshold) 값까지 지수적 증가(Slow-Start)를 하게 되고 ssthresh를 넘어서면 선형적 증가(Additive Increase)를 하는 것까지는 동일하다. 차이가 생기는 기준은 N개의 중복 ACK가 발생할 경우이다. 오류 제어 오류 제어 기법은 오류 검출(Error detection)과 재전송(retransmission)을 포함한다. ARQ(Automatic Repeat Request) 기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다. ARQ 기법은 흐름 제어 기법과 관련되어 있는데 stop and wait은 stop and wait ARQ로, Sliding Window는 GBn(Go-Back-n) ARQ 또는 SR(Selective-Reject) ARQ 형태로 구혀한다. 오류 제어 방법 ARQ : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식 Stop and Wait ARQ 전송측은 수신측에서 보내준 ACK를 받을 때까지 프레임의 복사본을 유지한다. 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 부여한다. 수신측이 데이터를 받지 못했을 경우, NAK를 송신측에게 보내고 NAK를 받은 송신측은 데이터를 재전송한다. 만약 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송한다. Go-Back-n ARQ(GBn ARQ) 전송된 프렘이이 손상되거나 분실될 경우, 확인된 마지막 프레임 이후로 모두 재전송하는 기법이다. 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별을 해야한다. ACK : 다음 프레임을 전송 NAK : 손상된 프레임 자체 번호를 반환 재전송 되는 경우는 다음과 같다. # 1. NAK 프레임을 받았을 경우 만약 수신측으로 0부터 5까지의 데이터를 보내었다고 가정한다. 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 받게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다. 그러나 만약 수신측에서 데이터 오류 프레임2가 잘못 되었다는 것을 발견하고 NAK 2를 전송측에 보낸다. NAK 2를 받은 전송측은 데이터 프레임2가 잘못 되었다는 것을 알고 데이터를 재전송한다. GBn ARQ의 특징은 바로 이 데이터를 재전송하는 부분이다. GBn ARQ는 NAK(n)을 받아 데이터를 재전송하게 되면, n 데이터만을 재전송하는 것이 아니라 n 데이터 이후의 데이터를 모두 재전송한다. # 2. 전송 데이터 프레임의 분실 GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 재전송과 수신측의 폐기이다. 수신측에서 데이터 1을 받았는데 갑자기 다음에 데이터 3을 받게 된다면 수신측에서는 데이터 2를 못받았으므로 데이터 3을 폐기하고 NAK 2를 전송측에 보낸다. NAK 2를 받은 전송측은 위의 1의 경우에서와 같이 NAK 2 데이터부터 모두 재전송을 실시하며 수신측은 기존 받았던 데이터 중 NAK(n)으로 보내었던 대상 데이터 이후의 데이터를 모두 폐기하고 재전송 받는다. # 3. 지정된 타임아웃 내의 ACK 프레임 분실(Lost ACK) 전송 스테이션은 분실된 ACK를 다루기 위해 타이머를 가지고 있다. 전송측에서는 이 타이머의 타임 아웃동안 ACK 데이터를 받지 못했을 경우, 마지막 ACK부터 재전송한다. 위의 그림은 송신측이 데이터 3을 보내고 수신측은 데이터 3을 받았지만 오류가 발생했을 경우이다. 이 경우에 송신측은 연속적으로 데이터를 보내지만 수신측은 데이터 3에서 오류가 발생했으므로 NAK 3을 송신측으로 보낸다. 수신측은 데이터 3 이후로 온 데이터 프레임을 모두 폐기하며 송신측은 데이터 3부터 재전송하게 된다. 위의 그림은 송신측에서 데이터 2를 보내는 도중에 분실된 경우이다. 이 경우 수신측은 데이터 0, 1은 맞게 받았지만 2를 받지 않고 3을 받게 되어 받은 데이터를 폐기하고 NAK 2를 송신측에게 보낸다. 그럼 송신측은 NAK 2를 받고 데이터 2부터 송신측은 수신측으로 데이터를 재전송하게 된다. 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송한다. 수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다. 타임아웃(ACK 분실)일 경우, 마지막 ACK된 데이터부터 재전송한다. Selective-Reject(SR) ARQ GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다. SR ARQ는 손상된, 분실된 프레임만 재전송한다. 그렇기 때문에 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 한다. GBn ARQ 기법과 SR ARQ 기법의 비교 참고 TCP Tahoe와 TCP Reno TCP/IP 혼잡제어 흐름 제어와 혼잡 제어","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"흐름 제어","slug":"흐름-제어","permalink":"https://woovictory.github.io/tags/흐름-제어/"},{"name":"혼잡 제어","slug":"혼잡-제어","permalink":"https://woovictory.github.io/tags/혼잡-제어/"},{"name":"오류 제어","slug":"오류-제어","permalink":"https://woovictory.github.io/tags/오류-제어/"}]},{"title":"[네트워크] 가상회선 패킷 교환 vs 데이터그램 패킷 교환","slug":"Network-Packet-Switching-Method","date":"2018-12-28T08:20:32.000Z","updated":"2020-05-12T15:08:02.755Z","comments":true,"path":"2018/12/28/Network-Packet-Switching-Method/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-Packet-Switching-Method/","excerpt":"","text":"패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다. 데이터그램 패킷 교환 방식 데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다. 이를 데이터그램이라 한다. 패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(비연결 지향형) 송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다. 가상회선 패킷 교환 방식 데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다. 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다. 비교 정해진 시간 안이나 다량의 데이터를 연속으로 보낼 때는 가상 회선 방식이 적합하다. 짧은 메시지의 일시적인 전송에는 데이터그램 방식이 적합하다. 네트워크 내의 한 노드가 다운되면 데이터그램 방식은 다른 경로를 새로 설정하지만, 가상회선 방식은 그 노드를 지나는 모든 가상회선을 잃게 된다. [부족한 내용 업데이트 해야 함.] 참고 데이터그램 패킷 교환 vs 가상회선 패킷 교환 참고할 예정 : 패킷교환방식인 데이터그램방식과 가상회선방식을 비교 참고할 예정 : [데이터그램(Datagram) &amp; 가상회선(Virtual Circuit)]","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"패킷 교환","slug":"패킷-교환","permalink":"https://woovictory.github.io/tags/패킷-교환/"}]},{"title":"[네트워크] UDP와 TCP","slug":"Network-UDP-TCP-Concept","date":"2018-12-28T06:14:42.000Z","updated":"2020-05-12T15:07:59.301Z","comments":true,"path":"2018/12/28/Network-UDP-TCP-Concept/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-UDP-TCP-Concept/","excerpt":"","text":"인터넷은 트랜스포트 계층에 연결형 프로토콜과 비연결형 프로토콜. 이렇게 두 개의 주된 프로토콜을 갖는다. # UDP UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜이다. IP 데이터크램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다. UDP가 특별히 유용한 분야는 클라이언트-서버 상황이다. 종종 클라이언트는 서버로 짧은 요청을 보내고 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실되면, 클라이언트는 time-out되고 다시 시도할 수 있다. 코드가 간단할 뿐만 아니라 TCP처럼 초기 설정에서 요구되는 프로토콜에서보다 적은 메시지가 요구된다. UDP가 사용되는 분야 DNS 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다. 실시간 멀티미디어 실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 패킷 형식으로 전송하는 실시간 트랜스포트 프로토콜(RTP :: Real-time Transprot Protocol)이 탄생했다. RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 멀티 플렉싱하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지들로 전송될 수 있다. RTP는 단지 UDP를 사용하기 때문에 전달, 지연, 손실 등에 대한 보장이 없다. [멀티플렉싱이 뭘까…?] 이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 바로 전 패킷보다 하나 높은 번호가 주어진다. 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 분실되었는지 알 수 있게 한다. 만약 한 패킷이 없다면 이를 획득하기 위해 목적지에서의 최상의 동작은 보간(Interpolation)에 의해 손실한 값에 대한 근사치를 얻는 것이다. 재전송은 재전송된 패킷이 유용하기에 너무 늦게 도착하므로 실용적인 옵션이 아니다. 그러므로 RTP는 확인 응답이 없고 재전송을 요청하는 메커니즘도 없다. 서로 다른 경로로 패킷을 처리함에도 순서를 부여하거나 재조립을 하거나 또는 흐름제어, 혼잡제어 등의 신뢰성 처리를 하지 않기 때문에 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터의 전송을 보장하지 못한다는 단점도 존재한다. # TCP 대부분의 인터넷 응용분야들은 신뢰성과 순차적인 전달을 필요로 한다. UDP로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다. TCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 서비스를 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다. 또한, TCP는 연결형 프로토콜로 3-way-handshake 과정을 통해서 연결을 설정하고 4-way-handshake 과정을 통해서 연결을 해제[가상 회선 방식]한다. 흐름 제어 및 혼잡 제어를 통해 높은 신뢰성을 보장한다. 그러나 이러한 기능 때문에 UDP보다 속도가 느리다. 그리고 전송 순서를 보장하며 수신 여부를 확인할 수 있다. TCP는 연속성보다 신뢰성이 있는 전송이 중요할 때 사용하는 프로토콜이다. 하나의 연결을 설정하려면 한쪽(서버)은 listen과 accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 listen과 accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 다른 한 쪽(client)은 connect를 실행하고 목적지 IP 주소와 포트 번호, 수신 가능한 최대 TCP 세그먼트 크기 그리고 기타 사용자 데이터를 명시한다. 1. TCP 연결방식 모든 TCP 연결은 전이중(full-duplex), 점대점(point to point) 방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다. 또한 메시지 스트림이 아니라 바이트 스트림의 형태를 갖는다. 메시지의 시작에서 끝까지 경계가 유지되지 않는다. 2. TCP 특징 TCP 연결상의 모든 바이트가 고유의 32-비트 순서번호(sequence number)를 갖는다. 송수신 TCP 개체들은 세그먼트의 형태로서 데이터를 주고받는다. 한 세그먼트는 고정 2바이트 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다. TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다. 세그먼트 크기에는 두 가지 제약요소가 있다. 모든 세그먼트들은 TCP 헤더를 포함하여 IP 수용량인 65,515 바이트를 넘을 수 없다는 것. 모든 네트워크는 정해진 **MTU(Maximum transfer Unit,최대 전송 단위)**를 갖는데 각 세그먼트는 이 MTU를 넘을 수 없다는 것. TCP는 IP와 함께 사용하는데 IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다. TCP는 신뢰성있는 데이터 전송을 지원하는 연결 지향형 프로토콜이다. 연결지향형인 TCP는 3-way-handshake 과정을 통해 연결 후 통신을 시작한다. TCP에서 사용하는 포트 번호의 수는 0 ~ 65535(=2^16)이며, 총 65536개가 사용 가능하다. TCP 개체들에 의해 사용되는 기본 프로토콜은 동적으로 윈도우 크기를 조절할 수 있는 슬라이딩 윈도우(Sliding Window)프로토콜이다. 송신자는 한 세그먼트를 전송할 때, 타이머를 구동시킨다. 그 세그먼트가 목적지에 도달하면 수신측 TCP 개체는 다음에 받으려고 하는 순서번호와 같은 응답 번호를 포함하는 세그먼트를 송신측으로 보낸다. 보낼 데이터가 있다면 그 데이터와 함께 보낸다. -Ex) 예를 들어, 송신측에 보낼 세그먼트가 3개 있고 번호는 1,2,3이라고 하자. 송신자는 1번 세그먼트를 수신측에 보낸다. 세그먼트가 목적지에 도달하면 수신측 TCP는 다음에 받으려고 하는 순서번호와 같은 확인 응답 번호 2를 포함하는 세그먼트를 송신측에 보낸다. 만일 확인 응답의 수신 전에 보낼 때 구동시킨 타이머가 종료되면 송신자는 그 세그먼트를 재전송한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 장치가 필요하며, 스트림 내의 각 바이트가 자기 고유의 offset을 가지고 있는데 이것을 장치로 한다. TCP에서 흐름 제어는 가변크기의 슬라이딩 윈도우를 사용하여 처리된다. window size 필드는 확인 응답된 바이트에서 시작하여 얼마나 많은 바이트가 보내질 수 있는지를 나타낸다. 그러나 이 경우 좋지 않은 상황이 발생할 수 있다. 송신자는 응용프로그램에서 데이터가 올 때마다 전송할 필요가 없고 수신자도 마찬가지로 데이터를 받은 즉시 확인 응답을 해야 하는 것은 아니다. 버퍼를 사용하면 되기 때문에 데이터를 모아서 보내거나 그것을 받고 애플리케이션에게 모아서 전달할 수 있는 것이다. 인터렉티브 에디터 네이글 알고리즘 애플리케이션에서 수신된 데이터를 1바이트씩 가져가는 것 3가지 추후 공부","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"TCP","slug":"TCP","permalink":"https://woovictory.github.io/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://woovictory.github.io/tags/UDP/"}]},{"title":"[네트워크] 3&4 Way Handshake","slug":"Network-TCP-3-4-WayHandShake","date":"2018-12-28T04:45:32.000Z","updated":"2020-05-12T15:08:01.037Z","comments":true,"path":"2018/12/28/Network-TCP-3-4-WayHandShake/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-TCP-3-4-WayHandShake/","excerpt":"","text":"3-Way-Handshake와 4-Way-Handshake 네트워크를 사용한 통신에서 TCP 통신을 하는 경우, 3-way-handshake라는 과정을 거친다. TPC/IP 프로토콜을 이용해서 통신하는 두 종단간에 데이터 전송 전 정확한 데이터 전송을 보장하기 위해 사전에 연결하는 과정이다. 연결 성립(Connection Extablishment) 클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다. 서버는 클라이언트의 요청인 SYN(a)을 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)과 SYN(b)가 설정된 패킷을 클라이언트에게 발송한다. 클라이언트는 서버의 수락 응답인 ACK(a+1)과 SYN(b) 패킷을 받고 ACK(b+1)을 서버로 보내면 연결이 성립(establish)된다. 연결 종료(Connection Termination) TCP 통신에서 3-way-handshake를 통한 연결을 해제하는 과정이다. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다. 서버는 클라이언트의 요청(FIN)을 받고 알겠다는 확인 메시지로 ACK를 보낸다. 2-1) 그리고 나서는 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.(서버측 :: 자신의 통신이 끝날 때까지 기다리며 서버는 해당 포트에 연결되어 있는 Application에게 close() 을 요청한다.) 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.(close() 요청을 받은 Application은 종료 프로세스를 진행하고 FIN 패킷을 Client에게 전송!) 클라이언트는 FIN 메시지를 확인했다는 메시지(ACK)를 서버에게 보낸다. 4-1) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.(TIME_WAIT)[TIME_WAIT에서 일정 시간이 지나면 close 된다.] 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close 한다. 연결 설정과 종료 단계에서 차이가 나는 이유는 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문이다. 따라서 일단, 클라이언트는 FIN에 대한 확인 응답인 ACK를 먼저 보내고, 데이터를 모두 전송한 후 서버 자신도 FIN을 보내기 때문이다. 클라이언트의 FIN 전송 후 ACK를 기다리는 FIN_WAIT1과 서버의 ACK를 받은 후 서버의 FIN을 기다리는 FIN_WAIT2는 일정 시간 후 TIME_OUT이 되면 스스로 연결을 종료한다. 그러나 CLOSE_WAIT은 Application에서 close()를 적절하게 처리해주지 못하면 CLOSE_WAIT 상태로 계속 기다리게 된다. CLOSE_WAIT 상태인 연결이 많아지면 Hang이 걸려 더 이상 연결을 하지 못하는 경우가 생긴다. [Hang이 뭘까…?] SYN Packet과 ACK Packet란? SYN :: synchronize sequence number ACK :: acknowledgement TCP Header에는 Control Bit(플래그 비트, 6bit)라는 부분이 존재한다. 각각의 비트들은 의미를 가지고 있으며, Urg-Ack-Psh-Rst-Syn-Fin 이다. 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다. ex) SYN 패킷일 경우에는 000010이 되고 ACK 패킷일 경우에는 010000이 된다. 왜 패킷의 종류가 두개인가? 일단 연결을 성립하려면 서로 통신이 가능한지를 먼저 파악하기 위해 패킷을 먼저 주고받아야 한다는 것까지는 이해가 쉽다. 그런데 두 종류의 패킷을 주고 받는다. 이는 요청과 응답에 대한 패킷을 주고 받아야 하기 때문에 두 종류인 것이다. 2-way가 아니고 3-way인 이유는?? 비유를 들어보자. 클라이언트가 자신의 목소리가 들리는지 물어본다.(SYN) 서버는 클라이언트의 목소리가 들린다고 말한다.(SYN+1) 그리고 자신의 목소리가 들리는지 물어본다.(ACK) 클라이언트는 서버의 목소리가 들린다고 말한다.(ACK+1) 이런 과정인 셈이다. TCP Connection은 양방향성 Connection이다. 클라이언트에서 서버에게 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, 서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. 그렇기 때문에 2-way-handshake로는 부족하므로 3-way-handshake를 사용한다. sequence number가 난수인 이유는? 처음 클라이언트에서 SYN 패킷을 보낼 때 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 sequence number를 ISN이라고 한다. ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇일까? Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다. 이러한 문제가 발생할 가능성을 줄이기 위해 난수로 ISN을 설정하는 것이다. 참고 TCP 3-way-handshake &amp; 4-way-handshake","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"TCP","slug":"TCP","permalink":"https://woovictory.github.io/tags/TCP/"},{"name":"3 & 4 Way Handshake","slug":"3-4-Way-Handshake","permalink":"https://woovictory.github.io/tags/3-4-Way-Handshake/"}]},{"title":"[네트워크] HTTP","slug":"Network-HTTP-Method-Diff-Of-GET-POST","date":"2018-12-28T03:02:38.000Z","updated":"2020-05-12T15:08:05.409Z","comments":true,"path":"2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/","link":"","permalink":"https://woovictory.github.io/2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/","excerpt":"","text":"HTTP란? HTTP(HyperText Transfer Protocol)의 약자로 하이퍼 텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, Web Server와 Web Clinet 간의 통신을 하기 위한 통신 규약이다. HTTP는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 월드 와이드 웹(WWW) 기반에서 전 세계적인 정보 공유를 이루는데 큰 역할을 하였다. HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 요청(request)과 응답(response)을 전송한다. HTTP 특징 HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석된다. TCP/IP를 이용하는 응용 프로토콜이다. HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.[이러한 단점을 해결하기 위해 쿠키와 세션이 등장.] HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청(request)와 응답(response) 방식으로 동작한다. 동작 사용자(Client)가 브라우저를 통해서 어떠한 서비스를 url을 통해서 혹은 다른 방법으로 요청(request)을 하면 서버에서는 해당 요청 사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작한다. 요청 : client -&gt; server 응답 : server -&gt; client HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다. Plain text로부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며 보통은 client가 어떤 정보를 어떻게 받고 싶은지 명시해주는 경우가 많다. (HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지) HTTP의 GET과 POST 비교 GET과 POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다. PUT과 DELETE도 있지만 지금은 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도로 사용할 수 있도록 하자. 1. GET GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송된다. “url?(데이터)” 처럼 request를 보내는 것이다. 이러한 방식은 url이라는 공간에 데이터가 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또한, 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되므로 GET 방식은 적절하지 않다. ex) password 2. POST POST 방식은 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다. 따라서 GET 방식에 비해서 더 큰 데이터를 보낼 수 있어 큰 데이터를 요청하는 경우에 사용할 수 있다. 보안적인 측면에서는 암호화를 하지 않은 이상 차이가 없다. GET은 가져오는 의미를 가지고 있다. 서버에서 어떤 데이터를 가져와서 보여주는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다. 반면에 POST는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다. GET 방식의 요청은 브라우저에서 Caching할 수 있다. 따라서 POST 방식보다 빠르게 응답할 수 있다. POST 방식으로 요청해야 할 데이터의 크기 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청을 한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 한다.","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"HTTP","slug":"HTTP","permalink":"https://woovictory.github.io/tags/HTTP/"}]},{"title":"[자료구조] Graph","slug":"DataStructure-Graph","date":"2018-12-28T02:07:43.000Z","updated":"2020-05-12T06:34:49.555Z","comments":true,"path":"2018/12/28/DataStructure-Graph/","link":"","permalink":"https://woovictory.github.io/2018/12/28/DataStructure-Graph/","excerpt":"","text":"정점과 간선의 집함, Graph 그래프 관련 용어 정리 정점과 간선의 집함, Graph 그래프란 정점과 간선의 집합을 말한다. ex) 트리는 그래프. [싸이클이 허용되지 않는 그래프이다.] 그래프 관련 용어 정리 V(vertex) : 정점을 의미한다. E(edge) : 간선을 의미한다. Directed Graph(Digraph) 말 그대로 정점과 간선의 연결관계에 있어서 방향성이 포함되어 있는 그래프를 말한다. V = {1,2,3,4,5,6} E = {(1,4),(2,1),(3,4),(5,6)} (u,v) = vertex u에서 vertex v로 가는 edge Undirected Graph 정점과 간선의 연결관계에 있어서 방향성이 없는 그래프를 말한다. Degree Undirected Graph에서 각 정점(Vertex)에 연결된 Edge의 개수를 Degree라고 한다. Directed Graph에서는 간선에 방향성이 존재하기 때문에 Degree가 두 개로 나뉘게 된다. 각 정점으로부터 나가는 간선의 개수를 Outdegree라고 하고, 들어오는 간선의 개수를 Indegree라고 한다. 가중치 그래프(Weight Graph) 가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프는 모든 간선의 가중치가 동일한 그래프이다. 부분 그래프(Sub Graph) 부분 집합과 유사한 개념으로 부분 그래프라는 것이 존재한다. 부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다. 그래프를 구현하는 두 방법 [무슨 말일까…?ㅠ^ㅠ] 인접 행렬(adjacent matrix) 정방 행렬을 사용하는 방법이다. 해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)으로 파악할 수 있다. Edge 개수와는 무관하게 V^2의 Space Complexity(공간 복잡도)를 갖는다. =&gt; Dense graph를 표현할 때 적절한 방법이다. 인접 리스트(adjacent list) 연결 리스트를 사용하는 방법이다. vertex의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다. Space Complexity는 O(E + V)이다. =&gt; Sparse graph를 표현하는데 적당한 방법이다. [어려운 용어가 많이 나온다… 더 공부하자!!] 그래프 탐색 그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다. 1. 깊이 우선 탐색(Depth First Search: DFS) 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결된 정점이 없으면 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다. 어떤 자료구조를 사용해야 할까? 바로 Stack이다. Time Complexity : O(V + E) =&gt; vertex개수+edge개수 2. 너비 우선 탐색(Breadth First Search: BFS) 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서 자료구조로 Queue를 사용한다. 연락을 취한 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 Queue에 넣는다.(enqueue) 그리고 dequeue를 하면서 dequeue를 하는 정점과 간선으로 연결된 정점들을 enqueue한다. 즉, vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다. Time Complexity : O(V + E) =&gt; vertex개수+edge개수 BFS로 구한 경로는 최단 경로이다. 참고 Graph라는 자료구조에 대해서","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Graph","slug":"Graph","permalink":"https://woovictory.github.io/tags/Graph/"}]},{"title":"[자료구조] Hash","slug":"DataStructure-HashTable","date":"2018-12-27T14:17:04.000Z","updated":"2020-05-12T06:34:52.068Z","comments":true,"path":"2018/12/27/DataStructure-HashTable/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-HashTable/","excerpt":"","text":"HastTable Hash(또는 HashMap)은 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 인덱스를 이용한 빠른 검색 속도를 갖는다. 특정한 값을 searching하는데 데이터 고유의 인덱스로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다. [항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.] 그리고 데이터의 삽입과 삭제 시 기존 데이터를 밀어내거나 다시 채우는 작업이 필요없도록 특별한 알고리즘을 이용하여 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에 삽입 시 다른 데이터의 사이에 끼어들거나 삭제 시 다른 데이터로 채울 필요가 없으므로 추가적인 데이터의 이동이 없다. '특별한 알고리즘’이라는 것을 통해서 고유한 인덱스 값을 설정하는 것이 중요한 포인트이다. 앞서 언급한 특별한 알고리즘을 해시 메소드 또는 해시 함수라고 하고 이 메소드에 의해 반환되는 데이터의 고유한 숫자 값을 hashCode라고 한다. Java에서는 Object 클래스의 _hashCode()_라는 메소드를 이용하여 모든 객체의 hashcode 값을 쉽게 구할 수 있다. hash 메소드를 구현하는 가장 간단한 방법은 나머지 연산자를 이용하는 것이다. 저장할 데이터의 값을 저장할 hash table의 크기로 나누고 나머지 연산 결과를 데이터의 인덱스로 사용하는 것이다. 하지만 이렇게 하면 문제점이 발생한다. 만약 3의 배수로 이루어진 데이터 9개를 저장한다고 가정해보자. 저장하려는 데이터 : 3,6,9,12,15,18,21,24,27 hashcode 값 계산 3 % 9 == 3 6 % 9 == 6 9 % 9 == 0 12 % 9 == 3 15 % 9 == 6 18 % 9 == 0 21 % 9 == 3 24 % 9 == 6 27 % 9 == 3 계산 결과 hashcode 값이 0,3,6으로 집중되고 있다. 이렇게 되면 같은 index로 접근하게 되는 value가 많아져 데이터를 저장할 수 없게 되는 충돌 현상이 발생한다. 이를 Collision이라고 한다. 이런 충돌을 최소화 하기 위한 가장 간단한 방법은 나머지 연산의 값이 중복되지 않도록 테이블의 크기를 소수(Prime number)로 만드는 것이다. 위와 동일한 입장일 경우, 저장하려는 데이터의 크기가 9이므로 9보다 큰 소수인 11로 나머지 연산을 해보자. hashcode 값 계산 3 % 11 == 3 6 % 11 == 6 9 % 11 == 9 12 % 11 == 1 15 % 11 == 4 18 % 11 == 7 21 % 11 == 10 24 % 11 == 2 27 % 11 == 5 중복되는 값이 깨끗하게 사라진 것을 확인할 수 있다. 하지만 이 방법으로 모든 것이 해결된 것일까?? 위의 과정에서 데이터의 성질이 달라져 다른 값이 들어올 수 있게 된 경우는 어떨까? 예를 들어 26이라는 데이터를 추가적으로 저장해야 한다면 데이터의 크기는 10이 되고 10보다 큰 소수는 11로 나머지 연산자 방법을 수행해준다. 26 % 11 == 4 결과를 확인해보니 다시 중복이 발생하였다. 바로 Collision이 발생한 것이다. Hash Table의 크기를 소수로 만드는 것은 충돌을 줄일 수는 있지만 원천적으로 해결해주지는 못한다. 충돌이 많아질수록 Searching에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 해쉬 함수는 해시를 해시답게 사용하지 못하도록 한다. 좋은 해쉬 함수를 선택하는 것은 해쉬 테이블의 성능 향상에 필수적인 것이다. 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.(Collision) 따라서 해싱된 인덱스에 이미 다른 값이 들어가 있다면 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수적이며 그 방법들에 대해 알아보고자 한다. 기본적인 두 가지 방법을 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 응용한 방법들이다. Open Address 방식(개방 주소법) 해시 충돌이 발생하면 즉 삽입하려는 해시 버킷이 이미 사용 중인 경우, 다른 해시 버킷에 해당 자료를 삽입하는 방식이다. 버킷(bucket)이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다. 공개 주소 방식이라고도 불리는 이 알고리즘은 Collision(충돌)이 발생하면 데이터를 저장할 장소. 즉 다른 해시 버킷을 찾아 헤맨다. 이 과정에서도 여러 방법들이 존재하는데 다음 3가지에 대해 간단하게 알아보자. Linear Probing 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다. Worst case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. Quadratic probing 2차 함수를 이용해 탐색할 위치를 찾는다. Double hashing probing 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두가지 방법에 비해 많은 연산량을 요구한다. Seperate Chaining 방식(분리 연결법) 참고로 Java 7에서는 Seperate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Why? HashMap의 특성상 remove() 메소드가 빈번하게 일어날 수 있는데 데이터를 삭제할 때 OpenAddress 방식은 처리가 효율적이기 어렵다. 또한 저장된 Key-value 쌍의 개수가 일정 개수 이상 많아지면 보통 Seperate Chaining 방식에 비해 Open Address 방식이 느리다. 연결 리스트를 사용하는 방식(LinkedList) 각각의 버킷들을 연결리스트(Linked List)로 만들어 Collision이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 일반적으로 Open Address 방법은 Seperate Chaining 방식보다 느리다. Open Address의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면에 Seperate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case에 가까워지는 것을 줄일 수 있다. 보조 해시 함수에 대한 글 Tree를 사용하는 방식(Red-Black-Tree) 기본적인 알고리즘은 Seperate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 여기서 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 버킷에 할당된 Key-Value 쌍의 개수이다. 트리는 기본적으로 메모리 사용량이 많고 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 연결 리스트의 성능 상의 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 연결 리스트를 사용한다. 데이터가 적다는 것은 얼마나 적다는 것을 의미할까?? 앞에서 언급한 것처럼 기준은 하나의 버킷에 할당되는 Key-Value 쌍의 개수이다. 이 Key-Value 쌍의 개수가 6개, 8개를 기준으로 결정한다. 오잉…? 왜 기준이 2개인가?? 이는 아래에서 설명하겠다. 결론부터 말하자면 연결 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다. 한 가지 상황을 가정해보자. 해시 버킷에 6개의 Key-Value 쌍이 들어있다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료 구조를 연결 리스트에서 트리로 변경해야 한다. 그러다가 바로 하나의 값이 삭제된다면 다시 트리에서 연결 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1이라면 Switching 할 때 생기는 비용이 너무 많이 필요하게 되는 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개 -&gt; 7개로 증가했을 때는 연결 리스트의 자료구조를 취하고 있을 것이고 8개 -&gt; 7개로 감소했을 때는 트리의 자료 구조를 취하고 있을 것이다. 참고로 Java 8을 구현하는데 사용하는 트리는 RBT이다. 해시 버킷 동적 확장(Resize) 해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능상 손실이 발생할 수도 있다. 그래서 HashMap은 Key-Value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 일정 개수 이상?? 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor로 HashMap의 생성자에서 지정할 수도 있다. 참고 hashcode와 HashMap에 대해서","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Hash","slug":"Hash","permalink":"https://woovictory.github.io/tags/Hash/"}]},{"title":"[자료구조] Red-Black Tree","slug":"DataStructure-RBT","date":"2018-12-27T13:01:28.000Z","updated":"2020-05-12T06:34:58.964Z","comments":true,"path":"2018/12/27/DataStructure-RBT/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-RBT/","excerpt":"","text":"RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식의 자료구조이다. 먼저 레드 블랙 트리를 알아보기 전에 BST가 무엇인지 한번 더 알고 넘어가자. BST(Binary Search Tree)는 이진 탐색 트리이다. 효율적인 탐색을 위해 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 저장 방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다. 규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다. 규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다. 규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다. 규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. Red Black Tree 결론부터 말하자면 Red-Black-Tree에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 Complete Binary Tree인 경우이다. 1. Red-Black-Tree의 정의 Red-Black-Tree를 앞으로 RBT라고 부르도록 하겠다. RBT는 다음의 성질을 만족하는 BST이다. 각 노드는 Red 혹은 Black라는 색깔을 갖는다. Root node의 색깔을 Black이다. 각 leaf node(단말 노드)는 black이다. 어떤 노드의 색깔이 red라면 두 개의 children의 색깔은 모두 black이다. 각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black node들을 포함하고 있다. 이를 해당 노드의 Black-Height라고 한다. [노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수] [무슨 말일까…? 어렵다!] 2. RBT의 특징 Binary Search Tree이므로 BST의 특징을 모두 갖는다. Root node부터 leaf node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 balanced 상태라고 한다. 노드의 child가 없을 경우, child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL은 leaf node로 간주한다. RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 그렇다면 이를 어떻게 해결할 것인가?? 삽입 우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 Red로 지정한다. Red로 지정하는 이유는 Black-Height의 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고 Black-Height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node 들의 Black-Height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2미만으로 유지된다. 삭제 삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation을 하고 노드의 색깔을 조정한다. &lt;지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Heap","slug":"Heap","permalink":"https://woovictory.github.io/tags/Heap/"}]},{"title":"[자료구조] Heap","slug":"DataStructure-Heap","date":"2018-12-27T12:45:11.000Z","updated":"2020-05-12T06:34:54.460Z","comments":true,"path":"2018/12/27/DataStructure-Heap/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-Heap/","excerpt":"","text":"Heap Heap Heap 자료구조는 일종의 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree(완전 이진 트리)이다. 배열에 트리의 값을 넣어줄 때, 0번째는 건너뛰고 1부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. 힙에는 최소 힙(min heap)과 최대 힙(max heap) 두 종류가 있다. Max Heap이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 Complete Binary Tree(완전 이진 트리)를 말한다.[Min Heap은 그 반대.] Max Heap에서는 Root node에 있는 값이 제일 크므로 최대값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다. 그리고 Complete Binary Tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다. (즉, 배열의 장점 중 하나인 Random Access가 가능하다) Min Heap에서는 최소값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다. Heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 Heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 Heapify 과정을 거쳐 Heap 구조를 유지한다. 이런 경우 결국에는 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있다. [Heap 구조를 유지시키는 더 자세한 내용을 추가 예정.]","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Heap","slug":"Heap","permalink":"https://woovictory.github.io/tags/Heap/"}]},{"title":"[자료구조] Tree 개념","slug":"DataStructure-Tree","date":"2018-12-27T07:59:05.000Z","updated":"2020-05-12T06:42:10.484Z","comments":true,"path":"2018/12/27/DataStructure-Tree/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-Tree/","excerpt":"","text":"Tree 트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계를 표현하는 자료구조이며, 표현에 집중한다. 무엇인가를 저장하고 꺼내야 한다는 사고를 벗어나 트리라는 자료구조를 보자. 트리를 구성하고 있는 구성요소들 Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미 Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미 Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미 Terminal Node(=leaf Noed, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미 Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다. 트리의 속성 중 가장 중요한 것은 루트 노드를 제외한 모든 노드는 단 하나의 부모 노드만을 가진다는 것이다. 이 속성 때문에 트리는 다음의 성질을 만족한다. 임의의 노드에서 다른 노드로 가는 경로(path)는 유일하다. 회로(cycle)가 존재하지 않는다. 모든 노드는 서로 연결되어 있다. 엣지를 하나 자르면 트리가 두 개로 분리된다. 엣지의 수(E) = 노드의 수(V) - 1 Binary Tree(이진 트리) 루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나누어진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다. 즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다. 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf Node에 다 달았을 때 정의가 만족되기 때문이다. 트리에서는 각 층 별로 숫자를 매겨서 이를 트리의 Level이라고 한다. 루트 노드부터 시작하고 루트 노드의 Level은 1이다. 그리고 트리의 최고 Level을 가리켜 해당 트리의 height(높이)라고 한다. 완전 이진 트리(Complete Binary Tree) 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진 트리라고 한다. 포화 이진 트리(Full Binary Tree) 모든 레벨에서 노드들이 꽉 채워진 이진트리를 말한다.(= 잎새 노드를 제외한 모든 노드가 자식 노드를 2개 가진다.) 포화 이진 트리의 노드 수가 n개라면 잎새노드의 수는 n/2를 올림한 숫자가 된다. 그리고 노드의 개수는 2^(k+1) - 1이 된다. 편향 이진 트리(skewed binary tree) 모든 노드가 부모의 왼쪽 자식이기 때문에 왼편으로 편향되어 있거나 반대로 모든 노드가 부모의 오른쪽 자식으로 되어 오른쪽으로 편향되어 있는 이진트리를 말한다. 이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면 탐색, 삽입, 삭제, 메모리 성능 등 모든 면에서 배열에 비해 좋은 것이 없다. BST(Binary Search Tree) 효율적인 탐색을 위한 저장 방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단, 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다. 규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다. 규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떤 노드의 키보다 크다. 규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떤 노드의 키보다 작다. 규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. 이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다. 이러한 이진 탐색 트리는 편항 트리가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생할 수 있기 때문이다. 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst cost가 발생하고 시간 복잡도는 O(n)이 된다. 배열보다 많은 메모리를 사용하여 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생했다. 이를 해결하기 위해 Rebalancing 기법이 등장했다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라고 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나는 추후에 살펴볼 Red-black-Tree 이다. 이진 트리의 순회 방법 이진 트리의 순회 방법을 간단하게 정리하면 아래와 같다. 루트의 위치를 기준으로 이름을 기억하면 된다. 전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리 중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리 후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"}]},{"title":"[자료구조] Array vs LinkedList","slug":"DataStructure-Diff-of-Array-LinkedList","date":"2018-12-27T06:44:23.000Z","updated":"2020-05-12T06:34:42.668Z","comments":true,"path":"2018/12/27/DataStructure-Diff-of-Array-LinkedList/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-Diff-of-Array-LinkedList/","excerpt":"","text":"2019.03.20 일자 기준으로 공부했던 내용을 수정하려고 한다. 이유는 이렇게 정리해놨지만 머리에 기억으로 남지 않기 때문이다. 먼저, Array VS LinkedList를 비교해보겠다. Array(배열) 논리적 저장순서와 물리적 저장 순서가 일치한다. 인덱스로 해당 원소에 접근이 가능하다. 인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다. 즉, Random Access가 가능하다. 배열의 원소를 삭제할 경우 삭제한 원소보다 큰 인덱스를 가진 원소들을 옮겨줘야(Shift) 하기 때문에 시간 복잡도 O(n)이 걸린다. 삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1씩 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다. 제한적인 크기를 갖는다. 즉, 삭제 또는 삽입 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생해 O(n)의 시간복잡도를 갖는다. LinkedList 자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다. 삽입과 삭제의 경우 LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다고 하는게 맞다. (아래에서 설명하겠다.) 원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회하여야 하므로 O(n)의 시간 복잡도를 갖는다. 트리의 근간이 되는 자료구조이다. LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다. 추가적으로 데이터를 삽입 / 삭제하기 위한 시간 복잡도까지 계산하면 결국 O(n)의 시간 복잡도를 갖는 셈이다. 하지만 위에서 경우에 따라서 다르다고 하지 않았는가? 삽입의 경우 일단, LinkedList는 어느 곳에 삽입하던지 O(n)의 시간복잡도를 갖는다. (만약, 중간 삽입이 없다면 즉 맨 앞과 맨 뒤에만 삽입한다면 -&gt; 시간 복잡도 : O(1)) 삭제의 경우 삭제의 경우도 삽입과 마찬가지이다. 어느 곳에 삽입하던지 O(n)의 시간 복잡도를 갖는다. (만약, 중간 삭제가 없고 맨 앞과 뒤에서만 삭제한다면 -&gt; 시간 복잡도 : O(1)) Array VS LinkedList # 데이터 접근 속도 Array는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. 따라서 Random Access를 지원한다. 시간 복잡도 O(1)로 빠르게 찾을 수 있다. LinkedList는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. 시간 복잡도 O(N) # 데이터의 삽입 속도 경우에 따라 다르다. 만약 배열에 공간이 많이 남아있고 맨 끝에 삽입한다면 삽입 속도 역시 O(1)에 가능하다. 하지만 이런 경우는 발생하기 힘든 케이스이다. Array(배열)의 경우 데이터를 중간이나 맨 앞에 삽입할 경우 그 이후의 데이터를 한 칸씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을 경우 비효율적이다. 그렇기 때문에 LinkedList가 필요하게 되었다. LinkedList는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다.(만약, 중간 삽입이 없다면 O(1)의 시간복잡도를 갖는다.) 이유는 삽입할 위치를 찾고(O(N)) 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다. 또한 Array의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받지만 LinkedList는 그럴 필요가 없다. 추가할 때마다 동적으로 할당하는 것으로 알고 있다. # 데이터의 삭제 속도 이 부분도 경우에 따라 다르다. Array는 데이터 삭제의 경우 그 위치의 데이터를 삭제 후, 전체적으로 Shift 해줘야 한다. (O(N)) LinkedList의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결구 O(N)의 시간 복잡도를 갖는다. 하지만 Array 보다 빠르게 삭제 연산을 수행한다. # 메모리 할당 Array에서 메모리는 Array가 선언되자 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다. Stack 영역에 메모리 할당이 이루어진다. LinkedList에서 메모리는 새로운 node가 추가될 때 runtime에 할당되어 진다. 이것은 동적 메모리 할당이라고 한다. Heap 영역에 메모리 할당이 이루어진다. # size Array의 size는 반드시 선언 시점에 지정되어있어야 한다. LinkedList의 size는 다양할 수 있다. node들이 추가될 때 runtime 시점에서 LinkedList의 size가 커질 수 있기 때문이다. 결론 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다. 데이터의 접근하는 게 중요하다면 Array를 사용하는 것이 좋다. 전반적인 내용을 보면 Array보다 LinkedList(포괄적인 범위에서 List라고 하겠다.)의 사용이 훨씬 좋아보인다. 하지만 일반적인 알고리즘 문제를 풀 때는 List보다 Array가 훨씬 빠르고 좋다. 왜냐하면 대부분의 알고리즘 문제는 메모리 공간의 범위를 파악할 수 있도록 N의 크기가 주어지기 때문이다. 그래서 배열의 크기를 MAX로 초반에 잡을 수 있다면 훨씬 더 편리하고 List와는 다른 속도를 보인다. 왜냐하면 위에서 본 것처럼 List의 입력마다 메모리의 할당이 일어나고 삭제에서는 메모리 해제가 일어난다. 이런 작업은 시간복잡도에 포함되지는 않지만 시스템 콜(System Call)을 사용하는 구문은 시간 소요가 꽤 걸린다. 사용하려는 목적에 따라서 Array와 List를 구분해서 사용하면 된다. 자자, 위에서는 Array와 LinkedList의 차이점을 살펴보았다. 이번에는 ArrayList와 LinkedList의 차이를 살펴보겠다. 사실 위에서 본 것과 차이는 거의 없다고 생각한다. 이유는 ArrayList가 단지 내부적으로 Array(배열)를 사용하고 List 인터페이스를 구현했기 때문에 거의 똑같다고 생각한다. 그래도 한 번 살펴보자. ArrayList vs LinkedList 1. ArrayList 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다. 대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다. 반면 인덱스를 가지고 있어서 한 번에 참조가 가능해 데이터 검색에 유리하다. ArrayList는 삽입과 삭제를 할 일이 없거나 배열의 끝에서만 하게 될 경우 유용하게 쓰일 수 있다. 원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다. 2.LinkedList 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다. ArrayList와 달리 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리하다. 반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다. 3. 데이터의 검색,삽입,삭제시 성능 비교 검색 ArrayList : 인덱스 기반이기 때문에 O(1)의 시간복잡도를 갖는다. LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다. 삽입,삭제 ArrayList : 삽입,삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간복잡도를 갖는다. LinkedList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다. 하지만 이 부분도 경우에 따라 다르다. 참고 Linked List 와 Array 배열(Array)과 연결리스트(Linked List) 차이 Java의 LinkedList와 ArrayList에 대한 비교 자료구조 List - ArrayList와 LinkedList 비교 [Algorism] ArrayList와 LinkedList란 무엇인가?","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Array","slug":"Array","permalink":"https://woovictory.github.io/tags/Array/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://woovictory.github.io/tags/LinkedList/"}]},{"title":"[자료구조] 자료구조 개요","slug":"DataStructure-What-Is","date":"2018-12-27T06:01:29.000Z","updated":"2020-05-12T06:40:58.195Z","comments":true,"path":"2018/12/27/DataStructure-What-Is/","link":"","permalink":"https://woovictory.github.io/2018/12/27/DataStructure-What-Is/","excerpt":"","text":"자료구조란? 자료구조하면 무엇이 떠오르는가? 흔한 자료구조의 형태로 큐(Queue)나 스택(Stack) 혹은 연결 리스트, 트리 등을 떠올리거나 선택정렬, 삽입정렬 등의 정렬 알고리즘이 먼저 떠오른다. 사전적 의미를 살펴보면 다음과 같다. &quot;자료(data)의 집합을 의미하고 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것&quot;이라고 한다. 자료를 더 효율적으로 저장하고 관리하기 위해 사용하며 잘 선택된 자료구조는 실행 시간을 단축시켜주거나 메모리 용량의 절약을 이끌어 낼 수 있다. 자료 구조의 선택 기준은 아래와 같다. 자료의 처리 시간 자료의 크기 자료의 활용 빈도 자료의 갱신 정도 프로그램의 용이성 자료구조의 특징 효율성 자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다. Ex) 검색에 대한 알고리즘을 구현할 때, 데이터의 양이 만다면 순차 검색을 사용하는 것보다 이분 탐색(이분 검색)을 활용하는 것이 더 효율적일 것이다. 왜냐하면 학생 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다. 이에 반해, 이분 탐색은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다. 추상화 추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 시간을 더 쏟을 수 있다. 알고리즘 자체에는 중점을 두지 않는다. 마찬가지로 자료구조 내부의 구현은 중요하지 않다. 어떻게 구현했는지보다 어떻게 사용해야 하는지를 알고 있어야 한다. Ex) Stack의 경우 나중에 들어간 것이 먼저 나오는 LIFO(Last In First Out)의 형태를 가지고 있다. push() 함수를 이용해 데이터를 삽입 pop() 함수를 이용해 데이터를 추출 그 함수 내부 구현이 어떻게 되었는지는 크게 중요하지 않다. 사람마다 다른 코드를 작성할 것이고 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다. 재사용성 자료구조를 설계할 때 특정 프로그램에서만 동작하도록 설계 하지 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다. 자료구조의 분류 자료구조는 크게 선형 자료구조와 비선형 자료구조로 나뉜다. 선형 자료구조 : 데이터가 일렬로 나열되어 있는 즉, 선형인 것을 뜻한다. 배열 연결 리스트 스택 큐 비선형 자료구조 : 선형이 아닌 특정한 형태를 띄고 있는 것을 뜻한다. 트리 그래프","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"}]},{"title":"[운영체제] 멀티 쓰레드","slug":"OS-MultiThread-Concept","date":"2018-12-26T08:33:53.000Z","updated":"2020-05-12T15:13:39.867Z","comments":true,"path":"2018/12/26/OS-MultiThread-Concept/","link":"","permalink":"https://woovictory.github.io/2018/12/26/OS-MultiThread-Concept/","excerpt":"","text":"멀티쓰레드란? 멀티 프로세스와 멀티 쓰레드의 차이점 멀티 쓰레딩의 장점 멀티 쓰레딩의 문제점 멀티 쓰레드란? 하나의 프로세스를 다수의 실행 단위(즉, 쓰레드)로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티 쓰레딩이라고 한다. 하나의 프로그램이 동시에 여러 개의 일을 수행할 수 있도록 해주는 것이다. 멀티 쓰레드를 사용하는 이유는? 앞서 설명한 것처럼 프로세스를 이용하여 동시에 처리하던 일을 쓰레드로 구현할 경우 메모리 공간과 자원 소모를 줄일 수 있게 된다. 쓰레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용하여 데이터를 주고 받을 수 있는 통신을 할 수 있다. 그렇기 때문에 프로세스 간 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다. 심지어 쓰레드의 문맥교환은 프로세스의 문맥교환과는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다. 따라서 앞에서 언급한 것처럼 시스템의 처리량이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축된다.[즉, 프로그램이 빨라진다.] 이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에 여러 쓰레드로 나누어 수행하는 것이다. 멀티 프로세스와 멀티 쓰레드의 차이점 멀티 프로세스 : [데이터, 힙, 스택] 영역 모두를 비공유한다. 멀티 쓰레드 : [데이터, 힙, 스택] 영역 중 스택 영역만 비공유하고 데이터와 힙 영역은 공유한다. 멀티 쓰레딩의 장점 프로세스 생성은 앞에서 언급한 것과 같이 많은 시간과 자원을 소비한다. 이러한 단점을 최소화 시킨 일종의 경량화된 프로세스인 쓰레드를 만들게 된 것이다. 멀티 쓰레드에서 쓰레드 간 스택 영역만 비공유하고 데이터 영역과 힙 영역은 공유한다. 쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다. 멀티 쓰레드 컨텍스트 스위칭 시 데이터 영역과 힙 영역을 올리고 내릴 필요가 없다. 데이터 영역과 힙 영역을 통해 데이터 교환이 가능하다. 쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요하지 않다. 멀티 쓰레딩의 문제점 멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 대해 접근하는 일이 없었지만 멀티 쓰레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 쓰레드가 데이터 영역과 힙 영역을 공유하기 때문에 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 그렇기 때문에 멀티 쓰레딩 환경에서는 동기화 작업이 필요하다. 동기화란? 시스템의 한정적인 자원에 여러 쓰레드가 동시에 접근해서 사용하려고 하면 문제가 발생할 수 있다. 이런 문제를 방지하기 위해 쓰레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법이다. 동기화를 통해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목 현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락(lock)으로 인한 병목 현상을 줄여야 한다. 공유 자원이 아닌 부분은 동기화 처리를 할 필요가 없다. 즉, 동기화 처리가 필요한 부분에만 synchronized 키워드를 통해 동기화 하는 것이다. 불필요한 부분까지 동기화를 할 경우 현재 쓰레드는 락(lock)을 획득한 쓰레드가 종료하기 전까지 대기해야 한다. 그렇게 되면 전체 성능에 악영향을 미치게 된다. 즉, 동기화를 하고자 할 때는 메소드 전체를 동기화 할 것인가 아니면 특정 부분만 동기화할 것인가를 고민해야 한다. 임계영역 둘 이상의 쓰레드(또는 프로세스)가 공유 자원에 동시에 접근하면 문제가 발생할 수 있다. 이런 문제를 일으킬 수 있는 코드 블록을 임계 영역이라고 한다. 다시 말해 임계 영역은 배타적 접근 권한(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수, static 변수 등)에 접근하는 코드 블럭을 의미한다. 동기화 방법 여러 쓰레드들은 자원을 공유하고, 프로세스간 메시지를 전송하면서 간혹 문제가 발생할 수 있다. 즉, 공유된 자원에 여러 프로세스, 쓰레드가 접근하면서 문제가 발생한다. 그래서 동기화를 통해 작업의 처리 순서와 공유 자원에 대한 접근을 컨트롤 하는 것이다. Mutex/Semaphore/Monitor 3가지가 존재하고 모두 운영체제의 동기화 기법이다. 프로세스의 동기화 기법 쓰레드의 동기화 기법 뮤텍스 뮤텍스는 Mutual Exclusion의 약자로 공유 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것이다. 뮤텍스의 쓰레드 동기화 방법은 임계 영역에 들어가기 위해 이 뮤텍스 객체를 가지고 있어야 들어갈 수 있다. 즉, 임계 영역을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술이다. 일종의 자물쇠 역할을 한다. 임계 영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올 때까지 다른 쓰레드가 못 들어오게 내부에서 자물쇠로 잠근다. fitting romm을 예로 들어 설명하겠다. fitting room은 ‘사용중’ 표시를 하는 대신에 사용자들에게 열쇠를 지급한다. 열쇠를 지급받은 사용자는 fitting room에 들어가서 옷을 갈아입는다. 열쇠가 없는 사람들은 기다린다. 옷을 다 갈아입은 사람은 열쇠를 카운터에 반납한다. fitting room을 사용할 사람은 카운터로 가서 열쇠를 받아서 사용하면 된다. 이것이 바로 대략적인 뮤텍스에 대한 설명이다. fitting room = 임계 영역 열쇠 = mutex 사용자 = 쓰레드 아래 그림을 보며 정리하자. 임계 영역(그림의 Protected Resource)에 진입하길 원하는 3개의 고양이(쓰레드)가 있다. 임계 영역에 접근하기 위해서는 뮤텍스라는 열쇠가 필요하다. 뮤텍스를 얻어야 임계 영역에 진입할 수 있다. 한 쓰레드(고양이)가 뮤텍스(열쇠)를 획득했다. 이제 이 쓰레드(고양이)는 임계 영역에 진입할 수 있게 된다. 진입한 쓰레드는 임계 영역을 처리한다. 이 때 다른 쓰레드들은 아무일도 못하고 쉬게 된다. 뮤텍스가 반환될 때까지 쉬면서 기다릴 수 밖에 없다.(Block 상태를 의미한다.) 임계 영역에 있는 쓰레드가 빠져나와 뮤텍스를 반납한다. 쉬던 쓰레드들이 이제 뮤텍스를 가질 수 있으며 이 쓰레드들 중 하나가 뮤텍스를 가지게 될 것이다. 그리고 지금까지의 과정을 반복한다. 세마포어 세마포어 역시 뮤텍스와 비슷한 역할을 하지만 세마포어는 동시 접근 동기화가 아닌 접근 순서 동기화에 더 관련있다. 내가 운영하는 별다방이 있다고 하자. 좌석은 테이블이 5개 있다. 각 테이블에는 한명의 손님만 사용할 수 있다고 가정 손님이 와서 빈 테이블을 보면 찾아서 앉고 시간을 보내고 집에 간다. 이 카페는 5개의 테이블만큼 손님을 받을 수가 있다. 5개의 테이블이 가득 차면 다음 손님은 기다려야 한다. 옷가게 fitting room에서는 한 명만 이용할 수 있었지만, 카페에서는 5 테이블을 이용할 수 있다. 이 점이 뮤텍스와 세마포어의 차이점이다. 카페가 임계 영역(critical section)이 되고, 손님은 쓰레드가 된다. 5개의 테이블이 바로 세마 포어이다. 뮤텍스가 5개가 되는 상황으로 이해할 수 있다. fitting room으로 바꾸면 최대 5명이 동시에 이용할 수 있는 큰 fitting room이 된다. 여기서는 개인의 권리가 없는 이상한 fitting room이 된다. 아무튼 이런 fitting room을 이용하려면 5개의 열쇠가 필요하다. 5개의 열쇠 즉, 5개의 뮤텍스가 바로 세마포어가 된다. 그래서 세마포어는 뮤텍스와 다르게 count와 관련된 사항이 중요하다. 세마포어는 다음의 세 가지 원자적인 연산만을 지원한다. initialize, decrement, increment initialize : 세마포어 초기화(음이 아닌 정수값으로 초기화) decrement : 프로세스를 블록시킬 수 있다. increment : 블록되었던 프로세스를 깨울 수 있다. 이 세마포어를 카운팅 세마포어 또는 범용 세마포어라고 한다. 세마포어의 값에 따라 운영체제는 프로세스가 즉시 자원을 사용할지, 자원이 다른 프로세스에 의해 사용 중인걸 알게 될 경우에는 일정 시간을 기다려야 한다. 프로세스가 자원을 사용하는 동안에는 세마포어 값을 변경함으로써 다른 프로세스들이 기다리게 해야 한다. 프로세스간 메시지를 전송하거나 고유 메모리를 통해 특정 데이터를 공유하게 될 경우 공유 자원에 여러 프로세스가 접근하면서 문제가 발생하기 때문에 하나의 프로세스만 공유 자원에 접근 가능하도록 설정할 때 세마포어를 사용한다. 이진 세마포어 : 0 또는 1의 값을 가지는 세마포어 위 그림은 뮤텍스를 설명하는 그림이다. 세마포어는 다수의 뮤텍스로 이해할 수 있다고 했으므로 다음 그림처럼 표현할 수 있다. 임계 영역으로 들어갈 수 있는 열쇠인 세마포어가 3개이다. 어떤 쓰레드가 세마포어를 얻으면 남은 세마포어의 수는 2개이다. 또 어떤 쓰레드가 세마포어를 얻어서 진입했다. 남은 세마포어의 수는 1개이다. 또 어떤 쓰레드가 세마포어를 얻어서 진입했다. 그러면 남은 세마포어의 수는 0개이다. 또 어떤 쓰레드가 임계영역에 진입하려 할 때, 더이상 남은 세마포어가 없기 때문에 임계영역 내에 어떤 쓰레드가 빠져나오면서 세마포어를 반납할 때까지 기다려야 한다. 모니터 Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다. 예를 들어 자바에서 모든 객체는 Object 클래스를 상속 받는다. 이 Object 클래스에는 wait(), nofityAll(), nofity() 메소드를 가지고 있는데 이게 바로 Condition Variables 역할이라고 보면 된다. 고로 모든 자바 객체는 Monitor를 가지고 있다. 자바에서는 Mutual Exclusion 해결을 위한 구현체로 Synchronization 키워드가 있다. 예들 들어, Synchronization가 메소드에 선언되어 있고, 쓰레드 A가 이미 Lock을 획득해서 Critical Section(메소드, 임계영역)을 수행중이라고 가정하자. 쓰레드 B가 동일한 메소드를 수행하기 위해 해당 Object의 Lock을 획득해야 할 것이다. 이 Lock이 반환될 때까지 대기를 해야하는데 그 때 사용되는게 바로 Monitor이다. 쓰레드 A가 Lock을 반환하면 쓰레드 B는 기다렸다가 Lock을 획득하게 된다. 그리고 Critical Section인 메소드를 수행할 수 있게 된다. 물론 Synchronized 키워드를 사용했을 때 자동적으로 수행되는 내부 동작이고, 별도로 명시적인 Monitor를 구현할 수도 있다. 그 외 Monitor의 다른 정의로는 공유자원에 안전하게 접근하기 위해 Mutual Exclusion가 랩핑된 Thread-Safe한 클래스, 객체, 모듈들을 의미하기도 한다. 하지만, 위의 모니터에 대한 설명은 무슨 말인지 이해가 가지 않는다. ㅜㅜ 이해가지 않으니 차이점이라도 알고 넘어가자. 우선 뮤텍스 / 모니터 / 세마포어는 개념적으로 차이가 있다. 전자(뮤텍스, 모니터)는 상호 배제를 함으로써 임계구역에 하나의 쓰레드만 들어갈 수 있다. 상호 배제란? 여기서 등장하는 상호 배제는 무엇일까?? 상호 배제는 한 프로세스가 공유 자원을 접근하는 임계 영역 코드를 수행하고 있으면 다른 프로세스ㅡㄹ은 공유 자원을 접근하는 임계 영역의 코드를 수행할 수 없다는 조건이다. 임계 영역을 보호하기 위한 개념 둘 이상의 프로세스(혹은 쓰레드)가 공유자원에 대해 동시에 읽거나 쓰는 것을 방지하기 위한 기법 상호 배제 기법에는 뮤텍스, 세마포어, 모니터, 메시지 전달 등의 기법이 있다. 후자(세마포어)는 하나의 쓰레드만 들어가거나 혹은 여러 개의 쓰레드가 들어가게 할 수도 있다. Q. 뮤텍스와 모니터의 차이는? 가장 큰 차이는 뮤텍스는 다른 프로세스(애플리케이션) 간에 동기화를 위해 사용한다. 반면에 모니터는 하나의 프로세스(애플리케이션)내에 다른 쓰레드들 간에 동기화를 위해 사용한다. 또한, 뮤텍스는 보통 운영체제 커널에 의해서 제공되는 반면에 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다. 따라서 뮤텍스는 무겁고(heavy-weight) 느리며(slower) 모니터는 가볍고(light-weight) 빠르다(faster). Q. 세마포어와 모니터의 차이는? Java에서는 모니터를 모든 객체에게 기본적으로 제공하고 있는 반면 C에서는 모니터를 사용할 수 없다. 세마포어는 카운터라는 변수 값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시 매번 값을 따로 지정해줘야 하는 등 조금 번거롭다. 반면, 모니터는 이러한 일들이 캡슐화(encapsulation)되어 있어서 개발자는 카운터값을 1 또는 0으로 주어야 하는 고민을 할 필요없이 synchronized, wait(), nofity() 등의 키워드를 이용해 조금 더 편하게 동기화를 할 수 있다. Q. 뮤텍스와 세마포어의 차이는? 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없다. (뮤텍스) 세마포어 -&gt; 가능 (세마포어) 뮤텍스 -&gt; 불가능 세마포어는 소유할 수 없는 반면 뮤텍스는 소유할 수 있고 소유자가 이에 책임을 진다. 뮤텍스는 1개만 동기화가 되지만 세마포어는 하나 이상을 동기화할 수 있다. Example 변기가 하나뿐인 화장실에서는 앞의 사람이 볼일을 마치고 나와야 다음 사람이 들어갈 수 있다. 이렇게 한번에 오직 하나만 처리할 수 있는 대상에 사용하는 것이 뮤텍스이다. 변기가 세개인 화장실에서는 동시에 세 사람이 볼일을 볼 수 있고 이 세 사람 중 아무나 한명이 나오면 다음 사람이 들어가서 볼일을 볼 수 있다. 이렇게 동시에 제한된 수의 여러 처리가 가능하면 세마포어를 사용한다. 만약 변기 세개짜리 화장실의 각 변기에 대해 뮤텍스를 사용한다면 대기 중인 사람은 각 변기 앞에 줄을 서는 것이고 이렇게 되면 옆 칸이 비어도 들어가지 못하게 된다. 만약 변기 세개를 묶어서 뮤텍스를 사용한다면 변기 수에 관계없이 무조건 한명만 사용할 수 있게 된다. 변기 - 동기화 대상(즉,공유 자원) 사람 - 동기화 대상에 접근하는 쓰레드 뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 쓰레드에 의해서 사용중일 경우 다른 쓰레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만 관리하는 동기화 대상이 몇 개인가에 따라 차이가 생기게 된다. 참고 임계영역 동기화 - 뮤텍스 멀티 쓰레드란? 쓰레드란 세마포어와 뮤텍스 쓰레드와 임계영역","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"[운영체제] 쓰레드","slug":"OS-Thread","date":"2018-12-26T05:05:44.000Z","updated":"2020-05-12T15:13:30.461Z","comments":true,"path":"2018/12/26/OS-Thread/","link":"","permalink":"https://woovictory.github.io/2018/12/26/OS-Thread/","excerpt":"","text":"메모리 관점에서 본 쓰레드 IPC 쓰레드란? 쓰레드를 생성하여 프로세스를 수행했을 때의 장점 프로세스와 쓰레드의 차이 메모리 관점에서 본 쓰레드 이를 보기 전에 먼저 메모리 관점에서 본 프로세스편을 보고 오기를 추천한다. 각각의 프로세스는 메모리 공간에서 독립적으로 존재한다. 위의 그림은 프로세스를 구성하는 메모리 공간의 모습이다. 각각의 프로세스는 자신만의 이런 메모리 구조를 가진다. 프로세스 A, B, C가 존재한다면 각각의 프로세스는 모두 위와 같은 구조의 메모리 공간을 가진다. 독립적인 만큼 다른 프로세스의 메모리 공간에 접근할 수도 없다. A가 B의 메모리 공간에 접근하게 된다면 재앙이 발생할 수도 있다. 예를 들면, Chrome이 windows 메모리 공간에 접근한다면 안전성이 보장되지 않는 문제가 발생할 것이다. 운영체제의 메모리 공간에 접근하여 뭔가를 변경한다면 심각한 문제가 발생할 수 있다.(물론 운영체제의 메모리 공간에 접근하는 것은 원천적으로 불가능하다.) 그러므로 프로세스의 안전성을 보장하기 위해서는 프로세스는 각각 독립된 메모리 공간을 가져야 한다. 그렇다면 프로세스 A에서 연산한 결과를 프로세스 B가 받아서 사용하고 싶다면 어떻게 해야할까?? IPC (inter process communication) A의 메모리 공간에 B가 직접 접근하지 못하기 때문에 프로세스간의 통신을 하는 특별한 방법이 존재하는데 메일슬롯, 파이프 등이 바로 프로세스 간의 통신 즉, IPC의 예라고 할 수 있다. IPC에 대한 설명은 프로세스부분을 참고하면 된다. 여기서 중요한 점은 프로세스는 독립적인 메모리 공간을 지니기 때문에 IPC를 통하지 않고서는 통신할 수 없다는 사실이다. 그리고 프로세스가 여럿이 병렬적으로 실행되기 위해서는 필연적으로 Context Switching이 발생할 수밖에 없다. 12독립적인 메모리 공간으로 컨텍스트 스위칭이 발생한다.프로세스 간 통신하기 위해서는 IPC가 필요하다. 위의 두 가지 프로세스가 지니는 문제점을 한 번에 해결할 수 있는 녀석이 쓰레드이다. 메모리 공간에서의 쓰레드 위 그림은 프로세스와 쓰레드의 메모리 구조의 차이점을 보여주는 그림이다. 왼쪽의 프로세스는 앞에서 설명했고, 오른쪽의 쓰레드의 메모리 구조를 확인해보자. 쓰레드는 프로세스 안에 존재하는 실행 흐름이다. 메모리 구조 역시 그러하다. 특이한 점은 쓰레드는 프로세스의 heap, stack, code 영역 등을 공유한다는 사실이다. 각각의 프로세스가 독립적인 stack, heap, data, code 영역을 가진 반면에 한 프로세스에 속한 쓰레드는 stack 영역을 제외한 메모리 영역은 프로세스의 메모리 영역을 공유해서 사용한다. 쓰레드가 code 영역을 공유하기 때문에 한 프로세스 내부의 다른 쓰레드들은 프로세스가 가지고 있는 함수를 자연스럽게 호출할 수 있다. 뿐만 아니라 쓰레드는 data, heap 영역을 공유하기 때문에 IPC 없이도 쓰레드 간의 통신이 가능하다. 동일한 프로세스 내부에 존재하는 쓰레드 A, B가 통신하기 위해 heap 영역에 메모리 공간을 할당하고 두 쓰레드가 자유롭게 접근한다고 생각하면 된다. 쓰레드는 프로세스처럼 스케줄리으이 대상이다. 이 과정에서 컨텍스트 스위칭이 발생한다. 하지만 쓰레드는 공유하고 있는 메모리 영역 덕분에 컨텍스트 스위칭이 발생하는 오버헤드가 프로세스에 비해 작다. 쓰레드란? 동일한 일을 하는 부분이 많은 프로세스를 여러 개 생성하는 것은 메모리 낭비이다. 그래서 프로세스는 하나만 생성하고 Program Counter만 여러 개 생성한다. 즉, CPU 수행 단위를 여러 개를 두는 것이며 이를 쓰레드라고 한다. 각각 다른 Instruction을 수행하려면 Program Counter 값이 존재해야 하고, 메모리에 어떤 레지스터 값들을 세팅해야 할텐데, 쓰레드마다 Program Counter 값과 레지스터 값들이 들어가는 것이다. 이렇게 쓰레드를 생성하여 쓰레드마다 다른 부분의 코드를 실행할 수 있게 하면 된다. 쓰레드란 프로그램(프로세스) 실행의 단위이며 하나의 프로세스는 1개 이상의 쓰레드로 구성이 가능하다. 하나의 프로세스를 구성하는 쓰레드들은 프로세스에 할당된 메모리, 자원 등을 공유한다. 프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며 실행 상태가 변할 때마다 쓰레드 문맥 교환(context switching)을 수행한다. 각 쓰레드별로 자신만의 스택과 레지스터를 가진다. 특징 스레드는 프로세스 내에서 Stack만 따로 할당받고, 프로세스의 Code, Data, Heap 영역은 공유한다. 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하며 실행된다. 같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다. 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다. 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다. 쓰레드를 생성하여 프로세스를 수행했을 때의 장점 응답시간이 줄어든다.(Responsiveness) 하나의 프로세스 안에 여러 쓰레드를 두게 되면 즉, 다중 쓰레드로 구성된 프로세스 내에서는 하나의 서버 쓰레드가 blocked(or waiting)상태인 동안에도 동일한 프로세스 내의 다른 쓰레드가 실행되어 보다 빠른 처리가 가능하다. 웹 브라우저에서 네트워크를 통해 웹 페이지를 읽어올 때 읽어오는 작업이 오래 걸리기 때문에, 웹 브라우저 상태가 blocked 상태가 된다. 하나의 쓰레드가 데이터를 읽어오는 동안에 다른 쓰레드가 읽어온 데이터를 화면에 뿌려주는 역할을 하면 되는 것이다. 시스템의 자원소모가 줄어든다.(Resource Sharing로 인해) 하나의 프로세스 안에 여러 개의 쓰레드를 두면 메모리 낭비를 줄일 수 있다. 비슷한 작업에 대해서는 리소스를 공유한 결과이다. Economy 생성하고 switch 하는 면에서 프로세스보다 오버헤드가 적고 빠르다. 이를 경제적이라고 표현한다.[아직 정확한 원리를 잘 모른다.] Utilization of MP(MultiProcessor) Architectures 쓰레드를 생성하게 되면 병렬성을 높일 수 있다. 이는 CPU가 여러 개인 컴퓨터에서만 얻을 수 있는 장점이지만 쓰레드를 통해 이 장점을 취할 수 있다. 프로세스와 쓰레드의 차이 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 쓰레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다. 프로세스는 실행중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다. 하지만 프로세스의 생성은 많은 시간과 자원을 소모한다. 쓰레드는 프로세스의 실행단위라고 위에서 설명했다. 한 프로세스 내에서 동작하는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원 등을 공유할 수 있다. 이 경우 각각의 쓰레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다. 쓰레드마다 스택을 독립적으로 할당하는 이유 스택은 함수 호출시 전달되는 인자, 복귀 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간으로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 가능하게 한다. 따라서 독립적인 실행 흐름을 위한 최소 조건으로 독립된 스택을 할당한다. 쓰레드마다 PC Register를 독립적으로 할당하는 이유 PC 값은 쓰레드가 명령어의 어디까지 수행했는지를 나타내게 된다. 쓰레드는 CPU를 할당받았다가 스케쥴러에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당하는 것이다. 쓰레드의 장점 쓰레드는 프로세스보다 생성 및 종료시간, 쓰레드간 전환시간이 짧다. 쓰레드는 프로세스의 메모리 자원 ㄷ으을 공유하므로 커널의 도움 없이 상호 간에 통신이 가능하다. 프로세스 간의 통신 방법에 비해 쓰레드의 간의 통신 방법이 훨씬 간단하다.[별도의 자원을 이용하는 것이 아니라 전역 변수의 공간을 이용하여 데이터를 주고 받을 수 있다.] 쓰레드의 단점 동기화 문제 앞에서 언급한 쓰레드의 장점 중에서 쓰레드 간의 통신시 데이터를 주고 받는 방법은 메모리 공간을 공유하여 데이터 세그먼트, 즉 전역변수를 이용한다고 했다. 그런데 공유하는 전역 변수를 여러 쓰레드가 함께 사용하려면 충돌하는 문제가 발생한다. 따라서 쓰레드 간에 통신할 경우에는 충돌 문제가 발생하지 않도록 동기화를 통하여 문제를 해결해야 한다. 멀티 쓰레드를 이용할 때 주의 깊게 설계해야 한다. 프로그램 디버깅이 어렵다.(왜지?) 단일 프로세서 시스템에서는 효과를 기대하기 어렵다. 쓰레드의 종류 kernel Thread(커널 쓰레드) 프레소스 내 스레드가 여러 개라는 것을 OS가 알고 있는 쓰레드이다. 그래서 커널이 쓰레드 스케쥴링을 맡아서 하게 된다. User Thread(유저 쓰레드) 라이브러리 차원에서 지원되는 쓰레드이다. 프로세스 안에 쓰레드가 여러 개 있다는 것을 OS가 모르기 때문에 커널 입장에서는 하나의 일반적인 프로세스로 인식된다. 참고 [운영체제 이론] 스레드 쓰레드란 무엇인가? 프로세스와 쓰레드의 차이 프로세스와 쓰레드 차이","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"[운영체제] 프로세스","slug":"OS-Process","date":"2018-12-24T15:24:39.000Z","updated":"2020-05-12T15:13:37.513Z","comments":true,"path":"2018/12/25/OS-Process/","link":"","permalink":"https://woovictory.github.io/2018/12/25/OS-Process/","excerpt":"","text":"프로그램과 프로세스의 개념 쓰레드를 먼저 알기 전에 프로그램과 프로세스의 개념을 알아보자. 프로그램이란 디스크 내의 실행 가능한 파일을 말하며, 프로세스란 현재 실행 중인 프로그램을 말하며 태스크(task)라고도 부른다. 프로세스는 시스템 작업의 기본단위로 모든 운영체제는 프로세스 개념을 바탕으로 동작한다. 그리고 이 프로세스를 구성하는 요소들을 프로세스의 문맥(process contexts)라고 한다. 예를 들어, 윈도우 환경에서 엑셀 프로그램이 있을 때 이를 실행하여 엑셀창(윈도우)를 띄우면 이는 프로세스가 된다. 특징 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당받는다. 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다. 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다. 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process-communication)을 사용해야 한다. ex) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용 프로그램이 실행되면 위 그림과 같이 메모리 공간에 프로세스가 존재한다. stack : 지역변수 할당과 함수 호출 시 전달되는 인자값들을 저장하기 위한 공간 heap : C의 malloc, calloc와 C++,Java의 new를 통한 동적 할당을 위해 존재하는 공간 data : 전역 변수나 static 변수의 할당을 위해 존재하는 공간 code : 프로그램을 실행시키면 실행파일 내에 존재하는 명령어가 메모리 상에 올라가야 프로그램을 동작시킬 수 있다. 이 명령어들을 위해 존재하는 공간(쉽게 말해 소스코드가 올라간다고 생각하면 됨) 이렇게 프로그램을 실행시키기 위해서는 메모리에 process를 위한 공간이 필요하다. 메모리 공간을 기준으로 process를 살펴본 결과이다. 이는 나중에 쓰레드와 비교할때에도 중요한 의미를 갖는다. 특정 프로그램이 실행되기 위해서는 즉, process가 되려면 메모리에 위 그림과 같은 할당이 필수적으로 이루어져야 한다. 메모리가 할당된 다음에 CPU에 의해서 처리된다. 여기서 프로세스의 문맥이란 무엇을 말하는가? CPU 수행 상태를 나타내는 하드웨어 문맥. Program Counter 등의 register들 값을 포함한다. PC는 다음에 수행할 명령어의 위치에 대한 정보(주소값)을 담고 있다. CPU가 할당되었을 때, PC가 가리키는 부분부터 수행해나가면 되는 것이다. 즉, 프로세스가 실행될 부분이라고 생각할 수 있다. 프로세스의 주소 공간을 포함한다. 즉, code, data, stack 각각의 공간에 어떠한 값이 들어있는가를 나타내는 주소값을 포함한다. 현재 변수의 값을 얼마인가? 메모리에는 어떤 내용들이 담겨져 있는가? 스택에는 어느 내용까지 쌓여있는가? 등에 대한 정보를 모두 담고 있다. 프로세스 관련 커널 자료구조를 포함한다. PCB(Process Control Block), Kernel Stack 등을 포함한다. 프로세스가 하나 시작될 때마다 운영체제에서는 그 프로세스를 관리하기 위해 PCB를 생성한다. 커널의 주소 공간에서 data에 해당하는 부분에 PCB를 저장해둔다. 이는 운영체제가 이 프로세스를 어떻게 관리하는지, 어떻게 다루고 있는지 파악할 때 사용된다. 시스템 콜이 발생할 때, 어떤 프로세스가 시스템 콜을 했는지 알기 위해 커널 주소 공간의 Stack에는 시스템 콜을 한 프로세스의 커널 스택 값을 저장하고 있다. 운영체제가 문맥(context)을 알고 있어야 하는 이유 현재의 컴퓨터는 time sharing, multitasking 체제이다. 즉, 하나의 CPU가 여러 개의 프로세스를 동시에 수행한다. 짧은 속도로 여러 개의 프로세스를 수행해야 하는 CPU의 입장에서는 이전에 수행하고 있던 프로세스가 어디까지 진행되었는지를 알아야 할 필요가 생긴다.(그래야 효율적이다.) 그 어디까지 진행되었는지에 대한 값을 문맥 즉, context에 저장하고 있기 때문에 이 문맥을 CPU가 알고 있어야 한다. 프로세스 제어 블록(Process Control Block, PCB) 프로세스 제어 블록이란 프로세스를 관리하기 위해 필요한 프로세스 요소들의 자료구조이다. 운영체제가 현재 CPU 제어권을 다른 프로세스에게 넘겨줄 때 실행중인 프로세스의 정보를 PCB에 저장한다. CPU 제어권을 다시 넘겨받은 경우 PCB에 저장되어 있던 정보를 불러와 추후 작업을 실행한다. PCB는 주로 다음과 같이 구성된다. 프로세스 식별자(Identifier) 프로세스 상태(State) 우선순위(Priority)같은 스케줄링에 대한 정보 메모리 포인터(Memory pointer) CPU 수행에 관련된 프로그램 카운터(Program counter), 각종 register 값 I/O 상태정보(I/O status information) code, data, stack에 대한 정보 프로세스 상태 프로세스는 실행되면서 자신의 상태가 시시각가 변한다. 생성(New) : 프로세스가 생성 중 프로세스가 생성되었지만 실행가능한 프로세스 집합에 소속되지 못한 상태(프로그램이 메모리에 적재되지 않은 상태) 준비(Ready) : 프로세스가 설정되어 대기중 CPU를 할당받기 위해 준비중인 상태(즉 Queue에서 대기하고 있는 상태를 의미한다. 이는 물리적인 메모리에 적재된 상태를 말한다.) 실행(Running) : 프로세스가 실행하는 중 프로세스가 CPU를 할당받아 기계어 명령어를 수행중인 상태 대기(Block, wait, sleep) : 프로세스가 어떤 사건이 발생하기를 기다리고 있는 상태 당장 CPU를 할당해줘도 instruction을 수행할 수 없는 상태를 말한다. 디스크에서 file을 읽어와야 하는 오래 걸리는 작업을 하고 있거나 다른 프로세스의 진행을 위해 일부러 재워둔 경우에 해당한다. 종료(Exit) : 프로세스가 실행 종료 프로세스가 실행 종료된 상태(프로그램이 메모리에서 해제된 상태) 프로세스가 종료되면 정리하는 작업을 진행하게 되는데 이 상태에 해당한다. 프로세스 상태 전이 프로세스는 아래와 같은 상태 전이를 가지며 주로 아래와 같이 명명한다. 디스패치(Dispatch) : 준비 -&gt; 실행 타임 아웃(Time out) : 실행 -&gt; 준비 대기(block) 또는 사건 준비(Event Wait) : 실행 -&gt; 대기 깨움(wake up) 또는 사건 발생(Event Occurs) : 대기 -&gt; 준비 new -&gt; ready : new 상태에서 프로세스가 생성되면 OS 커널에 존재하는 Ready Queue에 올라가게 된다. ready -&gt; running : Ready Queue에 있는 프로세스들을 OS가 프로세스 스케쥴링 알고리즘에 의해서 Running 상태로 가야할 프로세스에게 CPU를 할당한다. 그러면 프로세스가 Running 상태가 된다. running -&gt; ready : 현재 running 상태에 있는 프로세스 A보다 Ready Queue에서 대기하고 있는 프로세스 B가 우선순위가 높으면, preemptive schedule(선점형)인 경우 프로세스 A는 Ready 상태로 오게 되고 프로세스 B가 Running 상태가 되어 CPU를 할당 받게 된다. running -&gt; blocked : 현재 running 상태에 있는 프로세스 A에게 입출력(I/O) 이벤트가 발생했을 때 프로세스 A가 blocked 상태로 가게 된다. running -&gt; terminate : 프로세스 종료. Context Switch(문맥 교환) 문맥 교환이란 CPU를 어떤 프로세스에서 다른 프로세스로 넘겨주는 과정을 말한다. System call이나 interrupt가 발생헀다고 해서 반드시 Context Switch가 발생하는 것은 아니다. 프로세스 내부에서 System call을 요청하거나 interrupt가 외부에서 들어왔어도 운영체제에서의 일을 마치고 다시 할당되었던 CPU로 넘어가게 된다. 다른 프로세스로 넘어가는 과정은 상당한 오버헤드를 발생시킨다. cache memory에 있던 진행하던 프로세스에 대한 cache를 모두 비워줘야 하기 때문이다. 그래서 문맥 교환이 일어나는 상황은 크게 두 가지 경우이다. Interrupt 중에서도 timer interrupt가 들어왔을 때와 I/O 요청 System Call이 들어왔을 때이다. 전환하는 동안에는 어떠한 유용한 작업도 불가능하다. IPC 준비중. 참고 프로세스란 무엇인가 [운영체제 이론] 프로세스 운영체제 프로세스 개념과 흐름 알아보기 프로세스란? 메모리 관점에서 본 프로세스","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"[운영체제] 인터럽트의 원리","slug":"OS-The-Principle-Of-Interrupt","date":"2018-12-23T14:14:21.000Z","updated":"2020-05-12T15:13:34.565Z","comments":true,"path":"2018/12/23/OS-The-Principle-Of-Interrupt/","link":"","permalink":"https://woovictory.github.io/2018/12/23/OS-The-Principle-Of-Interrupt/","excerpt":"","text":"프로그램의 구조와 인터럽트 프로그램의 구조와 인터럽트 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. 이 때, 프로그램의 주소 영역은 크게 코드, 데이터, 스택 영역으로 구분된다. 코드 영역 : 우리가 작성한 프로그램 함수들의 코드가 기계어 명렁으로 변환되어 저장되는 부분이다. 데이터 영역 : 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다. 스택 영역 : 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다. 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다. 반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 OS 커널 부분에 존재하게 된다. OS는 현재 실행 중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다. 1234예를 들어, A, B 두 개의 프로그램이 현재 수행중이라면커널 어딘가에 이 두 프로그램을 관리하기 위한 자료 구조가 존재한다.이 자료 구조를 &quot;프로세스 제어 블록(PCB)&quot;라 부른다. PCB에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다. 123456프로그램 A가 수행 중에 인터럽트가 발생하면현재 실행 중이던 지점을 A의 프로세스 제어 블록에 저장한 후,인터럽트 처리를 모두 마치면프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다. 컴퓨터 시스템의 작동 개요 CPU를 컴퓨터의 두뇌라고 부르지만 CPU는 인간의 뇌처럼 스스로 생각하고 판단하는 능력을 갖추고 있지는 못하다. 이는 CPU가 빠른 속도로 처리하는 계산 능력은 가지고 있지만, 어떠한 작업을 수행해야 하는지에 대해 스스로 결정하는 능력이 없기 때문이다. CPU는 현재 수행해야 할 메모리 주소의 명령을 있는 그대로 처리할 뿐이다. 이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 프로그램 카운터라고 부른다. 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다. 일반적으로 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 바로 다음 주소의 명령을 가리키게 되어 코드의 순차적인 수행이 이루어진다. 메모리에는 사용자 프로그램과 OS가 같이 올라가 수행된다. 이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다. 1234if 만약 프로그램 카운터가 메모리 주소 중 OS가 존재하는 부분을 가리킨다면 CPU가 커널 모드에서 수행 중이라고 이야기한다.else CPU가 사용자 모드에서 수행 중이라고 이야기한다. CPU가 수행하는 명령에는 일반 명령과 특권 명령이 있다. 일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다. 이러한 일반 명령은 모든 프로그램이 수행할 수 있는 명령이다. 특권 명령은 보안이 필요한 명령으로 입출력 장치, 타이머 등 각종 장치를 접근하는 명령이다. 컴퓨터 시스템에서는 CPU 내에 모드 비트를 두어 특권 명령을 항상 OS만이 수행할 수 있도록 제한하고 있다. 사용자 프로그램이 특권 명령의 수행이 필요한 경우 OS에게 특권 명령의 대행을 요청한다. 이와 같은 서비스 요청을 시스템 콜이라고 한다. 사용자 프로그램이 시스템 콜을 하게 되면 OS는 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다. 프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다. CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 주변 장치의 상태를 지속적으로 파악할 수 없다. 따라서, 주변 장치는 CPU의 도움이 필요한 경우 인터럽트를 사용해 CPU에게 서비스를 요청하게 된다. 인터럽트를 발생시키기 위해 주변 장치는 인터럽트 라인을 세팅하고 CPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 있는지 확인한다. 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다. 프로그램의 실행 &quot;프로그램이 실행되고 있다&quot;는 것은 컴퓨터 시스템 차원에서 볼 때 크게 두 가지 중요한 의미를 갖는다. 디스크에 존재하던 실행 파일이 메모리에 적재됨을 의미한다. 프로그램이 CPU를 할당받고 기계 명령을 수행하고 있는 상태를 의미한다. 일반적인 컴퓨터 시스템의 경우 CPU는 하나밖에 없으므로 매 시점 CPU에서 명령을 수행하는 프로그램은 단 하나뿐이다. 하지만, 여러 프로그램이 짧은 시간 단위로 CPU를 나누어 쓰고, 이들 프로그램이 메모리에 동시에 적재되어 있을 수 있으므로 여러 프로그램이 동시에 실행된다는 말을 보편적으로 사용하는 것이다. 실행 파일이 메모리에 적재될 때 실행 파일 전체가 메모리에 한꺼번에 올라가기 보다는 일부분만 메모리에 올라가고 나머지는 디스크의 특정 영역에 내려가 있는 것이 일반적이다. 이는 여러 프로그램이 공유하는 메모리 공간을 효율적으로 사용하기 위한 방법이다. 프로그램의 주소 공간 중 당장 CPU의 수행에 필요한 부분은 메모리에 올려놓고 그렇지 않은 부분은 디스크 중 메모리의 연장 공간으로 사용되는 스왑 영역에 내려놓는 방식으로 운영된다. 실행 파일이 실행되어 물리적 메모리에 적재되는 모습 프로그램의 주소 공간은 코드, 데이터, 스택 등으로 구성된다. 각각의 프로그램마다 이러한 주소 공간을 별도로 가지며, 각 프로그램마다 독자적으로 존재하는 이와 같은 주소 공간을 가상 메모리 또는 논리적 메모리라 부른다. 주소 변환에 의해 프로세스의 논리적 주소 공간이 물리적 메모리에 적재되는 모습 OS도 하나의 프로그램이므로 OS 커널 역시 코드, 데이터, 스택의 주소 공간을 갖으며, 각각은 아래와 같은 역할 및 기능을 갖는다. 커널의 코드 OS의 기능 : 아랫단의 HW 자원을 효율적으로 관리하는 일 + 윗단의 응용프로그램 및 사용자에게 편리한 서비스 제공 CPU, 메모리 등의 자원을 관리하기 위한 부분 + 사용자에게 편리한 인터페이스를 제공하기 위한 부분이 주를 이룬다. 이 밖에도 시스템 콜 및 인터럽트를 처리하기 위한 부분을 포함한다. 커널의 데이터 영역 각종 자원을 관리하기 위한 자료 구조가 저장된다. CPU, 메모리와 같은 HW 자원을 관리하기 위한 자료 구조뿐만 아니라 현재 수행 중인 프로그램을 관리하기 위한 자료 구조도 커널의 데이터 영역에 유지된다. 이 때, 현재 수행 중인 프로그램을 프로세스라고 부른다. 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB가 존재한다. 즉, HW + SW를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료 구조를 각각 유지한다. 커널의 스택 영역 함수 호출 시 복귀 주소를 저장하기 위한 용도로 사용된다. 커널의 스택은 일반 사용자 프로그램의 스택과 달리 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다. 즉, 프로그램이 실행되어 자기 자신의 코드 내에서 함수 호출 및 복귀 주소를 유지하기 위해서는 자기 주소 공간 내의 스택을 사용하고, 시스템 콜 등 커널 내의 함수를 호출하는 경우에는 커널의 주소 공간에 존재하는 커널 스택을 사용하게 된다. Q. 프로세스마다 별도의 스택을 두는 이유 A. 프로세스가 함수를 호출할 때 자기 주소 영역 내부에 정의된 함수를 호출하면 자신의 스택에 복귀 주소를 저장하지만, 프로세스가 특권 명령을 수행하려고 커널에 정의된 시스템 콜을 호출하고 시스템 콜 내부에서 다른 함수를 호출하는 경우에 그 복귀 주소는 커널 내의 주소가 되어 사용자 프로그램의 스택과는 별도의 저장 공간이 필요하기 때문이다. 또한, 커널은 일종의 공유 코드로서 모든 사용자 프로그램이 시스템 콜을 통해 커널의 함수를 접근할 수 있으므로 일관성 유지를 위해 각 프로세스마다 커널 내에 별도의 스택을 두게 된다. 운영체제의 주소 공간 구조 사용자 프로그램의 사용 함수 프로그램이 사용하는 함수는 크게 사용자 정의 함수, 라이브러리 함수, 커널 함수 세 가지로 구분할 수 있다. 사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다. 라이브러리 함수란 누군가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다. 커널 함수는 OS 커널의 정의된 함수를 뜻한다. 사용자 정의 함수와 라이브러리 함수는 모두 컴파일하여 실행 파일을 만들게 되면 프로그램의 코드 부분에 기계 명령 형태로 삽입된다. 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. 또한, 함수 호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다. 커널 함수의 종류에는 사용자 프로그램이 OS의 서비스를 요청하기 위한 시스템 콜 함수와 HW/SW가 CPU의 서비스를 요청하기 위한 인터럽트 처리 함수가 있다. 이와 같은 커널 함수는 OS 커널의 주소 공간에 코드가 정의된다. 즉, OS가 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다. 인터럽트 인터럽트와 관련된 주요 용어로는 인터럽트 벡터와 인터럽트 핸들러가 있다. 인터럽트 벡터 여러가지 인터럽트에 대해 해당 인터럽트 발생 시 처리해야 할 루틴의 주소를 보관하고 있는 테이블을 의미한다. 일종의 함수를 가리키는 포인터라고도 할 수 있다. 인터럽트 핸들러 실제 인터럽트를 처리하기 위한 루틴으로 인터럽트 서비스 루틴이라고도 부른다. OS 코드 부분에는 각종 인터럽트별로 처리해야 할 내용이 이미 프로그램되어 있으며, 이 부분을 인터럽트 서비스 루틴 또는 인터럽트 핸들러라고 부른다. 시스템 콜 컴퓨터 시스템에서는 HW 및 SW 자원의 보안을 위해 CPU가 실행할 수 있는 명령을 일반 명령과 특권 명령으로 나누어 관리한다. 사용자 프로그램이 CPU의 제어권을 가지고 프로그램을 수행하다 보면, 입출력 등 특권 명령을 수행해야 할 필요가 잇다. 이 경우 사용자 프로그램은 OS에게 시스템 콜을 통해 특권 명령의 대행을 요청하게 된다. 사용자 프로그램이 이와 같이 특권 명령을 수행하는 커널 함수를 호출하게 되면 CPU의 제어권이 OS에게 넘어가게 된다. 이 때 하드웨어적으로 모드 비트가 1에서 0으로 자동 세팅되기 때문에 OS는 특권 명령을 수행할 수 있다. 모든 프로그램은 자신의 독자적인 주소 공간을 가지고 있으며, 프로그램이 함수 호출을 하는 경우 자신의 주소 공간 내에서 호출이 이루어지게 된다. 그러나 시스템 콜은 비록 함수 호출이긴 하지만 자신의 주소 공간을 거스르는 영역에 존재ㅐ하는 함수를 호출하는 것이다. 커널이라는 다른 프로그램의 주소 공간에 존재하는 함수를 호출하는 일이기 때문이다. 시스템 콜은 주소 공간 자체가 다른 곳으로 이동해야 하므로 일반 함수를 호출하는 것과는 상이한 방법을 사용한다. 프로그램 자신이 인터럽트 라인에 인터럽트를 세팅하는 명령을 통해 이루어진다. 어떤 프로그램이 CPU를 할당받고 명령을 수행하다 중간에 CPU를 선점당하는 경우는 크게 두 가지 경우가 있다. 타이머에 의해 인터럽트 발생 특정 프로그램이 CPU를 독점하는 것을 방지하기 위한 하드웨어로 CPU 할당 시간이 만료되면 인터럽트를 발생시킨다. 이러한 타이머는 여러 프로세스가 CPU를 나누어 사용하는 시분할 시스템의 구현을 위한 필수적인 요소이다. 입출력 요청을 위한 시스템 콜 오래 거리는 입출력 작업이 완료되기까지 그 프로세스에게 CPU를 다시 할당하더라도 당장 다음 명령을 수행하지 못하는 경우가 일반적이므로 CPU를 다른 프로세스에게 이향하게 된다. 입출력을 요청해는 프로세스는 입출력 요청이 완료되어 컨트롤러가 입터럽트를 발생시킨 시점부터 다시 CPU를 얻을 수 있는 기회가 생기며 CPU를 기다리는 큐에 삽입하여 CPU 할당을 기다린다. 프로세스의 상태 프로세스의 상태는 실행, 준비, 봉쇄의 3가지로 크게 나누어 볼 수 있다. 실행 CPU를 할당받고 기계어 명령을 수행하고 있는 프로세스의 상태이다. 준비 상태 CPU만 할당받으면 당장 명령을 수행할 수 있지만 CPU가 하나밖에 없어 현재 CPU를 할당받지 못한 프로세스의 상태이다. 봉쇄 상태 CPU를 할당받더라도 명령을 수행할 수 없는 프로세스의 상태이다. 프로세스가 요청한 입출력 작업이 진행중인 경우 CPU를 할당받더라도 입출력이 끝나기 전까지는 작업을 진행할 수 없기 때문에 CPU를 할당하지 않는다. 준비상태에 있는 프로세스가 실행 상태로 변경되는 경우는 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태가 되거나 또는 실행 상태에 있던 프로세스의 CPU 할당 시간이 만료되어 타이머 인터럽트가 발생한 경우를 들 수 있다. OS는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(Ready Queue)를 두고 준비 큐의 제일 앞에 있는 프로세스에게 CPU를 할당한다. 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다. OS는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 큐를 두고 있다. 예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 디스크 입출력 큐(Disk I/O Queue)에 줄을 서게 된다. 그러면, 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행하게 된다. 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시키고 그러면 인터럽트 처리 루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄을 서게 된다. 위에서 언급된 큐는 HW 자원을 기다리는 프로세스들을 줄 세우기 위한 것이었다. 이와 같은 큐는 SW 자원을 기다리는 경우에도 필요한데, 아래와 같다. 예를 들어 데이터에 대한 접근 권한은 SW 자원으로 분류될 수 있다. 어떠한 프로세스가 공유 데이터를 사용하고 있는 도중에 다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 일관성이 훼손될 수 있다. 따라서, 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다. 이 때 접근한다는 의미가 반드시 CPU가 그 데이터를 사용하고 있다는 의미는 아니다. 공유 데이터를 접근 중인 프로세스가 &quot;준비 상태&quot;나 &quot;봉쇄 상태&quot;로 변경된 경우에도 새롭게 CPU를 할당받은 프로세스가 동일한 데이터를 접근하게 되면 데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안된다. 즉, 공유 데이터라는 일종의 SW 자원을 앞서 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당 받았다 하더라도 접근하지 않고 기다려야 하는 것이다. 여러 프로세스가 공유 데이터를 동시에 접근하려고 할 경우 공유 데이터를 기다리는 &quot;큐&quot;에 줄을 서게 하여 현재 그 데이터를 사용중인 프로세스가 데이터를 반납하기 전까지는 접근을 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방법을 사용하게 된다. 위 그림처럼 프로세스의 상태 관리는 커널의 주소 영역 중 데이터 영역에 다양한 큐를 두어 이루어지게 된다. 각 프로세스들이 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리하고 있다는 뜻이다. 123456789예를 들어 타이머 입터럽트가 발생하면커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해다음에 어느 프로세스에게 CPU를 할당할지 결정하고현재 실행되던 프로세스는 준비 큐의 제일 뒤로 보내진다.준비 큐는 CPU 를 할당받기 위해 기다리고 있는 큐이므로어떤 프로세스에게 CPU를 할당할지 결정하려면 준비 큐를 봐야 한다.타이머 인터럽트이기 때문에 &quot;봉쇄 상태&quot;가 아니라 준비 큐의 가장 마지막에 재삽입하는 것이다.입출력 요청이었을 시에는 &quot;봉쇄 상태&quot;로 빠져 준비 큐에 들어가지 못한다. 프로세스의 두 가지 실행 상태 하나의 프로세스가 시작되어 수행을 완료하기까지는 프로세스 자신의 주소 공간에 있는 코드만 실행되는 것이 아니라 커널의 주소 공간에 있는 코드도 실행된다. 이는 프로그램이 사용자 정의 함수나 라이브러리 함수뿐 아니라 입출력 시스템 콜 등을 통해 OS 커널의 함수도 호출하여 실행하기 때문이다. 12345678910111213141516171819예를 들어 프로세스 A가 CPU에서 실행되고 있다고 하면이는 자신의 주소 공간에 정의된 코드를 실행하는 것과커널의 시스템 콜 함수를 실행하는 것으로 나누어 볼 수 있다.전자를 사용자 모드에서의 실행 상태(User mode Running)이라 하고,후자를 커널 모드에서의 실행 상태(User mode Running)라고 한다.한가지 주의할 점은 시스템 콜이 수행되는 동안프로세스 A의 코드가 아니라 OS 커널의 코드이지만커널이 실행 상태에 있다고 하지 않고프로세스 A가 실행 상태에 있다고 말한다.프로세스 A 입장에서는 CPU를 OS 커널에게 빼앗긴 것으로 생각할 수도 있지만 커널의 코드가 실행되는 것이 사실상 프로세스 A가 해야 할 일을 대행하는것이기 때문에 시스템 콜이 실행 중일 때에도 여전히 프로세스 A는 실행 상태에 있는것으로 간주한다.다만, 프로세스 A 자신의 코드를 실행하는 것과 구분지어이러한 상태를 프로세스 A가 커널 모드에서 실행중이라고 이야기한다. 정리하자면, 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 사용자 모드와 커널 모드의 실행 상태로 구분 지을 수 있다. 프로그램이 사용자 정의 함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 사용자 모드에서의 실행을 하게 되며, 시스템 콜을 하는 경우에는 커널 모드로 진입해 커널의 주소 공간에 정의된 함수를 실행하게 된다. 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스템 콜 이후의 명령들을 계속 실행하게 된다. 프로그램의 실행이 끝날 때에는 커널 모드로 진입해 프로그램을 종료하게 된다.","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"[운영체제] 컴퓨터 시스템의 동작 원리","slug":"OS-How-Computer-System-Work","date":"2018-12-21T16:11:21.000Z","updated":"2020-05-12T15:13:45.301Z","comments":true,"path":"2018/12/22/OS-How-Computer-System-Work/","link":"","permalink":"https://woovictory.github.io/2018/12/22/OS-How-Computer-System-Work/","excerpt":"","text":"컴퓨터 시스템의 구조 CPU와 I/O 연산 인터럽트의 일반적 기능 인터럽트 핸들링 컴퓨터 시스템의 구조 OS 중 항상 메모리에 올라가 있는 부분은 전체 OS 중 일부분에 해당되는데, 이 부분은 커널이라고 한다. CPU와 I/O 연산 컴퓨터에서 연산을 한다는 뜻은 CPU가 무언가 일을 한다는 것을 의미한다. 컴퓨터 내의 각 하드웨어 장치들에는 컨트롤러(Controller:제어기)라는 것이 붙어있다. 컨트롤러는 일종의 작은 CPU로서, 컴퓨터 전체에 CPU라는 중앙 처리 장치가 있듯이, 컨트롤러는 각 하드웨어 장치마다 존재하면서 이들을 제어하는 작은 CPU라고 할 수 있다. 각 장치마다 이를 제어하기 위해 설치된 장체 컨트롤러에는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 갖고 있으며, 이를 로컬 버퍼라고 부른다. 이 때 장치에서 로컬 버퍼로 읽어오는 일은 컨트롤러가 담당한다. 데이터를 모두 가지고 왔는지 확인하는 작업은 메인 CPU가 일일이 체크하는 것이 아니라 장치에 있는 컨트롤러가 인터럽트를 발생시켜 CPU에게 보고한다. 이 때 인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법을 말한다. 기본적으로 CPU는 매 시점 메모리에서 명령을 하나씩 읽어와서 수행한다. 이 때 CPU 옆에는 인터럽트 라인이 있어서 CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고, 인터럽트와 관련된 일을 처리한다. 즉, CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 체크한다. 인터럽트의 일반적 기능 OS 커널에는 인터럽트가 들어왔을 때 해야 할 일을 미리 다 프로그래밍해서 보관하고 있다. 그 중 한가지가 인터럽트 처리 루틴이다. 먼저, 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리에 전달하고, 이제 B가 CPU를 할당받을 경우 다음 명령(instruction)을 수행할 수 있음을 표시한다. 인터럽트가 발생하면 CPU는 하던 일을 멈추고 인터럽트를 처리하기 위한 루틴(OS 커널 내부 코드)에 들어가서 정의된 일을 찾게 된다. OS는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터라는 것을 갖고 있다. 인터럽트 벡터란? 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 포인터로 가리키는 자료 구조이다. 실제 처리해야 할 내용은 인터럽트 서비스 루틴이라는 다른 곳에 정의된다. 인터럽트 핸들링 CPU에서 명령이 수행될 때에는 CPU 내부에 있는 임시 기억 장치인 레지스터에 데이터를 Read/Write 하는 작업을 수행하게 되는데, 인터럽트가 발생해 새로운 명령을 수행하면 기존의 레지스터 값들이 지워지게 되므로 레지스터 값 등 CPU 내의 하드웨어 상태를 저장해 두어야 한다. OS 커널 영역에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료구조인 프로세스 제어 블록(PCB)을 두고 있다. PCB 중 일부분은 인터럽트 발생 시 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위해 사용된다. 저장되는 내용으로는 현재 수행 중이던 메모리 주소와 레지스터 값, HW 상태 등이 있다. 인터럽트 수행이 끝나면 PCB에 저장된 값을 CPU 상에 다시 복원해 직전의 명령을 계속 수행할 수 있도록 한다. 현재 수행 중인 프로그램의 수가 n개라고 할 때, 커널 스택은 n만큼 독립적인 공간을 둔다. 즉, 인터럽트 처리 루틴으로 넘어와서 함수 호출이 이루어질 경우에는 각 프로세스별로 독자적인 커널 스택을 사용하게 된다. 프로그램 A가 수행 중에 인터럽트가 발생하면 현재까지 수행된 지점을 프로세스 제어 블록(PCB)에 저장하고, 인터럽트 처리 루틴으로 와서 커널 코드를 수행하게 되며, 이 때 이루어지는 함수 호출은 프로세스 A의 커널 스택을 사용하게 된다 통상적으로 인터럽트라 하면 HW 인터럽트를 의미하고, SW 인터럽트는 트랩(trap)라는 용어를 사용한다. SW 인터럽트의 예로는 예외 상황(Exception), 시스템 콜(System Call)등이 있다. SW 인터럽트는 HW 인터럽트처럼 컨트롤러가 발생시키는 인터럽트가 아니라 프로그램 수행 도중 직접 CPU에 인터럽트 라인을 세팅하여 발생시킨다. 입출력 구조 입출력(Input/Output)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고 받는 것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다. 동기식 입출력 입출력 요청 후 입출력 작업이 완료된 후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. [호출한 프로그램에게 다시 넘어간다!] Example 12345프로그램 A가 CPU를 할당받고 명령을 수행하다가 입출력 요청을 하게 되면 입출력 작업이 완료될 때까지 CPU의 낭비가 초래되므로CPU를 프로그램 A에게서 선점해 다른 프로그램 B에게 할당하게 된다.그러면 프로그램 B가 CPU를 할당받아 명령을 수행하고, 프로그램 A의 입출력이 완료될 때까지 A에게는 CPU를 다시 할당하지 않는다.이는 입출력이 완료될 때까지 그 프로그램에 CPU를 할당하더라도 명령을 수행하지 못하기 때문이다. 이것을 프로그램 봉쇄 상태(Blocked State)로 전환시킨다고 말한다. 1234567선점 시 다음과 같은 문제 발생이 가능하다.프로그램 A가 파일의 내용을 1에서 3으로 바꾸는 입출력을 요청그러면 A로부터 CPU를 선점해서 프로그램 B에게 할당프로그램 B는 파일의 내용 값을 1 증가시키는 연산 실행그러면 결과적으로1-&gt;3-&gt;4가 아닌 1-&gt;2-&gt;3이 된다. 따라서 동기식 입출력에서는 입출력 요청의 동기화를 위해 장치별로 큐(Queue)를 두어 요청 순서대로 처리하여 동기화 문제를 해결한다. 동기식 입출력 요약 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없기에 CPU가 낭비된다. CPU의 낭비를 막고 효율적인 사용을 위해 입출력이 수행되는 동안 다른 프로그램에게 CPU를 양도하여 동시에 다수의 입출력 연산이 가능하게 한다. 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성을 보장하기 위해 장치마다 큐를 두어 해결한다. 동기식 입출력 과정(1) 12345678사용자가 I/O 요청을 하면 먼저 OS의 커널로 CPU의 제어권이 넘어와서입출력 처리와 관련된 커널의 코드가 수행된다.이 때, 입출력을 호출한 프로세스의 상태를 봉쇄 상태로 바꾸고입출력이 완료될 때까지 CPU를 할당받지 못하도록 한다.입출력이 완료되면 I/O 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완려되었음을 알려준다.그러면 이 프로세스의 봉쇄 상태를 해제시켜 CPU를 할당받을 수 있는 권한디 다시 생기게 된다. 동기식 입출력 과정(2) 1234567891011121314151617181920212223프로그램 A가 실행 중에 디스크에서 어떤 데이터를 읽어오는 명령을 만나면프로그램 A는 시스템 콜을 통해 CPU에게 S/W 인터럽트를 발생시킨다.그러면 CPU는 지금까지 프로그램 A의 작업을 멈추고 현재 상태를 PCB에 저장 후 인터럽트에 의해 처리해야 할 커널의 루틴으로 이동한다.처리 루틴으로 이동하면 CPU는 컨트롤러에게 입출력 연산을 요청한다.그러면 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다.읽어오는 동안 프로그램 A는 봉쇄 상태가 되고 CPU를 다른 프로세스에게 선점당하게 되며, CPU는 다른 프로세스에게 할댕되어 계속 CPU가 일을 할 수 있도록 한다.원하는 정보가 로컬 버퍼로 다 들어오면 컨트롤러는 CPU에게 인터럽트를 발생시킨다. 이 때 발생하는 인터럽트는 H/W 인터럽테에 해당한다.프로그램 B를 수행중이던 CPU는 작업을 멈추고 현재 상태를 저장 후 인터럽트를 처리하게 된다.인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고, A의 봉쇄 상태를 해제시킨다. 그러면 A는 다시 CPU를 기다리는 줄에 대기하게 된다.그 후 CPU는 원래 수행하던 프로그램 B의 지점으로 돌아가서 하던 업무를 계속 수행한다.프로그램 A는 CPU를 기다리는 줄에서 기다리다 자신의 차례가 되면 CPU를 할당 받고 입출력 연산 이후의 작업을 수행하게 된다. 비동기식 입출력 입출력 연산 요청 후 연산 결과를 기다리는게 아니라 CPU의 제어권을 다시 프로그램에게 곧바로 부여하는 방식이다. 어떤 프로그램이 데이터를 디스크에서 읽어오라는 요청을 했을 때 보통은 읽어온 결과를 이용해서 다음 연산을 수행하지만 경우에 따라서는 그 데이터와 관련없이 수행할 수 있는 일이 있을 수 있다. 비동기식 입출력에서는 그러한 작업을 먼저 수행하고, 읽어오는 데이터가 반드시 있어야 수행할 수 있는 일들은 입출력이 완료된 후에 수행하게 된다. 비동기식 입출력 과정 123비동기식 입출력에서는 CPU의 제어권이 입출력을 요청한 프로세스에게 곧바로 다시 주어지게 되며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 시작한다.한편, 비동기식 입출력에서도 입출력 연산이 완료도면 동기식과 맟나가지로 인터럽트를 통해 이를 CPU에게 알려주게 된다. 그러면 그 시점부터 읽어온 데이터를 필요로 하는 명령을 수행하게 할 수 있게 된다. DMA(Direct Memory Access) 원칙적으로 메모리는 CPU에 의해서만 접근 가능한 장치이다. 따라서, 주변 장치들이 메모리에 접근하기 위해서는 CPU에게 입터럽트를 발생시켜 CPU가 일을 대행하는 식으로만 가능하다. 즉, 컨트롤러가 CPU에게 인터럽트를 발생시키면 CPU는 컨트롤러의 로컬 버퍼와 메모리 사이에서 데이터를 옮겨 주는 일을 하게 된다. 모든 메모리 접근 연산이 CPU에 의해서만 이뤄질 경우에는 CPU의 업무가 방해를 받아 효율성이 떨어지는 문제점이 발생한다. 이러한 비효율성을 극복하기 위해 CPU 이외의 메모리 접근이 가능한 장치를 하나 더 두는 경우가 많은데 이와 같은 장치를 DMA라고 부른다. DMA는 로컬 버퍼에서 메모리로 읽어오는 작업을 진행한 후 CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알려준다. DMA는 바이트 단위가 아니라 블록이라는 큰 단위로 데이터를 메모리로 읽어 온다. 이런 방식으로 CPU에 발생하는 인터럽트의 빈도를 줄여 CPU의 효율성을 높일 수 있게 된다. 저장 장치의 구조 컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조 기억 장치로 나눌 수 있다. 주 기억 장치 보통 메모리라 부르며 전원이 나가면 저장되었던 내용이 모두 사라져 버리는 휘방성이다. Ex)RAM을 매체로 사용하는 경우가 대부분이다. 보조 기억 장치 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성 Ex)플래시 메모리, CD, 마그네틱 테이프 등등 보조 기억 장치의 용도는 크게 2가지로 구분된다. 파일 시스템용 전원 Off시 유지해야 할 정보가 있으면 그것을 파일 형태로 보조 기억 장치에 저장한다. 메모리는 휘발성이므로 비휘발성 매체인 디스크를 파일 시스템용으로 흔히 사용한다. 메모리의 연장 공간인 스왑 영역용(Swap) OS는 프로그램 수행에 당장 필요한 부분만 메모리에 올려 놓고 나머지는 디스크의 스왑 영역에 내려놓게 된다. 디스크에 내려놓는 일을 스왑 아웃이라고 말한다. 스왑 아웃된 부분이 필요 시 다시 메모리 영역에 올린다. 스왑 영역은 프로그램이 실행 시 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간으로서의 역할을 담당한다. 파일 시스템처럼 비휘발성 용도로 사용되는 것과는 역할이 구분된다. 저장 장치의 계층 구조 주 기억 장치와 보조 기억 장치로 나눌 수 있다. 주 기억 장치 : 비쌈 / 빠름 / 용량이 적음 / 휘발성 보조 기억 장치 : 저렴 / 느림 / 용량이 많은 / 비휘발성 하드웨어의 보안 우리가 흔히 사용하는 OS는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 동작한다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 서로 충돌을 일으키는 문제를 막기 위해 HW에 대한 각종 보안 기법이 필요하다. HW 보안을 유지하기 위해 OS는 기본적으로 두 가지 모드의 오퍼레이션을 지원한다. 커널 모드(Kernel Mode) CPU 내부의 모드 비트가 0인 상태이다. OS가 CPU의 제어권을 갖고 OS 코드를 실행하는 모드로서, 모든 종류의 명령을 다 실행할 수 있다. 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널 모드에서만 실행되도록 하여 보안성을 확보한다. 시스템의 보안과 관련된 명령들을 특권 명령이라 하며, 모든 비트가 0일 때만 수행 가능하다. 즉, 특권 명령을 커널 모드에서 OS에 의해서만 수행이 가능하다. 사용자 모드(User Mode) CPU 내부의 모드 비트가 1인 상태이다. 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다. 1234567891011# 모드 비트 사용 이유사용자 프로그램이 프로그램 내에서 시스템에 영향을 끼치는 연산을 수행할 수가 있다. 이 때 사용자 프로그램이 CPU를 가지고 있는 동안에는 OS가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없다.그렇기 때문에 CPU 내부에 모드 비트를 두어 사용자 프로그램을 감시할 수 있게 된다.# 모드 비트 세팅 과정OS가 CPU를 점유해 자신의 코드를 수행하다 사용자 프로그램에게 CPU의 제어권을 넘길 때 모드 비트를 1로 세팅해 넘긴다.사용자 프로그램이 수행되다 HW 접근 등 보안이 필요한 중요한 명령을 수행해야 할 경우에는 시스템 콜을 통해 OS에게 서비스를 대신해 줄 것을 요청하게 된다.인터럽트가 발생할 때에는 모드 비트가 0으로 세팅되어 OS는 서비스에 필요한 모든 종류의 명령을 수행할 수 있다. 메모리 보안 여러 프로그램이 동시에 메모리에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 OS가 위치한 메모리 영역을 침범할 수 있기 때문에 메모리 보안이 필요하다 2개의 레지스터(기준 레지스터, 한계 레지스터)를 사용해서 프로글매이 접근하려는 메모리 부분이 합법적인지 체크하여 메모리 보호가 이루어진다. 기준 레지스터는 어떤 프로그램이 수행되는 동안 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다. 한계 레지스터는 그 프로그램이 기준 레지스터 값부터 접근할 수 있는 메모리의 범위를 보관한다. 즉 어떤 프로그램이 실제 메모리에 올라가 있는 부분의 시작 주소와 그 프로그램의 길이를 보관해 메모리 접근 연산이 있을 때마다 하드웨어적으로 현재 접근하려는 위치가 합법적인 범위인지를 체크한다. 사용자 프로그램은 기준 레지스터 + 한계 레지스터 값 사이 주소 영역만 접근이 가능하며, 이 범위 안에 없으면 불법적인 메모리 접근이므로 예외 상황이라는 SW 인터럽트를 발생하게 된다. 예외 상황은 OS에게 SW 인터럽트를 발생시켜 CPU의 제어권을 이양시키고 OS는 그 프로그램을 강제 종료시킨다. 단, 여기에서 기준 + 한계 레지스터를 통한 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 경우에 대한 설명이다. 그 박의 하나의 프로그램이 메모리 여러 영역에 나뉘어 위치하는 페이징 기법도 존재한다. 메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안에 수행할 수 있는 연산이므로 특권 명령은 아니다. 다만 사용자 프로그램이 메모리를 접근하기 전에 하드웨어적으로 그 접근이 합법적인지를 체크하여 메모리를 보호한다. 이것이 OS만 수행할 수 있는 입출력 연산과 메모리 접근 연산과의 차이점이라 할 수 있다. 사용자 모드인 경우에는 기준 + 한계 레지스터를 사용해 메모리를 보호하고 커널 모드에서는 메모리에 무제한으로 접근이 가능하다. [무슨 말일까…? 책으로 보면서 추후에 더 이해하자.] CPU 보호 일반적으로 CPU는 컴퓨터 내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 CPU를 독점해 무한 박복문을 수행하는 등 부적절한 방법으로 독점한다면 다른 프로그램 및 OS가 CPU의 제어권을 획득할 수 있는 방법이 없게 된다. OS는 CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 타이머라는 HW를 사용한다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 OS에게 CPU의 제어권을 이양시키는 역할응 수행한다. 타이머는 시분할 시스템에서 현재 시간을 계산하기 위해서도 널리 사용된다. 시분할 시스템이란? 여러 프로그램이 CPU의 시간을 조금씩 나누어 사용하는 시스템을 의미한다. 시스템 콜을 이용한 입출력 수행 시스템 콜은 일종의 SW 인터럽트로 사용자 프로그램이 시스템 콜을 요청할 경우 트랩이 발생해 CPU에 대한 제어권이 OS로 넘어가게 된다. 그러면 OS는 해당 시스템 콜을 처리하기 위한 루틴으로 가서 정의된 명령을 수행하게 된다.","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"[운영체제] 운영체제 개요","slug":"OS-info","date":"2018-12-21T14:28:22.000Z","updated":"2020-05-12T15:13:42.699Z","comments":true,"path":"2018/12/21/OS-info/","link":"","permalink":"https://woovictory.github.io/2018/12/21/OS-info/","excerpt":"","text":"운영체제의 정의 운영체제의 정의 OS는 컴퓨터 HW 바로 윗단에 설치되는 SW 이다. OS는 사용자 및 다른 모든 SW와 HW를 연결하는 SW 계층으로 위상은 아래 그림과 같다. 각종 SW들은 위 그림과 같이 HW와 OS가 한 몸으로 존재하는 컴퓨터 시스템 위에서 수행된다. 컴퓨터 전원을 ON 했을 때 OS가 없으면 컴퓨터는 고철 덩어리에 불과하다. SW가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 적재되어야 한다. OS도 하나의 SW로서 전원이 켜짐과 동시에 메모리에 적재된다. 하지만, OS처럼 큰 규모가 모두 메모리에 적재된다면 한정된 메모리 공간의 낭비가 심할 것이다. 따라서 OS 중 항상 필요한 부분만 메모리에 적재하고 그렇지 않은 부분은 필요할 때 메모리에 적재 후 사용한다. 이때, 메모리에 상주하는 OS 부분을 커널(Kernel)이라 부르며 이를 좁은 의미의 OS라고도 한다. 즉, 커널은 OS 코드 중에서도 핵심적인 부분을 뜻한다. 운영체제의 기능 위 그림과 같이 OS가 컴퓨터 HW와 사용자 사이에 존재하기 때문에 OS의 역할은 HW에 대한 역할과 사용자에 대한 역할로 크게 나눌 수 있다. HW쪽에서는 사용자가 알기 힘든 각종 HW를 OS가 직접 관리함으로써 사용자에게는 편리한 인터페이스를 제공한다. 보다 자세히 살펴보면 OS의 두가지 주요 기능은 다음과 같다. 편리한 환경 제공 편리한 환경 제공이란? OS가 동시 사용자 및 프로그램들에게 각자 독자적으로 컴퓨터를 사용하는 것과 같은 환상을 제공하는 것을 말한다. 시스템 내 자원을 효율적으로 관리 효율적 자원 관리란? OS를 자원 관리자라 부르기도 한다. 이때, 자원이란 CPU, 메모리, 하드 디스크 등 HW+SW 자원을 통칭한다. OS는 자원들을 효율적으로 관리해 가장 좋은 성능을 내는 역할을 담당한다. 하지만 전체적인 성능을 향상시키려다 일부 프로그램 또는 사용자가 불이익을 당할 수도 있다. 따라서 형평성 있게 분배되도록 균형자 역할도 함께 수행하는 것이 중요하다. 즉, 효율성이 가장 큰 목표이지만 이로 인해 일부가 지나치게 희생되지 않게 형평성 역시 OS가 고려해야할 목표이다. 추가적으로 OS는 사용자와 OS 자신을 보호하는 역할을 담당한다. 운영체제의 분류 동시 작업 지원 다중 사용자의 동시 지원 여부 작업을 처리하는 방식 1. 동시 작업 지원 동시 작업 지원 X -&gt; 단일 작업용 OS 동시 작업 지원 O -&gt; 다중 작업용 OS 단일 작업용 OS는 한 번에 하나의 프로그램만 수행 가능하다. OS 다중 작업을 처리할 때 여러 프로그램이 CPU와 메모리를 공유한다. 하지만 일반적으로 컴퓨터에는 CPU가 1개 존재한다. 따라서 다중 작업용 OS라 하더라도 CPU에서는 매 순간 하나의 프로그램만 수행한다. CPU에서 번갈아 수행되지만 CPU의 처리 속도가 워낙 빨라서 여러 프로그램들이 동시에 수행되는 것처럼 보이는 것이다. 이와 같이 CPU의 작업 시간을 여러 프로그램들이 나누어 쓰는 시스템을 시분할 시스템이라고 한다. CPU와 달리 메모리의 경우에는 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이처럼 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그래밍 시스템이라 한다. 다중 작업용 OS의 경우 프로그램을 같이 수행시키지만 사용자 입장에서는 각 프로그램에 대한 키보드 입력의 결과를 바로 화면에 보여주기 때문에 이러한 시스템을 대화형 시스템이라 한다. 여러 사용자가 동시에 접속해서 쓰는 서버의 경우에도 대화형 시스템에 해당된다. 다중 처리기 시스템이란 하나의 컴퓨터에 여러 개의 CPU가 설치된 경우를 뜻한다. CPU가 여럿 있는 컴퓨터는 서로 다른 CPU에서 여러 프로그램이 동시에 수행될 수 있어 처리가 빠르지만 OS 입장에서는 여러 CPU를 관리하기 위해서 더욱 복잡한 메커니즘을 필요로 한다. 2. 다중 사용자의 동시 지원 여부 한 번에 한 명의 사용자만이 사용 -&gt; 단일 사용자용 OS 여러 사용자가 동시에 접속해서 사용 -&gt; 다중 사용자용 OS 흔히 서버라고 부르는 컴퓨터는 다중 사용자용 OS이다. 3. 작업을 처리하는 방식 OS를 분류하는 또 다른 기준은 작업을 처리하는 방식이다. [1]. 일괄 처리(Batch Processing) 작업 요청의 일정량을 모아서 한꺼번에(일괄로) 처리하는 방식을 뜻한다. [2]. 시분할 방식(Time Sharing) 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 것 사용자의 요청에 대한 결과를 즉각적으로 얻을 수 있는 시스템을 대화형 시스템이라 한다. [3]. 실시간(Real Time) 실시간 OS는 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장 되어야 하는 시스템이다. 다시 말해, 일정 시간 안에 작업이 완료되지 못할 경우에는 시스템 자체가 동작하지 않거나 큰 위험을 초래할 가능성이 있는 시스템에서 사용한다. 실시간 시스템은 시간 제약의 중요성에 따라 2가지로 세분화가 가능하다. (1). 경성 실시간 시스템(Hard Realtime System) 주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 가능성이 있는 시스템을 말한다. ex)로켓, 원자로, 제어 시스템 등 (2). 연성 실시간 시스템(Soft Realtime System) 멀티미디어 스트리밍 시스템과 같이 데이터가 시간을 맞추어 전달되어야 올바른 기능을 수행할 수 있는 시스템 ex) 동영상 재생이 끊기거나 정확히 전달되지 않을 경우 경성 실시간 시스템처럼 위험한 결과를 초래하지 않는다. 운영체제의 자원 관리 기능 OS의 가장 핵심적인 기능은 뭐다? 자원을 효율적으로 관리하는 것이다. 자원 = HW 자원 + SW 자원 HW 자원 = CPU와 메모리를 비롯해 주변 장치 및 입출력 장치 등을 의미한다. 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리되어야 한다. 메모리 역시 시스템 내에 한정된 공간이 존재하기 때문에 서로 다른 다수의 프로세스들이 메모리를 나누어 쓸 수 있도록 해야 한다. 또한 주변 장치도 OS의 관리가 필요하다. CPU와 메모리는 전원 Off 시 데이터가 모두 지워지기 때문에 저장되어야 할 데이터는 보조 기억 장치에 파일 형태로 저장된다. 이러한 파일들이 저장되는 방식 및 접근 권한 등에 대해서도 OS가 관리한다. CPU를 관리하는 방법 일반적인 컴퓨터에는 CPU가 하나밖에 없지만 프로세스는 여러 개가 동시에 실행된다. 그러므로 매 시점 어떠한 프로세스에게 CPU를 할당해 작업을 처리할 것인지를 결정하는 일이 필요하다. 이러한 일을 CPU 스케줄링이라고 한다. 메모리를 관리하는 방법 메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억 장치이다. 프로그램이 CPU에서 수행되려면 해당 부분이 메모리에 적재되어야 한다. 한정된 메모리 공간에 여러 프로그램을 수용하려면 메모리에 대한 효율적인 관리 메커니즘이 필요하다. 메모리를 관리하기 위해 OS는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 유지하는 데 이러한 정보는 Address(주소)를 통해 관리된다. OS는 프로그램에게 메모리가 필요할 때 할당 해주고, 더 이상 필요하지 않을 때 회수한다. 물리적 메모리를 관리하는 방식 [1]. 고정 분할 방식 : 물리적 메모리를 몇 개의 영구적인 분할로 나눈다. - 내부 단편화 발생[내부 단편화가 뭐지…?] - 물리적 메모리보다 큰 프로그램을 실행하지 못한다. [2]. 가변 분할 방식 : 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식 - 외부 단편화 발생[이건 또 뭐니…?] - 물리적 메모리보다 큰 프로그램을 실행하지 못한다. [3]. 가상 메모리 방식 : 최근 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. - 물리적 메모리보다 큰 프로그램을 실행할 수 있다. - 모든 프로그램은 물리적 메모리와는 독립적으로 주소가 0부터 시작하는 자신만의 가상 메모리를 갖게 된다. - OS는 가상 메모리의 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 적재한다. - 가상 메모리 기법에서는 물리적 메모리의 크기와 상관없이 사용할 수 있는 메모리의 크기를 충분히 크다고 가정하고 프로그래밍하는 것이 가능하다. - 가능하게 하는 원리는 다음과 같다. 프로그램의 전체가 항상 동시에 사용되는 것은 아니다. 그러므로 현재 사용되고 있는 부분만 메모리에 적재 후, 나머지(현재 사용되고 있지 않은 부분)는 하드디스크와 같은 보조 기억 장치에 저장해 두었다가 필요할 때 메모리에 적재하는 방식을 취한다. 이 때 사용되는 보조 기억 장치의 영역을 우리는 스왑 영역(Swap Area)이라 부른다. 프로그램을 구성하는 주소 공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징(Paging) 기법이라 한다. [페이지와 페이징이 뭐야…?] 주변 장치 및 입출력 장치는 CPU나 메모리와 달리 인터럽트(Interrupt)라는 메커니즘을 통해 관리. 주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데 이 때 발생시키는 신호를 인터럽트라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행한다. 인터럽트는 요청하는 장치와 발생 상황에 따라 다양한 종류가 있기 때문에 OS는 인터럽트 종류마다 서로 다른 인터럽트 처리 루틴을 갖는다. 인터럽트 처리 루틴이란? 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드를 말한다. 이것은 OS 커널 내에 존재하는 코드로 CPU 스케줄링, 메모리 관리 루틴 등 다양한 기능을 위한 커널 코드 중 일부분이라 할 수 있다. 인터럽트 발생시키는 예는 책 참고(63~65p)","categories":[{"name":"Operation System","slug":"Operation-System","permalink":"https://woovictory.github.io/categories/Operation-System/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://woovictory.github.io/tags/OS/"},{"name":"운영체제","slug":"운영체제","permalink":"https://woovictory.github.io/tags/운영체제/"}]},{"title":"Java :: iterator","slug":"Java-iterator","date":"2018-12-20T13:31:40.000Z","updated":"2020-04-22T07:47:26.055Z","comments":true,"path":"2018/12/20/Java-iterator/","link":"","permalink":"https://woovictory.github.io/2018/12/20/Java-iterator/","excerpt":"","text":"iterator iterator iterator는 자바의 컬렉션 프레임워크에서 컬렉션에 저장되어 있는 요소들을 읽어오는 방법을 표준화 하였는데 그 중 하나가 iterator입니다. 쉽게 말하면 컬렉션으로부터 정보를 얻어내는 인터페이스입니다. 또한, iterator는 인터페이스이며 그 구성은 아래와 같습니다. 12345public interface Iterator( boolean hasNext(); Object next(); void remove();) boolean hasNext() : 읽어 올 요소가 남아있는지 확인하는 메소드로 읽어 올 요소가 남아 있으면 true, 없으면 false를 반환합니다. Object next() : 읽어 올 요소가 있으면 다음 요소를 가져옵니다. void remove() : next()로 읽어 온 요소를 삭제합니다. 그러므로 next()를 호출한 다음에 remove()를 호출해야 합니다. 그렇다면 우리가 사용하는 컬렉션 프레임워크에서는 어떻게 사용하면 될까요?? 이 질문에 대한 답은 간단합니다. 예를 들어, List, set과 같은 인터페이스를 구현하는 컬렉션은 iterator()가 컬렉션의 특징에 맞게 설계가 되어 있기 때문에 쉽게 사용할 수 있습니다. Iterator와 list.size() 사용법 Iterator 사용법 123456ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext())&#123; iterator.next();&#125; list.size 사용법 12345ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();for(int i=0;i&lt;list.size();i++)&#123; list.get(i);&#125; 결론 iteraotr는 자동으로 index를 관리해주기 때문에 사용함에 있어서 편리함을 가져다 주지만, Iterator는 객체를 만들어서 사용하기 때문에 list의 size를 가져와서 계산하는 것보다 속도가 느립니다. 그러므로, list의 size를 받아와서 사용하는 것이 더 좋습니다. (속도면에서 빠릅니다.)","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Programmers] 소수의 합","slug":"PGM14406","date":"2018-12-18T12:46:44.000Z","updated":"2019-06-05T07:31:56.519Z","comments":true,"path":"2018/12/18/PGM14406/","link":"","permalink":"https://woovictory.github.io/2018/12/18/PGM14406/","excerpt":"","text":"소수의합 에라토스테네스의체 실력을 쌓아 알고리즘 문제를 풀려는 계획을 가지고 있었는데, GoodGid님께서 팩폭을 해주셔서 그 분의 커리큘럼을 따라가는 중입니다. 그래서 프로그래머스의 leve1,2 수준의 문제를 먼저 풀고 나태 지옥에 빠지지 않기 위해 푼 문제를 포스팅 할 계획입니다. level1을 못풀면 코딩 접어야 한다고 했는데, 다행히도 접을 정도는 아닌가봅니다. 소수의합 어려울 줄 알았지만, 생각보다 간단한 문제입니다. N이 주어지면 2부터 N까지의 소수의 합을 구하면 됩니다. 소수의 대한 간단한 정의는 다음과 같습니다. 1과 자기 자신으로만 나누어 떨어지는 수 이에 반대로 1과 자기 자신이 아닌 수로 나누어 떨어지면 소수가 아니라는 생각을 했고 이를 아래와 같이 구현했습니다. 이미 나누어 떨어짐에도 불구하고 for문을 돌면서 나머지를 계속 검사하기 때문에 break 추가해서 문제 해결! 123456789101112131415161718192021222324252627282930313233343536import java.io.*;public class ex1 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); int total = 0; // 소수의 합 Boolean isPrime = false; for(int i=2;i&lt;=N;i++)&#123; isPrime = true; for(int j=2;j&lt;i;j++) &#123; // 이 부분은 입력받은 수가 1과 자기 자신을 제외한 수로 나누는 과정 // 이 과정에서 나누어 떨어진다는 것은 소수가 아닌 배수임을 의미 // 그렇기 때문에 한번 들어오면 어차피 소수가 아님으로 낭비를 줄이고자 // break문으로 빠져나옴. if (i % j == 0) &#123; isPrime = false; break; &#125; &#125; if(isPrime == true) total += i; &#125; bw.write(total+\"\"); bw.flush(); bw.close(); &#125;&#125; 에라토스테네스의체","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"Programmers","slug":"algorithm/Programmers","permalink":"https://woovictory.github.io/categories/algorithm/Programmers/"}],"tags":[{"name":"Programmers","slug":"Programmers","permalink":"https://woovictory.github.io/tags/Programmers/"}]},{"title":"[안드로이드] 네트워크","slug":"android-network","date":"2018-12-09T07:12:07.000Z","updated":"2020-03-01T10:27:24.078Z","comments":true,"path":"2018/12/09/android-network/","link":"","permalink":"https://woovictory.github.io/2018/12/09/android-network/","excerpt":"","text":"부스트 캠프 사전 작업을 진행하는 과정에서 네이버 검색 API를 사용했습니다. 하지만, Main Thread에서 검색 결과를 받아오는 과정에서 NetworkOnMainThreadException가 발생했습니다. 그래서 저는 인터넷 연결의 문제라고 생각을 하여 Manifest에 인터넷 권한을 추가 해주었지만, 똑같은 에러를 겪었습니다. 그래서 구글링을 해서 다른 방법을 찾았습니다. 메인 Thread에서 발생하는 에러로 네트워크를 이용해 데이터를 받기 위해서는 별개의 Thread가 필요합니다. 그렇지 않으면 Stream 객체를 통해 데이터를 읽어 오는 과정에서 android.os.NetworkOnMainThreadException 에러가 발생하게 됩니다. 네트워크 처리를 잘 못하게 되면 메인 Thread가 멈출 수 있으므로 강제로 분리해서 구현하도록 만든 것 같다는 생각이 듭니다. 데이터를 읽어 오는 과정에서 InputStreamReader에서 Exception이 발생한 것입니다. 네트워크 특성상 가져오는 데이터의 양이 정해져 있지는 않기 때문에 Thread를 별도로 돌려야 합니다. 그렇지 않으면 데이터를 가져오는 동안 프로그램이 멈춰 있을 수 있습니다.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Error","slug":"Error","permalink":"https://woovictory.github.io/tags/Error/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"},{"name":"Network","slug":"Network","permalink":"https://woovictory.github.io/tags/Network/"}]},{"title":"[DMZing 개인정보 취급 방침]","slug":"privacy","date":"2018-11-30T17:35:46.000Z","updated":"2020-06-26T04:26:09.804Z","comments":true,"path":"2018/12/01/privacy/","link":"","permalink":"https://woovictory.github.io/2018/12/01/privacy/","excerpt":"","text":"개인정보의 처리 목적 DMZing(이하 ‘사이트’) 은(는) 다음의 목적을 위하여 개인정보를 처리하고 있으며, 다음의 목적 이외의 용도로는 이용하지 않습니다. 고객 가입의사 확인, 고객에 대한 서비스 제공에 따른 본인 식별. 인증, 회원자격 유지.관리, 물품 또는 서비스 공급에 따른 금액 결제, 물품 또는 서비스의 공급.배송 등 개인정보처리 위탁 ① 사이트는 원활한 개인정보 업무처리를 위하여 다음과 같이 개인정보 처리업무를 위탁하고 있습니다. ② 사이트는 위탁계약 체결시 개인정보 보호법 제25조에 따라 위탁업무 수행목적 외 개인정보 처리금지, 기술적․관리적 보호조치, 재위탁 제한, 수탁자에 대한 관리․감독, 손해배상 등 책임에 관한 사항을 계약서 등 문서에 명시하고, 수탁자가 개인정보를 안전하게 처리하는지를 감독하고 있습니다. ③ 위탁업무의 내용이나 수탁자가 변경될 경우에는 지체없이 본 개인정보 처리방침을 통하여 공개하도록 하겠습니다. 정보주체의 권리,의무 및 그 행사방법 이용자는 개인정보주체로서 다음과 같은 권리를 행사할 수 있습니다. ① 정보주체는 사이트에 대해 언제든지 다음 각 호의 개인정보 보호 관련 권리를 행사할 수 있습니다. 개인정보 열람요구 오류 등이 있을 경우 정정 요구 삭제요구 처리정지 요구 처리하는 개인정보의 항목 작성 ① 사이트는 다음의 개인정보 항목을 처리하고 있습니다. - 필수항목 : 비밀번호, 닉네임, 이메일, 휴대폰 번호 개인정보의 파기 사이트는 원칙적으로 개인정보 처리목적이 달성된 경우에는 지체없이 해당 개인정보를 파기합니다. 파기의 절차, 기한 및 방법은 다음과 같습니다. -파기절차 이용자가 입력한 정보는 목적 달성 후 별도의 DB에 옮겨져(종이의 경우 별도의 서류) 내부 방침 및 기타 관련 법령에 따라 일정기간 저장된 후 혹은 즉시 파기됩니다. 이 때, DB로 옮겨진 개인정보는 법률에 의한 경우가 아니고서는 다른 목적으로 이용되지 않습니다. -파기기한 이용자의 개인정보는 개인정보의 보유기간이 경과된 경우에는 보유기간의 종료일로부터 5일 이내에, 개인정보의 처리 목적 달성, 해당 서비스의 폐지, 사업의 종료 등 그 개인정보가 불필요하게 되었을 때에는 개인정보의 처리가 불필요한 것으로 인정되는 날로부터 5일 이내에 그 개인정보를 파기합니다. 개인정보의 안전성 확보 조치 사이트는 개인정보보호법 제29조에 따라 다음과 같이 안전성 확보에 필요한 기술적/관리적 및 물리적 조치를 하고 있습니다. 개인정보의 암호화 이용자의 개인정보는 비밀번호는 암호화 되어 저장 및 관리되고 있어, 본인만이 알 수 있으며 중요한 데이터는 파일 및 전송 데이터를 암호화 하거나 파일 잠금 기능을 사용하는 등의 별도 보안기능을 사용하고 있습니다. 해킹 등에 대비한 기술적 대책 사이트는 해킹이나 컴퓨터 바이러스 등에 의한 개인정보 유출 및 훼손을 막기 위하여 보안프로그램을 설치하고 주기적인 갱신·점검을 하며 외부로부터 접근이 통제된 구역에 시스템을 설치하고 기술적/물리적으로 감시 및 차단하고 있습니다. 개인정보 처리방침 변경 ① 이 개인정보처리방침은 시행일로부터 적용되며, 법령 및 방침에 따른 변경내용의 추가, 삭제 및 정정이 있는 경우에는 변경사항의 시행 7일 전부터 공지사항을 통하여 고지할 것입니다.","categories":[{"name":"ETC","slug":"ETC","permalink":"https://woovictory.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"https://woovictory.github.io/tags/ETC/"}]},{"title":"[10814] 나이순 정렬","slug":"BOJ10814","date":"2018-10-26T11:50:32.000Z","updated":"2018-12-04T08:30:58.158Z","comments":true,"path":"2018/10/26/BOJ10814/","link":"","permalink":"https://woovictory.github.io/2018/10/26/BOJ10814/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10814 풀이방법 이 문제는 너무 너무 간단한 문제입니다. 정렬 시리즈 중에 하나로 나이순으로 정렬하고 나이가 같다면 먼저 가입한 순서로 정렬하게 됩니다. 여기서 먼저 가입한 순서는 먼저 입력된 순서와 같으므로 입력될 때 list에 Member이라는 클래스에 index를 추가로 가지게 하여 구현했습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;import java.util.*;public class BOJ10814 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); List&lt;Member&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;N;i++)&#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int age = Integer.parseInt(st.nextToken()); String name = st.nextToken(); list.add(new Member(age, name, (i+1))); &#125; Collections.sort(list, new Comparator&lt;Member&gt;() &#123; @Override public int compare(Member o1, Member o2) &#123; if(o1.age&gt;o2.age)&#123; return 1; &#125;else if(o1.age == o2.age)&#123; if(o1.order&gt;o2.order)&#123; return 1; &#125;else &#123; return -1; &#125; &#125;else &#123; return -1; &#125; &#125; &#125;); for(int i=0;i&lt;list.size();i++) bw.write(list.get(i).age+\" \"+list.get(i).name+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Member&#123; int age; String name; int order; public Member(int age, String name, int order)&#123; this.age = age; this.name = name; this.order = order; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10825] 국영수","slug":"BOJ10825","date":"2018-10-25T12:02:08.000Z","updated":"2018-12-04T08:31:24.004Z","comments":true,"path":"2018/10/25/BOJ10825/","link":"","permalink":"https://woovictory.github.io/2018/10/25/BOJ10825/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10825 풀이방법 최근 푼 문제들은 정렬 시리즈 인 것 같습니다.ㅎㅎㅎㅎ 아무튼! 오늘은 학생들의 국,영,수 점수를 입력받아서 조건에 따라 정렬을 하는 문제입니다. 학생 이름, 국어, 영어, 수학 점수를 갖는 Student 클래스를 만들고 List를 만들어서 add를 통하여 추가해줍니다. 그리고 Comparator를 이용해서 객체의 요소들끼리 비교를 통해서 원하는 정렬을 진행합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.*;import java.util.*;public class BOJ10825 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); List&lt;Student&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); String person = st.nextToken(); int korean_grade = Integer.parseInt(st.nextToken()); int english_grade = Integer.parseInt(st.nextToken()); int math_grade = Integer.parseInt(st.nextToken()); list.add(new Student(person, korean_grade, english_grade, math_grade)); &#125; Collections.sort(list, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; if (o1.korean == o2.korean) &#123; if (o1.english == o2.english) &#123; if (o1.math == o2.math) &#123; // 이름에 대해서는 오름차순 정렬으로! return o1.name.compareTo(o2.name); &#125; else if (o1.math &gt; o2.math) &#123; return -1; &#125; else &#123; return 1; &#125; &#125; else if (o1.english &gt; o2.english) &#123; return 1; &#125; else &#123; return -1; &#125; &#125; else if (o1.korean &gt; o2.korean) &#123; return -1; &#125; else &#123; return 1; &#125; &#125; &#125;); for (int i = 0; i &lt; list.size(); i++) bw.write(list.get(i).name + \"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Student &#123; String name; int korean; int english; int math; public Student(String name, int korean, int english, int math) &#123; this.name = name; this.korean = korean; this.english = english; this.math = math; &#125;&#125; 배운점 최근에 Comparator 혹은 Comparable을 구현해서 정렬하는 문제를 풀어보았는데, 잘 알아두면 추후에 유용하게 쓸 수 있을 것 같다는 생각이 듭니다. 이 문제는 조건에 따라서 if~else 문으로 분기하여 푸는 간단한 문제이지만, 나중에는 더 어려운 문제가 나올 것이므로 미리미리 이 개념을 익혀 두는 것이 도움이 될 것 같다고 느꼈습니다. :)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[11651] 좌표 정렬하기2","slug":"BOJ11651","date":"2018-10-24T11:58:34.000Z","updated":"2018-12-04T08:31:46.105Z","comments":true,"path":"2018/10/24/BOJ11651/","link":"","permalink":"https://woovictory.github.io/2018/10/24/BOJ11651/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/11651 풀이방법 어제 풀었던 좌표 정렬하기 문제에서 x를 기준으로 정렬했다면 이 문제는 y를 기준으로 정렬하고 y좌표의 값이 같으면 x좌표를 오름차순으로 정렬하는 문제입니다. 어제 언급했던 Comparable or Comparator을 활용해서 문제를 풀 수 있는지 확인하는 문제입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.*;import java.util.*;public class BOJ11651 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); List&lt;Point&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); list.add(new Point(x, y)); &#125; Collections.sort(list, new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point o1, Point o2) &#123; if(o1.y == o2.y)&#123; if(o1.x&gt;o2.x)&#123; return 1; &#125;else if(o1.x&lt;o2.x)&#123; return -1; &#125;else &#123; return 0; &#125; &#125;else if(o1.y&gt;o2.y)&#123; return 1; &#125;else if(o1.y&lt;o2.y)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125;); for(int i=0;i&lt;list.size();i++) bw.write(list.get(i).x+\" \"+list.get(i).y+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Point &#123; int x; int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[11650] 좌표 정렬하기","slug":"BOJ11650","date":"2018-10-23T11:57:56.000Z","updated":"2018-12-04T08:31:42.038Z","comments":true,"path":"2018/10/23/BOJ11650/","link":"","permalink":"https://woovictory.github.io/2018/10/23/BOJ11650/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/11650 풀이방법 이 문제는 어제 풀어보았던 단어 정렬 문제와 비슷한 유형입니다. 바로 Comparator 혹은 Comparable을 구현해서 정렬하는 문제입니다. 그럼 여기서 의문이 생길 수 있습니다. 그냥 sort를 사용해서 정렬을 하면 되는데, 왜 저런 것을 사용하는거지?? sort는 하나의 값을 기준으로 정렬할 때 사용할 수 있지만, 객체를 정렬할 때는 사용하지 못하기 때문입니다. 즉 객체의 어떤 속성(값)을 기준으로 정렬할 지 모호하기 때문에 Comparable 혹은 Comparator를 구현해서 원하는 정렬을 진행해야 합니다. 사용법만 안다면 간단하게 구현할 수 있습니다. Comparable 구현 Comparable은 객체가 될 클래스가 Comparable을 구현함으로써 사용 가능합니다. compareTo라는 함수를 오버라이드 해서 클래스의 객체인 Coordinates와 this의 x,y 값을 비교해서 값을 리턴하게 됩니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.*;import java.util.*;public class BOJ11650 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); List&lt;Coordinates&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); list.add(new Coordinates(x, y)); &#125; Collections.sort(list); for (int i = 0; i &lt; list.size(); i++) bw.write(list.get(i).x + \" \" + list.get(i).y + \"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Coordinates implements Comparable&lt;Coordinates&gt; &#123; int x; int y; public Coordinates(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public int compareTo(Coordinates o) &#123; // 오름 차순일 경우 // this를 기준으로 함 // this가 크면 1, this가 작으면 -1 : 오름차순 정렬! // 여기서 비교하는 값은 o라는 객체가 됨. if (this.x &gt; o.x) &#123; return 1; &#125; else if (o.x == this.x) &#123; if (this.y &gt; o.y) &#123; return 1; &#125; else &#123; return -1; &#125; &#125; else if (this.x &lt; o.x) &#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125; Comparator 구현 Comparator를 구현하면 compare()라는 메소드를 오버라이드 합니다. 이 함수는 매개 변수로 두 개의 객체가 들어있어서 두 개의 객체를 비교하여 리턴하는 값에 따라서 정렬된 값을 알 수 있습니다. 두 객체를 비교해서 음수, 0, 양수를 반환하도록 합니다. Comparator를 구현하면 기본 정렬 외에도 다른 기준으로 정렬하고자 할 때 사용할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package language;import java.io.*;import java.util.*;public class BOJ11650 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); List&lt;Coordinates&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); list.add(new Coordinates(x, y)); &#125; // Comparator를 이용한 방법 list.sort(new Comparator&lt;Coordinates&gt;() &#123; @Override public int compare(Coordinates o1, Coordinates o2) &#123; // o1을 기준으로 잡는다. // o2가 비교하는 객체가 된다. // 오름 차순! if (o1.x == o2.x) &#123; if (o1.y &gt; o2.y) &#123; return 1; &#125; else &#123; return -1; &#125; &#125;else if(o1.x&gt;o2.x)&#123; return 1; &#125;else if(o1.x&lt;o2.x)&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125;); Collections.sort(list); for (int i = 0; i &lt; list.size(); i++) bw.write(list.get(i).x + \" \" + list.get(i).y + \"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Coordinates &#123; int x; int y; public Coordinates(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 참고 : Collection Framework 중 Comparable, Comparator에 관한 내용","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1181] 단어 정렬","slug":"BOJ1181","date":"2018-10-22T13:33:43.000Z","updated":"2018-12-04T08:24:54.543Z","comments":true,"path":"2018/10/22/BOJ1181/","link":"","permalink":"https://woovictory.github.io/2018/10/22/BOJ1181/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1181 풀이 방법 첫 번째 시도 처음에는 간단하게 배열로 입력받은 문자열을 담은 다음에 Comparable을 구현한 클래스를 통해서 정렬을 하려고 했습니다. 하지만, 문자열의 길이순으로는 정렬이 되는데, 문자열의 길이가 같은 경우에는 사전 순으로 먼저 나오는 단어가 출력되고 그 다음 단어가 출력되는 형식으로 결과를 도출해야 합니다. 하지만, 배열을 사용할 경우에 그렇게 하기란 쉽지 않았습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;import java.util.Arrays;public class BOJ1181 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); Data[] arr = new Data[N]; for(int i=0;i&lt;N;i++)&#123; String input = bf.readLine(); arr[i] = new Data(input,input.length()); &#125; Arrays.sort(arr); for(int i=0;i&lt;N;i++) bw.write(arr[i].name+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;class Data implements Comparable&lt;Data&gt;&#123; String name; int length; public Data(String name, int length)&#123; this.name = name; this.length = length; &#125; @Override public int compareTo(Data o) &#123; if(this.length&gt;o.length)&#123; System.out.println(\"here 0\"); return 1; &#125;else if(this.length&lt;o.length)&#123; System.out.println(\"here -1\"); return -1; &#125;else &#123; return 0; &#125; &#125;&#125; 두 번째 방법 문제를 자세히 읽어보니 이미 나온 단어가 또 나오면 한번만 출력한다고 합니다. 이 뜻은 중복을 허용하지 않는다는 뜻이므로, Set을 이용할 수 있다는 의미입니다. 또한, Set을 이용해서 데이터를 add 하고 나서 List list = new ArrayList&lt;&gt;(set); 을 통해서 Set을 List의 생성자에 대입할 수 있습니다. 그로 인해서 Set이 List가 되어서 Collections.sort를 통해서 입력 받은 문자열들을 먼저 사전순으로 정렬할 수 있습니다. 그 후에, Comparator를 구현하여 문자열의 길이순으로 오름차순 정렬을 수행할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.*;import java.util.*;public class BOJ1181 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; N; i++) &#123; String input = bf.readLine(); set.add(input); &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(set); // 일단 사전순으로 먼저 정렬 Collections.sort(list); // 길이순으로 정렬 // Comparator을 구현함. // compare 함수를 오버라이드하여 길이로 비교함 Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if (o1.length() &gt; o2.length()) return 1; else if (o1.length() &lt; o2.length()) return -1; else return 0; &#125; &#125;); // 출력 for (int i = 0; i &lt; list.size(); i++) bw.write(list.get(i) + \"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125; 배운 점 1일 1 알고리즘을 실천하기 위해서 매일 알고리즘을 풉니다. 그리고 지금은 기초 단계이기 때문에 비교적 쉬운 문제이지만 기초를 잘 다져놔야 추후에 난이도 있는 문제도 풀 수 있다고 생각합니다. 오늘처럼 분명 사용해보았지만 기억이 나지 않았던 부분들은 확실하게 기억하고 넘어가야 할 필요가 있습니다. 오늘 나왔었던 개념은 문제를 자세히 읽어보고 어떠한 자료구조를 선택할 것인가를 잘 생각하고 문제를 이해하고 풀어야 한다는 것입니다. 이 부분은 자료구조에 대한 이해력을 더 높이고 공부를 더 해야 할 것 같습니다. 그리고 두 번째로는 Comparable 혹은 Comparator에 대한 내용입니다. 예전에 공부할 때 포스팅해 둔 내용이 있어서 잠깐 참고해서 보았습니다. 하지만, 이 부분도 시간이 지나면서 점차 기억 속에서 잊혀졌기 때문에 다시 한 번 보면서 개념을 상기시켜야 할 것 같습니다!! :) Comparable or Comparator 내용 : https://woovictory.github.io/2018/03/08/java-collection-framework/","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10813] 공 바꾸기","slug":"BOJ10813","date":"2018-10-21T14:42:56.000Z","updated":"2018-12-04T08:30:55.982Z","comments":true,"path":"2018/10/21/BOJ10813/","link":"","permalink":"https://woovictory.github.io/2018/10/21/BOJ10813/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10813 풀이방법 이 문제는 풀이방법을 말하기도 민망합니다…;; 왜냐하면 단순하게 Swap 하는 문제이기 때문이죠! 배열을 생성하고 공을 바꿔주기만 하면 되는 간단한 문제입니다:) 오늘은 간단한 문제들이기 때문에 3개 정도 풀었네요…ㅎ 12345678910111213141516171819202122232425262728293031323334import java.io.*;import java.util.StringTokenizer;public class BOJ10813 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st = new StringTokenizer(bf.readLine(),\" \"); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[] arr = new int[N+1]; for(int i=1;i&lt;=N;i++) arr[i]=i; for(int k=0;k&lt;M;k++)&#123; st = new StringTokenizer(bf.readLine(),\" \"); int i = Integer.parseInt(st.nextToken()); int j = Integer.parseInt(st.nextToken()); int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; for(int i=1;i&lt;arr.length;i++) bw.write(arr[i]+\" \"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10812] 바구니 순서 바꾸기","slug":"BOJ10812","date":"2018-10-21T14:42:53.000Z","updated":"2018-12-04T08:30:52.061Z","comments":true,"path":"2018/10/21/BOJ10812/","link":"","permalink":"https://woovictory.github.io/2018/10/21/BOJ10812/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10812 풀이 방법 이 문제는 딱 보았을 때 간단하게 풀면 되겠다라고 생각을 했습니다. 하지만, mid라는 바구니를 기준으로 해서 end ~ mid 까지 그리고 begin의 순서로 바구니의 순서를 바꿔야 하는데, 처음에 mid ~ end까지 바꾸고 나서 그 다음에 begin ~ mid까지 바꾸려고 하는데 중간에 begin부터의 값을 가지고 있는 상태를 만들어주는 것을 못했습니다. 이 부분은 문제를 풀고 나서 깨닫게 되었는데, 일단 한번 더 시도해보려고 생각 중입니다. C++을 rotate 기능이 있는데, 자바는…ㅜㅜ 노력해봅시다!!","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10811] 바구니 뒤집기","slug":"BOJ10811","date":"2018-10-19T12:27:59.000Z","updated":"2018-12-04T08:30:49.534Z","comments":true,"path":"2018/10/19/BOJ10811/","link":"","permalink":"https://woovictory.github.io/2018/10/19/BOJ10811/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10811 풀이 방법 첫 번째 풀이 이 문제는 어제 풀었던 도현이의 바구니 시리즈편인 것 같습니다. 그래서 이 문제도 간단하게 배열로 구현했습니다… 하지만, 정답이 틀렸다는 결과가,ㅜㅜ 그래서 무엇이 틀린지 코드를 분석해보는데 틀린 부분이 없었습니다. 제가 푼 방식은 우선, 바구니를 뒤집을 범위를 입력 받고 난 다음에 i부터 (i+j)/2 까지 반복문을 돌면서 조건을 검사합니다. int형 변수인 temp를 만듭니다. i번째 바구니와 j번째 바구니를 바꾸고, (i+1)번째 바구니와 (j-1)번째 바구니를 바꿉니다… 이 과정을 반복합니다. 저는 이 로직으로 구현했습니다만 테스트 케이스는 맞았지만, 정답이 틀렸다는 결과를 얻었습니다. 123456789101112131415161718192021222324252627282930313233343536373839package language;import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;public class BOJ10811 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[] arr = new int[N+1]; for(int i=1;i&lt;=N;i++) arr[i] = i; for(int k=0;k&lt;M;k++)&#123; st = new StringTokenizer(bf.readLine(),\" \"); int i = Integer.parseInt(st.nextToken()); int j = Integer.parseInt(st.nextToken()); for(int m=i;m&lt;=(i+j)/2;m++)&#123; int temp = arr[m]; arr[m] = arr[j]; arr[j] = temp; j--; &#125; &#125; for(int i=1;i&lt;arr.length;i++) System.out.print(arr[i]+\" \"); &#125;&#125; Stack을 이용한 풀이 내 생각에는 정확히 풀었다고 생각을 했는데, 결과는 틀렸다고 했습니다… 그래서 다른 사람들은 도대체 어떻게 풀었으며 제가 예전에 어떻게 풀었는지 확인해보았습니다. 먼저, 예전에 저는 자바가 아닌 C++을 이용해서 풀었습니다. 도움이 되지 않으니 패스, 그리고 다른 사람들은 Stack을 이용해서 문제를 풀었습니다. 사람들은 왜 Stack을 사용해서 풀었는지 의문이 생겼고 직접 Stack을 이용해서 문제를 풀어보았습니다. Stack은 후입선출(LIFO)의 구조를 가지는 자료구조입니다. 문제에서 원하는대로 바구니를 뒤집을 범위를 입력받으면 Stack에 push하고 다시 pop을 해서 원래 배열에 담으면 뒤집어진 상태로 출력이 되기 때문에 원하는 결과를 얻을 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.Stack;import java.util.StringTokenizer;public class BOJ10811 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int[] arr = new int[N + 1]; for (int i = 1; i &lt;= N; i++) arr[i] = i; for (int k = 0; k &lt; M; k++) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); st = new StringTokenizer(bf.readLine(), \" \"); int i = Integer.parseInt(st.nextToken()); int j = Integer.parseInt(st.nextToken()); for (int m = i; m &lt;= j; m++) stack.push(arr[m]); for (int m = i; m &lt;= j; m++) arr[m] = stack.pop(); &#125; StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= N; i++) sb.append(arr[i] + \" \"); bw.write(sb.toString() + \"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125; 배운점 가끔 다른 사람의 코드를 참고하여 문제를 이해하거나 풀이를 확인해서 로직을 이해하는데 이로 인해 배움을 얻고 이해를 하는 것이 좋은 과정이라고 생각합니다. 굿굿~","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10810] 공 넣기","slug":"BOJ10810","date":"2018-10-18T14:15:55.000Z","updated":"2018-12-04T08:30:40.296Z","comments":true,"path":"2018/10/18/BOJ10810/","link":"","permalink":"https://woovictory.github.io/2018/10/18/BOJ10810/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10810 풀이방법 도현이가 바구니에 공을 넣는 문제입니다. 도현이는 N개의 바구니를 가지고 있고 그 중에서 M개의 바구니에 공을 넣으려고 합니다. 그 M개의 바구니에서는 몇번부터 몇번 바구니에 어떤 번호의 공을 넣을 것인지 정합니다. 처음에 저는 List로 구현하면 되겠다고 생각을 하였으나, index에 접근해야 하고 처음에 1번 바구니에 2번을 넣었다가 나중에 3번을 넣으면 덮어 씌워야 하므로 List가 아닌 int형 배열을 이용하여 구현하였습니다. 12345678910111213141516171819202122232425262728293031import java.io.*;import java.util.StringTokenizer;public class BOJ10810 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st1 = new StringTokenizer(bf.readLine(),\" \"); int N = Integer.parseInt(st1.nextToken()); //List&lt;Integer&gt; list = new ArrayList&lt;&gt;(N); int[] intArr = new int[N]; int M = Integer.parseInt(st1.nextToken()); for(int p=0;p&lt;M;p++)&#123; st1 = new StringTokenizer(bf.readLine(),\" \"); int i = Integer.parseInt(st1.nextToken()); int j = Integer.parseInt(st1.nextToken()); int k = Integer.parseInt(st1.nextToken()); for(int m=i-1;m&lt;j;m++)&#123; //list.add(k); intArr[m] = k; &#125; &#125; for(int i=0;i&lt;intArr.length;i++) System.out.print(intArr[i]+\" \"); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10809] 알파벳 찾기","slug":"BOJ10809","date":"2018-10-17T12:01:29.000Z","updated":"2018-12-04T08:30:38.340Z","comments":true,"path":"2018/10/17/BOJ10809/","link":"","permalink":"https://woovictory.github.io/2018/10/17/BOJ10809/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10809 풀이 방법 이 문제의 풀이 방법은 알파벳 개수 문제와 비슷한 유형입니다. (배열을 처음에 -1로 초기화를 해줍니다.) 단지 이 문제에서는 문자열이 어느 위치에서 나타났는지 찾아서 배열에 넣어주면 됩니다. 동일한 문자열이 나올 경우 문자열이 처음 등장한 위치를 넣어주면 되는데, 이 부분은 -1이 아닌 경우에는 문자열이 등장했다는 것을 나타내므로 값을 바꾸지 않고 continue를 통해서 건너 뛰면 됩니다. 123456789101112131415161718192021222324252627import java.io.*;public class BOJ10809 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] checkArr = new int[26]; for(int i=0;i&lt;checkArr.length;i++) checkArr[i]=-1; String input = bf.readLine(); for(int i=0;i&lt;input.length();i++)&#123; int idx = input.charAt(i)-97; if((checkArr[idx]) == -1)&#123; checkArr[idx] = i; &#125;else continue; &#125; for(int i=0;i&lt;26;i++) bw.write(checkArr[i]+\" \"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10808] 알파벳 개수","slug":"BOJ10808","date":"2018-10-17T11:52:01.000Z","updated":"2018-12-04T08:30:36.317Z","comments":true,"path":"2018/10/17/BOJ10808/","link":"","permalink":"https://woovictory.github.io/2018/10/17/BOJ10808/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10808 풀이방법 이 문제는 예전에 풀어봤지만 당연하게 기억이 나지 않아서 다시 풀어봤습니다. 이 문제는 알파벳의 개수가 26개이므로 size가 26인 배열을 만들고 모든 배열 요소를 0으로 초기화 해주었습니다. 그리고 input 문자열을 입력받고 그 문자열의 각 요소에 charAt() 메소드를 통하여 접근하고 아스키 코드 표를 이용하여 A에 해당하는 값인 97을 빼준 값을 index로 정하고 index에 해당하는 배열 요소의 값을 증가시켜줌으로써 계산을 했습니다. 1234567891011121314151617181920212223242526package language;import java.io.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int[] checkArr = new int[26]; String input = bf.readLine(); for(int i=0;i&lt;26;i++) checkArr[i]=0; for(int i=0;i&lt;input.length();i++) &#123; int index = input.charAt(i) - 97; checkArr[index]++; &#125; for(int i=0;i&lt;26;i++)&#123; System.out.print(checkArr[i]+\" \"); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10807] 개수 세기","slug":"BOJ10807","date":"2018-10-17T11:48:24.000Z","updated":"2018-12-04T08:30:34.115Z","comments":true,"path":"2018/10/17/BOJ10807/","link":"","permalink":"https://woovictory.github.io/2018/10/17/BOJ10807/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10807 풀이 방법 이 문제도 비교적 어렵지 않게 풀 수 있습니다. N개의 정수를 입력으로 받아서 배열에 집어 넣고 그 배열에 들어 있는 요소를 확인하여 그 다음으로 입력받은 수가 배열에 몇개 존재하는지 확인합니다. count 변수를 통해 확인하고 출력합니다. 1234567891011121314151617181920212223242526272829import java.io.*;import java.util.StringTokenizer;public class BOJ10807 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int N = Integer.parseInt(bf.readLine()); int[] intArr = new int[N]; StringTokenizer st = new StringTokenizer(bf.readLine(),\" \"); for(int i=0;i&lt;N;i++)&#123; int value = Integer.parseInt(st.nextToken()); intArr[i] = value; &#125; int count = 0; int res = Integer.parseInt(bf.readLine()); for(int i=0;i&lt;N;i++)&#123; if(intArr[i] == res) count++; &#125; bw.write(count+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10824] 네 수","slug":"BOJ10824","date":"2018-10-15T11:27:20.000Z","updated":"2018-12-04T08:31:15.453Z","comments":true,"path":"2018/10/15/BOJ10824/","link":"","permalink":"https://woovictory.github.io/2018/10/15/BOJ10824/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10824 풀이방법 이 문제도 앞에서 풀어보았던 10822, 10823과 같은 형식의 문제라고 생각하고 간단하게 접근을 했습니다. 로직을 다 짜고 실행시켜보니 런타임 에러…? 그래서 왜 런타임 에러가 날까 생각을 해보았습니다. 그리고 문제를 자세히 다시 읽어보니 입력받을 수 있는 네 수 A,B,C,D 모두 1~1,000,000의 범위를 가지고 있었습니다. 이렇게 큰 범위의 수는 int형으로 처리할 수 없기 때문에 이러한 큰 수를 다룰 수 있는 자료형인 BigInteger를 사용해야 합니다. 또한 BigInteger는 객체이기 때문에 그냥 더할 수 없습니다. **add()**라는 메소드를 사용하여 BigInteger 객체끼리 더해줘야 합니다. 12345678910111213141516171819202122import java.io.*;import java.math.BigInteger;public class BOJ10824 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String input = bf.readLine(); String[] words = input.split(\" \"); String ab = words[0]+words[1]; String cd = words[2]+words[3]; BigInteger big1 = new BigInteger(ab); BigInteger big2= new BigInteger(cd); bw.write(big1.add(big2)+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10823] 더하기2","slug":"BOJ10823","date":"2018-10-15T10:37:49.000Z","updated":"2018-12-04T08:31:13.354Z","comments":true,"path":"2018/10/15/BOJ10823/","link":"","permalink":"https://woovictory.github.io/2018/10/15/BOJ10823/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10823 풀이방법 이 문제는 BOJ 10822 문제와 비슷하지만 살짝 다릅니다. 다른 부분은 이 문제에서는 EOF까지 입력을 받아야 한다는 점입니다. EOF란 End of File의 약자로서 파일의 끝이라는 의미를 가지고 있습니다. 즉, 파일의 끝까지 입력을 받으라고 해석할 수 있으며, 다시 말하면 입력이 끝날 때까지 계속해서 입력을 받으라는 의미입니다. 그래서 저는 BufferedReader를 이용해서 EOF까지 입력을 받고 입력받은 문자열의 길이만큼 반복문을 돌리면서 검사를 시작했습니다. 콤마(,)가 있는 경우와 없는 경우를 나누었으며, 콤마(,)가 없다면 StringBuilder 객체인 sb에 append 시켜주었으며, 콤마(,)를 만나면 지금까지 sb에 붙은 값들을 sum에 더해주고 StringBuilder 객체를 다시 새롭게 할당해줍니다. 다시 새롭게 할당하지 않고, 원래 객체에 이어 붙이게 되면 문자열 형태로 뒤에 붙기 때문에 새롭게 할당해주어야 합니다. 12345678910111213141516171819202122232425262728293031import java.io.*;import java.util.Scanner;public class BOJ10823 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringBuilder sb= new StringBuilder(); int sum=0; while(true)&#123; String input = bf.readLine(); if(input == null) break; for(int i=0;i&lt;input.length();i++)&#123; if(input.charAt(i) == ',')&#123; sum+=Integer.parseInt(sb.toString()); sb = new StringBuilder(); // 초기화 &#125;else &#123; sb.append(input.charAt(i)); &#125; &#125; &#125; bw.write(sum+Integer.parseInt(sb.toString())+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10822] 더하기","slug":"BOJ10822","date":"2018-10-15T10:37:45.000Z","updated":"2018-12-04T08:31:11.082Z","comments":true,"path":"2018/10/15/BOJ10822/","link":"","permalink":"https://woovictory.github.io/2018/10/15/BOJ10822/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10822 풀이방법 이 문제는 콤마를 포함하는 숫자들을 문자열 형태로 입력을 받아서 split() 함수를 사용하여 콤마(,) 기준으로 문자열을 짤라서 문자열 배열에 담습니다. 그리고 배열의 길이만큼 반복문을 돌려서 sum이라는 변수에 값들을 더해준 후 출력해줍니다. 이 문제도 비교적 간단하게 구현할 수 있는 문제였고, 많이 생각하지 않아도 되는 문제였습니다. 123456789101112131415161718192021import java.io.*;import java.util.StringTokenizer;public class BOJ10822 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String word = bf.readLine(); String[] strArr = word.split(\",\"); int sum=0; for(int i=0;i&lt;strArr.length;i++) sum+=Integer.parseInt(strArr[i]); bw.write(sum+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[2743] 단어 길이 재기","slug":"BOJ2743","date":"2018-10-15T10:37:17.000Z","updated":"2018-12-04T08:30:15.566Z","comments":true,"path":"2018/10/15/BOJ2743/","link":"","permalink":"https://woovictory.github.io/2018/10/15/BOJ2743/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/2743 풀이 방법 시간이 되지 않아서 일단 간단한 문제를 풀었습니다. 1일 1알고리즘을 목표로 하고 있기 때문에 시간이 되지 않는다면 쉬운 문제라도 풀려고 습관을 들이고 있습니다. 이 문제는 정말 간단합니다… 설명하기 조차 부끄러울 정도로…;;; 그래도 설명을 드리자면, String 문자열을 입력받고 그 문자열의 길이를 출력해주면 끝입니다~~^^ 간단하죠?? ㅎㅎ 1234567891011121314import java.io.*;public class BOJ2743 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String word = bf.readLine(); bw.write(word.length()+\"\\n\"); bw.flush(); bw.close(); bf.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10820] 문자열 분석","slug":"BOJ10820","date":"2018-10-11T10:14:40.000Z","updated":"2018-12-04T08:31:07.586Z","comments":true,"path":"2018/10/11/BOJ10820/","link":"","permalink":"https://woovictory.github.io/2018/10/11/BOJ10820/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10820 풀이 방법 처음에 문제를 보고 까다로운 것인지 귀찮은 것인지 이상한 감정이 들었습니다…;; 하지만, 집중해서 풀어보려고 하니까 그렇게 까다로운 문제가 아니었습니다. 쉬운 문제였습니다… ㅎㅎㅎ 이 문제의 핵심은 입력받은 문자열에서 각 문자에 접근할 수 있느냐가 관건인 것 같습니다. 입력받은 문자를 담는 변수를 word라고 한다면 word.charAt(int index)를 아느냐 모르느냐가 이 문제를 해결할 수 있느냐 없느냐를 판가름 할 것 같습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.Scanner;public class BOJ10820 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int smallAlphabet = 0; int bigAlphabet = 0; int number = 0; int space = 0; while (true) &#123; // BufferedReader를 이용한 EOF까지 입력받기 String word = bf.readLine(); if (word == null) break; smallAlphabet = 0; bigAlphabet = 0; number = 0; space = 0; for (int i = 0; i &lt; word.length(); i++) &#123; if (word.charAt(i) == ' ') space++; else if (word.charAt(i) &gt;= 65 &amp;&amp; word.charAt(i) &lt;= 90) bigAlphabet++; else if (word.charAt(i) &gt;= 97 &amp;&amp; word.charAt(i) &lt;= 122) smallAlphabet++; else if (word.charAt(i) &gt;= 48 &amp;&amp; word.charAt(i) &lt;= 57) number++; &#125; bw.write(smallAlphabet + \" \" + bigAlphabet + \" \" + number + \" \" + space + \"\\n\"); &#125; bw.flush(); bw.close(); bf.close(); &#125;&#125; 배운 점 BufferedReader이나 BufferedWriter를 사용하면 사용을 하지 않는 시점에서 메모리에서 비워줘야 합니다. 이러한 동작을 마지막 줄에서 하는데 실행 창에서는 결과를 확인할 수 없지만, 제출했을 경우에는 답이 나오는 것을 확인할 수 있었습니다… 이 부분 좀 이해가 안가지만, 나중에 찾아봐야 할 것 같습니다.","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1158] 조세퍼스 문제","slug":"BOJ1158","date":"2018-10-10T14:18:03.000Z","updated":"2019-06-05T07:32:20.594Z","comments":true,"path":"2018/10/10/BOJ1158/","link":"","permalink":"https://woovictory.github.io/2018/10/10/BOJ1158/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1158 풀이 방법 이 문제는 조세퍼스 순열이라는 문제입니다. 처음에 이 문제를 보고 큐 혹은 리스트를 사용하면 될 것 같다는 생각을 했습니다. 그래서 생각을 실천하기 위해서 코드를 작성했습니다. 하지만, 계속 M번째 사람을 제거하는 과정을 어떻게 구현할 수 있을까가 문제였습니다. 이 부분을 고민하게 된 이유는 리스트의 성질을 이해하지 못한 부분에서 발생했습니다. 리스트에서 요소를 삭제하면 빈 곳은 다른 요소들이 채우게 되면서 자연스럽게 빈 자리를 채워줍니다. 당연히 인덱스도 변경이 일어나게 됩니다. 이런 특성을 이해하고 나서 문제를 접근하는 것이 더 편해졌습니다. 저는 LinkedList라는 자료구조를 사용하고 이 list에 N번까지의 사람을 채워넣고 그 다음에 M번째 사람을 계속해서 제거하였습니다. 사람을 제거하면서 StringBuilder 객체에 표시를 하였고, list의 사이즈는 계속 줄어들고 제거해야 할 index는 계속해서 증가하기 때문에 index&gt;list.size의 문제가 발생합니다. 이러한 문제를 해결하기 위해서 index가 list의 size를 넘어가게 되면 index를 list의 size로 나눈 나머지를 index로 사용하게 됩니다. 왜냐하면 이 문제에서 사람들은 원을 이루면서 앉아있는 상황이기 때문에, 시작과 끝이 연결되어 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;import java.util.LinkedList;import java.util.StringTokenizer;public class BOJ1158 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); StringBuilder sb = new StringBuilder(\"&lt;\"); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); for(int i=0;i&lt;N;i++)&#123; list.add(i+1); &#125; int index=0; while(!list.isEmpty())&#123; index +=(M-1); if(index&gt;=list.size())&#123; index = index % list.size(); &#125; sb.append(list.remove(index)+\", \"); &#125; //bw.write(sb.toString()+\"\\n\"); String result = sb.substring(0, sb.length()-2); bw.write(result+\"&gt;\"); bw.flush(); bw.close(); &#125;&#125; 배운 점 문제를 보고 사용할 수 있는 자료구조를 바로 생각해 내는 방법을 배웠습니다. 이러한 과정이 쉽지만은 않지만, 계속해서 노력하면 실력이 늘 것이라고 생각합니다.:)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1927] 최소 힙","slug":"BOJ1927","date":"2018-10-10T13:17:48.000Z","updated":"2018-12-04T08:30:00.794Z","comments":true,"path":"2018/10/10/BOJ1927/","link":"","permalink":"https://woovictory.github.io/2018/10/10/BOJ1927/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1927 풀이 방법 이 문제는 Priority Queue 라는 것을 알 수 있는 좋은 문제라고 생각합니다. 문제를 읽어보았을 때 그냥, Queue를 이용해서 풀면 될 것 같다는 생각을 하고 문제를 풀었으나, 큐의 특성상 선입선출 즉, 먼저 들어온 것이 큐의 대기열에 있다가 먼저 나가므로 문제에서 원하는 작은 수가 먼저 출력되는 부분을 만족하지 않았습니다. 이 부분을 해결하기 위해서는 정렬이 필요한데, 정렬하는 부분을 따로 구현을 해줘야 합니다. 그래서 저는 이 방법 말고 분명히 자바에서 제공하는 자료구조 중에서 사용할 수 있는 것이 있다고 판단했습니다. 그리고 C++ 코드에서는 Priority Queue라는 것을 사용하는 것을 보아 자바에서도 비슷한 것이 있을 것이라고 추측했고, 그 추측은 정답이었습니다 :) 이 문제를 풀 때는 Priority Queue의 natural ordering 속성을 통해서 문제를 해결하였습니다. Priority Queue는 natural ordering에 따라서 큐를 정렬합니다. 한마디로 오름차순으로 큐를 정렬시킨다는 뜻입니다. 이러한 속성을 이용해서 작은 값이 먼저 출력될 수 있도록 문제를 풀 수 있었습니다. 12345678910111213141516171819202122232425262728293031import java.io.*;import java.util.*;public class BOJ1927 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); int N = Integer.parseInt(bf.readLine()); for (int i = 0; i &lt; N; i++) &#123; int x = Integer.parseInt(bf.readLine()); if (x == 0) &#123; if (!priorityQueue.isEmpty()) bw.write(priorityQueue.poll() + \"\\n\"); else bw.write(0 + \"\\n\"); &#125; else &#123; priorityQueue.add(x); &#125; &#125; bw.flush(); bw.close(); &#125;&#125; 배운 점 이 문제를 풀면서 배운 점은 Priority Queue라는 자료구조에 대해서 배우게 된 것입니다. 이 자료구조의 특성과 성질을 공부해볼 수 있었습니다. 먼저, 일반적인 큐(Queue)는 선입선출(FIFO)의 구조를 가집니다. 그렇다면 Priority Queue는 어떻게 다를까요?? Priority Queue는 내부적으로 Natural Ordering에 따라서 정렬하는 큐입니다. 그래서 다음의 코드를 테스트해보면 10이라는 숫자가 나와야 하는데, 실제로 1이 나오는 것을 확인할 수 있습니다. 또한, 무작위로 숫자 값을 넣었을 경우에는 어떻게 될까요??? 이 경우에 오름차순된 상태로 출력되는 것을 확인 할 수 있습니다. 이것이 가장 큰 Priority Queue의 특징입니다. 그리고 Priority Queue는 null을 허용하지 않습니다. 왜냐하면 Natural Ordering에 기반을 두고 있기 때문에 정렬할 수 없는 null은 허용되지 않는 것입니다. Priority Queue의 head는 가장 적은 값이 나옵니다. 만약 다수의 엘리먼트가 가장 적은 값이라면, 그 헤드는 그 중에 하나가 되는데 어떤것이 될지는 모릅니다. 우선 순위 대기열에는 각 요소에 우선순위가 할당되어 있습니다. 우선 순위가 가장 높은 요소가 대기열 맨 위에 나타납니다. 이제는 각 요소에 우선 순위를 지정하는 방법에 따라 다릅니다. 그렇게 하지 않으면 Java가 기본 방식으로 처리합니다. 기본 방식은 가장 값이 작은 요소에 가장 높은 우선 순위가 할당되므로 먼저 큐에서 제거됩니다. 동일한 우선 순위를 가진 요소가 여러 개 있으면 타이는 임의로 끊어집니다. 또한, 생성자 PriorityQueue(initialCapacity, comparator)에서 comparator를 사용하여 순서를 지정할 수도 있습니다. Method 함수 기능 element 삭제유무 비어있는 경우 peek head를 가져옴 X return null poll head를 가져옴 O return null remove head를 가져옴 X throw exception element head를 가져옴 O throw exception 1234567891011121314151617PriorityQueue&lt;Integer&gt; pQueue = new PriorityQueue&lt;&gt;();for(int i=0;i&lt;=10;i++)&#123; pQueue.add(i);&#125;System.out.println(\"result : \"+pQueue.peek());// 마지막 삽입된 요소 참조!PriorityQueue&lt;Integer&gt; pQueue2 = new PriorityQueue&lt;&gt;();pQueue2.add(6);pQueue2.add(11);pQueue2.add(3);pQueue2.add(12);int count = pQueue2.size();for(int i=0;i&lt;count;i++)&#125;&#123; System.out.println(pQueue2.poll());&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10821] 문자열 개수","slug":"BOJ10821","date":"2018-10-07T13:49:43.000Z","updated":"2018-12-04T08:31:09.255Z","comments":true,"path":"2018/10/07/BOJ10821/","link":"","permalink":"https://woovictory.github.io/2018/10/07/BOJ10821/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10821 풀이 방법 원래 오늘 풀 문제는 조금 난이도가 있는 문제를 풀어야 했지만, SOPT MT를 갔다와서 체력이 방전되고 컨디션이 좋지 않아서 오늘은 간단한 문제를 풀어보았습니다…;; 이 문제는 입력을 문자열 한 줄로 받아서 split() 함수를 이용해서 “,” 즉, 콤마를 기준으로 문자열을 짜릅니다. 그리고 반환값은 String 배열이기 때문에 배열로 받고 배열의 length를 출력해 주었습니다. 123456789101112131415import java.io.*;public class BOJ10821 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf=new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); //StringTokenizer st = new StringTokenizer(bf.readLine(),\",\"); String word = bf.readLine(); String[] words = word.split(\",\"); bw.write(words.length+\"\\n\"); bw.flush(); bw.close(); &#125;&#125; 배운 점 요즘은 문제를 풀면서 시간 초과가 안나는 것도 고려해가면서 문제를 풀고 있습니다. 그리고 입력과 출력을 받을 때 시간이 적게 걸리는 BufferedReader, BufferedWriter을 사용법을 알게 되었고, 적용해서 문제를 풀고 있습니다. 꾸준히 하는게 중요합니다:)","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10845] 큐","slug":"BOJ10845","date":"2018-10-05T14:57:48.000Z","updated":"2018-12-04T08:31:26.607Z","comments":true,"path":"2018/10/05/BOJ10845/","link":"","permalink":"https://woovictory.github.io/2018/10/05/BOJ10845/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10845 풀이 방법 이 문제는 큐라는 자료구조를 사용해볼 수 있는 가장 간단한 문제라고 볼 수 있습니다. Stack 문제와 같지만, 다른 자료구조를 사용한다라는 점만 다릅니다. 또한, 앞으로 큐를 사용하면서 자주 쓰는 메소드를 접해볼 수 있었고, 더 큐에 대해 알아갈 수 있는 시간이었습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.*;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class BOJ10845 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int test_case = Integer.parseInt(bf.readLine()); LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0;i&lt;test_case;i++)&#123; StringTokenizer st= new StringTokenizer(bf.readLine(),\" \"); String commnad = st.nextToken(); switch (commnad)&#123; case \"push\": int number = Integer.parseInt(st.nextToken()); queue.add(number); break; case \"front\": if(queue.isEmpty()) bw.write(-1+\"\\n\"); else bw.write(queue.peekFirst()+\"\\n\"); break; case \"pop\": if(queue.isEmpty()) bw.write(-1+\"\\n\"); else bw.write(queue.poll()+\"\\n\"); break; case \"size\": bw.write(queue.size()+\"\\n\"); break; case \"empty\": if (queue.isEmpty()) bw.write(1+\"\\n\"); else bw.write(0+\"\\n\"); break; case \"back\": if(queue.isEmpty()) bw.write(-1+\"\\n\"); else bw.write(queue.peekLast()+\"\\n\"); break; &#125; &#125; bw.flush(); bw.close(); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1746] 듣보잡","slug":"BOJ1746","date":"2018-10-03T08:01:51.000Z","updated":"2018-12-04T08:29:44.506Z","comments":true,"path":"2018/10/03/BOJ1746/","link":"","permalink":"https://woovictory.github.io/2018/10/03/BOJ1746/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1746 풀이방법 일단 총 세가지 방법을 시도해보았습니다. List를 이용한 두 번의 시도와 Set을 이용한 한 번의 시도를 했습니다. List를 이용한 방법 시간 초과 뜸! 아마 for문이 중첩되어 있어서 시간 초과가 나는 것으로 예상됨! 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;public class BOJ1764 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf= new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st= new StringTokenizer(bf.readLine(),\" \"); List&lt;String&gt; noEarList = new ArrayList&lt;&gt;(); List&lt;String&gt; noEyeList = new ArrayList&lt;&gt;(); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); for(int i=0;i&lt;N;i++) noEarList.add(bf.readLine()); for(int i=0;i&lt;M;i++) noEyeList.add(bf.readLine()); int count=0; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;N;i++)&#123; String person = noEarList.get(i); for(int j=0;j&lt;M;j++)&#123; if(noEyeList.get(j).equals(person))&#123; count++; sb.append(noEyeList.get(j)+\"\\n\"); &#125; &#125; &#125; System.out.println(count); System.out.println(sb.toString()); &#125;&#125; List를 이용한 다른 방법 두 번째로 시도한 방법은 List를 사용하지만, 다른 방식입니다. 이것은 처음에 N개를 입력 받고 List에 추가한 후에, 두 번째 M을 입력받을 때 바로 List에 포함되어 있는지 검사를 진행합니다. 검사를 진행해서 포함이 되어 있는 String 값은 result라는 배열에 저장하게 됩니다. 하지만, List에 저장할 때 정렬된 상태가 아니기 때문에 결과를 출력하기 전에 Collections.sort()를 이용해서 출력하는 과정을 거칩니다. 하지만, 이렇게 푸는 방식도 시간 초과가 납니다… 그래서 다른 사람들의 풀이를 비교해보니 List를 사용하지 않고 Set을 사용하는 것을 볼 수 있었습니다. Set은 List와 유사하지만, 중복된 값을 허용하지 않고 순서가 없는 자료구조 입니다. 세 번째 방법에서는 똑같은 풀이에서 List를 Set으로 바꾼 차이만 존재합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.*;public class BOJ1764 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf= new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st= new StringTokenizer(bf.readLine(),\" \"); List&lt;String&gt; noEarSett = new ArrayList&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); for(int i=0;i&lt;N;i++) &#123; noEarSett.add(bf.readLine()); &#125; for(int i=0;i&lt;M;i++)&#123; String person = bf.readLine(); if(noEarSett.contains(person))&#123; result.add(person); &#125; &#125; StringBuilder sb= new StringBuilder(); Collections.sort(result); sb.append(result.size()+\"\\n\"); for (String str : result) &#123; sb.append(str+\"\\n\"); &#125; bw.write(sb.toString()); bw.flush(); bw.close(); &#125;&#125; Set을 이용한 방법 List -&gt; Set으로 바꾼 차이 밖에 없지만, 왜 시간초과가 나지 않고 통과하는지 잘 모르겠습니다… 아마 자료 구조에 대한 공부를 조금 더 해보고 성능 상으로 차이를 확인해봐야 할 것 같습니다. 구글링을 통해서 List와 Set의 성능 차이를 검색해보았습니다. 그랬더니 약간의 차이를 보이는 것을 확인할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.*;import java.util.*;public class BOJ1764 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf= new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); StringTokenizer st= new StringTokenizer(bf.readLine(),\" \"); Set&lt;String&gt; noEarSett = new HashSet&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); int N = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); for(int i=0;i&lt;N;i++) &#123; noEarSett.add(bf.readLine()); &#125; for(int i=0;i&lt;M;i++)&#123; String person = bf.readLine(); if(noEarSett.contains(person))&#123; result.add(person); &#125; &#125; StringBuilder sb= new StringBuilder(); Collections.sort(result); sb.append(result.size()+\"\\n\"); for (String str : result) &#123; sb.append(str+\"\\n\"); &#125; bw.write(sb.toString()); bw.flush(); bw.close(); &#125;&#125; 배운점 정답률에 비해 문제가 그리 어려운 편은 아니었지만, 왜 이렇게 List와 Set에서 차이가 나는지 알 수 없었습니다. 그러다가 구글에서 List의 contains가 시간복잡도가 조금 걸린다는 것을 알게되었고, 이 부분에서 데이터가 많을 경우에는 Set이 오히려 낫다는 걸 알게되었습니다. 하지만, 데이터가 그리 많지 않은데 이런 시간초과가 나는 것은 추후에 더 알아봐야 할 것 같습니다. 그리고 N,M 두 개의 테스트 케이스를 입력 받는데, 하나는 입력 받아 Set에 저장하고 다른 테스트 케이스는 입력 받으면서 바로 Set과 비교하는 방식을 진행하였습니다. 이런 방식을 사용하는 것이 익숙치 않아서 더 풀어보면서 익숙해져야 할 것 같습니다.","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1076] 저항","slug":"BOJ1076","date":"2018-10-03T07:18:29.000Z","updated":"2020-03-01T10:43:53.008Z","comments":true,"path":"2018/10/03/BOJ1076/","link":"","permalink":"https://woovictory.github.io/2018/10/03/BOJ1076/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1076 풀이 방법 첫 번째 접근 방법 처음에는 Map이라는 자료구조를 사용해야 한다는 느낌을 받았지만, 조금 복잡하게 생각을 했었습니다. 아마도 문제의 패턴을 몰랐기 때문일 것입니다. 그래서 저는 값과 곱을 가지는 Class를 만들어서 이 클래스 타입의 ArrayList를 만들려고 시도했습니다. 하지만, 이렇게 되면 인덱스로 원소에 접근을 해야하는 문제와 시간 복잡도가 커질 수 있는 문제가 발생하여 비효율적임을 알게 되었습니다. 두 번째 접근 방법 이번에는 다른 방식을 생각했습니다. 값과 곱의 규칙을 찾아내어 Class를 따로 만들 필요가 없음을 알았습니다. 10^값 = 곱 이라는 규칙을 찾아 냈습니다. 쉽게 설명하면 값이 0일 때, 곱은 1 값이 1일 때, 곱은 10, 값이 2일 때, 곱은 100 … 이런 규칙성을 찾을 수 있었고, Map이라는 자료 구조에 String을 키로 하고, Integer를 값으로 하는 Map을 생성했고, 데이터를 넣어놓았습니다. 그리고 문제에서 입력은 3개 뿐이므로, 반복문을 통해 입력을 받기보다는 바로 받아서 처리하는 것이 효율적이라고 판단했습니다. 코드는 아래에 있습니다. 배운 점 ** Map이라는 자료구조는 내가 생각하는 것보다 다양한 곳에서 쓰이는 것 같습니다. 이러한 자료구조를 사용해서 문제를 풀 수 있도록 많이 생각해보고 문제도 많이 풀어봐야 할 것 같습니다. :) 1234567891011121314151617181920212223242526272829303132333435import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;public class BOJ1076 &#123; public static void main(String[] args) throws IOException &#123; // 저항 문제는 Map 자료구조를 사용해서 풀 수 있다. // 문제에서 입력은 세 개이므로 for문을 돌려서 받지 않고 그냥 한번에 받는 것이 더 간단. BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(\"black\", 0); map.put(\"brown\", 1); map.put(\"red\", 2); map.put(\"orange\", 3); map.put(\"yellow\", 4); map.put(\"green\", 5); map.put(\"blue\", 6); map.put(\"violet\", 7); map.put(\"grey\", 8); map.put(\"white\", 9); String one = bf.readLine(), two = bf.readLine(), three = bf.readLine(); int firstResult = map.get(one) * 10 + map.get(two); long secondResult = (long) Math.pow(10, map.get(three)); System.out.println(firstResult * secondResult); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10816] ","slug":"BOJ10816","date":"2018-09-23T12:11:55.000Z","updated":"2018-12-18T08:15:58.441Z","comments":true,"path":"2018/09/23/BOJ10816/","link":"","permalink":"https://woovictory.github.io/2018/09/23/BOJ10816/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10816 풀이 방법 멍청한 풀이 오늘 풀어본 문제는 어제 풀었던 문제의 두번째 시리즈라고 할 수 있습니다. 즉, 숫자카드2 입니다. 어제 숫자카드 문제를 풀면서 이해를 했다고 생각하고 바로 두번째 시리즈에 도전했습니다. 하지만 역시나 시즌2는 쉽지는 않다는 것을 깨달았습니다. 단순하게 Set을 쓰려고했지만, 문제를 읽어보니 Set이 아닌 다른 자료구조를 써야한다는 생각을 했고, 저는 늘 써오던 List를 이용해서 문제를 풀려고 했습니다. 하지만 List를 사용하게 되면 시간초과의 난관을 극복할 수 없었습니다. 애초에 List로 풀어야지라고 마음을 먹으면서 시간초과 날 것 같다는 염려를 했습니다…ㅜㅜ 아직 시간 초과를 해결하기 위한 다른 자료구조를 생각하는 능력이 많이 부족합니다…ㅜㅜ 그래서 일단은 부딪혀보자는 마음으로 List를 사용하여 문제를 풀었습니다. 아래의 코드는 List를 이용한 문제 풀이 방법입니다. 완성된 코드는 아니며 제가 생각해보면서 짠 코드입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;import java.util.StringTokenizer;public class BOJ10816 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++)&#123; list.add(Integer.parseInt(st.nextToken())); &#125; int M = Integer.parseInt(bf.readLine()); StringTokenizer st2 = new StringTokenizer(bf.readLine(), \" \"); StringBuilder sb = new StringBuilder(); int[] counts = new int[M]; int count = 0; for(int j=0;j&lt;M;j++)&#123; int value = Integer.parseInt(st2.nextToken()); for(int k=0;k&lt;N;k++)&#123; if(list.get(k).equals(value))&#123; count+=1; counts[M] = count; &#125;else &#123; counts[M] = 0; &#125; sb.append(counts[M]+\" \"); count = 0; &#125; /* if(list.contains(value))&#123; System.out.println(\"들어오긴 하니;??\"+\", \"+(j)); count+=1; counts[M] = count; System.out.println(counts[M]); &#125;else &#123; counts[M] = 0; &#125; sb.append(counts[M]+\" \"); count = 0;*/ &#125; System.out.println(sb.toString()); &#125;&#125; 전체적인 틀을 잡았고 어떻게 푸는지 알았지만 List만을 사용해서는 중복된 값이 들어있는 것을 Check하고 갯수를 확인하는 과정이 어려웠습니다. 그래서 생각을 하다가 구글링을 해보았습니다. 생각하고 나서 깨달은 풀이 Map이라는 자료구조를 사용했습니다. Map은 키와 값을 쌍으로 저장하는 자료구조입니다. 특징은 저장 요소의 순서를 유지하지 않고, Key는 중복을 허용하지 않지만, 값은 중복을 허용합니다. Map을 이용해서 Key, Value 쌍으로 데이터를 저장하는 방식을 사용했습니다. 처음에 상근이가 가지고 있는 카드를 입력받는데, 이 값들을 모두 Map에 저장합니다. 여기서 상근이가 가지고 있는 카드를 Key값으로 정했습니다. Map은 초기화되지 않은 상태이기 때문에 처음에 들어오는 카드 입력들은 모두 카드를 Key값으로 가지면서 Value는 모두 1을 저장했습니다. 그러다가 앞에서 저장되었던 Key의 카드 입력이 들어오게 되면 기존에 있던 key에 해당하는 value를 1을 더한 값으로 교체해줍니다. *이러한 과정을 거쳐 상근이가 가지고 있는 카드를 입력받으면 Map이라는 자료구조에 상근이가 가지고 있는 카드의 갯수가 저장됩니다. 그리고 추후에 입력받는 카드들을 상근이가 가지고 있는지 비교하는 것이므로 입력받은 카드를 Map의 containsKey() 메소드를 이용해서 카드를 가지고 있는지 비교해서 가지고 있다면 입력받은 카드의 값을 Key로 해서 Map에서 뽑아내어 출력합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.StringTokenizer;public class BOJ10816 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for (int i = 0; i &lt; N; i++) &#123; int key = Integer.parseInt(st.nextToken()); // get()은 key에 해당하는 value를 반환 if (map.containsKey(key)) &#123; map.replace(key, map.get(key) + 1); &#125; else &#123; map.put(key, 1); &#125; &#125; int M = Integer.parseInt(bf.readLine()); st = new StringTokenizer(bf.readLine(), \" \"); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; M; i++) &#123; int value = Integer.parseInt(st.nextToken()); if (map.containsKey(value)) &#123; sb.append(map.get(value) + \" \"); &#125; else &#123; sb.append(0 + \" \"); &#125; &#125; System.out.println(sb.toString()); &#125;&#125;// 입력106 3 2 10 10 10 -10 -10 7 3810 9 -5 2 3 4 5 -10// 출력3 0 0 1 2 0 0 2 배운점 알고리즘을 풀 때 시간초과를 생각하는 방법을 배웠습니다. 이전에는 무작정 풀고 나서 '왜 안되는거지???'라는 생각을 하고 구글링을 해서 다른 방법을 찾아보았다면 이제는 '시간 초과가 나서 안되네…'라는 생각을 하고 시간 초과가 나지 않는 자료구조를 생각해보고 로직을 생각하는 힘을 키우게 된 것 같습니다. 또한, 알고리즘을 풀 때 어떠한 자료구조를 사용해야 할 지 결정하는 능력은 문제를 많이 풀어봐야 한다는 것을 알게 되었습니다. 문제를 보고 도전할 수 있는 자료구조는 List, Set 정도입니다. Map은 무엇인지 알긴 하지만, 알고리즘을 풀 때 어떻게 어떤 상황에서 사용하는지에 대해 잘 모르고 있었기 때문에 부족함을 많이 느꼈습니다. 앞으로 Map을 자주 사용해보고 많이 풀어보도록 노력하는게 좋을 것 같습니다.","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[]},{"title":"[10815] 숫자 카드 ","slug":"BOJ10815","date":"2018-09-22T13:14:02.000Z","updated":"2018-12-04T08:31:00.347Z","comments":true,"path":"2018/09/22/BOJ10815/","link":"","permalink":"https://woovictory.github.io/2018/09/22/BOJ10815/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10815 풀이 방법 첫번째 접근방법 처음에는 배열을 이용해서 접근하려고 했습니다. 상근이가 몇개의 숫자 카드를 가지고 있는지 그리고 어떤 숫자 카드를 가지고 있는지 입력 받고, 그 후에는 카드의 갯수와 카드를 입력 받아서 후에 입력받은 카드를 상근이가 가지고 있는지 없는지 여부를 확인하였습니다. 상근이가 숫자 카드를 가지고 있다면 1, 가지고 있지 않다면 0을 출력하게 됩니다. 그래서 저는 N, M 크기의 배열 2개를 만들고 각 배열에 저장해서 서로 비교할 수 있도록 구현했습니다. 문제에서 주어진 테스트 케이스를 만족시키는 답을 얻을 수 있었습니다. 허나 시간 초과를 피하지 못했습니다. 문제를 풀면서도 이 문제는 시간 초과가 날 것 같다는 느낌이 들었지만, 일단 무작정 풀어보았습니다. 결과는, 역시나… 그래서 다른 방법으로 풀어보았습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package language;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class BOJ10815 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); // 상근이가 가지고 있는 카드의 갯수 //Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++)&#123; list.add(Integer.parseInt(st.nextToken())); &#125; //Set&lt;Integer&gt; check_set = new HashSet&lt;&gt;(); ArrayList&lt;Integer&gt; checkList = new ArrayList&lt;&gt;(); int M = Integer.parseInt(bf.readLine()); StringTokenizer st2 = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;M;i++)&#123; checkList.add(Integer.parseInt(st2.nextToken())); &#125; for(int i=0;i&lt;M;i++)&#123; for(int j=0;j&lt;N;j++)&#123; if(checkList.get(i).equals(list.get(j)))&#123; checkList.set(i,1); &#125; else&#123; continue; &#125; &#125; if(!checkList.get(i).equals(1))&#123; checkList.set(i,0); &#125; &#125; Iterator&lt;Integer&gt; iterator = checkList.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next()+\" \"); &#125; &#125;&#125;// 결과시간 초과....ㅜㅜ 두 번째 방법 그 다음으로는 Set 자료 구조를 이용하는 것입니다. Set 자료구조는 기본적으로 중복된 값의 저장을 허용하지 않고, 값이 정렬된 것처럼 저장됩니다. 여기서는 Set의 특성을 이용하지는 않지만, 배열보다는 더욱 편리하게 다룰 수 있을 것 같아서 이 자료구조를 사용하기로 결정했습니다. [List를 사용해도 비슷한 결과를 얻을 수 있다고 생각합니다.] 그리고 문제를 다시 살펴보면서 2개의 Set을 만들어서 값을 가지고 있을 필요가 없다고 생각했습니다. 어차피 우리가 가지고 있어야 할 값들은 상근이가 가지고 있는 숫자 카드이기 때문에 상근이가 가지고 있는 숫자 카드만 Set 자료구조에 저장해서 가지고 있도록 했습니다. M개의 숫자 카드를 가지고 있는지 확인하기 위해서 숫자 카드를 입력받는데 이 부분은 Set을 통해 값을 저장하지 않아도 됨을 깨달았습니다. 이유는 여기서 입력받는 값을 사용하지 않고 단순하게 상근이가 가지고 있는 카드인지 아닌지를 비교하기 위해서 사용하는 일회성 값이라고 판단되어 입력 받은 즉시 Set에 포함되어 있는지 contains() 메소드를 사용해서 확인해주었습니다. 12345678910111213141516171819202122232425262728293031323334353637383940import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class BOJ10815 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); // 상근이가 가지고 있는 카드의 갯수 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 상근이가 가지고 있는 카드를 담을 Set 자료구조 StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++)&#123; set.add(Integer.parseInt(st.nextToken())); &#125; int M = Integer.parseInt(bf.readLine()); StringTokenizer st2 = new StringTokenizer(bf.readLine(), \" \"); /*FIXME * 여기서는 어차피 기존에 상근이가 가지고 있는 카드와 * 입력받은 카드를 비교해서 상근이가 가지고 있는지 가지고 있지 않은지 * 판단하므로 굳이 Set을 통해서 값을 저장하지 않아도 됨. * 입력 받은 그대로 비교하면 된다. * */ for(int i=0;i&lt;M;i++)&#123; if(set.contains(Integer.parseInt(st2.nextToken())))&#123; System.out.print(1+\" \"); &#125;else &#123; System.out.print(0+\" \"); &#125; &#125; &#125;&#125;// 입력56 3 2 10 -10810 9 -5 2 3 4 5 -10// 출력 결과1 0 0 1 1 0 0 1 세 번째 방법 이 방법은 두 번째 방법과 똑같은 형태로 구현하지만, 실행 시간을 줄이기 위한 방법입니다. 두 번째 방법으로 문제를 풀면 실행시간은 1.9초 정도 나오게 됩니다. 이 문제의 시간 제한이 2초인 것에 비하면 그 안에 들어서 문제는 없습니다. 하지만 다른 사람들이 푼 코드를 통해서 시간을 줄일 수 있는 방법을 찾았습니다. 그 방법은 System.out.print()를 빈번하게 호출하는 것보다는 StringBuilder 객체를 만들어서 append() 함수를 통해 값을 추가하고 마지막으로 한 번만 최종 결과를 출력해 주는 것입니다. 이 방법은 실행 시간이 0.9초 나오는 것을 확인할 수 있었고, 두 번째 방법과 1초 정도의 실핼 시간 차이가 남을 확인할 수 있었습니다. 실행 시간을 단축할 수 있는 방법을 찾았습니다. :) 123456789101112131415161718192021222324252627282930313233343536373839404142434445package language;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class BOJ10815 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); // 상근이가 가지고 있는 카드의 갯수 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 상근이가 가지고 있는 카드를 담을 Set 자료구조 StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++)&#123; set.add(Integer.parseInt(st.nextToken())); &#125; int M = Integer.parseInt(bf.readLine()); StringTokenizer st2 = new StringTokenizer(bf.readLine(), \" \"); /*FIXME * 여기서는 어차피 기존에 상근이가 가지고 있는 카드와 * 입력받은 카드를 비교해서 상근이가 가지고 있는지 가지고 있지 않은지 * 판단하므로 굳이 Set을 통해서 값을 저장하지 않아도 됨. * 입력 받은 그대로 비교하면 된다. * */ StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;M;i++)&#123; if(set.contains(Integer.parseInt(st2.nextToken())))&#123; sb.append(1+\" \"); &#125;else &#123; sb.append(0+\" \"); &#125; &#125; System.out.println(sb.toString()); &#125;&#125;// 입력56 3 2 10 -10810 9 -5 2 3 4 5 -10// 출력 결과1 0 0 1 1 0 0 1 단 3줄의 차이로 실행시간이 1초 줄어든 것을 확인할 수 있습니다. 앞으로 알고리즘 문제를 풀었더라도 실행 시간을 줄이는 방법을 찾아보고 공부해보는 것도 좋은 경험이 되고 실력도 쌓일 것 같습니다.","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[]},{"title":"[10867] 중복빼고 정렬하기 ","slug":"BOJ10867","date":"2018-09-22T09:27:21.000Z","updated":"2018-12-04T08:31:29.293Z","comments":true,"path":"2018/09/22/BOJ10867/","link":"","permalink":"https://woovictory.github.io/2018/09/22/BOJ10867/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10867 풀이 방법 이 문제는 입력받은 숫자를 오름차순으로 정렬하는 문제입니다. 하지만 중복된 숫자가 있다면 제거하고 정렬해야 합니다. 이 문제는 배열을 이용해서 풀어도 되지만, 배열을 이용해서 푼다면 중복된 값을 체크해야 하기 때문에, 그보다는 중복된 값을 허용하지 않는 자료구조를 사용하는 것이 간편하다고 생각합니다. 그래서 저는 Set 자료구조를 사용했고, HashSet을 이용해서 문제를 해결하였습니다. 1234567891011121314151617181920212223242526import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;test_case;i++)&#123; int value = Integer.parseInt(st.nextToken()); set.add(value); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(set); Collections.sort(list); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next()+\" \"); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[2346] 풍선 터뜨리기 ","slug":"BOJ2346","date":"2018-09-18T13:41:18.000Z","updated":"2018-12-04T08:30:09.563Z","comments":true,"path":"2018/09/18/BOJ2346/","link":"","permalink":"https://woovictory.github.io/2018/09/18/BOJ2346/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/2346 풀이 방법 예전에 한 번 풀어본 문제이지만, 인간의 기억력은 역시나… 오래 지속되지 않는다는 걸 알면서도 똑같은 실수를 반복했습니다…ㅜ 그래서 저는 다시 풀어보았습니다. 다행스럽게도 풀어본 경험이 있어서인지 문제를 보고 어떻게 접근해야 하는지 생각할 수 있었습니다. Class 만들기 풍선의 순서와 풍선에 적혀있는 값을 가지고 있는 Class를 만들어서 사용하면 됩니다. List 사용 이 문제를 풀기 위해서 위에서 만든 Class를 타입으로 갖는 객체 배열을 사용할지 리스트를 사용할지 생각했습니다. 이 문제에서는 풍선을 터뜨릴 경우 삭제를 해줘야 하기 때문에 추가 및 삭제가 일어나도 빈 공간을 처리하지 않아도 되는 즉, 빈 공간이 자동으로 채워지는 List를 사용하였습니다. 터뜨릴 순서? 풍선을 터뜨릴 순서를 결정하기 위해서는 풍선에 적혀있는 값을 가지고 결정해야 합니다. 풍선에 적혀있는 값이 양수이면 오른쪽으로 돌고, 음수이면 왼쪽으로 돌아서 풍선을 터뜨리면 됩니다. 문제에서 풍선은 원형처럼 1번의 왼쪽에는 N번 풍선이, N번의 오른쪽에는 1번 풍선이 있다고 하였으므로 참고해서 돌고 터뜨리면 됩니다. 주의할 점은 처음에 터뜨릴 풍선은 1번 풍선인데, 이 풍선을 터뜨리고 나면 1번 풍선이 사라지면서 2번째 풍선이 1번 풍선의 인덱스를 가지게 됩니다. 그러므로 첫번째 풍선을 이미 터뜨리고 나서 풍선에 적힌 값에 따라서 다음에 터뜨릴 풍선을 결정할 때, 풍선에 적혀있는 값이 양수라면 (그 값 - 1) 만큼만 계산하면 됩니다. 왜냐하면 리스트에서 풍선이 삭제됨에 따라서 이미 한칸을 이동했기 때문입니다. (쉽게 말하면 풍선이 하나 터지면서 다른 풍선의 인덱스들이 터진 풍선 이후 부터 즉, 오른쪽부터 0부터 재할당되기 때문입니다.) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Iterator;import java.util.StringTokenizer;public class BOJ2346 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); // 테스트 케이스 ArrayList&lt;Ballons&gt; ballons = new ArrayList&lt;&gt;(); StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;test_case;i++)&#123; int value = Integer.parseInt(st.nextToken()); ballons.add(new Ballons(i+1, value)); &#125; String str = process(ballons, test_case); System.out.println(str); &#125; public static String process(ArrayList&lt;Ballons&gt; ballon_list, int num)&#123; int kill=0; // 터뜨릴 풍선의 인덱스 int value=0; // 터뜨릴 풍선의 값 StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;num;i++)&#123; // value 즉, 풍선에 적혀있는 값이 양수인지 음수인지에 따라 // 오른쪽 혹은 왼쪽으로 이동하기 위해 검사 if(value&gt;0)&#123; for(int k=0;k&lt;value-1;k++)&#123; ++kill; if(kill&gt;=ballon_list.size())&#123; kill=0; &#125; &#125; &#125;else if(value&lt;0)&#123; value = Math.abs(value); // 절대값 변환 for(int j=0;j&lt;value;j++)&#123; --kill; if (kill&lt;0)&#123; kill = ballon_list.size()-1; &#125; &#125; &#125; /*FIXME * 처음에는 0번째 즉, 첫 번째 풍선을 터뜨려야 하기 때문에 * 이렇게 터뜨릴 풍선을 정하고 * 그 풍선의 값(value)[즉, 적혀있는 값!]를 알아낸다. * 왜냐하면, 다음 풍선을 터뜨리기 위해 얼만큼 이동할지 알기 위해서 * */ Ballons ballon = ballon_list.get(kill); System.out.println(\"삭제가 될 풍선 : \"+ballon.valueNumber+\", \"+(ballon.orderNumber)+\", \"+kill); value = ballon.valueNumber; sb.append(ballon.orderNumber+\" \"); ballon_list.remove(kill); if(kill == ballon_list.size())&#123; System.out.println(\"몇번?\"); kill = 0; &#125; &#125; return sb.toString(); &#125;&#125;class Ballons&#123; int orderNumber; // 풍선의 순서 int valueNumber; // 풍선 안에 적힌 값 public Ballons(int orderNumber, int valueNumber)&#123; this.orderNumber = orderNumber; this.valueNumber = valueNumber; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[Java] 19. java.time","slug":"java-basic-19","date":"2018-09-05T11:36:36.000Z","updated":"2020-04-22T07:47:45.864Z","comments":true,"path":"2018/09/05/java-basic-19/","link":"","permalink":"https://woovictory.github.io/2018/09/05/java-basic-19/","excerpt":"","text":"자바에서의 날짜 및 시간 처리 JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 처리를 수행했습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(deprecated)있습니다. JDK 1.1부터 새롭게 제공된 Calendar 클래스는 날짜와 시간에 대한 정보를 손쉽게 얻을 수 있었습니다. 하지만 Calendar 클래스는 다음과 같은 문제점을 가지고 있습니다. Calendar 인스턴스는 불변 객체(immutable object)가 아니라서 값이 수정될 수 있습니다. 윤초(leap second)와 같은 특별한 상황을 고려하지 않습니다. Calendar 클래스에서는 월(month)을 나타낼 때 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다. 따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러리를 함께 사용해 왔습니다. 버전에서는 이러한 Joda-Time 라이브러리를 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 하위 패키지를 포함하고 있습니다. java.time 패키지 Java SE 8부터 제공되는 java.time 패키지에는 자바에서 날짜와 시간을 다루는 데 사용되는 필수 클래스들이 포함되어 있습니다. 또한, 다음과 같은 다양한 기능을 하는 하위 패키지를 포함하고 있습니다. java.time.chrono : ISO-8601에 정의된 표준 달력 이외의 달력 시스템을 사용할 때 필요한 클래스들 java.time.format : 날짜와 시간에 대한 데이터를 구문 분석하고 형식화하는데 사용되는 클래스들 java.time.temporal : 날짜와 시간에 대한 데이터를 연산하는 데 사용되는 보조 클래스들 java.time.zone : 타임 존(time-zone)과 관련된 클래스들 java.time 패키지는 기존에 사용되는 Calendar 클래스의 단점을 보완하였습니다. 따라서 해당 패키지에 속하는 모든 클래스의 인스턴스는 불변 객체(immutable object)로 생성됩니다. 따라서, 값을 수정할 수 없습니다. 즉, java.time 패키지에 포함되는 클래스의 메소드들은 모두 새로운 객체를 생성하여 반환하고 있습니다. java.time 패키지의 구성 클래스 기존의 Calendar 클래스는 날짜와 시간을 한 번에 표현했지만, java.time 패키지에서는 별도로 구분하여 처리합니다. LocalData 클래스는 날짜를 표현할 때 사용하며, LocalTime 클래스는 시간을 표현할 때 사용합니다. 또한, 기존의 Caledar 클래스처럼 날짜와 시간을 한 번에 표현하고 싶을 때는 LocalDateTime 클래스를 사용합니다. ZonedDateTime 클래스는 특정 타임 존(time-zone)에 해당하는 날짜와 시간을 다루는 데 사용합니다. 또한, 기존의 Date 클래스와 비슷한 용도로 사용되는 Instant 클래스가 있습니다. Instant 클래스는 특정 시점의 날짜와 시간을 나노초(nanosecond) 단위로 표현하는 타임스탬프(time-stamp)를 다루는 데 사용됩니다. Period 클래스(단어가 의미하듯이 '기간’이라는 뜻을 가지고 있음)는 두 날짜 사이의 차이를 표현하는 데 사용되며, Duration 클래스는 두 시각 사이의 차이를 표현하는 데 사용됩니다. LocalDate와 LocalTime LocalData 클래스는 날짜를 표현하는 데 사용되며, LocalTime 클래스는 시간을 표현하는 데 사용됩니다. java.time 패키지에 포함된 대부분의 클래스들은 이 두 클래스를 확장한 것이 많으므로, 우선 이 두 클래스를 먼저 이해하고 알고 있어야 합니다. :) 날짜와 시간 객체의 생성 LocalData와 LocalTime 클래스는 객체를 생성하기 위해 now()와 of() 메소드라는 클래스 메소드를 제공합니다. now() 메소드는 현재 날짜와 시간을 이용하여 새로운 객체를 생성하여 반환합니다. 하지만 of() 메소드는 전달된 인수를 가지고 특정 날짜와 시간을 표현하는 새로운 객체를 생성하여 반환합니다. 12345678910111213141516171819package com.company;import java.time.LocalDate;import java.time.LocalTime;public class streamExam &#123; public static void main(String[] args) &#123; LocalDate today = LocalDate.now(); // 현재 날짜 기준으로 생성 LocalTime present = LocalTime.now(); System.out.println(today+\" 와 \"+present); LocalDate birthday = LocalDate.of(1994,06,27); LocalTime birthTime = LocalTime.of(02,00,00,11); System.out.println(birthday+\", \"+birthTime); &#125;&#125;// 결과2018-09-05 와 21:22:06.6401994-06-27, 02:00:00.000000011 of() 메소드는 위의 예제에서 사용된 메소드 시그니처 이외에도 다양한 형태로 오버로딩되어 제공됩니다. 날짜와 시간 객체에 접근하기 LocalDate와 LocalTime 클래스는 특정 필드의 값을 가져오기 위해서 다음과 같이 다양한 getter 메소드를 제공합니다. 메소드 설명 int get(TemporalField field) long getLong(TemporalField field) 해당 날짜 객체의 명시된 필드의 값을 int형이나 long형으로 반환함. int getYear() 해당 날짜 객체의 연도(YEAR) 필드의 값을 반환함. Month getMonth() 해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 Month 열거체를 이용하여 반환함.(즉, SEPTEMBER과 같은 형식으로 반환) int getMonthValue() 해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 반환함. (숫자로 1~12까지를 반환함.) int getDayOfMonth() 해당 날짜 객체의 일(DAY_OF_MONTH) 필드의 값을 반환함. (숫자로 1~31까지를 반환함.) int getDayOfYear() 해당 날짜 객체의 일(DAY_OF_YEAR) 필드의 값을 반환함. (숫자로 1~365까지를 반환함.[윤년이면 366]) DayOfWeek getDayOfWeek() 해당 날짜 객체의 요일(DAY_OF_WEEK) 필드의 값을 DayOfWeek 열거체를 이용하여 반환함. 기존의 Calendar 클래스에서는 1월을 0으로 표현하여 월의 범위가 0~11이었으며, 요일은 일요일부터 1로 표현했습니다. 하지만 java.time 패키지에서 1월을 1로 표현하여 월의 범위가 1~12가 되었으며, 요일은 월요일부터 1로 표현하도록 변경되었습니다. Calendar 클래스와 java.time 패키지의 클래스를 같이 사용할 때에는 특히 위와 같은 차이점에 주의해야 합니다. 12345678910111213141516171819202122import java.time.LocalDate;import java.time.temporal.ChronoField;public class streamExam &#123; public static void main(String[] args) &#123; LocalDate today = LocalDate.now(); // 현재 날짜 기준으로 생성 System.out.println(\"올해는 \"+today.getYear()+\"년입니다.\"); System.out.println(\"이번달은 \"+today.getMonthValue()+\"월입니다.\"); System.out.println(\"오늘은\"+today.getDayOfWeek()+\"입니다.\"); System.out.println(\"오늘은 1년 중 \"+today.get(ChronoField.DAY_OF_YEAR)+\"일째 날입니다.\"); &#125;&#125;//결과올해는 2018년입니다.이번달은 9월입니다.오늘은WEDNESDAY입니다.오늘은 1년 중 248일째 날입니다. LocalTime 클래스에서 제공하는 대표적인 getter 메소드는 다음과 같습니다. 메소드 설명 int get(TemporalField field) long getLong(TemporalField field) 해당 시간 객체의 명시된 필드의 값을 int형이나 long형으로 반환함. int getHour() 해당 시간 객체의 시(HOUR_OF_DAY) 필드의 값을 반환함. int getMinute() 해당 시간 객체의 분(MINUTE_OF_HOUR) 필드의 값을 반환함. int getSecond() 해당 시간 객체의 초(SECOND_OF_MINUTE) 필드의 값을 반환함. int getNano() 해당 시간 객체의 나노초(NANO_OF_SECOND) 필드의 값을 반환함. 123456789101112import java.time.LocalTime;public class streamExam &#123; public static void main(String[] args) &#123; LocalTime present = LocalTime.now(); System.out.println(\"현재 시각은 \" + present.getHour() + \"시 \" + present.getMinute() + \"분입니다.\"); &#125;&#125;//결과현재 시각은 0시 18분입니다. LocalDate와 LocalTime 클래스는 모두 현재 시간을 기준으로 하기 때문에 이 글을 보고 참고하시는 분들은 저와 다른 결과를 볼 수 있습니다. 다른 것이 당연한 것이니 당황해 하지 마시길…ㅎㅎ TemporalField 인터페이스 TemporalField 인터페이스는 월(month-of-year)과 시(hour-of-day)와 같이 날짜와 시간과 관련된 필드를 정의해 놓은 인터페이스입니다. 이 인터페이스를 구현하여 날짜와 시간을 나타낼 때 사용하는 열거체가 바로 ChronoField입니다. java.time 패키지를 구성하는 클래스의 메소드에서는 이 열거체를 이용하여 날짜와 시간을 처리하고 있스빈다. ChronoField 열거체에 정의된 대표적인 열거체 상수는 다음 표와 같습니다. 123456789101112131415161718192021222324import java.time.LocalTime;import java.time.temporal.ChronoField;public class streamExam &#123; public static void main(String[] args) &#123; LocalTime present = LocalTime.of(13, 13, 13); String ampm; System.out.println(present.get(ChronoField.AMPM_OF_DAY)); // 0 : 오전, 1 : 오후 if (present.get(ChronoField.AMPM_OF_DAY) == 0) &#123; ampm = \"오전\"; &#125; else &#123; ampm = \"오후\"; &#125; System.out.println(\"지금은 \" + ampm + \" \" + present.get(ChronoField.HOUR_OF_AMPM) + \"시입니다.\"); &#125;&#125;// 결과1지금은 오후 1시입니다. 위의 결과에서 보듯이 'present.get(ChronoField.AMPM_OF_DAY)'는 오전은 0을 오후는 1을 반환하고 있습니다. 날짜와 시간 객체의 필드값 변경 LocalDate와 LocalTime 클래스는 날짜와 시간 객체에 접근하여 특정 필드의 값을 변경하기 위해서 with() 메소드를 사용합니다. with() 메소드를 사용하면 값이 변경될 필드를 사용자가 직접 명시할 수 있습니다. 또한, 특정 필드의 값을 변경하기 위해 미리 정의되어 제공되는 다양한 with() 메소드를 사용할 수도 있습니다. LocalDate 클래스에서 제공하는 with() 메소드는 다음과 같습니다. LocalTime 클래스에서 제공하는 with() 메소드는 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132package com.company;import java.time.LocalDate;import java.time.LocalTime;public class streamExam &#123; public static void main(String[] args) &#123; LocalDate today = LocalDate.now(); System.out.println(\"올해는 \"+today.getYear()+\"년입니다.\"); LocalDate otherDay = today.withYear(1994); // 새로운 객체를 반환 System.out.println(\"올해는 \"+otherDay.getYear()+\"년입니다.\"); System.out.println(); LocalTime present = LocalTime.now(); System.out.println(\"현재 시각은 \"+present.getHour()+\"시 입니다.\"); LocalTime otherTime = present.withHour(16); // 새로운 객체를 반환 System.out.println(\"현재 시각은 \"+otherTime.getHour()+\"시 입니다.\"); &#125;&#125;//결과올해는 2018년입니다.올해는 1994년입니다.현재 시각은 0시 입니다.현재 시각은 16시 입니다. with() 메소드 이외에도 특정 필드의 값을 더하거나 뺄 수 있는 다양한 plus()와 minus() 메소드도 제공됩니다. 1234567891011121314151617181920212223package com.company;import java.time.LocalTime;import java.time.temporal.ChronoField;import java.time.temporal.ChronoUnit;public class streamExam &#123; public static void main(String[] args) &#123; LocalTime present = LocalTime.now(); System.out.println(\"현재 시각은 \" + present.get(ChronoField.HOUR_OF_DAY) + \"시입니다.\"); LocalTime otherTime = present.plus(2, ChronoUnit.HOURS); System.out.println(\"바뀐 시간은 \" + otherTime.getHour() + \"시입니다.\"); LocalTime anotherTime = present.minus(6, ChronoUnit.HOURS); System.out.println(\"바뀐 시간은 \" + anotherTime.getHour() + \"시입니다.\"); &#125;&#125;//결과현재 시각은 1시입니다.바뀐 시간은 3시입니다.바뀐 시간은 19시입니다. 날짜와 시간 객체의 비교 LocalDate와 LocalTime 클래스에도 객체를 비교할 수 있는 compareTo() 메소드가 오버라이딩 되어 있습니다. 하지만 더욱 편리하게 날짜와 시간 객체를 서로 비교할 수 있도록 다음과 같은 메소드를 제공합니다. isEqual() 메소드 : equals() 메소드와는 달리 오직 날짜만을 비교함.(LocalDate 클래스에서만 제공) isBefore() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 앞선 시간인지를 비교함. isAfter() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 늦은 시간인지를 비교함. 1234567891011121314151617181920212223242526import java.time.LocalDate;public class streamExam &#123; public static void main(String[] args) &#123; LocalDate today = LocalDate.now(); LocalDate otherDay = LocalDate.of(1994, 06, 27); LocalDate otherDay2 = LocalDate.of(1994, 06, 27); System.out.println(today.compareTo(otherDay)); // today와 otherDay의 year 간의 차이를 반환 System.out.println(today.isBefore(otherDay)); System.out.println(today.isAfter(otherDay)); System.out.println(today.isEqual(otherDay)); System.out.println(); System.out.println(otherDay.isEqual(otherDay2)); &#125;&#125;// 결과24falsetruefalsetrue","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 18. 스트림API","slug":"java-basic-18","date":"2018-09-04T03:06:54.000Z","updated":"2020-04-22T07:47:48.453Z","comments":true,"path":"2018/09/04/java-basic-18/","link":"","permalink":"https://woovictory.github.io/2018/09/04/java-basic-18/","excerpt":"","text":"스트림API Java SE 8부터 추가된 스트림 API는 앞서 입력과 출력 수업에서 살펴본 스트림과는 전혀 다른 개념입니다. 자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용하는데, 이렇게 저장된 데이터에 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 새로운 코드를 작성해야 합니다. 하지만 이렇게 작성된 코드는 길이가 너무 길고 가독성도 떨어지며, 코드의 재사용이 거의 불가능합니다. 즉, 데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했습니다. 이러한 문제점을 극복하기 위해서 Java SE 8부터 스트림(stream) API를 도입합니다. 스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다. 따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 됩니다. 스트림 API의 특징 스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복(internal iteration)을 통해 작업을 수행합니다. 스트림은 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있습니다. 스트림은 원본 데이터를 변경하지 않습니다. 스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화합니다. 스트림은 parallelStream() 메소드를 통한 손쉬운 병렬 처리를 지원합니다. 스트림 API의 동작 흐름 스트림 APi는 다음과 같이 세 가지 단계에 걸쳐서 동작합니다. 스트림의 생성 스트림의 중개 연산(스트림의 변환) 스트림의 최종 연산(스트림의 사용) 스트림의 생성 스트림 API는 다음과 같은 다양한 데이터 소스에서 생성해서 사용할 수 있습니다. 컬렉션 배열 가변 매개변수 지정된 범위의 연속된 정수 특정 타입의 난수들 람다 표현식 파일 빈 스트림 컬렉션 자바에서 제공하는 모든 컬렉션의 최고 상위 조상인 Collection 인터페이스에는 stream() 메소드가 정의되어 있습니다. 따라서 Collection 인터페이스를 구현한 모든 List와 Set 컬렉션 클래스에서도 stream() 메소드로 스트림을 생성할 수 있습니다. 또한, parallelStream() 메소드를 사용하면 병렬 처리가 가능한 스트림을 생성할 수 있습니다. 123456789101112131415161718192021import java.util.ArrayList;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(4); list.add(2); list.add(3); list.add(1); Stream&lt;Integer&gt; stream = list.stream(); stream.forEach(System.out::println); // stream.forEach(System.out::println); 한 번 더 호출하면 에러가 발생 &#125;&#125;//결과4231 Stream 클래스의 forEach() 메소드는 해당 스트림의 요소를 하나씩 소모해가며 순차적으로 요소에 접근하는 메소드입니다. 따라서 같은 스트림으로는 forEach() 메소드를 한 번밖에 호출할 수 없습니다. 단, 원본 데이터의 요소를 소모하는 것은 아니므로, 같은 데이터에서 또 다른 스트림을 생성하여 forEach() 메소드를 호출하는 것은 가능합니다. 배열 배열에 관한 스트림을 생성하기 위해 Arrays 클래스에는 다양한 형태의 stream() 메소드가 클래스 메소드로 정의되어 있습니다. 또한, 기본 타입인 int, long, double 형을 저장할 수 있는 배열에 관한 스트림이 별도로 정의되어 있습니다. 이러한 스트림은 java.util.stream 패키지의 IntStream, LongStream, DoubleStream 인터페이스로 각각 제공됩니다. 12345678910111213141516171819202122import java.util.ArrayList;import java.util.Arrays;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; String[] arr = new String[]&#123;\"넷\", \"둘\", \"셋\", \"하나\"&#125;; // 배열에서 스트림 생성 Stream&lt;String&gt; stream1 = Arrays.stream(arr); stream1.forEach(e -&gt; System.out.print(e + \" \")); System.out.println(); // 배열의 특정 부분만을 이용한 스트림 생성 Stream&lt;String&gt; stream2 = Arrays.stream(arr, 1, 3); stream2.forEach(e -&gt; System.out.print(e + \" \")); &#125;&#125;// 결과넷 둘 셋 하나 둘 셋 Arryas 클래스의 stream() 메소드는 전체 배열뿐만 아니라 배열의 특정 부분만을 이용하여 스트림을 생성할 수도 있습니다. 가변 매개변수 Stream 클래스의 of() 메소드를 사용하면 가변 매개변수를 전달받아 스트림을 생성할 수 있습니다. 1234567891011121314import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;Double&gt; stream = Stream.of(4.2, 2.5, 3.1, 1.9); stream.forEach(System.out::println); &#125;&#125;//결과4.22.53.11.9 지정된 범위의 연속된 정수 지정된 범위의 연속된 정수를 스트림으로 생성하기 위해 IntStream이나 LongStream 인터페이스에는 range()와 rangeClosed() 메소드가 정의되어 있습니다. range() : 명시된 시작 정수를 포함하지만, 명시된 마지막 정수는 포함하지 않는 스트림을 생성합니다. rangeClosed() : 명시된 시작 정수뿐만 아니라 명시된 마지막 정수까지도 포함하는 스트림을 생성합니다. 1234567891011121314151617import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream1 = IntStream.range(1, 4); stream1.forEach(e -&gt; System.out.print(e + \" \")); System.out.println(); IntStream stream2 = IntStream.rangeClosed(1, 4); stream2.forEach(e -&gt; System.out.print(e + \" \")); &#125;&#125;//결과1 2 3 1 2 3 4 특정 타입의 난수들 특정 타입의 난수로 이루어진 스트림을 생성하기 위해 Random 클래스에는 ints(), longs(), doubles()와 같은 메소드가 정의되어 있습니다. 이 메소드들은 매개변수로 스트림의 크기를 long 타입으로 전달받을 수 있습니다. 이 메소드들은 만약 매개 변수를 전달받지 않으면 크기가 정해지지 않은 무한 스트림을 반환합니다. 이때에는 limit() 메소드를 사용하여 따로 스트림의 크기를 제한해야 합니다. 123456789101112131415161718192021import java.util.Random;import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream intStream = new Random().ints().limit(10); intStream.forEach(System.out::println); &#125;&#125;// 결과-3064527311589863803-2033593764-686440616-9386281662106259183700874167-1006255911-1814985891937399570 위의 코드에서 처음에 ints() 메소드에 크기를 지정해주지 않아서 무한 스트림을 반환하지만, 뒤에 limit() 메소드를 이용하여 크기를 10으로 제한했습니다. 람다 표현식 람다 표현식을 매개변수로 전달받아 해당 람다 표현식에 의해 반환되는 값을 요소로 하는 무한 스트림을 생성하기 위해 Stream 클래스에는 iterate()와 generate() 메소드가 정의되어 있습니다. iterate() : 시드(seed)로 명시된 값을 람다 표현식에 사용하여 반환된 값을 다시 시드로 사용하는 방식으로 무한 스트림을 생성합니다. generate() : 매개변수가 없는 람다 표현식을 사용하여 반환된 값으로 무한 스트림을 생성합니다. 12IntStream stream = Stream.iterate(2, n-&gt;n+2);// 2,4,6,8,10, ... 파일 파일의 한 행(line)을 요소로 하는 스트림을 생성하기 위해 java.nio.file.Files 클래스에는 lines() 메소드가 정의되어 있습니다. 또한, java.io.BufferedReader 클래스의 lines() 메소드를 사용하면 파일뿐만 아니라 다른 입력으로부터도 데이터를 행(line) 단위로 읽어 올 수 있습니다. 1String&lt;String&gt; stream = File.lines(Path path); 빈 스트림 아무 요소도 가지지 않는 빈 스트림은 Stream 클래스의 empty() 메소드를 사용하여 생성할 수 있습니다. 1234567891011121314// 빈 스트림 생성import java.util.Random;import java.util.stream.IntStream;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;Object&gt; stream = Stream.empty(); System.out.println(stream.count()); // 스트림의 요소의 총 개수를 출력 &#125;&#125;// 결과0 스트림의 중개 연산 스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됩니다. 이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있습니다. 또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 지연(lazy) 연산을 통해 성능을 최적화할 수 있습니다. 스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같습니다. 스트림 필터링 : filter(), distinct() 스트림 변환 : map(), flatMap() 스트림 제한 : limit(), skip() 스트림 정렬 : sorted() 스트림 연산 결과 확인 : peek() 스트림 필터링 filter() 메소드는 해당 스트림에서 주어진 조건(predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환합니다. 또한, distinct() 메소드는 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환합니다. distinct() 메소드는 내부적으로 Object 클래스의 equals() 메소드를 사용하여 요소의 중복을 비교합니다. 123456789101112131415161718import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream intStream1 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6); IntStream intStream2 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6); // 스트림에서 중복된 요소 제거 intStream1.distinct().forEach(e-&gt;System.out.print(e+\" \")); System.out.println(); // 스트림에서 홀수만 골라냄 intStream2.filter(k-&gt;k%2 != 0).forEach(e-&gt;System.out.print(e+\" \")); &#125;&#125;// 결과7 5 2 1 3 4 6 7 5 5 1 3 5 스트림 변환 map() 메소드는 해당 스트림의 요소들을 주어진 함수에 인수로 전달하여, 그 반환값들로 이루어진 새로운 스트림을 반환합니다. 만약 해당 스트림의 요소가 배열이라면, flatMap() 메소드를 사용하여 각 배열의 각 요소의 반환값을 하나로 합친 새로운 스트림을 얻을 수 있습니다. 다음 코드는 문자열로 이루어진 스트림을 map() 메소드를 이용하여 각 문자열의 길이로 이루어진 스트림으로 변환하는 예제입니다. 12345678910111213import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stringStream = Stream.of(\"HTML\", \"CSS\", \"JAVA\", \"JAVASCRIPT\"); stringStream.map(e-&gt;e.length()).forEach(System.out::println); &#125;&#125;// 결과43410 다음은 여러 문자열이 저장된 배열을 각 문자열에 포함된 단어로 이루어진 스트림으로 변환하는 예제입니다. 1234567891011121314151617181920212223package com.company;import java.util.Arrays;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; String[] arr = &#123;\"I study hard\", \"You study JAVA\", \"I am hungry\"&#125;; Stream&lt;String&gt; stream = Arrays.stream(arr); stream.flatMap(s-&gt;Stream.of(s.split(\" \"))).forEach(System.out::println); &#125;&#125;// 결과IstudyhardYoustudyJAVAIamhungry 스트림 제한 limit() 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소만으로 이루어진 새로운 스트림을 반환합니다. skip() 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소를 제외한 나머지 요소만으로 이루어진 새로운 스트림을 반환합니다. 그리고 두 메소드의 들어가는 매개변수의 인덱스는 포함하지 않고 바로 직전 인덱스까지만 해당됩니다. 123456789101112131415161718192021222324import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream1 = IntStream.range(0, 10); IntStream stream2 = IntStream.range(0, 10); IntStream stream3 = IntStream.range(0, 10); // 첫 번째 요소부터 4개의 요소를 제외 : 0,1,2,3 제외한 나머지 요소 출력 stream1.skip(4).forEach(n -&gt; System.out.print(n + \" \")); System.out.println(); // 첫 번째 요소부터 5개의 요소 출력 : 0,1,2,3,4 stream2.limit(5).forEach(n -&gt; System.out.print(n + \" \")); System.out.println(); stream3.skip(3).limit(5).forEach(n -&gt; System.out.print(n + \" \")); &#125;&#125;//결과4 5 6 7 8 9 0 1 2 3 4 3 4 5 6 7 스트림 정렬 sorted() 메소드는 해당 스트림을 주어진 비교자(comparator)를 이용하여 정렬합니다. 이때 비교자를 전달하지 않으면 기본적으로 사전 편찬 순(natural order)으로 정렬하게 되고, 비교자를 전달하면 사전 편찬 순의 역순으로 정렬하게 됩니다. 12345678910111213141516171819package com.company;import java.util.Comparator;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream1 = Stream.of(\"JAVA\", \"HTML\", \"JAVASCRIPT\", \"CSS\"); Stream&lt;String&gt; stream2 = Stream.of(\"JAVA\", \"HTML\", \"JAVASCRIPT\", \"CSS\"); stream1.sorted().forEach(s -&gt; System.out.print(s + \" \")); System.out.println(); stream2.sorted(Comparator.reverseOrder()).forEach(s -&gt; System.out.print(s + \" \")); &#125;&#125;// 결과CSS HTML JAVA JAVASCRIPT JAVASCRIPT JAVA HTML CSS 스트림 연산 결과 확인 peek() 메소드는 결과 스트림으로부터 요소를 소모하여 추가로 명시된 동작을 수행합니다. 이 메소드는 원본 스트림에서 요소를 소모하지 않으므로, 주로 연산과 연산 사이에 결과를 확인하고 싶을 때 사용합니다. 따라서 개발자가 디버깅 용도로 많이 사용합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.company;import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6); stream.peek(s -&gt; System.out.println(\"원본 스트림 : \" + s)) .skip(2) .peek(s -&gt; System.out.println(\"skip(2) 실행 후 : \" + s)) .limit(5) .peek(s -&gt; System.out.println(\"limit(5) 실행 후 : \" + s)) .sorted() .peek(s -&gt; System.out.println(\"sorted() 실행 후 : \" + s)) .forEach(n -&gt; System.out.println(n)); &#125;&#125;// 결과원본 스트림 : 7원본 스트림 : 5원본 스트림 : 5skip(2) 실행 후 : 5limit(5) 실행 후 : 5원본 스트림 : 2skip(2) 실행 후 : 2limit(5) 실행 후 : 2원본 스트림 : 1skip(2) 실행 후 : 1limit(5) 실행 후 : 1원본 스트림 : 2skip(2) 실행 후 : 2limit(5) 실행 후 : 2원본 스트림 : 3skip(2) 실행 후 : 3limit(5) 실행 후 : 3sorted() 실행 후 : 11sorted() 실행 후 : 22sorted() 실행 후 : 22sorted() 실행 후 : 33sorted() 실행 후 : 55 위의 코드는 다음과 같은 결과를 보여줍니다. 현재 지금 저는 스트림 API에 대한 개념이 적은 상태입니다. 그리고 위의 peek()이라는 메소드의 동작 상태가 이해가 가지 않네요… 이렇게 정리해놓고 나중에 다시 공부할 때 조금 더 찾아보게 된다면 아마 이해가 가지 않을까요?ㅎㅎ 위의 예제에서 첫 번째 요소인 7과 두 번째 요소인 5는 skip() 메소드에 의해 삭제되므로, 원본 스트림에서만 나타납니다. 하지만 세 번째 요소인 5는 skip() 메소드와 limit() 메소드가 실행된 후에도 존재하므로, 모두 나타납니다. 이렇게 peek() 메소드는 스트림의 각 요소가 해당 중개 연산 후에 어떻게 변화하는지를 보여줍니다. 대표적인 중개 연산 메소드 스트림 API에서 사용할 수 있는 대표적인 중개 연산을 위한 메소드는 다음과 같습니다. 스트림의 최종 연산 스트림 API에서 중개 연산을 통해 변환된 스트림은 마지막으로 최종 연산을 통해 각 요소를 소모하여 결과를 표시합니다. 즉, 지연(lazy)되었던 모든 중개 연산들이 최종 연산 시에 모두 수행되는 것입니다. 이렇게 최종 연산 시에 모든 요소를 소모한 해당 스트림은 더는 사용할 수 없게 됩니다. 스트림 API에서 사용할 수 있는 대표적인 최종 연산과 그에 따른 메소드는 다음과 같습니다. 요소의 출력 : forEach() 요소의 소모 : reduce() 요소의 검색 : findFirst(), findAny() 요소의 검사 : anyMatch(), allMatch(), noneMatch() 요소의 통계 : count(), min(), max() 요소의 연산 : sum(), average() 요소의 수집 : collect() 요소의 출력 위에서 중개 연산과 관련된 메소드를 사용하면서 자주 사용했던 forEach() 메소드는 스트림의 각 요소를 소모하여 명시된 동작을 수행합니다. 반환 타입이 void이므로 보통 스트림의 모든 요소를 출력하는 용도로 많이 사용합니다. 1234567Stream&lt;String&gt; stream = Stream.of(\"넷\",\"둘\",\"셋\",\"하나\");stream.forEach(System.out::println);// 결과넷둘셋하나 요소의 소모 스트림의 최종 연산은 모든 스트림의 각 요소를 소모하여 연산을 수행하게 됩니다. 하지만 reduce() 메소드는 첫 번째와 두 번째 요소를 가지고 연산을 수행한 뒤, 그 결과와 세 번째 요소를 가지고 또 다시 연산을 수행합니다. 이런 식으로 해당 스트림의 모든 요소를 소모하여 연산을 수행하고, 그 결과를 반환하게 됩니다. 또한, 인수로 초기값을 전달하면 초기값과 해당 스트림의 첫 번째 요소와 연산을 시작하며, 그 결과와 두 번째 요소를 가지고 계속해서 연산을 수행하게 됩니다. 다음 예제는 스트림의 각 문자열 요소를 “++” 기호로 연결하여 출력하는 예제입니다. 1234567891011121314151617181920package com.company;import java.util.Optional;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream1 = Stream.of(\"넷\", \"둘\", \"셋\", \"하나\"); Stream&lt;String&gt; stream2 = Stream.of(\"넷\", \"둘\", \"셋\", \"하나\"); Optional&lt;String&gt; result1 = stream1.reduce((s1, s2) -&gt; s1 + \"++\" + s2); result1.ifPresent(System.out::println); String result2 = stream2.reduce(\"시작\", (s1, s2) -&gt; s1 + \"++\" + s2); System.out.println(result2); &#125;&#125;// 결과넷++둘++셋++하나시작++넷++둘++셋++하나 위의 예제처럼 인수로 초기값을 전달하는 reduce() 메소드의 반환 타입은 Optional가 아닌 T 타입입니다. 그 이유는 비어 있는 스트림과 reduce 연산을 할 경우 전달받은 초기값을 그대로 반환해야 하기 때문입니다. Optional 클래스에 관한 내용은 아래에서 확인할 수 있습니다. 요소의 검색 findFirst()와 findAny() 메소드는 해당 스트림에서 첫 번째 요소를 참조하는 Optional 객체를 반환합니다. 두 메소드 모두 비어있는 스트림에서 비어있는 Optional 객체를 반환합니다. 다음 예제는 스트림의 모든 요소를 정렬한 후, 첫 번째에 위치한 요소를 출력하는 예제입니다. 12345678910111213141516171819import java.util.OptionalInt;import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream1 = IntStream.of(4, 2, 7, 3, 5, 1, 6); IntStream stream2 = IntStream.of(4, 2, 7, 3, 5, 1, 6); OptionalInt result1 = stream1.sorted().findFirst(); System.out.println(\"findFirst() 메소드의 결과 : \"+result1.getAsInt()); OptionalInt result2 = stream2.sorted().findAny(); System.out.println(\"findAny() 메소드의 결과 : \"+result2.getAsInt()); &#125;&#125;// 결과findFirst() 메소드의 결과 : 1findAny() 메소드의 결과 : 1 요소의 검사 해당 스트림의 요소 중에서 특정 조건을 만족하는 요소가 있는지, 아니면 모두 만족하거나 모두 만족하지 않는지를 다음 메소드를 사용하여 확인할 수 있습니다. anyMatch() : 해당 스트림의 일부 요소가 특정 조건을 만족할 경우에 true를 반환함. allMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족할 경우에 true를 반환함. noneMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족하지 않은 경우에 true를 반환함. 세 메소드 모두 인수로 Predicate 객체를 전달받으며, 요소의 검사 결과는 boolean값으로 반환합니다. 다음 예제는 스트림의 모든 요소를 검사하여 80보다 큰 값을 가지는 요소가 하나라도 존재하는지를 검사하는 예제입니다. 12345678910111213141516171819import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream1 = IntStream.of(30, 90, 70, 10); IntStream stream2 = IntStream.of(30, 90, 70, 10); // stream1의 요소 중 어느 하나라도 80보다 크면 true 반환 System.out.println(stream1.anyMatch(n -&gt; n &gt; 80)); // stream2의 요소 중 모든 요소가 80보다 크면 treu 반환 System.out.println(stream2.allMatch(n -&gt; n &gt; 80)); &#125;&#125;// 결과truefalse 요소의 통계, 연산 통계 count() : 해당 스트림의 요소의 총 개수를 long 타입의 값으로 반환합니다. max(), min() : 해당 스트림의 요소 중에서 가장 큰 값과 가장 작은 값을 가지는 요소를 참조하는 Optional 객체를 얻을 수 있습니다. 원하는 Int값을 얻기 위해서는 getAsInt() 메소드를 사용하면 Int 값을 얻을 수 있습니다. 연산 IntStream이나 DoubleStream과 같은 기본 타입 스트림에는 해당 스트림의 모든 요소에 대해 합과 평균을 구할 수 있는 sum()과 average() 메소드가 각각 정의되어 있습니다. 이때 average() 메소드는 각 기본 타입으로 래핑된 Optional 객체를 반환하므로, Int값을 얻기 위해서는 getAsInt() 메소드를 사용해서 얻을 수 있습니다. 1234567891011121314151617181920212223242526import java.util.stream.DoubleStream;import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream1 = IntStream.of(30, 90, 70, 10); IntStream stream2 = IntStream.of(30, 90, 70, 10); DoubleStream stream3 = DoubleStream.of(30.3, 90.9, 70.7, 10.1); IntStream stream4 = IntStream.of(30, 90, 70, 10); System.out.println(\"count() 메소드 호출 : \"+stream1.count()); System.out.println(\"min() 메소드 호출 : \"+stream2.min().getAsInt()); //System.out.println(stream2.max().getAsInt()); System.out.println(\"average() 메소드 호출 : \"+stream3.average().getAsDouble()); System.out.println(\"sum() 메소드 호출 : \"+stream4.sum()); &#125;&#125;//결과count() 메소드 호출 : 4min() 메소드 호출 : 10average() 메소드 호출 : 50.5sum() 메소드 호출 : 200 요소의 수집 collect() 메소드는 인수로 전달되는 Collectors 객체에 구현된 방법대로 스트림의 요소를 수집합니다. 또한, Collectors 클래스에는 미리 정의된 다양한 방법이 클래스 메소드로 정의되어 있습니다. 이 외에도 사용자가 직접 Collector 인터페이스를 구현하여 자신만의 수집 방법을 정의할 수도 있습니다. 스트림 요소의 수집 용도별 사용할 수 있는 Collectors 메소드는 다음과 같습니다. 스트림을 배열이나 컬렉션으로 변환 : toArray(), toCollection(), toList(), toSet(), toMap() 요소의 통계와 연산 메소드와 같은 동작을 수행 : counting(), maxBy(), minBy(), summingInt(), averagingInt() 등 요소의 소모와 같은 동작을 수행 : reducing(), joining() 요소의 그룹화와 분할 : groupingBy(), partitioningBy() 다음 예제는 collect() 메소드를 이용하여 해당 스트림을 리스트로 변환하는 예제입니다. 123456789101112131415161718192021222324package com.company;import java.util.Iterator;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"넷\",\"둘\",\"하나\",\"셋\"); List&lt;String&gt; list = stream.collect(Collectors.toList()); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; &#125;&#125;// 결과넷둘하나셋 다음 예제는 Collectors 클래스의 partitioningBy() 메소드를 이용하여 해당 스트림의 각 요소별 글자 수에 따라 홀수와 짝수로 나누어 저장하는 예제입니다. 12345678910111213141516171819202122232425262728293031import java.util.List;import java.util.Map;import java.util.stream.Collectors;import java.util.stream.Stream;public class streamExam &#123; public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of(\"HTML\", \"CSS\", \"JAVA\", \"PHP\"); Map&lt;Boolean, List&lt;String&gt;&gt; partition = stream.collect(Collectors.partitioningBy(s-&gt;(s.length() % 2) == 0)); // 문자열의 길이가 홀수인 List List&lt;String&gt; oddList = partition.get(false); System.out.println(oddList); // 문자열의 길이가 짝수인 Lists List&lt;String&gt; evenList = partition.get(true); System.out.println(evenList); System.out.println(partition); &#125;&#125;//결과[CSS, PHP][HTML, JAVA]&#123;false=[CSS, PHP], true=[HTML, JAVA]&#125; 대표적인 최종 연산 메소드 스트림 API에서 사용할 수 있는 대표적인 최종 연산을 위한 메소드는 다음과 같습니다. Optional 클래스 Optional 클래스는 Integer나 Double 클래스처럼 ‘T’ 타입의 객체를 포장해 주는 래퍼(Wrapper class)입니다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있습니다. 이러한 Optional 객체를 사용하면 예상치 못한 NullPointerException 예외를 제공되는 메소드로 간단히 회피할 수 있습니다. 즉, 복잡한 조건문 없이도 널(null) 값으로 인해 발생하는 예외를 처리할 수 있게 됩니다. Optional 객체의 생성 of() 메소드나 ofNullable() 메소드를 사용하여 Optional 객체를 생성할 수 있습니다. of() 메소드는 null이 아닌 명시된 값을 가지는 Optional 객체를 반환합니다. 만약 of() 메소드를 통해 생성된 Optional 객체에 null이 저장되면 NullPointerException 예외가 발생합니다. 따라서 만약 참조 변수의 값이 만에 하나 null이 될 가능성이 있다면, ofNullable() 메소드를 사용하여 Optional 객체를 생성하는 것이 좋습니다. ofNullable() 메소드는 명시된 값이 null이 아니면 명시된 값을 가지는 Optional 객체를 반환하며, 명시된 값이 null이면 비어있는 Optional 객체를 반환합니다. 1234567891011121314151617181920import java.util.Optional;public class streamExam &#123; public static void main(String[] args) &#123; Optional&lt;String&gt; opt = Optional.ofNullable(\"자바 공부 중\"); Optional&lt;String&gt; opt2 = Optional.ofNullable(null); System.out.println(opt); System.out.println(opt2); System.out.println(opt.get()); //System.out.println(opt2.get()); 에러발생 &#125;&#125;//결과Optional[자바 공부 중]Optional.empty자바 공부 중 Optional 객체에 접근 get() 메소드를 사용하면 Optional 객체에 저장된 값에 접근할 수 있습니다. 만약 Optional 객체에 저장된 값이 null이면, NoSuchElementException 예외가 발생합니다. 따라서 get() 메소드를 호출하기 전에 isPresent() 메소드를 사용하여 Optional 객체에 저장된 값이 null인지 아닌지를 먼저 확인한 후 호출하는 것이 좋습니다. 다음 예제는 isPresent() 메소드를 이용하여 좀 더 안전하게 Optional 객체에 저장된 값에 접근하는 예제입니다. 123456789101112131415import java.util.Optional;public class streamExam &#123; public static void main(String[] args) &#123; Optional&lt;String&gt; opt = Optional.ofNullable(\"자바 공부 중\"); if (opt.isPresent())&#123; System.out.println(opt.get()); &#125;else &#123; System.out.println(\"opt 객체는 null입니다.\"); &#125; &#125;&#125;// 결과자바 공부 중 또한, 아래와 같은 메소드를 사용하여 null 대신에 대체할 값을 지정할 수도 있습니다. orElse() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 값을 반환함. orElseGet() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결과값을 반환함. orElseThrow() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 예외를 발생시킴 123456789101112import java.util.Optional;public class streamExam &#123; public static void main(String[] args) &#123; Optional&lt;String&gt; opt = Optional.empty(); // Optional를 null로 초기화함. System.out.println(opt.orElse(\"빈 Optional 객체\")); System.out.println(opt.orElseGet(String::new)); &#125;&#125;//결과빈 Optional 객체 empty() 메소드는 Optional 객체를 null로 초기화해줍니다. 기본 타입의 Optional 클래스 자바에서는 IntStream 클래스와 같이 기본 타입 스트림을 위한 별도의 Optional 클래스를 제공하고 있습니다. OptionalInt 클래스 OptionalLong 클래스 OptionalDouble 클래스 이러한 클래스는 반환 타입이 Optional 타입이 아니라 해당 기본 타입이라는 사실만 제외하면 거의 모든 면에서 비슷합니다. 또한, Optional 객체에서 get() 메소드를 사용하여 저장된 값에 접근할 수 있는 것처럼 클래스별로 저장된 값에 접근할 수 있는 다음과 같은 메소드를 제공하고 있습니다. 클래스 저장된 값에 접근하는 메소드 Optional T get() OptionalInt int getAsInt() OptionalLong long getAsLong() OptionalDouble double getAsDouble() 123456789101112131415package com.company;import java.util.OptionalInt;import java.util.stream.IntStream;public class streamExam &#123; public static void main(String[] args) &#123; IntStream stream = IntStream.of(4, 2, 1, 3); OptionalInt result = stream.findFirst(); System.out.println(result.getAsInt()); &#125;&#125;//결과4 Optional 메소드","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 17. 람다표현식","slug":"java-basic-17","date":"2018-09-03T08:06:06.000Z","updated":"2020-04-22T07:47:50.589Z","comments":true,"path":"2018/09/03/java-basic-17/","link":"","permalink":"https://woovictory.github.io/2018/09/03/java-basic-17/","excerpt":"","text":"람다 표현식 람다 표현식(lambda expression)이란 간단히 말해서 메소드를 하나의 식으로 표현한 것을 말합니다. 기존의 메소드는 아래와 같이 작성합니다. 123int min(int x, int y)&#123; return x+y;&#125; 람다 표현식으로 위의 코드를 표현하면 아래와 같습니다. 12// 람다 표현식(x,y) -&gt; x &lt; y ? x : y; 위의 예제처럼 메소드를 람다 표현식으로 표혀하면, 클래스를 작성하고 객체를 생성하지 않아도 메소드를 사용할 수 있습니다. 그런데 자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다. 따라서 자바에서 람다 표현식은 익명 클래스와 같다고 할 수 있습니다. 123456789// 람다 표현식(x,y) -&gt; x &lt; y ? x : y;// 익명 클래스new Object()&#123; int min(int x, int y)&#123; return x &lt; y ? x : y; &#125;&#125; 이러한 람다 표현식은 메소드의 매개변수로 전달될 수도 있으며, 메소드의 결과값으로 반환될 수도 있습니다. 따라서 람다 표현식을 사용하면, 기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높여줍니다. Java SE 8부터는 이러한 람다 표현식을 사용하여 자바에서도 함수형 프로그래밍을 할 수 있게 되었습니다. 람다 표현식 작성 화살표( -&gt; ) 기호를 사용하여 람다 표현식을 작성할 수 있습니다. 1(매개변수 목록) -&gt; &#123; 함수 몸체 &#125; 자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다. 매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다. 매개변수가 하나인 경우에는 괄호 () 를 생략할 수 있습니다. 함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호 {} 를 생략할 수 있습니다. (이 때, 세미콜론(;)은 붙이지 않음) 함수의 몸체가 하나의 return문으로만 이루어진 경우에는 중괄호 {} 를 생략할 수 없습니다. return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결과값이 됩니다.(이때 세미콜론(;)은 붙이지 않음) 다음은 전통적인 방식의 스레드 생성과 람다 표현식을 사용한 스레드의 생성을 비교하는 코드입니다. 12345678910111213new Thread(new Runnable()&#123; public void run()&#123; System.out.println(\"전통적인 방식의 일회용 스레드 생성\") &#125;&#125;).start();new Thread(()-&gt;&#123; System.out.println(\"람다 표현식을 사용한 일회용 스레드 생성\")&#125;).start();// 결과전통적인 방식의 일회용 스레드 생성람다 표현식을 사용한 일회용 스레드 생성 람다 표현식을 사용하면 불피요한 코드를 줄일 수 있으며, 코드의 가독성이 훨씬 좋아집니다. 함수형 인터페이스(functional interface) 람다 표현식을 사용할 때는 람다 표현식을 저장하기 위한 참조 변수의 타입을 결정해야만 합니다. 12// 문법참조변수의타입 참조변수의이름 = 람다 표현식 위의 문법처럼 람다 표현식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입을 함수형 인터페이스라고 부릅니다. 함수형 인터페이스는 추상 클래스와는 달리 단 하나의 추상 메소드만을 가져야 합니다. 또한, 다음과 같은 어노테이션(annotation)을 사용하여 함수형 인터페이스임을 명시할 수 있습니다. 12// 문법@FunctionalInterface 위와 같은 어노테이션을 인터페이스의 선언 앞에 붙이면, 컴파일러는 해당 인터페이스를 함수형 인터페이스로 인식합니다. 자바 컴파일러는 이렇게 명시된 함수형 인터페이스에 두 개 이상의 메소드가 선언되면 오류를 발생시킵니다. 123456789101112131415@FunctionalInterfaceinterface Calc &#123; // 함수형 인터페이스의 선언 public int min(int x, int y);&#125;public class Lambda02 &#123;public static void main(String[] args)&#123; Calc minNum = (x, y) -&gt; x &lt; y ? x : y; // 추상 메소드의 구현 System.out.println(minNum.min(3, 4)); // 함수형 인터페이스의 사용 &#125;&#125;// 결과3 자바는 java.util.function 패키지를 통해 여러 상황에서 사용할 수 있는 다양한 함수형 인터페이스를 미리 정의하여 재공합니다. 메소드 참조 메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있도록 해줍니다. 메소드 참조를 사용하면 불필요한 매개변수를 제거하고 다음과 같이 ‘::’ 기호를 사용하여 표현할 수 있습니다. 1234// 문법클래스이름::메소드이름또는참조변수이름::메소드이름 다음 코드는 두 개의 값을 전달받아 제곱 연산을 수행하는 Math 클래스의 클래스 메소드인 pow() 메소드를 호출하는 람다 표현식입니다. 1234(base, exponent) -&gt; Math.pow(base, exponent);// 위의 식은 단순히 Math 클래스의 pow() 메소드로 인수를// 전달하는 역할만 하므로, 메소드 참조를 사용해 다음과 같이 표현 가능Math::pow; 또한, 특정 인스턴스의 메소드를 참조할 때에도 참조 변수의 이름을 통해 메소드 참조를 사용할 수 있습니다. 123MyClass obj = new MyClass;Function&lt;String, Boolean&gt; func = (a) -&gt; obj.equals(a); // 람다 표현식Function&lt;String, Boolean&gt; func = obj::equals(a); // 메소드 참조 다음 코드는 람다 표현식과 메소드 참조를 비교하는 코드입니다. 아래의 코드에서 차이를 확인할 수 있습니다. 12345678910DoubleUnaryOperator oper;oper = (n) -&gt; Math.abs(n); // 람다 표현식System.out.println(oper.applyAsDouble(-5));oper = Math::abs; // 메소드 참조System.out.println(oper.applyAsDouble(-5));//결과5.05.0 DoubleUnaryOperator 인터페이스는 한 개의 double 형 매개변수를 전달받아 한 개의 double 형 값을 반환하는 java.util.function 패키지에서 제공하는 함수형 인터페이스입니다. 생성자 참조 생성자를 호출하는 람다 표현식도 앞서 살펴본 메소드 참조를 이용할 수 있습니다. 즉, 단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환할 수 있습니다. 123(a) -&gt;&#123; return new Object(a);&#125; 위의 코드는 단순히 Object 클래스의 인스턴스를 생성하고 반환하기만 하므로, 생성자 참조를 사용하여 다음처럼 간단하게 표현할 수 있습니다. 1Object::new; 이때, 해당 생성자가 존재하지 않으면 컴파일 시 오류가 발생합니다. 또한, 배열을 생성할 때에도 다음과 같이 생성자 참조를 사용할 수 있습니다. 12345Function&lt;Integer, double[]&gt; func1 = a -&gt; new double[a];// 람다 표현식Function&lt;Integer, double[]&gt; func2 = double[]::new;// 생성자 참조","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 16. 스레드","slug":"java-basic-16","date":"2018-09-03T03:48:43.000Z","updated":"2020-04-22T07:47:52.177Z","comments":true,"path":"2018/09/03/java-basic-16/","link":"","permalink":"https://woovictory.github.io/2018/09/03/java-basic-16/","excerpt":"","text":"프로세스(process)란? 프로세스란 단순히 실행 중인 프로그램이라고 할 수 있습니다. 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다. 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다. 스레드(thread)란? 스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다. 스레드의 생성과 실행 자바에서 스레드를 생성하는 방법에는 다음과 같은 두 가지 방법이 있습니다. Runnable 인터페이스를 구현하는 방법 Thread 클래스를 상속받는 방법 두 방법 모두 스레드를 통해 작업하고 싶은 내용을 run()이라는 메소드에 작성하면 됩니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class threadExam &#123; public static void main(String[] args) &#123; ThreadWithClass thread1 = new ThreadWithClass(); Thread thread2 = new Thread(new ThreadWithRunnable()); // Runnable을 구현한 클래스는 Thread가 없기 때문에 Thread 타입으로 객체를 만들고 구현한 클래스를 // 생성자에 매개변수로 넣는다. thread1.start(); thread2.start(); &#125;&#125;// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함class ThreadWithRunnable implements Runnable &#123; @Override public void run() &#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(\"Runnable 인터페이스를 구현 : \"+Thread.currentThread().getName()); // 현재 실행 중인 스레드의 이름을 반환 try &#123; Thread.sleep(10); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;// Thread 클래스를 상속받아 Thread 구현class ThreadWithClass extends Thread&#123; public void run()&#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(\"Thread를 상속받아 구현 : \"+getName()); &#125; try&#123; Thread.sleep(10); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;// 결과Runnable 인터페이스를 구현 : Thread-1Thread를 상속받아 구현 : Thread-0Thread를 상속받아 구현 : Thread-0Thread를 상속받아 구현 : Thread-0Thread를 상속받아 구현 : Thread-0Thread를 상속받아 구현 : Thread-0Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-1 위의 결과를 보면, 생성된 스레드가 서로 번갈아가며 실행되고 있는 것을 확인할 수 있습니다. 스레드의 실행은 어떤 것이 먼저 실행되는 것인지 정해져 있지 않습니다. 그리고 Thread의 실행은 start()라는 메소드를 호출함으로써 실행시킬 수 있습니다. Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없으므로, 일반적으로 Runnable 인터페이스를 구현하는 방법으로 스레드를 생성합니다. Runnable 인터페이스는 몸체가 없는 메소드인 run() 메소드 단 하나만을 가지는 간단한 인터페이스입니다. 스레드 우선순위 자바에서 각 스레드는 우선순위(priority)에 관한 자신만의 필드를 가지고 있습니다. 이러한 우선순위에 따라 특정 스레드가 더 많은 시간 동안 작업을 할 수 있도록 설정할 수 있습니다. 필드 설명 static int MAX_PRIORITY 스레드가 가질 수 있는 최대 우선순위를 명시함. static int MIN_PRIORITY 스레드가 가질 수 있는 최소 우선순위를 명시함. static int NORM_PRIORITY 스레드가 생성될 때 가지는 기본 우선순위를 명시함. getPriority()와 setPriority() 메소드를 통해 스레드의 우선순위를 반환하거나 변경할 수 있습니다. 스레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, 숫자가 높을수록 우선순위 또한 높아집니다. 하지만 스레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐입니다. 우선순위가 10인 스레드가 우선순위가 1인 스레드보다 10배 더 빨리 수행되는 것이 아닙니다. 단지 우선순위가 10인 스레드는 우선순위가 1인 스레드보다 좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐입니다. 그리고 스레드의 우선순위는 해당 스레드를 생성한 스레드의 우선순위를 상속받게 됩니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class threadExam &#123; public static void main(String[] args) &#123; Thread thread1 = new Thread(new ThreadWithRunnable()); Thread thread2 = new Thread(new ThreadWithRunnable()); thread2.setPriority(10); // 1 : thread-1의 우선순위를 10으로 변경함 thread1.start(); // 2 : thread-0 실행 thread2.start(); // 3 : thread-1 실행 System.out.println(thread1.getPriority()); System.out.println(thread2.getPriority()); &#125;&#125;// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함class ThreadWithRunnable implements Runnable &#123; @Override public void run() &#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(\"Runnable 인터페이스를 구현 : \"+Thread.currentThread().getName()); // 현재 실행 중인 스레드의 이름을 반환 try &#123; Thread.sleep(10); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//결과510Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-0Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-0Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-0Runnable 인터페이스를 구현 : Thread-0Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-1Runnable 인터페이스를 구현 : Thread-0 main() 메소드를 실행하는 스레드의 우선순위는 언제나 5이므로, main() 메소드 내에서 생성된 스레드는 Thread-0의 우선순위는 5로 설정되는 것을 확인할 수 있습니다. 위의 코드에서 2번 라인에서 Thread-0이 먼저 실행되고, 3번 라인에서 Thread-1이 나중에 실행됩니다. 따라서 만약 1번 라인이 존재하지 않는다면, Thread-0이 먼저 실행되고, Thread-1이 나중에 실행될 것입니다. 하지만 1번 라인에서 Thread-1의 우선순위를 10으로 변경했기 때문에, Thread-1이 나중에 실행되었더라도 우선순위가 Thread-0보다 높아서 먼저 실행되는 것입니다. 멀티 스레드(multi thread) 스레드와 관련된 내용은 운영체제(OS)와 연관된 내용입니다. 그래서 여기에서는 간단하게 알아보고 추후에 운영체제 공부를 할 때 자세하게 포스팅하겠습니다. :) 일반적으로 하나의 프로세스는 하나의 스레드를 가지고 작업을 수행하게 됩니다. 하지만 멀티 스레드(multi trhead)란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다. 또한, 멀티 프로세스(multi process)는 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미합니다. 멀티 스레드와 멀티 프로세스 모두 여러 흐름을 동시에 수행한다는 공통점을 가지고 있습니다. 멀티 프로세스는 각 프로세스가 독립적인 메모리를 가지고 별도로 실행되지만, 멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유한다는 점이 다릅니다. 멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적습니다. 또한, 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아집니다. 문맥 교환(context switching) 컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어(core) 수와 같습니다. 만약 CPU의 코어 수보다 더 많은 스레드가 실행되면, 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행하게 됩니다. 이 때, 각 스레드가 서로 교체될 때 스레드 간의 문맥 교환(context switching)이라는 것이 발생합니다. 문맥 교환이란 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업을 가리킵니다. 이러한 문맥 교환에 걸리는 시간이 커지면 커질수록, 멀티 스레딩의 효율은 저하됩니다. 오히여 많은 양의 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있습니다. 따라서 많은 수의 스레드를 실행하는 것이 언제나 좋은 성능을 보이는 것은 아니라는 점을 유의해야 합니다. 스레드 그룹(thread group) 스레드 그룹(thread group)이란 서로 관련이 있는 스레드를 하나의 그룹으로 묶어 다루기 위한 장치입니다. 자바에서는 스레드 그룹을 다루기 위해 ThreadGroup라는 클래스를 제공합니다. 이러한 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이렇게 포함된 스레드 그룹은 트리 형태로 연결됩니다. 이 때, 스레드는 자신이 포함된 스레드나 그 하위 그룹에는 접근할 수 있지만 다른 그룹에는 접근할 수 없습니다. 이렇게 스레드 그룹은 스레드가 접근할 수 있는 범위를 제한하는 보안상으로도 중요한 역할을 하고 있습니다. 12345678910111213141516171819202122232425262728293031323334public class threadGroupExam &#123; public static void main(String[] args)&#123; Thread thread0 = new Thread(new ThreadWithRunnable()); thread0.start(); // thread-0 실행 System.out.println(thread0.getThreadGroup()); ThreadGroup threadGroup = new ThreadGroup(\"MyThread\"); // MyThread라는 스레드 그룹 생성 threadGroup.setMaxPriority(7); // 해당 스레드 그룹의 최대 우선순위를 7로 설정함 Thread thread1 = new Thread(threadGroup, new ThreadWithRunnable()); // 스레드를 생성할 때 포함될 스레드 그룹을 전달할 수 있다. thread1.start(); // thread-1 실행 System.out.println(thread1.getThreadGroup()); &#125;&#125;// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함class ThreadWithRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;//결과java.lang.ThreadGroup[name=main,maxpri=10]java.lang.ThreadGroup[name=MyThread,maxpri=7] 위의 코드처럼 main() 메소드에서 생성된 스레드의 기본 스레드 그룹의 이름은 main이 되며, 최대 우선순위는 10으로 자동 설정됩니다. 데몬 스레드(deamon thread) 데몬 스레드(deamo thread)란 다른 일반 스레드의 작업을 돕는 보조적인 역할을 하는 스레드를 가리킵니다. 따라서 데몬 스레드는 일반 스레드가 모두 종료되면 더는 할 일이 없으므로, 데몬 스레드 역시 자동으로 종료됩니다. 데몬 스레드의 생성 방법과 실행 방법은 모두 일반 스레드와 같습니다. 단, 실행하기 전에 setDaemon() 메소드를 호출하여 데몬 스레드로 설정하기만 하면 됩니다. 123456789101112131415161718192021public class threadGroupExam &#123; public static void main(String[] args)&#123; Thread thread0 = new Thread(new ThreadWithRunnable()); thread0.setDaemon(true); // 데몬 스레드로 설정 &#125;&#125;// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함class ThreadWithRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 이러한 데몬 스레드는 일정 시간마다 자동으로 수행되는 저장 및 화면 갱신 등에 이용되고 있습니다. 가비지 컬렉터(garbage collector) 가비지 컬렉터는 자바에서 중요한 개념으로 알고 있습니다. 이 부분에 대한 심화된 내용은 별도의 포스트에서 소개할 예정이고, 이번에는 간단하게 알고 넘어가도록 하겠습니다. 데몬 스레드를 이용하는 가장 대표적인 예로 가비지 컬렉터(garbage collector)를 들 수 있습니다. 가비지 컬렉터(garbage collector)란 프로그래머가 동적으로 할당한 메모리 중 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제해 주는 데몬 스레드입니다. 자바에서는 프로그래머가 메모리에 직접 접근하지 못하게 하는 대신에 가비지 컬렉터가 자동으로 메모리를 관리해 줍니다. 이러한 가비지 컬렉터를 이용하면 프로그래밍을 하기가 훨씬 쉬워지며, 메모리에 관련된 버그가 발생할 확률도 낮아집니다. 보통 가비지 컬렉터가 동작하는 동안에는 프로세서가 일시적으로 중지되므로, 필연적으로 성능의 저하가 발생합니다. 하지만 요즘에는 가비지 컬렉터의 성능이 많이 향상되어, 새롭게 만들어지는 대부분의 프로그래밍 언어에서 가비지 컬렉터를 제공하고 있습니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 15. 입력과 출력","slug":"java-basic-15","date":"2018-09-03T01:51:33.000Z","updated":"2020-04-22T07:47:53.668Z","comments":true,"path":"2018/09/03/java-basic-15/","link":"","permalink":"https://woovictory.github.io/2018/09/03/java-basic-15/","excerpt":"","text":"스트림 자바에서는 파일이나 콘솔의 입출력을 직접 다루지 않고, 스트림(stream)이라는 흐름을 통해 다룹니다. 스트림(stream)이란 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름을 의미합니다. 즉, 스트림은 운영체제에 의해 생성되는 가상의 연결고리를 의미하며, 중간 매개자 역할을 합니다. Java SE 8 버전부터 추가된 스트림 API는 앞서 설명한 스트림과는 전혀 다른 개념입니다. 스트림 API는 추후에 포스팅할 예정입니다. ^0^ 입출력 스트림 스트림은 한 방향으로만 통신할 수 있으므로, 입력과 출력을 동시에 처리할 수는 없습니다. 따라서 스트림은 사용 목적에 따라 입력 스트림과 출력 스트림으로 구분됩니다. 자바에서는 java.io 패키지를 통해 InputStream과 OutputStream 클래스를 별도로 제공하고 있습니다. 즉, 자바에서의 스트림 생성이란 이러한 스트림 클래스 타입의 인스턴스를 생성한다는 의미입니다. InputStream 클래스에는 read() 메소드가, OutputStream 클래스에는 write() 메소드가 각각 추상 메소드로 포함되어 있습니다. 사용자는 이 두 메소드를 상황에 맞게 적절히 구현해야만 입출력 스트림을 생성하여 사용할 수 있습니다. read() 메소드는 해당 입력 스트림에서 더 이상 읽어들일 바이트가 없으면 -1을 반환해야 합니다. 그런데 반환 타입을 byte 타입으로 하면 0 ~ 255까지의 바이트 정보는 표현할 수 있지만 -1은 표현할 수 없게 됩니다. 따라서 InputStream의 read() 메소드는 반환 타입을 int형으로 선언하고 있습니다. 바이트 기반 스트림 자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 자바에서는 아래와 같이 다양한 바이트 기반의 입출력 스트림을 제공하고 있습니다. 입력 스트림 출력 스트림 입출력 대상 FileInputStream FileOutputStream 파일 ByteArrayInputStream ByteArrayOutputStream 메모리 PipedInputStream PipedOutputStream 프로세스 AudioInputStream AudioOutputStream 오디오 장치 보조 스트림 자바에서 제공하는 보조 스트림은 실제로 데이터를 주고 받을 수는 없지만, 다른 스트림의 기능을 향상시키거나 새로운 기능을 추가해 주는 스트림입니다. 자바에서는 아래와 같은 다양한 보조 스트림을 제공하고 있습니다. 입력 스트림 출력 스트림 설명 FilterInputStream FilterOutputStream 필터를 이용한 입출력 BufferedInputStream BufferedOutputStream 버퍼를 이용한 입출력 DataInputStream DataOutputStream 입출력 스트림으로부터 자바의 기본 타입으로 데이터를 읽어올 수 있게함. ObjectInputStream ObjectOutputStream 데이터를 객체 단위로 읽거나, 읽어 들인 객체를 역직렬화시킴 SequenceInputStream X 두 개의 입력 스트림을 논리적으로 연결함. PushbackInputStream X 다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함. X PrintStream 다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함. 문자 기반 스트림 자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 하지만 자바에서 가장 작은 타입인 char 형이 2바이트이므로, 1바이트씩 전송되는 바이트 기반 스트림으로는 원활한 처리가 힘든 경우가 있습니다. 따라서 자바에서는 바이트 기반 스트림뿐만 아니라 문자 기반의 스트림도 별도로 제공합니다. 이러한 문자 기반 스트림은 기존의 바이트 기반 스트림에서 InputStream을 Reader로, OutputStream을 Writer로 변경하면 사용할 수 있습니다. 다음은 다양한 문자 기반의 입출력 스트림을 보여주고 있습니다. 입력 스트림 출력 스트림 입출력 대상 FileReader FileWriter 파일 CharArrayReader CharArrayWriter 메모리 PipedReader PipedWriter 프로세스 StringReader StringWriter 오디오 장치 지금까지 살펴본 바이트 기반의 스트림과 문자 기반의 스트림은 활용 방법이 거의 같습니다. 따라서 문자 기반의 보조 스트림도 다음과 같이 제공됩니다. 입력 스트림 출력 스트림 설명 FilterReader FilterWriter 필터를 이용한 입출력 BufferedReader BufferedWriter 버퍼를 이용한 입출력 PushbackReader X 다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함. X PrintWriter 다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함. 표준 입출력 자바에서는 콘솔과 같은 입출력 장치를 위해 System이라는 표준 입출력 클래스를 정의하고 있습니다. java.lang 패키지에 포함되어 있는 System 클래스는 표준 입출력을 위해 다음과 같은 클래스 변수를 제공합니다. 클래스 변수 입출력 스트림 설명 System.in InputStream 콘솔로부터 데이터를 입력받는다. System.out PrintStream 콘솔로 데이터를 출력한다. System.err PrintStream 콘솔로 데이터를 출력한다.(에러를 출력) 표준 입출력 스트림은 자바가 자동으로 생성하므로, 개발자인 우리가 별도로 스트림을 생성하지 않아도 사용할 수 있습니다. &gt;__&lt; 표준 입출력의 대상 변경 앞서 살펴본 세 가지 입출력 스트림은 모두 콘솔과 같은 표준 입출력 장치를 대상으로 합니다. 하지만 이와 같은 스트림에 다음 System 메소드를 사용하면 스트림의 대상을 다른 입출력 장치로 변경할 수 있습니다. 메소드 설명 static void setIn(InputStream in) 입력 스트림의 대상을 전달된 입력 스트림으로 변경함. static void setOut(PrintStream out) 출력 스트림의 대상을 전달된 출력 스트림으로 변경함. static void setErr(PrintStream err) 출력 스트림의 대상을 전달된 출력 스트림으로 변경함. RandomAccessFile 클래스 앞서 살펴본 다양한 입출력 스트림을 이용하면 파일에 순차적으로 입출력 작업을 수행할 수 있습니다. 하지만 순차적인 접근이 아닌 임의의 지점에 접근하여 작업을 수행하고 싶다면, RandomAccessFile 클래스를 사용하면 됩니다. 이 클래스는 파일만을 대상으로 하며, 임의의 지점에서 입출력을 동시에 수행할 수 있습니다. RandomAccessFile 클래스의 생성자에는 인수로 파일의 이름뿐만 아니라 파일 모드까지 함께 전달해야 합니다. 파일 모드란 파일의 사용 용도를 나타내는 문자열로, 자바에서 사용할 수 있는 대표적인 파일 모드는 다음과 같습니다. 파일 모드 설명 “r” 파일을 오로지 읽는 것만 가능한 모드로 개방함. “rw” 파일을 읽고 쓰는 것이 모두 가능한 모드로 개방함. 만약 파일이 없으면 새로운 파일을 생성함. 12345678910111213141516171819202122public static void main(String[] args)&#123; try &#123; // \"rw\" 모드로 \"data.txt\" 파일을 개방함. RandomAccessFile file = new RandomAccessFile(\"data.txt\", \"rw\"); System.out.println(file.getFilePointer()); // 0 : 파일 포인터의 현재 위치를 반환함. file.writeInt(10);// 정수 10을 저장함. System.out.println(file.getFilePointer()); // 4 file.seek(20); // 파일 포인터의 위치를 20으로 이동시킴. System.out.println(file.getFilePointer()); // 20 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;//결과0420 getFilePointer() : 파일 포인터의 현재 위치를 확인할 수 있다. seek() : 파일 포인터의 위치를 변경할 수 있다. File 클래스 앞서 살펴본 입출력 스트림을 사용하면 파일을 통한 입출력 작업을 수행할 수 있습니다. 하지만 파일의 제거나 디렉터리에 관한 작업 등은 입출력 스트림을 통해서는 수행할 수 없습니다. 자바는 이러한 입출력 작업 이외의 파일과 디렉터리에 관한 작업을 File 클래스를 통해 처리하도록 하고 있습니다. File 클래스에는 다음과 같은 다양한 메소드가 정의되어 있습니다. 12345678910111213141516public static void main(String[] args)&#123; File dir = new File(\"D:\\\\data\"); // 디렉토리 생성 File file = new File(dir, \"data.txt\"); // 위에서 생성한 디렉토리에 파일 생성 if(!file.exists())&#123; System.out.println(\"파일이 존재하지 않습니다.\"); System.out(0); &#125; System.out.pirntln(file.getPath()); // 파일의 경로 반환 : D:\\data\\data.txt System.out.println(file.length()); // 파일의 크기를 반환함&#125;// 결과D:\\data\\data.txt0","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 14. 예외 처리","slug":"java-basic-14","date":"2018-09-02T02:02:54.000Z","updated":"2020-04-22T07:47:55.906Z","comments":true,"path":"2018/09/02/java-basic-14/","link":"","permalink":"https://woovictory.github.io/2018/09/02/java-basic-14/","excerpt":"","text":"오류(error)와 예외(exception) 자바 프로그램을 작성할 때 자바 문법에 맞지 않게 코드를 작성하고 컴파일하려고 하면 자바 컴파일러는 문법 오류(syntax error)를 발생시킵니다. 또한, 자바 문법에는 맞게 작성되었다 하더라도 프로그램이 실행되면서 예상하지 못한 오류가 발생할 수 있습니다. 이렇게 컴퓨터 시스템이 동작하는 도중에 예상하지 못한 사태가 발생하여 실행 중인 프로그램이 영향을 받는 것을 오류(error)와 예외(exception) 두 가지로 구분할 수 있습니다. 코드를 작성하는 과정에서 예기치 못한 수많은 에러들이 발생합니다. 예를 들면 다음과 같습니다. 컴파일 전에 알게 되는 에러도 있고, 작성할 때는 아무 문제 없다가 실행시키고 나서야 발생하는 에러들이 있습니다. 이것들을 제어할 수 있어야 좀 더 안전한 프로그램을 설계할 수 있습니다. 에러(error)? 예외(exception)? 컴파일 에러 - 컴파일 시에 발생하는 에러 런타임 에러 - 실행 시에 발생하는 에러 논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 에러 그럼 위에서 말하는 컴파일, 런타임은 무엇이면 컴파일 에러는 무엇일까요?? 공부를 하다보니 들어본 적은 있지만, 정확하게 무엇이라고 설명하기에는 부족한 부분들이 있어서 아래에 정리해봤습니다. 컴파일 에러 : 주로 문법상의 오류가 많습니다. (빨간 줄이 나타나는 에러와 같은 경우입니다. 대부분의 IDE들이 빨간줄 표시로 잡아줍니다.) 컴파일 에러가 발생하는 경우는 주로 오타, 중괄호의 짝이 맞지 않는 경우, 중복된 변수명 등의 원인이 있을 수 있습니다. RunTime : 어떤 프로그램이 실행되는 동안의 Time을 의미하며, runtime error는 어떤 프로그램이 실행되는 동안 발생하는 에러입니다. 런타임 에러 : 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 경우, 대표적인 경우가 NullpointerException Compile Time : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정이라고 하며, compile error는 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정에서 발생하는 에러입니다. 즉, 컴파일 에러가 발생하지 않더라도 런타임 에러가 발생할 수 있습니다. 오류(error) **오류(error)**는 시스템 레벨에서 프로그램에 심각한 문제를 야기하여 실행 중인 프로그램을 종료시킵니다. 이러한 오류는 개발자가 미리 예측하여 처리할 수 없는 것이 대부분이므로, 오류에 대한 처리는 할 수 없습니다. (ex. 메모리 부족, 스택 오버플로우와 같이 발생하면 복구할 수 없는.) 예외(exception) **예외(exception)**는 오류와 마찬가지로 실행 중인 프로그램을 비정상적으로 종료시키지만, 발생할 수 있는 상황을 미리 예측하여 처리할 수 있습니다. 따라서 개발자는 예외 처리(Exception handling)를 통해 예외 상황을 처리할 수 있도록 코드의 흐름을 바꿀 필요가 있습니다. (발생하더라도 수습될 수 있는, 비교적 덜 심각한. 그렇기에 프로그램의 비정상적인 종료를 사전에 예방할 수 있음.) 예외처리(exception handling) 자바에서 예외 처리는 이 Exception을 Handling하는 것을 말합니다. 프로그램을 제작하는 과정에서 발생할 예외에 대해 미리 코드를 작성하는 것입니다. if-else문으로 처리를 해야만 했던, C에서는 예외 처리를 위한 if문과 일반 if문을 구분하기 힘들었습니다. 이 문제를 해결하기 위해 Java에서는 예외 처리에 특화된 문법을 제공합니다. 그것이 바로 try-catch문입니다. 사용하는 방법과 코드에 대한 설명은 아래와 같습니다. 1234567891011121314try&#123;// 예외를 발생시킬 위험을 갖고 있는 코드(로직)// 이 로직은 예외 상황과 관련있는 문장들도 고려해야 합니다.&#125;catch(Exception e1)&#123;// 예외가 발생했을 때 실행되는 로직// Exception클래스는 모든 예외의 상위 클래스&#125;catch(e2)&#123;&#125;...finally&#123;// 예외 발생 여부와 상관없이 무조건 실행될 코드&#125; 위의 코드에서 보면 예외를 발생시킬 위험을 갖고 있는 코드인 경우 try{ } 블록 안에 넣어둡니다. 그리고 catch를 통해 오류 메시지를 출력합니다. try안에 있는 코드를 실행하다가 오류가 발생하면 catch 구문으로 Jump합니다. Jump : 오류가 발생한 구문 다음의 코드는 실행되지 않는다. 그러면 catch 메소드가 실행되게 되는데, 이 때 Exception이라는 클래스를 e로 인스턴스화하여 catch에 매개변수로 전달합니다. 그리고 Exception 이라는 클래스에 있던 getMessage라는 메소드를 호출하거나 다른 구문을 실행합니다. 다음은 예외가 발생했을 때 실행되는 로직의 예입니다. Sysetm.out.println(e.getMessage()); -&gt; 가장 간단한 예외 상황을 출력 Sysetm.out.println(e.toString()); -&gt; 예외 상황에 대한 좀 더 자세한 정보를 출력 e.printStackTrace(); -&gt; 예외 상황이 발생한 소스코드의 위치까지 출력 그리고 위의 코드처럼 catch 구문을 여러 개 두어서 다중 catch도 가능합니다. catch 블록과 finally 블록은 선택적인 옵션으로 반드시 사용할 필요는 없습니다. 따라서 사용할 수 있는 모든 적합한 try 구문은 다음과 같습니다. 1231. try / catch2. try / finally3. try / catch / ... / finally 다른 제어문과 달리 예외 처리문은 중괄호를 생략할 수 없습니다. 예외처리 메커니즘 자바에서 예외 처리는 아래의 그림과 순서로 진행됩니다. try 블록에 도달한 프로그램의 제어는 try 블록 내의 코드를 실행합니다. 이 때 만약 예외가 발생(throw)하지 않고, finally 블록이 존재하면 프로그램의 제어는 바로 finally 블록으로 이동합니다. try 블로에서 예외가 발생하면 catch 구문으로 Jump하게 되고, catch 핸들러는 다음과 같은 순서로 적절한 catch 블록을 찾게 됩니다. 스택에서 try 블록과 가장 가까운 catch 블록부터 차례대로 검사합니다. 만약 적절한 catch 블록을 찾지 못하면, 바로 다음 바깥쪽 try 블록 다음에 위치한 catch 블록을 차례대로 검사합니다. 이러한 과정을 가장 바깥쪽의 try 블록까지 계속 검사하게 됩니다. 그래도 적절한 catch 블록을 찾지 못하면, 예외는 처리되지 못합니다. 만약 적절한 catch 블록을 찾게 되면, throw 문의 피연산자는 예외 객체의 형식 매개변수로 전달됩니다. 모든 예외 처리가 끝나면 프로그램의 제어는 finally 블록으로 이동합니다.(finally 블록이 있다면) finally 블록이 모두 처리되면, 프로그램의 제어는 예외 처리문 바로 다음으로 이동합니다. 만약 1번 try 블록에서 예외가 발생하지 않고, 바깥쪽 try 블록에서도 예외가 발생하지 않으면, 6번 finally 블록이 바로 실행될 것입니다. 하지만, 1번 try 블록에서 예외가 발생하면 2번과 3번 catch 블록에서 해당 예외를 처리할 수 있는지 검사하게 됩니다. 만약 적절한 catch 블록을 처리하지 못하면, 바깥쪽 4,5번 catch 블록도 차례대로 검사하게 됩니다. 이 때 해당 예외를 처리할 수 있는 catch 블록을 찾게 되면, 해당 catch 블록을 실행한 후 6번의 finally 블록을 실행합니다. 하지만 모든 catch 블록이 해당 예외를 처리할 수 없으면, 예외는 처리되지 못한채 해당 프로그램을 강제 종료될 것입니다. Exception 클래스 자바에서 모든 예외의 조상 클래스가 되는 Exception 클래스는 크게 다음과 같이 구분할 수 있습니다. RuntimeException 클래스 그 외의 Exception 클래스의 자식 클래스 RuntimeException 클래스를 상속받는 자식 클래스들은 주로 치명적인 예외 상황을 발생시키지 않는 예외들로 구성됩니다. 따라서 try / catch 문을 사용하기보다는 프로그램을 작성하면서 예외가 발생하지 않도록 주의를 기울이는 편이 좋습니다. 하지만 그 외의 Exception 클래스에 속하는 자식 클래스들은 치명적인 예외 상황을 발생시키므로, 반드시 try / catch문을 사용하여 예외를 처리해야만 합니다. 따라서 자바 컴파일러는 RuntimeException 클래스 이외의 Exception 클래스의 자식 클래스에 속하는 예외가 발생할 가능성이 있는 구문에는 반드시 예외를 처리하도록 강제하고 있습니다. 만약 이러한 예외가 발생할 가능성이 있는 구문을 처리하지 않았을 때는 컴파일 시 오류를 발생시킵니다. 다음 예제는 PrintStream 클래스의 write() 메소드를 사용하여 byte 타입 배열의 모든 요소를 출력하는 예제입니다. 하지만 write() 메소드에서 발생할 수 있는 IOException에 대한 예외를 처리하지 않았으므로, 컴파일 시 오류가 발생합니다. 따라서 try / catch문을 사용하여 IOException에 대한 예외 처리까지 해주어야만 컴파일 할 수 있습니다. 12345678import java.io.IOException;public class ExceptionExam &#123; public static void main(String[] args) throws IOException &#123; byte[] list = &#123;1,3,2&#125;; System.out.write(list); &#125;&#125; 예외 처리의 계층 관계 자바에서는 예외가 발생하면, try 블록과 가장 가까운 catch 블록부터 순서대로 검사합니다. 따라서 여러 개의 catch 블록을 사용할 때는 Exception 클래스의 계층 관계에도 주의를 기울여야만 합니다. 12345678910111213try &#123; System.out.write(list);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 위의 예제에서 IOException이 발생하면, 자바는 첫 번째 catch 블록부터 순서대로 해당 예외를 처리할 수 있는지를 검사합니다. 그런데 IOException은 Exception 클래스의 자식 클래스이므로, 첫 번째 catch 블록에서도 IOException을 처리할 수 있습니다. 따라서 IOException을 비롯한 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면, 언제나 첫 번째 catch 블록에서만 처리될 것입니다. 즉, catch 블록의 순서를 위의 코드처럼 작성하면, 두 번째 catch 블록은 영원히 실행되지 않을 것입니다. 따라서, IOException만을 따로 처리하고자 한다면, 다음과 같이 catch 블록의 순서를 변경해야 합니다. 1234567891011121314try &#123; System.out.write(list);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;catch (Exception e) &#123; e.printStackTrace();&#125; 이렇게 변경하면 IOException이 발생하면, 첫 번째 catch 블록에서 해당 예외를 처리할 것입니다. 또한, IOException 이외의 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면 두 번째 catch 블록에서 처리될 것입니다. 이처럼 범위가 더 좁은 예외를 처리하는 catch 블록을 먼저 명시하고, 범위가 더 넓은 예외를 처리하는 catch 블록은 나중에 명시해야만 정상적으로 해당 예외를 처리할 수 있습니다. 여러 예외 타입의 동시 처리 Java SE 7 부터는 ‘|’ 기호를 사용하여 하나의 catch 블록에서 여러 타입의 예외를 동시에 처리할 수 있습니다. 12345678910111213try &#123; this.db.commit();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; 위와 같이 일반적으로 작성하던 catch 블록을 아래와 같이 동시에 처리할 수 있습니다. 123456789try &#123; this.db.commit();&#125; catch (IOException | SQLException e) &#123; e.printStackTrace();&#125; 하지만, 둘 이상의 예외 타입을 동시에 처리하는 catch 블록에서 매개변수로 전달받은 예외 객체는 묵시적으로 final 제어자를 가지게 됩니다. 따라서 catch 블록 내에서 해당 매개변수에는 어떠한 값도 대입할 수 없습니다.(상수화가 되었기 때문) Throwable 클래스 자바에서 Throwable 클래스는 모든 예외의 조상이 되는 Exception 클래스와 모든 오류의 조상이 되는 Error 클래스의 부모 클래스입니다. Throwable 타입과 이 클래스를 상속받은 서브 타입만이 자바 가상 머신(JVM)이나 throw 키워드에 의해 던져질 수 있습니다. 이 클래스에는 예외나 오류에 관한 다양한 정보를 확인할 수 있는 다음과 같은 메소드가 포함되어 있습니다. String getMessage() : 해당 throwable 객체에 대한 자세한 내용을 문자열로 반환함 vodi printStackTree() : 해당 throwable 객체와 표준 오류 스트림(standard error stream)에서 해당 객체의 스택 트레이스를 출력함 String toString() : 해당 throwable 객체에 대한 간략한 내용을 문자열로 반환함 다음 예제는 일부로 숫자를 0으로 나눠서 ArithmeticException 오류를 발생시키는 예제입니다. 이렇게 발생한 오류에 대해서 Throwable 메소드를 사용하여 발생한 오류에 대한 정보를 출력합니다. 12345678910111213141516package com.company;import java.io.IOException;public class ExceptionExam &#123; public static void main(String[] args)&#123; try&#123; System.out.println(5/0); &#125;catch (ArithmeticException e)&#123; e.printStackTrace(); &#125; &#125;&#125;// 결과현재 발생한 예외의 정보 : / by zero 자주 사용되는 예외 클래스 자바에서 자주 사용되는 예외 클래스는 다음의 표와 같습니다. 예외 발생 및 회피 자바에서는 throw 키워드를 사용하여 강제로 예외를 발생시킬 수 있습니다. 123Exception e = new Exeption(\"메시지\");throw e; 예외 회피하기 예외 처리에 대한 부분에서 가장 헷갈리는 부분이 throw와 throws입니다. throw 예외를 발생시키는 것이고, 예외를 던지는 것입니다. 메소드 내에서 상위 블록으로 예외를 던지는 것 억지로 에러를 발생시킬 때도 사용되지만 현재 메소드의 에러를 처리한 후에 상위 메소드에 에러 정보를 줌으로써 상위 메소드에서도 에러가 발생한 것을 감지할 수 있습니다. 실제로 exception을 throw할 때 사용하는 키워드 throw는 강제로 예외를 발생시키는 것 123456789101112131415161718public class ExceptionExam &#123; static void handlingException() &#123; try &#123; throw new Exception(); &#125; catch (Exception e) &#123; System.out.println(\"호출된 메소드에서 예외가 처리됨!\"); &#125; &#125; public static void main(String[] args) &#123; try &#123; handlingException(); &#125; catch (Exception e) &#123; System.out.println(\"main() 메소드에서 예외가 처리됨!\"); &#125; &#125;&#125;// 결과호출된 메소드에서 예외가 처리됨! Main 함수에서 handlingException() 함수를 호출하고 그 함수 안에서는 throw 키워드를 사용하여 예외를 발생시키고 있습니다. 이 예외를 발생시키는 문장을 try / catch로 감싸고 있기 때문에 발생한 예외는 catch 블록으로 Jump하게 되고 함수 내에서 예외를 처리하게 됩니다. throws 메소드나 생성자를 수행할 때 발생하는 Exception을 선언할 때 사용하는 키워드 예외를 던지는 것 현재 메소드에서 상위 메소드로 예외를 던집니다. 다시 말해, 에외를 자신이 직접 처리하지 않고, 자신을 호출한 메소드에세 책임을 전가하는 것입니다. 123456789101112131415public class Exception04 &#123; static void handlingException() throws Exception &#123; throw new Exception(); &#125; public static void main(String[] args) &#123; try &#123; handlingException(); &#125; catch (Exception e) &#123; System.out.println(\"main() 메소드에서 예외가 처리됨!\"); &#125; &#125;&#125;// 결과main() 메소드에서 예외가 처리됨! 위의 코드는 throws를 사용하여 handlingException() 함수에서 발생한 예외를 전가시키는 예제입니다. 메소드를 정의할 때 throws 키워드를 추가하여 이 메소드를 호출하는 곳에서 예외 처리를 하도록 전가시킬 수 있습니다. handlingException() throws Exception 라는 문장을 해석해보자면, handlingException()라는 함수가 Exception 예외를 던진다는 뜻이므로 handlingException() 함수를 사용하는 곳(혹은 호출하는 곳)으로 예외를 던집니다. 여기서는 Main 함수에서 handlingException() 함수를 호출하였고 handlingException() 함수는 이 함수를 호출한 곳으로 예외를 던지기 때문에 Main 함수에서 예외를 처리해주어야 합니다. 하지만, 예외가 발생할 수 있기 때문에 앞에서 배운 에외 처리를 통해서 함수를 호출하는 문장을 try 블록으로 감싸줍니다. 그러면 여기서 예외가 발생하면 아래의 catch 블록으로 빠지게 되고, 결국에는 Main 함수에서 예외를 처리하게 됩니다. 사용자 정의 예외 클래스 자바에서는 Exception 클래스를 상속받아 자신만의 새로운 예외 클래스를 정의하여 사용할 수 있습니다. 사용자 정의 예외 클래스에는 생성자뿐 아니라 필드 및 메소드도 원하는 만큼 추가할 수 있습니다. 12345class MyException extends RuntimeException&#123; MyException(String errMsg)&#123; super(errMsg); &#125;&#125; 요즘에는 위와 같이 Exception 클래스가 아닌 예외 처리를 강제하지 않는 RuntimeException 클래스를 상속받아 작성하는 경우가 많습니다. try-with-resources문 Java SE 7 부터는 사용자 자원을 자동으로 해제해주는 try-with-resources 문을 사용할 수 있습니다. 123try(파일을 열거나 자원을 할당하는 명령문)&#123; ...&#125; 위와 같이 try 블록에 괄호 () 를 추가하여 파일을 열거나 자원을 할당하늠 명령문을 명시하면, 해당 try 블록이 끝나자마자 자동으로 파일을 닫거나 할당된 자원을 해제해줍니다. 다음은 파일에서 문자열을 한 줄 읽어오는 예제입니다. 123456789static String readFile(String filePath) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(filePath)); try &#123; return br.readLine(); &#125; finally &#123; if (br != null) br.close(); &#125;&#125; 위와 같이 Java SE 7 이전에서는 finally 블록을 사용하여 사용한 파일을 닫아줘야 했습니다. 하지만 try-with-resources 문을 사용하면 다음과 같이 자동으로 파일의 닫기를 수행할 수 있습니다. 12345static String readFile(String filePath) throws IOException &#123; try (BufferedReader br = new BufferedReader(new FileReader(filePath))) &#123; return br.readLine(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 13. 제네릭","slug":"java-basic-13","date":"2018-08-27T00:51:07.000Z","updated":"2020-04-22T07:47:58.100Z","comments":true,"path":"2018/08/27/java-basic-13/","link":"","permalink":"https://woovictory.github.io/2018/08/27/java-basic-13/","excerpt":"","text":"제네릭(Generic) 자바에서 제네릭(Generic)이란 데이터의 타입(data type)을 일반화(generalize)한다는 것을 의미합니다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다. 이렇게 컴파일 시에 미리 타입 검사(type check)를 수행하면 다음과 같은 장점을 가집니다. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다. 반환값에 대한 타입 변환 및 검사에 들어가는 노력을 줄일 수 있습니다. JDK 1.5 이전에서는 여러 타입을 사용하는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object 타입을 사용했습니다. 하지만 이 경우에는 반환된 Object 객체를 다시 원하는 타입으로 타입 변환해야 하며, 이 때 오류가 발생할 가능성도 존재합니다. 하지만, JDK 1.5부터 도입된 제네릭을 사용하면 컴파일 시에 미리 타입이 정해지므로, 타입 검사나 타입 변환과 같은 번거로운 작업을 생략할 수 있게 됩니다. 제네릭의 선언 및 생성 12345678910111213class Person&lt;T&gt;&#123; T info; void setInfo(T info)&#123; this.info = info; &#125; T getInfo()&#123; return info; &#125;&#125;Person&lt;Integer&gt; person1 = new Person&lt;Integer&gt;();Person&lt;String&gt; person2 = new Person&lt;String&gt;(); T를 타입 변수(type variable)이라고 하며, 임의의 참조형 타입을 의미합니다. 꼭 T뿐만 아니라 어떠한 문자를 사용해도 상관없으며, 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있습니다. 위의 코드처럼 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로도 사용할 수 있습니다. T를 인스턴스화할 때, 꺽쇠 안에 있는 데이터 타입이 적용됩니다. 제네릭을 이용하여 클래스를 하나 정의하게 되면 클래스에서 정의한 변수에 대해 다양한 데이터 타입으로 인스턴스를 생성할 수 있습니다. 즉, 사용자 데이터 타입인 것입니다. 제네릭이 없는 상황의 코드에서는 코드의 중복이 발생할 수 있는데, 이 때 구현이 비슷한 두 클래스를 하나로 합칠 수가 있습니다. 변수의 데이터 타입을 지정하는 것은 그변수에 그 형식의 데이터 타입만 올 것이라는 것을 보장받을 수 있습니다. 그런데 Object로 처리를 하게 되면 어떠한 데이터도 들어올 수가 있습니다. 이것을 타입이 안전하지 않다라고 합니다. Javascript, Ruby on Rails 등에서는 타입 안전성에 대해서 free 합니다. 이런 언어를 typeless language라고 합니다. 또한, 제네릭으로는 참조형 데이터 타입만 올 수 있습니다. 기본 데이터 타입은 올 수 없습니다.(ex. int, char, double …) 하지만, Wrapper class를 사용해서 기본 데이터 타입을 객체처럼 만들어서 사용할 수 있습니다. 그런 클래스를 Wrapper class라고 합니다. 또한, Java SE 7부터 인스턴스 생성 시 타입을 추정할 수 있는 경우에는 다음과 같이 타입을 생략할 수 있습니다. 1Person&lt;Integer&gt; person1 = new Person&lt;&gt;(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.ArrayList;public class generics &#123; public static void main(String[] args) &#123; AnimalList&lt;LandAnimal&gt; animalAnimalList = new AnimalList&lt;&gt;(); animalAnimalList.add(new LandAnimal()); animalAnimalList.add(new cat()); animalAnimalList.add(new dog()); //animalAnimalList.add(new Sparrow()); 오류 발생 for(int i=0;i&lt;animalAnimalList.size();i++)&#123; animalAnimalList.get(i).crying(); &#125; &#125;&#125;class LandAnimal &#123; public void crying() &#123; System.out.println(\"육지 동물\"); &#125;&#125;class cat extends LandAnimal &#123; public void crying() &#123; System.out.println(\"냐옹냐옹\"); &#125;&#125;class dog extends LandAnimal &#123; public void crying() &#123; System.out.println(\"멍멍~~\"); &#125;&#125;class Sparrow &#123; public void crying() &#123; System.out.println(\"짹\"); &#125;&#125;class AnimalList&lt;T&gt; &#123; ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;(); void add(T animal) &#123; al.add(animal); &#125; T get(int index) &#123; return al.get(index); &#125; boolean remove(T animal) &#123; return al.remove(animal); &#125; int size() &#123; return al.size(); &#125;&#125;// 결과육지 동물냐옹냐옹멍멍~~ 위의 코드처럼 cat과 dog 클래스는 LandAnimal 클래스를 상속받는 자식 클래스이므로, AnimalList에 추가할 수 있습니다. 하지만 Sparrow 클래스는 타입이 다르므로 추가할 수 없습니다. 제네릭의 제거 시기 자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환됩니다. 그리고서 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 됩니다. 이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서입니다. 타입 변수의 제한 제네릭은 T와 같은 타입 변수(type variable)를 사용하여 타입을 제한합니다. 이 때, extends 키워드를 사용하면 타입 변수에 특정 타입만을 사용하도록 제한할 수 있습니다. 123456예시interface WarmBlood&#123; ... &#125;class AnimalList&lt;T extends LandAnimal&gt; &#123; ... &#125;class AnimalList&lt;T extends WarmBlood&gt; &#123; ... &#125;class AnimalList&lt;T extends LandAnimal &amp; WramBlood&gt;&#123; ... &#125;// implements 키워드를 사용해서는 안됨 위와 같이 클래스의 타입 변수에 제한을 걸어 놓으면 클래스 내부에서 사용된 모든 타입 변수에 제한이 걸립니다. 이 때에는 클래스가 아닌 인터페이스를 구현할 경우에도 implements 키워드가 아닌 extends 키워드를 사용해야만 합니다. 또한 클래스와 인터페이스를 동시에 상속받고 구현해야 한다면 마지막 코드처럼 &amp;기호를 사용하면 됩니다. 이 기호는 앰퍼센트라고 읽습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.ArrayList;public class generics &#123; public static void main(String[] args) &#123; AnimalList&lt;LandAnimal&gt; animalList1 = new AnimalList&lt;&gt;(); // 1 AnimalList&lt;cat&gt; animalList2 = new AnimalList&lt;&gt;(); // 2 AnimalList&lt;dog&gt; animalList = new AnimalList&lt;&gt;(); // 3 // AnimalList&lt;Sparrow&gt; animalList3 = new AnimalList&lt;Sparrow&gt;(); 4 animalList1.add(new LandAnimal()); animalList1.add(new cat()); animalList1.add(new dog()); //animalAnimalList.add(new Sparrow()); for(int i=0;i&lt;animalList1.size();i++)&#123; animalList1.get(i).crying(); &#125; &#125;&#125;class LandAnimal &#123; public void crying() &#123; System.out.println(\"육지 동물\"); &#125;&#125;class cat extends LandAnimal &#123; public void crying() &#123; System.out.println(\"냐옹냐옹\"); &#125;&#125;class dog extends LandAnimal &#123; public void crying() &#123; System.out.println(\"멍멍~~\"); &#125;&#125;class Sparrow &#123; public void crying() &#123; System.out.println(\"짹\"); &#125;&#125;class AnimalList&lt;T extends LandAnimal&gt; &#123; ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;(); void add(T animal) &#123; al.add(animal); &#125; T get(int index) &#123; return al.get(index); &#125; boolean remove(T animal) &#123; return al.remove(animal); &#125; int size() &#123; return al.size(); &#125;&#125; 위와 같이 타입 제한을 ’ AnimalList ’ 걸게 되면 타입 변수에는 1번 처럼 LandAnimal 타입만 사용할 수 있도록 제한할 수 있습니다. 또한, 2,3번 처럼 LandAnimal을 상속한 자식 클래스까지도 사용할 수 있습니다. 하지만, 4번처럼 그 외의 클래스는 타입으로 사용할 수 없습니다. 만약 타입 변수를 제한하지 않는다면, 4번에서도 클래스를 정상적으로 사용할 수 있습니다. 제네릭 메소드 제네릭 메소드(generic method)란 메소드의 선언부에 타입 변수를 사용한 메소드를 의미합니다. 이 때 타입 변수의 선언은 메소드의 선언부에서 반환 타입 바로 앞에 위치합니다. 1public static &lt;T&gt; void sort()&#123; ... &#125; 다음 코드에서 제네릭 클래스에서 정의된 타입 변수 T와 제네릭 메소드에서 사용된 타입 변수 T는 전혀 별개의 것임을 주의해야 합니다. 12345678class AnimalList&lt;T&gt;&#123; ... public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comp)&#123; ... &#125; ...&#125; 와일드 카드의 사용 와일드 카드(wild card)란 이름에 제한을 두지 않음을 표현하는 데 사용되는 기호를 의미합니다. 자바의 제네릭에서는 물음표(?) 기호를 사용하여 이러한 와일드카드를 사용할 수 있습니다. 1234문법&lt;?&gt; // 타입 변수에 모든 타입을 사용할 수 있음&lt;? extends T&gt; // T 타입과 T 타입을 상속받는 자식 클래스 타입만을 사용할 수 있음&lt;? super T&gt; // T 타입과 T 타입이 상속받은 조상 클래스 타입만을 사용할 수 있음 다음은 클래스 메소드인 cryingAnimalList() 메소드의 매개변수의 타입을 와일드카드를 사용하여 제한하는 코드입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.ArrayList;public class generics &#123; public static void main(String[] args) &#123; AnimalList&lt;cat&gt; catList = new AnimalList&lt;&gt;(); catList.add(new cat()); AnimalList&lt;dog&gt; dogList = new AnimalList&lt;&gt;(); dogList.add(new dog()); AnimalList&lt;Sparrow&gt; sparrowList = new AnimalList&lt;&gt;(); AnimalList.cryingAnimalList(catList); AnimalList.cryingAnimalList(dogList); //AnimalList.cryingAnimalList(sparrowList); 오류 &#125; &#125;class AnimalList&lt;T&gt; &#123; ArrayList&lt;T&gt; al = new ArrayList&lt;T&gt;(); public static void cryingAnimalList(AnimalList&lt;? extends LandAnimal&gt; al) &#123; LandAnimal la = al.get(0); la.crying(); &#125; void add(T animal) &#123; al.add(animal);&#125; T get(int index) &#123;return al.get(index);&#125; boolean remove(T animal) &#123;return al.remove(animal);&#125; int size() &#123;return al.size();&#125;&#125;class LandAnimal &#123; public void crying() &#123; System.out.println(\"육지 동물\"); &#125;&#125;class cat extends LandAnimal &#123; public void crying() &#123; System.out.println(\"냐옹냐옹\"); &#125;&#125;class dog extends LandAnimal &#123; public void crying() &#123; System.out.println(\"멍멍~~\"); &#125;&#125;class Sparrow &#123; public void crying() &#123; System.out.println(\"짹\"); &#125;&#125;// 결과냐옹냐옹멍멍~~ 클래스 메소드인 cryingAniamlList() 메소드가 매개변수의 타입을 와일드카드를 사용하여 제한했습니다. 따라서 LandAnimal 타입과 그 타입을 상속받는 자식 클래스의 타입만 접근할 수 있기 때문에 4번은 오류가 발생하는 것입니다. 와일드카드를 사용한 타입 제한을 제거한다면 4번도 정상적으로 동작하게 됩니다. 정리 제네릭은 제한도 걸어놓을 수 있다고 합니다. 하지만, 지금은 이해가 가지 않네요… 조금 더 공부하다 보면 많은 내용을 알고 자료를 찾아가다 보면 이해가 되겠지요? ㅎㅎ 상위 클래스를 만들어 준다. or 인터페이스를 만들어준다. 그리고 그 상위의 것에 extends 해준다. (상속과는 다르다) just 부모가 누구냐만 밝혀주는 용도로 extends를 사용한다. (인터페이스의 경우에도 extends를 사용한다. 따로 implements라는 표현을 사용하지 않는다.) Tip &gt; super 부모를 제한하는 경우 제네릭은 같은 기능을 하는 클래스를 여러 개 정의해야 한다는 불편함을 해소하면서 이것을 해소하기 위해 Object를 사용하게 되면 원하는 자료형에 대한 타입 변환을 해야 하고 또한, 안전성이 보장되지 않기 때문에 사용하는 것입니다. 변수와 비슷한 개념인데도 값이 들어가는게 아니라 데이터 타입이 들어가는 것입니다. 그렇다면 왜 제네릭을 알아야 하는가?? 앞으로 공부하게 될 컬렉션 프레임워크를 이애하기 위해 제네릭에 대한 이해가 필요합니다. Collection Framework에서 제네릭을 사용합니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"Android :: 깨알 팁","slug":"android-tip","date":"2018-08-22T08:31:58.000Z","updated":"2020-03-01T10:26:56.177Z","comments":true,"path":"2018/08/22/android-tip/","link":"","permalink":"https://woovictory.github.io/2018/08/22/android-tip/","excerpt":"","text":"오늘은 안드로이드 스튜디오를 사용하면서 자신이 작성한 코드임을 명시할 수 있는 팁을 알려드리고자 합니다. :) Github에서 다른 사람이 작성한 코드를 참고해서 개발을 하는 경우가 많습니다. 저는 그렇게 하는데 다른 분들은 어떻게 하시는지…??ㅎㅎㅎ 아무튼!!! 다음과 같은 문장을 본 적이 있을 것입니다. 이 문장은 아무것도 아닌 것 같지만, 이렇게 명시함으로써 누가 코드를 작성했는지 알 수 있게 해줍니다. 다른 사람이랑 협업할 때 누가 작성한 코드인지 명확하게 볼 수 있어서 편리하다고 생각합니다. ㅎㅎㅎ 설정 방법 안드로이드 스튜디오 File Settings Editor File and Code Templates를 선택합니다. 그리고 Includes 탭에 들어가면 아래와 같은 모습을 볼 수 있습니다. 그러면 + 버튼을 클릭해서 Lee와 같은 파일을 하나 생성합니다. 그리고 주석을 생성하고 그 안에 자신의 이름이나 자신이 원하는 문구를 작성합니다. 파일을 작성하고 Files 탭으로 넘어가서 아래 그림과 같이 위에서 만든 파일의 이름을 넣습니다. 그리고 Apply 버튼을 누르고 새 파일을 생성하면 문구가 자동으로 들어가는 것을 확인할 수 있습니다. 이 방법 말고도 File Header를 수정하는 방법이 있습니다. 이것은 아래와 같은 방식으로 수정하면 됩니다. ^0^ 123/** * Created by $&#123;USER&#125; on $&#123;DATE&#125;. */ 별 내용은 아니지만, 혹시나 이런 것이 궁금하신 분들이 계실거 같아서 생각 난 김에 포스팅하고 갑니다~","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Tip","slug":"Tip","permalink":"https://woovictory.github.io/tags/Tip/"}]},{"title":"[Java] 12. API 클래스-2","slug":"java-basic-12","date":"2018-08-21T02:44:33.000Z","updated":"2020-04-22T07:47:59.900Z","comments":true,"path":"2018/08/21/java-basic-12/","link":"","permalink":"https://woovictory.github.io/2018/08/21/java-basic-12/","excerpt":"","text":"Wrapper 클래스 프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있습니다. 예를 들어, 메소드의 인수로 객체 타입만이 요구된다면, 기본 타입의 데이터를 그대로 사용할 수는 없습니다. 이 때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 합니다. 이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 래퍼 클래스(Wrapper class)라고 합니다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공됩니다. 래퍼 클래스 중에서 Integer 클래스와 Character 클래스만이 자신의 기본 타입과 이름이 다름을 주의해야 합니다. 박싱과 언박싱 래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있습니다. 위의 그림과 같이 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정을 박싱(Boxing)이라고 합니다. 반면 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정은 언박싱(UnBoxing)이라고 합니다. 오토 박싱과 오토 언박싱 JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해 줍니다. 이렇게 자동화된 박싱과 언박싱을 오토 박싱(AutoBoxing)과 오토 언방식(AutonUnBoxing)이라고 부릅니다. 12345678910111213141516public class Exam &#123; public static void main(String[] args) &#123; Integer num1 = new Integer(10); // 박싱 int number1 = num1; // 언박싱 System.out.println(number1); Character ch = 'X'; // Character ch = new Character('X'); :오토박싱 char c = ch; // char c = ch.charValue(); :오토 언박싱 System.out.println(c); &#125;&#125;// 결과10X 위 예제에서 볼 수 있듯이 래퍼 클래스인 Integer 클래스와 Character 클래스에는 각각 언박싱을 위한 intValue() 메소드와 charValue() 메소드가 포함되어 있습니다. 또한, 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 Character 인스턴스를 생성할 수 있습니다. 반대로 charValue() 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있습니다. 12345678910111213141516171819202122232425public class Exam &#123; public static void main(String[] args) &#123; Integer num1 = new Integer(7); // 박싱 Integer num2 = new Integer(3); // 박싱 int int1 = num1.intValue(); // 언박싱 int int2 = num2.intValue(); // 언박싱 Integer result1 = num1 + num2; // 1번 : 10 Integer result2 = int1 - int2; // 2번 : 4 int result3 = num1 * int2; // 3번 : 21 System.out.println(result1); System.out.println(result2); System.out.println(result3); &#125;&#125;// 결과10421 1번 : Integer 객체로 박싱된 객체들을 더하는 연산을 진행하고 있습니다. 하지만, 래퍼 클래스 타입의 객체들은 산술을 위해 정의된 클래스가 아니라고 했습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값을 참조할 수 있습니다. 따라서 산술 연산을 위해서 자바 컴파일러에 의해서 오토 언박싱되고, 산술 연산을 수행한 후의 결과 값인 10을 다시 오토 박싱하여 result1에 결과를 담게 됩니다. 2번 : 이미 언박싱 과정을 통해서 산술 연산이 가능해졌습니다. 따라서 두 값의 산술 연산을 진행한 후의 결과 값인 4를 오토 박싱하여 result2에 결과를 담게 됩니다. 3번 : 래퍼 클래스 타입의 객체와 기본형 타입인 int형 변수의 산술 연산입니다. 이를 위해서는 num1이 자동으로 오토 언박싱 되어서 산술 연산을 할 수 있도록 변환됩니다. 그리고 나서 산술 연산을 진행하고, 결과 값을 int형 변수인 result3에 담게 됩니다. 123456789101112131415161718192021public class Exam &#123; public static void main(String[] args) &#123; Integer num1 = new Integer(10); // 박싱 Integer num2 = new Integer(20); // 박싱 Integer num3 = new Integer(10); System.out.println(num1&lt;num2); // 1 System.out.println(num1 == num3); // 2 System.out.println(num1.equals(num3)); // 3 int n1 = num1; int n3 = num3; System.out.println(n1 == n3); // 4 &#125;&#125;// 결과truefalsetruetrue 래퍼 클래스의 비교 연산도 오토 언박싱을 통해 가능하지만, 인스턴스에 저장된 값의 동등 여부 판단은 1번 라인처럼 비교 연산자인 동등 연산자( == )를 사용해서는 안되며, 2번 라인처럼 equals() 메소드를 사용해야만 합니다. 래퍼 클래스도 객체이므로 동등 연산자(==)를 사용하게 되면, 두 인스턴스의 값을 비교하는 것이 아니라 두 인스턴스의 주소값을 비교하게 됩니다. 따라서 서로 다른 두 인스턴스를 동등 연산자로 비교하게 되면, 언제나 false 값을 반환하게 됩니다. 그러므로 인스턴스에 저장된 값의 동등 여부를 정확히 판단하려면 equals() 메소드를 사용해야만 합니다. num1과 num2에 들어있는 래퍼 클래스 타입의 객체 즉, 인스턴스는 서로 다른 주소값을 가지고 있지만 그 주소에 들어있는 값은 동일합니다. 이를 int형 변수인 n1과 n2에 각각 오토 언박싱을 하고 동등 연산자를 통해 비교해보면 true 값을 반환하는 것을 확인할 수 있습니다. 이유는 인스턴스를 오토 언박싱을 통해서 기본 타입으로 변환했기 때문에 동등 연산자를 통해 비교해보면 같은 값임을 확인할 수 있습니다. Enum 클래스 C언어와 C++에서는 열거체를 사용할 수 있지만, JDK 1.5 이전의 자바에서는 열거체를 사용할 수 없었습니다. 하지만,JDK 1.5부터는 C언어의 열거체보다 더욱 향상된 성능의 열거체를 정의한 Enum 클래스를 사용할 수 있습니다. 이와 같은 자바의 열거체는 다음과 같은 장점을 가집니다. 열거체를 비교할 때 실제 값 뿐만 아니라 타입까지도 체크합니다. 열거체의 상숫값이 재정의되더라도 다시 컴파일할 필요가 없습니다. 열거체의 정의 및 사용 자바에서는 enum 키워드를 사용하여 열거체를 정의할 수 있습니다. 123456enum 열거체이름&#123; 상수1이름, 상수2이름 ...&#125;enum Rainbow&#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO&#125;// 사용 방법열거체이름.상수이름Rainbow.RED 열거체의 상숫값 정의 및 추가 위와 같이 정의된 열거체의 첫 번째 상숫값은 0부터 설정되며, 그 다음은 바로 앞의 상숫값보다 1만큼 증가되며 설정됩니다. 또한, 불규칙한 값을 상숫값으로 설정하고 싶으면 상수의 이름 옆에 괄호 (())을 추가하고, 그 안에 원하는 상숫값을 명시할 수 있습니다. 하지만, 이 때에는 불규칙한 특정 값을 저장할 수 있는 인스턴스 변ㅅ와 생성자를 다음과 같이 추가해야 합니다. 1234567891011121314151617181920212223public class Exam &#123; public static void main(String[] args) &#123; System.out.println(\"상수값 : \"+Rainbow.RED.getValue()); // 1 System.out.println(\"상수값 : \"+Rainbow2.RED.ordinal()); // 2 &#125; enum Rainbow &#123; RED(3), ORANGE(10), YELLOW(11), GREEN(23), BLUE(4), INDIGO(5), VIOLET(17); private int value; Rainbow(int value) &#123; this.value = value; &#125; public int getValue()&#123; return this.value; &#125; &#125; enum Type&#123; WALKING, RUNNING, HIKING &#125;&#125;// 결과상수값 : 3상수값 : 0 1을 보면 불규칙한 상숫값을 설정하고 이 불규칙한 특정 값을 저장할 수 있는 인스턴스 변수와 생성자를 추가함으로써 상수값에 접근할 수 있습니다. 또한 2번에서는 상수값을 지정하지 않으면 첫 번째 상수값은 0부터 설정되어 순서대로 설정되므로 이 값에 접근하기 위해서는 ordinal() 메소드를 통해 접근할 수 있습니다. java.lang.Enum 클래스 Enum 클래스는 모든 자바 열거체의 공통된 조상 클래스입니다. Enum 클래스에는 열거체를 조작하기 위한 다양한 메소드가 포함되어 있습니다. values() 메소드 values() 메소드는 해당 열거체의 모든 상수를 저장한 배열을 생성하여 반환합니다. 이 메소드는 자바의 모든 열거체에 컴파일러가 자동으로 추가해 주는 메소드입니다. 12345678910111213141516171819public class Exam &#123; public static void main(String[] args) &#123; Rainbow2[] arr = Rainbow2.values(); for (Rainbow2 rb : arr) &#123; System.out.println(rb); &#125; &#125; enum Rainbow2 &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO &#125;&#125;// 결과REDORANGEYELLOWGREENBLUEINDIGO valueOf() 메소드 valueOf() 메소드는 전달된 문자열과 일치하는 해당 열거체의 상수를 반환합니다. 12345678910public class Exam &#123; public static void main(String[] args) &#123; System.out.println(Rainbow2.valueOf(\"RED\")); &#125; enum Rainbow2 &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO &#125;&#125;// 결과RED ordinal() 메소드 ordinal() 메소드는 해당 열거체 상수가 열거체 정의에서 정의된 순서 (0부터 시작)를 반환합니다. 이 때, 반환되는 값은 열거체 정의에서 해당 열거체 상수가 정의된 순서이며, 상수값 자체가 아님을 명심해야 합니다. 12345678910enum Rainbow &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET &#125;public class Exam &#123; public static void main(String[] args) &#123; int idx = Rainbow.YELLOW.ordinal(); System.out.println(idx); &#125;&#125;// 결과2 다음 예제는 불규칙적인 상수값을 가지는 열거체에서 ordinal()메소드를 사용한 예제입니다. 12345678910111213141516171819202122232425public class Exam &#123; public static void main(String[] args) &#123; System.out.println(Rainbow.YELLOW.ordinal()); &#125; enum Rainbow &#123; RED(3), ORANGE(10), YELLOW(11), GREEN(23), BLUE(4), INDIGO(5), VIOLET(17); private int value; Rainbow(int value) &#123; this.value = value; &#125; public int getValue() &#123; return this.value; &#125; &#125;&#125;// 결과2 대표적인 Enum 메소드 Arrays 클래스 Arrays 클래스를 다루기 전에 먼저 살펴보아야 할 것은 java.util 패키지입니다. java.util 패키지에는 프로그램을 개발하는 데 사용할 수 있는 유용한 유틸리티 클래스가 다수 포함되어 있습니다. 실제로 java.lang 패키지 다음으로 가장 많이 사용되는 패키지가 java.util 패키지입니다. 하지만, import문을 사용하지 않아도 바로 사용할 수 있는 java.lang 패키지와는 달리 java.util 패키지는 import문으로 패키지를 불러오고 나서야 클래스 이름만으로 사용할 수 있습니다. java.util.Arrays 클래스 Arrays 클래스에는 배열을 다루기 위한 다양한 메소드가 포함되어 있습니다. Arrays 클래스의 모든 메소드는 클래스 메소드 (static method)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이 클래스는 반드시 import문으로 java.util 패키지를 불러오고 나서 사용해야 합니다. binarySearch() 메소드 binarySearch() 메소드는 전달받은 배열에서 특정 객체의 위치를 이진 검색 알고리즘을 사용하여 검색한 후, 해당 위치를 반환합니다. 이 메소드는 이진 검색 알고리즘을 사용하므로, 매개변수로 전달되는 배열이 sort() 메소드 등을 사용하여 미리 정렬되어 있어야만 제대로 동작합니다. 123456789101112public class Exam &#123; public static void main(String[] args) &#123; int[] arr = new int[1000]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; System.out.println(Arrays.binarySearch(arr, 437)); &#125;&#125;// 결과437 copyOf() 메소드 copyOf() 메소드는 전달받은 배열의 특정 길이만큼을 새로운 배열로 복사하여 반환합니다. copyOf() 메소드는 첫 번째 매개변수로 원본 배열을 전달받고, 두 번째 매개변수로 원본 배열에서 새로운 배열로 복사할 요소의 개수를 전달받습니다. 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다. 이 때, 새로운 배열의 길이가 원본 배열보다 길면, 나머지 요소는 배열 요소의 타입에 맞게 기본값으로 채워지게 됩니다. 1234567891011121314151617181920import java.util.Arrays;public class Exam &#123; public static void main(String[] args) &#123; int[] arr1 = &#123;1, 2, 3, 4, 5&#125;; int[] arr2 = Arrays.copyOf(arr1, 3); // 1 for (int i : arr2) &#123; System.out.print(i + \" \"); &#125; System.out.println(); int[] arr3 = Arrays.copyOf(arr1, 10); // 2 for (int j : arr3) &#123; System.out.print(j + \" \"); &#125; &#125;&#125;// 결과1 2 3 1 2 3 4 5 0 0 0 0 0 1번에서는 copyOf() 메소드를 사용하여 배열 arr1의 첫 번째 배열 요소부터 3개의 요소를 복사하여 배열 arr2에 대입하고 있습니다. 2번에서는 배열 arr1에서 10개의 배열 요소를 복사하여 배열 arr3에 대입하려고 합니다. 하지만, 배열 arr1의 길이가 5밖에 되지 않으므로, 배열 arr3의 나머지 배열 요소에는 int형의 기본 값인 0이 채워지게 됩니다. copyOfRange() 메소드 copyOfRange() 메소드는 전달받은 배열의 특정 범위에 해당하는 요소만을 새로운 배열로 복사하여 반환합니다. copyOfRange() 메소드는 첫 번째 매개변수로 복사의 대상이 될 원본 배열을 전달받습니다. 두 번째 매개변수로 원본 배열에서 복사할 시작 인덱스를 전달받고, 세 번째 매개변수로는 마지막으로 복사될 배열 요소의 다음 인덱스를 전달받습니다. 즉, 세 번째 매개변수로 전달된 인덱스 바로 전까지의 배열 요소까지만 복사됩니다. 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다. 123456789101112131415161718192021import java.util.Arrays;public class Exam &#123; public static void main(String[] args) &#123; int[] arr1 = &#123;1, 2, 3, 4, 5&#125;; int[] arr2 = Arrays.copyOfRange(arr1, 2, 4); for (int i : arr2) &#123; System.out.print(i + \" \"); &#125; System.out.println(); System.out.println(\"아래는 원본 배열\"); for (int j : arr1) &#123; System.out.print(j + \" \"); &#125; &#125;&#125;// 결과3 4아래는 원본 배열1 2 3 4 5 위와 같이 배열이 복사되는 것을 확인할 수 있고, 원본 배열이 변경되는 것이 아니라 원본 배열을 가지고 새로운 배열을 복사하는 것이기 때문에 원본 배열은 변경되지 않습니다. fill() 메소드 fill() 메소드는 전달받은 배열의 모든 요소를 특정 값으로 초기화해줍니다. fill() 메소드는 첫 번째 매개변수로 초기화할 배열을 전달 받고, 두 번째 매개변수로 초기값을 전달받습니다. 따라서 이 메소드는 전달받은 원본 배열의 값을 변경하게 됩니다. 1234567891011121314151617181920212223import java.util.Arrays;public class Exam &#123; public static void main(String[] args) &#123; int[] arr1 = &#123;1, 2, 3, 4, 5&#125;; System.out.println(\"원본 배열\"); for (int i:arr1) &#123; System.out.print(i+\" \"); &#125; System.out.println(); System.out.println(\"fill() 메소드 사용 후 원본 배열\"); Arrays.fill(arr1, 10); for (int i:arr1) &#123; System.out.print(i+\" \"); &#125; &#125;&#125;// 결과원본 배열1 2 3 4 5 fill() 메소드 사용 후 원본 배열10 10 10 10 10 sort() 메소드 sort() 메소드는 전달받은 배열의 모든 요소를 오름차순으로 정렬합니다. sort() 메소드는 매개변수로 정렬한 배열을 전달받으며, 따라서 이 메소드는 전달받은 원본 배열의 순서를 변경하게 됩니다. 12345678910111213141516171819202122import java.util.Arrays;public class Exam &#123; public static void main(String[] args) &#123; int[] arr1 = &#123;5,2,3,1,4&#125;; System.out.println(\"원본 배열\"); for (int i:arr1) &#123; System.out.print(i+\" \"); &#125; System.out.println(); System.out.println(\"sort() 메소드 사용 후 원본 배열\"); Arrays.sort(arr1); for (int i:arr1) &#123; System.out.print(i+\" \"); &#125; &#125;&#125;// 결과원본 배열5 2 3 1 4 sort() 메소드 사용 후 원본 배열1 2 3 4 5 대표적인 Arrays 메소드 Arrays 클래스의 메소드는 매우 다양하며, 그 중에서 많이 사용되는 메소드는 다음과 같습니다. Calendar 클래스 자바에서의 날짜 및 시간 처리 JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 간단한 처리만을 수행할 수 있었습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(deprecated) 있습니다. JDk 1.1부터는 새롭게 제공되는 Calendar 클래스를 이용하여 날짜와 시간에 관한 처리를 수행하게 됩니다. 하지만 이러한 Calendar 클래스는 다음과 같은 문제점을 안고 있습니다. Calendar 인스턴스는 불변 객체가 아니라서 값이 수정될 수 있습니다. 윤초(leap second)와 같은 특별한 상황을 고려하지 않았습니다. Calendar 클래스에서는 월(month)을 나타낼 때, 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다. 따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러를 함께 사용해왔습니다. Java SE 8 버전에서는 이러한 Joda-Time 라이브러리르 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 패키지를 포함하고 있습니다. 더 자세한 내용을 추후에 공부하겠습니다. :D java.util.Calendar 클래스 Calendar 클래스는 자바에서 날짜와 시간에 관한 데이터를 손쉽게 처리할 수 있도록 제공하는 추상 클래스입니다. 이 클래스가 추상 클래스로 선언된 이유는 나라마다 사용하는 달력 체계가 조금씩 다를 수 있기 때문입니다. 이러한 Calendar 클래스에는 날짜와 시간을 처리하기 위한 다양한 필드와 메소드가 포함되어 있습니다. Calendar 클래스의 모든 필드는 클래스 변수(static variable)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. java.util.GregorianCalendar 클래스 현재 전 세계적으로 가장 많이 사용되는 달력은 1582년 교황 그레고리오 13세가 개혁한 그레고리오 달력입니다. Calendar 클래스는 추상 클래스이므로, 직접 인스턴스를 생성할 수 없습니다. GregorianCalendar 클래스는 이러한 Calendar 클래스를 상속받아 그레고리오 달력을 완전히 구현한 하위 클래스입니다. add() 메소드 add() 메소드는 전달된 Calendar 필드에서 일정 시간 만큼을 더하거나 빼줍니다. 즉, 특정 시간을 기준으로 일정 시간 전후의 날짜와 시간을 알 수 있습니다. 아래는 현재 시각에 1시간을 더하는 예제입니다.:) 123456789101112131415import java.util.Calendar;public class Exam &#123; public static void main(String[] args) &#123; Calendar time = Calendar.getInstance(); System.out.println(time.getTime()); time.add(Calendar.HOUR, 1); System.out.println(time.getTime()); &#125;&#125;// 결과Wed Aug 22 12:32:43 KST 2018Wed Aug 22 13:32:43 KST 2018 Calendar 클래스에 메소드는 현재 시각을 기준으로 동작하기 때문에, 이 예제를 보고 따라하신다면 다른 결과값을 얻을 수 있습니다. before()와 after() 메소드 두 시간상의 전후 관계만을 알고 싶을 경우에는 before()와 after() 메소드를 사용할 수 있습니다. before() 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 앞서는지를 판단하고, 결과를 true/false로 반환합니다. 반대로 after() 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 나중인지를 판단하고, 결과를 true/false로 판단합니다. 123456789101112131415161718import java.util.Calendar;public class Exam &#123; public static void main(String[] args) &#123; Calendar time1 = Calendar.getInstance(); Calendar time2 = Calendar.getInstance(); Calendar time3 = Calendar.getInstance(); time2.set(1994,06,27); time3.set(2020,06,27); System.out.println(time1.before(time2)); System.out.println(time1.before(time3)); &#125;&#125;// 결과falsetrue get() 메소드 get() 메소드는 전달된 Calendar 필드에 저장된 값을 반환합니다. 1234567891011121314151617181920212223242526import java.util.Calendar;public class Exam &#123; public static void main(String[] args) &#123; Calendar time = Calendar.getInstance(); System.out.println(time.getTime()); System.out.println(time.get(Calendar.DAY_OF_WEEK)); System.out.println(time.get(Calendar.MONTH) + 1); System.out.println(time.get(Calendar.DAY_OF_MONTH)); System.out.println(time.get(Calendar.HOUR_OF_DAY)); System.out.println(time.get(Calendar.MINUTE)); System.out.println(time.get(Calendar.SECOND)); System.out.println(time.get(Calendar.YEAR)); &#125;&#125;// 결과Wed Aug 22 12:47:34 KST 201848221247342018 roll(), set() 메소드 roll() 메소드는 전달된 Calendar 필드에 일정 시간 만큼을 더하거나 빼줍니다. 하지만, add() 메소드와는 달리 다른 Calendar 필드에는 영향을 주지 않습니다. 즉, 계산 결과가 해당 필드의 최댓값이나 최솟값을 넘어가도 다른 필드에 영향을 주지 않습니다. set() 메소드는 전달된 Calendar 필드를 특정 값으로 설정합니다. 아래의 코드에서 add(), roll() , set() 메소드를 사용하는 것을 확인할 수 있습니다. 123456789101112131415161718192021import java.util.Calendar;public class Exam &#123; public static void main(String[] args) &#123; Calendar time1 = Calendar.getInstance(); Calendar time2 = Calendar.getInstance(); // 같은 시간으로 설정 time1.set(1994, 06, 27, 12, 34, 50); time2.set(1994, 06, 27, 12, 34, 50); time1.add(Calendar.SECOND, 15); time2.roll(Calendar.SECOND, 15); System.out.println(\"add() 메소드 호출 후 : \"+time1.getTime()); System.out.println(\"roll() 메소드 호출 후 : \"+time2.getTime()); &#125;&#125;// 결과add() 메소드 호출 후 : Wed Jul 27 12:35:05 KST 1994roll() 메소드 호출 후 : Wed Jul 27 12:34:05 KST 1994 위의 코드에서 add() 메소드를 사용하여 Calendar.SECOND를 15초 증가시키면 결과적으로 Calendar.MINUTE 필드가 1 증가하게 됩니다. 하지만, roll() 메소드를 사용하여 Calendar.SECOND 필드를 15초 증가시키면 Calendar.MINUTE 필드에는 아무런 영향을 주지 않는 것을 확인할 수 있습니다. 즉, Calendar.SECOND 필드만이 15초 증가하여 출력됩니다. 대표적인 Calendar 메소드","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"BOJ :: 9012","slug":"9012","date":"2018-08-20T14:22:36.000Z","updated":"2018-12-04T08:32:24.484Z","comments":true,"path":"2018/08/20/9012/","link":"","permalink":"https://woovictory.github.io/2018/08/20/9012/","excerpt":"","text":"알고리즘을 다시 풀려고 하는데, 기억이 하나도 나지 않아서 차근 차근 자바 문법부터 보고 있습니다…ㅎㅎ 하지만, 뭔가 알고리즘을 빨리 시작해서 공부해야 한다는 부담감이 조금씩 있죠… 하지만, 지금의 상황에서는 여러 가지를 하면서 진도를 많이 나가지 못하는 것보다는 범위를 좁혀서 빠르게 공부하는 게 나을 것 같다는 생각을 했습니다…! 그래서 이번 알고리즘 문제까지 풀고 당분간 우선 순위를 잡아 놓은 것들을 해결하고 나서야 다시 알고리즘을 꾸준하게 풀 수 있을 것 같습니다…ㅜㅜ 조급해 할 필요는 없고 시작하기 위한 기초를 잘 다지기 위한 과정이니까 조급해 하지 맙시다 ^^ 문제 괄호 문자열이 주어졌을 때, 올바른 괄호 문자열인지 아닌지를 판단하는 문제입니다. 괄호 문자열 : ( 와 )로만 이루어진 문자열 올바른 괄호 문자열 : 괄호의 쌍이 올바른 문제 문제 : https://www.acmicpc.net/problem/9012 풀이 여는 괄호 : ( 닫는 괄호 : ) 닫는 괄호의 입장에서 닫는 괄호와 짝이 맞는 여는 괄호는 어디에 있을까요? 왼쪽에 있어야 합니다. 아직 짝이 맞지 않아야 합니다. 1과 2와 해당하는 문자 중에서 가장 오른쪽에 있는 괄호가 어떤 닫는 괄호가 있었을 때 그 닫는 괄호와 짝이 맞는 여는 괄호를 의미하게 됩니다. 이 성질을 이용해서 Stack을 이욜해서 풀 수 있다. 1 -&gt; 어떤 순서로 문자열을 검사할 것인지를 판단할 수 있습니다. 2 -&gt; 2번에 해당하는 여는 괄호를 차례대로 스택에 넣습니다. 그렇다면 스택에 있는 괄호는 아직 짝이 맞지 않는 괄호이기 때문에 가장 오른쪽에 있는 괄호는 Stack의 top을 의미하게 됩니다. 따라서 stack을 이용하면 시간 복잡도는 O(1)로 줄일 수 있게 됩니다. Stack을 이용해서 올바른 괄호 문자열인지 아닌지를 알 수 있습니다. ( 가 나오면 스택에 (를 넣고 )가 나오면 스택에서 하나를 빼서 (인지 확인합니다. 또는 하나를 뺄 수 있는지를 확인합니다. 경우는 세 가지로 나눠 볼 수 있습니다. 닫는 괄호가 나왔는데 스택이 비어있는 경우 -&gt; 올바른 문자열이라고 할 수 없습니다. 왜냐하면 닫는 괄호에 해당하는 여는 괄호가 없기 때문입니다. 모든 과정이 끝났고, 스택이 비어있는 경우 -&gt; 올바른 문자열이라고 할 수 있습니다. 모든 과정이 끝났는데, 스택이 비어있지 않은 경우 -&gt; 여는 괄호에 대한 닫는 괄호가 없기 때문입니다. 하지만, 다시 생각해보면 스택에는 어차피 여는 괄호를 넣습니다. 따라서 스택에 무엇이 들어있는지 보다는 몇개가 들어있는지가 중요한 문제입니다. 즉, count 변수를 선언해서 체크함으로써 해결 가능합니다. 코드 123456789101112131415161718192021222324252627282930313233343536373839import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Scanner;import java.util.Stack;public class BOJ9012 &#123; public static void main(String[] args) throws IOException &#123; Scanner sc = new Scanner(System.in); int test_case = sc.nextInt(); sc.nextLine(); for (int i = 0; i &lt; test_case; i++) &#123; System.out.println(check(sc.nextLine())); &#125; &#125; public static String check(String str) &#123; int count = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == '(') &#123; count += 1; &#125; else if (str.charAt(i) == ')') &#123; count -= 1; &#125; if (count &lt; 0) &#123; // 닫는 괄호에 대한 여는 괄호가 스택에 없음. 문자열에 닫는 괄호가 있어서 count가 음수 return \"NO\"; &#125; &#125; if (count == 0) &#123; // 스택이 비어있음. 올바른 문자열 return \"YES\"; &#125; else &#123; // 스택이 비어있지 않음. 올바르지 못한 문자열 return \"NO\"; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[Java] 11. API 클래스-1","slug":"java-basic-11","date":"2018-08-20T01:14:45.000Z","updated":"2020-04-22T07:48:01.529Z","comments":true,"path":"2018/08/20/java-basic-11/","link":"","permalink":"https://woovictory.github.io/2018/08/20/java-basic-11/","excerpt":"","text":"Object 클래스 java.lang 패키지 중에서도 가장 많이 사용되는 클래스는 바로 Object 클래스입니다. Object 클래스는 모든 자바 클래스의 최고 조상 클래스가 됩니다. 따라서 자바의 모든 클래스는 Object 클래스의 모든 메소드를 바로 사용할 수 있습니다. toString()메소드 toString() 메소드는 해당 인스턴스에 대한 정보를 문자열로 반환합니다. 이 때 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되며, 그 뒤로 16진수 해시 코드가 추가됩니다. 16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값으로, 인스턴스마다 모두 다르게 반환됩니다. 123456789Car car1 = new Car();Car car2 = new Car();System.out.println(car1.toString());System.out.println(car2.toString());//결과com.company.Car@60e53b93com.company.Car@5e2de80c 자바에서 toString() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다. equals() 메소드 equals() 메소드는 해당 인스턴스를 매개변수로 전달받은 참조 변수와 비교하여, 그 결과를 반환합니다. 이 때, 참조 변수가 가리키는 값을 비교하므로, 서로 다른 두 객체는 언제나 false를 반환하게 됩니다. 12345678910Car car1 = new Car();Car car2 = new Car();System.out.println(car1.equals(car2));car1 = car2; // 두 참조 변수가 같은 주소를 가리킴 System.out.println(car1.equals(car2));// 결과falsetrue 자바에서 equals() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다. clone() 메소드 clone() 메소드는 해당 인스턴스를 복제하여, 새로운 인스턴스를 반환합니다. 하지만 Object 클래스의 clone() 메소드는 단지 필드의 값만을 복사하므로, 필드의 값이 배열이나 인스턴스이면 제대로 복제할 수 없습니다. 따라서 이러한 경우에는 해당 클래스에서 clone() 메소드를 오버라이딩하여, 복제가 제대로 이루어지도록 재정의해야 합니다. 이러한 clone() 메소드는 데이터의 보호를 이유로 Cloneable 인터페이스를 구현한 클래스의 인스턴스만이 사용할 수 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.company;import java.util.ArrayList;public class api &#123; public static void main(String[] args) &#123; Car car01 = new Car(); // 5 car01.setModelName(\"아반떼\"); car01.setOwners(\"홍길동\"); System.out.println(\"Car01 : \" + car01.getModelName() + \", \" + car01.getOwners() + \"\\n\"); // 6 Car car02 = (Car) car01.clone(); // 7 car02.setOwners(\"이순신\"); // 8 System.out.println(\"Car01 : \" + car01.getModelName() + \", \" + car01.getOwners()); // 9 System.out.println(\"Car02 : \" + car02.getModelName() + \", \" + car02.getOwners()); // 10 &#125;&#125;class Car implements Cloneable &#123; private String modelName; private ArrayList&lt;String&gt; owners = new ArrayList&lt;String&gt;(); // 1 public String getModelName() &#123; return this.modelName; &#125; // modelName의 값을 반환함 public void setModelName(String modelName) &#123; this.modelName = modelName; &#125; // modelName의 값을 설정함 public ArrayList getOwners() &#123; return this.owners; &#125; // owners의 값을 반환함 public void setOwners(String ownerName) &#123; this.owners.add(ownerName); &#125; // owners의 값을 추가함 public Object clone() &#123; try &#123; Car clonedCar = (Car) super.clone(); // 2 // clonedCar.owners = (ArrayList)owners.clone(); 3 return clonedCar; &#125; catch (CloneNotSupportedException ex) &#123; // 4 ex.printStackTrace(); return null; &#125; &#125;&#125;// 결과Car01 : 아반떼, [홍길동]Car02 : 아반떼, [홍길동, 이순신]Car02 : 아반떼, [홍길동, 이순신] 위의 코드에서 2번에서는 부모 클래스의 clone() 메소드를 호출하여 clone() 메소드를 오버라이딩하고 있습니다. 5번에서는 Car 클래스의 인스턴스인 car01을 생성하고, 7번에서는 오버라이딩한 clone() 메소드를 호출하여 복제를 수행하고 있습니다. 하지만, 2번처럼 clone() 메소드를 재정의하면, 필드의 값이 1번처럼 인스턴스일 때는 제대로 된 복제를 수행할 수 없습니다. 8번에서는 복제된 인스턴스인 car02의 owners 필드에 새로운 값을 하나 추가합니다. 하지만 9번의 실행 결과를 보면, 7번에서의 결과와는 달리 원본 인스턴스인 car01의 owners 필드에도 새로운 값이 추가되었음을 확인할 수 있습니다. 이처럼 단순히 부모 클래스의 clone() 메소드를 호출하여 clone() 메소드를 재정의하면, 배열이나 인스턴스인 필드는 복제되는 것이 아닌 해당 배열이나 인스턴스를 가리키는 주소값만이 복제되는 것입니다. 따라서 정확한 복제를 위해서는 3번처럼 배열이나 인스턴스인 필드에 대해서는 별도로 clone() 메소드를 구현하여 호출해야 합니다. 3번의 주석을 해제하고 결과를 보면 다음과 같습니다. 1234Car01 : 아반떼, [홍길동]Car02 : 아반떼, [홍길동]Car02 : 아반떼, [홍길동, 이순신] Object 클래스의 메소드 String 클래스 자바에서는 문자열을 위한 String이라는 클래스를 별도로 제공합니다. String 클래스에는 문자열과 관련된 작업을 할 때 유용하게 사용할 수 있는 다양한 메소드가 포함되어 있습니다. 이러한 String 클래스는 java.lang 패키지에 포함되어 제공됩니다. String 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 이러한 객체를 자바에서는 불변 객체(immutable object)라고 합니다. 즉, 자바에서 덧셈(+) 연산자를 이용하여 문자열 결합을 수행하면, 기존 문자열의 내용이 변경되는 것이 아니라 내용이 합쳐진 새로운 String 인스턴스가 생성되는 것입니다. charAt() 메소드 charAt() 메소드는 해당 문자열의 특정 인덱스에 해당하는 문자를 반환합니다. 만약 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면, IndexOutOfBoundsException 오류가 발생합니다. 123456789101112131415161718public class api &#123; public static void main(String[] args) &#123; String str = new String(\"Java\"); System.out.println(\"원본 문자열 : \"+str); for(int i=0;i&lt;str.length();i++)&#123; System.out.print(str.charAt(i)+\" \"); &#125; System.out.println(); System.out.println(\"charAt() 메소드 호출 후 문자열 : \"+str); &#125;&#125;// 결과원본 문자열 : JavaJ a v a charAt() 메소드 호출 후 문자열 : Java comparTo() 메소드 compareTo() 메소드는 해당 문자열을 인수로 전달된 문자열과 사전 편찬 순으로 비교합니다. 이 메소드는 문자열을 비교할 때 대소문자를 구분하여 비교합니다. 만약 두 문자열이 같다면 0을 반환하며, 해당 문자열인 인수로 전달된 문자열보다 작으면 음수를, 크면 양수를 반환합니다. 만약 문자열을 비교할 때 대소문자를 구분하지 않기를 원하면, compareToIgnoreCase() 메소드를 사용하면 됩니다. 쉽게 말해서 다음과 같은 문자열이 있다고 생각해봅시다. 12345678910111213141516String str = new String(\"abcd\");System.out.println(\"원본 문자열 : \"+str);System.out.println(str.compareTo(\"abcf\")); // 1System.out.println(str.compareTo(\"abbb\")); // 2 System.out.println(str.compareTo(\"Abcd\")); // 3System.out.println(str.compareToIgnoreCase(\"ABCD\")); // 4System.out.println(\"compareTo() 메소드 호출 후 문자열 : \"+str);//결과원본 문자열 : abcd-13320compareTo() 메소드 호출 후 문자열 : abcd 1 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abcf&quot;보다 사전순으로 먼저 존재하고, 이를 작다고 표현하며 음수를 반환합니다. 2 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abbb&quot;보다 사전순으로 뒤에 존재하고, 이를 크다고 표현하며 양수를 반환합니다. 3 -&gt; 사전 순으로 대문자가 먼저 존재하고, 소문자가 존재하는 것으로 파악됩니다. 4 -&gt; compareToIgnoreCase() 메소드를 사용함으로써 대소문자를 구분하지 않고 비교합니다. concat() 메소드 concat() 메소드는 해당 문자열의 뒤에 인수로 전달된 문자열을 추가한 새로운 문자열을 반환합니다. 만약 인수로 전달된 문자열의 길이가 0이면, 해당 문자열을 그대로 반환합니다. 12345678910String str = new String(\"Java\");System.out.println(\"원본 문자열 : \" + str);System.out.println(str.concat(\"수업\"));System.out.println(\"concat() 메소드 호출 후 원본 문자열 : \" + str);// 결과원본 문자열 : JavaJava수업concat() 메소드 호출 후 원본 문자열 : Java indexOf() 메소드 indexOf() 메소드는 해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환합니다. 만약 해당 문자열에 전달된 문자나 문자열이 포함되어 있지 않으면 -1을 반환합니다. 1234567891011121314String str = new String(\"Oracle Java\");System.out.println(\"원본 문자열 : \" + str);System.out.println(str.indexOf('o'));System.out.println(str.indexOf('a'));System.out.println(str.indexOf(\"Java\"));System.out.println(\"indexOf() 메소드 호출 후 원본 문자열 : \" + str);// 결과원본 문자열 : Oracle Java-127indexOf() 메소드 호출 후 원본 문자열 : Oracle Java 위의 예제처럼 indexOf() 메소드는 문자나 문자열을 찾을 때 대소문자를 구분합니다. trim() 메소드 trim() 메소드는 해당 문자열의 맨 앞과 맨 뒤에 포함된 모든 공백 문자를 제거해줍니다. 123456789101112String str = new String(\" Java \");System.out.println(\"원본 문자열 : \"+str);System.out.println(str + '|');System.out.println(str.trim() + '|');System.out.println(\"trim() 메소드 호출 후 원본 문자열 : \" + str);// 결과원본 문자열 : Java Java |Java|trim() 메소드 호출 후 원본 문자열 : Java toLowerCase(), toUpperCase() 메소드 toLowerCase() : 해당 문자열의 모든 문자를 소문자로 변환시켜 줍니다. toUpperCase() : 해당 문자열의 모든 문자를 대문자로 변환시켜 줍니다. 1234원본 문자열 : JavajavaJAVAtrim() 메소드 호출 후 원본 문자열 : Java 대표적인 String 메소드 StringBuffer 클래스 String 클래스의 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 하지만, StringBuffer 클래스의 인스턴스는 그 값을 변경할 수도 있고, 추가할 수도 있습니다. 이를 위해 StringBuffer 클래스는 내부적으로 버퍼(Buffer)라고 하는 독립적인 공간을 가집니다. 버퍼 크기의 기본값은 16개의 문자를 저장할 수 있는 크기이며, 생성자를 통해 그 크기를 별도로 설정할 수 있습니다. 하지만, 인스턴스 생성 시 사용자가 설정한 크기보다 언제나 16개의 문자를 더 저장할 수 있도록 여유 있는 크기로 생성됩니다.(즉, 두배씩 증가한다는 말입니다. 16-&gt;32-&gt;64 …) 덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성합니다. 따라서 문자열을 많이 결합하면 결합할수록 공간의 낭비뿐만 아니라 속도 또한 매우 느려지게 됩니다. 하지만, StringBuffer 인스턴스를 사용하면 문자열을 바로 추가할 수 있으므로, 공간의 낭비도 없으며 속도도 매우 빨라집니다. 이러한 StringBuffer 클래스는 java.lang 패키지에 포함되어 제공됩니다. 짚고 넘어가기~ String 클래스를 이용해서 객체를 생성하면, 그 인스턴스는 읽을 수만 있고 값을 변경할 수는 없습니다. 이를 코드를 통해서 확인해보겠습니다. 12345678String str1 = new String(\"이승우\");System.out.println(str1.hashCode());str1 = \"정지현\";System.out.println(str1.hashCode());// 결과1번 : 506648432번 : 50879257 위의 개념대로라면 str1의 값은 읽기만 가능하고, 변경할 수는 없습니다. 하지만, 위의 코드는 정상적으로 실행됩니다. 그렇다면 값을 읽을 수만 있고 변경할 수는 없다는 것은 무슨 뜻일까요?? 처음에 str1은 문자열이 &quot;이승우&quot;이고, 50664843라는 주소를 가지고 있는 인스턴스를 참조하고 있습니다. 이 공간에 있는 값은 읽을 수만 있고 변경할 수는 없습니다. str1 = &quot;정지현&quot;;을 통해서 값을 변경하려고 한다면, 새로운 공간을 할당하고 그 공간에 문자열을 집어넣습니다. 그 결과로 str1은 문자열이 &quot;정지현&quot;이고, 50879257라는 주소를ㄹ 가지고 있는 인스턴스를 참조하게 됩니다. 따라서 원래의 공간에 있는 값은 변경되지 않고, str1이 참조하고 있는 공간이 바뀌는 것입니다. 정리하면, String 클래스의 값을 변경한다는 것은 str1 인스턴스가 새롭게 생성되고, 이렇게 생성된 인스턴스의 공간은 str1이 참조하게 되는 것입니다. 그리고 그 전의 인스턴스는 공간을 차지하면서, 누구도 참조하지 않게 되고 이로 인해서 공간의 낭비는 발생하게 되고, 속도도 느려지는 것입니다. 불변클래스와 가변 클래스 String 클래스와 같이 인스턴스가 한 번 생성되면 그 값을 변경할 수 없는 클래스를 불변 클래스(immutable class) 라고 합니다. 반대로 StringBuffer 클래스와 같이 자유롭게 인스턴스의 값을 변경할 수 있는 클래스를 **가변 클래스(mutable class)**라고 합니다. String 클래스와 같은 불변 클래스는 StringBuffer 클래스의 append()나 insert() 메소드와 같이 값을 변경하는 set 메소드를 포함하지 않습니다. 이렇게 불편하기만 할 것 같은 불변 클래스를 사용하는 이유는 멀티 스레드 환경에서 객체가 변화되는 상황이라면 불변 인스턴스를 사용하는 것이 좀 더 신뢰할 수 있는 코드를 작성할 수 있기 때문입니다. 즉, 하나의 객체에 접근하면서 각각의 객체가 서로 영향을 주어서는 안되는 경우에 불변 인스턴스를 사용하면 값이 변하지 않는다는 점이 보장됩니다. append() 메소드 append()메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가합니다. 이 메소드는 String 클래스의 concat() 메소드와 같은 결과를 반환하지만, 내부적인 처리 속도가 훨씬 빠릅니다. 이유는 String 클래스의 concat() 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가하지만, 원본 문자열에 추가하는 것이 아니라 문자열을 추가한 새로운 인스턴스를 생성하는 것이고, append() 메소드는 원본 문자열에 인수로 전달된 문자열을 추가하는 것이기 때문에 처리 속도가 빠른 것입니다. 12345678910111213public class string2 &#123; public static void main(String[] args)&#123; StringBuffer str = new StringBuffer(\"Java\"); System.out.println(\"원본 문자열 : \"+str); System.out.println(str.append(\"수업\")); System.out.println(\"append() 메소드 호출 한 후 문자열 : \"+str); &#125;&#125;// 결과원본 문자열 : JavaJava수업append() 메소드 호출 한 후 문자열 : Java수업 capacity() 메소드 capacity() 메소드는 StringBuffer 인스턴스의 현재 버퍼 크기를 반환합니다. 12345678910111213public class string2 &#123; public static void main(String[] args)&#123; StringBuffer str1 = new StringBuffer(\"Java\"); StringBuffer str2 = new StringBuffer(); System.out.println(str1.capacity()); System.out.println(str2.capacity()); &#125;&#125;// 결과2016 위의 예제처럼 길이가 4인 문자열로 StringBuffer 인스턴스를 생성하면, 기본적으로 생성되는 여유 버퍼 크기인 16에 문자의 길이인 4를 더한 총 20개의 문자를 저장할 수 있는 버퍼가 생성되는 것을 확인할 수 있습니다. delete() 메소드 delete() 메소드는 전달된 인덱스에 해당하는 부분 문자열을 해당 문자열에서 제거합니다. 또한, deleteCharAt() 메소드를 사용하면 특정 위치의 문자 한 개만을 제거할 수도 있습니다. 1234567891011121314151617public class string2 &#123; public static void main(String[] args) &#123; StringBuffer str = new StringBuffer(\"Java Oracle\"); System.out.println(\"원본 문자열 : \" + str); System.out.println(str.delete(4, 8)); // 1 System.out.println(str.deleteCharAt(1)); // 2 System.out.println(\"deleteCharAt() 메소드 호출 후 원본 문자열 : \" + str); &#125;&#125;// 결과원본 문자열 : Java OracleJavacleJvacledeleteCharAt() 메소드 호출 후 원본 문자열 : Jvacle 1번에서는 delete() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치의 문자부터 8보다 하나 적은 7인 위치의 문자까지를 삭제하고 있습니다. 이처럼 delete() 메소드는 첫 번째 매개변수로 전달된 인덱스부터 두 번째 매개변수로 전달된 인덱스 바로 앞의 문자까지를 삭제하는 메소드입니다. insert() 메소드 insert() 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 지정된 인덱스 위치에 추가합니다. 이 때, 전달된 인덱스가 해당 문자열의 길이와 같으면, append() 메소드와 같은 결과를 반환합니다. 12345678910111213public class string2 &#123; public static void main(String[] args) &#123; StringBuffer str = new StringBuffer(\"Java 만세!!\"); System.out.println(\"원본 문자열 : \"+str); System.out.println(str.insert(5, \"Script \")); System.out.println(\"insert() 메소드 호출 후 문자열 : \"+str); &#125;&#125;// 결과원본 문자열 : Java 만세!!Java Script 만세!!insert() 메소드 호출 후 문자열 : Java Script 만세!! insert() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치부터 두 번째 매개변수로 전달된 문자열을 추가하고 있습니다. 이처럼 내가 원하는 위치에 문자열을 추가할 때 사용할 수 있는 메소드입니다. 대표적인 StringBuffer 메소드 Math 클래스 Math 클래스는 수학에서 자주 사용하는 상수들과 함수들을 미리 구현해 놓은 클래스입니다. Math 클래스의 모든 메소드는 클래스 메소드 (static method) 이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이러한 Math 클래스는 java.lang 패키지에 포함되어 제공됩니다. Math.E와 Math.PI 다음은 Math 클래스에 정의되어 있는 클래스 필드입니다. Math.E : 오일러의 수라 불리며, 자연로그(natural logarithms)의 밑(base) 값으로 약 2.718을 의미합니다. Math.PI : 원의 원주를 지름으로 나눈 비율(원주율) 값으로 약 3.14159를 의미합니다. random() 메소드 random() 메소드는 0.0이상 1.0 미만의 범위에서 임의의 double 형 값을 하나 생성하여 반환합니다. 이 메소드는 내부적으로 java.util 패키지의 Random 클래스를 사용한 의사 난수 발생기(pseudorandom generator)를 사용하여 임의의 수를 생성합니다. 123456789101112import java.util.Random;public class Exam &#123; public static void main(String[] args)&#123; System.out.println((int) (Math.random()*100)); Random random = new Random(); System.out.println(random.nextInt(100)); &#125;&#125; 자바에서는 Math 클래스의 random() 메소드 뿐만 아니라 java.util 패키지에 포함된 Random 클래스의 nextInt() 메소드를 사용해도 난수를 생성할 수 있습니다. nextInt() 메소드는 매개변수로 범위를 지정해 줄 수 있습니다. 만약 특정 범위에 속하는 난수를 생성하려면, 다음과 같이 난수 생성 범위를 조절할 수 있습니다. 123System.out.println((int) (Math.random()*6)); //1System.out.println((int) (Math.random()*6)+1); //2System.out.println((int) (Math.random()*6)+3); //3 만약 특정 범위에 속하는 난수를 생성하려면, 위와 같이 난수 생성 범위를 조절할 수 있습니다. 기본적으로 0부터 곱해지는 수의 바로 앞 수까지가 난수 생성 범위로 지정됩니다. 1 -&gt; 0~5 2 -&gt; 1~6 3 -&gt; 3~8 abs() 메소드 abs() 메소드는 전달된 값이 음수이면 그 값의 절대값을 반환하며, 전달된 값이 양수이면 전달된 값을 그대로 출력합니다. 12345678System.out.println(Math.abs(10));System.out.println(Math.abs(-10));System.out.println(Math.abs(-123123));/// 결과1010123123 floor(), ceil(), round() 메소드 floor() : 인수로 전달받은 값과 같거나 작은 수 중에서 가장 큰 정수를 반환합니다. ceil() : 반대로 인수로 전달받은 값과 같거나 큰 수 중에서 가장 작은 정수를 반환합니다. round() : 전달받은 실수를 소수점 첫째 자리애서 반올림한 정수를 반환합니다. 1234567891011121314151617181920212223242526System.out.println(Math.ceil(10.9));System.out.println(Math.ceil(10.0));System.out.println(Math.ceil(9.9));System.out.println();System.out.println(Math.floor(9.9));System.out.println(Math.floor(10.9));System.out.println(Math.floor(10.1));System.out.println();System.out.println(Math.round(10.34457));System.out.println(Math.round(10.49));System.out.println(Math.round(10.61));// 결과11.010.010.09.010.010.0101011 max(), min() 메소드 max() 메소드는 전달된 두 값을 비교하여 그 중에서 큰 값을 반환하며, min() 메소드는 그 중에서 작은 값을 반환합니다. 123456789101112System.out.println(Math.max(3.14, 3.141));System.out.println(Math.max(3.14, 3.14159)); System.out.println(Math.min(3.14, 3.14159)); System.out.println(Math.max(-10, -11)); System.out.println(Math.min(-10, -11)); // 결과3.1413.141593.14-10-11 pow(), sqrt() 메소드 pow() 메소드는 전달된 두 개의 double형을 가지고 제곱 연산을 수행합니다. 예를 들어, pow(a,b)는 a의 b승, 즉 a^b를 반환하게 됩니다. 반대로 sqrt() 메소드는 전달된 double형 값의 제곱근을 반화합니다. 123456System.out.println((int)(Math.pow(5,2)));System.out.println((int)(Math.sqrt(25)));// 결과255 삼각함수와 관련된 메소드 자바에서는 삼각 함수와 관련된 다양한 연산을 간편하게 수행할 수 있도록 많은 삼각 함수를 제공하고 있습니다. sin() : 전달된 double형 값의 사인 값을 반환합니다. cos() : 전달된 double형 값의 코사인 값을 반환합니다. tan() : 전달된 double형 값의 탄젠트 값을 반환합니다. 이 외에도 Math 클래스에서 제공하는 삼각 함수와 관련된 메소드는 다음과 같습니다. -asin(), acos(), atan(), atan2(), sinh(), cosh(), tanh() 12345678910111213141516System.out.println(Math.sin(Math.toRadians(30)));System.out.println(Math.sin(Math.PI / 6));System.out.println(Math.tan(Math.toRadians(45)));System.out.println(Math.tan(Math.PI / 4));System.out.println(Math.cos(Math.toRadians(60)));System.out.println(Math.cos(Math.PI / 3));// 결과0.499999999999999940.499999999999999940.99999999999999990.99999999999999990.50000000000000010.5000000000000001 위의 예제처럼 자바의 삼각 함수에 관한 메소드는 정확한 값을 나타내지 못합니다. 그 이유는 컴퓨터가 실수를 나타내는데 사용하는 부동 소수점 방식의 한계로 모든 언어에서 공통으로 발생하는 문제입니다. 대표적인 Math 메소드","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 10. 다형성","slug":"java-basic-10","date":"2018-08-19T07:02:01.000Z","updated":"2020-04-22T07:48:03.277Z","comments":true,"path":"2018/08/19/java-basic-10/","link":"","permalink":"https://woovictory.github.io/2018/08/19/java-basic-10/","excerpt":"","text":"# 다형성 하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미한다. 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 해 구현한다. 여러 가지 형태를 가질 수 있는 능력을 의미한다. 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 구현한다. # 참조 변수의 다형성 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 한다. 참조 변수가 사용할 수 있는 멤버의 개수 &lt;= 실제 인스턴스의 멤버의 개수 1234567891011121314151617181920class Parent&#123; String name; void showTV()&#123; &#125; void goSleep()&#123; &#125;&#125;class Child extends Parent&#123; String gender; void goSchool()&#123; &#125;&#125;public class text&#123; public static void main(String[] args)&#123; Parent p = new Parent(); // 1 Parent pc = new Child(); // 2 Child c = new Child(); // 3 Child cp = new Parent(): // 4 &#125; &#125; 참조변수 a = new 인스턴스타입() 특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문이다. 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있다. 참조 변수가 사용할 수 있는 멤버가 실제 인스턴스의 멤버 개수보다 적기 때문입니다. 하지만 반대의 경우, 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다. 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 된다. 기본적으로는 참조 변수와 인스턴스의 타입이 일치하는 걸 많이 사용한다. 참조 변수보다 인스턴스 타입의 멤버가 범위가 더 넓어야 한다. Parent p = new Child(); 참조 변수 : 부모, 인스턴스 타입 : 자식 -&gt; 가능, 부모의 멤버만 참조가 가능. Child d = new Parent(); 참조 변수 : 자식, 인스턴스 타입 : 부모 -&gt; 불가능, 참조 변수의 멤버를 모두 충족하지 못한다. # 참조 변수의 타입 변환 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있다. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있다. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있다. 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다. 참조 변수의 타입 변환도 기본 타입의 변환과 마찬가지로 타입 캐스트 연산자 ()를 사용한다. 1(변환할 타입의 클래스 이름) 변환할 참조 변수 12345678910111213class Parent&#123; ... &#125;class Child extends Parent&#123; ... &#125;class Brother extends Parent&#123; ... &#125;...Parent pa1 = null;Child ch = new Child();Parent pa2 = new Parent();Brother bro = null;pa1 = ch; // 1bro = (Brother)pa2; // 2bro = (Brother)ch; // 3 1 : pa1 = (Parent)ch; 와 같으며 자식 클래스 -&gt; 부모 클래스 타입으로의 변환이므로 타입 변환을 생략할 수 있다. 2 : 타입 변환을 생략할 수 없다. (부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.) 3 : 이 문장은 두 클래스 간의 직접적인 상속 관계가 아니므로 오류 발생. 짚고 넘어가야 할 부분! 자식 -&gt; 부모(Up-casting) : 형 변환 생략 가능 자식이 부모의 모든 걸 상속 받았으므로 자식이 더 범위가 넓다고 판단하여 손실이 없다고 판단하고 형 변환 생략이 가능하다. 부모 -&gt;자식(Down-casting) : 형 변환 생략 불가능 TV2 t = new TV2();와 TV2 t = new CaptionTV();의 차이점을 알아보자. 사실 TV2 t = new CaptionTV();는 다음을 줄인 것이다. TV2 t = (TV2)new CaptionTV(); 업 캐스팅이므로 형 변환이 생략되어있던 것이다. 이걸 또 풀어 쓰면 다음과 같다. CaptionTV c = new CaptionTV(); TV2 t = (TV2)c 역시 업 캐스팅이므로 TV2는 생략이 가능하다. 그렇다면 차이점이 무엇일까??? 1234567891011121314151617181920212223242526public class TV2 &#123; boolean power; int channel; void power()&#123;...&#125; void channelUp()&#123;...&#125; void channelDown()&#123;...&#125;&#125;class CaptionTV extends TV2 &#123; String text; void caption()&#123;...&#125;&#125;class Test4 &#123; public static void main(String[] args) &#123; TV2 t = new TV2(); TV2 t2 = new CaptionTV(); System.out.println(((CaptionTV) t2).text); // 1 // t는 TV2 인스턴스여서 TV2의 멤버만 가지고 있으므로 CaptionTV 타입을 커버할 수가 없다. // 컴파일 시에는 올바른 형변환으로 보지만 런타임에서 체크 해보면 부모가 자식을 커버할 수 없는 원리와 같다. // CaptionTV c = (CaptionTV)t; // System.out.println(c.text); // t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅 해서 일단 CaptionTV 멤버를 들고는 있는데 // 접근만 못할 뿐이라 CaptionTV 타입을 커버할 수 있다. CaptionTV c2 = (CaptionTV)t2; // 2 System.out.println(c2.text); // null &#125;&#125; t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅해서 일단 CaptionTV 멤버를 들고 있다. 그래서 접근하기 위해서는 1번과 같이 t2를 CaptionTV2로 다운 캐스팅 한 후에 접근해야 한다. 2번과 그 아래 코드는 1번에서 캐스팅 하고 text에 접근하는 과정을 풀어서 나타낸 것이다. TV2 t = new TV2(); 부모 참조 타입에 부모 인스턴스이면 Caption c = (CaptionTV)t -&gt; 불가능 자식의 참조 타입으로 변환하지 못한다. 컴파일에서 에러가 발생하지는 않지만, 런타임에 에러가 발생한다. TV2 t = new CaptionTV(); 부모 참조 타입에서 자식 인스턴스이면 CaptionTV c = (CaptionTV)t -&gt; 가능 자식의 참조 타입으로 변환 가능하다. instanceof 연산자 런타임에 참조 변수가 실제 참조하고 있는 인스턴스의 타입을 확인하기 위해 사용한다. 참조 변수 instanceof 클래스이름 true : 참조 변수 = 실제 참조하고 있는 인스턴스 타입일 때 반환 false : 참조 변수 != 실제 참조하고 있는 인스턴스 타입이 아닐 때 반환 참조 변수가 null을 가리키고 있으면 false 반환. 12345678910111213141516171819202122232425262728293031class Parent&#123; ... &#125;class Child extends Parent&#123; ... &#125;class Brother extends Parent&#123; ... &#125;public class Exam&#123; public static void main(String[] args)&#123; Parent pa1 = new Parent(); System.out.println(p instanceof Object); System.out.println(p instanceof Parent); System.out.println(p instanceof Child); System.out.println(p instanceof Brother); System.out.println(); Parent child = new Child(); System.out.println(child instanceof Object); System.out.println(child instanceof Parent); System.out.println(child instanceof Child); &#125;&#125;// 결과truetruefalsefalsetruetruetrue # 다형성에 대해 더 이후에 추가적으로 더 좋은 글을 참고하여 덧붙이게 되었다. 다형성? 여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함을 구현하는데 사용한다. 구체적으로는 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하는 것이다. 1234567891011121314151617181920public class testExam &#123; public static void main(String[] args) &#123; A obj = new B(); obj.x(); // obj.y(); 이 녀석으로 인해 컴파일 에러 &#125;&#125;class A &#123; public String x() &#123; return \"x\"; &#125;&#125;class B extends A &#123; // class A를 상속 받고 있는 B public String y() &#123; return \"y\"; &#125;&#125; class B를 obj로 인스턴스화하는데 데이터 타입은 A 그 말은 실질적으로 class B를 담고 있지만 A인 것!! 즉, class A에는 메소드 y()가 정의되어 있지 않다. 그래서 obj.y()는 컴파일 에러가 발생한다. 어떤 클래스를 인스턴스화 시킬 때, 변수를 담는 데이터 타입은 그 클래스가 될 수도 있고, 그 클래스의 부모 클래스가 될 수도 있다. 그럼 도대체 왜 이렇게 객체를 생성하는가 의문이 들기 시작한다. 다음 코드를 보자. 12345678910111213141516171819202122232425262728public class testExam &#123; public static void main(String[] args) &#123; A obj = new B(); System.out.println(obj.x()); &#125;&#125;class A &#123; public String x() &#123; return \"x\"; &#125;&#125;class B extends A &#123; // class A를 상속 받고 있는 B public String y() &#123; return \"y\"; &#125; @Override public String x() &#123; // 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것 return \"B.x\"; &#125;&#125;//결과B.x A obj = new B(); 위의 코드는 class B를 인스턴스화 한 obj이지만 class A의 행세를 한다. 그 뜻은 class A에 속해 있는 메소드만 호출할 수 있다는 것이다. 즉, class B에만 속해 있는 메소드는 호출할 수 없다. class B에서 class A에 속해있던 메소드를 오버라이딩했다면 그 오버라이딩한 결과가 호출된다. 하지만 아직도 왜 이런 코드를 작성하는지 모르는 건 마찬가지이다…ㅜ 아래의 코드를 하나 더 살펴보도록 하자. 12345678910111213141516171819202122232425262728293031323334353637public class testExam &#123; public static void main(String[] args) &#123; A obj = new B(); A obj2 = new B2(); System.out.println(obj.x()); System.out.println(obj2.x()); &#125;&#125;class A &#123; public String x() &#123; return \"x\"; &#125;&#125;class B extends A &#123; // class A를 상속 받고 있는 B public String y() &#123; return \"y\"; &#125; @Override public String x() &#123; // 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것 return \"B.x\"; &#125;&#125;class B2 extends A&#123; @Override public String x() &#123; return \"B2.x\"; &#125;&#125;//결과B.xB2.x obj, obj2 둘은 각각 B, B2 클래스를 통해 형성된 것이지만 부모 행세를 하고 있다. 따라서 자식 클래스에서 정의된 메소드를 호출할 수 없고 오버라이딩한 부분에 대해서만 호출한다. 즉 각각의 자식 클래스에서 오버라이딩한 부분이 실행된다. 서로 다른 객체가 동일한 데이터 타입으로 존재하면서 각각의 클래스에 정의되어 있는 메소드를 호출할 때 각자가 정의한 대로 호출합니다. 이쯤 되면 이러한 의문을 가질 수 있습니다. 같은 데이터 타입을 갖게 되면 장점이 있을까? 맞다. 데이터 타입이 같으면 메소드를 실행시키기가 편리해진다. 위의 코드처럼 호출하는 메소드를 만들어두면 하나의 데이터 타입을 대상으로 여러가지를 호출할 수 있다. 다형성과 인터페이스 어떤 클래스가 어떤 인터페이스를 구현하고 있다면 그 클래스로부터 인스턴스화 되는 인스턴스의 데이터 타입은 구현하고 있는 인터페이스로 인스턴스화 될 수 있다. 1234567891011interface I&#123;&#125;class C implements I&#123;&#125;public class Polymorphism&#123; public static void main(String[] args)&#123; I obj = new C(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647interface I2&#123; public String A();&#125;interface I3&#123; public String B();&#125;class D implements I2, I3&#123; public String A()&#123; return \"A\"; &#125; public String B()&#123; return \"B\"; &#125;&#125;public class testExam &#123; public static void main(String[] args) &#123; D objD = new D(); I2 objI2 = new D(); I3 objI3 = new D(); System.out.println(objD.A()); // class D가 정의한 모든 멤버를 호출할 수 있습니다. System.out.println(objD.B()); // class D가 정의한 모든 멤버를 호출할 수 있습니다. System.out.println(); System.out.println(objI2.A()); // interface I2의 데이터 타입이므로 A() 메소드 호출 가능 // System.out.println(objI2.B()); // interafce I2의 데이터 타입이므로 B() 메소드가 존재하지 않아 호출 불가능 // System.out.println(objI3.A()); // interface I3의 데이터 타입이므로 A() 메소드가 존재하지 않아 호출 불가능 System.out.println(objI3.B()); // interface I3의 데이터 타입이므로 호출 가능 &#125;&#125;//결과ABAB 클래스가 갖고 있는 모든 메소드를 호출해야 한다면(모든 기능을 사용해야 한다면) 데이터 타입을 그 클래스로 지정해줘야 하지만, 특정한 인터페이스에 해당하는 기능만을 사용한다고 하면 데이터 타입으로 그 기능이 속해 있는 인터페이스를 데이터 타입으로 지정하면 된다. 나머지 기능을 마치 존재하지 않는 것처럼 할 수 있다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"AWS :: amathon","slug":"aws-hackathon","date":"2018-08-18T13:52:19.000Z","updated":"2018-08-18T14:27:15.719Z","comments":true,"path":"2018/08/18/aws-hackathon/","link":"","permalink":"https://woovictory.github.io/2018/08/18/aws-hackathon/","excerpt":"","text":"뒤늦은 후기이지만, 제가 참여한 해커톤에 대한 간단한 리뷰를 해보겠습니다. ^0^ 제가 활동하고 있는 SOPT라는 동아리에서 AppJam이라는 2주 간의 해커톤은 해 본 경험이 있지만, 이렇게 짧은 1박 2일간의 해커톤은 처음이었습니다. 이번 글은 제가 첫 해커톤에 참가해서 느낀 경험을 말해보는 시간입니다. :D Amathon 해커톤에 대한 부푼 기대를 안고 참가했습니다. 하지만, 생각과 달리 분위기는 자유로웠고 즐거웠습니다. ㅎㅎ 바로 시작을 하지 않고, 간단한 소개 및 인사말과 후원을 해주신 분들 그리고 여러가지 설명을 해주셨습니다…ㅎㅎㅎ 먼저, Amathon이란?? Amathon Session 그리고 먼저 해커톤을 진행하기에 앞서 사전 교육 세션을 진행했습니다. 저는 이 중에서 Serverless Crawling &amp; Data Analysis 세션을 들었습니다. 이 세션은 AWS에서 제공하는 기능들을 이용해서 크롤링을 진행하고 많은 기능들을 체험해봄으로써 AWS에 친숙해지자는 목적을 담고 있습니다. 덕분에 크롤링이라는 것을 AWS에서 제공하는 기능들을 통해서 경험해보고 좋은 이야기를 들을 수 있었습니다. Time table Requirements Review 첫 해커톤에 대한 기대와 설렘 그리고 부담감이 있었지만, 자유롭고 즐거운 분위기 속에서 즐길 수 있었습니다. 제일 중요한 것은 좋은 팀원들을 만나서 정말 재미있는 해커톤을 진행하였으며, 실력이 좋으신 안드로이드 개발자 선배님을 만나서 그래들을 관리하는 법, Pair coding, 안드로이드 스튜디오는 항상 최신 버전으로 유지할 것 등등 유용한 것들을 많이 배울 수 있었습니다. 또한, 상을 주는 기준은 잘하는 것이 아닌 재미와 asug에서 정한 기준에 따른 수상이었습니다. 저희 팀은 운이 좋게도 기능은 좋지만 디자인이 별로였다상을 받아서 치킨을 선물로 받을 수 있었습니다. 그리고 참가비 만원을 내고 참가하였지만, 참가자에게 주는 기념품과 제가 받은 상까지 포함하면 소위 말해 개이득이었고, 정말 좋은 기회였습니다. 앞으로 해커톤이 생기면 자주 참여하도록 노력할 생각입니다. ^0^","categories":[],"tags":[]},{"title":"[Java] 9. 상속","slug":"java-basic-9","date":"2018-08-17T01:38:44.000Z","updated":"2020-04-22T07:48:04.804Z","comments":true,"path":"2018/08/17/java-basic-9/","link":"","permalink":"https://woovictory.github.io/2018/08/17/java-basic-9/","excerpt":"","text":"# 상속 기존의 클래스에 기능을 추가하거나 메소드를 재정의하여 새로운 클래스를 정의하는 것을 의미한다. 캡슐화, 추상화와 더불어 객체지향 프로그래밍의 특징 중 하나이다. extends 키워드를 사용한다. 단일 상속만을 지원한다. 상속을 통해 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다. 즉, 기존의 객체를 그대로 유지하면서 어떤 기능을 추가하는 방법이다. 기존의 객체가 갖고 있는 메소드들을 그대로 사용할 수 있다. 이때 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스(base class)라고도 한다. 그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스(child class) 또는 하위 클래스(sub class), 파생 클래스(derived class)라고도 한다. 상속의 장점 기존에 작성된 클래스를 재활용할 수 있다. 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다. 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다. 1. 자식 클래스(child class) 부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스. 1class 자식 클래스 이름 extends 부모 클래스 이름&#123; ... &#125; 부모 클래스와 자식 클래스 간의 포함 관계 부모 클래스는 자식 클래스에 포함된 것으로 볼 수 있다. 따라서, 부모 클래스에 새로운 필드를 하나 추가하면 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작한다. 자식 클래스에는 부모 클래스의 필드와 메소드만이 상속된다. 생성자와 초기화 블록은 상속되지 않는다. 또한, 부모 클래스의 접근 제어자가 private나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근할 수 없다. private로 선언된 멤버는 자식 클래스에서 접근할 수 없다. (같은 패키지이건, 다른 패키지이건) default로 선언된 멤버는 자식 클래스에서 접근 할 수 있다. (같은 패키지에 한해서만) 다른 패키지의 자식 클래스에서는 접근을 할 수 없다. 123456789101112131415161718192021class Parent&#123; private int num1 = 10; // private 필드 public int num2 = 20; // public 필드&#125;class Child extends Parent&#123; public int num3 = 30; void display()&#123; System.out.println(num1); // 1 System.out.println(num2); // 2 System.out.println(num3); // 3 &#125;&#125;public class Inheritance &#123; public static void main(String[] args)&#123; Child child = new Child(); child.display(); &#125;&#125; 1 : 부모 클래스의 private 멤버는 자식 클래스에서 접근할 수 없으므로 오류 발생. 2 : 부모 클래스의 public 멤버는 자식 클래스에서 접근 가능. 3 : 자식 클래스에서 자신만의 필드 혹은 메소드를 선언하여 사용할 수 있으므로 가능. # Object 클래스 Object 클래스는 모든 클래스의 부모 클래스이다. 모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 된다. toString(), clone()과 같은 메소드 등등. # super super : 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수이다. 인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 사용해서 구분했었다. 이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 super 키워드를 사용하여 구별할 수 있다. this와 마찬가지로 super 참조 변수는 인스턴스 메소드에서만 사용할 수 있다. 클래스 메소드에서는 사용할 수 없다. 123456789101112131415161718192021222324class Parent&#123; int a = 10;&#125;class Child extends Parent&#123; int a = 22; void display()&#123; System.out.println(a); System.out.println(this.a); System.out.println(super.a); &#125;&#125;public class Inheritance &#123; public static void main(String[] args)&#123; Child child = new Child(); child.display(); &#125;&#125;결과222210 위의 예제에서 int형 변수 a는 자식 클래스인 Child와 부모 클래스인 Parent에 선언되어 있습니다. 따라서 지역 변수와 this 참조 변수는 자식 클래스에서 대입된 값을 출력하며, super 참조 변수만이 부모 클래스에서 대입된 값을 출력하게 됩니다. # super() this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, super() 메소드는 부모 클래스의 생성자를 호출할 때 사용된다. 자식 클래스의 인스턴스를 생성하면 이 인스턴스에는 자식 클래스의 고유 멤버뿐 아니라 부모 클래스의 모든 멤버가 포함되어 있다. 따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야 한다. 이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 Object 클래스의 생성자까지 거슬러 올라가며 수행된다. 자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 super()를 추가하여 부모 클래스의 멤버를 초기화할 수 있도록 해준다. 하지만 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야, 자동으로 기본 생성자를 추가해준다. 아래처럼 부모 클래스에 매개변수를 가지는 생성자를 하나라도 선언했다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다. 123456789101112131415class Parent()&#123; int a; // 부모 클래스의 매개변수가 있는 생성자 Parent(int n)&#123; this.a = n; &#125;&#125;class Child extends Parent&#123; int b; Child()&#123; super(); b = 20; &#125;&#125; 위의 코드에서 super()를 사용해 부모 클래스의 기본 생성자를 호출하면 오류가 발생한다. 이유는 부모 클래스에 기본 생성자가 없기 때문이다. 매개변수를 가진 생성자를 선언해야 할 경우는 기본 생성자까지 명시적으로 선언하는 것이 좋다. 혹은 아래의 2번처럼 super(20); super() 메소드를 호출할 때 부모 클래스의 매개변수가 있는 생성자를 호출하는 것도 하나의 방법이다. 12345678910111213141516171819class Parent()&#123; int a; // 부모 클래스의 매개변수가 있는 생성자 Parent(int n)&#123; this.a = n; &#125; Parent()&#123; a = 10; &#125;&#125;class Child extends Parent&#123; int b; Child()&#123; super(); // 1 super(20); // 2 b = 20; &#125;&#125; 아래는 super() 메소드가 어떻게 호출되는지를 보여주는 예제이다. 123456789101112131415161718192021222324252627282930class Parent &#123; int a; Parent() &#123; a = 10; &#125; Parent(int n) &#123; a = n; &#125;&#125;class Child extends Parent &#123; int b; Child() &#123; // 하위 클래스에서는 반드시 상위 클래스의 생성자가 호출되어야 합니다. // super(40); 1번 b = 20; &#125; void display() &#123; System.out.println(a); System.out.println(b); &#125;&#125;public class Inheritance04 &#123; public static void main(String[] args) &#123; Child ch = new Child(); ch.display(); &#125;&#125; 자바 컴파일러는 주석 처리된 1번 라인에 자동으로 super();를 삽입할 것이다. 따라서 변수 a는 10으로 초기화된다. 1번 라인의 주석을 해제하고 실행하면 부모 클래스 Parent 클래스는 두 번째 생성자에 의해 초기화되고 변수 a는 40으로 초기화된다. 추가적으로 인스턴스 변수(여기서 int b)의 초기화는 인스턴스 변수가 선언된 클래스의 생성자를 통해서 진행하는 것이 가장 좋은 모델이 될 수 있다. 상위 클래스의 인스턴스 변수는 상위 클래스의 생성자 내에서 초기화가 진행되어야 하고, 하위 클래스에서는 상위 클래스의 인스턴스 변수를 초기화하는데 필요한 데이터를 키워드 super를 통해서 전달만 하는 것이 합리적이다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 8. 클래스 멤버","slug":"java-basic-8","date":"2018-08-13T07:01:59.000Z","updated":"2020-04-22T07:48:07.853Z","comments":true,"path":"2018/08/13/java-basic-8/","link":"","permalink":"https://woovictory.github.io/2018/08/13/java-basic-8/","excerpt":"","text":"자바에서는 변수가 3 종류로 나누어지고 각각 다른 메모리에 올라간다. 메소드도 클래스 메소드와 인스턴스 메소드로 분류할 수 있다. # 필드의 구분 클래스의 필드(field)란 클래스에 포함된 변수를 의미한다. 클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분된다. 클래스 변수(static variable) 인스턴스 변수(instance variable) 지역 변수(local variable) 12345678class Car&#123; static int cv; // 클래스 변수 String iv; // 인스턴스 변수 void method()&#123; int lv = 10; // 지역 변수 &#125;&#125; 클래스 변수와 인스턴스 변수는 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화 된다. 지역 변수는 사용하기 전에 초기화하지 않으면, 자바 컴파일러가 오류를 발생시킨다. 따라서 지역 변수는 반드시 초기화 해야 한다. 1. 클래스 변수 멤버 변수라고도 한다. 모든 인스턴스에게 적용될 수 있는 변수이며, 메모리 공간에 하나만 존재하고 모든 인스턴스가 공유하는 변수이다.(공유 변수) 인스턴스를 생성하지 않고도 바로 사용할 수 있다. 클래스 영역에 위치하며 static으로 선언된다. 어디서나 접근할 수 있도록 하기 위해 public 제어자를 추가한다. 참조의 용도로만 사용되는 공유 변수는 static final로 선언한다. static 변수(즉, 클래스 변수, 멤버 변수, 공유 변수)는 인스턴스가 생성되기 전에 메모리 공간에 할당되어 초기화까지 완료된다. int 타입 변수는 0으로 초기화된다. String 타입 변수는 null로 초기화된다. JVM에 의해 클래스가 메모리에 올라가는 순간에 초기화된다. static 변수에는 무거운 즉, 용량이 큰 변수를 선언하면 메모리의 비효율을 발생시킨다. 프로그램이 실행되면서 static area(= 메소드 영역)에 변수가 생성되기 때문이다. 이 영역에 생성되는 변수는 프로그램이 종료될 때까지 할당된 메모리를 점유하고 있게 된다. 이로 인해 무거운 즉, 용량이 큰 변수를 선언하지 않도록 주의해야 한다. 2. 인스턴스 변수 클래스 내부에 선언된다. 클래스 영역에 위치하며 static 키워드를 갖지 않는다. 인스턴스마다 다른 값을 갖는 변수. 인스턴스가 new 키워드를 통해 생성되어야 생성된다. 즉, 인스턴스가 생성되었을 때 인스턴스 변수에 접근할 수 있다. 자바 메모리 구조 중 Heap 영역에 생성된다. 삭제하지 않아도 GC에 의해 메모리가 회수된다. 3. 지역 변수 메소드 내에 선언되고 메소드 내에서만 사용 가능하다. 메소드가 종료되면 지역 변수는 소멸된다. 초기화하지 않으면 기본값이 설정되지 않기 때문에 명시적으로 초기화를 해줘야 한다. 예제 1234567891011121314151617181920212223242526272829303132333435363738class Field&#123; static int classVar = 10; // 클래스 변수 int instanceVar = 20; // 인스턴스 변수&#125;public class child&#123; public static void main(String[] args)&#123; int localVar = 30; System.out.println(\"지역 변수 참조 : \"+localVar); System.out.println(); Field field1 = new Field(); Field field2 = new Field(); System.out.println(\"클래스 변수 참조 : \"+Field.classVar); System.out.println(\"field1의 클래스 변수 참조 : \"+field1.classVar); System.out.println(\"field2의 클래스 변수 참조 : \"+field2.classVar); System.out.println(); field1.classVar = 100; System.out.println(\"클래스 참조 변수의 값 변경 후\"); System.out.println(\"클래스 변수 참조 : \"+Field.classVar); System.out.println(\"field1의 클래스 변수 참조 : \"+field1.classVar); System.out.println(\"field2의 클래스 변수 참조 : \"+field2.classVar); System.out.println(); System.out.println(\"field1의 인스턴스 변수 참조 : \"+field1.instanceVar); System.out.println(\"field2의 인스턴스 변수 참조 : \"+field2.instanceVar); field1.instanceVar = 200; field2.instanceVar = 2000; System.out.println(\"인스턴스 참조 변수의 값 변경 후\"); System.out.println(field1.instanceVar); System.out.println(field2.instanceVar); &#125;&#125; 123456789101112131415161718결과지역 변수 참조 : 30클래스 변수 참조 : 10field1의 클래스 변수 참조 : 10field2의 클래스 변수 참조 : 10클래스 참조 변수의 값 변경 후클래스 변수 참조 : 100field1의 클래스 변수 참조 : 100field2의 클래스 변수 참조 : 100field1의 인스턴스 변수 참조 : 20field2의 인스턴스 변수 참조 : 20인스턴스 참조 변수의 값 변경 후field1의 인스턴스 변수 참조 : 200field2의 인스턴스 변수 참조 : 2000 클래스 변수는 해당 클래스의 모든 인스턴스 변수가 같은 값을 공유한다. 인스턴스 변수는 인스턴스마다 별도의 고유한 값을 갖는다. 선언된 위치에 따라 구분되는 변수는 생성 및 소멸 시기, 저장되는 메모리 공간과 사용 방법까지도 서로 다르다. # 메소드의 구분 클래스 메소드(static method) 인스턴스 메소드(instance method) 1. 클래스 메소드(static 메소드) static 키워드를 갖는 메소드를 의미한다. 인스턴스를 생성하지 않아도 static 메소드에 접근하여 호출할 수 있다. 효율적으로 메모리와 시간을 컨트롤할 수 있다. 클래스 메소드는 인스턴스 변수를 사용하지 않고 전달된 매개변수만으로 동작하는 메소드이다. 클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다. 이유는 인스턴스 변수는 인스턴스가 생성될 때 사용할 수 있도록 메모리에 할당되기 때문이다. 클래스는 메소드보다 먼저 존재한다. 클래스는 컴파일 과정에서 이미 메모리에 올라가게 된다. 그리고 클래스를 기반으로 인스턴스를 생성하게 된다. 인스턴스 멤버는 인스턴스가 생성되면 사용할 수 있도록 메모리에 올라가게 된다. 클래스 메소드는 인스턴스 생성과 관계 없이 접근할 수 있다. 생성되지 않은 인스턴스는 메모리에 없다. 클래스 메소드가 메모리에 없는 인스턴스 변수에 접근하기 때문에 오류가 발생한다. 이러한 이유로 클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다. 메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려해볼만 합니다. 메소드 호출 시간이 짧아지므로 성능이 향상됩니다. 예제 123456789101112131415161718192021222324class Method &#123; int a = 20; int b = 30; int add() &#123; // 인스턴스 메소드 return a + b; &#125; static int add(int x, int y) &#123; // 클래스 메소드 return x + y; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(Method.add(10, 100)); Method method = new Method(); System.out.println(method.add()); &#125;&#125;// 결과11050 # 필드의 초기화 필드를 초기화하지 않으면 변수 타입에 맞는 초기값으로 자동 초기화된다. 하지만 지역 변수와 마찬가지로 적절한 값으로 초기화한 후에 사용하는 것이 좋다. 필드 초기화 방법 명시적 초기화 지역 변수를 초기화하는 방법과 마찬가지로 필드를 선언과 동시에 초기화하는 방법이다. 1234class Field&#123; static int classVar = 10; int instanceVar = 20;&#125; 생성자를 이용한 초기화 객체의 생성과 동시에 필드를 초기화하는 방법이다. 따라서 이 방법은 인스턴스를 생성할 때까지는 필드를 초기화할 수 없다. 초기화 블록을 이용한 초기화 클래스 필드의 초기화만을 담당하는 중괄호({})로 둘러싸인 블록을 의미한다. 초기화 블록은 생성자보다 먼저 호출되며, static 키워드의 유무에 따라 구분할 수 있다. static 키워드 X : 인스턴스 초기화 블록 static 키워드 O : 클래스 초기화 블록 초기화 블록에는 다양한 명령문 및 제어문을 사용할 수 있으므로, 복잡한 초기화를 해야할 경우 유용하게 사용된다. 인스턴스 초기화 블록 단순히 중괄호만을 사용하여 정의 가능. 생성자와 마찬가지로 인스턴스가 생성될 때 실행된다. 하지만 인스턴스 초기화 블록이 생성자보다 먼저 실행된다. 차이가 거의 없어 잘 사용되지 않는다. 다만 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있다.(사용해본 적이 없다.) 클래스 초기화 블록 static 키워드를 초기화 블록 앞에 정의한다. 클래스가 처음으로 메모리에 로딩될 때 단 한 번만 실행된다. 생성자나 인스턴스 초기화 블록으로 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용된다. 123456789101112131415161718192021222324252627282930class Method&#123; static int classVar; int instanceVar; // 인스턴스 초기화 블록 &#123; classVar = 11; &#125; // 클래스 초기화 블록 static&#123; classVar = 10; // 1 instanceVar = 20; // 2 : 오류 발생 &#125; Method()&#123; classVar = 100; // 3 this.instanceVar = 200; // 4 &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Method m = new Method(); System.out.println(Method.classVar); System.out.println(m.classVar); System.out.println(m.instanceVar); &#125;&#125; 1234결과 10100200 1 : 클래스 초기화 블록을 이용한 클래스 변수의 초기화는 수행된다. 2 : 클래스 초기화 블록을 이용한 인스턴스 변수의 초기화는 에러가 발생한다. 3 : 생성자를 이용한 클래스 변수의 초기화는 수행된다. 4 : 생성자를 이용한 인스턴스 변수의 초기화는 수행된다. 정리하면, 클래스 변수는 클래스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다. 그리고 인스턴스 변수는 인스턴스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다. 클래스 초기화 블록이 먼저 실행되고 그 다음으로는 인스턴스 초기화 블록이 실행된다. 가장 나중에는 생성자가 실행된다. 이 경우 위의 3가지 방법을 모두 이용해 초기화를 한다면 비효율적이다. 왜냐하면 어차피 제일 나중에 생성자를 위한 초기화가 반영되기 때문이다. 그래서 초기화할 때는 용도나 상황에 맞게 적절하게 사용하는 것이 중요하다. 필드의 초기화 순서 예시 클래스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블록 인스턴스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블록 -&gt; 생성자 1234567891011121314151617181920212223242526272829class InitBlack &#123; static int classVar = 10; int instanceVar = 10; // 클래스를 참조할 때 실행된다. static &#123; classVar = 20; &#125; &#123; instanceVar = 20; &#125; InitBlack()&#123; instanceVar = 30; classVar = 30; &#125;&#125;public class test &#123; public static void main(String[] args) &#123; System.out.println(\"클래스 변수 : \"+InitBlack.classVar); InitBlack initBlack = new InitBlack(); System.out.println(\"인스턴스 변수 : \"+initBlack.instanceVar); System.out.println(\"클래스 변수 - 생성자를 이용한 초기화한 후\"); System.out.println(\"클래스 변수 : \"+InitBlack.classVar); &#125;&#125; 12345결과클래스 변수 : 20인스턴스 변수 : 30클래스 변수 - 생성자를 이용한 초기화한 후클래스 변수 : 30 같은 필드를 여러 번 초기화하면 제일 마지막으로 초기화한 값만 남게된다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 7. 제어자","slug":"java-basic-7","date":"2018-08-12T08:14:53.000Z","updated":"2020-04-22T07:48:10.153Z","comments":true,"path":"2018/08/12/java-basic-7/","link":"","permalink":"https://woovictory.github.io/2018/08/12/java-basic-7/","excerpt":"","text":"제어자는 클래스와 멤버 선언 시 사용해 부가적인 의미를 부여하는 키워드. 접근 제어자 : 두 개 이상 사용 불가. 기타 제어자 : 여러 개 함께 사용 가능. # 접근 제어자 정보 은닉을 위해 접근 제어자 기능을 제공한다. 정보 은닉 : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념. 클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정해 정보 은닉을 구체화할 수 있다. 자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다. private public default protected 1. private private 접근 제어자를 사용하여 선언된 클래스 멤버는 외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없다. 자바 프로그램은 private 멤버에 직접 접근할 수 없으며, 해당 객체의 public 메소드를 통해서만 접근할 수 있다. 따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는데 사용된다. 123456789public class Person&#123; private String name =\"이승우\"; private String getName()&#123; // 1 return this.name; &#125; public String getInfo()&#123; // 2 return this.name; &#125;&#125; private 멤버는 해당 멤버를 선언한 클래스에서만 접근할 수 있다. 다른 클래스에서 Person 클래스의 name에 접근하고자 할 때는 2와 같이 Person 클래스에 public으로 메소드를 선언하여 private로 선언된 name에 접근할 수 있다. 1과 같이 메소드를 private로 선언하게 된다면, 다른 클래스에서 Person 클래스의 name에 접근할 수 없다. 2. public public 접근 제어자를 사용하여 선언된 클래스 멤버는 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다. 자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다. public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행한다. 123456public class EveryWhere&#123; public String var = \"누구든지 허용\"; public String getInfo()&#123; return this.var; &#125;&#125; 3. default(package-private) 클래스 및 클래스 멤버의 접근 제어 기본값으로 default 접근 제어자를 사용한다. 접근 제어자가 지정되지 않으면 default 접근 제어자를 자동으로 갖는다. default 접근 제어를 가지는 멤버는 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있습니다. 상속 관계에 있더라도 다른 패키지에서는 접근할 수 없다. 123456같은 패키지만 접근 허용package test;public class SamePackage&#123; String sameVar = \"같은 패키지는 허용\"; // default 필드&#125; 12345678910같은 클래스도 접근 허용package test;public class SameClass&#123; String var = \"다른 패키지는 접근 불가\"; // 1 : default 필드 public static void main(String[] args)&#123; SamePackage sp = new SamePackage(); System.out.println(sp.sameVar); &#125;&#125; 1에서 var 변수는 다른 패키지에서는 접근할 수 없다. 4. protected 자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축한다. 여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다. protected 멤버는 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됩니다. 상속 관계에 있을 경우 다른 패키지에서도 접근 가능. 상속 관계가 아닌 경우 다른 패키지에서 접근 불가능. 클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다. 이 멤버를 선언한 클래스의 멤버 이 멤버를 선언한 클래스가 속한 패키지의 멤버 이 멤버를 선언한 클래스를 상속받은 자식 클래스(child class)의 멤버 1234567같은 패키지는 접근 허용package test;public class SameClass&#123; protected String sameVar = \"다른 패키지에 속하는 자식 클래스까지 허용\"; // protected 필드&#125; 123456789101112다른 패키지에 속하는 자식 클래스도 접근 허용package test.other;import test.SameClass;// test 패키지의 SameClass 클래스를 불러들여 포함시킴public class ChildClass extends SameClass&#123; public static void main(String[] args)&#123; SameClass sameClass = new SameClass(); System.out.println(sameClass.sameVar); // 다른 패키지에 속하는 자식 클래스까지 허용 &#125;&#125; # 접근 제어자의 접근 범위 자바에서 접근 제어자의 접근 범위가 보다 많은 제어자부터 적은 제어자 순으로 나열하면 다음과 같다. 자바에서는 클래스나 멤버를 선언할 때, 접근을 허용할 범위에 맞는 접근 제어자를 선택하는 것이 매우 중요하다. public -&gt; protected -&gt; default -&gt; private # 기타 제어자 기타 제어자의 종류로는 다음과 같습니다. final 제어자 static 제어자 abstract 제어자 1.final final 제어자는 '변경할 수 없다’는 의미로 사용된다. 즉, 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)가 된다. 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없다. 메소드에 사용하면 오버라이딩을 통한 재정의를 할 수 없다. 자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같다. 클래스, 메소드, 필드, 지역 변수 ?? 어디지?? 메소드 오버라이딩이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다. 자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속받을 수 있습니다. 이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 재정의하여 사용할 수도 있습니다. 123456final class Car&#123; // 1 final int VAR; // 2 final void break()&#123; // 3 final double MAX_NUM = 10.2; // 4 &#125;&#125; 1 : Car 클래스는 상속을 통해 서브 클래스를 생성할 수 없다. 2 : VAR 필드는 상수화되어 값을 변경할 수 없다. 3 : 이 메소드는 오버라이딩을 통해 재정의할 수 없다. 4 : 이 지역 변수는 상수화되어 값을 변경할 수 없다. 2.static 변수에 static 제어자를 사용하면 클래스 변수가 된다. 메소드에 static 제어자를 사용하면 클래스 메소드가 된다. 특징 프로그램 시작시 최초에 단 한 번만 생성되고 초기화 된다. 인스턴스를 생성하지 않고도 바로 사용할 수 있다. 해당 클래스의 모든 인스턴스가 공유한다. 자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같습니다. 메소드, 필드, 초기화 블록 123456789class Car&#123; static int var; // 1 static&#123; // 2 &#125; static void break()&#123; // 3 &#125;&#125; 1 : 클래스 필드(static 변수) - Car 클래스의 인스턴스들이 공유한다. 2 : static 초기화 블록으로 보통 클래스 필드의 초기화를 진행 3 : 클래스 메소드(static 메소드) 3.abstract abstract 제어자는 '추상적인’이라는 의미로 사용된다. 선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstract 제어자를 붙여야 한다. 하나 이상의 추상 메소드를 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 한다. 자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같다. 클래스, 메소드 123abstract class Car&#123; // 1 abstract void break(); // 2&#125; 1 : 추상 클래스 2 : 추상 메소드 # 제어자의 조합 접근 제어자와 기타 제어자를 한 대상에 사용할 수 있다. 모든 경우가 가능한 것은 아니며 대상에 따라 조금 다르다. 클래스에서 final과 abstract는 함께 사용할 수 없다. final 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, abstract 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용할 수 있으므로, 상반된 이 두 제어자는 클래스에 함께 사용할 수 없다. 메소드에 static과 abstract는 함께 사용할 수 없다. abstract 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없다. 메소드에 private과 abstract는 함께 사용할 수 없다. : abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, private 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없다. 메소드에 private와 final은 함께 사용할 필요가 없다. 메소드에 사용된 final 제어자와 private 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없게 된다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있습니다. private 제어자를 사용한 메소드에는 자식 클래스가 접근할 수 없으므로 메소드 오버라이딩을 통한 재정의를 할 수 없다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 6. 메소드와 생성자","slug":"java-basic-6","date":"2018-08-10T06:31:15.000Z","updated":"2020-04-22T07:48:12.854Z","comments":true,"path":"2018/08/10/java-basic-6/","link":"","permalink":"https://woovictory.github.io/2018/08/10/java-basic-6/","excerpt":"","text":"# 메소드 클래스의 멤버 중 기능을 표현하는 메소드 특정 작업을 수행하기 위한 명령문의 집합 중복되는 코드의 작성을 피할 수 있다. 모듈화로 인해 가독성이 좋아진다. 유지보수 또한 쉽다. 메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다. 메소드의 정의 및 호출 1234567891011121314class Car&#123; private int currentSpeed; private int accelerationTime; public void accelerate(int speed, int second)&#123; // 선언부 System.out.println(second + \"초간 속도를 시속 \" + speed + \"(으)로 가속함!!\"); &#125;&#125; public static void main(String[] args)&#123; Car myCar = new Car();// 객체 생성 myCar.acceleratea(60,20); // 메소드 호출&#125; 메소드 시그니처란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킨다. 만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면 이 두 메소드의 시그니처는 같다고 할 수 있다. 메소드를 호출할 때 멤버 참조 연산자(.)를 사용하여 호출한다. 121. 객체참조변수이름.메소드이름(); // 매개변수가 없는 메소드의 호출2. 객체참조변수이름.메소드이름(인수1,인수2, ...); // 매개변수가 있는 메소드의 호출 # 생성자 클래스로부터 객체를 생성하면 해당 객체는 즉시 메모리에 생성된다. 하지만 이 객체는 모든 인스턴스 변수가 초기화되지 않은 상태이다. 클래스 변수와 인스턴스 변수를 별도로 초기화하지 않으면 타입에 맞는 값으로 자동 초기화된다. 사용자가 원하는 값으로 인스턴스 변수를 초기화하려면 일반적인 초기화 방식으로는 할 수 없다. private 변수도 있기 때문이다. 따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 public 메소드가 필요하다. 초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 한다. 자바에서 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공한다. 생성자의 이름은 해당 클래스의 이름과 같아야 한다. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다. 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다. 생성자는 인스턴스 생성 시 딱 한번 호출되는 메소드이다. return문도 정의되어 있지 않다. 생성자의 선언 121. 클래스이름()&#123; ... &#125; // 매개변수가 없는 생성자 선언2. 클래스이름(인수1,인수2, ...)&#123; ... &#125; // 매개변수가 있는 생성자 선언 생성자의 호출 new 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출된다. 123456789101112131415161718192021class Car&#123; private int number; private String name; Car(int number, String name)&#123; // 생성자 this.number = number; this.name = name; &#125; public String getModel()&#123; return this.number+\"년식의 \"+this.name; &#125;&#125;public class Practice &#123; public static void main(String[] args) &#123; Car myCar = new Car(3242, \"아반떼\"); // 객체 생성 및 생성자의 호출 System.out.println(myCar.getModel()); &#125;&#125; 기본 생성자 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다. 하지만, 특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다. 자바 컴파일러가 기본 생성자(default constructor)를 기본적으로 제공해주기 때문이다. 기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다. 자바 컴파일러가 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 기본 생성자를 추가한다. 12기본생성자 : 클래스이름()&#123;&#125; 예시 : Car()&#123;&#125; 위와 같이 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다. 다음 코드는 Car 클래스에 생성자를 정의하지 않고, 기본 생성자를 호출하는 코드이다. 123456789101112131415class Car&#123; private int number; private String name; public String getModel()&#123; return this.number+\"년식의 \"+this.name; &#125;&#125;public class Practice &#123; public static void main(String[] args) &#123; Car myCar = new Car(); // 기본 생성자의 호출 System.out.println(myCar.getModel()); &#125;&#125; 위의 코드에서 Car 클래스의 객체인 myCar는 기본 생성자를 호출하여 생성된다. Car 클래스에 기본 생성자가 존재하지 않는다. 기본 생성자가 없을 경우 자바 컴파일러가 컴파일 시 자동으로 생성해준다. 기본 생성자는 아무 동작도 하지 않는다. 따라서 인스턴스 변수를 클래스 필드에서 바로 초기화할 수 있다. 인스턴스 변수의 초기화는 생성자를 사용하거나 클래스 필드에서 수행할 수 있다. 만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않는다. 따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생한다. 이 경우에는 기본 생성자를 직접 추가해줘야 한다. 123456789101112131415161718192021class Car&#123; private int number; private String name; Car(int number, String name)&#123; // 1 this.number = number; this.name = name; &#125; public String getModel()&#123; return this.number+\"년식의 \"+this.name; &#125;&#125;public class Practice &#123; public static void main(String[] args) &#123; Car myCar = new Car(3242, \"아반떼\"); // 2. 객체 생성 및 생성자의 호출 Car yourCar = new Car(); // 3. 기본 생성자의 호출 -&gt; 오류 발생 System.out.println(myCar.getModel()); &#125;&#125; 매개변수를 갖는 생성자를 정의하고 있다. 따라서 자바 컴파일러는 Car 클래스에 기본 생성자를 추가하지 않는다. 3번에서 기본 생성자를 호출하여 인스턴스를 생성하려고 한다. 자바 컴파일러가 오류를 발생시킨다. 오류를 발생을 없애기 위해서는 Car 클래스에 기본 생성자를 추가하면 된다. # this와 this() this 참조 변수 : 인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수이다. this 참조 변수는 해당 인스턴스의 주소를 가리키고 있다. 123456789class Car&#123; private int number; private String name; Car(int number, String name)&#123; this.number = number; this.name = name; &#125;&#125; 위의 코드처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 인스턴스 변수 앞에 this 키워드를 붙여 구분해야 한다. 자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다. this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다. 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다. this() 메소드 : this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용한다. this() 메소드에 인수를 전달하면 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해줍니다. 12345678910111213141516171819202122class Car&#123; private int number = 1234; private String name = \"소나타\"; Car(int number, String name)&#123; this.number = number; this.name = name; &#125; Car()&#123; this(33,\"그랜져\"); &#125; public String getModel()&#123; return this.number+\"년식의 \"+this.name; &#125;&#125;public static void main(String[] args)&#123; Car myCar = new Car(); System.out.println(myCar.getModel());&#125; 매개변수를 가지는 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근한다. 또한, 매개변수를 가지지 않은 기본 생성자는 내부에서 this() 메소드를 사용하여 매개 변수를 가진 생성자를 호출한다. 이처럼 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있다. 단, 한 생성자에서 다른 생성자를 호출할 때는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있습니다. # 메소드 오버로딩 핵심은 메소드 시그니처 메소드 시그니처 : 메소드의 선언부에 명시되는 매개변수의 리스트를 말한다. 두 메소드의 매개변수의 개수와 타입, 그 순서까지 모두 같다면 두 메소드의 시그니처는 같다고 할 수 있다. 메소드 오버로딩은 같은 이름의 메소드를 매개변수의 개수와 타입을 다르게하여(중복) 정의하는 것이다. 즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이다. 메소드 오버로딩을 통해 메소드에 사용되는 이름을 절약할 수 있다. 또한, 메소드를 호출할 때 전달할 매개변수의 타입이나 개수에 대해 신경 쓰지 않아도 된다. 메소드 오버로딩은 OOP의 특징 중 하나인 다형성의 한 예다. 메소드 오버로딩의 대표적인 예 : println() 전달받은 매개변수의 타입에 따라 다양한 원형 중 적절한 원형을 호출한다. 1234567891011메소드 원형1. println()2. println(boolean x)3. println(char x)4. println(char[] x)5. println(double x)6. println(float x)7. println(int x)8. println(long x)9. println(Object x)10. println(String x) 메소드 오버로딩의 조건 메소드의 이름이 같아야 한다. 메소드의 시그니처 즉, 매개변수의 개수와 타입이 달라야 한다. 메소드 오버로딩은 반환 타입과는 관계가 없다. 메소드의 시그니처는 같은데 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않는다. 12345678910111213141516171819202122class Test&#123; // 전달받은 숫자 그대로 출력 static void display(int num1)&#123; System.out.println(num1); &#125; // 두 정수의 곱 출력 static void display(int num1, int num2)&#123; System.out.println(num1*num2); &#125; // 정수와 실수의 합 출력 static void display(int num1, double num2)&#123; System.out.println(num1+num2); &#125;&#125;public static void main(String[] args)&#123; Test test = new Test(); test.display(10); // 1 test.display(10,20); // 2 test.display(10,3.14); // 3 test.display(10,'a'); // 4&#125; 컴파일러는 사용자가 오버로딩된 함수를 호출하면 같은 메소드 시그니처를 갖는 메소드를 찾아서 호출한다. 4번에서 문제가 발생한다. 자바에서 char형 데이터는 int형 뿐만 아니라 double형으로도 타입 변환될 수 있기 때문이다. 이 호출은 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출해야 할 지 불명확하다. 자바에서는 오버로딩한 메소드의 이러한 모호한 호출을 허용하지 않으며, 위와 같은 경우에는 더 작은 표현 범위를 가지는 int형으로 자동 타입 변환된다. 4번 라인의 display() 메소드 호출은 영문 소문자 'a’의 아스키 코드값이 97이므로, int형으로 자동 타입 변환되어 두 수의 곱이 출력된다. # 재귀 호출 재귀 호출(recursive call)이란 메소드 내부에서 해당 메소드가 또 다시 호출되는 것을 의미한다. 메소드 내에 재귀 호출을 중단하도록 조건이 변경된 명령문을 반드시 포함해야 한다. 재귀 호출의 개념 12345678int sum(int n)&#123; int result = 0; for(int i=0;i&lt;=n;i++)&#123; result+=i; &#125; return result;&#125; 재귀 호출을 사용하지 않고 반복문으로 만든 메소드이다. 규칙 1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다. 1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다. 1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다. 1부터 1까지의 합은 그냥 1입니다. 위의 알고리즘을 의사코드(psedo code)로 작성하면 아래와 같다. 1234시작 1. n이 1이 아니면, n과 1부터 (n-1)까지의 합을 더한 값을 반환함 2. n이 1이면, 그냥 1을 반환함끝 의사 코드(psedo code)란 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드를 말한다. 의사 코드로 작성하고 바로 코드로 옮겨서 재귀 호출을 구현한다. 1234567int recursiveSum(int n)&#123; if(n==1) // n이 1이면, 그냥 1을 반환 return 1; return n+recursiveSum(n-1); // n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환&#125; if 문이 존재하지 않으면, 이 프로그램은 실행 직후 스택 오버플로우(stack overflow)에 의해 종료될 것이다. 따라서 if문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다. 스택 오버플로우는 메모리 구조 중 스택 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"생활코딩 :: supervisor","slug":"open-tutorials-8","date":"2018-08-10T01:51:48.000Z","updated":"2020-05-12T15:13:53.847Z","comments":true,"path":"2018/08/10/open-tutorials-8/","link":"","permalink":"https://woovictory.github.io/2018/08/10/open-tutorials-8/","excerpt":"","text":"supervisor 우리가 자바스크립트 코드를 수정하면 node가 이것을 알아서 감지하지 못합니다. 그래서 우리는 코드를 수정하고 서버를 껐다 켜야 하는 번거로운 작업을 수행하고 변경된 내용이 반영되는 것을 확인할 수 있습니다. 이러한 작업은 이미 실행된 프로그램이 루프를 계속 돌고 있기 때문에 우리가 변경한 내용이 반영되지 않는 것입니다. watch : 변경된 사항을 보고 있다가 변경이 일어났을 때 자동으로 node를 내부적으로 껐다가 키는 것 먼저, npm install supervisor -g 를 통해서 전역적으로 설치한 후 supervisor app.js를 통해 코드를 수행하면 app.js가 실행이 되고 app.js의 코드를 수정하고 변경된 사항을 저장하면 아래와 같이 서버가 자동으로 꺼졌다가 켜지는 것을 확인할 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"[Java] 5. 클래스","slug":"java-basic-5","date":"2018-08-09T10:11:44.000Z","updated":"2020-04-22T07:48:14.856Z","comments":true,"path":"2018/08/09/java-basic-5/","link":"","permalink":"https://woovictory.github.io/2018/08/09/java-basic-5/","excerpt":"","text":"# 객체지향 프로그래밍(OOP) 객체 지향 프로그래밍(Object-Oriented Programming)에서는 모든 데이터를 객체로 취급하며, 객체가 바로 프로그래밍의 중심이 된다. 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 상태 -&gt; Property로 정의. 행위 -&gt; Method로 정의. 장점 코드 재사용성이 높다. 만들어 놓은 클래스를 가져와 사용할 수 있고, 상속을 통해 확장하여 사용할 수 있다. 유지보수가 쉽다. 수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메소드로 있기 때문에 해당 부분만 수정하면 된다. 대형 프로젝트에 적합하다. 클래스 단위로 모듈화시켜 개발할 수 있으므로 업무 분담이 쉽다. 단점 실행 처리 속도가 상대적으로 느리다. 객체가 많으면 용량이 커질 수 있다. 설계시 많은 시간과 노력이 필요하다. # 클래스와 인스턴스 클래스 어떤 문제를 해결하이 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메소드로 정의한 것이다. 인스턴스 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터이다. 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다. 하지만 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다. # 메소드 클래스는 멤버로 속성을 표현하는 필드와 기능을 표현하는 메소드를 갖는다. 메소드는 특정 작업을 수행하기 위한 명령문의 집합. 123public void println(String data)&#123; System.out.println(data);&#125; 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시 반환 타입 : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시 메소드 이름 : 메소드를 호출하기 위한 이름을 명시 매개변수 목록 : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시 구현부: 메소드의 고유 기능을 수행하는 명령문의 집합 자바에서 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다. 하지만, 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다. 메소드 오버로딩 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다. 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다. 또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 된다. # 클래스의 구성 요소 클래스의 멤버 필드 : 속성을 표현 메소드 : 기능을 표현 생성자 : 객체의 필드를 초기화하는 메소드 12345678910111213class Car&#123; // 클래스 이름 private String modelName; // 필드 private int modelYear; // 필드 Car(String modelName, int modelYear)&#123; // 생성자 this.modelName = modelName; this.modelYear = modelYear; &#125; public String getModel()&#123; // 메소드 return this.modelYear+\"년식 \"+this.modelName; &#125;&#125; 필드(field) 클래스에 포함된 변수를 의미한다. 클래스 내에 선언된 위치에 따라서 다음과 같이 구분된다. 클래스 변수(static variable) 인스턴스 변수(instance variable) 지역 변수(local variable) Java :: 기초에서 확인가능합니다. 메소드(method) 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있으며, 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 된다. 유지보수가 용이하다. 생성자(constructor) 클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성된다. 하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태이다. 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공한다. 자바에서 생성자의 이름은 클래스의 이름과 같아야 한다. # 클래스의 선언 12345678클래스이름 객체참조변수이름; // 1Car myCar; 객체참조변수이름 = new 클래스이름(); // 2myCar = new Car();클래스이름 객체참조변수이름 = new 클래스이름(); // 3Car myCar = new Car(); 1번 : 객체 참조 변수 선언 2번 : 객체를 생성한다.(메모리상에 할당된다.) 객체의 주소를 미리 선언한 참조 변수에 저장한다. 3번 : 선언과 동시에 생성한다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"생활코딩 :: POST","slug":"open-tutorials-7","date":"2018-08-09T09:37:01.000Z","updated":"2020-05-12T15:13:55.477Z","comments":true,"path":"2018/08/09/open-tutorials-7/","link":"","permalink":"https://woovictory.github.io/2018/08/09/open-tutorials-7/","excerpt":"","text":"Get vs Post 서버와 웹 브라우져가 상호작용하는 과정에서 크게 보면 두 가지 방법이 있습니다. GET : 우리가 지금까지 웹 브라우져에서 웹 서버로 정보를 요청할 때 사용한 방식이며, 기본 방법입니다. 기본적으로 웹 브라우저에 주소를 입력해서 정보를 가져오는 것은 get 방식입니다. 쿼리스트링을 사용하는 방법 역시 정보를 가져오는 것이기 때문에 get 방식입니다. 즉, 우리가 서버에게 어떠한 정보를 요청해서 가져오는 방식을 말합니다. POST : 사용자의 정보를 서버로 전송할 때는 POST 방식을 사용합니다. form 123456789101112doctype htmlhtml head meta(charset='utf-8' method=\"get\") body form(action=\"/form_receiver\") p input(type =\"text\", name='title') p textarea(name='description') p input(type=\"submit\") form을 이용해서 '/form_receiver’에 해당되는 url을 생성해주었고 사용자가 입력한 title과 description은 제출 버튼을 누르면 해당 url을 통해서 서버로 값을 보내줍니다. 12345app.get('/form_receiver', function(req, res)&#123; var title = req.query.title; var description = req.query.description; res.send(title+\", \"+description);&#125;) 지금까지 한 것은 get 방식입니다. post 방식은 url을 통해서 데이터 즉 값을 보내지 않습니다. Post 1234567app.get('/form_receiver',function(req,res)&#123; res.send(\"Hello, GET\");&#125;)app.post('/form_receiver',function(req,res)&#123; res.send(\"Hello, POST\");&#125;) 사용자가 Post 방식으로 데이터를 전송하면 우리는 Post라는 메소드에 Controller를 연결시켜서 실행시킬 수 있습니다. form.jade 파일의 form 태그에서 method를 get인지 post인지 지정함에 따라서 사용자의 요청은 get과 post로 나뉘어 질 수 있고, 이러한 요청이 서버로 들어오게 되면 각각에 맞는 라우터에 걸려서 해당 익명 함수 즉, Controller의 동작을 수행할 수 있습니다. 그러면 post 방식으로 전송했을 때, post 방식으로 전송한 데이터를 우리 애플리케이션에서는 어떻게 받을 수 있을까요?? 12345app.post('/form_recevier', function(req, res)&#123; var title = req.body.title; var description = req.body.description; res.send(title+\", \"+description+\"in Post\");&#125;); Post 방식에서는 get 방식과는 다르게 body라는 객체를 통해서 사용자가 전송한 값을 받을 수 있습니다. 하지만, 코드를 실행하고 서버를 킨 다음에 테스트를 해보면 에러를 만날 수 있습니다. 기본적으로 post 방식으로 전달된 데이터는 정의되어 있지 않습니다. 이 데이터를 사용하려면 body-parser나 multer와 같은 mmiddleware를 설치해야 합니다. body-parser : post 방식으로 전송한 데이터를 우리의 애플리케이션에서 사용할 수 있도록 해주는 일종의 plug-in 또는 확장 기능이라고 생각하면 됩니다. body-parser를 우리의 애플리케이션에 포함시켜서 작동하도록 하면 우리는 req 객체 안의 body 객체를 사용할 수 있습니다. 123456789var bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123; extended: false&#125;))app.post('/form_recevier', function(req, res)&#123; var title = req.body.title; var description = req.body.description; res.send(title+\", \"+description+\"in Post\");&#125;); 위의 코드를 통해서 npm을 통해서 우리 프로젝트에 포함시킨 body-parser란 모듈을 가져올 수 있습니다. 우리가 가져온 body-parser란 모듈을 애플리케이션 객체에 use를 하면 이 모듈을 붙이는 것입니다. 즉, application 객체에 body-parser라는 모듈을 붙이는 것입니다. 그리고 앞으로 이 애플리케이션으로 들어오는 모든 요청들은 body-parser라는 미들웨어를 먼저 통과한 다음에 라우터가 동작하게 됩니다. 제일 앞쪽에서 body-parser가 항상 대기하고 있다가 사용자 요청이 들어오면 body-parser가 동작하면서 사용자가 포스트 방식으로 전송한 데이터를 우리가 사용할 수 있도록 하는 역할을 합니다. 정리하자면, body-parser라는 모듈을 추가했고, 이 body-parser라는 모듈을 우리의 애플리케이션에 user라는 메소드를 통해서 연결시켰습니다. 그러면 사용자에게서 들어오는 모든 요청들이 있을 때 body-parser가 제일 먼저 실행됩니다. 그러면 body-parser가 실행이 될 때, body-parser는 사용자가 post 방식으로 전송한 데이터가 있다면 애플리케이션 안에서 req 객체가 원래 가지고 있지 않았던 body라는 객체를 body-parser가 추가합니다. 그리고 사용자가 전송한 데이터의 이름이 title이라면 body라는 객체에 title이라는 프로퍼티에 그 값을 넣어서 사용자에게 제공합니다. Get과 Post의 용도 get : 어떤 정보에 대한 주소를 나타낼 때는 url 상에 모든 정보를 포함시켜야 합니다. post : 사용자가 id와 password를 입력해서 서버에서 전송해야 하는 경우라면 get 방식을 이용하게 된다면 url 상에 정보가 나타나게 됩니다. 하지만, 이 경우 우리의 id와 password가 노출될 위험이 있기 때문에 이러한 정보는 url 상에 정보가 표시되지 않는 방식인 post 방식을 사용해야 합니다. 하지만, 본질적으로 get 방식이건 post 방식이건 어떤 데이터가 전송되는가라는 것을 얻어내는 노력의 난이도가 조금 다를 뿐이지 본질적으로 다 알아낼 수 있기 때문에 post 방식이 get 방식보다 충분히 안전하다고 할 수 없고 둘 다 불안전합니다. 중간에 누군가가 데이터를 가로채지 못하게 하는 것은 다른 방법이 필요합니다. ex. https(ssl) 또 하나는 url을 통해서(쿼리스트링) 우리가 길이가 굉장히 긴 정보를 전송할 때, url을 통해서 쿼리스트링에 포함시켜서 get 방식으로 전달한다면 그 정보가 굉장히 크면 url 규격상 일정한 길이보다 더 길어지면 서버가 정보를 버립니다. 또는 브라우저가 전송을 하지 않을수도 있습니다. 따라서 이런 경우에는 데이터가 중간에 끊기지 않고 온전히 전체 데이터가 대규모로 전송되려면 전송 방법을 post로 지정해야 합니다. 요약 get 방식 get 방식을 통해서 전송된 쿼리 스트링의 데이터에 따라서 다른 결과를 보여줄 수 있습니다. 쿼리 스트링으로 데이터를 전송했을 때의 중요한 장점 express가 기본적으로 제공함 post 방식 url에 데이터가 포함되지 않고 데이터가 조용히 암시적으로 동작하기 때문에 불필요하게 정보가 노출되지않음 용량이 큰 데이터를 전송하는데 제한이 없음 express가 기본적으로 제공하지 않기 때문에 body-parser라는 middleware를 로드하고 application의 use를 통해서 붙여서 사용자로부터 들어오는 요청을 중간에 가로채서 post 방식이라면 req 객체의 body라는 객체를 추가시켜주는 역할을 한다. 그리고 body라는 객체에는 form으로 전송될 때 name의 값으로 전달된 데이터의 이름이 body 객체에 프로퍼티로 들어오기 때문에 form의 이름을 통해서 사용자가 전송한 데이터를 받을 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"생활코딩 :: URL","slug":"open-tutorials-6","date":"2018-08-09T06:39:19.000Z","updated":"2020-05-12T15:13:57.031Z","comments":true,"path":"2018/08/09/open-tutorials-6/","link":"","permalink":"https://woovictory.github.io/2018/08/09/open-tutorials-6/","excerpt":"","text":"쿼리 스트링 어떠한 사용자의 입력이 있을 때, 그 입력에 따라서 적당한 다른 결과를 보여주는 것이 의미있는 즉, 기능성이 있는 애플리케이션이라고 할 수 있습니다. 지금까지는 사용자가 어떤 주소로 접근하느냐에 따라서 사용자에게 다른 결과를 보여주었습니다. 만약 우리의 웹사이트가 a.com이라고 한다면 사용자가 path에 /login을 하게 되면 login에 해당되는 Route가 그 라우트와 연결되어 있는 Controller(익명 함수)를 호출해서 적당한 결과를 만들어 내는 것이 애플리케이션의 구조입니다. 그림과 같이 paht만 놓고 본다면 서로 다른 결과를 사용자에게 보여주지만, http://a.com/topic이라는 path 한 개는 사용자에게 언제나 똑같은 결과만을 보여줍니다. 사고를 좀 더 확장해보면 이 topic으로 사용자가 접근했을 때도 경우에 따라서 다른 결과를 보여줄 수 있다면 더 좋을 것입니다. 이것을 하기 위해서 쿼리 스트링을 배울 것입니다. topic이라는 라우터에 id가 1이라고 하는 값을 전달하고 있습니다. 1이라는 숫자에 해당되는 결과를 처리해서 화면에 보여줍니다. 결과적으로 topic이라는 단 하나의 path로, 다른 말로 단 하나의 라우터로 id 값을 다르게 주는 것에 따라서 다른 결과를 만들어 낼 수 있습니다. ? 뒤에 나타나는 정보를 쿼리 스트링이라고 합니다. query 객체 사용법 123456var express = require('express');var app = express();app.get('/topic',function(req, res)&#123; res.send(req.query.id); res.send(req.query.id+', '+req.query.name)&#125;) topic이라는 path가 가리키는 Controller가 쿼리 스트링을 어떻게 알 수 있을까?? 사용자는 주소를 통해서 웹 페이지에 접근하고 있고, 사용자는 우리에게 요청을 하고 있습니다. 이러한 요청과 관련된 정보는 req라는 첫 번째 매개변수에 값으로 request 정보가 들어오게 됩니다. 쿼리 스트링으로 전달된 값이 이 함수의(Controller의) 첫 번째 매개변수의 값인 req에 query라고 하는 객체에 id라고 하는 프로퍼티 값으로 들어옵니다. express는 req라는 값을 전달하며, req는 query라고 하는 객체를 갖습니다. 그리고 query라는 객체는 사용자가 전달한 쿼리스트링을 프로퍼티로 갖습니다. topic?id=1&amp;name=“이승우” 쿼리스트링을 통해서 우리가 애플리케이션에 전달할 수 있는 값은 하나가 아니라 여러 개 일수도 있습니다. 값을 구분하는 구분자로 쿼리스트링은 &amp;를 사용합니다. query 객체의 활용 1234567891011121314app.get('/topic',function(req, res)&#123; var topics = [ 'Javascript is ...', 'Nodejs is ...', 'Express is ...' ]; var output = ` &lt;a href=\"/topic?id=0\"&gt;JavaScript&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic?id=1\"&gt;Nodejs&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic?id=2\"&gt;Express&lt;/a&gt;&lt;br&gt;&lt;br&gt; $&#123;topics[req.query.id]&#125; ` res.send(output);&#125;); 쿼리스트링 : 어떤 애플리케이션에서 정보를 전달할 때 사용하는 URL의 약속되어 있는 국제적인 표준입니다. 그리고 쿼리스트링으로 전달된 값은 request 영역이기 때문에 첫 번째 매개변수에 담겨 있는 값인 req 객체, 또 그 객체가 가지고 있는 query라는 객체 또 그 객체 안에 있는 id 값을 통해서 가져올 수 있습니다. 시멘틱 URl topic/?id=2가 아니라 쿼리스트링이 없이 topic/2와 같은 깔끔한 URL을 통해서 애플리케이션을 제어할 수 있습니다. 이런 방식의 URL 체계를 시멘틱 URL이라고 합니다. 하지만, 기존의 쿼리스트링 방식의 URL을 사용하면 topic/2와 같은 URL을 잡아내지 못하고, 주소 뒤에 오는 숫자 값을 사용하기 위해서는 시멘틱 URL에서는 params를 이용합니다. 따라서 아래와 같은 수정이 필요합니다. 1234567891011121314app.get('/topic/:id', function(req, res)&#123; var topics = [ 'Javascript is ...', 'Nodejs is ...', 'Express is ...' ]; var output = ` &lt;a href=\"/topic?id=0\"&gt;JavaScript&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic?id=1\"&gt;Nodejs&lt;/a&gt;&lt;br&gt; &lt;a href=\"/topic?id=2\"&gt;Express&lt;/a&gt;&lt;br&gt;&lt;br&gt; $&#123;topics[req.params.id]&#125; ` res.send(output);&#125;) 쿼리 스트링을 사용해 접근하는 경우 : req.query.id로 접근하면 됩니다. 시멘틱 URL(path 방식)을 사용해 접근하는 경우 : req.params.id로 접근하면 됩니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"생활코딩 :: 템플릿","slug":"open-tutorials-5","date":"2018-08-09T04:59:53.000Z","updated":"2020-05-12T15:13:58.449Z","comments":true,"path":"2018/08/09/open-tutorials-5/","link":"","permalink":"https://woovictory.github.io/2018/08/09/open-tutorials-5/","excerpt":"","text":"템플릿 엔진이란 무엇인가? 정적인 방법과 동적인 방법의 장/단점을 가지고 있습니다. 정적인 파일만 서비스한다면 필요없지만, 동적인 결과를 정적인 파일에 담기 위해 사용합니다. 풀어 설명하자면, 자바스크립트 코드로 연산된 결과를 변수에 넣고 변수를 뷰 파일에서도 사용할 수 있게끔 합니다. 템플릿 엔진을 사용하는 이유 클라이언트 요청에 따라 웹 페이지에 들어가는 내용(결과)이 달라질 수 있어서 정적인 부분과 동적인 부분을 따로 하기위해 사용합니다. app.js 내 html 코드를 쓰지 않아도 됩니다. 뷰 파일과 자바스크립트 코드를 한 파일에 정의하지 않고 따로 따로 사용할 수 있습니다. 자바스크립트로 연산된 결과를 뷰 파일에 쉽게 넣을 수 있습니다. 템플릿 엔진 중 Jade를 사용합니다. 템플릿 엔진을 이용하면 짧은 코드로 장황한 HTML 코드를 만들어 낼 수 있는 기능을 제공합니다. 템플릿 엔진 안에서 변수도 사용할 수 있다. Express와 함께 템플릿 엔진 사용 Express는 템플릿 엔진 기능이 없기 때문에 사용하기 위해서 템플릿 엔진을 설치해서 express와 연결한 다음에 사용하면 됩니다. 'npm install jade --save’를 통해 모듈을 설치합니다. 이를 통해 node_modules 폴더에 Jade가 추가되고, package.json 파일에 Jade가 dependencies 항목으로 추가됩니다. 123456789var express = require('express');var app = express();app.set('view engine','jade');app.set('views', './views');// 위의 한 줄을 생략해도 express 기본적으로 views라는 디렉토리를 찾도록 설정되어 있습니다.app.get('/template',function(req, res)&#123; res.render('temp');&#125;) view engine : 약속되어 있는 이름 jade : 템플릿 엔진 express의 application에게 jade라는 템플릿 엔진을 set합니다. 우리가 설치한 jade라고 하는 템플릿 엔진과 우리가 지금 만들고 있는 애플리케이션 프레임워크인 express를 연결합니다. 그리고 views라는 폴더를 생성해줍니다. 앞으로의 jade 파일은 이 디렉토리에 저장합니다. (템플릿 엔진들의 템플릿 파일을 views라는 파일에 넣습니다.) ‘/template/’ 경로를 통해서 들어온 사용자에게 함수가 실행되면서 temp라는 템플릿 파일을 웹 페이지로 렌더링해서 전송한다는 뜻입니다. 템플릿 엔진의 코드에 따라서 만들어진 템플릿 파일을 읽어옵니다. temp라는 파일은 views 폴더에 위치합니다. response 즉, 응답으로 temp를 render하게 되면 express는 내부적으로 위쪽에 정의해놓은 views라고 하는 디렉토리에서 우리가 템플리세 엔진으로 jade를 정해놓았기 때문에 jade의 확장자인 temp.jade라는 파일을 찾아서 그 파일에 있는 내용을 jade의 문법에 따라서 해석한 후에 결과를 가져오고 그것을 사용자에게 response하는 코드입니다. Jade 문법 123456789html head body h1 Hello Jade ul - for(var i=0;i&lt;5;i++) li coding div= time // jade의 변수 들여쓰기를 통해서 head 태그와 body 태그를 html 태그 안에 넣을 수 있습니다. 하지만, 웹 페이지에서 소스보기를 통해서 확인하면 코드의 가독성이 떨어지고 이쁘지 않은 모습을 볼 수 있습니다. 이럴 때는 app.locals.pretty = true;라는 코드를 추가해주면 이쁘게 바뀐 모습을 확인할 수 있습니다. 반복적인 작업을 할 때는 for문을 이용하면 되는데, 이는 화면에 출력하는 코드가 아니고 프로그래밍적으로 제어하기 위한 코드입니다. 이러한 코드는 앞에 -라는 Jade 안에서 약속되어 있는 특수 기호를 붙이면 jade는 -를 보고 for가 화면에 출력되는 것이 아니라는 것을 알게 됩니다. for는 Jade 안에서 반복문으로 사용됩니다. Html을 작성하는 것이 훨씬 더 간결하게 가능해집니다. 그리고 동시에 프로그래머블하다는 특성을 가지게 됩니다. time이라는 변수로 현재 시간을 넣기 위해서는 jade 안에서 가능한 것이 아니고 jade를 사용하는 express 쪽에서 변수 값을 주입해주어야 합니다. 123app.get('/template',function(req, res)&#123; res.render('temp', &#123;time: Date()&#125;);&#125;) render 함수의 두 번째 인자로 객체를 전달합니다. time이라는 객체가 render에 의해서 temp.jade라고 하는 template에 흘러들어가게 됩니다. 그러면 temp가 가리키고 있는 temp.jade는 내부적으로 time이라는 변수를 사용할 수 있게 됩니다. 우리가 넘긴 변수 값이 jade 파일 안에서 사용될 수 있습니다. 변수의 값은 여러 개가 전달될 수 있으며, Jade 파일에서 명시된 것과 동일한 이름을 사용해야 합니다. 정리 먼저, 'npm install jade --save’를 통해서 사용할 템플릿 엔진인 Jade를 설치합니다. 12345678var express = require('express');var app = express();app.set('view engine', 'jade');app.set('views', './views');app.get('/template', function(req, res)&#123; res.render('temp', &#123;time : Date(), _title : 'Jade'&#125;);&#125;) 설치된 jade와 express를 연결하기 위해서 위의 코드를 통해서 환결 설정을 해줍니다. 그리고 우리가 어떤 특정한 템플릿을 사용하고 싶다면, temp.jade를 사용하고 싶다면 res가 가지고 있는 메소드 중에서 render라는 메소드를 호출하면서 첫 번째 인자로 그 템플릿의 이름을 전달해주면 render가 내부적으로 템플릿을 읽어서 그 템플릿 엔진의 문법에 따라서 해석한 다음에 사용자에게 response 해줍니다. 만약에 템플릿에 데이터를 주입하고 싶다면, 객체를 정의해서 그 객체의 프로퍼티 값으로 원하는 값을 전달하면 그 템플릿 엔진에서는 = time과 같이 문법을 통해서 변수의 값을 화면에 출력할 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"[Java] 4. 배열","slug":"java-basic-4","date":"2018-08-06T14:21:14.000Z","updated":"2020-04-22T07:48:16.754Z","comments":true,"path":"2018/08/06/java-basic-4/","link":"","permalink":"https://woovictory.github.io/2018/08/06/java-basic-4/","excerpt":"","text":"# 배열(Array) 같은 타입의 변수들로 이루어진 유한 집합 배열을 구성하는 각각의 값을 배열 요소라고 한다. 위치를 가리키는 숫자를 인덱스라고 한다. 인덱스는 0부터 시작하고 0을 포함한 양의 정수만을 가질 수 있다. 같은 종류의 데이터를 많이 다뤄야 하는 경우에 사용. 1차원, 2차원, 다차원 배열이 존재 배열의 초기화 다양한 초기화 방법들이 존재한다. 12345678910111213// 배열의 선언과 동시에 초기화할 수 있음int[] grade1 = &#123;70,80,90&#125;; // 배열의 선언과 동시에 초기화할 수 있음int[] grade2 = new int[]&#123;70,80,90&#125;; // 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함int[] grade3;grade3 = &#123;70,80,90&#125;; // 이미 선언된 배열은 이 방법으로만 초기화 가능int[] grade4;grade4 = new int[]&#123;70,80,90&#125;; 위의 grade1, grade2, grade4 배열은 초기화 블록에 맞춰 자동으로 배열의 길이가 설정된다. # 다차원 배열 2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다. 2차원 배열 : 배열 요소로 1차원 배열을 가지는 배열 3차원 배열 : 배열 요소로 2차원 배열을 가지는 배열 2차원 배열 배열의 요소로 1차원 배열을 가지는 배열. 자바에서 2차원 배열을 나타내는 타입을 따로 제공하지 않는다. - 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있다. 1234567891011121314151617int[][] arr = new int[2][3];int k = 10;for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr[i].length;j++)&#123; arr[i][j] = k; k+=10; &#125;&#125;for(int i=0;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;arr[i].length;j++)&#123; System.out.print(arr[i][j]+\" \"); &#125; System.out.println();&#125;System.out.println(arr.length); // 2System.out.println(arr[0].length);// 3 arr.length는 2차원 배열인 arr의 배열 요소의 총 개수인 2를 반환. arr[i].length는 arr의 각 배열 요소인 1차원 배열이 가지고 있는 배열 요소의 총 개수인 3을 반환. 2차원 배열의 선언과 동시에 초기화하는 방법 12345int[][] arr = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125;, &#123;7,8,9&#125;&#125;; 가변 배열(dynamic arrya) 2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장할 수 있다. 이렇게 행마다 다른 길이의 배열을 저장할 수 있는 배열을 **가변 배열(dynami array)**이라고 한다. 배열을 생성할 때 열에 해당하는 인덱스를 생략하면 가변 배열을 만들 수 있다. 1234int[][] arr = new int[3][];arr[0] = new int[2];arr[1] = new int[4];arr[2] = new int[1]; 가변 배열도 초기화 블록을 사용해 배열을 선언과 동시에 초기화할 수 있다. 12345int[][] arr = &#123; &#123;10,20&#125;, &#123;10,20,30,40&#125;, &#123;10&#125;&#125;; # 배열의 복사 배열은 한 번 생성하면 그 길이를 변경할 수 없다. 더 많은 데이터를 저장하기 위해서는 더 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다. 배열의 복사를 위해 다음과 같은 방법이 존재한다. System 클래스의 arraycopy() 메소드 가장 좋은 성능을 보이며, 배열의 복사만을 위해 만들어짐 Arrays 클래스의 copyOf() 메소드 현재 배열의 복사를 위해 가장 많이 사용되며, 좀 더 유연함 Object 클래스의 clone() 메소드 이전 배열과 같은 길이의 배열밖에 만들 수 없음 for문과 인덱스를 이용한 복사 arraycopy(), copyOf() 메소드와 for문을 이용한 복사는 배열의 길이를 마음대로 늘일 수 있습니다. 123456789101112131415int[] arr1 = new int[]&#123;1, 2, 3, 4, 5&#125;;int newLen = 10;// 1. System 클래스의 arraycopy() 메소드int[] arr2 = new int[newLen];System.arraycopy(arr1, 0, arr2, 0, arr1.length);// 2. Arrays 클래스의 copyOf() 메소드int[] arr3 = Arrays.copyOf(arr1, 10);// 3. Object 클래스의 clone() 메소드int[] arr4 = (int[])arr1.clone();// 4. for 문과 인덱스를 이용한 복사int[] arr5 = new int[newLen]; # Enhanced for문 JDK 1.5부터는 배열과 컬렉션의 모든 요소를 참조하기 위한 Enhanced for문이라는 반복문이 새롭게 추가되었다. 이 반복문은 배열과 컬렉션 프레임워크에서 유용하게 사용됩니다. Enhanced for문은 명시한 배열이나 컬렉션의 길이만큼 반복되어 실행됩니다. 루프마다 각 요소는 명시한 변수의 이름으로 저장되며, 명령문에서는 이 변수를 사용하여 각 요소를 참조할 수 있습니다. 예시 1234567int[] arr = new int[]&#123;1,2,3,45&#125;;for(타입 변수명 : 배열 또는 컬렉션)&#123; // 반복할 문장&#125;for(int e : arr)&#123; System.out.print(e+\" \");&#125; 타입은 배열 또는 컬렉션의 요소 타입과 일치해야 한다. 배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다. 하지만, Enhanced for문은 요소를 참조할 때만 사용하는 것이 좋으며, 요소의 값을 변경하는 작업에는 적합하지 않습니다. 다음 코드를 통해 확인할 수 있습니다. 12345678910111213for(int i=0;i&lt;arr1.length;i++)&#123; arr1[i]+=10; // 1&#125;for(int e : arr2)&#123; e+=10; // 2&#125;for (int e : arr1) System.out.print(e+\" \");System.out.println();for (int e : arr2) System.out.print(e+\" \"); 1번에서는 for문을 이용하여 각 배열 요소에 10을 더하고 있다. for문을 사용하면, 각 배열 요소의 값을 쉽게 변경할 수 있다. 2번에서는 Enhanced for문을 이용하여 각 배열 요소에 10을 더하고 있다. 하지만 실행 결과를 살펴보면, 원본 배열에는 아무런 변화가 없음을 알 수 있다. 이유는 Enhanced for문 내부에서 사용되는 배열 요소는 배열 요소 그 자체가 아닌 배열 요소의 복사본이기 때문이다. 따라서 Enhanced for문에서 배열 요소의 값을 변경하여도 원본 배열에는 아무런 영향을 주지 못하게 된다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 3. 제어문","slug":"java-basic-3","date":"2018-08-06T09:41:07.000Z","updated":"2020-04-22T07:48:18.307Z","comments":true,"path":"2018/08/06/java-basic-3/","link":"","permalink":"https://woovictory.github.io/2018/08/06/java-basic-3/","excerpt":"","text":"# 제어문 원하는 결과를 얻기 위해서 순차적인 흐름을 제어해야 하는 경우가 생긴다. 이 때 사용하는 명령문을 제어문이라고 하며, 조건문과 반복문 등이 이에 해당한다. 조건문 주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다. 가장 기본이 되는건 if문이다. 1. if문 조건식의 결과가 참이면 주어진 명령문을 실행하며, 거짓이면 아무것도 실행하지 않는다. 12345String name = \"이승우\";if(name == \"이승우\")&#123; System.out.println(name); // 조건식의 결과가 참일 때 실행하고자 하는 명령문&#125; 2. if / else 문 if문과 함께 사용하는 else문은 if문과는 반대로 주어진 조건식의 결과가 거짓이라면 주어진 명령문을 실행한다. 12345if(ch&gt;='a' &amp;&amp; ch&lt;='z')&#123; System.out.println(\"해당 문자는 영문 소문자입니다.\");&#125; else&#123; System.out.println(\"해당 문자는 영문 소문자가 아닙니다.\");&#125; 3. if/ else if / else 문 if/else if/else문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if/else 문이 연달아 나온 것뿐입니다. 이러한 if/else if/else문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if문을 좀 더 간결하게 표현할 수 있습니다. 4. switch문 if/else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문이다. 이러한 switch문은 if/else 보다 가독성이 더 좋으며, 컴파일러가 최적화를 쉽게 할 수 있어 속도 또한 빠른 편이다. 하지만 switch문의 조건 값으로는 int형으로 승격할 수 있는(integer promotion) 값만이 사용될 수 있다. 즉, 자바에서는 switch 문의 조건 값으로 byte, short, char, int 형의 변수나 리터럴을 사용할 수 있다. 또한, 이러한 기본 타입에 해당하는 데이터를 객체로 포장해주는 래퍼 클래스(Wrapper class) 중에서 위에 해당하는 Byte, Short, Character, Integer 클래스의 객체도 사용할 수 있습니다. enum 키워드를 사용한 열거체(enumeration type)와 String 클래스의 객체도 사용할 수 있습니다. 따라서 switch문은 if/else 문보다는 사용할 수 있는 상황이 적습니다. 1234567891011121314151617181920switch(ch)&#123; case 'a': System.out.println(\"해당 문자는 a입니다.\"); break; case 'e': System.out.println(\"해당 문자는 e입니다.\"); break; case 'i': System.out.println(\"해당 문자는 i입니다.\"); break; case 'o': System.out.println(\"해당 문자는 o입니다.\"); break; case 'u': System.out.println(\"해당 문자는 u입니다.\"); break; default: System.out.println(\"해당 문자는 모음이 아닙니다.\") breakl&#125; 각 case절, default 절은 반드시 break 키워드를 포함해야 한다. switch문에서 사용된 break 키워드는 조건 값에 해당하는 case/default절이 실행된 뒤에 switch문을 빠져나가게 해준다. break 키워드가 없다면 해당 조건 이후의 case절이 전부 실행된다. 5.삼항 연산자에 의한 조건문 간단한 if/else 문은 삼항 연산자를 이용하여 간결하게 표현할 수 있다. 1234조건식? 반환값1 : 반환값2//조건식의 결과가 참이라면 반환값1을 반환하고, 거짓이라면 반환값2를 반환합니다. # 반복문 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다. 프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나이다. while문 while문은 특정 조건을 만족할 때까지 계속해서 주어진 명령문을 반복 실행합니다. 먼저 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행한다. 그리고 조건식의 결과를 변경하는 명령문이 실행된다. 내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단한다. 조건식을 만족할 때까지 반복문을 수행한다. 12345int i=0;while(i&lt;5)&#123; System.out.println((i+1)+\"번째 실행중 입니다.\"); i++;&#125; while문의 내부에 조건식의 결과를 변경하는 명령문이 존재하지 않을 때는 프로그램이 무한루프에 빠지게 된다. 이 경우 영원히 종료되지 않습니다. while문을 작성할 때는 조건식의 결과가 어느 순간 거짓을 갖도록 조건식의 결과를 변경하는 명령문을 반드시 포함시켜야 한다. 위의 코드에서 i++ 명령문을 제거하면 무한 루프에 빠지게 된다. do / while문 while문은 루프에 진입하기 전에 먼저 조건식부터 검사한다. 하지만, do/while문은 먼저 루프를 한 번 실행한 후에 조건식을 검사한다. 즉, do/while문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행한다. for문 for문은 while문과는 달리 자체적으로 초기식, 조건식, 증감식을 모두 포함하고 있는 반복문이다. 따라서 while문보다는 좀 더 간결하게 표현할 수 있다. 12345int i;for(i=0;i&lt;5;i++)&#123; System.out.println(\"for 문이 \" + (i + 1) + \"번째 반복 실행중입니다\");&#125;System.out.println(\"for 문이 종료된 후 변수 i의 값은 \"+ i + \"입니다.\"); for문 안에서만 사용하는 변수를 초기식에서 직접 선언할 수 있습니다. 이렇게 for문에서 직접 선언된 변수는 for문이 종료되면 같이 소멸된다. # 기타 제어문 일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행한다. 하지만, continue문과 break문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와준다. continue문 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 조건식의 판단으로 넘어가게 해준다. 보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용된다. 1234567for(int i=0;i&lt;=100;i++)&#123; if(i%5 == 0 || i%7 == 0)&#123; System.out.println(i); &#125;else&#123; continue; &#125;&#125; break문 루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행한다. 즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용한다. 가장 가까운 반복문을 빠져나가는 것이다. 이름을 가지는 반복문(break with label) 일반적인 break문은 단 하나의 반복문만을 빠져나가게 해준다. 따라서 여러 반복문이 중첩된 상황에서 한 번에 모든 반복문을 빠져나가거나, 특정 반복문까지만 빠져나가고 싶을 때는 다른 방법을 사용해야 한다. 이때 사용할 수 있는 방법이 반복문에 이름(label)을 설정하는 것이다. 가장 바깥쪽 반복문이나 빠져나가고 싶은 특정 반복문에 이름을 설정한 후, break 키워드 다음에 해당 이름을 명시하면 된다. 그러면 해당 break 키워드는 현재 반복문이 아닌 해당 이름의 반복문 바로 다음으로 프로그램의 실행을 옮겨준다. 단, 이때 이름(label)은 가리키고자 하는 반복문의 키워드 바로 앞에 위치해야 한다. 이름과 반복문의 키워드 사이에 명령문이 존재하면, 자바 컴파일러는 오류를 발생시킨다. 123456789101112llLoop : for (int i = 2; i &lt; 10; i++) &#123; for (int j = 2; j &lt; 10; j++) &#123; if (i == 5) &#123; break llLoop; &#125; System.out.println(i + \" * \" + j + \" = \" + (i * j)); &#125; &#125; System.out.println(\"구구단 4단까지 출력!\"); 12345678결과2 * 2 = 42 * 3 = 62 * 4 = 8...4 * 7 = 284 * 8 = 324 * 9 = 36 이름(label)을 가지는 반복문을 통해서 구구단 2단~4단까지 출력하는 코드이다. C언어나 C++과는 달리 자바에는 goto문이 없다. 이렇게 반복문을 가리키는 이름(label)은 break문이나 continue문에만 사용될 수 있다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Java] 2. 연산자","slug":"java-basic-2","date":"2018-08-03T14:41:53.000Z","updated":"2020-04-22T07:48:19.865Z","comments":true,"path":"2018/08/03/java-basic-2/","link":"","permalink":"https://woovictory.github.io/2018/08/03/java-basic-2/","excerpt":"","text":"# 연산자 x&lt;&lt;2+1 : 쉬프트 연산자(&lt;&lt;)는 덧셈 연산자보다 우선순위가 낮습니다. 그래서 해당 식은 x&lt;&lt;(2+1)과 같습니다. data &amp; 0xFF == 0 : 논리연산자(&amp;)는 비교연산자(==)보다 우선순위가 낮으므로 비교연산을 먼저 수행한 후에 논리연산이 수행됩니다. 따라서 해당 식은 data &amp; (0xFF == 0)과 같습니다. x&lt;-1 || x&gt;3 &amp;&amp; x&lt;5 : 논리연산자 중에서 AND를 의미하는 &amp;&amp;가 OR을 의미하는 ||보다 우선순위가 높습니다. 그래서 해당 식은 x&lt;-1 || (x&gt;3 &amp;&amp; x&lt;5)과 같습니다. 증감 연산자의 연산 순서 : 증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라집니다. 다음 예제를 통하여 확인해볼 수 있습니다. 123456int x = 10;int y = x-- + 5 + --x;System.out.println(\"x : \"+x+\", y : \"+y);// 결과x : 8, y : 23 instanceof 연산자 : 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환해준다. 즉, 해당 객체가 어떤 클래스나 인터페이스로부터 생성되었는지를 판별해 주는 역할을 한다. instanceof 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 true를, 아니면 false를 반환한다. 123456789101112131415class A&#123;&#125;class B extends A&#123;&#125;public static void main(String[] args)&#123; A a = new A(); B b = new B(); System.out.println(a instanceof A); System.out.println(b instanceof A); System.out.println(a instanceof B); System.out.println(b instanceof B);&#125;// 결과truetruefalsetrue 형 변환 산술 변환 : 연산을 수행하기 전 피연산자 타입의 일치를 위해 자동 형 변환되는 것을 말한다. 이항 연산뿐만 아니라 단항 연산에서도 일어난다. 규칙은 다음과 같습니다. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치) 피연산자의 값 손실을 최소화한다. long + int -&gt; long + long -&gt; long float + int -&gt; float + float -&gt; float 피연산자의 타입이 int보다 작은 타입이면 int로 변환됩니다. JVM의 피연산자 스택이 피연산자를 4 Byte로 저장하기 때문에 int형보다 작은 데이터 타입은 int형으로 변환된 후 연산이 수행된다. byte + short -&gt; int + int -&gt; int char + short -&gt; int + int -&gt; int 그리고 int보다 작은 타입, 예를 들면 char나 short의 표현범위가 좁아서 연산 중에 오버플로우(Overflow)가 발생할 가능성이 높기 때문에 만들어진 것입니다. 12345678long a = 1000000 * 1000000;long b = 1000000 * 1000000L;System.out.println(\"a = \"+a);System.out.println(\"b = \"+b);// 결과a = -727379968;b = 1000000000000; 위의 예제에서 '1000000 * 1000000’의 결과가 1000000000000(2 * 10의 12승)임에도 불구하고, -727379968라는 결과가 출력된다. 그 이유는 int 타입과 int 타입의 연산 결과는 int 타입인데, 연산결과가 int 타입의 최대 값인 1000000000(2 * 10의 9승)을 넘으므로 오버플로우(Overflow)가 발생했기 때문이다. 이미 오버플로우가 발생한 값을 아무리 long 타입의 변수에 저장해도 소용 없다. b에서 처럼 1000000L으로 형 변환을 통해서 1000000도 long형으로 타입을 맞춘 후에 연산을 수행한 값을 long형 타입의 변수 b에 저장한다면 올바른 결과를 얻을 수 있다. 123456789char c1 = 'a'; // c1에는 문자 'a'의 코드값인 97이 저장됩니다.char c2 = c1; // c1에 저장되어 있는 값이 c2에 저장됩니다.char c3 = ' '; // c3를 공백으로 초기화int i = c1 + 1; // 'a'+1 -&gt; 97 + 1 -&gt; 98c3 = (char)(c1+1);c2++;c3++; 위 예제에서 c2++; 대신에 c2 = c2+1;을 사용하면 에러가 발생하게 됩니다. 이유는 c2+1의 연산결과는 int형이며, 그 결과를 다시 c2에 담으려면 형변환 연산자를 이용해 char형으로 형변환해야 하기 때문이다. 123char c1 = 'a';char c2 = c2+1; // 컴파일 에러 발생 Ochar c3 = 'a'+1; // 컴파일 에러 발생 X ‘a’+1은 리터럴간의 연산이기 때문에 에러가 발생하지 않는다. 상수 또는 리터럴 간의 연산은 실행과정 동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. 컴파일러가 미리 덧셈 연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다. 수식에 변수가 들어가있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형 변환을 해줘야 한다. char ch2 = (char)(c1+1) 그렇지 않으면 컴파일 에러가 발생한다. 12double f = 0.1f;double d = 0.1; float 타입의 값을 double 타입으로 형 변환하면, 부호와 지수는 달라지지 않고 그저 기수의 빈자리를 0으로 채울뿐이므로 0.1f를 double 타입으로 형 변환해도 그 값은 여전히 달라지지 않는다. 즉, float 타입의 값을 정밀도가 더 높은 double 타입으로 형변환했다고 해서 오차가 적어지는 것은 아니다. ==와 equals() 차이 형태의 차이 가장 단순한 차이점은 형태의 차이다. equals()는 메소드이다. 객체끼리 내용을 비교할 수 있도록 한다. == 는 비교를 위한 연산자이다. 주소값 비교와 내용 비교 비교할 수 있는 대상에 대한 부분이다. equals() 메소드는 비교하고자 하는 대상의 내용 자체를 비교한다. == 연산자는 비교하고자 하는 대상의 주소값을 비교한다. 1234567891011121314String str1 = \"abc\";String str2 = new String(\"abc\"); if(str1 == str2)&#123; System.out.println(\"같은 문자열입니다.\"); &#125; else &#123; System.out.println(\"다른 문자열입니다.\"); &#125;if(str1.equals(str2))&#123; System.out.println(\"같은 문자열입니다.\");&#125; else &#123; System.out.println(\"다른 문자열입니다.\");&#125; str1과 str2의 내용이 &quot;abc&quot;로 같은데도 ==로 비교하면 false의 결과를 얻게 된다. 내용은 같지만 str1과 str2가 서로 다른 객체이기 때문이다. 그러나 equals()는 객체가 달라도 내용이 같으면 true를 반환한다.그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다. 효율적인 연산 효율적인 연산 OR 연산 '||'의 경우, 두 피연산자 중 어느 한 쪽만 '참’이어도 전체 연산결과가 '참’이므로 좌측 피연산자가 'true(참)'이면, 우측 피연산자의 값은 평가하지 않는다. AND 연산 '&amp;&amp;'의 경우, 어느 한 쪽만 '거짓(0)'이어도 전체 연산결과가 '거짓(0)'이므로 좌측 피연산자가 '거짓(0)'이면, 우측 피연산자의 값은 평가하지 않는다. 비트 XOR 연산자 '^'는 두 피연산자의 비트가 다를 때만 1이 된다. 그리고 같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아온다는 특징이 있어서 간단한 암호화에 사용된다. 비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산 결과는 32자리의 2진수입니다. 쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int 타입으로 자동 변환되고 연산결과 역시 int 타입이 됩니다. 그러나 쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않습니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"생활코딩 :: express","slug":"open-tutorials-4","date":"2018-08-03T04:13:32.000Z","updated":"2020-05-12T15:14:00.166Z","comments":true,"path":"2018/08/03/open-tutorials-4/","link":"","permalink":"https://woovictory.github.io/2018/08/03/open-tutorials-4/","excerpt":"","text":"Express IP : 어떠한 컴퓨터를 식별하는 식별자 Port : 그 컴퓨터 안에 설치되어 있는 서버들 중에서 어떤 서버를 사용할 것인가에 대한 식별자 우리가 웹 서버를 만든 다음에 그 웹서버를 어떤 포트가 실행시킬 것이지를, 바라보게 할 것인지를 결정해야 합니다. 컴퓨터에는 0~65535개의 포트가 있고, 우리는 이 포트 중에서 어떤 특정한 웹서버를 만든 다음에 그 웹 서버가 특정한 포트를 바라보게 하면 사용자의 요청은 그 포트를 향해서 들어오게 됩니다. 1234567891011121314const http = require('http');const hostname = '127.0.0.1';const port = 1339;var server = http.createServer(function(req, res)&#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('Hello World\\n');&#125;);server.listen(port, hostname, function()&#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`); // 만들어진 서버를 가지고 실제로 그 포트로 사용자가 들어왔을 때, 어떤 내용을 출력할 것인가는 위에서 작성할 수 있습니다.&#125;); http라는 변수에 http라는 객체가 담겨있는데, 그 객체가 가지고 있는 createServer라는 함수를 호출해서 서버를 만듭니다. createServer에 의해서 서버가 만들어지고 만들어진 서버를 우리가 제어할 수 있도록 객체를 리턴합니다. 실제로 그 포트로 사용자가 들어왔을 때 어떤 내용을 출력할 것인가는 이 함수에서 정의할 수 있습니다. 역시나 이 함수도 익명함수를 통해 작성합니다. 이 함수는 두 개의 인자를 받는데, req(요청과 관련된 것), res(응답과 관련된 것) 서버가 특정 포트를 바라보게 하기 위해서 Port를 매개변수로 넘겨줍니다. 사용자가 우리 서버로 접속할 때 여러가지 방법으로 접속할 수 있습니다. 그래서 어떤 IP를 타고 들어온 사용자를 수용할 것인가를 확인하기 위해서 hostname을 적습니다. 시간이 좀 걸릴 수 있는 작업이기 때문에 listen이라는 메소드는 Callback으로 비동기적으로 작동합니다. 그래서 listen이 완료되었을 때 이 callback이 실행되도록 약속이 되어있는 것입니다. 이것도 편한지만, 이런 것들을 우리가 훨씬 더 적은 코드로 이런 역할을 하면서도 더 많은 일을 할 수 있도록 해주는 도구들 (프레임워크)이 존재합니다. Node를 직접 사용해서 웹 애플리케이션을 구현하는 것도 좋겠지만, 손이 많이 가기 때문에 Node를 이용해서 만들어진 프레임워크를 통해서 웹 개발을 해볼 것입니다. 그것이 바로 Express라는 것입니다. Express 설치 먼저 설치를 하기 전에 해당 디렉토리를 Npm이 사용할 수 있는 프로젝트로 만들기 위해서 ‘npm init()’ 명령어를 수행합니다. 그 다음 ‘npm install --save express’ 명령어를 통해 express를 설치합니다. 이제 해당 프로젝트 폴더에 설치해서 Express라는 프레임워크를 사용할 수 있는 기본적인 준비는 끝났습니다. Express - 간단한 웹애플리케이션 만들기 지금 app.js 라는 파일을 만들 것입니다. 이 파일을 메인 파일이라고 합니다. 또는 메인 애플리케이션(엔트리 애플리케이션)이라고 부릅니다. 최초의 진입점이 되는 파일입니다. app.js라는 이름은 express에서 권장하는 메인 애플리케이션의 이름입니다. 1234567891011121314151617var express = require('express');// require를 통해 express 모듈을 리턴받고 express라는 변수를 통해서 모듈을 제어할 수 있습니다.// 다음은 express라는 모듈을 통해서 application 객체를 만듭니다.var app = express();// express라는 모듈은 함수입니다. 그래서 실행하게 되면 함수는 application라는 객체를 리턴합니다.app.get('/', function(req, res)&#123; res.send(\"Hello Homepage\"); &#125;)app.get('/login', function(req, res)&#123; res.send(\"Login please\"); &#125;)app.listen(3000, function()&#123; console.log(\"Connected 3000 Port!\"); &#125;) Home 화면에 접속했을 때 우리가 실행시킨 get이라는 메소드를 통해서 사용자가 홈으로 접속하면 두 번째 인자로 전달한 callback 함수가 실행되도록 약속되어 있습니다. 함수의 인자로 첫 번째 매개변수는 req, 두 번째 매개변수는 res가 들어온다고 약속되어 있습니다. 함수를 이렇게 정의하면, get이라는 함수는 사용자가 Home으로 들어오고 이것이 완료되었을 때, 인자로 전달된 함수를 실행시키면서 첫 번째 매개변수의 값으로 사용자가 요청한 것과 관련된 request 객체를 전달하는 것이고 두 번째로 사용자가 요청한 정보에 대해서 응답을 할 수 있는 여러가지 방법을 담고 있는 응답에 대한 객체를 전달하도록 약속이 되어 있습니다. 정리하자면, get이라는 메소드는 사용자가 어떠한 경로로 들어왔을 때, 어떠한 것이 실행이 될 것인가를 결정하는 역할을 합니다. 이러한 역할을 하는 것을 router라고 부르며 router가 하는 일을 routing이라고 합니다. 우리가 배우는 메소드 중 get, post, put, delete가 router의 역할을 하는 메소드입니다. Routing 사용자 : 웹 브라우저를 사용해서 우리의 애플리케이션으로 접속하는 사람 우리의 애플리케이션은 Router와 Controller라는 것으로 이루어져 있습니다. 사용자가 '/'로 들어오게 되면 get('/')가 받고 이것을 두 번째 인자로 전달되었던 익명 함수를 실행시키고 &quot;Welcome to Home Page&quot;라는 정보를 사용자에게 응답해주고 있습니다. 사용자가 '/login’으로 접속하면 저 get('/login')가 받고 두 번째 인자인 익명 함수 안에 있는 코드를 실행시켜서 사용자에게 &quot;login please&quot;라고 하는 정보를 사용자에게 응답해주고 있습니다. 그래서 get이라고 하는 함수의 역할은 사용자의 요청과 그 요청에 대한 처리인 Controller를 중개해주는 역할을 하는 것이 라우터의 역할입니다. 이 라우터라고 하는 것은 웹 애플리케이션을 만든다라고 했을 때 가장 중요한 것 중 하나입니다. 연결성 Javascript와 Nodejs의 관계 연결이라는 측면에서 보면 기본적으로 Node.js는 다음과 같은 기능을 제공합니다. FS : File을 읽고 쓰는 시스템 HTTP : 네트워크를 통해 어떠한 일을 할 수 있는 기능 OS : 운영체제를 제어할 수 있는 여러가지 기능 Nodejs가 제공하는 기본적인 기능들을 Javascript라고 하는 프로그래밍 언어의 문법에 맞게 결합해서 우리가 의도하는 바에 해당되는 프로그램을 만들어 낼 수 있습니다. 일단 한 번 프로그램을 만들면 그 프로그램은 언제든지 똑같이 실행되는, 재사용할 수 있는 애플리케이션이 됩니다. 이것이 가능한 이유는 Nodejs가 기초적인 명령들을 제공하고 Javascript이라는 프로그래밍 언어가 노드가 제공하는 명령들을 조합해서 새로운 명령을 만들어 낼 수 있습니다. 그렇게 해서 만들어 낼 수 있는 명령어의 개수는 정말 많고 다양한 가능성을 제공합니다. 이것과 비슷한 관계에 있는 또 다른 하나는 Module과 NPM의 관계입니다. Module : 우리의 프로그램 안에서 부품으로 사용될 작은 프로그램들을 말합니다. 이 세상에는 여러가지 모듈들이 만들어져 있고 그 중에는 우리가 만든 것, 우리가 만들지 않은 것이 있습니다. NPM : 다양한 모듈들을 NPM을 통해서 우리의 애플리케이션에 담아서 다양한 형태의 애플리케이션을 만들어 낼 수 있습니다. (ex. Express, Underscore, Jade) Router : 사용자의 접속을, 사용자의 요청을 어떤 Controller에 전달해줄 것인가라고 하는 중개자의 역할을 합니다. Controller : 예를 들면, 회원을 가입할 때 사용하는 Controller, 홈페이지의 표현을 위한 Controller, 에러 화면을 만들어주는 Controller가 있습니다. JavaScript, NPM, Router 이러한 연결하는 녀석들에게 연결할 대상을 제공해주는 것이 Node.js, Module, Controller 입니다. 정적파일을 서비스하는 법 정적인 정보 : 사람이 한 번 작성한 것이 즉, 만들어진 것이 언제나 똑같이 보이면 이것을 정적인 정보라고 합니다. 동적인 정보 : 프로그래밍적으로 만들어진 정보를 동적인 정보라고 합니다. 12345678910111213141516var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function(req, res)&#123; res.send(\"Hello Homepage\"); &#125;)app.get('/login', function(req, res)&#123; res.send(\"Login please\"); &#125;)app.listen(3000, function()&#123; console.log(\"Connected 3000 Port!\"); &#125;) 정적인 파일을 서비스하고 싶다면 app.use(express.static('public')); 이 한줄을 추가합니다. public이라는 디렉토리에 우리가 정적인 파일을 갖다 놓으면 그 정적인 파일을 사용자에게 서비스 할 수 있습니다. 웹 페이지를 표현하는 방법 웹 페이지를 사용자에게 서비스 하는 방법은 두 가지가 있다. 정적인 파일 전달하는 법 한 번 만들어지면 언제나 똑같은 모습인 Html public이라는 디렉토리에 static.html 파일을 놓습니다. 서버를 동작시키고, localhost:3000/static.html로 접근하면 작성된 웹 페이지를 확인할 수 있습니다. 내용을 수정하면 서버를 껐다 킬 필요 없이 내용을 바로 반영시킬 수 있습니다. 하지만, 웹 페이지 상에서 반복적인 일들이나 추가적인 사항이 많이 생긴다면 반영하기 어렵습니다. 그 하나의 예로는 현재 시간을 보여주는 것이라고 할 수 있습니다. 자바스크립트에서는 여러 줄의 코드를 삽입하고 싶다면 \\를 붙이면 가능하지만, 코드의 가독성이 많이 떨어집니다. 자바스크립트의 새로운 표준에는 formatted text라는 기능이 추가되었습니다. 12345678910111213141516171819202122app.get('/dynamic', function(req, res)&#123; var time = Date(); var lis = ' '; for(var i = 0;i&lt;5;i++)&#123; lis = lis + '&lt;li&gt;Coding&lt;/li&gt;'; &#125; var output = ` &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; Hello, Dynamic~~~~~ &lt;ul&gt; $&#123;lis&#125; &lt;/ul&gt; $&#123;time&#125; &lt;/body&gt; &lt;/html&gt;`; res.send(output);&#125;) 동적인 파일 전달하는 법 우리가 작성한 코드가 다시 실행되어야 하기 때문에 서버를 껐다가 다시 node app.js를 실행해주어야 합니다. 내부적으로 dynamic하게 웹 코드를 작성하면 코드의 짧은 수정을 통해서 반복적인 작업의 횟수가 프로그래밍적으로 달라지기 때문에, 자바스크립트 코드에서 일부분만 수정하면 되므로 정확하게 원하는만큼 반복시킬 수 있습니다. 하지만, 정적인 파일의 경우에는 요청이 들어올 때마다 node가 그것을 잡아서 던져주기 때문에, 우리가 굳이 껐다 킬 필요가 없습니다. 이로 인해서 정적인 파일을 서비스하는 것이 좀 더 코드를 짜는데는 편리합니다. 물론 동적인 파일도 자동화 시키는 방법이 있지만, 아직은 배우지 않고 다음에 배울 것 입니다. 또는 현재 시간을 웹 페이지에 표시하고 싶다면 Date()라는 API를 사용하여 동적인 파일을 서비스하는 방법을 통해서 웹 페이지에 보여줄 수 있습니다. 변수의 값을 Html 코드에 삽입하면 문자열로 인식하기 때문에 ${time}과 같은 방법을 써서 변수를 포함시킬 수 있도록 합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"생활코딩 :: 동기와 비동기 프로그래밍","slug":"open-tutorials-3","date":"2018-08-02T11:09:51.000Z","updated":"2020-05-12T15:14:01.758Z","comments":true,"path":"2018/08/02/open-tutorials-3/","link":"","permalink":"https://woovictory.github.io/2018/08/02/open-tutorials-3/","excerpt":"","text":"동기와 비동기 프로그래밍 동기(Synchronous) 줄여서 sync라고도 부릅니다. 예를 들어서, 빨래와 설거지 청소의 3가지 일을 해야 한다면 빨래를 1시간 동안하고 끝낸 다음에 설거지를 1시간 동안하고 그 다음에 청소를 1시간 동안하고 끝냅니다. 총 3시간에 걸쳐서 일을 끝냅니다. 즉, 순차적으로 일을 스스로 끝내 나가는 방식입니다. 비동기(Asynchronous) 일단은 빨래하는 업체 A가 있고, 설거지 하는 업체 B, 청소하는 업체 C가 있다고 가정하면 빨래를 하기 위해서 A 업체에 전화를 하고 빨래가 끝나면 알려 달라고 한 다음에 전화를 끊고 B 업체에 전화해서 청소를 부탁하고 끝나면 알려 달라하고 전화를 끊고, C 업체에 전화해서 청소를 부탁하고 끝나면 알려 달라고 합니다. 전화를 하는데 각각 1분씩 걸렸다면 총 3분만에 일처리를 시작했다는 걸 끝낼 수 있습니다. 시간이 지난 후에 각각의 업체로부터 업무가 끝났다는 알림을 받을 수 있습니다. 어떤 업무가 먼저 끝날 지 알 수가 없다는 단점이 있습니다. 예시 Node.js 사이트에서 document(문서)를 참고해서 file system 모듈을 참고합니다. file system 모듈은 Node.js를 이용해서 file을 제어하는 것과 관련된 기능을 합니다. Node.js는 기본적으로 시간이 필요한 작업들(I/O가 필요한 작업)을 비동기적으로 처리합니다. 우리가 특별히 원할 경우에는 동기적으로 일을 처리할 수 있도록 Sync라는 키워드가 붙은 메소드들이 존재합니다. 동기식 코드 123456789var fs = require('fs');console.log(1); // 실행 순서 1var data = fs.readFileSync('textdata.txt',&#123;encoding:'utf8'&#125;);console.log(data); // 실행 순서 2// 결과1Hello Sync And Async 만약 readFileSync를 통해서 파일을 읽는데 시간이 오래 걸린다면 동기적 처리 방식에서는 그 시간 동안 다른 작업을 수행할 수 없습니다. 비동기식 코드 1234567891011121314var fs = require('fs');console.log(2); // 실행 순서 1var data = fs.readFile('textdata.txt',&#123;encoding:'utf8'&#125;, function(err, data)&#123; console.log(3); // 실행 순서 3 console.log(data); // 실행 순서 4 &#125;);console.log(4); // 실행 순서 2// 결과243Hello Sync And Async readFile을 통해서 파일을 읽는 동안 다른 작업을 먼저 수행합니다. 그리고 readFile이 파일을 다 읽고 에러가 없다고 판단하면 readFile 함수의 매개변수로 전달된 익명 함수(즉, Callback 함수)의 data라는 매개변수 값으로 textdata.txt 파일의 내용을 전달하고 이를 호출합니다. 그리고 이후 나머지 동작들을 수행하게 됩니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"생활코딩 :: 콜백(Callback) 함수","slug":"open-tutorials-2","date":"2018-08-02T10:05:18.000Z","updated":"2020-05-12T15:14:03.413Z","comments":true,"path":"2018/08/02/open-tutorials-2/","link":"","permalink":"https://woovictory.github.io/2018/08/02/open-tutorials-2/","excerpt":"","text":"Callback 함수 Callback 함수를 배웠습니다. 우선, Terminal에서 javascript로 작성된 파일을 node로 실행시킬 때는 node hello.js를 통해서 실행시키면 됩니다. 하지만, 지금 배우는 환경에서는 node라고 입력하고 인터프리터 환경에서 실습을 진행할 예정입니다. 1234567a = [3,1,2];function b()&#123; // 여러번 사용될 함수라면 이름을 붙여줍니다. return v2-v1;&#125;a.sort(); // [1,2,3]a.sort(b); // [3,2,1]console.log(a); 123456a = [3,1,2];a.sort(function(v1, v2)&#123; // 이 경우 정렬할 때 한번만 사용할 목적이라면 익명 함수를 이용해 callback함수로 사용 return v2-v1; &#125;);console.log(a); 위의 코드를 보면 sort라는 함수의 인자로 다른 함수를 전달했고, 저렇게 전달된 함수를 callback 함수라고 부릅니다. callback 함수를 우리는 정의했습니다. 하지만, 우리가 callback 함수를 호출하지 않았고, sort라는 함수가 필요할 때마다 내부적으로 b를 호출하고 있습니다. 다시 말해서, b라는 함수는 우리가 호출할 함수가 아니라 누군가에 의해서 나중에 호출 당할 함수입니다. 그리고 sort라는 함수가 가지는 기본적인 방법을 확장할 수 있는 가능성을 우리가 어떠한 logic을 주입함으로써 할 수 있었습니다. 이것이 Callback을 우리가 사용하는 이유입니다. Callback 함수를 사용하여 프로그램의 흐름을 끊지 않음으로서, Non-Blocking 코드를 사용하는 서버는 Blocking 코드를 사용하는 서버보다 더 많은 양의 요청을 빠르게 처리할 수 있습니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"생활코딩 :: 모듈과 NPM","slug":"open-tutorials-1","date":"2018-08-02T08:51:59.000Z","updated":"2020-05-12T15:14:06.091Z","comments":true,"path":"2018/08/02/open-tutorials-1/","link":"","permalink":"https://woovictory.github.io/2018/08/02/open-tutorials-1/","excerpt":"","text":"인터넷의 동작 방법 클라이언트 : 웹 브라우저가 설치된 컴퓨터, 요청 서버 : Client가 요청한 정보를 응답 도메인 : 사람이 쉽게 이해할 수 있도록 만들어진 서버의 주소(이름) IP : 실제 웹 브라우저가 연결되는 주소 Port : 웹 서버를 실행시킬 때 6만개의 포트 중에 80번 포트에 웹 서버를 실행시킵니다. 즉, 웹 서버를 실행시켜놓고 80번에 해당되는 문에다가 웹 서버를 연결시켜 놓고, 웹서버가 80번 포트를 바라보게 합니다. 즉, 80번 포트를 리스닝하게 하는 것입니다. 사용자가 이 서버에 접속할 때, 예를 들어서 http://a.com:80 이렇게 접속하면 웹 브라우저는 a.com에 해당되는 컴퓨터를 찾고 a.com에 해당되는 컴퓨터한테 80번 포트와 연결하고 싶다라고 얘기를 합니다. 그럼 그 컴퓨터가 80번 포트를 연결해주기 때문에 웹 브라우저를 통해서 들어온 접속은 80번 포트에서 리스닝하고 있는 즉, 듣고 있는 웹 서버를 호출하고 그 웹서버가 요청을 받아서 웹 서버가 응답할 수 있게 됩니다. 이러한 과정이 인터넷의 동작 방법이라고 볼 수 있습니다. http로 접속하는 경우에는 80번 포트를 쓰자라는 약속이 되어 있기 때문에 끝에 붙이는 :80을 생략할 수 있습니다. 모듈과 NPM 모듈은 다른 말로는 부품이라고 할 수 있으며, 우리가 필요로 하는 모듈을 가져와서 쓸 수 있습니다. Node.js에서는 필요한 모듈을 가져와서 쓰기 위해서는 require라는 함수를 사용합니다. 12345678910111213141516171819202122232425const http = require('http');// http라는 변수에 http라는 서버를 구동시키기 위해서 필요한 모듈을 담은 것이다.// 이 http를 통해서 모듈을 제어할 수 있습니다.// 값이 한 번 할당이 되면 그 이후에는 값을 바꿀 수 없음.const o = require('os');console.log(o.platform());const hostname = '127.0.0.1';const port = 1338; http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; 'Content-Type': 'text/plain' &#125;); res.end('Hello World\\n');&#125;).listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;);// 이 코드가 웹브라우저를 통해서 요청한 내용을 받아서 우리에게 hello world라는 텍스트를// 전송한 것입니다.// createServer를 통해서 서버 한개를 만들고// listen을 통해서 그 서버가 컴퓨터 한 대를 리스닝하게 만든다.// 모듈은 부품과 같은 것이다. 그래서 가져다 쓸 수 있다.// 우리가 필요한 모듈을 가져다 쓸 수 있고 그러한 모듈을 가져다 쓰기 위해서는// require라는 함수를 호출해서 사용한다. NPM : Node Package Manager NPM -&gt; Node계의 앱스토어라고 부르기도 합니다. 어떠한 모듈을 우리의 프로젝트에 사용하기 쉽게 그리고 간편하게 설치하고 필요없으면 삭제할 수도 있고, 우리가 쓰고 있는 모듈이 기능 개선이 되었으면 업그레이드를 편리하게 해주고, 의존성 관리도 해줍니다. Node.js는 다양한 모듈을 제공합니다. HTTP, OS -&gt; Node.js가 제공하는 모듈 Date, String, Array -&gt; JavaScript가 제공하는 모듈 NPM은 다른 사람의 S/W를 가져와서 연결시켜주는 연결자의 역할을 하고 있습니다. 따라서 Node.js의 생태계의 중심에는 NPM이 있다고 할 수 있습니다. 이번에는 타인의 모듈을 사용하는 방법을 배워볼 것이고 그 방법으로서 NPM을 사용해볼 것입니다. NPM 소프트웨어 패키지의 종류 독립적으로 동작하는 소프트웨어 : npm install underscore -g g는 global의 약자이며, 전역적으로 실행할 수 있는 독립적인 소프트웨어의 설치 부품 모듈 : 모듈을 설치하기 전에 지금 현재 진행하고 있는 프로젝트 폴더를 npm의 패키지로 초기화하는 작업을 거쳐야 합니다. -&gt; npm init() 사용하고 정보들을 등록합니다. 이 정보들을 명령어 수행 후 package.json이라는 파일에 저장되어 생성됩니다. npm install underscore 해당 폴더, 즉 패키지에서 부품으로 사용할 수 있는 모듈을 설치하는 것입니다. npm install underscore --save --save 옵션을 주게 되면 underscore라는 모듈이 package.json 파일 안에 dependencies 항목으로 추가되기 때문에 이 프로젝트의 의존성을 명시적으로 표시해서 다른 디렉토리에서 이 프로젝트를 사용할 때 의존성을 갖고 있는 프로젝트를 쉽게 가져올 수 있습니다. 어떠한 모듈을 항상 프로젝트에 포함시킬 때는 --save 옵션을 사용하는게 좋습니다. 일시적으로 사용하는 모듈은 --save 옵션이 필요없습니다. npm install underscore 이렇게 옵션을 주면 해당 폴더, 즉 패키지에서 부품으로 사용할 수 있는 모듈을 설치하는 것입니다. npm install underscore --save 이렇게 --save 옵션을 주게 되면 underscore라는 모듈이 package.json 파일안에 dependencies 항목으로 추가되기 때문에 이 프로젝트의 의존성을 명시적으로 표시해서 다른 디렉토리에서 이 프로젝트를 사용할 때 의존성을 갖고 있는 프로젝트를 쉽게 가져올 수 있습니다. 그리고 npm을 이용해서 모듈을 사용하기 전에는 지금 현재 프로젝트 폴더를 npm의 패키지로 초기화해야 합니다. npm init()","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"Nodejs :: Nodejs?","slug":"nodejs-chap1","date":"2018-08-01T08:38:49.000Z","updated":"2020-05-12T15:14:15.927Z","comments":true,"path":"2018/08/01/nodejs-chap1/","link":"","permalink":"https://woovictory.github.io/2018/08/01/nodejs-chap1/","excerpt":"","text":"SOPT라는 동아리를 통해서 Client 즉, Android에 대해서 공부하면서 프로젝트를 진행해보고 App 개발에 대한 실력을 얻었고 관련 지식도 얻을 수 있었습니다. 저는 Android에 대해 더 공부하기 위한 발판으로 서버 공부를 하기 위해서 JavaScript와 Node.js를 공부할 계획입니다. 공부하는 내용은 이곳에 포스팅할 예정입니다. JavaScript 웹 브라우저에서 동작하는 스크립트 언어로 시작 다양한 분야에서 활용 가능, 풀스택개발까지 가능 가볍고 손쉽게 작성이 가능한 프로그래밍 언어 HTML 내에 코드를 삽입해서 사용 가능 거의 모든 브라우저에서 실행 가능 이벤트 중심 프로그래밍 Node.js의 등장으로 서버 사이드 개발 가능 클래스는 지원하지 않지만 객체 지향 프로그래밍 가능 대부분의 개념은 객체(기본 데이터타입, null, undefined) 함수조차 객체로 취급! -&gt; 일급 객체로 다뤄짐 실행 컨텍스트가 독특하다. -&gt; 스코프(객체의 유효범위)가 일반적이지 않다. 모든 객체는 프로토타입을 가짐 일급객체와 클로저의 특성으로 함수 지향 프로그래밍까지 가능 Javascript의 표준이 ECMAScript이고 현재는 ECMAScript6(줄여서 ES6)가 표준 Javascript 문법 Javascript는 변수 타입을 표시하지 않고, 값이 할당되는 과정에서 자동으로 자료형이 결정됩니다. =&gt; 그래서 같은 변수에 여러 자료형의 값을 대입할 수 있습니다. 자료형은 var, let, const로 표시 -&gt; Scope의 차이 String, Number, Boolean, undefined, null, Object의 자료형을 갖고 있습니다. ES6에서 Symbol이 추가됨 : primitive type이기 때문에 new로 생성 X 기본 타입 : Number, String, Boolean, undefined, null + Symbol 참조 타입 : Array, Function(Object) Object에는 배열, 함수, 정규표현식 등이 포함됩니다. 자료형 Number 다른 언어들처럼 여러 타입(short,int,long,byte) 등이 있지 않고, 정수값과 실수값을 구분하지 않습니다. 모든 숫자를 실수로 표현합니다.(64bit의 floating point type으로 저장) 그리고 비트연산도 가능하자 속도가 느립니다. 53bit의 정확도로 정수 표기 가능합니다. 즉, int형도 완벽히 표기 가능! String 2byte의 값들이 연속적으로 나열되어 있습니다. 0기반의 인덱싱 사용(다른 언어와 동일)합니다. 그리고 문자 하나를 표현하는 문자형은 제공하지 않습니다.(길이가 1인 문자열) 또한, ‘(작은 따옴표)’,&quot;(큰 따옴표)&quot; 둘 다 가능하며, 여러 문자열을 '+'를 이용해 연결할 수 있습니다. (+가 addition과 concatenation으로 사용되기 때문에 주의하여 사용해야 합니다.) 문자열을 수정하는 모든 메소드는 새로운 문자열을 반환합니다. Boolean true, false 중 하나의 값을 가지며, 비교의 결과로 생성됩니다. false : 0, “”, undefined, null, NAN(Not A Number) null, undefined null은 객체가 아님을 뜻하는 특수한 값입니다. undefined는 값이 없음을 나타내는 값으로 값 자체가 없거나 초기화 되어 있지 않거나 존재하지 않는 값에 접근할 때 사용합니다. 시스템 레벨에서는 undefined, 일반적인 프로그램 레벨에서는 null을 사용 Object 속성(property) : 키(key) - 값(value)의 쌍으로 이루어지며, 속성끼리는 쉼표(,)로 구분합니다. 키는 문자열만 가능하고 따옴표가 있어도 없어도 가능합니다. Array []로 감싸며, 값들이 순서대로 나열되어 있습니다. 배열의 원소에는 다른 데이터 타입들이 들어갈 수 있습니다. 기본 자료형 Number String : &quot; &quot;,’ ’ 둘 다 가능 Boolean : true/false Array : 0 이상의 임의의 종류의 값으로 이루어진 순서가 있는 리스트. 대괄호 [] 사용 Object : 순서가 없는 이름 - 값 의 쌍으로 이루어진 집합이며, 이름(키)은 문자열입니다. 중괄호 {} 사용 null 함수(Function) 일급객체 javascript는 함수형 프로그래밍 언어이며, 객체가 일급 객체(First Class Object)입니다. =&gt; 함수도 객체! =&gt; 함수가 일급 객체! 익명 함수(Anonymous Function) : 함수의 이름이 없는 함수 고차 함수(Higher-Order Function) : 함수를 인자로 받거나 반환할 수 있는 함수 일급 객체의 조건 (1). 변수나 데이터 구조 안에 담을 수 있습니다. (2). 다른 함수의 파라미터로 전달할 수 있습니다. (3). 반환값(return value)로 사용할 수 있습니다. (4). 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다. (5). 동적으로 프로퍼티 할당이 가능합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 변수나 데이터 구조 안에 담을 수 있습니다.var func1 = function()&#123; console.log(1);&#125;func1();// (1)// 다른 함수의 파라미터로 전달할 수 있습니다.var func2_1 = function()&#123; return 2;&#125;// var func2_2 = function(value)&#123; console.log(value);&#125;func2_2(func2_1());// (2)// 반환값(return value)로 사용할 수 있습니다.var func3 = function()&#123; return function()&#123; console.log(3); &#125;&#125;func3()(); // (3)// 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다.var func4 = function func44()&#123; console.log(4);&#125;func4();// (4)// 동적으로 프로퍼티 할당이 가능합니다.var func5 = function()&#123; console.log(5);&#125;func5.property = '55';console.log(func5.property);// (5) 함수의 생성 방법 함수 선언문을 사용한 생성 코드 블록 자체는 실행 가능한 코드는 아님 함수명이 반드시 정의되어야 함 일반적인 언어의 함수 정의와 같음 매개변수의 타입을 표시하지 않음 123function func1(n)&#123; console.log('func1 : '+n);&#125; 함수 표현식을 사용한 생성 함수 리터럴(표현식)로 특정 변수에 할당되거나 즉시 실행 가능한 코드 블록 일급 객체이므로 변수에 할당이 가능 함수의 이름은 선택 사항이고 함수 표현식에서 사용된 함수 이름은 외부에서 접근할 수 없음 -&gt; 그래서 보통 익명함수로 생성 후 변수명으로 사용합니다. 1234567var func2 = function(n)&#123; console.log('func2 : '+n);&#125;var func4 = function func44(n)&#123; console.log('func4 : '+n);&#125; 생성자 함수를 사용한 생성 함수가 일급 객체이기 때문에 객체 생성 방식과 비슷 new 키워드로 객체를 생성할 수 있는 함수 prototype을 사용하여 한 번만 메소드를 생성할 수 있음 자주 사용하지 않습니다. Json(JavaScript Object Notation) 속성 - 값의 쌍으로 이루어진 데이터 Object를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷을 말합니다. 일반적으로 서버에서 클라이언트로 데이터를 보낼 때 사용하는 포맷입니다. 또한, 자바스크립트에서 파생되어 자바스크립트의 구문 형식을 따르지만 언어 독립형 데이터 포맷입니다.-&gt; 자바스크립트에서만 사용하는 것이 아님! 공식 인터넷 미디어 타입 : application/json 프로퍼티 사이의 구분은 쉼표(,)로 하고 마지막 프로퍼티 끝에는 붙이지 않습니다. 아래와 같이 둘 다 가능합니다. 1234567891011&#123; \"name\" : \"이승우\", \"age\" : 25, \"married\" : false&#125;&#123; name : \"이승우\", age : 25, marrie\" : false&#125; 1. Object() 생성자 함수 이용 1234var server = new Object();server.name = \"이승우\";server.age = 26;server.married = false; 2. 객체 리터럴(표현식) 방식 이용 123456var server = &#123; name : \"이승우\", age : 25, married : false, gender : \"남자\"&#125; 3. 프로퍼티 접근 1234server[\"name\"];server[\"age\"];server.married;server.gender; 이처럼 대괄호 표기법을 이용하면 프로퍼티 이름을 문자열 형식으로 적어줘야 접근할 수 있습니다. 만약 server[name]으로 접근시 undefined 마침표 표기법을 이용해서 간단한게 .을 통해서 객체의 프로퍼티에 접근할 수 있습니다. 4. 객체 프로퍼티 순회 for in문을 사용해서 객체의 프로퍼티에 접근할 수 있습니다. 객체에 포함된 모든 프로퍼티에 대해 루프를 수행합니다. 123for(i in server)&#123; console.log(server[i]);&#125; 5. 객체 프로퍼티 삭제 delete연산자를 통해서 가능합니다. delete 연산자가 객체의 프로퍼티는 삭제할 수 있지만 객체 자체를 삭제할 수는 없습니다. 1delete(server.name); 배열 1var nameOfArray = [1, 2.5, \"sopt\",true, &#123;\"part\" : \"server\", \"name\" : \"이승우\"&#125;] 위의 코드처럼 배열의 원소에는 다른 데이터 타입들이 들어갈 수 있습니다. 또한, 함수도 객체이므로 들어갈 수 있습니다. 1. 배열 요소 추가 동적으로 배열 원소를 추가할 수 있습니다. 특히나, 값을 순차적으로 넣을 필요 없이 아무데나 넣을 수 있습니다. array.push(넣을값) -&gt; 가장 끝에 있는 인덱스 뒤에 넣습니다. array.splice(index,0,item) -&gt; 원하는 index에 item 값을 넣을 수 있습니다. 2. 배열 요소 삭제 delete를 통해 배열 요소를 삭제할 수 있습니다. 삭제를 하고 나서는 해당 인덱스의 값이 undefined로 남아 있습니다. 즉, 비어있는 상태로 남아있습니다. 1delete(nameOfArray[0]); 3. 배열 요소 접근 array[음이 아닌 정수 or 변수]로 배열 요소에 접근이 가능합니다. 그리고 현재 배열 내 없는 인덱스로 접근하더라도 out of bound 가 나지 않습니다. 4. 배열 요소 순회 1234567console.log(\"** 배열 요소 순회 예제 **\");for (var i = 0; i &lt; nameOfArray.length; i++) &#123; console.log(nameOfArray[i]);&#125; // 배열 내 없는 원소까지 undefined로 모두 출력for(var j in nameOfArray)&#123; console.log(nameOfArray[j]);&#125; // 배열 내 없는 원소는 출력하지 않음 5. 배열도 객체다! 배열이름.프로퍼티이름 = 값으로 프로퍼티를 추가하는 것이 가능합니다. 또한, length도 메소드가 아니라 객체의 프로퍼티입니다. 그래서 실제 배열의 길이와 관계없이 변경이 가능합니다. 인덱스에만 관계가 있기 때문에 배열 객체의 프로퍼티는 length에 포함되지 않습니다. 실행 컨텍스트 아직까지 무슨 이야기인지 잘 모르겠습니다…ㅜ_ㅜ 자바스크립트가 실행될 때 생성되는 하나의 실행 단위를 말합니다. C,C++,Java 등의 콜스택에 들어가는 하나의 실행정보와 비슷한 개념입니다. 실행 가능한 자바스크립트 코드 블록이 실행되는 환경입니다. 현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동합니다. 실행 컨텍스트 생성 과정 활성 객체 생성 arguments 객체 생성 스코프 정보 생성 변수 생성 -&gt; 여기서 선언이 이루어짐 this 바인딩 코드 실행 -&gt; 여기서 할당이 이루어짐 변수 타입별 스코프(영역) var : 함수 단위 스코프, 재선언 가능, 재할당 가능 let, const : 블록 단위 스코프 (일반적인 C,C++,Java) let : 재선언 불가능, 재할당 가능 const : 재선언 불가능, 재할당 불가능 호이스팅이란?? - 사실, 이 친구도 어려워요…ㅜ 변수, 함수의 선언부가 스코프 가장 위로 끌어올려지는 것을 말합니다. 블록 내부에 정의된 변수는 블록에 포함된 함수 전체에 선언되는 것과 같으므로 유효범위가 함수 전체로 확대됩니다. 반복문, 조건문 내부에 사용된 변수를 같은 함수 내라면 바깥에서 접근이 가능합니다. 또한 함수 표현식으로 정의되어 있으면 호이스팅이 발생하지 않습니다. 연산자의 종류 보통의 연산자는 다른 언어와 유사합니다. 그래서 일반적이지 않은 javascript의 연산자에 대해서 공부해보았습니다. 관계 연산자 두 피연산자의 관계를 검사하여 관계가 성립하면 true, 아니면 false를 반환합니다. 항상 Boolean 값을 반환합니다. 동등 연산자 vs 일치 연산자 ==, != (동등 연산자, Equality) : 타입이 다를 경우 형변환(묵시적 형변환)을 한 후에 값을 비교합니다. 즉, 타입이 달라도 동등할 수 있습니다. ===, !== (일치 연산자, Identity) : 형변환을 하지 않고 현재 상태로 값을 비교합니다. 즉, 타입이 다르면 일치하지 않습니다. + 연산자 Number + Number =&gt; 더하기 연산 수행 String + String, Number + String, String + Number =&gt; 문자열 연결 연산을 수행 여러 숫자, 문자열을 결합 시 연산자가 실행된 순서에 따라 연산 결과가 바뀌게 됩니다. / 연산자 자료형만 확실히 이해하고 있다면 어렵지 않습니다. console.log(5/2)의 결과는 =&gt; 2.5 typeof 연산자 피연산자의 타입을 String 형태로 반환하는 연산자 변수의 범위(Variable Scope) 변수가 존재하는 컨텍스트(함수가 실행되거나 변수를 참조할 때의 환경). 어디에서 변수가 접근할 수 있는지, 그 컨텍스트에서 변수에 접근할 수 있는지를 명시적으로 나타냅니다. 지역 변수(함수 수준 범위) : 함수 내에 정의된 변수는 지역 범위를 가지며, 해당 함수와 내부 함수에서만 접근이 가능합니다. 지역 변수는 함수 내에서 전역 변수보다 높은 우선순위를 갖습니다. 전역 변수 : 함수의 외부에서 선언된 모든 변수는 전역 범위를 가집니다. 전역 컨텍스트(scope)는 window를 가리킵니다. 지금까지 Javascript에서 변수를 선언하는 방법은 var를 이용하는 것 뿐이었다고 합니다. 물론 Javascript 특성상 var 없이 변수를 선언하는 것도 가능하지만 부작용이 심각하기 때문에 실무에서는 적용하지 않는 것이 보통입니다. 일이 아니더라도 var 선언 없이 변수를 사용하는 것은 정신건강에 좋지 않기 때문에 절대로 사용하지 말 것을 권장한다고 합니다. 본론으로 넘어가서, ES6로 넘어오면서 let과 const라는 새로운 선언 방법이 생겼습니다. var : function-scoped. 변수 재선언 가능 123console.log(foo);var foo; 위의 코드는 에러가 발생하지 않습니다. 변수 foo는 값이 정의되지 않은 형인 undefined가 되어 있을 뿐입니다. 선언보다 호출이 먼저 있었음에도 불구하고 이 코드는 정상적으로 작동합니다. 이유는 호이스팅이라는 키워드를 검색해보면 알 수 있습니다. 12345678910111213function ab()&#123; var foo = 'bar1'; console.log(foo); // bar1 if (true) &#123; var foo = 'bar2'; console.log(foo); // bar2 &#125; console.log(foo); // bar2&#125;ab(); 위의 코드가 ab()라는 함수 안에 존재한다고 했을 때, if문 밖의 변수 foo와 if문 안의 변수 foo는 동일한 변수가 됩니다. 중복 선언을 했지만 앞서 말한바와 같이 별다른 에러를 발생시키지 않고, 값마저 'bar2’로 변경해버립니다. 하지만, let과 const는 Block-scoped라고 합니다. 유효 범위가 블록 즉, {}로 감싸지는 범위라는 뜻입니다. let : block-scoped. 변수 재선언 불가능. 변수 재할당 가능 123let c = \"kim\";let c = \"lee\"; // 재선언 불가능. 에러 발생c = \"lee\"; // 재할당 가능. 에러 없이 정상적으로 작동 위의 코드를 통해서 let이 잘 작동하는지 확인해보았습니다. 그리고 여러 예제를 통해서 let의 의미를 더 알아보았습니다. 123456789let foo = 'bar1';console.log(foo); // bar1 if (true) &#123; let foo = 'bar2'; console.log(foo) // bar2&#125; console.log(foo); // bar1 위 코드에서는 var를 사용한 경우와는 달리 if문 밖의 foo와 if문 안의 foo는 서로 다른 변수입니다. 따라서 중복 선언으로 인한 에러도 발생하지 않으며, if문 안쪽에서 선언한 foo의 경우 if문이 닫히는 시점에서 유효 범위가 끝납니다. 여기서 의문이 조금 생깁니다. if문 안에서 foo를 먼저 호출한 다음 let으로 foo에 값을 할당하게 된다면?? 12345678910let foo = 'bar1';console.log(foo); // bar1 if (true) &#123; console.log(foo) // bar1 foo = 'bar2'; console.log(foo) // bar2&#125; console.log(foo); // bar2 걱정했던 것과는 다르게 정상적으로 호출도 되고 값의 변경에도 아무 문제가 없습니다. 그럼 foo 호출 이후에 let으로 foo를 선언해보겠습니다. 1234567891011let foo = 'bar1';console.log(foo); // bar1 if (true) &#123; console.log(foo); // Uncaught ReferenceError: foo is not defined let foo = 'bar2';&#125; console.log(foo); foo는 정의되지 않았다는 에러가 발생합니다. 앞에서 말한 임시적 사각지대(TDZ)의 정체가 이것입니다. 어떤 변수가 호출되었을 때 블록 안에 같은 이름의 변수가 없으면 상위 블록에서 선언된 같은 이름의 변수를 호출합니다. 하지만 블록 안에서 let이나 const로 변수 선언이 있었다면 그 이름의 변수는 변수가 선언되기 이전까지 그 블록 안에서는 정의되지 않은 변수로 간주되는 것입니다. const : block-scope. 변수 재선언 불가능. 변수 재할당 불가능 123console.log(foo);let foo; 호출한 시점에서 변수가 선언되어 있지 않음을 알리는 에러가 발생합니다;. 일시적 사각지대(Temporal Dead Zone : TDZ)라는 개념인데, 특정 개념을 설명하지 않더라도 let과 const의 동작 방식이 직관적이고 자연스럽다고 생각합니다. 실제로 원시형(primitives type : String, Number, Boolean, null, undefined)에서 const는 상수로 동작합니다. 따라서 const로 선언되면 값을 재할당할 경우 에러가 발생합니다. 또한, 당연하게도 초기값을 설정하지 않으면 에러가 발생합니다. 따라서 단순형의 경우 값의 변경이 있는 경우에는 let으로, 상수로 사용하는 경우에는 const로 선언하는 것이 바람직합니다. 하지만, 참조형(Complex tyupe : Array, Object, Function)의 경우 결론부터 말하자면 const로 선언하는 것이 바람직합니다. 참조형은 const로 선언하더라도 멤버값을 조작하는 것이 가능합니다. 1234567const foo3 = [0,1];const bar3 = foo3; foo3.push(2);console.log(foo3, bar3);bar3[0] = 10;console.log(foo3, bar3); 위의 결과를 보면 const bar = foo;의 선언으로 bar는 foo를 참조합니다. 참조가 아니라 값을 복사(copy)하는 경우에는 array는 … 연산자를 사용하고, object는 assign() 함수를 사용합니다. 호이스팅 : 변수의 정의가 그 범위에 따라 선언과 할당이 분리되는 것을 의미 함수 내에서 정의되었을 경우 : 선언이 함수의 최상위 함수 바깥에서 정의되었을 경우 : 전역 컨텍스트의 최상위로 변경 변수의 선언이 초기화나 할당시에 발생하는 것이 아니라, 최상위로 호이스트 됨 함수 선언문 방식만 호이스팅이 제대로 이루어짐 함수 선언은 변수 선언을 덮어씁니다. 하지만, 변수에 값이 할당될 경우 반대로 변수가 함수 선언을 덮어쓰게 됩니다. 123456789101112131415var test; function test()&#123; console.log('test');&#125;console.log(typeof test); // functionvar test = 'test';function test()&#123; console.log('test');&#125;console.log(typeof test); // string 변수는 camelCase로 작성합니다. [ ex. var mainTest; ] 세미콜론은 항상 붙여줍니다. 변수 선언은 스코프 상단에 선언합니다. 동치 연산자(==,!=)보다는 일치 연산자(===,!==)를 사용합니다. 중괄호 ‘{’ 위치는 선언문과 같은 줄에 결론 ES6에서는 var는 지양하고 가급적 let과 const를 사용 원시형 변수는 let, 상수는 const로 선언 참조형은 const로 선언 Node.js? Nodejs는 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼입니다. Javascript가 브라우저 밖에 존재하지 않았던 한계를 극복하여 브라우저 외부 환경에서 Javascript 애플리케이션 개발에 사용되며 이에 필요한 모듈, 파일 시스템, HTTP 등 Built-in API를 제공합니다. 또한, Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다. 런타임(RunTime)이란?? 단순하게 말해서 프로그래밍 언어가 구동되는 환경이라고 이해하면 됩니다. Javascript라면 Web Browser에서 작동하는 Javascript 측면이 있고, Node.js라는 환경에서 구동되는 측면이 존재합니다. 여기에서의 Browser와 Node.js를 런타임이라고 볼 수 있습니다. 특징 기존의 웹에서 서버는 스레드를 기반으로 하는 동기 방식(Multi-Thread)으로 네트워크 입출력을 처리합니다. 여기서 동기 방식이란 작업 요청이 들어올 때마다 스레드를 여러 개 만들어 동시에 일을 처리하는 것을 말합니다. 좋은 해결법이지만, 일이 많아질수록 스레드를 더 많이 만들어야 하므로 메모리 사용량이 많아질 수 있습니다. 그러나 서버의 자원이 제한되어 있기 때문에 Thread를 무한히 생성할 수는 없습니다. Multi-Thread 방식은 이러한 문제를 서버의 성능을 높이거나 Load-Balancing 등으로 분산 처리하여 해결합니다. Multi-Thread 방식은 Thread 간의 공유 자원 접근 시에도 신중해야 합니다. 각 Thred는 독립적인 시점에서 동작하기 때문에 공유 자원에 대한 동기화도 반드시 필요합니다. Node.js의 경우, 모든 API는 이벤트 기반 비동기 방식으로 동작하여 Non-blocking I/O가 가능(제어권을 넘김)하여 요청을 처리하면서 다음 요청을 받을 수 있습니다. 또한, single thread를 사용하여 Multi Thread의 문제로부터 자유롭습니다. Node.js 동작원리 Node.js는 Event-Callback 방식을 이용하여 비동기식 처리를 진행합니다. 클라이언트가 Event를 요청하면 Message 형태로 Event Queue에 저장됩니다. Event Loop는 Node.js에서 Single thread에서 돌아가며 I/O Bound 작업들을 비동기적으로 처리하기 위하여 필요합니다. Event Loop가 Queue에 있는 Task를 Pop하여 kernel에 요청하게 되는데 처리하는 동안 제어권은 다음 요청으로 넘어가게 됩니다. (Non-Blocking:또 다른 요청을 처리할 수 있게 됩니다.) 요청이 Blocking I/O 혹은 처리에 많은 시간을 요구하는 복잡한 성격의 요청(파일 시스템 I/O, 데이터베이스, 외부 서비스 처리 등)이라면 내부 쓰레드 풀에서 대기 중인 쓰레드에게 요청을 위임합니다. 요청이 Non-Blocking I/O 또는 복잡하지 않은 작업이라면 Event Loop Thread는 요청을 즉각 처리합니다. 요청 처리가 완료되면 Callback을 호출하여 처리 완료를 클라이언트에게 전달합니다. 내부적으로 비동기식 방식(Non-Blocking)을 지원하지 않는 task는 Multi Thread Pool로 처리하는데 이는 내부 처리를 위한 목적이며 요청 처리 자체를 Thread로 하지 않습니다. 그림을 통해 설명하자면, Client A가 요청을 하면 CPU 작업이 수행되고 I/O 요청을 보냅니다. Non-Blocking 처리 방식을 사용하기 때문에 I/O 작업을 수행하며 또 다른 요청을 처리할 수 있습니다. Client B의 요청이 오면 CPU 작업을 수행하고 I/O 요청을 보냅니다. I/O 작업 시 기다리지 않기 때문에 single thread가 다른 요청을 받아서 작업을 처리할 수 있는 구조입니다. Event Loop는 Single Thread로 이루어져 있습니다. 따라서, 하나의 request 처리 작업이 CPU를 많이 사용(CPU intensive한 처리)하게 된다면 전체 서버 처리에 영향을 줄 수 있는 단점이 있습니다. (다른 요청이 CPU 작업을 수행하기 힘들다.) 이에 따라, 처리해야할 작업이 CPU를 많이 소모한다거나 대용량 파일을 처리해야 한다면 Node.js가 적합하지 않을 수 있습니다. 장단점 이벤트 기반 비동기 방식으로 많은 클라이언트 요청에 대하여 이벤트 루프를 사용하기 때문에 많은 스레드를 사용하지 않습니다. 따라서, 멀티 스레드 방식보다 Thread 수가 적기 때문에 메모리 또는 자원 소모가 작습니다. 오버헤드 또한 적습니다. 추가적인 장점으로 JavaScript를 사용하여. 웹 개발자가 쉽게 접근할 수 있습니다. 또한, Google이 만든 자바스크립트 엔진을 사용하고 있습니다. 계속해서 여러 큰 기업들이 경쟁하며 자바스크립트 엔진의 속도를 높이고 있어 Google이 무너지지 않는 이상 속도는 계속 빨라질 것입니다. 마지막 장점으로, C++로 개발된 V8 JavaScript 엔진을 사용하여 C++을 사용해 기능을 확장할 수 있습니다. JavaScript를 사용한 것이 단점이 될 수도 있습니다. C/C++로 개발된 서버 애플리케이션보다는 느리기 때문입니다. 그러나, 또 다른 스크립트 언어를 사용해서도 웹 개발이 많이 이루어지고 있어 큰 문제라고는 생각할 수 없습니다. Single Thread기반의 비동기 I/O처리, 이벤트 처리 방식으로 인해 성능이 매우 빠릅니다. 또한, 시스템 리소스의 부하가 적습니다. 또한, Single Thread를 사용하기 때문에 CPU intensive한 영역에서는 약한 모습을 보입니다. 그러나 상대적으로 CPU intensive한 작업이 없고, 많은 Connection을 동시에 처리해야 하는 경우에는 node.js의 성능이 압도적으로 높은 것을 알 수 있습니다. 단점으로는 일을 처리하는 한 명(즉,Single Thread)이 쓰러지는 순간 프로그램 전체에 문제가 발생하게 됩니다. 또한, 하나의 작업 자체가 시간이 많이 걸리면, 전체 시스템의 성능이 급격하게 떨어집니다. 그리고 코드의 가독성이 떨어져 유지보수가 어렵습니다. 마지막으로 에러가 날 경우 프로세스 자체가 죽어버립니다. 요약하자면, 개발 관점에서는 빠르고 쉬운 장점이 있지만, 반대로 운영관점에서는 테스트, 디버깅 등에 어려움이 있을 수 있습니다. 대규모 프로젝트나 게임 서버보다는 RESTful API 서버, 채팅 서버 등에 적절합니다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://woovictory.github.io/tags/Node-js/"}]},{"title":"[Java] 1. 타입","slug":"java-basic-1","date":"2018-07-31T16:45:03.000Z","updated":"2020-04-22T07:48:22.066Z","comments":true,"path":"2018/08/01/java-basic-1/","link":"","permalink":"https://woovictory.github.io/2018/08/01/java-basic-1/","excerpt":"","text":"자바의 기초적인 문법과 개념을 정리하는 공간 # Java Program 한 개 이상의 클래스로 구성된다. 클래스는 한 개 이상의 필드나 메소드로 구성된다. main() 메소드를 가지는 클래스가 반드시 하나 존재해야 한다. 소스 파일의 이름은 해당 public 클래스의 이름과 같아야 한다. 12345public class Victory&#123; public static void main(String[] args)&#123; System.out.println(\"Victory\"); &#125;&#125; # 변수(variable) 데이터를 저장할 수 있는 메모리 공간을 의미. 저장된 값은 변경 가능하다. 변수의 이름 생성 규칙 변수의 이름은 해당 변수에 저장될 데이터의 의미를 잘 나타내도록 짓는 것이 좋다. 영문자(대소문자), 숫자, 언더스코어,달러($)로만 구성할 수 있다. 숫자로 시작할 수 없다. 변수의 이름 사이에는 공백을 포함할 수 없다. 자바에서 미리 정의된 키워드를 사용할 수는 없다. 변수의 종류 기본형 변수(primitive type) 계산을 위해 실제 연산에 사용되는 변수. 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double) 참조형 변수(reference type) 8개의 기본형을 제외한 나머지 타입이다. 객체의 주소를 저장한다. 덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합합니다. 참조변수의 출력이나 덧셈 연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리합니다. 변수의 선언과 초기화 변수 선언만 한다. 변수를 선언하여 메모리 공간을 할당 받는다. 초기화하지 않았으므로 쓰레기 값이 들어간다. 반드시 초기화 이후에 사용해야 한다. 그렇지 않으면 컴파일 오류 발생. 변수 선언과 초기화를 동시에 한다. 선언과 동시에 초기화한다. 타입이 같으면 동시에 선언 및 초기화 가능. # 상수(constant) 변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간. 변수와 다르게 저장된 데이터를 변경할 수 없다. 선언과 동시에 초기화해야 한다. final 키워드를 사용하여 선언한다. 통상적으로 상수는 대문자를 사용해 선언한다. 길 경우 언더스코어 사용. 리터럴(literal) 상수의 다른 이름이다. 값 그 자체를 의미한다. 12int var = 30; // 30이 리터럴final int AGES = 100; // 100이 리터럴 리터럴 타입 접미사(literal type suffix) 자바에서 3.14와 같은 실수형 리터럴을 그대로 사용하면, 해당 리터럴은 실수형 타입 중에서도 double로 인식할 것이다. 하지만, 실수형 리터럴 맨 뒤에 F나 f를 추가하면, 자바는 해당 실수형 리터럴을 float형으로 인식할 것이다. 이처럼 리터럴 뒤에 추가되어 해당 리터럴의 타입을 명시해주는 접미사를 리터럴 타입 접미사(lister type suffix)라고 한다. 자바에서 사용할 수 있는 리터럴 타입 접미사 # 기본형 데이터 타입의 범위 타입은 데이터가 메모리에 어떻게 저장되는지, 처리되는지 명시적으로 알려준다. boolean 저장 가능한 범위 true / false Java에서 데이터를 다루는 최소 범위가 1 Byte이기 때문에 낭비적이긴 하지만 1 Byte 사용. char Unicode를 사용. 동양 글자의 경우 2Byte가 필요하기 때문에 char의 경우 2Byte 사용. 유일하게 제공되는 Unsinged 형태(음수가 존재하지 않는다.) 맨 앞 1bit로 음수나 양수를 나타내지만 char형은 unsinged 형식이기 때문에 맨 앞 비트를 음수, 양수 형식으로 사용하지 않는다. char 형은 유니코드 정수 형태로 저장한다. 12char a = &apos;A&apos;a 변수에는 &apos;A&apos;의 정수 값인 65가 들어간다. JVM의 피연산자 스택이 피연산자를 4 Byte 단위로 저장하기 때문에 int 형보다 작은 자료형의 값을 계산할 때 int 형으로 형 변환하고 연산이 수행된다. 정수형 데이터를 사용하게 되면 JVM에서 기본적으로 int 형 데이터 타입의 데이터로 인식을 한다. int형 데이터 타입의 범위를 넘는 long 타입의 정수를 사용하고자 하는 경우에는 정수 데이터 맨 뒤쪽에 접미사 ‘l ’ 또는 'L’을 붙여줘야 한다. 정수형 데이터 타입 오버플로우와 언더플로우 데이터를 저장할 때는 데이터의 크기를 고려해서 적절한 데이터 타입을 사용해야 한다. 그렇지 않으면 데이터 손실이 생긴다. 오버 플로우 : 해당 타입이 표현할 수 있는 최대 범위를 벗어난 데이터를 저장할 경우 발생한다. 다른 값이 저장될 수 있다. 언더 플로우 : 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생한다. # 실수 실수란 소수부와 지수부가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다. double 형이 기본 데이터 타입이다. float double 컴퓨터에서 실수를 표현하는 방식은 오차가 발생할 수 밖에 없는 태생적 한계를 지닌다. 이러한 실수형 데이터의 오차는 자바뿐만 아니라 모든 프로그래밍 언어에서 발생하는 공통된 문제입니다. # 실수의 표현 컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡합니다. 왜냐하면, 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표현해야 하기 때문이다. 두 가지의 방법이 사용되고 있다. 고정 소수점 방식(fixed point) 실수는 보통 정수부와 소수부로 나눌 수 있다. 따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 고정하여 고정된 자릿수의 소수를 표현하는 것이다. 위 그림은 32비트 실수를 고정 소수점 방식으로 표현한 것이다. 하지만, 이 방식은 정수부와 소수부의 자릿수가 크지 않으므로 표현할 수 있는 범위가 매우 적다는 단점이 있다. 부동 소수점 방식(floating point) 실수는 보통 정수부와 소수부로 나누지만, 가수부와 지수부로 나누어 표현할 수도 있다. 부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식이다. 앞서 살펴본 고정 소수점 방식은 제한된 자릿수로 인해 표현할 수 있는 범위가 매우 작다. 하지만, 부동 소수점 방식은 다음의 수식을 이용하여 매우 큰 실수까지도 표현할 수 있게 되었다. 현재 대부분의 시스템에서는 부동 소수점 방식으로 실수를 표현하고 있다. IEEE 부동 소수점 방식 현재 사용되고 있는 부동 소수점 방식은 대부분 IEEE 754 표준을 따르고 있다. 32비트(4바이트)의 float형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다. 64비트의 double형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다. 지수 필드의 비트 수가 늘어나면 표현 가능한 수의 범위가 확장되고, 가수 필드의 비트 수가 늘어나면 정밀도가 증가한다. 부동 소수점 방식의 오차 부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있다. 하지만, 부동 소수점 방식에 의한 실수의 표현은 항상 오차가 존재한다는 단점을 가지고 있다. 부동 소수점 방식에서의 오차는 앞에서 본 공식에 의해 발생한다. 이 공식을 사용하면 표현할 수 있는 범위는 늘어나지만, 10진수를 정확하게 표현할 수는 없게 된다. 따라서 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임을 항상 명심해야 한다. 타입 변환 하나의 타입을 다른 타입으로 바꾸는 것이다. boolean형을 제외한 나머지 기본 타입 간의 타입 변환을 자유롭게 수행할 수 있다. 다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입 -&gt; 큰 타입으로의 변환은 생략할 수 있다. 하지만, 메모리에 할당받은 바이트의 크기가 큰 타입 -&gt; 작은 타입으로의 타입 변환은 데이터의 손실이 발생한다. 따라서 상대적으로 바이트의 크기가 작은 타입으로 타입 변환을 할 경우 자바 컴파일러는 오류를 발생시킨다. 묵시적 타입 변환(자동 타입 변환) 대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환을 가리킨다. 자바에서는 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환을 진행합니다. 또한, 자바에서는 데이터의 손실이 발생하는 대입 연산은 허용하지 않습니다. 12345double num1 = 10; // 1int num2 = 3.14; // 2double num3 = 7.0f + 3.14; //3System.out.println(num1);System.out.println(num3); 1번 double형 변수에 int형 데이터를 대입한다. int형 데이터 -&gt; double형 데이터 : 자동 형 변환된다. 2번 int형 변수가 표현할 수 있는 범위보다 더 큰 double형 데이터를 대입하므로 데이터의 손실이 발생한다. 이 대입 연산의 경우 컴파일러가 오류를 발생시킨다. 3번 데이터의 손실이 최소화되도록 float형 데이터 -&gt; double형 데이터로 자동 형 변환시킨다. 자바 컴파일러가 자동으로 수행하는 타입 변환은 데이터의 손실이 최소화되는 방향으로 이루어진다. 따라서 자바에서는 타입의 표현 범위에 따라 다음과 같은 방향으로 자동 타입 변환이 이루어집니다. 명시적 타입 변환(강제 타입 변환) 사용자가 타입 캐스트 연산자 (())를 사용하여 강제적으로 수행하는 타입 변환을 말한다. 다음과 같은 방법으로 명시적 타입 변환을 수행할 수 있습니다. 1(변환할 타입) 변환할 데이터 변환시키고자 하는 데이터의 앞에 괄호 (())를 넣고, 그 괄호 안에 변환할 타입을 적으면 된다.이 괄호를 타입 캐스트(type cast) 연산자라고 한다. 1234567int num1 = 1, num2 = 4;double result1 = num1 / num2;double resutl2 = (double) num1 / num2; // 강제 타입 변환System.out.println(result1);System.out.println(resutl2); 123// 결과0.00.25 result1은 나눗셈의 결과로는 0이 반환된다. 자바에서 산술 연산을 수행하고 얻는 결과값의 타입은 언제나 피연산자의 타입과 일치해야 합니다. 즉, int형 데이터끼리 산술 연산에 대한 결과값은 언제나 int형 데이터의 결과가 나오게 된다. 따라서 1/4의 결과로는 0.25가 반환되지만, int형으로 자동 타입 변환되어 0이 반환되게 된다. 그리고서 double형 변수에 그 결과가 대입될 때, double형으로 자동 타입 변환되어 0.0이라는 결과가 출력된다. 데이터가 손실되었다. 정확한 결과를 얻고자 한다면 result2처럼 피연산자 중 하나의 타입을 double형으로 강제 타입 변환을 해야 한다. 이렇게 피연산자 중 하나의 타입이 double형이 되면, 나눗셈 연산을 위해 나머지 하나의 피연산자도 double형으로 자동 타입 변환된다. 따라서 그 결과 또한 double형인 0.25가 될 것이며, 이 결과가 double형 변수에 제대로 대입될 것이다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"},{"name":"Language","slug":"Language","permalink":"https://woovictory.github.io/tags/Language/"},{"name":"Developer","slug":"Developer","permalink":"https://woovictory.github.io/tags/Developer/"}]},{"title":" [안드로이드] Context","slug":"Android-Context","date":"2018-06-25T13:29:41.000Z","updated":"2020-03-01T10:28:54.529Z","comments":true,"path":"2018/06/25/Android-Context/","link":"","permalink":"https://woovictory.github.io/2018/06/25/Android-Context/","excerpt":"","text":"안드로이드를 공부하면서 항상 Context에 대해서 의문을 가지고 있었지만, 명확하게 설명해주는 글이 없어서 그냥 넘어갔습니다. 하지만, 다른 사람이 Context에 대해서 물어본다면 속 시원하게 대답해줄 수 없었습니다. 그 당시에는 공식처럼 넘겨주면 된다고 생각을 하였지만, 공부를 계속 할수록 저걸 '왜 넘겨주는 걸까 ?'라는 의문이 들어서 찾아보면서 공부하자고 마음 먹었습니다. Context 안드로이드 개발을 공부하면서 자주 사용하는 함수들이 있습니다. 예를 들면 간단한 메시지를 띄워주는 Toast 메시지, 다른 Activity로 화면 전환을 위해서 주로 사용되는 Intent 등은 applicationContext라는 것을 매개변수로 항상 넘겨주곤 합니다. Context가 뭘까?? 안드로이드의 Context 개념은 안드로이드 Developer에 따르면 다음과 같습니다. Application 환경에 관한 글로벌 정보를 접근하기 위한 인터페이스. Abstract 클래스이며 실제 구현은 안드로이스 시스템에 의해 제공됩니다. Context를 통해 Application에 특화된 리소스나 클래스에 접근할 수 있을 뿐만 아니라 추가적으로 Application 레벨의 작업(Activity 실행, Intent 브로드캐스팅, Intent 수신 등등)을 수행하기 위한 API를 호출 할 수도 있습니다. Context는 크게 두 가지 역할을 수행하는 Abstract 클래스입니다. Application에 관하여 시스템이 관리하고 있는 정보에 접근하기 – getPackageName(), getResource() 안드로이드 시스템 서비스에서 제공하는 API를 호출할 수 있는 기능 – startActivity(), bindService() 왜 Context가 필요할까?? Context가 왜 필요하지?? 라는 질문은 어렵습니다. 전역적인 Application 정보에 접근하거나 Application 연관된 시스템 기능을 수행하기 위해 시스템 함수를 호출하는 일은 안드로이드가 아닌 다른 플랫폼에서도 늘상 일어나는 일입니다. 또, 그러한 작업들은 어떠한 매개체를 거칠 필요 없이 직접적으로 시스템 API를 호출하면 됩니다. 반면 안드로이드에서는 Context라는 인스턴스화된 매개체를 통해야만 유사한 작업들을 수행할 수 있습니다. C#의 경우에는 System 단에서 제공하는 정적 함수(static function)를 호출함으로서 간단하게 할 수 있는 일들을 안드로이드에서는 Context에 정의된 인스턴스 함수를 호출해야만 가능하게 되어있습니다. 즉, 반드시 인스턴스화된 Context 클래스를 사용해야 합니다. 왜 이런 차이가 생기게 된 것일까요?? 안드로이드가 아닌 플랫폼에서는 어떻게 정적 함수 호출을 통해서 Application에 관한 정보를 가져오고, 시스템 함수를 호출할 수 있는 걸까요?? OS에 대한 지식이 별로 없지만, 찾아보고 공부해본 바로는 일반적인 경우, Application이 프로세스와 아주 긴밀하게 연결되어 있습니다. OS 커널의 가장 중요한 일 중 하나는 프로세스를 관리하는 것입니다. 특정 프로세스가 특정 Application과 Mapping 된다면 우리는 별다른 매개체 없이 시스템에서 직접 프로세스의 정보에 관해서 물어볼 수 있고, 프로세스와 연관된 시스템 함수를 호출할 수 있습니다. 그런데 안드로이드에서 Application과 프로세스와의 관계는 조금 다릅니다. 안드로이드에서 Application과 Process는 서로 독립적으로 존재합니다. 예를 들면, 안드로이드 플랫폼에서는 프로세스가 없는 상황에도 Application은 살아있는 것처럼 사용자에게 표시되기도 하고, 메모리가 부족한 상황이 될 경우 작동 중이던 Process가 강제로 종료되고, 대신 해당 Process에서 작동 중이던 Application에 관한 일부 정보만 별도로 관리하고, 이 후에 메모리 공간이 확보되면 저장되어 있던 Application 정보를 바탕으로 새로운 Process를 시작하는 등의 일이 벌어집니다. 안드로이드에서도 Process는 당연히 OS 커널에서 관리됩니다. Application과 Process가 별도로 관리되고 있다면, Application 정보는 어디에서 관리하고 있을까요?? 안드로이드의 시스템 서비스 중 하나인 ActivityManagerService에서 책임을 지고 있습니다. ActivityuManagerService는 특정 토큰을 키값으로 Key-Value 쌍으로 이루어진 배열을 이용해서 현재 작동중인 Application 정보를 관리합니다. 결론에 가까워졌습니다. ^^ Context는 Application과 관련된 정보에 접근하고자 하거나 Application과 연관된 시스템 레벨의 함수를 호출하고자 할 때 사용됩니다. 그런데 안드로이드 시스템에서 Application 정보를 관리하고 있는 것은 시스템이 아닌, ActivityManagerService 라는 일종의 또 다른 Application입니다. 따라서 다른 일반적인 플랫폼과는 달리 안드로이드에서는 Application과 관련된 정보에 접근하고자 할 때는 ActivityManagerService를 통해야만 합니다. 당연히 정보를 얻고자 하는 Application이 어떤 Application인지에 관한 key 값도 필요해집니다. 즉, 안드로이드 플랫폼상에서의 관점으로 살펴보면 Context는 다음과 같은 두 가지 역할을 수행하기 때문에 꼭 필요한 존재입니다. 자신이 어떤 Application을 나타내고 있는지 알려주는 ID 역할 ActivityManagerService에 접근할 수 있도록 하는 통로 역할 일반적인 OS 플랫폼에서 Application은 곧 Process 입니다. 특정 Application이 OS에게 내가 어떤 Process인지만 알려주면 Application 관련된 정보를 얼마든지 획득할 수 있습니다. 이른바 자신의 존재 자체가 자신임을 증명해주는 ‘지문인식’ 혹은 ‘홍채인식’ 등의 '생채인식’과 비슷한 개념이기 때문에 Context와 같은 애매한 중간 매개체가 존재할 이유가 없습니다. 하지만 안드로이드 플랫폼은 조금 다릅니다. 비유하자면 ‘생채인식’ 보다는 'ID 카드’를 통한 보안 시스템과 유사한 구조를 가지고 있습니다. 특정 Application이 자신이 본인임을 확인 받을 수 있는 방법은 자신이 작동중인 Process를 보여주는 것이 아니라, 자신이 건네받은 ID 카드를 제시하는 것입니다. 이때, ID 카드의 역할을 수행하는 것이 바로 Context이고, 당연히 이 카드는 위변조가 가능하기 때문에, 자신의 권한을 제 3자의 Application에게 넘겨주는 PendingIntent와 같은 기농도 가능해집니다. Context는 언제 생성될까?? Application이 생성될 때 입니다. 그렇다면 하나의 Application을 구성하는 각종 컴포넌트들(Activity, Service, BroadcastReceiver)은 모두 동일한 Context를 공유해서 사용하고 있을까요?? 대답은 그렇지 않습니다. Activity와 Service가 생성될때 만들어지는 Context와 BroadcastReceiver가 호출될 때 전해지는 Context는 모두 서로 다른 인스턴스입니다. 즉, Context는 Application이 시작될 때는 물론, Application Component들이 생성될 때마다 만들어지게 됩니다. 새롭게 생성되는 Context는 부모와 완전히 독립되어 있는 존재는 아니고 ‘거의’ 비슷한 내용을 담고 있습니다. 동일한 Context 인스턴스를 Application Component들이 공유해서 사용하지 않고, 모두 서로 다른(그러나 알고보면 알맹이는 거의 같은) 인스턴스를 만들어서 사용하고 있을까요??? Context의 기능 중, 시스템 API를 호출하는 기능과 관련되어 한 가지 문제점이 있습니다. 어떤 Application 컴포넌트가 시스템 API를 호출하느냐에 따라서 서로 다른 결과가 나타나야 한다는 점입니다. 예를 들어, Service 에서 Activity 실행하기에서 확인할 수 있는 것처럼, 동일한 형태로 startActivity 메소드를 호출하더라도, 일반적인 Activity에서는 정상적으로 새로운 Activity를 시작하게 되지만, Service에서 호출할 경우에는 예외가 발생합니다. 만일 Application을 구성하는 Service와 Activity가 서로 동일한 Context 인스턴스를 공유하고 있다면 동일한 메소드 호출에 대하여 서로 다른 결과를 나타내도록 구현하지 못했을 것입니다. 따라서 현재 안드로이드 시스템은 Application Context를 기반으로 Component를 위한 Context를 생성할 때 해당 Context가 어떤 종류의 Component인지 알 수 있도록 약간의 표시를 해두곤 합니다. Android MultiTasking 안드로이드는 독특한 방법으로 동시에 여러 Application이 작동하는 멀티태스킹 기능을 지원합니다. 다른 플랫폼에서 개발을 하던 개발자들은 안드로이드가 멀티태스킹을 지원하는 방식을 보면 놀랄 것입니다. 몰티태스킹이 작동하는 방식을 이해하는 것은 잘 작동하는 동시에 안드로이드 플랫폼의 다른 요소들과 매끄럽게 결합될 수 있는 Application을 디자인하는데 매우 중요합니다. 아래의 내용은 안드로이드 멀티태스킹이 현재와 같이 작동하는 디자인적인 이유와 Application 작동에 끼치는 영향 그리고 개발자가 어떻게 안드로이드가 지원하는 기능들을 잘 활용할 수 있는지에 대해 다룹니다. Desing Considerations 모바일 Device는 기술적인 한계점을 갖으며 일반적인 데스크탑 혹은 웹 환경과는 다른 사용자 경험이 요구됩니다. 다음은 안드로이드의 멀티태스킹 기능을 설계하는데 중요하게 여긴 4가지 제약 사항들입니다. 사용자가 특정 Application 사용을 끝마쳤을 때, 명시적으로 Application을 종료하지 않아도 되기를 원합니다. 사용자들은 다양한 종류의 Application을 아주 짧게 그리고 반복적으로 사용하기 때문입니다. 휴대용 장치들은 풍족환 스왑 메모리 공간을 갖고 있지 못하며, 메모리 사용에 빡빡한 제한을 갖고 있습니다. 모바일 Device에서 Application 스위칭은 중요합니다. 새로운 Application이 1초 이내에 시작될 수 있도록 굉장한 노력을 기울입니다. 비디오를 보다가 새로 도착한 SMS 문자를 확인하고 다시 비디오 플레이 Application으로 돌아가는 등의 사용자 시나리오를 생각해 본다면, 몇몇 Application간의 빠른 스위칭은 특히 더 중요한 문제입니다. 사용할 수 있는 API는 안드로이드에 기본 내장된 구글 Application을 만들 수 있을 만큼 충분히 강력해야 합니다. 이것은 ‘모든 Application은 동등하다’ 라는 철학의 문제입니다. 즉, 백그라운드 음악 재생, 데이터 동기화, GPS 네비게이션, Application 다운로드 등의 기능은 서드 파티 Application 개발자들이 사용 가능한 API와 동일한 API를 이용해서 작성되어야 합니다. 앞선 두 가지 요구사항은 한 가지 흥미로운 모순점을 가지고 있습니다. 우리는 사용자들이 Application 종료에 대해 신경쓰는 것 대신 모든 Application은 항상 실행 중인 것처럼 느낄 수 있기를 바랍니다. 하지만 동시에 모바일 Device는 메모리 사용에 빡빡한 제한이 있습니다. 시스템이 사용 가능한 램 영역보다 많은 메모리가 필요한 경우가 되면, 데스크탑 컴퓨터들은 단순히 페이지 스왑을 위해 작동이 조금 느려지게 됩니다. 반면, 모바일 Device는 성능상에 큰 문제점이 생기거나 아예 먹통이 되어버릴 수 있습니다. 이 도전할 만한 제약 조건이 안드로이드의 멀티태스킹 메커니즘을 설계하기 위한 핵심 동기가 되었습니다. When dose an application “stop”? 안드로이드의 멀티태스킹과 관련된 가장 일반적인 오해는 프로세스와 Application의 차이에 관한 점입니다. 안드로이드에서 프로세스와 Application은 밀접하게 연결되어 있는 요소가 아니며, Application은 해당 Application을 작동시키고 있는 프로세스가 없음에도 사용자에게 현재 작동하고 있는 것처럼 보일 수도 있고, 또 여러 Application이 프로세스를 공유할 수도 있습니다. 혹은 필요에 따라 하나의 Application이 여러 개의 프로세스를 사용할 수도 있고, 실제로 Application이 작동 중이 아님에도 Application을 구동했던 프로세스들은 종료되지 않고 안드로이드 시스템에 의해 유지될 수 있습니다. 즉, 개발자가 Application이 프로세스가 Running 상태임을 확인할 수 있다고 해서 그것이 해당 Application이 현재 작동 중이거나 어떠한 일을 하고 있다는 것을 의미하지 않습니다. Application의 프로세스는 단순히 안드로이드 시스템이 해당 프로세스가 필요했었고, 이 후에 해당 프로세스가 다시 사용될 경웨 대비해서 프로세스를 유지하기로 결정했기 때문에 살아있는 것 뿐입니다. 이와 비슷하게 개발자가 아주 잠시동안 특정 Application을 떠나 곧 돌아오기를 원하고자 하는 경우라 할지라도 해당 Application을 작동시키고 있는 프로세스는 안드로이드 시스템에 의해 강제로 종료될 수 있습니다. 사실, 안드로이드가 Application을 관리하는 핵심은 프로세스를 깔끔하게 종료시키지 않는 것입니다. 사용자가 Application을 떠나는 순간, 해당 Application의 프로세스는 계속 유지되며, 백그라운드 상에서 필요한 경우 어떠한 작업을 수행할 수 있습니다. 그리고 사용자가 해당 Application으로 돌아오면 그 즉시 포그라운드로 전환됩니다. 만일 Device의 메모리가 충분하다면, 안드로이드는 모든 Application 프로세스들을 유지하게 되고, 말 그대로 모든 Application은 동시에 작동할 수 있습니다. 물론, 메모리는 무한하지 않습니다. 이러한 한계를 극복하기 위해 안드로이드 시스템은 더 이상 필요하지 않은 프로세스를 종료해야만 합니다. 즉, 각각의 프로세스들은 정해진 규칙에 따라 그 중요도가 결정되고, 가장 중요하지 않은 프로세스가 종료되게 됩니다. 이러한 과정이 안드로이드의 프로세스 생명주기(Process LifeCycle)를 만들어 냅니다. 프로세스의 중요도는 프로세스가 현재 사용자에게 얼마나 큰 영향을 미치고 있는지 그리고 사용자가 마지막으로 해당 프로세스를 필요로 한 것이 얼마나 오래전인지 두 가지 요소에 의해 결정됩니다. 안드로이드 시스템이 특정 프로세스를 제거하기로 결정하면, 강제로 프로세스를 종료합니다. 따라서 커널은 해당 프로세스가 시스템으 프로세스 종료 요청에 대하여 사용중인 자원을 적절하게 반환하도록 작성되었는지 그렇지 않은지와 관계없이, 즉시 해당 프로세스에 의해 사용 중이던 리소스들을 사용할 수 있습니다. 커널이 Application이 사용 중이던 리소스를 즉시 사용할 수 있도록 함으로서, 시스템 메모리 부족으로 인해 발생하는 심각한 문제들을 훨씬 쉽게 회피할 수 있게 됩니다. **모든 Application은 항상 작동하고 있다.**라는 사용자 경험을 만족시키기 위해 만일 사용자가 이미 종료된 Application으로 돌아가기를 원하는 경우, 해당 Application의 마지막 상황과 동일한 형태로 Application이 시작되어야 합니다. 이를 위해, 사용자에게 보여지는 Application 요소(즉, Activity)는 늘 기록 되며, 필요한 경우 특정 Activity가 화면 상에 보였던 상태 정보와 함께 Activity를 재시작합니다. Activity의 상태 정보는 Application 종료 시점이 아니라, 사용자가 Application을 떠날 때마다 생성됨으로 커널은 사용자가 Application을 벗어난 후에는 비교적 자유롭게 해당 Application을 종료할 수 있습니다. 어떤면으로 보면, 안드로이드가 프로세스를 관리하는 방법은 공간 교체(swap space)의 형식으로 여겨질 수 있습니다. Application 프로세스들은 사용 중인 메모리 공간을 나타냅니다. 메모리가 부족하게 될 경우 몇몇 프로세스들은 강제로 종료 되고(교체당함 - Swapped Out), 해당 프로세스들이 다시 필요하게 될 경우 마지막으로 저장된 상태 정보를 기반으로 다시 시작(교체 투입 - Swapped in)될 수 있습니다. Explicitly running in the background Application 프로세스가 안드로이드 시스템에 의해 강제로 종료되지 않는 한, 암시적으로 해당 백그라운드 작업을 수행할 수 있습니다. 하지만, 이런 기능이 웹 페이지를 로딩하는 등의 일을 하기에는 충분할 지 모르지만, 예를 들어 백그라운드에서 음악을 재생, 데이터를 동기화, 위치 정보를 기록, 알람 등과 같이 보다 엄밀한 요구사항이 필요한 경우에는 적절하지 못합니다. 이러한 작업들을 위해서 Application은 안드로이드 시스템에게 명시적으로 백그라운드 상에서 작업이 수행되어야 함을 알릴 필요가 있습니다. Application은 메니페스트 상에 BroadcastReceiver 혹은 Service 요소를 선언할 수 있으며, 이 두 가지 요소를 통해 명시적으로 백그라운드 작업을 수행할 수 있습니다. Broadcast Receivers Broadcast Receiver는 Application이 특정한 이벤트가 발생하는 경우에, 아주 짧은 시간 동안 백그라운드에서 작업할 수 있도록 해주며, 다양한 방식으로 보다 상위의 기능을 구현하는데 사용될 수 있습니다. 예를 들어 AlarmManager는 Application이 미래의 특정 시점에 Broadcast를 전송할 수 있도록 해주며, LocationManager는 위치 정보가 변경될 때마다 Broadcast를 전송할 수 있습니다. BroadcastReceiver에 관한 정보는 Application 메니페스트에 포함되기 때문에 안드로이드 시스템은 현재 작동하지 않는 Application의 BroadcastReceiver를 찾아서 실행시켜 줄 수 있으며, 물론 Application이 현재 작동 중이라면 그 Application에 속하는 BroadcastReceiver는 매우 효율적으로 실행됩니다. 마무리 결국, 안드로이드 Context는 여러가지 이유로 기존 플랫폼과는 다른 방식으로 Application을 관리하고 있고, 때문에 기존 플랫폼들에서는 단순하게 시스템 API를 통해 할 수 있는 일들을 Context 인스턴스라는 귀찮지만 강력한 녀석을 통해 대행 처리하고 있습니다. 참고 안드로이드/Android Context 란?","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Context","slug":"Context","permalink":"https://woovictory.github.io/tags/Context/"}]},{"title":"[SOPT] Seminar8","slug":"sopt-seminar8","date":"2018-06-09T05:14:08.000Z","updated":"2020-05-26T07:08:11.086Z","comments":true,"path":"2018/06/09/sopt-seminar8/","link":"","permalink":"https://woovictory.github.io/2018/06/09/sopt-seminar8/","excerpt":"","text":"페이스북 연동 로그인 마지막 세미나인 8주차 세미나 시간에는 가장 많이 쓰이면서 간단한 방식인 페이스북 연동 로그인을 할 것입니다. 실제로 AppJam을 한다면 SNS 연동 로그인 기능을 많이 사용하기 때문에 페이스북 연동 로그인을 실습할 예정입니다. Part1. 페이스북 개발자 등록과 앱 ID를 얻기 1. 먼저, Google에 페이스북 개발자를 검색하고 두 번째 항목을 선택합니다. 2. 우측 상단의 내 앱을 클릭합니다. 3. 새 앱 추가 버튼을 클릭합니다. 4. 앱 ID를 작성하고 앱 ID 만들기 버튼을 클릭합니다. 5. 위의 단계를 거치게 되면 다음과 같은 화면이 나옵니다. 6. 여기서 페이스북 로그인에서 설정을 클릭합니다. 7. 아래의 화면에서 iOS, Android, WWW 중에서 사용할 것을 선택합니다. 안드로이드 개발을 위해서 사용하므로 안드로이드를 선택합니다. 8. 1번은 다음을 선택해서 넘어갑니다. 9. 2번도 다음을 선택해서 넘어가도록 합니다. 10. 아래의 패키지 이름에 진행하고 있는 프로젝트의 Manifest 파일에 가서 패키지 이름을 복사한 다음 붙여넣기를 합니다. 기본 액티비티 클래스 이름은 작성하지 않아도 됩니다. 11. 그 다음에 좌측에 설정 - 기본 설정으로 들어간 다음에 하단의 플랫폼 추가를 클릭하여 패키지 이름과 해쉬 키 내용을 작성하고 저정을 누릅니다. 해쉬 키를 얻는 과정은 아래에서 설명하도록 하겠습니다. 12. 그리고 상단의 보이는 앱 ID를 복사한 다음 안드로이드 스튜디오에서 진행하는 프로젝트로 이동합니다. Part2. 해쉬 키를 얻고 페이스북 로그인을 진행해보자. 1. 먼저, 해쉬 키를 얻기 위해서 코드를 작성합니다. 아래의 코드는 세미나 시간에 파트장님께서 공유해주신 코드로 이 코드를 통해서 고유의 해쉬 키를 얻습니다. (참고로 지금 사용하는 해쉬 키는 나중에 배포할 때 사용하는 릴리즈용 해쉬 키와는 다릅니다. 따라서 배포를 위해서는 다시 릴리즈용 해쉬 키를 발급 받아서 사용해야 합니다. 지금은 배포의 목적이 아니기 때문에 이 해쉬 키를 사용합니다.) 이를 통해서 얻은 해쉬 키를 위의 과정에서 11번에 등록합니다. 123456789101112try &#123; val info = packageManager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES) for (signature in info.signatures) &#123; val md = MessageDigest.getInstance(\"SHA\") md.update(signature.toByteArray()) Log.d(\"KeyHash:\", Base64.encodeToString(md.digest(), Base64.DEFAULT)) &#125;&#125; catch (e: PackageManager.NameNotFoundException) &#123; e.printStackTrace()&#125; catch (e: NoSuchAlgorithmException) &#123; e.printStackTrace()&#125; 2. gradle의 Project 안에다가 mavenCentral()를 추가합니다. 3. 그 다음은 gradle의 app 안에 dependencies에 아래의 코드를 추가합니다. 1implementation &apos;com.facebook.android:facebook-login:[4,5)&apos; 4. 그리고 Manifest 파일에 페이스북 로그인을 위해서 인터넷 접근을 허용해줍니다. 5. 다음으로는 res - valuse - string.xml 파일에 Part1에서 얻은 앱 ID를 가져와서 등록합니다. (나의 앱 ID가 노출되기 때문에 가상의 앱 ID인 000000000000000를 사용하였습니다.) 6. 다음 과정은 Manifest의 application 태그 안에다가 provider, meta-data, activity를 추가해줍니다. 7. MainActivity에 버튼을 하나 추가하고 다음 코드를 작성한 뒤 실행을 하면 페이스북 로그인이 되는 것을 확인할 수 있습니다. 그리고 Log를 찍어 확인해보면 사용자의 정보를 페이스북으로부터 받아온 것을 볼 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MainActivity : AppCompatActivity() &#123; lateinit var callbackManager: CallbackManager // 커스텀을 이용한 로그인 버튼 생성 override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) callbackManager = CallbackManager.Factory.create() // 콜백 매니저 생성 main_fb_login_btn.setOnClickListener &#123; loginWithFaceBook() &#125; &#125; // facebook로 로그인한다는 함수 fun loginWithFaceBook()&#123; LoginManager.getInstance().logInWithReadPermissions(this@MainActivity, Arrays.asList(&quot;public_profile&quot;, &quot;email&quot;)) // profile과 email 정보를 가지고 오겠다. LoginManager.getInstance().registerCallback(callbackManager, object : FacebookCallback&lt;LoginResult&gt; &#123; // 콜백을 등록하겠다. override fun onSuccess(loginResult: LoginResult) &#123; val request: GraphRequest request = GraphRequest.newMeRequest(loginResult.accessToken) &#123; user, response -&gt; if (response.error != null) &#123; &#125; else &#123; Log.i(&quot;TAG&quot;, &quot;user: &quot; + user.toString()) Log.i(&quot;TAG&quot;, &quot;AccessToken: &quot; + loginResult.accessToken.token) // 유효 토큰값 Log.i(&quot;TAG&quot;, &quot;AccessToken: &quot; + loginResult.accessToken.userId) /*FIXME * 토큰값이나 userId로 사용자를 구분하는데 * 토큰 보다는 userId로 사용자를 구분하는것이 좋다. 왜냐하면 토큰은 만료 기간이 있기 때문에(짧지는 않지만) * 그래서 userId를 서버에 보내서 로그인하는 것이 좋다. * * 로그인을 성공해서 이 안으로 들어오면 받은 id(숫자로만 구성된것)를 서버에게 보낸다. (request) * 그러면 로그인에 대한 response가 돌아올 것! * * 근데, accessToken을 보내면 이것은 수시로 바뀌기 때문에 이것을 서버에게 보내주게 되면 서버가 처음에 우리가 보낸 토큰을 * 디비에 저장하지만 accessToken이 변하게 되면 디비에 없는 경우가 발생하게 된다. * 그래서 웬만하면 id를 보내는 방향으로 하는 것이 좋다.(서버와 말을 잘해서^^) * * */ setResult(Activity.RESULT_OK) &#125; &#125; val parameters = Bundle() parameters.putString(&quot;fields&quot;, &quot;id,name,email,gender,birthday&quot;) request.parameters = parameters request.executeAsync() &#125; override fun onCancel() &#123; &#125; override fun onError(error: FacebookException) &#123; &#125; &#125;) &#125; override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123; //super.onActivityResult(requestCode, resultCode, data) // 여기서는 메니페스트에 등록한 페이스북 로그인 액티비티를 부르고 여기서 필요한 정보들을 onActivityResult를 통해서 받아오게 된다. callbackManager.onActivityResult(requestCode, resultCode, data) &#125;&#125; Git 주의할 점 Git은 Crash가 많이 나서 즉, 충돌이 많이 발생한다…ㅜㅜ 애초에 Crash가 나지 않는 방법으로 깃을 사용하는 것이 좋다. init : 해당 프로젝트에 git을 사용함. init과 동시에 Git은 로컬에 저장소를 생성해준다. (세이브 폴더) commit : 로컬 저장소로 변경된 내용을 보낸다.(세이브) 그러면 로컬 저장소에 내가 추가한 내용이 저장되게 된다. 또한, 새로 추가되는 내용뿐만 아니라, 변경사항이 있다면 변경됨 문제점 저장소(세이브 파일)이 한개라는 문제가 발생한다. 예를 들어서 실수로 잘못 저장했을 때 돌아갈 수 없다. 또한, 저장 이력을 볼 수 없다. 이를 해결하기 위한 방법 중 하나로 브랜치를 사용한다. 브랜치 : 새로운 저장공간을 만듦 마스터 브랜치 : 중앙 저장소, 모든 브랜치는 결국 중앙저장소에 저장되어야 반영된다. (Android의 Main Thread 개념) 그냥 브랜치 : 추가 저장소, 모든 브랜치는 작업 완료 후, 마스터 브랜치에 합쳐져야 한다. merge : 브랜치를 합병한다.(세이브 파일을 합침) Github : 온라인 저장소(원격, remote)를 이용할 수 있도록 해주는 서비스 push : 로컬 저장소를 원격 저장소에 올림 pull : 내가 안전하다 싶으면 충돌이 날 거 같지 않으면 pull로 합침 fetch : 가져오기만 함. 그리고 그 이력을 보고 내가 수동으로 합침 clone : 원격 저장소를 내 컴퓨터에 복사함 pull, fetch는 local 저장소와 remote 저장소가 연동이 되어 있어야 한다. 하지만, clone는 연동이 되어있지 않아도 된다. TIP 작업을 먼저 하기 전에 pull을 한 다음에 자신이 할 작업을 한다. 퇴근 전 commit 출근 전 pull 작업 영역에서 남의 영역을 건드리지 말자! 혹시나 건드릴 것이라면 건드릴 작업영역이 같아지는 다음에 건드리자!! .gitignore .gitignore 파일을 만들어서 그 안에 올릴 파일과 올리지 않을 파일을 명시할 수 있다. AppJam을 할 때 Main 개발자는 저장소를 만들고 Sub 개발자들은 Fork를 한다. 그리고 Main 개발자가 .gitignore 파일을 작성할 때 무시할 파일을 명시하고 Sub 개발자는 올릴 파일을 명시한다. 이렇게 하면 서로의 영역을 침범하지 않아 충돌이 일어나는 경우를 최소화 할 수 있다. 123456789101112/* -&gt; 모든 파일을 올리지 않는다.!/abc.txt -&gt; 그 중에서 abc.txt는 빼고 즉, abc.txt는 올리겠다는 의미!폴더링은 항상 해야 한다.서브 개발자가 만약 api를 작업한다면api만 변경된 내용을 올려야 하기 때문에/*!/api/* -&gt; api 폴더는 올리겠다는 의미 위 처럼 하게 된다면 모든 파일을 올리지 않을 것이지만, api 폴더 밑에 있는 파일들은 제외하겠다. 즉, api 폴더는 올리겠다는 의미!! 폴더링 잘하고 .gitignore를 잘하면 된다. --&gt; 중요!!!","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[SOPT] Seminar7","slug":"sopt-seminar7","date":"2018-06-09T05:14:04.000Z","updated":"2020-05-26T07:08:08.435Z","comments":true,"path":"2018/06/09/sopt-seminar7/","link":"","permalink":"https://woovictory.github.io/2018/06/09/sopt-seminar7/","excerpt":"","text":"지금까지의 UI SOPT를 통해서 UI를 구현하는 법에서부터 기능까지 많은 것을 배울 수 있었다. 하지만 짧은 시간 안에 진행하는 세미나에서 많은 것을 얻기란 쉽지 않은 법! 지금까지 구현한 UI는 정적이다. 즉, 클릭 클릭 하면 끝나게 되는 것이다. 반면에 우리가 실제로 사용하는 앱(Facebook, Youtube 등)를 보면 스크롤, 로딩, 알람, 로딩 등등 다양하고 적절한 애니메이션이 존재한다. 다만, 동작 하나를 구현하기 위해서 필요한 코드는 생각 외로 복잡하고 버그나 에러의 발생 원인을 찾기가 어렵다. 하지만, 완성하면 통신 그 이상의 뿌듯함을 얻을 수 있다고 한다. (우리의 파트장 영규님의 말씀^^) 그래서 이번 세미나의 목표는 카카오톡에서 채팅방을 좌우로 스와이프 했을 때의 Animation을 흉내 내보고자 합니다. 애니메이션 구현은 3차 세미나에서 추가적으로 기능을 구현하였습니다. 구현한 코드는 아래의 제 Github 주소에서 확인할 수 있습니다. Github : https://github.com/WooVictory/SOPT_22th_Seminar3_HomeWork","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[SOPT] Seminar6","slug":"sopt-semniar6","date":"2018-06-08T16:26:45.000Z","updated":"2020-05-26T07:08:15.812Z","comments":true,"path":"2018/06/09/sopt-semniar6/","link":"","permalink":"https://woovictory.github.io/2018/06/09/sopt-semniar6/","excerpt":"","text":"이번주에는 내부 DB, Realm, SQLite에 대해 배워보겠습니다. 내부 DB 안드로이드 앱 개발을 하다보면 서버와 통신을 하면서 가끔 이런 생각을 하곤 합니다. 데이터가 어딘가에 저장되어 있어야 하는 건 맞고 서버랑 통신을 하긴 하는데, 굳이 이런 데이터까지 서버랑 통신을 해야하나… 혹은 오히려 서버랑 통신하면 더 불편할 정도로 정말 너무나도 간단한 데이터를 다루거나 서버한테 데이터를 맡기는 것보다는 내가 처리하는게 낫겠다라는 생각을 해본 적이 있습니다…(서버 디스는 아닙니다…^0^) SharedPreference 가장 간단하게 다룰 수 있는 데이터 저장 방식 자동 로그인을 사용할 때 특히 많이 쓰임 어플이 종료되어도 저장된 데이터는 사라지지 않음 어플이 삭제되면 저장된 데이터는 증발함 요청한 데이터가 없을 때 기본값을 지정할 수 있음 쿼리문이 없다. Code 12345678910111213// SharedPreference에 저장fun setId(context : Context, id : String)&#123; val pref = context.getSharedPreferences(USER, Context.MODE_PRIVATE) val editor = pref.edit() editor.putString(ID,id) editor.commit()&#125;// SharedPreference에서 가져오기fun getId(context : Context) : String&#123; val pref = context.getSharedPreferences(USER, Context.MODE_PRIVATE) return pref.getString(ID, \"\")&#125; Realm 최근 각광받는 Mobile Database 쿼리문을 사용하지 않음 객체들로 하여금 데이터를 다룸 어플이 종료되어도 데이터는 유지 어플이 삭제되면 데이터는 증발함 일단 DB처럼 Primary Key를 필수로 지정해야 함 데이터가 만일 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 데이터 저장 객체 생성open class MemberVO : RealmObject()&#123; @PrimaryKey var id : String = \"\" var pwd : String = \"\"&#125;// Realm 초기화fun init()&#123; Realm.init(this) memberRealm = Realm.getDefaultInstance()&#125;// 데이터 가져오기fun getMemberList(id : String) : RealmResults&lt;MemberVO&gt;&#123; return memberRealm.where(MemberVO::class.java) .equalTo(\"id\",id).findAll()&#125;// 데이터 삽입fun insertMemberList()&#123; memberVO = MemberVO() memberVO.id = sign_id_edit.text.toString() memberVO.pwd = sign_pw_edit.text.toString() memberRealm.beginTransaction() memberRealm.copyToRealm(memberVO) memberRealm.commitTransaction()&#125;// 데이터 삭제fun deletePokemonList(name : String)&#123; val result = pokemonRealm.where(PokemonVO::class.java) .equalTo(\"name\",name) .findAll() if(result.isEmpty())&#123; return &#125; pokemonRealm.beginTransaction() result.deleteAllFromRealm() pokemonRealm.commitTransaction()&#125; 별도의 과제는 없고 내가 우아한 테크 캠프 코딩 테스트를 보느라 출석만 하고 바로 빠져나오는 바람에 세미나를 듣지 못하였다. 일단은 혼자 자료를 보면서 정리하였는데, 얼른 프로젝트를 보면서 혼자 만들어보면서 공부해야겠다. 공부한 다음에 Github에 코드를 올릴 예정이다.","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[11723] 집합","slug":"BOJ11723","date":"2018-06-08T05:35:26.000Z","updated":"2018-12-04T08:31:48.475Z","comments":true,"path":"2018/06/08/BOJ11723/","link":"","permalink":"https://woovictory.github.io/2018/06/08/BOJ11723/","excerpt":"","text":"한 동안 졸업 작품과 다른 것들로 인해서 바빠서 알고리즘을 풀지 못했다… 이런 나를 반성하면서 다시 꾸준하게 알고리즘을 풀면서 공부해야겠다!! 문제 : https://www.acmicpc.net/problem/11723 Explain 비어있는 공집합 S가 있고, 문제에 나온 명령어가 주어졌을 때 명령어에 따라 연산을 진행한다. 입력 : 첫 줄에 수행하는 연산의 수인 M이 주어진다. (1&lt;=M&lt;=3,000,000) 출력 : check 연산이 주어질 때마다, 출력한다. Key Points 간단하게 비트 마스크를 이용하여 문제를 풀어보았다. 비트 마스크를 이용하여 문제에 원하는 추가, 삭제, 검색 등을 구현할 수 있다. 문제에서 집합에 추가하는 수인 x의 범위가 1&lt;=x&lt;=20이다. 하지만, 비트 마스크는 0 ~ N-1 까지의 수를 저장하고 있기 때문에 문제를 풀기 위해서는 입력 받은 수 모두 1을 빼주어서 0 ~ 19 로 맞추고 문제를 풀면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class BOJ11723 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; // 내가 배운 비트마스크는 0~N-1 까지의 수를 저장하고 있기 때문에 // 이 문제를 풀기 위해서는 입력으로 받은 수를 모두 1을 빼주고 0~19로 만든 다음에 구현하면 된다. // 왜냐하면 문제에서 집합에 추가할 수 있는 x의 범위가 1~20이기 때문에 내가 배운 비트마스크의 범위인 0~N-1을 맞추기 위해서 // 입력받은 집합에서 1씩 빼주어 0~19 사이의 범위로 맞춘다. BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = 20; int s = 0; // 처음에 비어있는 집합 생성 int M = Integer.parseInt(bf.readLine()); // test_case StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;M;i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); String command = st.nextToken(); if(command.equals(\"add\")) &#123; int x = Integer.parseInt(st.nextToken()); x--; s = s | (1&lt;&lt;x); &#125; else if(command.equals(\"remove\")) &#123; int x = Integer.parseInt(st.nextToken()); x--; s = s &amp; ~(1&lt;&lt;x); &#125; else if(command.equals(\"check\")) &#123; int x = Integer.parseInt(st.nextToken()); x--; int tmp = s &amp; (1&lt;&lt;x); if(tmp !=0) &#123; sb.append(\"1\"); sb.append(\"\\n\"); &#125; else &#123; sb.append(\"0\"); sb.append(\"\\n\"); &#125; &#125; else if(command.equals(\"toggle\")) &#123; int x = Integer.parseInt(st.nextToken()); x--; s = s ^ (1&lt;&lt;x); &#125; else if(command.equals(\"all\")) &#123; s = (1&lt;&lt;N) - 1; &#125; else if(command.equals(\"empty\")) &#123; s = 0; &#125; &#125; System.out.println(sb.toString()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[BoostCourse] 2. Event와 ListView","slug":"boostcourse2","date":"2018-06-04T14:29:38.000Z","updated":"2018-12-04T08:25:45.645Z","comments":true,"path":"2018/06/04/boostcourse2/","link":"","permalink":"https://woovictory.github.io/2018/06/04/boostcourse2/","excerpt":"","text":"스크롤뷰 사용하기 테이블 레이아웃 격자 형태로 뷰를 배치할 때 사용한다. TableLayout 안쪽에 TableRow를 넣으면 그것이 한 줄을 나타낸다. 각각의 줄(행)이 추가할 때는 TableRow 태그를 이용해서 추가하면 된다. 여러 개의 TableRow가 추가될 수 있고 각각의 TableRow 안에는 여러 개의 뷰가 들어갈 수 있는 구조로 되어 있다. 리니어 레이아웃 안에 리니어 레이아웃을 넣는 방식을 사용해도 격자 모양을 만들 수 있지만 테이블 레이아웃을 사용하면 좀 더 쉽게 만들 수 있다. TableRow 태그 안에 있는 Button에 layout_column 속성을 이용해서 해당되는 칼럼의 인덱스에 위치시킬 수 있다. stretchColumns란? TableRow에 Button과 같은 위젯을 추가하게 되면 각각이 칼럼이 된다. 그리고 0,1,2 이렇게 번호를 가지고 추가가 된다. 하지만, 이렇게 되면 오른쪽에 공간이 남게 되기 때문에 이 공간을 버튼 3개가 꽉 차게 가지고 싶다면?? stretchColumns라는 속성을 사용하면 된다. 콤마로 구분하게 되는 0,1,2 이렇게 값을 넣어주면 0,1,2가 남아있는 여유 공간을 다 차지하도록 해준다. 즉, 0,1,2 세개의 칼럼이 추가가 되는데, 그거를 전부 다 가로를 꽉 채워달라는 의미 스크롤뷰(ScrollView) 글자나 이미지가 들어간 뷰가 화면 영역을 벗어나면 보이지 않게 된다. 이 때는 손가락으로 스크롤 하여 보이지 않는 부분을 보이도록 만들어주어야 한다. ScrollView는 이런 스크롤 기능을 쉽게 만들 수 있도록 도와준다. ImageView나 TextView등의 뷰를 ScrollView로 감싸주면 ScrollView가 뷰의 영역을 계산하게 된다. 그리고 화면에 보이는 공간을 넘어갔을 때 자동으로 스크롤을 만들어 준다. ScrollView의 속성으로 상,하 스크롤을 할 것인지 좌,우 스크롤을 할 지 설정할 수 있다.","categories":[],"tags":[]},{"title":"[SOPT] Seminar5","slug":"sopt-seminar5","date":"2018-05-19T05:22:15.000Z","updated":"2020-05-26T07:08:05.493Z","comments":true,"path":"2018/05/19/sopt-seminar5/","link":"","permalink":"https://woovictory.github.io/2018/05/19/sopt-seminar5/","excerpt":"","text":"스플래쉬 + 폰트 + 아이콘 스플래쉬(Splash) 백그라운드에 있지 않은 어플리케이션을 실행했을 때 맨 처음 나오는 화면 (보통은 로그인 하기 전에 나오는 화면)을 말한다. 사용자로 하여금 앱이 실행되고 있음을 보여준다. 로그인 전에 서버와 통신해야 할 부분이나 기타 처리할 데이터가 있으면 이 화면에서 처리한다. 폰트 외부 폰트를 안드로이드 스튜디오 내에서 사용할 수 있도록 xml로 작성한다. res -&gt; new -&gt; Android Resource Directroy에서 font를 추가 사용할 폰트를 font 폴더에 추가한다. 그리고 추가한 폰트를 사용하는 xml 파일을 작성한다. 그리고 layout xml 파일에서 사용할 폰트 xml 파일을 적용한다. 아이콘 우리가 사용하는 앱의 아이콘은 어떻게 설정할까요?? 그렇게 어렵지 않습니다. res -&gt; mimmap -&gt; new -&gt; Image Asset에서 새로운 아이콘 이미지 추가 Path에서 사용하고 싶은 이미지를 불러오고 적용 시키면 끝!! 화면의 이해 해상도 : 하나의 이미지를 표혀하는데 몇 개의 픽셀(pixel) 또는 도트(dot)로 나타내는 지의 정도를 알려주는 지표 안드로이드 운영체제를 가진 device는 다양한 종류가 존재한다. 즉 너무나도 다양한 해상도가 존재하는 것이다. 이처럼 다양한 해상도를 가진 device에 뷰를 맞춰서 개발하는 것은 힘든 일이다. 이와 같은 문제를 잘 해결하기 위해서 다음에서 설명하는 개념들을 잘 알고 있어야 한다. 픽셀의 이해 픽셀은 고정값이다. 그래서 크기가 변한다. 값은 고정이지만 해상도별로 달라보이는 문제가 발생한다. 그래서 값은 고정이어도 크기는 변한다. 그래서 픽셀로는 화면에 대응하기가 힘들다. 픽셀 : 기기 대응이 힘들다. DP dp는 디바이스에 따라 값이 변한다. 그래서 크기가 고정된다. 기기 해상도에 따라 네모 사이즈가 같아보인다. (디바이스 해상도에 따라 크기의 사이즈가 조정되었기 때문) 그래서 device는 달라도 크기는 고정된다. 이 때문에 디자이너가 여러 dp에 대응하게끔 이미지를 준다. 문제 같은 dp라 할지라도 화면 너비, 높이에 따라 차지하는 정도는 달라질 수 있다.즉, 여백 문제가 발생함 크기 중심으로 갈 지 여백 중심으로 갈 지 잘 판단해야 한다. 우선적으로는 사용할 대표 기기를 선정하는 것이 그나마 수치의 오차를 줄일 수 있는 방법 사실상, 가장 확실한 방법은 기기마다 레이아웃을 짜는 것이지만, 쉽지는 않다. SP 글자에 많이 쓰이는 사이즈 단위 글자가 가지는 고유의 사이즈에 비례해서 크기가 변하는 것 기본 원리는 dp와 유사 사용자가 설정한 글꼴에 따라 호환되어 사이즈 조정 디자이너와 협동하기 방법 서로가 고생하기 디자이너는 모든 기기에 대한 디자인을 만든다 개발자는 모든 기기에 대한 레이아웃을 짠다. 가능할까? Build 클래스를 통해 기기 분류가 가능하다. 가장 정확한 방법이지만, SOPT에서 진행하는 2주간의 App Jam에서는 시간이 부족하고 불가능한 방법이다. 적당히 타협하기 중요도를 묻는다. – 뷰 자체의 크기가 중요하면 뷰 위주로 값을 넣을 것 – 배치 및 공간이 중요하면 여백 위주로 값을 넣을 것 기기들의 태생적 한계를 공유한다. – 기기가 너무 다양한 나머지 디자인적인 차이와 한계가 존재한다. – 디자이너가 기준으로 정한 기기 이외의 기기들과는 보이는 모습이 조금 달라 질 수 있음을 충분히 인지시키자. 수치를 최대한 자세하게 요구한다. – 길이든 색상이든 일단 최대한 빈틈없이 알려달라 할 것 – 수치를 보면 무엇이 중요한지(자체 크기, 공간) 어느정도 판단 가능 이미지 이름은 꼭 소문자, 밑줄(_) 그리고 숫자 조합지어달라 한다. 과제 세미나 시간 동안 디자이너와 협업한 View 완성하기(SeekBar 사용) 참고 : 기능은 구현하지 않고 View 만 구현하였습니다. Github : https://github.com/WooVictory/SOPT_22th_Seminar5_HomeWork 다른 뮤직 플레이어 (Progressbar Wheel 사용) Github : https://github.com/WooVictory/SOPT_22th_Seminar5_Preview","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[9025] 맥주 마시며 걸어가기","slug":"BOJ9025","date":"2018-05-18T15:39:21.000Z","updated":"2018-12-04T08:30:26.258Z","comments":true,"path":"2018/05/19/BOJ9025/","link":"","permalink":"https://woovictory.github.io/2018/05/19/BOJ9025/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/9025 Key Points 편의점의 위치가 상근이네 집 즉 출발점과 가까운 위치에 있는 것이 아니라 일일히 확인해봐야 한다. 그 말은 모든 경우를 다 해봐야 하는 것이다. 즉, BFS로 문제를 접근해서 풀어야 한다. Explain 시작위치, 편의점위치, 도착지의 좌표 모두 클래스 배열인 location[]에 넣어준다. 시작위치로부터 출발한다. (큐에 넣어준다.) 출발하여 location[] 클래스 배열 안에 있는 조건에 맞는 좌표를 방문한다. 조건은 출발위치로부터 다음 위치의 차이가 1000이하이고, 방문하지 않은 점이어야 한다. 페스티벌 위치 즉 도착지와 계속 비교하면서 페스티벌 위치라면 즉시 boolean success를 true로 변경하고 빠져나온다. boolean success에 따라 결과를 출력하면 된다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Exam9205 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; // 모든 경우를 다 해보는 BFS 문제 BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); // 테스크 케이스 입력 for(int i=0;i&lt;test_case;i++) &#123; int N = Integer.parseInt(bf.readLine()); LOCATION[] location = new LOCATION[N+2]; // 모든 위치의 좌표를 저장하기 위한 클래스 배열 int[] check = new int[N+2]; // 방문했는지 안했는지 확인하기 위한 배열 Queue&lt;LOCATION&gt; q = new LinkedList&lt;LOCATION&gt;(); boolean success = false; // 도착지에 도달하면 true로 바꾼다. for(int j=0;j&lt;N+2;j++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;); location[j] = new LOCATION(Integer.parseInt(st.nextToken()) ,Integer.parseInt(st.nextToken())); &#125; // 입력 끝 LOCATION start = location[0]; // 출발지점 LOCATION end = location[N+1]; // 도착지점 q.add(start); // 큐에 넣는다. while(!q.isEmpty()) &#123; LOCATION current = q.poll(); // 삭제하면서 원소를 뺀다. if(current.equals(end)) &#123; // 도착지점에 도착하면 success를 true로 바꾸고 탈출 success = true; break; &#125; for(int j=1;j&lt;N+2;j++) &#123; if(check[j] == 0 &amp;&amp; Math.abs(current.x - location[j].x) + Math.abs(current.y - location[j].y) &lt;=1000) &#123; // 조건 : 방문하지 않았고, 좌표의 차이가 1000이하인 것들만 큐에 저장한다. q.add(location[j]); // 큐에 넣는다. check[j] = 1; // 방문했음을 표시 &#125; &#125; &#125; if(success) System.out.println(&quot;happy&quot;); else System.out.println(&quot;sad&quot;); &#125; &#125;&#125;// 좌표를 저장하는 클래스 배열class LOCATION&#123; int x; int y; LOCATION(int x, int y)&#123; this.x = x; this.y = y; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[2407] 조합","slug":"BOJ2407","date":"2018-05-18T15:07:07.000Z","updated":"2018-12-04T08:30:12.931Z","comments":true,"path":"2018/05/19/BOJ2407/","link":"","permalink":"https://woovictory.github.io/2018/05/19/BOJ2407/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/2407 Key Points 이 문제를 풀기 위해서는 먼저 순열과 조합의 개념에 대해 알고 있어야 한다. 순서가 있는 경우 : 순열(Permutation) [서로 다른 n 개 중 r 개를 뽑아서 나열하는 경우] 순서가 없는 경우 : 조합(Combination) [서로 다른 n 개 중 r 개를 뽑는 경우] 아래와 같은 방법으로 계산한다. 이 문제는 메모이제이션이라는 방법을 이용하여 조합의 공식에 따라서 구했다. Explain Memoization(메모이제이션)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게하는 기술이다. 동적 계획법의 핵심이 되는 기술이다. 메모이제이션을 이용하면 조합의 값을 구하기 위해 파스칼 삼각형의 꼭대기까지 올라갈 필요 없이 바로 좌우측 상단의 값을 메모리에서 불러와 이용할 수 있다. Code 1234567891011121314151617181920212223242526272829public class Exam2407 &#123; public static void main(String[] args) throws IOException &#123; BigInteger[][] list; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BigInteger big = new BigInteger(&quot;1&quot;); StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;); int n = Integer.parseInt(st.nextToken()); int m = Integer.parseInt(st.nextToken()); list = new BigInteger[10001][10001]; list[1][0] = list[1][1] = big; for(int i=2;i&lt;=n;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; if(i == j || j == 0) &#123; list[i][j] = big; &#125;else &#123; list[i][j] = list[i-1][j-1].add(list[i-1][j]); &#125; &#125; &#125; System.out.println(list[n][m]); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[14501] 퇴사","slug":"BOJ14501","date":"2018-05-18T14:06:58.000Z","updated":"2018-12-04T08:31:50.815Z","comments":true,"path":"2018/05/18/BOJ14501/","link":"","permalink":"https://woovictory.github.io/2018/05/18/BOJ14501/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/14501 Key Points 위의 상담 일정표에서 확인 할 수 있듯이 힌트를 얻을 수 있다. 백준이는 오늘로부터 N+1일째 되는 날 퇴사를 한다. 그래서 남은 N일 동안 최대한 많은 상담을 하려 한다. 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 마찬가지로 2일에 있는 상담을 하게 되면, 3,4,5,6일에 잡혀있는 상담을 할 수 없게 된다. Explain 문제를 위한 점화식을 도출해보자. dp[N] = N일까지 얻는 이익 이라 하자. N일을 기준으로 N일 이전에 이익을 얻을 수 있는 경우를 모두 비교하면 된다. dp[5] = Max(5일의 이익 + 1일까지의 이익, 5일까지의 이익) dp[5] = Max(5일의 이익 + 2일까지의 이익, 5일까지의 이익) dp[5] = Max(5일의 이익 + 3일까지의 이익, 5일까지의 이익) dp[5] = Max(5일의 이익 + 4일까지의 이익, 5일까지의 이익) 위와 같이 dp 배열의 값을 문제의 조건을 성립시켜 가면서 갱신해 나간다. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Exam14501 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); // test_case 입력 받는다. int max = 0; // 최대값 int[] T = new int[N+1]; // 상담하는데 걸리는 기간 T int[] P = new int[N+1]; // 상담하는데 드는 비용 P int[] dp = new int[N+1]; for(int i=0;i&lt;N;i++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); T[i] = Integer.parseInt(st.nextToken()); P[i] = Integer.parseInt(st.nextToken()); dp[i] = P[i]; &#125; // dp[N] = N일때까지 얻은 이익 // 처음 상담은 두 번째 for문에서 등장함. for(int i=2;i&lt;=N;i++) &#123; for(int j=1;j&lt;i;j++) &#123; if(i-j &gt;=T[j]) &#123; // 처음 상담 기간을 지나고 계속해서 갱신하기 위함 dp[i] = Math.max(P[i]+dp[j], dp[i]); &#125; &#125; &#125; // dp 배열이 갱신된다. // 갱신된 배열을 가지고 max 값을 찾는다. for(int i=1;i&lt;=N;i++) &#123; if(i+T[i]&lt;=N+1) &#123; if(max&lt;dp[i]) &#123; max = dp[i]; &#125; &#125; &#125; System.out.println(max); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"네트워크 :: 네트워크?","slug":"network","date":"2018-05-17T14:09:03.000Z","updated":"2020-05-12T15:07:57.320Z","comments":true,"path":"2018/05/17/network/","link":"","permalink":"https://woovictory.github.io/2018/05/17/network/","excerpt":"","text":"HTTP 소개 HTTP란?? HyperText Transfer Protocol의 약자로 하이퍼 텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, Web Server와 Web Client 간의 통신을 하기 위한 통신 규약이다. HTTP는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 월드 와이드 웹(WWW)기반에서 전 세계적인 정보 공유를 이루는데 큰 역할을 하였다. HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 요청과 응답을 전송한다. HTTP 특징 HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석이 된다. TCP/IP를 이용하는 응용 프로토콜 HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜 (이러한 단점을 해결하기 위해 Cookei와 Seesing등장) HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청(request)/응답(response) 방식으로 동작한다. 동작 예를들면, 클라이언트(client) 즉, 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 요청(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 응답(response)하는 형태로 동작합니다 요청 : client -&gt; server 응답 : server -&gt; client HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다 Plain text로부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며, 보통은 client가 어떤 정보를 HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지 명시해주는 경우가 많다. HTTP의 GET과 POST 비교 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다. 하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용할 수 있도록 알아보자. GET 우선 GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request를 보내게 되는 것이다. 이러한 방식은 url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되므로 GET 방식은 적절하지 한다.(ex. password) POST POST 방식의 request는 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다. (하지만 보안적인 측면에서는 암호화를 하지 않는다면 고만고만하다…^^) 우선 GET은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여주는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT적인 성향을 가지고 있다고 볼 수 있다. 반면에 POST는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다. 부수적인 차이점을 좀 더 살펴보면 GET 방식의 요청은 브라우제에서 Caching할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다. TCP 3-way-handshake &amp; 4-way-handshake 연결 성립(Connection Establishment) client는 server에 접속을 요청하는 SYN(a)을 보낸다. server는 client의 요청인 SYN(a)을 받고 client에게 요청을 수락한다는 ACK(a+1)와 SYN(b)이 설정된 패킷을 발송한다. client는 server의 수락 응답인 ACK(a+1)와 SYN(b) 패킷을 받고 ACK(b+1)를 server로 보내면 연결이 성립(establish)된다. 연결 해제(Connection Termination) client가 연결을 종료하겠다는 FIN 플래그를 전송한다. server는 client의 요청(FIN)을 받고 알겠다는 확인 메시지로 ACK를 보낸다. 2-1. 그리고 나서는 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다. 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 client에게 FIN 플래그를 전송한다. client는 FIN 메시지를 확인했다는 **메시지(ACK)**를 보낸다. client의 ACK 메시지를 받은 server는 소켓 연결을 close한다. client는 아직 server로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT) SYN : synchronize sequence number ACK : acknowledgement TCP header에는 Code Bit(Flag bit)라는 부분이 존재한다. 이 부분은 총 6bit로 이루어져 있으며 각각 한 bit들이 의미를 가지고 있다. Urg-Ack-Psh-Rst-Syn-Fin 순서로 되어 있으며 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷이닞를 나타낸다. SYN 패킷일 경우에는 000010이 되고, ACK 패킷일 경우에는 010000이 되는 것이다. Why tow types of packets? 일단 연결을 성립하려면 서로 통신이 가능한지를 먼저 파악하기 위해 패킷을 먼저 주고 받아야 한다는 것까지 이해가 되었다. 그런데 두 종류의 패킷을 주고 받는 다는 것은 요청과 응답에 대한 패킷을 주고 받아야 하기 때문에 두 종류인 것이다. client가 자신의 목소리가 들리는지 물어본다.(SYN) server는 client의 목소리가 들린다고 말한다.(SYN+1) 그리고 자신(server)의 목소리가 들리는지 물어본다. (ACK) client는 server의 목소리가 들린다고 말한다. (ACK+1) 이런 과정인 셈이다. TCP Connection은 양방향성 connection이다. client에서 server의 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, server에서도 client에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. 그렇기 때문에 2-way-handshake로는 부족하고 3-way-handshake를 사용해야 한다. Why randomized sequence number? 처음 client에서 SYN 패킷을 보낼 때 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 sequence number ISN이라고 한다. ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇일까??? 그에 대한 해답은 여기서 확인할 수 있다. Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. server 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있는 문제가 생긴다. 이러한 문제가 발생할 가능성을 줄이기 위해 난수로 ISN을 설정하는 것이다. TCP vs UDP 인터넷은 Transport 계층에 연결형 프로토콜과 비연결형 프로토콜 두 개의 주된 프로토콜을 갖는다. UDP UDP(User Datagram Protocol)는 비연결형 프로토콜이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. 또한, UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다. UDP가 특별히 유용한 분야는 Client-Server 상황이다. 종종 client는 server로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, client는 time out 되고 다시 시도할 수 있다. 코드가 간단할 뿐만 아니라 TCP처럼 초기설정에서 요구되는 프로토콜에서보다 적은 메시지가 요구된다. UDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다. UDP가 사용되는 또 다른 분야로는 실시간 멀티미디어가 있다. 실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 데이터 패킷 형식으로 전송하는 실시간 트랜스포트 프로토콜 (RTP : Real-time Transport Protocol)이 탄생했다. RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 멀티플렉싱하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지로 전송될 수 있다. RTP는 단지 일반적인 UDP를 사용하기 때문에 전달, 지연, 손실 등에 대한 특별한 보장이 없다. 이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 바로 전 패킷보다 하나 높은 번호가 주어진다. 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 분실되었는지 알 수 있게 한다. 만약 한 패킷이 없다면 이를 획득하기 위해 목적지에서의 최상의 동작은 보간(Interpolation)에 의해 손실한 값에 대한 근사치를 얻는 것이다. 재전송은 재전송된 패킷이 유용하기에 너무 늦게 도착하므로 실용적인 옵션이 아니다. 그러므로 RTP는 확인 응답이 없고 재전송을 요청하는 매커니즘도 없다. TCP 대부분의 인터넷 응용분야들은 신뢰성과 순차적인 전달을 필요로 한다. UDP로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다. TCP(Transmission Control Protocol)는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 서비스를 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다. 모든 TCP 연결은 전이중(full-duplex), 점대점(point to point) 방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다. TCP는 멀티 캐스팅이나 브로드 캐스팅을 지원하지 않는다. 또한 메시지 스트림이 아니라 바이트 스트림의 형태를 갖는다. 메시지의 시작에서 끝까지의 경계가 유지되지 않는다. TCP의 특징은 TCP 연결상의 모든 바이트가 고유의 32-비트 순서번호(sequence nunmber)를 갖는다는 것이다. 송수신 TCP 개체들은 세그먼트의 형태로서 데이터를 주고 받는다. 한 세그먼트는 고정 2바이트 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다. TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다. 세그먼트 크기에는 두 가지 제약요소가 있다. 한 가지는 모든 세그먼트들은 TCP 헤더를 포함하여 IP 수용량인 65,515바이트를 넘을 수 없다는 것이며 나머지 하나는 모든 네트워크는 정해진 MTU(Maximum transfer Unit, 최대 전송 단위)를 갖는데 각 세그먼트는 MTU를 넘을 수 없다는 것이다. TCP 개체들에 의해 사용되는 기본 프로토콜은 동적으로 윈도우 크기를 조절하는 슬라이딩 윈도우(sliding window)프로토콜이다. 송신자는 한 세그먼트를 전송할 때, 타이머를 구동시킨다. 그 세그먼트가 목적지에 도달하면, 수신측 TCP 개체는 다음에 받으려고 하는 순서번호와 같은 확인 응답 번호를 포함하는 세그먼트를 송신측으로 보낸다. 보낼 데이터가 있다면 그 데이터와 함께 보낸다. 만일 확인 응답의 수신 전에 보낼 때 구동시킨 타이머가 종료되면 송신자는 그 세그먼트를 재전송한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 하는 장치가 필요하다. 스트림 내의 각 바이트가 자기 고유의 offset을 가지고 있는 것을 그 장치로 한다. TCP에서 연결 설정(connection establishment)는 3-way-handshake를 통해 행해진다. 하나의 연결을 설정하려면 한쪽(서버)은 listen과 accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 listen과 accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 다른 한쪽(client)은 connect를 실행하고 목적지 IP 주소와 포트, 수신 가능한 최대 TCP 세그먼트 크기 그리고 기타 사용자 데이터를 명시한다. TCP에서 흐름제어는 가변 크기의 슬라이딩 윈도우를 사용하여 처리된다. window size 필드는 확인 응답된 바이트에서 시작하여 얼마나 많은 바이트가 보내질 수 있는지를 나타낸다. 그러나 이 경우 좋지 않은 상황이 발생할 수 있다. 송신자는 응용 프로그램에서 데이터가 올 때마다 전송할 필요가 없고 수신자도 마찬가지로 데이터를 받은 즉시 확인 응답을 해야 하는 것이 아니다. 버퍼를 사용하면 되기 때문에 데이터를 모아서 보내거나 그것을 받고 애플리케이션에서 모아서 전달할 수 있는 것이다. 각 키보드 입력마다 즉시 반응해야 하는 '인터렉티브 에디터(Interactive Editor)라면 어떨까?? 송신측에서 한 번에 1 바이트씩 데이터를 전송해오는 것이다. 이러한 상황을 해결하기 위해 지연 확인 응답(delayed acknowledgement)방법을 사용한다. 응답 메시지를 전송하는 것과 윈도우 사이즈를 갱신하는 것을 지연시키는 것이다. 하지만 이 방법이 네트워크 부하를 감소시켜준다고 할 지라도 송신측에서는 계속해서 1바이트씩 보내게 된다. 그래서 네이글 알고리즘(Nagle Algorithm)을 통해 해결하곤 한다. 데이터가 한 번에 한 바이트씩 송신자에게 올 경우, 첫 번째 바이트만을 송신하고 나머지는 보낸 바이트에 대한 명백한 확인 응답이 올 때까지 버퍼에 보관한다는 것이다. 그리고 버퍼 내의 모든 문자를 하나의 TCP 세그먼트로서 전송한 후, 또 응답 메시지가 도착할 때까지 버퍼에 전송할 데이터를 저장한다. 하지만 이 알고리즘이 교착상태를 야기할 수 있고 그 결과 웹 페이지의 다운을 초래할 수 있다. 그런데 애플리케이션이 수신된 데이터를 1 바이트씩 가져간다면 어떻게 될까?? 수신측은 버퍼에서 1 바이트가 비었기 때문에 window size를 1 바이트로 설정해서 응답을 하게 되고 송신측은 window size가 1 바이트니 1 바이트만큼의 데이터를 전송하게 된다. 1 바이트의 데이터를 보내기 위해서 41 바이트의 패킷 구성을 하는 비효율적인 상황이 발생하게 된다. 이런 상황을 silly window syndrome이라고 하는데, 이 상황을 최적화 하기 위해 1 바이트에 해당하는 윈도우 사이즈를 통보하지 않는다. 설정 당시 통보한 세그먼트의 최대 크기를 처리할 수 있게 되거나, 버퍼의 반이 빈 상태가 될 때까지 통보하지 않는 것이다. 송신자 측도 윈도우 사이즈가 커질 때까지 기다리는 것이다.","categories":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/categories/네트워크/"}],"tags":[{"name":"네트워크","slug":"네트워크","permalink":"https://woovictory.github.io/tags/네트워크/"},{"name":"network","slug":"network","permalink":"https://woovictory.github.io/tags/network/"},{"name":"computer science","slug":"computer-science","permalink":"https://woovictory.github.io/tags/computer-science/"}]},{"title":"자료구조 :: 자료구조?","slug":"DataStructure","date":"2018-05-16T16:07:37.000Z","updated":"2020-05-12T06:37:59.627Z","comments":true,"path":"2018/05/17/DataStructure/","link":"","permalink":"https://woovictory.github.io/2018/05/17/DataStructure/","excerpt":"","text":"[2020.05.12] 이 글은 굉장히 오래 전에 작성된 글입니다. 그래서 정리라기 보다는 내용을 한 곳에 썼다는 표현이 나을 것 같네요! 삭제하려고 했지만, 많은 내용을 담고 있어 레거시로 유지하려고 합니다. :) 이 페이지의 내용들이 여러 포스팅으로 나누어 작성되었으니 그 글을 참고하면 좋을 것 같습니다. 자료구조란 무엇인가?? 자료구조 하면 무엇이 떠오를까요??? 흔한 자료구조의 형태로 큐(Queue)나 스택(Stack) 혹은 연결 리스트(Linked List), 트리(Tree) 등을 떠올리거나 선택정렬, 삽입 정렬 등등의 정렬 알고리즘 등이 먼저 떠오릅니다. 사전적인 의미는 자료(data)의 집합을 의미하며, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것이라고 한다. 목적은 명확하다. 자료를 더 효율적으로 저장하고, 관리하기 위해 사용하며, 잘 선택된 자료구조는 실행시간을 단축시켜주거나 메모리 용량의 절약을 이끌어 낼 수 있다. 자료구조의 선택 기준 자료의 처리 시간 자료의 크기 자료의 활용 빈도 자료의 갱신 정도 프로그램의 용이성 자료의 처리를 보다 효율적으로 하기 위해서 위와 같은 사항을 고려하여 선택, 사용해야 한다. 자료구조의 특징 효율성 자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다. Ex) 검색에 대한 알고리즘을 구현할 때, 데이터의 양이 많다면 순차 검색을 사용하는 것보다 이분 검색을 활용하는 것이 더 효율적일 것이다. 왜냐하면 학생이라는 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다. 이에 반해 이분 검색은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다. 추상화 추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 더 시간을 쏟을 수 있다. 알고리즘 자체에는 중점을 두지 않는다. 마찬가지로 자료구조 내부의 구현은 중요하지 않다. 어떻게 구현했는지 보다 어떻게 사용해야 하는지를 알고 있어야 한다. Ex) Stack의 경우 먼저 들어간 것이 나중에 나오는 LIFO(Last In First Out)의 형태를 가지고 있다. 그리고 push() 함수를 이용해서 데이터를 삽입할 수 있고, pop() 함수를 이용해서 데이터를 추출할 수 있다. 그 함수 내부 구현이 어떻게 되었는지는 중요하지 않다. 사람마다 다른 코드를 작성할 것이고, 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다. 재사용성 자료구조를 설계할 때 특정 프로그램에서만 동작하게 설계 하지는 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다. 자료구조의 분류 자료구조는 크게 선형 자료구조와 비선형 자료구조로 나뉜다. 선형 자료구조 : 데이터가 일렬로 나열되어 있는 것을 뜻한다. 배열(Array) 연결 리스트(Linked List) 스택(Stack) 큐(Queue) 비선형 자료구조 : 특정한 형태를 띄고 있는 것을 뜻함 트리(Tree) 그래프(Graph) Array vs Linked List Array 가장 기본적인 자료구조인 Array 자료구조는, 논리적 저장 순서와 물리적 저장 순서가 일치한다. 따라서 인덱스(index)로 해당 원소에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 시간 복잡도 O(1)에 해당 원소로 접근할 수 있다. 즉 random access가 가능하다는 장점이 존재 하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약, 배열 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity와 worst case는 O(n)이 된다. 삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1씩 shift 해줘야 하므로 이 경우도 시간 복잡도 O(n)을 갖게 된다. Linked List 이 부분에 대한 문제점을 해결하기 위한 자료구조가 Linked List이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 시간 복잡도 O(1)만에 해결할 수 있다. 하지만 Linked List 역시 한 가지 문제가 존재한다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 하는 과정에 있어서 첫 번째 원소부터 모두 확인해봐야 한다는 것이다. Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 시간 복잡도 O(n)의 시간이 추가적으로 발생하게 된다. 결국 Linked List 자료구조는 Search에도 O(n)의 시간 복잡도를 갖고, 삽입, 삭제에 대해서도 O(n)의 시간 복잡도를 갖는다. 그렇다고 해서 아주 쓸모 없는 자료구조는 아니기에, 우리가 아직 배우는 것이다. Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때, 그 유용성이 드러난다. Stack and Queue Stack 선형 자료구조의 일종으로 Last In First Out(LIFO) 즉, 나중에 들어간 원소가 먼저 나온다. 이것이 Stack의 가장 큰 특징이다. 차곡 차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조이다. Queue 선형 자료구조의 일종으로 Fist In First Out(FIFO) 즉, 먼저 들어간 놈이 먼저 나온다. Stack과는 반대로 먼저 들어간 놈이 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다. Tree 트리는 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다. 트리는 계층적 관계를 표현하는 자료구조이다. 트리라는 자료구조는 표현에 집중한다. 트리를 구성하고 있는 구성요소들 - 용어 Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미 Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미 Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미 Termianl Node( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미 Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다. Binary Tree(이진 트리) 루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어 진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다. 즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다. 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않을 듯 하다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf node에 다 달았을 때, 정의가 만족되기 때문이다. 트리에서는 각 층별로 숫자를 매겨서 이를 트리의 Level이라고 하낟. 루트 노드부터 시작하고 루트 노드의 level은 9이다. 그리고 트리의 최고 level을 가리켜 해당 트리의 height(높이)라고 한다. 완전 이진 트리(Complete Binary Tree) 그림과 같이 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워지고 자식이 2개이고 꽉 찬 트리르 완전 이진 트리라고 한다. 완전 이진 트리의 노드 개수는 2^(level-1)이다. 포화 이진 트리(Full Binary Tree) 모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 한다. Full Binary Tree와 Complete Binary Tree는 노드의 개수가 n일 때, i번째 노드에 대해서 parent(i) = i/2, left_child(i) = 2i, right_child(i) = 2i+1 의 index 값을 갖는다. 이러한 최악의 경우 한쪽으로 계속 쏠리게 되는 형태 또한 이진 트리이다. 이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면, 탐색, 삽입, 삭제, 메모리 성능 모든 면에서 배열에 비해 좋은 것이 없다. 이진 트리의 순회 방법 전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리 중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리 후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트 BST(Binary Search Tree) 효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다. 규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다. 규칙2 : 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떤 노드의 키보다 크다. 규칙3 : 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떤 노드의 키보다 작다. 규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다. 이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 Skewed Tree(편향 트리)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다. 이럴 경우 성능에 영향을 미치게 되며, 탐색의 Worst Case가 되고 시간 복잡도는 O(n)이 된다. 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 Rebalancing 기법이 등장했다. 균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 긎 ㅜㅇ에서 하나가 뒤에서 살펴볼 Red-black-Tree이다. Binary Heap 자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다. 배열에 트리의 값을 넣어 줄 때, 0번째는 건너뛰고 1번 index 부터 루트 노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다. 힙에는 최대힙(max heap)과 최소힙(min heap) 두 종류가 있다. Max heap이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 **Complete Binary Tree(완전 이진 트리)**를 말한다. [Min heap은 그 반대] Max heap에서는 Root noed에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다. 그리고 complete binary tree 이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다 (즉, random access가 가능하다. Min heap에서는 최소값을 찾는데 소요되는 연산의 시간복잡도가 O(1)이다.) 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 된다. Red Black Tree RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식의 자료구조이다. 결론부터 말하자면 Red-Black Tree에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 완전 이진 트리(complete binary tree)인 경우이다. Red-Black Tree의 정의 RBT는 다음의 성질을 만족하는 BST이다. 각 노드는 Red or Black라는 색깔을 갖는다. Root node의 색깔은 Black이다. 각 leaf node는 black이다. 어떤 노드의 색깔이 red라면 두 개의 children 의 색깔은 모두 black이다. 각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes들을 포함하고 있다. 이를 해당 노드의 Black-Height라고 한다. cf) Black-Height : 노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수 Red-Black Tree의 특징 Binary Search Tree이므로 BST의 특징을 모두 갖는다. Root node부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 balanced 상태라고 한다. 노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 leaf node로 간주한다. 삽입 우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 RED로 지정한다. Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고, Black-Height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 Black-height가 같아지게 되고 최소 경로와 최대 겨올의 크기 비율이 2미만으로 유지된다. 삭제 삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고 노드의 색깔을 조정한다. 지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다. HashTable hash는 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 Search하는데 데이터 고유의 인덱스로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다. (항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.) 하지만 문제는 이 인덱스로 저장되는 key 값이 불규칙하다는 것이다. 그래서 특별한 알고리즘을 이용하여 저장할 데이터와 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다. hash function '특별한 알고리즘’을 통해 고유한 인덱스 값을 설정하는 것이 중요하다. '특별한 알고리즘’을 hash method또는 해시 함수(hash function)라고 하고 이 메소드에 의해 반환된 데이터의 고유의 숫자 값을 hashcode라고 한다. 저장되는 값들의 key 값을 hash function을 통해서 작은 범위의 값들로 바꿔준다. 하지만 어설픈 hash function을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 Collision이라고 한다. Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다. 일반적으로 좋은 hash function는 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다. 하지만 좋은 해쉬 함수는 키의 어떤 특성을 가지고 있느냐에 따라 달라지게 된다. hash function를 무조건 1:1로 만드는 것보다 Collision을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 hash function를 만들어봤자 그건 array와 다를바 없고 메모리를 너무 차지하게 된다. Collision이 많아질 수록 Search에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 hash function는 hash를 hash답게 사용하지 못하도록 한다. 좋은 hash function를 선택하는 것은 hash table의 성능 향상에 필수적인 것이다. 따라서 hashing된 인덱스에 이미 다른 값이 들어 있다면 세 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자. Resolve Confilct Open Address 방식(개방 주소법) 해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용중인 경우) 다른 해시 버킷에 해당 자료를 삽입하는 방식이다. 버킷이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다. 다른 해시 버킷이란 어떤 해시 버킷인가??? 공개 주소 방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. Worst Case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 방법이 존재하고, 3가지를 살펴보겠다. Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다. Quadratic probing : 2차 함수를 이용해 탐색할 위치를 찾는다. Double hashing probing : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다. Seperate Chaining 방식(분리 연결법) 일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 Separate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정할 수 있다면 Worst Case에 가까워 지는 빈도를 줄일 수 있다. Java 7에서는 Separate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다. 연결 리스트를 사용하는 방식(Linked List) 각각의 버킷들을 연결 리스트로 만들어 Collision이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 바해 테이블의 확장을 늦출 수 있다. Tree를 사용하는 방식 기본적인 알고리즘은 Separate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 데이터의 개수가 적다면 Linked List를 사용하는 것이 맞다. Tree는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다. 데이터가 적다는 것은 얼마나 적다는 것을 의미하는가? 앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6개, 8개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다. 한 가지 상황을 가정해보자. 해시 버킷에 6개 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개에서 7개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다. Open Address vs Separate Chaining 일단 두 방식 모두 Worst Case 에서 O(M)이다. 하지만 Open Address방식은 연속된 공간에 데이터를 저장하기 때문에 Separate Chaining에 비해 캐시 효율이 높다. 따라서 데이터의 개수가 충분히 적다면 Open Address 방식이 Separate Chaining 보다 더 성능이 좋다. 한 가지 차이점이 더 존재한다. Separate Chaining방식에 비해 Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 확장을 보다 늦출 수 있다. 보조 해시 함수 보조 해시 함수의 목적은 key의 해시 값을 변형하여 해시 충돌 가능성을 줄이는 것이다. Separate Chaining 방식을 사용할 때 함께 사용되며 보조 해시 함수로 Worst Case에 가까워지는 경우를 줄일 수 있다. 해시 버킷 동적 확장(Resize) 해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 HashMap은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다. 일정 개수 이상 -&gt; 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75 -&gt; load factor라고 불린다. Graph Graph : 정점과 간선의 집합 cf) 트리 또한 그래프이며, 그 중 사이클이 허용되지 않는 그래프를 말한다. 그래프 관련 용어 정리 Undirected Graph 정점과 간선의 연결 관계에 있어서 방향성이 없는 그래프 Directed Graph(Diagraph) 간선에 방향성이 포함되어 있는 그래프 Degree(차수) Undirected Graph에서 각 정점에 연결된 Edge의 개수를 말한다. Directed Graph에서는 간선에 방향성이 존재하기 때문에 Degree가 두 개로 나뉘게 된다. 각 정점으로부터 나가는 간선의 개수를 OutDegree라 하고, 들어오는 간선의 개수를 Indegree이라 한다. 가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph) 가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프 즉, 모든 간선의 가중치가 동일한 그래프도 존재한다. 부분 집합과 유사한 개념으로 부분 그래프라는 것이 있다. 부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다. 그래프를 구현하는 두 방법 인접 행렬(adjacent matrix) : 정방 행렬을 사용하는 방법 해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)로 파악할 수 있다. Edge 개수와는 무관하게 V^2의 공간 복잡도를 갖는다. Dense graph를 표현할 때 적절한 방법이다. 인접 리스트(adjacent list) : 연결 리스트를 사용하는 방법 vertex(정점)의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다. 공간 복잡도는 O(E+V)이다. Sparse graph를 표현하는데 적당한 방법 그래프 탐색 그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다. 깊이 우선 탐색(Depth First Search : DFS) 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다. 어떤 자료구조를 사용해야할까?? Stack이다. 시간 복잡도 : O(V+E) … vertex개수+edge개수 너비 우선 탐색(Breadth First Search : BFS) 그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서는 자료구조로 Queue를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 Queue에 넣는다.(enqueue) 그리고 dequeue를 하면서 정점과 간선으로 연결되어 있는 정점들을 enqueue한다. 즉 vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다. 시간 복잡도 : O(V+E) … vertex개수 + edge 개수 BFS로 구한 경로는 최단 경로 Minimum Spanning Tree 그래프 G의 spanning tree 중 edge weight의 합이 최소이 spanning tree를 말한다. 여기서 말하는 spanning tree란 그래프 G의 모든 vertex가 cycle이 없이 연결된 형태를 말한다. Kruskal Algorithm 초기화 작업으로 edge 없이 vertex들만으로 그래프를 구성한다. 그리고 weight가 제일 작은 edge부터 검토한다. 그러기 위해서는 edge Set을 non-decreasing으로 해야 한다. 그리고 가장 작은 weight에 해당하는 edge를 추가하는데 추가할 때 그래프에 cycle이 생기지 않는 경우에만 추가한다. spanning tree가 완성되면 모든 vertex들이 연결된 상태로 종료가 되고 완성될 수 없는 그래프에 대해서는 모든 edge에 대해 판단이 이루어지면 종료된다. 어떻게 cycle 생성 여부를 판단하는가?? graph의 각 vertex에 set-id라는 것을 추가적으로 부여한다. 그리고 초기화 과정에서 모두 1~n까지의 값으로 각각의 vertex들을 초기화한다. 여기서 0은 어떠한 edge와도 연결되지 않았음을 의미하게 된다. 그리고 연결할 때마다 set-id를 하나로 통일시키는데, 값이 동일한 set-id개수가 많은 set-id 값으로 통일시킨다. Time Complexity(시간 복잡도) Edge의 weight를 기준으로 sorting - O(E log E) cycle 생성 여부를 검사하고 set-id를 통일 - O(E + V log V) =&gt; 전체 시간 복잡도 : O(E log E) Prim Algorithm 초기화 과정에서 한 개의 vertex로 이루어진 초기 그래프 A를 구성한다. 그리고 나서 그래프 A 내부에 있는 vertex로부터 외부에 있는 vertex 사이의 edge를 연결하는데 그 중 가장 작은 weight의 edge를 통해 연결되는 vertex를 추가한다. 어떤 vertex건 간에 상관없이 edge의 weight를 기준으로 연결하는 것이다. 이렇게 연결된 vertex(정점)는 그래프 A에 포함된다. 위 과정을 반복하고 모든 vertex들이 연결되면 종료한다. Time Complexity(시간 복잡도) =&gt; 전체 시간 복잡도 : O(E log V)","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"}]},{"title":"[SOPT] Seminar4","slug":"sopt-seminar4","date":"2018-05-05T08:55:30.000Z","updated":"2020-05-26T07:08:02.716Z","comments":true,"path":"2018/05/05/sopt-seminar4/","link":"","permalink":"https://woovictory.github.io/2018/05/05/sopt-seminar4/","excerpt":"","text":"통신의 기본 HTTP? 하이퍼텍스트 기반(링크 기반)으로 데이터를 주고 받는다. 인터넷 상에서 데이터를 주고 받기 위한 Client/Server 모델을 따르는 프로토콜 가장 성공적으로 평가받는 프로토콜 프로토콜 Client/Server 주요 메소드 GET : 데이터 받기 : URL 혹은 URL에 변수를 포함시켜(포함시키지 않을 수도 있음) 데이터를 받는 방식 POST : 데이터 생성 : 데이터를 Body(일종의 객체)에 감싸서 보내는 방식 PUT : 데이터 업데이트 : POST와 마찬가지로 Body에 감싸서 보내는 방식 : 성공적으로 보내면 데이터가 업데이트 된다. DELETE : 데이터 삭제 : 성공적으로 보내면 데이터가 삭제 된다. In Android Http 기반 REST API(GET,POST,PUT,DELETE)를 Retrofit2 라이브러리를 통해 사용 REST API의 표현식인 JSON을 Object 개념으로 바꿔주는 GSON 라이브러리를 함께 사용 Retrofit2 Retrofit2이란? Http REST API 통신을 위한 라이브러리 @ annotation 형식을 통해 사용 인터페이스를 통해 쉽게 구현 할 수 있다. JSON을 간단하게 처리할 수 있다. JSON/GSON JSON JSON이란 ‘Key’:value 조합을 갖는 데이터를 말한다. value에는 숫자, 문자열, 배열, 논리, 객체가 올 수 있다. JSON 자체를 배열로 받을 수 있다. 객체는 중괄호로 {} 구분하고, 배열을 대괄호로 [] 구분한다. 12345678910111213141516171819202122232425262728293031&quot;JSON Object&quot; : &#123; &quot;name&quot; : &quot;Lee&quot;, &quot;age&quot; : 25, &quot;part&quot; : android, &quot;etc&quot; : &#123; &quot;dog&quot; : false, &quot;cat&quot; : false &#125;&#125;// JSON Object&quot;JSON Array&quot; : [ &#123; &quot;name&quot; : &quot;탁형민&quot;, &quot;nick&quot; : &quot;탁클라운&quot; &quot;age&quot; : 25 &#125;, &#123; &quot;name&quot; : &quot;류수한&quot;, &quot;nick&quot; : &quot;류뚱&quot; &quot;age&quot; : 25 &#125;, &#123; &quot;name&quot; : &quot;이종찬&quot;, &quot;nick&quot; : &quot;종팡&quot; &quot;age&quot; : 26 &#125;,]// JSON Array GSON 12345&quot;JSON Object&quot; : &#123; &quot;name&quot; : &quot;Lee&quot;, &quot;age&quot; : 25, &quot;part&quot; : android&#125; 위의 JSON을 아래의 객체로 사용할 수 있게끔 변환해주는 라이브러리 12345data class JSON&#123; var name : String, var age : Int, var part : String&#125; JSON의 Key와 객체의 변수명은 같아야 한다. 물론 타입도 맞춰줘야 한다. Glide 이미지 로드 라이브러리 서버에서 받은 이미지 url을 로드할 수 있게끔 도와준다. 이미지 비율에 맞게 사이즈 조정 Out of memory 방지 기본 사용법 1234Glide.with(Context).load(서버에서 받아 온 이미지 url).into(이미지를 받을 뷰 객체) 과제 복습 : 세미나 시간동안 구현한 것 완성 + 상세보기 화면 구현 응용 : 상세보기 화면에서 댓글 구현(댓글 달기, 삭제) 심화 : 서버 API가 없으므로 간단한 로그인 &amp; 회원 가입 기능 구현(SharedPreference 사용) Github : https://github.com/WooVictory/SOPT_22th_Seminar4_HomeWork","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[SOPT] Seminar3","slug":"sopt-seminar3","date":"2018-05-05T02:48:08.000Z","updated":"2020-05-26T07:08:00.444Z","comments":true,"path":"2018/05/05/sopt-seminar3/","link":"","permalink":"https://woovictory.github.io/2018/05/05/sopt-seminar3/","excerpt":"","text":"RecyclerView 특징 반복되는 패턴 적용에 유리한 View(일종의 리스트) LayoutManager 속성을 추가하여 리스트 타입을 쉽게 변경 할 수 있다. 재활용성이 뛰어난 구조 구성 요소 DataClass ViewHolder LayoutManager Adapter DataClass 위의 네모난 채팅방을 item이라고 하며, 이 item에 들어갈 **데이터(자료형)**가 무엇인지 명시 프로필 이미지(Int), 채팅방 이름(String), 미리보기(String), 날짜(String)이 표시 된다. 위 서버의 Response를 보고 작성한 DataClass 1234567891011121314data class GetBoardResponse( var message : String, var data : ArrayList&lt;GetBoardResponseData&gt;)class GetBoardResponseData( var board_idx : Int, var board_title : String?, var board_content : String, var board_view : Int, var board_photo : String?, var board_writetime : String?, var user_id : String) 서버 API를 보고 DataClass를 작성할 경우에는 서버의 Key값과 동일하게 변수명을 작성하여야 한다. ViewHolder Item에 들어갈 View가 무엇인지 명시 프로필 이미지(ImageView), 채팅방 이름(TextView), 미리보기((TextView), 날짜((TextView) LayoutManger Item들의 배치 방식을 결정 LinearLayoutManager(선형), StaggeredGridLayoutManager(지그재그, 정확히는 가변 그리드), GridLayoutManager(사진첩 형태) 이번 세미나에서는 LinearLayoutManager를 통해서 수직 배치를 할 예정! Adapter DataClass와 ViewHolder를 연결 이번 세미나에서는 DataClass의 프로필 이미지(Int)을 ViewHolder의 프로필 ImageView에, 채팅방(String)을 채팅방 TextView에, 미리보기(String)을 미리보기 TextView에 연결, 날짜(String)를 날짜 TextView에 연결한다. 서버와 통신을 할 경우에는 DataClass를 서버의 Response(응답)을 보고 작성하게 되는데, DataClass가 서버의 응답을 받아서 ViewHolder와 연결을 해주면 된다!! DataClass가 중요한 부분!! 연결 후 RecyclerView가 Adapter를 잡게 함으로써 사용자에게 보여준다. 과제 복습 : RecyclerView를 이용한 리스트 만들기 [hint : color값 넘기기!] 응용 : Item 요소 중에서 '프로필 이미지’를 클릭하면 프뢸 이미지만 볼 수 있는 Activity로 넘어가도록 작성 [hint : Adapter의 ViewHolder를 변경하면 됨] [주의 : Item을 클릭하면 상대방과의 채팅방으로 이동하는 Activity와는 별개로 작성해야 함] 심화 : RecyclerView의 Header를 만들어서 다른 형태의 Item도 RecyclerView에 포함되도록 작성 Github : https://github.com/WooVictory/SOPT_22th_Seminar3_HomeWork","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[BoostCourse] 1. Layout","slug":"boostcourse1","date":"2018-05-04T14:20:11.000Z","updated":"2018-12-04T08:25:39.792Z","comments":true,"path":"2018/05/04/boostcourse1/","link":"","permalink":"https://woovictory.github.io/2018/05/04/boostcourse1/","excerpt":"","text":"View란? View와 View 그룹의 정의 View란? 화면에 보이는 각각의 것들(버튼, 텍스틍 등등) 흔히 콘트롤이나 위젯이라 불리는 UI 구성 요소 ViewGroup? 뷰들을 여러개 포함하고 있는 것 뷰 그룹도 뷰에서 상속하여 뷰가 된다. 즉, 위의 뷰는 버튼, 텍스트 뿐만 아니라 이것들을 포함하는 눈에 보이지 않는 영역을 포함 위젯이란? 뷰 중에서 일반적인 컨트롤 역할을 하고 있는 것 예 : 버튼, 텍스트 등등 레이아웃이란? 뷰 그룹 중에서 내부에 뷰들을 포함하고 있으면서 그것들을 배치하는 역할을 하는 것 레이아웃은 그 안에 다른 뷰들을 담아둘 수 있는데 레이아웃도 뷰를 상속하여 정의되었기 때문에 레이아웃 안에 레이아웃도 담을 수 있다. 레이아웃 안에 레이아웃 다시 그 레이아웃 안에 레이아웃을 담으면 복잡한 화면을 구성할 수 있다. View의 크기 속성 layout_width : 가로의 크기를 지정 layout_height : 세로의 크기를 지정 세로와 가로의 크기를 지정하는 필수적인 요소!! 크기 지정 방법 3가지 match_parent : 상위 뷰의 크기에 맞게 구성 요소를 확장 wrap_content : 뷰 안에 들어있는 내용물의 크기에 딱 맞게 크기를 결정 원하는 크기로 사용자가 직접 지정 이 때 크기를 나타내는 숫자 뒤에는 px나 dp와 같은 단위를 사용한다. 대표적인 레이아웃 LinearLayout 상자를 쌓듯이 뷰를 하나씩 쌓을 수 있는 레이아웃 방향 속성인 orientation을 이용해서 vertical[가로]방향이나 horizontal[세로]방향으로 뷰를 쌓을 수 있습니다. 간단하고 사용이 쉬운 레이아웃이지만, Linear안에 Linear 레이아웃을 중첩시켜서 각각에 다른 orientation 방향 속성을 주어서 복잡한 화면 구성도 가능합니다. layout_gravity 속성 : 뷰를 정렬하는데 사용 gravity 속성 : 뷰 안에 들어있는 내용물을 정렬할 때 사용 추가적으로 margin을 설정할 수 있습니다. margin은 뷰의 테두리선 바깥쪽 공간을 얼마나 띄울 것인지를 지정하는 속성 padding은 뷰 안에 들어있는 내용물을 테두리 선과 얼마나 띄울 것인지를 지정하는 속성 layout_weight : 공간 분할에 사용되는 속성 예를 들어, 두 개의 버튼을 가로 방향으로 똑같은 크기만큼 반반씩 공간을 차지하도록 만들고 싶을 때 사용한다. 그런데 이 속성은 남아있는 여유 공간만 분할한다. 이 때문에 두 개의 버튼을 가로 방향으로 추가했다면 layout_widht 속성의 값은 0dp로 주는 것이 필요하다. RelativeLayout 뷰를 담고 있는 부모 레이아웃이나 그 안에 들어있는 다른 뷰들과의 상대적 위치를 이용해 화면을 배치하는 레이아웃 사용방식 화면의 아래쪽에 버튼을 붙이고 싶다면 layout_alignParentBottom 속성의 값을 true로 설정하는 것으로 충분하다. RelativeLayout을 이용한 뷰의 배치 상대 레이아웃이 뷰를 담고 있다면 이 뷰의 입장에서는 상대 레이아웃이 부모 레이아웃이 된다. 그리고 부모 레이아웃의 상대적 위치를 이용할 수 있다. A 뷰는 부모 레이아웃의 위쪽에 붙이고, B 뷰는 A 뷰의 아래쪽에 붙일 수 있다. 같은 상대 레이아웃 안에 들어있는 다른 뷰와의 상대적 위치를 이용 부모 레이아웃과의 상대적 위치를 지정할 때 사용하는 속성으로는 layout_alignParet [Top,Bottom,Left,Right] 등이 존재 부모 레이아웃의 가운데에 배치하기 위한 layout_centerInParent 속성도 존재 다른 뷰와의 상대적 위치를 지정할 때 사용하는 속성으로는 layout_toLeftOf,layout_toRightOf,layout_alignTop,layout_alignBottom 등이 존재 부모 레이아웃과의 상대적 위치를 지정할 때 사용하는 속성들은 모두 Parent라는 단어가 들어가 있지만 다른 뷰와의 상대적 위치를 지정할 때 사용하는 속성들에는 Parent라는 단어가 들어가 있지 않습니다. FrameLayout 프레임 레이아웃은 한 번에 하나의 뷰만 보여주는 레이아웃입니다. 가장 단순한 레이아웃이고, 이 레이아웃에 뷰를 여러 개 추가했다면 그 중 가장 나중에 추가한 뷰만 화면에 보이게 된다. 이런 특성 때문에 뷰들을 여러 개 담아놓고 중첩할 때 주로 사용 아래쪽에 깔린 다른 뷰를 화면에 보여주고 싶다면 위쪽으로 뷰를 올려줄 수도 있고 보고자 하는 뷰 외의 다른 뷰들을 보이지 않게 할 수도 있다. 프레임 레이아웃을 이용한 뷰의 중첩 방식 가시성 속성을 사용해서 프레임 레이아웃 안에 중첩된 뷰들 중에서 하나만 보여주게 할 수 있다. 가시성(visibility) : visible, invisible, gone","categories":[],"tags":[]},{"title":"[SOPT] Seminar2","slug":"sopt-seminar2","date":"2018-05-02T03:03:54.000Z","updated":"2020-05-26T07:07:58.345Z","comments":true,"path":"2018/05/02/sopt-seminar2/","link":"","permalink":"https://woovictory.github.io/2018/05/02/sopt-seminar2/","excerpt":"","text":"안드로이드의 4대 컴포넌트 Activity(액티비티) 사용자 인터페이스 화면을 가지며 특정한 작업을 담당하는 컴포넌트 UI를 구성하는 컴포넌트 안드로이드의 Manifest 파일에 등록이 되어 있어야 한다. 안드로이드 Application은 최소 1개 이상의 Activity가 있어야 한다. 하나 이상의 View를 가질 수 있다. 쉽게 말하자면 사용자가 보는 화면이다. Service(서비스) 백그라운드에서 실행되는 컴포넌트로 오랫동안 실행되는 작업이나 원격 프로세스를 위한 작업을 할 때 사용된다. 모든 서비스는 Service 클래스를 상속 받는다. 한 번 실행되면 다른 어플리케이션으로 이동하더라도 종료되지 않는다. 네트워크를 통하여 데이터를 꺼내올 수도 있다. ex) 뮤직 플레이어, 안드로이드 사용량 모니터링, 주기적으로 특정 웹사이트에서 데이터를 읽어오는 것 등등 BroadCast Receiver BroadCast는 시스템에서 발생하는 이벤트이며 이것의 Receiver은 특정 BroadCast에 반응하는 컴포넌트 단말기에서 발생하는 다양한 이벤트 / 정보를 받고 반응한다. 수신기를 통해 상황을 감지하고 적절한 작업을 수행한다. 신호만 기다릴 뿐 별도의 UI를 거치지 않는다. ex) 배터리 부족, 네트워크 전송, 시스템 부팅, 전화/문자 수신, 네트워크 끊김을 알려주는 것 등등 Content Provider 데이터를 관리하고 어플리케이션 간 데이터 공유를 위한 컴포넌트 데이터는 파일 시스템이나 SQLite 데이터베이스, 웹 상에 저장될 수 있습니다. 콘텐트 제공자를 통해서 다른 애플리케이션의 데이터를 쿼리하거나 변경 가능합니다. 유일한 합법적 데이터 공유 장치 (주소록 Content Provider를 통해 제공) Activity의 생명주기 onCreate() 액티비티가 만들어지고 나서 최초에 실행될 때 호출됩니다. 액티비티에 필요한 리소스들을 초기화하거나 화면에 보이는 뷰들의 일반적인 상태들을 여기서 설정합니다. 이전 상태가 저장되어 있을 경우, 번들 객체를 참조하여 이전 상태로 복원이 가능합니다. 이 다음에는 항상 onStart()가 호출됩니다. onStart() 액티비티가 화면에 보이기 바로 전에 호출됩니다. 액티비티가 화면상에 보이면 이 메소드 다음에 onResume()메소드가 호출된 것입니다. 매우 빠르게 끝나고, onResume() 단계로 넘어갑니다. 보통 Broadcast Receiver는 이 단계에서 등록하는 것이 좋습니다. 액티비티가 시작되기 전에 호출되는 함수 / 액티비티가 멈춘 후 다시 시작되기 전에 호출되는 함수 onResume() 액티비티가 사용자와 상호 작용하기 바로 직전에 호출되는 함수입니다. 이 메소드가 호출되고 나서 바로 액티비티가 사용자에게 보이기 시작합니다. 액티비티가 화면에 보여집니다. 사용자에게 focus를 잡은 상태입니다. onRestart() 액티비티가 중지된(Stopped) 이후에 호출되는 메소드로 다시 시작되기 바로 전에 호출됩니다. 액티비티가 멈춰 있다가 다시 다시 호출될 때 불리는 함수입니다. 다른 액티비티가 호출되는 경우 onPause() 액티비티 위에 액티비티가 올라와서 focus를 잃었을 때 호출되는 함수 액티비티가 완전히 가려지지 않고 부분만 가려진 상태에서 호출되는 함수, 즉 일부분이 보이거나 투명상태일 경우에 호출됩니다. 다른 액티비티가 호출되기 전에 실행되기 때문에 onPause() 함수에서 시간이 많이 소요되는 작업이나 많은 일을 처리하면 다른 액티비티가 호출되는 시간이 지연되기 때문에 많은 일을 처리하지 않도록 주의합니다. 영구적인 Data는 여기서 저장합니다. 이 메소드가 리턴하기 전에는 다음 액티비티가 시작될 수 없으므로 이 작업은 빠르게 리턴되어야 합니다. 액티비티가 이 상테에 들어가면 시스템은 액티비티를 강제 종료할 수 있습니다. onStop() 액티비티 위에 다른 액티비티가 완전히 올라와 100% 가려질 때 호출되는 함수 액티비티가 사용자에게 더 이상 보이지 않을 때 호출되는 함수 만약 이 상태에서 액티비티가 다시 불려지면 onRestart()함수가 호출됩니다. 시스템이 onStop() 상태에 들어오면, onSaveInstanceState()이라는 메소드를 호출하는데, 이 단계에서는 key-value 형태로 값을 저장할 수 있고, 이 값을 onCreate()에서 복원할 수 있습니다. ex) 홈 키를 누른 경우, 또는 다른 액티비티 페이지로 이동이 있는 경우에 호출됩니다. onDestroy() 액티비티가 완전히 스택에서 없어질 때 호출되는 함수 즉 제거되는 경우입니다. Finish() 메소드가 호출되거나 시스템 메모리 확보를 위해서 시스템이 강제로 종료시키는 경웨 호출될 수 있습니다. 참고 onStop(), onDestroy() 함수는 호출되지 않을 수도 있습니다. 메모리 부족으로 인해 onStop()이 호출되지 않을 수 있습니다. Fragment(프래그먼트) 일종의 하위 Activity이며 자체 생명주기를 갖는다. 자체 입력 이벤트를 가지고 있으며 값 전달은 Bundle로 한다. [Activity가 Intent로 한 것과는 대조적이다.] Tag를 달 수 있다. FragmentManager를 통해 관리할 수 있다. FragmentManager Fragment 관리를 목적으로 하는 클래스 FragmentManager 클래스를 통해 FragmentTransaction 객체를 FragmentTransaction을 통해 동적 관리 Kotlin에서는 supportFragmentManager를 통해 생성 FragmentTransaction Fragment 추가, 삭제, 전환을 도와주는 클래스 addToBackStack() 함수를 호출해서 교체되서 Fragment를 back stack에 저장 항상 마지막에 변경사항 적용을 위해 commit()을 해야 한다. onAttach() : 프래그먼트가 액티비티에 붙을 때 호출된다. 하지만, 아직 완벽하게 생성된 것은 아니다. 프래그먼트는 액티비티 없이는 단독적으로 존재할 수 없기 때문이다. onCreate() : 본격적으로 프래그먼트가 액티비티의 호출을 받아 생성되는 시점이다. 액티비티의 onCreate()에서는 view나 UI 작업을 할 수 있으나, 프래그먼트의 onCreate()에서는 할 수 없다. onCreateView() : 프래그먼트에 속한 각종 view나 viewGroup에 대한 UI 바인딩 작업을 할 수 있다. (Layout을 inflate하여 view 작업을 수행한다.) onActivityCreated() : 액티비티에서 프래그먼트를 모두 생성하고 난 다음에 호출된다. 즉 액티비티에서 onCreate() 다음에 호출되는 메소드이다. 액티비티와 프래그먼트가 드디어 연결되는 시점이다. onStart() : 프래그먼트가 사용자에게 보여지기 전에 호출되는 함수 (액티비티와 같음) onResume() : 프래그먼트가 비로소 화면에 보이는 단계이다. 사용자에게 focus를 잡은 상태 사용자와의 상호작용이 가능 다른 프래그먼트가 치고 들어오는 경우(add되는 경우) onPause() : 프래그먼트는 사용자와의 상호작용을 중지한다. 다시 돌아온다는 보장이 없으므로, 중요한 정보는 저장해둔다. onStop() : 프래그먼트는 더 이상 보여지지 않게 되며, 프래그먼트 기능은 중지한다. onDestroyView() : 프래그먼트를 view에서 제거한다. Backstack을 사용했다면, 다시 해당 프래그먼트로 돌아올 때 onCreateView()가 호출된다. onDestroy() : 프래그먼트를 제거하기 직전이다. onDetach() : 프래그먼트를 비로소 제거하고 액티비티와의 연결도 해제한다. 과제 복습 : 세미나 시간동안 구현한 것 완성 응용 : Fragment안에 Fragment 구현 심화 : 첫 Fragment에서 이미지가 여러장일 경우에는 swipe를 통해 구현 Github : https://github.com/WooVictory/SOPT_22th_Seminar2_HomeWork","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[SOPT] Seminar1","slug":"sopt-semniar1","date":"2018-05-01T09:45:28.000Z","updated":"2020-05-26T07:08:13.516Z","comments":true,"path":"2018/05/01/sopt-semniar1/","link":"","permalink":"https://woovictory.github.io/2018/05/01/sopt-semniar1/","excerpt":"","text":"Android 가볍게 보는 특징 Google에서 만든 모바일 운영체제 가장 많이 사용하는 OS 오픈소스 다양한 라이브러리 지원 개발 접근이 용이 빈번한 SDK 업그레이드 최근 이슈 최근에 구글과 오라클의 소송에서 구글이 패배함으로써 자바가 위협을 받고 Kotlin이 대두되고 있습니다. SOPT에서는 Kotlin을 이용하여 안드로이드 개발을 배우고 세미나를 진행합니다. Kotlin의 특징 자동 형 변환 기능을 허용하지 않는다. [타입이 다르면 반드시 형 변환을 해야 한다.] NPE에 대응 [NPE = Null Pointer Exception] 뛰어난 자바와의 호환성 표현이 자바에 비해 훨씬 간결 문장 끝에 세미콜론을 사용하지 않는다. View / Layout이란?? View와 ViewGroup View 버튼, 텍스트, 이미지 등 모든 유저 인터페이스(UI)의 통칭 사용자 눈에 보이는 화면 구성 요소 Activity 상에서 직접 Code를 작성해서 구현할 수 있지만 더 쉽고 정교하게 작성하기 위해서 XML사용 layout_width -&gt; 뷰의 너비(가로 길이) layout_height -&gt; 뷰의 높이(세로 길이) wrap_content -&gt; 내용의 길이(혹은 크기)에 맞게 조절 match_parent -&gt; 부모 뷰에 꽉 채워진 크기(여백 제외) 위의 두 가지가 아닌 경우에는 직접 설정 배경 지정 / 색 뿐만 아니라 이미지도 지정 가능 화면에 보여지는 속성 visible : 공간도 차지하고 화면에 보임 invisible : 공간은 차지하는데 보이지는 않음 gone : 공간도 차지하지 않고 보이지도 않음 View의 여백 설정 margin -&gt; 부모 혹은 View와의 여백 padding -&gt; View 외곽과 내용 사이의 여백 ViewGroup 뷰들을 여러 개 포함하고 있는 것 뷰 그룹도 뷰에서 상속하여 뷰가 된다. 즉, 위의 뷰는 버튼, 텍스트 뿐만 아니라 이것들을 포함하는 눈에 보이지 않는 영역을 포함 위젯 뷰 중에서 일반적인 컨트롤 역할을 하고 있는 것 ex) 버튼, 텍스트뷰 등등 Layout View들이 배치 될 그룹 Layout에 따라 배치되는 방식이 달라짐 XML을 통해 작성 LinearLayout, RelativeLayout, FrameLayout, ConstraintLayout 등등 존재 레이아웃은 그 안에 다른 뷰들을 담을 수 있는데, 레이아웃도 뷰를 상속하여 정의되었기 때문에 레이아웃 안에 다른 레이아웃을 담을 수 있다. 이를 이용하여 복잡한 화면 구성을 할 수 있다. LinearLayout View들의 선형 배치를 제공하는 Layout 수직 방향, 수평 방향으로 배치 가능 수직 배치시 다음 뷰는 가장 아래 뷰를 기준으로 밑에 수평 배치시 다음 뷰는 가장 오른쪽 뷰를 기준으로 오른쪽에 배치 배치 기준이 정해져 있어서 직접 정해주지 않아도 됨 특정 뷰 기준으로 배치하는 것은 불가능하다. 방향성이 존재하기 때문에 뷰 위에 뷰를 쌓는 것이 불가능하다. 계단식으로 배치할 때 용이하게 사용할 수 있다. orientation : 뷰 배치에 방향성을 부여한다.(horizontal, vertical) layout_gravity : 부모 컨테이너 안에서 뷰의 위치를 정함 gravity : 뷰 안에서 내용물의 위치를 정함 layout_weight : 뷰의 가중치로 비율을 통해 너비 혹은 길이를 정함 RalativeLayout View들의 상대적 배치를 제공하는 Layout 특정 뷰를 기준으로 다른 뷰를 배치하는 특징을 가지고 있다. 기준을 정해주지 않게 되면 뷰가 왼쪽 상단에 쌓이게 된다. 뷰 위에 뷰를 겹칠 수 있따. 원하는 배치를 하기 위해서 직접 기준을 정해주면 된다. 복잡한 뷰를 작성할 때 용이하게 사용할 수 있다. Github : https://github.com/WooVictory/SOPT_22th_Seminar1_HomeWork","categories":[{"name":"Inno_SOPT","slug":"Inno-SOPT","permalink":"https://woovictory.github.io/categories/Inno-SOPT/"}],"tags":[{"name":"SOPT","slug":"SOPT","permalink":"https://woovictory.github.io/tags/SOPT/"}]},{"title":"[개발 상식] RESTful","slug":"devknowledge-RESTful","date":"2018-04-18T08:43:33.000Z","updated":"2020-05-12T11:30:28.873Z","comments":true,"path":"2018/04/18/devknowledge-RESTful/","link":"","permalink":"https://woovictory.github.io/2018/04/18/devknowledge-RESTful/","excerpt":"","text":"RESTful API 월드 와이드 웹(World Wide Web a.k.a WWW)과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식으로 자원을 정의하고 자원에 대한 주소를 지정하는 방법 전반에 대한 패턴 REST란 REpresentational State Transfer의 약자이다. 여기에 ~ful이라는 형용사형 어미를 붙여 ~한 API라는 표현으로 사용된다. 즉, REST의 기본 원칙을 성실히 지킨 서비스 디자인은 RESTful하다라고 표현할 수 있다. REST가 디자인 패턴이다. 아키텍처마다 많은 이야기가 존재하는데, 하나의 아키텍처로 볼 수 있다. 좀 더 정확한 표현으로 말하자면, REST는 Resource Oriented Architecture이다. API 설계의 중심에 자원(Resource)이 있고, HTTP Method를 통해 자원을 처리하도록 설계하는 것이다. REST 구성 REST API는 다음의 구성으로 이루어져 있다. 자원(Resource) - URI 행위(Verb) - HTTP Method 표현(Representations) REST 6가지 원칙 Uniform URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말한다. Stateless 무상태성 성격을 갖는다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않는다. 세션 정보자 쿠키 정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만 단순히 처리하면 된다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다. Caching REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹 표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용 가능합니다. 따라서 HTTP가 가진 캐싱 기능의 적용이 가능. HTTP 프로토콜 표준에서 사용하는 Last-Modified 태그나 E-Tag를 이용하면 캐싱 구현이 가능 Client-Server REST 서버는 API 제공, Client는 사용자 인증이나 컨텍스트(세션, 로그인 정보)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 Client와 Server에게 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 된다. Hierarchical system REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 Proxy, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 한다. Code on demand RESTful 하게 API를 디자인 한다는 것은 무엇을 의마하는가 리소스와 행위를 명시적이고 직관적으로 분리한다. 리소스는 URI로 표현되는데 리소스가 가리키는 것은 명사로 표현되어야 한다. 행위는 HTTP Method로 표현하고, GET(조회),POST(생성),PUT(기존 entity 전체 수정),PATCH(기존),DELETE(삭제)` 을 분명한 목적으로 사용한다. Message는 Header와 Body를 명확하게 분리해서 사용한다. Entity에 대한 내용은 body에 담는다. 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등은 header에 담는다. header와 body는 http header와 http body로 나눌 수도 있고, http body에 들어가는 json 구조로 분리할 수도 있다. API 버전을 관리한다. 환경을 항상 변하기 때문에 API의 signature가 변경될 수도 있음에 유의하자. 특정 API를 변경할 때는 반드시 하위호환성을 보장해야 한다. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다. 브라우저는 form-data 형식의 submit으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 json으로 보내든, 둘 다 form-data 형식으로 보내든 하나로 통일한다. 다른 말로 표현하자면 URI가 플랫폼 중립적이어야 한다. 장점 Open API를 제공하기 쉽다. 멀티플랫폼 지원 및 연동이 용이하다. 원하는 타입으로 데이터를 주고 받을 수 있다. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다. 단점 사용할 수 있는 메소드가 4가지 밖에 없다. 분산환경에는 부적합하다. HTTP 통신 모델에 대해서만 지원한다. REST API 디자인 가이드 URI는 정보의 자원을 표현해야 한다. 자원에 대한 행위는 HTTP Method(GET,POST,PUT,DELETE)로 표현한다. REST API 중심 규칙 URI는 정보의 자원을 표현해야 한다. (리소스명은 동사보다는 명사를 사용) GET /members/delete/1 위와 같은 방식은 REST를 제대로 적용하지 않은 URI입니다. URI는 자원을 표현하는데 중점을 두어야 하므로 delete와 같은 행위에 대한 표현이 들어가서는 안된다. 자원에 대한 행위는 HTTP Method로 표현 위의 잘못 된 URI를 HTTP Method를 통해 수정하면 DELETE /members/1 으로 수정할 수 있다. 회원 정보를 가져올 때는 GET, 회원 추가 시의 행위를 표현하고자 할 때는 POST Method를 사용하여 표현하면 된다. HTTP Method의 역할 POST : POST를 통해 해당 URI를 요청하면 리소스를 생성 GET : GET을 통해 해당 리소스를 조회. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. PUT : PUT을 통해 해당 리소스를 수정 DELETE : DELETE를 통해 리소스를 삭제 URI 설계 시 주의할 점 슬래시 구분자(/)는 계층 관계를 나타내는 데 사용 URI 마지막 문자로 슬래시(/)를 포함하지 않는다. URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것이고 역으로 리소스가 다르면 URI도 달라져야 한다. REST API는 분명한 URI를 만들어 통신을 해야 하기 때문에 혼동을 주지 않도록 URI 경로의 마지막에는 슬래시(/)를 사용하지 않는다. 하이픈(-)은 URI 가독성을 높이는 데 사용 URI를 쉽게 읽고 해석하기 위해, 불가피하게 긴 URI 경로를 사용하게 된다면 하이픈을 사용해 가독성을 높일 수 있다. 언더바는 URI에 사용하지 않는다. 글꼴에 따라 다르긴 하지만 밑줄은 보기 어렵거나 밑줄 때문에 문자가 가려지기도 한다. 이런 문제를 피하기 위해 언더바 대신 하이픈(-)을 사용하는 것이 좋다.(가독성) URI 경로에는 소문자가 적합 URI 경로에 대문자 사용은 피하도록 한다. 대소문자에 따라 다른 리소스로 인식하게 되기 때문이다. RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정함 파일 확장자는 URI에 포함시키지 않는다. REST API에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다. Accept header를 사용하도록 한다. 리소스 간의 관계를 표현하는 방법 REST 리소스 간에는 연관 관계가 있을 수 있고, 이런 경우 다음과 같이 표현 /리소스명/리소스 ID/관계가 있는 다른 리소스명 GET : /users/{userid}/devices (일반적으로 소유 'has’의 관계를 포현할 때) 만약에 관계명이 복잡하다면 이를 서브 리소스에 명시적으로 표현하는 방법이 있다. 예를 들어 사용자가 ‘좋아하는’ 디바이스 목록을 표현해야 할 경우 다음과 같이 표현 가능 GET : /users/{userid}/likes/devices (관계명이 애매하거나 구체적으로 표현이 필요할 때) 자원을 표현하는 Collection과 Document Collection과 Document에 대해 알면 URI 설계가 한 층 더 쉬워진다. Document는 단순히 문서로 이해해도 되고, 한 객체라고 이해하면 편하다. Collection은 문서들의 집합, 객체들의 집합이라고 생각하면 이해가 편하다. Collection과 Document는 모두 리소스라고 표현할 수 있으며 URI에 표현된다. http:// restapi.example.com/sports/soccer sports라는 컬렉션과 soccer이라는 도큐먼트로 표현된다. http:// restapi.example.com/sports/soccer/players/13 sports, players 컬렉션과 soccer,13을 의미하는 도큐먼트로 URI가 이루어지게 된다. 여기서 중요한 점은 컬렉션은 복수로 사용한다는 점이다. 좀 더 직관적인 REST API를 위해서는 컬렉션과 도큐먼트를 사용할 때 단수, 복수도 지켜준다면 좀 더 이해하기 쉬운 URI를 설계할 수 있다. HTTP 응답 상태 코드 200 : client의 요청을 정상적으로 수행함 201 : client가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업 시) 400 : client의 요청이 부적절 할 경우 사용하는 응답 코드 401 : client가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답 코드 (로그인 하지 않은 유저가 로그인 했을 때, 요청 가능한 리소스를 요청했을 때) 403 : 유저 인증상태와 관계 없이 응답하고 싶지 않은 리소스를 client가 요청했을 때 사용하는 응답 코드 (403 보다는 400이나 404를 사용할 것을 권고. 403 자체가 리소스가 존재한다는 뜻이기 때문에) 405 : client가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답 코드 301 : client가 요청한 리소스에 대한 URI가 변경 되었을 때 사용하는 응답 코드 (응답 시 Location header에 변경된 URI를 적어줘야 한다.) 500 : 서버에 문제가 있을 경우 사용하는 응답 코드","categories":[{"name":"개발 상식","slug":"개발-상식","permalink":"https://woovictory.github.io/categories/개발-상식/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"https://woovictory.github.io/tags/RESTful/"}]},{"title":"[1759] 암호 만들기","slug":"BOJ1759","date":"2018-04-13T10:02:33.000Z","updated":"2018-12-04T08:29:57.806Z","comments":true,"path":"2018/04/13/BOJ1759/","link":"","permalink":"https://woovictory.github.io/2018/04/13/BOJ1759/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1759 Explain 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며, 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다. 암호를 이루는 알파벳은 오름차순 정렬 암호로 사용할 수 있는 문자의 종류는 C가지 Key Point 알파벳을 입력받은 다음 오름차순 정렬을 먼저 한다. 각각의 문자를 사용할지 말지 결정한다. go(L, alphabet, password, index) L : 만들어야 하는 암호의 길이 alphabet : 사용할 수 있는 알파벳 배열 password : 현재까지 만든 암호 index : 사용할 지 말 지 결정해야 하는 알파벳의 index 예외 불가능한 경우 : 더 이상 사용할 알파벳 배열이 없을 경우 정답을 찾은 경우 : 지금까지 만든 암호의 길이가 만들어야 하는 암호의 길이와 같을 경우 다음 경우 i번째 알파벳을 사용하는 경우 = go(L, alphabet, password+alphabet[index], index+1) i번째 알파벳을 사용하지 않는 경우 = go(L, alphabet, password, index+1) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Exam1759 &#123; // 자음과 모음의 개수를 check하는 배열 public static boolean check(String password) &#123; int ja = 0; // 자음 int mo = 0; // 모음 for(char word : password.toCharArray()) &#123; // 문자열의 문자 각각이 자음인지 모음인지 확인하기 위한 과정 if(word == &apos;a&apos; || word == &apos;e&apos; || word == &apos;i&apos; || word == &apos;o&apos; || word == &apos;u&apos;) &#123; mo++; &#125;else &#123; ja++; &#125; &#125; return ja&gt;=2 &amp;&amp; mo&gt;=1; &#125; // 재귀 함수 public static void go(int L, String[] alphabet, String password, int index) &#123; // 정답을 찾은 경우 if(L == password.length()) &#123; if(check(password)) &#123; System.out.println(password); &#125; return; &#125; // 더 이상 사용할 알파벳이 없을 경우 [다 탐색을 진행한 경우] if(index &gt;= alphabet.length) &#123; return; &#125; go(L, alphabet, password+alphabet[index], index+1); // 다음의 알파벳을 사용하는 경우 [ 현재까지 만든 암호에 다음 알파벳을 이어 붙여준다.] 그리고 index 증가 go(L, alphabet, password, index+1); // 다음의 알파벳을 사용하지 않는 경우 [다음 알파벳을 사용하지 않으므로 현재까지 만든 암호만 넘겨준다.] 그리고 수행을 했으므로 index 증가 // ( 다음 알파벳은 사용하지 않았지만, 다 다음 알파벳에 대해서 진행해야 하기 때문에 index를 증가시키는 것이다. ) &#125; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st1 = new StringTokenizer(bf.readLine(), &quot; &quot;); int L = Integer.parseInt(st1.nextToken()); // 만들어야 하는 암호의 길이 : 4 int C = Integer.parseInt(st1.nextToken()); // 암호로 사용할 수 있는 문자의 종류 : 6가지 String[] alphabet = new String[C]; StringTokenizer st2 = new StringTokenizer(bf.readLine(), &quot; &quot;); for(int i=0;i&lt;C;i++) &#123; alphabet[i] = st2.nextToken(); &#125; Arrays.sort(alphabet); // 오름차순으로 정렬 go(L, alphabet, &quot;&quot;, 0); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[9095] 1,2,3 더하기","slug":"BOJ9095-Recursive","date":"2018-04-13T07:06:24.000Z","updated":"2018-12-04T08:30:29.161Z","comments":true,"path":"2018/04/13/BOJ9095-Recursive/","link":"","permalink":"https://woovictory.github.io/2018/04/13/BOJ9095-Recursive/","excerpt":"","text":"Key Point 이전에는 n의 범위가 0&lt;=n&lt;=10 까지이므로 모든 경우의 수를 다 진행해보았다. 하지만, 재귀 함수를 이용해서 문제를 풀면 더욱 간단하게 풀 수 있다. Explain go(count, sum, goal)라는 재귀 함수를 만들어서 사용한다. 불가능한 경우 : 합이 만드려는 수보다 커지는 경우 : sum &gt; goal 정답을 찾은 경우 : sum == goal 다음 경우 go(count+1, sum+1, goal) go(count+1, sum+2, goal) go(count+1, sum+3, goal) Code 12345678910111213141516171819202122232425262728public class Exam9095_Recursive &#123; public static int go(int count, int sum, int goal) &#123; if(count&gt;10) &#123; return 0; &#125; if(sum == goal) &#123; return 1; &#125; int now = 0; for(int i=1;i&lt;=3;i++) &#123; now = now + go(count+1, sum+i,goal); &#125; return now; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); while(test_case-- &gt;0) &#123; int number = Integer.parseInt(bf.readLine()); System.out.println(go(0,0,number)); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[5014] 스타트링크","slug":"BOJ5014","date":"2018-04-11T16:18:20.000Z","updated":"2018-12-04T08:30:19.562Z","comments":true,"path":"2018/04/12/BOJ5014/","link":"","permalink":"https://woovictory.github.io/2018/04/12/BOJ5014/","excerpt":"","text":"Key Point BFS를 통해 문제를 플었다. 큐를 이용해 문제를 해결하였다. 만약, U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다. (1 ≤ S, G ≤ F ≤ 1000000, 0 ≤ U, D ≤ 1000000) Explain 방문한 적이 있는지 확인할 수 있도록 dist라는 배열을 만들어서 방문하지 않았다면 -1 방문하였고, 이동했다면 1씩 증가해주었다. dist[current]가 이전에 계산했던 이동횟수를 저장하고 있다. F : 건물의 총 층 수 S : 강호가 위치한 층 G : 강호가 가려는 층 U : 위로 U층만큼 이동 D : 아래로 D층만큼 이동 Code 123456789101112131415161718192021222324252627282930313233343536public class Exam5014 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int F = sc.nextInt(); // 건물의 층 수 int S = sc.nextInt(); // 강호가 위치해 있는 층 int G = sc.nextInt(); // 강호가 이동하려는 층 int U = sc.nextInt(); // 위로 U층만큼 이동하는 버튼 int D = sc.nextInt(); // 아래로 D층만큼 이동하는 버튼 int[] dist = new int[F+1]; Arrays.fill(dist, -1); Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); dist[S] = 0; q.add(S); while(!q.isEmpty()) &#123; int current = q.poll(); if(current + U &lt;=F &amp;&amp; dist[current+U] == -1) &#123; q.add(current+U); dist[current+U] = dist[current]+1; &#125; if(current - D &gt;=1 &amp;&amp; dist[current-D] == -1) &#123; q.add(current-D); dist[current-D] = dist[current]+1; &#125; &#125; if(dist[G] == -1) &#123; System.out.println(&quot;Use&quot;); &#125;else &#123; System.out.println(dist[G]); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[2251] 물통","slug":"BOJ2251","date":"2018-04-11T10:15:27.000Z","updated":"2018-12-04T08:30:04.902Z","comments":true,"path":"2018/04/11/BOJ2251/","link":"","permalink":"https://woovictory.github.io/2018/04/11/BOJ2251/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/2251 Key Point 처음에 a,b는 비어있고, c만 가득 채워져있는 상태이므로 c의 용량은 c = C - a - b로 계산할 수 있다. a의 용량 &gt; b의 용량일 경우, a-&gt;b로 물을 부었을 경우 넘친 만큼을 a로 다시 부어주는 상황을 생각해야 한다. Explain 각 물통의 용량을 입력으로 받는다. 그리고 처음에 앞에 두 물통은 비어있고, C만 가득차있다. 물을 옮기는 과정에서 손실되는 물이 없는 것이 중요한 점이다. 이 때, 첫 번쨰 물통 A가 비어있을 때, 세 번째 물통 C에 담겨 있을 수 있는 물의 양을 모두 구하는 것이다. [오름차순] BFS를 이용해서 문제를 푼다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Pair implements Comparable&lt;Pair&gt;&#123; int first; // 첫번째 물통 int second; // 두번째 물통 Pair(int first,int second)&#123; this.first = first; this.second = second; &#125; @Override public int compareTo(Pair pair) &#123; if(this.first&lt;pair.first) &#123; return -1; &#125; if(this.first&gt;pair.first) &#123; return 1; &#125; if(this.second&lt;pair.second) &#123; return -1; &#125; if(this.second&gt;pair.second) &#123; return 1; &#125; return 0; &#125;&#125;public class Exam2251 &#123; public static final int[] from = &#123;0,0,1,1,2,2&#125;; public static final int[] to = &#123;1,2,0,2,0,1&#125;; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int[] cap = new int[3]; for(int i=0;i&lt;3;i++) &#123; cap[i] = sc.nextInt(); &#125; int sun = cap[2]; // a+b+c = C boolean[][] check = new boolean[201][201]; boolean[] ans = new boolean[201]; Queue&lt;Pair&gt; q = new LinkedList&lt;Pair&gt;(); q.add(new Pair(0,0)); check[0][0] = true; ans[cap[2]] = true; while(!q.isEmpty()) &#123; int[] current = new int[3]; Pair p = q.peek(); current[0] = p.first; current[1] = p.second; current[2] = sun - current[0] - current[1]; q.remove(); for(int i=0;i&lt;6;i++) &#123; int[] next = &#123;current[0],current[1],current[2]&#125;; next[to[i]] +=next[from[i]]; // 물통에 있는 물 따르기 ex) a-&gt;b next[from[i]] = 0; // 물통비우기 if(next[to[i]]&gt;=cap[to[i]]) &#123; next[from[i]] = next[to[i]] - cap[to[i]]; next[to[i]] = cap[to[i]]; &#125; // q에 없던 친구들이라면! // 즉, check[next[0]][next[1]]이 false라면 if(!check[next[0]][next[1]]) &#123; check[next[0]][next[1]] = true; q.add(new Pair(next[0],next[1])); if(next[0] == 0) &#123; ans[next[2]] = true; &#125; &#125; &#125; &#125; for(int k=0;k&lt;=cap[2];k++) &#123; if(ans[k] == true) &#123; System.out.print(k+&quot; &quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1525] 퍼즐문제","slug":"BOJ1525","date":"2018-04-05T08:53:29.000Z","updated":"2018-12-04T08:29:46.385Z","comments":true,"path":"2018/04/05/BOJ1525/","link":"","permalink":"https://woovictory.github.io/2018/04/05/BOJ1525/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1525 Key Point 8 퍼즐 문제이므로 9!개의 경우의 수가 있다. 그리고 0 -&gt; 9로 바꿔서 9자리의 수가 나오므로 이를 이용해서 문제를 푼다. 네 방향으로 이동할 수 있다. Explain 큐를 이용해서 값을 꺼내면서 찾는다. 그리고 Map을 이용해서 상태 값을 저장한다. 큐에 있는 값들을 빼면서 가장 적게 걸리는 상태를 찾아낸다. 모든 경우의 수를 탐색하면서 상태값을 저장하고 원하는 123456789의 상태값만 찾아서 출력하면 된다. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Exam1525 &#123; public static final int[] dx = &#123;0,0,1,-1&#125;; public static final int[] dy = &#123;1,-1,0,0&#125;; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n=3; int start=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; int temp = sc.nextInt(); if(temp == 0) &#123; temp =9; &#125; start = start*10 + temp; // 숫자를 문자열처럼 저장하기 위함 // 그리고 2차원 배열의 형태를 1차원 배열의 형태로 바꾸기 위해서 &#125; &#125; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(start, 0); q.add(start); while(!q.isEmpty()) &#123; int now_num = q.poll(); // 제일 위에 있는 숫자 빼 String now = Integer.toString(now_num); // 숫자를 문자열로 변환 int z = now.indexOf(&apos;9&apos;); // 그리고 9[0]이 있는 위치를 찾는다. int x = z/3; // 9가 위치한 인덱스를 나중에 구하기위해 int y = z%3; // 9가 위치한 인덱스를 나중에 구하기위해 for(int k=0;k&lt;4;k++) &#123; int nx = x+dx[k]; // 네방향으로 이동하기 위해서 int ny = y+dy[k]; // 네 방향으로 이동하기 위해서 if(nx&gt;=0 &amp;&amp; nx&lt;n &amp;&amp; ny&gt;=0 &amp;&amp; ny&lt;n) &#123; //범위를 벗어나지 않도록 하기 위해서 StringBuilder next = new StringBuilder(now); // 밑에는 9가 위치한 곳과 다른 곳의 위치를 교환하는 코드 char temp = next.charAt(x*3+y); next.setCharAt(x*3+y, next.charAt(nx*3+ny)); next.setCharAt(nx*3+ny, temp); int number = Integer.parseInt(next.toString()); // map이 number를 포함하지 않으면 그 number의 상태를 1증가시킨다. // 그리고 큐에 추가한다. if(!map.containsKey(number)) &#123; map.put(number, map.get(now_num)+1); q.add(number); &#125; &#125; &#125; &#125; if(map.containsKey(123456789)) &#123; System.out.println(map.get(123456789)); &#125;else &#123; System.out.println(-1); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1963] 소수 경로","slug":"BOJ1963","date":"2018-04-05T06:47:55.000Z","updated":"2018-12-04T08:30:02.844Z","comments":true,"path":"2018/04/05/BOJ1963/","link":"","permalink":"https://woovictory.github.io/2018/04/05/BOJ1963/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1963 Key Point 먼저, 에라토스테네스의 체를 이용해 4자리 소수를 구한다. 그리고 한자리씩 바꾸면서 바뀐 수가 소수인지 확인하면 된다. 정점의 개수 10000개 이하 Explain N을 M으로 바꾸는 최소 변환 횟수를 구하는 문제이므로 BFS 한번에 N에서 한자리만 바꿀 수 있고 바꾼 숫자도 소수여야 한다. i번째 자리수를 j로 바꾼다. [change] next = -1 -&gt; 바꿀 수 없음을 의미하며, 첫번째 자리가 0인 경우를 뜻한다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Exam1963 &#123; public static int change(int num, int index, int digit) &#123; if(index == 0 &amp;&amp; digit == 0) &#123; // indext와 digit이 0이면 첫번째 자리수가 0을 뜻함 return -1; &#125; String s = Integer.toString(num); StringBuilder sb = new StringBuilder(s); sb.setCharAt(index, (char)(digit+&apos;0&apos;)); // index번째 자리를 digit으로 바꾼다. return Integer.parseInt(sb.toString()); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); boolean[] prime = new boolean[10001]; // 에라토스테네스의 체를 이용한 소수 구하기 for(int i=2;i&lt;=10000;i++) &#123; if(prime[i] == false) &#123; for(int j=i*i;j&lt;=10000;j+=i) &#123; prime[j] = true; &#125; &#125; &#125; for(int i=0;i&lt;=10000;i++) &#123; prime[i] = !prime[i]; &#125; // prime[] 배열에 true로 check되어 있는 것들이 소수임! int test_case = sc.nextInt(); while(test_case-- &gt;0) &#123; int n = sc.nextInt(); int m = sc.nextInt(); boolean[] check = new boolean[10001]; int[] dist = new int[10001]; dist[n] = 0; check[n] = true; // 소수임을 의미 Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); q.add(n); while(!q.isEmpty()) &#123; int now_location = q.poll(); for(int i=0;i&lt;4;i++) &#123; for(int j=0;j&lt;=9;j++) &#123; int next_location = change(now_location,i,j); if(next_location != -1) &#123; if(prime[next_location] == true &amp;&amp; check[next_location] == false) &#123; // next_location이 prime[] 배열에서 소수로 체크되어있는지와 check[] 배열에는 false로 체크되어있는지 // 조건을 확인한다. // 조건에 맞으면 [prime 배열에 존재하면 ] 소수임을 뜻한다. q.add(next_location); dist[next_location] = dist[now_location]+1; check[next_location] = true; // 소수로 check해버린다. &#125; &#125; &#125; &#125; &#125; System.out.println(dist[m]); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10971] 외판원 순회2","slug":"BOJ10971","date":"2018-04-03T03:05:07.000Z","updated":"2018-12-04T08:31:33.007Z","comments":true,"path":"2018/04/03/BOJ10971/","link":"","permalink":"https://woovictory.github.io/2018/04/03/BOJ10971/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10971 Key Point go[i][j] = 도시 i에서 도시 j로 가기 위한 비용 어떤 도시를 방문할 지 city[] 라는 배열에 넣는다. city[0] city[1] … city[N-1] 은 각각 도시1, 도시2, … 도시N-1을 나타냄 Explain N의 범위 : 2&lt;=N&lt;=10 이므로 모든 경우를 시간 복잡도 안에 구할 수 있다. 모든 도시를 한번만 거친다고 하였므로 순열을 이용해서 풀 수 있다. N = 4일 경우 순회할 수 있는 경우는 4개이다. 1-&gt;2-&gt;3-&gt;4 2-&gt;3-&gt;4-&gt;1 3-&gt;4-&gt;1-&gt;2 4-&gt;1-&gt;2-&gt;3 문제에서 N개의 도시를 거쳐 다시 시작했던 지점으로 돌아간다고 했으므로 1번 도시를 시작도시로 정해놓고 (N-1)!개의 경우를 구하면 된다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Exam10971 &#123; // 다음 순열을 구하는 next_permutation() 함수 public static boolean next_permutation(int[] a) &#123; int i = a.length-1; while(i&gt;0 &amp;&amp; a[i-1]&gt;=a[i]) &#123; i--; &#125; if(i&lt;=0) &#123; return false; &#125; int j = a.length-1; while(a[j]&lt;=a[i-1]) &#123; j--; &#125; int tmp = a[i-1]; a[i-1] = a[j]; a[j] = tmp; j = a.length-1; while(i&lt;j) &#123; tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; return true; &#125; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); int[][] cost = new int[test_case][test_case]; // i에서 j로 가기 위한 비용 for(int i=0;i&lt;test_case;i++) &#123; for(int j=0;j&lt;test_case;j++) &#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); cost[i][j] = Integer.parseInt(st.nextToken()); &#125; &#125; int[] city = new int[test_case]; for(int i=0;i&lt;test_case;i++) &#123; city[i] = i; // 도시를 의미 &#125; int ans = Integer.MAX_VALUE; do &#123; boolean possible = true; int sum = 0; for(int i=0;i&lt;test_case-1;i++) &#123; if(cost[city[i]][city[i+1]] == 0) &#123; possible = false; &#125;else &#123; sum += cost[city[i]][city[i+1]]; &#125; &#125; if(possible == true &amp;&amp; cost[city[test_case-1]][city[0]] !=0) &#123; // 다음 도시로 갈 수 있고, 처음 도시로 돌아갈 수 있다면 sum+=cost[city[test_case-1]][city[0]]; if(ans&gt;sum) ans = sum; &#125; &#125;while(next_permutation(city)); System.out.println(ans); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1722] 순열의 순서","slug":"BOJ1722","date":"2018-03-31T11:53:52.000Z","updated":"2018-12-04T08:29:45.379Z","comments":true,"path":"2018/03/31/BOJ1722/","link":"","permalink":"https://woovictory.github.io/2018/03/31/BOJ1722/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1722 Key Point N의 범위 : 0&lt;=N&lt;=20 그래서 next_permutation 함수를 구현해서 문제를 풀려고 하였는데, 시간초과가 발생하여서 다른 방식으로 풀어야 한다. Explain Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Exam1722 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int check = sc.nextInt(); long[] fac = new long[num+1]; boolean[] c = new boolean[num+1]; fac[0] = 1; for(int i=1;i&lt;=num;i++) &#123; fac[i] = fac[i-1] * i; &#125; // 팩토리얼 구하기 if(check == 1) &#123; long where = sc.nextLong(); int[] arr = new int[num]; for(int i=0;i&lt;num;i++) &#123; for(int j=1;j&lt;=num;j++) &#123; if(c[j] == true) &#123; continue; &#125; if(fac[num-i-1]&lt;where) &#123; where = where - fac[num-i-1]; &#125;else &#123; arr[i] = j; c[j] = true; break; &#125; &#125; &#125; for(int i=0;i&lt;num;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; &#125;else if(check == 2) &#123; int[] arr = new int[num]; for(int i=0;i&lt;num;i++) &#123; arr[i] = sc.nextInt(); &#125; long result = 0; for(int i=0;i&lt;num;i++) &#123; for(int j=1;j&lt;arr[i];j++) &#123; if(c[j] == false) &#123; result = result + fac[num-i-1]; &#125; &#125; c[arr[i]] = true; &#125; System.out.println(result+1); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10974] 모든 순열","slug":"BOJ10974","date":"2018-03-31T11:37:39.000Z","updated":"2018-12-04T08:31:39.652Z","comments":true,"path":"2018/03/31/BOJ10974/","link":"","permalink":"https://woovictory.github.io/2018/03/31/BOJ10974/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10974 Key Point 123do&#123;&#125;while(); 잘 사용하지 않은 반복문을 사용해서 첫번째 순열을 찍고 다음 순열을 계속해서 찍어내면 된다. do ~ while문을 사용하지 않으면 사전순으로 첫 번째에 위치한 순열을 찍어낼 수 없으므로 do ~ while문을 사용한다. Explain 이전 순열과 모든 순열을 구하는 문제를 하나로 합치면 된다. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Exam10974 &#123; public static boolean next_permutation(int[] a) &#123; int i = a.length-1; while(i&gt;0 &amp;&amp; a[i-1]&gt;=a[i]) &#123; i--; &#125; if(i&lt;=0) &#123; return false; &#125; int j = a.length-1; while(a[j]&lt;=a[i-1]) &#123; j--; &#125; int tmp = a[i-1]; a[i-1] = a[j]; a[j] = tmp; j = a.length-1; while(i&lt;j) &#123; tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; return true; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); int[] a = new int[N]; for(int i=0;i&lt;N;i++) &#123; a[i] = i+1; &#125; do &#123; for(int i=0;i&lt;N;i++) &#123; System.out.print(a[i]+&quot; &quot;); &#125; System.out.println(); &#125;while(next_permutation(a)); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10973] 이전 순열","slug":"BOJ10973","date":"2018-03-31T11:21:50.000Z","updated":"2018-12-04T08:31:37.170Z","comments":true,"path":"2018/03/31/BOJ10973/","link":"","permalink":"https://woovictory.github.io/2018/03/31/BOJ10973/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10973 Key Point 모든 순열을 구하는 문제를 반대로 생각해서 풀면된다. Explain 모든 순열을 구할 때와 반대로 생각하면 된다. 1 2 3 4 이 경우 이전 순열은 없으므로 -1을 출력하면 된다. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Exam10973 &#123; public static boolean next_permutation(int[] a) &#123; int i = a.length - 1; while(i&gt;0 &amp;&amp; a[i-1]&lt;=a[i]) &#123; i--; &#125; if(i&lt;=0) &#123; return false; &#125; int j = a.length-1; while(a[j]&gt;=a[i-1]) &#123; j--; &#125; int tmp = a[i-1]; a[i-1] = a[j]; a[j] = tmp; j = a.length-1; while(i&lt;j) &#123; tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; return true; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); int[] arr = new int[N]; StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;); for(int i=0;i&lt;N;i++) &#123; arr[i] = Integer.parseInt(st.nextToken()); &#125; if(next_permutation(arr)) &#123; for(int i=0;i&lt;N;i++) &#123; System.out.print(arr[i]+&quot; &quot;); &#125; System.out.println(); &#125;else &#123; System.out.println(&quot;-1&quot;); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10972] 다음 순열","slug":"BOJ10972","date":"2018-03-31T10:55:42.000Z","updated":"2018-12-04T08:31:35.144Z","comments":true,"path":"2018/03/31/BOJ10972/","link":"","permalink":"https://woovictory.github.io/2018/03/31/BOJ10972/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10972 Explain 1부터 N까지의 수로 이루어진 순열이 있다. 이 떄, 사전순으로 다음에 오는 순열을 구해보자! 사전순으로 가장 앞서는 순열은 오름차순으로 이루어진 순열이고, 가장 마지막에 오는 순열은 내림차순으로 이루어진 순열이다. 여기서 사전순이란 N=3인 경우에 사전순으로 나열하면 아래와 같다. 1,2,3 1,3,2 2,1,3 2,3,1 3,1,2 3,2,1 C++에서는 STL의 next_permutation을 사용하면 되지만, Java에서는 직접 구현해서 사용하면 된다. 직접 next_permutation 함수를 구현해서 다음 순열을 구하면 된다. Key Point 순열을 사전순으로 나열했을 때, 사전순으로 다음에 오는 순열을 찾는 방법과 똑같다. i는 가장 오른쪽[마지막]원소부터 시작하며 a[i-1]&lt; a[i]를 만족하는 가장 큰 i를 찾는다. 즉, 순열의 마지막 수에서 끝나는 가장 긴 감소수열을 찾아야 한다. 7 2 3 6 5 4 1 여기서는 i:6, i-1:3이 된다. j&gt;=i이면서 a[j]&gt;a[i-1]를 만족하는 즉, i-1의 오른쪽에서 i-1보다 크면서 거기서 가장 작은 수를 찾는다. a[i-1]과 a[j]를 swap한다. a[i]부터 순열을 뒤집는다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Exam10972 &#123; public static boolean next_permutation(int[] a) &#123; int i = a.length - 1; while(i&gt;0 &amp;&amp; a[i-1]&gt;=a[i]) &#123; i--; &#125; if(i&lt;=0) &#123; return false; &#125; int j = a.length-1; while(a[j]&lt;=a[i-1]) &#123; j--; &#125; int tmp = a[i-1]; a[i-1] = a[j]; a[j] = tmp; j = a.length-1; while(i&lt;j) &#123; tmp = a[i]; a[i] = a[j]; a[j] = tmp; i++; j--; &#125; return true; &#125; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); int[] arr = new int[N]; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++) &#123; arr[i] = Integer.parseInt(st.nextToken()); &#125; if(next_permutation(arr)) &#123; for(int i=0;i&lt;N;i++) &#123; System.out.print(arr[i]+\" \"); &#125; System.out.println(); &#125;else &#123; System.out.println(\"-1\"); &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1107] 리모컨 문제","slug":"BOJ1107","date":"2018-03-30T09:41:18.000Z","updated":"2019-06-05T07:32:38.467Z","comments":true,"path":"2018/03/30/BOJ1107/","link":"","permalink":"https://woovictory.github.io/2018/03/30/BOJ1107/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1107 key Point 숫자 누르고 +/- 버튼을 눌러야 한다. +와 -를 번갈아 누르는 것은 의미가 없다. 문제에서 가능한 채널의 개수 : 500,000개 하지만, 채널은 무한대이므로 500,000을 기준으로 0에서 +버튼을 누르는 것과 1000,000에서 -버튼을 누르는 것은 동일한 횟수를 가짐 Explain 이동할 채널 C를 구한 다음 -&gt; C에 포함되어 있는 숫자 중에서 고장난 버튼이 있는지 확인을 한다. 고장난 버튼이 없다면 |c-N|을 계산해서 +,- 버튼을 총 몇번 눌러야 하는지 계산한다. 그리고 C가 0일 경우 예외처리를 해주어야 한다. 참고 : BufferedReader를 사용해 입력을 받으면 Runtime error 발생! Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Exam1107 &#123; static boolean[] broken = new boolean[10]; // 버튼이 고장났는지 확인하기 위한 배열 // true : 고장 false : 고장 X static int possible(int c) &#123; // 채널의 길이를 구한다. if(c == 0) &#123; if(broken[0] == true) &#123; return 0; &#125;else &#123; return 1; &#125; &#125; int len = 0; while(c&gt;0) &#123; if(broken[c%10] == true) &#123; return 0; &#125; len+=1; c = c/10; &#125; return len; &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); for(int i=0;i&lt;m;i++) &#123; int button = sc.nextInt(); broken[button] = true; &#125; int ans = n - 100; if(ans&lt;0) &#123; ans = -ans; &#125; for(int i=0;i&lt;=1000000;i++) &#123; int c = i; int len = possible(c); if(len&gt;0) &#123; int press = c-n; if(press&lt;0) &#123; press = -press; &#125; if(ans&gt;press+len) &#123; ans = len+press; &#125; &#125; &#125; System.out.println(ans); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[1476] 날짜계산","slug":"BOJ1476","date":"2018-03-30T09:17:29.000Z","updated":"2018-12-04T08:29:36.713Z","comments":true,"path":"2018/03/30/BOJ1476/","link":"","permalink":"https://woovictory.github.io/2018/03/30/BOJ1476/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/1476 Key Point 지구를 나타내는 숫자 E : 0&lt;=E&lt;=15 태양을 나타내는 숫자 S : 0&lt;=S&lt;=28 달을 나타내는 숫자 M : 0&lt;=M&lt;=19 1 1 1은 1년을 의미한다. 각 숫자의 범위를 넘어가면 1로 바뀐다. Explain e=1,s=1,m=1로 1년을 설정해놓고 풀면 된다. 무한 loop 속에서 e,s,m이 내가 입력 받은 E,S,M과 모두 일치하는 경우를 찾으면 된다. Code 12345678910111213141516171819202122232425262728293031public class Exam1476 &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;); int E = Integer.parseInt(st.nextToken()); int S = Integer.parseInt(st.nextToken()); int M = Integer.parseInt(st.nextToken()); int e=1,s=1,m=1; // 1 1 1은 1년을 의미 for(int i=1; ; i++) &#123; // 무한 loop if(e == E &amp;&amp; s == S &amp;&amp; m == M) &#123; System.out.println(i); break; &#125; e++; s++; m++; if(e == 16) e=1; if(s == 29) s=1; if(m == 20) m=1; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[9095] 1,2,3 더하기","slug":"BOJ9095","date":"2018-03-30T09:10:30.000Z","updated":"2018-12-04T08:30:31.426Z","comments":true,"path":"2018/03/30/BOJ9095/","link":"","permalink":"https://woovictory.github.io/2018/03/30/BOJ9095/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/9095 핵심 test_case를 입력받고 정수 N을 입력 받았을 때, 정수를 1,2,3의 합으로 표현할 수 있는 경우의 수를 구하는 문제이다. N의 범위 : N&lt;=10 풀이 이 경우는 N중 for문을 이용해서 문제를 푼다. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Exam9095 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int test_case = Integer.parseInt(bf.readLine()); for(int i=0;i&lt;test_case;i++) &#123; int num = Integer.parseInt(bf.readLine()); int cnt = 0; for(int l1=1;l1&lt;=3;l1++) &#123; if(l1 == num) &#123; cnt++; &#125;for(int l2=1;l2&lt;=3;l2++) &#123; if(l1+l2 == num) &#123; cnt++; &#125;for(int l3=1;l3&lt;=3;l3++) &#123; if(l1+l2+l3 == num) &#123; cnt++; &#125;for(int l4=1;l4&lt;=3;l4++) &#123; if(l1+l2+l3+l4 == num) &#123; cnt++; &#125;for(int l5=1;l5&lt;=3;l5++) &#123; if(l1+l2+l3+l4+l5 == num) &#123; cnt++; &#125;for(int l6=1;l6&lt;=3;l6++) &#123; if(l1+l2+l3+l4+l5+l6 == num) &#123; cnt++; &#125;for(int l7=1;l7&lt;=3;l7++) &#123; if(l1+l2+l3+l4+l5+l6+l7 == num) &#123; cnt++; &#125;for(int l8=1;l8&lt;=3;l8++) &#123; if(l1+l2+l3+l4+l5+l6+l7+l8 == num) &#123; cnt++; &#125;for(int l9=1;l9&lt;=3;l9++) &#123; if(l1+l2+l3+l4+l5+l6+l7+l8+l9 == num) &#123; cnt++; &#125;for(int l10=1;l10&lt;=3;l10++) &#123; if(l1+l2+l3+l4+l5+l6+l7+l8+l9+l10 == num) &#123; cnt++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; System.out.println(cnt); &#125;&#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[10819] 차이를 최대로","slug":"BOJ10819","date":"2018-03-30T08:19:56.000Z","updated":"2018-12-04T08:31:05.377Z","comments":true,"path":"2018/03/30/BOJ10819/","link":"","permalink":"https://woovictory.github.io/2018/03/30/BOJ10819/","excerpt":"","text":"문제 : https://www.acmicpc.net/problem/10819 핵심 순열을 사용해서 전체 경우의 수를 구한다. 문제에서 N의 범위는 3&lt;=N&lt;=8이므로 최대 경우의 수는 8! = 40320이다. 1i=1;i&lt;a.length;i++ 풀이 입력받은 정수의 개수 N에 대하여 배열에 들어갈 수를 입력받는다. 순열을 구하기 전에 오름차순으로 정렬을 한다. next_permutation을 통해서 N!개의 모든 순열을 구한다. 그리고 _Cal()_이라는 함수를 통해서 해당 순열의 차이의 최대값의 합을 저장한다. 그리고 처음에 값을 value에 저장했다가 Calculate_sum을 통해서 계산되는 차이의 합과 value를 _Math.max_을 이용해서 최대값을 구한다. value에 저장한다. 결국, value -&gt; 차이의 최대값 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Exam10819 &#123; public static void main(String[] args) throws NumberFormatException, IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(bf.readLine()); int[] number_arr = new int[N]; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); for(int i=0;i&lt;N;i++) &#123; number_arr[i] = Integer.parseInt(st.nextToken()); &#125; Arrays.sort(number_arr); // 정렬 int value = 0; do &#123; int cal_sum = Calculate_sum(number_arr); value = Math.max(value, cal_sum); &#125;while(next_permutation(number_arr)); System.out.println(value);&#125;public static int Calculate_sum(int[] arr) &#123; int sum = 0; for(int i=1;i&lt;arr.length;i++) &#123; sum = sum + Math.abs(arr[i]-arr[i-1]); &#125; return sum;&#125;public static boolean next_permutation(int[] arr) &#123; int i = arr.length-1; while(i&gt;0 &amp;&amp; arr[i-1]&gt;=arr[i]) &#123; i--; &#125; if(i&lt;=0) &#123; return false; &#125; int j = arr.length-1; while(arr[j]&lt;=arr[i-1]) &#123; j--; &#125; int tmp = arr[i-1]; arr[i-1] = arr[j]; arr[j] = tmp; j = arr.length-1; while(i&lt;j) &#123; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; i++; j--; &#125; return true;&#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://woovictory.github.io/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","permalink":"https://woovictory.github.io/categories/algorithm/BOJ/"}],"tags":[{"name":"BOJ","slug":"BOJ","permalink":"https://woovictory.github.io/tags/BOJ/"}]},{"title":"[자료구조] Stack vs Queue","slug":"DataStructure-Diff-of-Stack-Queue","date":"2018-03-20T07:16:05.000Z","updated":"2020-05-12T06:42:22.381Z","comments":true,"path":"2018/03/20/DataStructure-Diff-of-Stack-Queue/","link":"","permalink":"https://woovictory.github.io/2018/03/20/DataStructure-Diff-of-Stack-Queue/","excerpt":"","text":"Stack Last In First Out(LIFO)의 구조로 나중에 들어간 원소가 가장 먼저 나오는 자료구조이다. 반대로 제일 먼저 들어간 원소가 가장 늦게 나온다. 함수의 콜스택에 쓰이고 문자열을 역순으로 출력할 때, 연산자 후위표기법 등에 쓰인다. Queue First In First Out(FIFO)의 구조로 먼저 들어간 원소가 먼저 나오는 구조를 갖는다. 컴퓨터 버퍼에서 주로 사용된다. 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼를 만들어 대기 시킨다. 참고 스택, 큐, 덱(Stack, queue, deque)의 특징에 대해 설명해보세요!","categories":[{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/categories/자료구조/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"https://woovictory.github.io/tags/Data-Structure/"},{"name":"자료구조","slug":"자료구조","permalink":"https://woovictory.github.io/tags/자료구조/"},{"name":"Stack","slug":"Stack","permalink":"https://woovictory.github.io/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"https://woovictory.github.io/tags/Queue/"}]},{"title":"자바 :: Priority Queue?","slug":"JavaCollectionPriorityQueue","date":"2018-03-19T08:11:16.000Z","updated":"2020-04-22T07:47:07.964Z","comments":true,"path":"2018/03/19/JavaCollectionPriorityQueue/","link":"","permalink":"https://woovictory.github.io/2018/03/19/JavaCollectionPriorityQueue/","excerpt":"","text":"이번에는 Priority Queue에 대해서 공부를 해보았습니다. Priority Queue 일반적으로 Queue라는 자료구조는 선입선출(First-In-First-Out)의 대기열 규칙을 갖고 있습니다. 즉, 큐에 삽입될 때의 시간이 큐에서의 순서를 결정하게 됩니다. 그러나 우선순위 큐는 입력 시간이 아닌 다른 조건으로 큐내에서의 순서를 결정할 수 있는데, 이 때 List에서 배운 Comparator 인터페이스가 큐 내에서의 순서를 결정하는 역할을 하게 됩니다. 사용법 import.java.util.PriorityQueue를 import하여 사용합니다. 사용법은 Queue와 동일한 메소드를 사용합니다. 12345// 기본 생성자. 객체의 기본 비교 CompareTo를 사용한다. PriorityQueue&lt;Integer&gt; pa = new PriorityQueue&lt;Integer&gt;();// 기본 배열크기, 비교함수를 인자로 받는 생성자.PriorityQueue&lt;Integer&gt; pa = new PriorityQueue&lt;Integer&gt;(); 메소드 삽입 - offer,add 큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다. 제거 - poll,remove 큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다. poll은 큐가 비어있다면 null을 반환 remove는 큐가 비어있다면 예외 발생 읽기 - peek,element 큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다. peek은 큐가 비어있다면 null을 반환 element은 큐가 비어있다면 예외 발생 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758PriorityQueue&lt;Prisoner&gt; pq = new PriorityQueue&lt;Prisoner&gt;(); Prisoner ps1 = new Prisoner(&quot;박보검&quot;,20);Prisoner ps2 = new Prisoner(&quot;하정우&quot;,3);Prisoner ps3 = new Prisoner(&quot;이준기&quot;,50);Prisoner ps4 = new Prisoner(&quot;강하늘&quot;,10);Prisoner ps5 = new Prisoner(&quot;박서준&quot;,2); pq.offer(ps1);pq.offer(ps2);pq.offer(ps3);pq.offer(ps4);pq.offer(ps5);System.out.println(&quot;사이즈:&quot;+pq.size()); while(!pq.isEmpty())&#123; Prisoner prisoner = pq.poll(); System.out.println(prisoner.name); &#125; System.out.println(&quot;----------Reverse&quot;); PriorityQueue&lt;Prisoner&gt; reversedPriorityQueue = new PriorityQueue&lt;Prisoner&gt;(pq.size(), Collections.reverseOrder());reversedPriorityQueue.addAll(pq); while(!reversedPriorityQueue.isEmpty())&#123; Prisoner prisoner2 = reversedPriorityQueue.poll(); System.out.println(prisoner2.name); &#125; &#125;&#125;class Prisoner implements Comparable&lt;Prisoner&gt;&#123; String name; int weight; public Prisoner(String name, int weight)&#123; this.name = name; this.weight = weight; &#125; @Override public int compareTo(Prisoner ps) &#123; if(this.weight&gt;ps.weight)&#123; return 1; &#125;else if(this.weight&lt;ps.weight)&#123; return -1; &#125; return 0; &#125; // 이 상태는 오름차순인데, // Comparable을 구현하고, compareTo 메소드를 사용해서 내림차순을 구현하려면 // return 하는 값을 바꾸면 된다. 1 대신에 -1을 -1 대신에 1을!!&#125; 우선순위 큐에서 값을 poll()이라는 함수를 통해서 꺼내게 되면 가장 작은 값부터 꺼낼 수 있게 됩니다. 그 이유는 우선순위 큐는 내부적으로 Natural Ordering에 따라서 정렬하는 큐이기 때문입니다. 12345678PriorityQueue&lt;Integer&gt; pQueue = new PriorityQueue&lt;Integer&gt;(); for (int i =10; i&gt;0; i--)&#123; pQueue.add(i);&#125;System. out .println(pQueue.peek()); 실제로 위의 예를 실행해보면 peek() 메소드를 통해서 head 에 있는 값을 가져오는데, 10이 아니라 1을 가져오는 것을 확인할 수 있습니다. 그것은 Priority Queue가 natural Ordering에 따라서 정렬하기 때문에 가장 작은 값이 head 부분에 위치하는 것을 알 수 있습니다. 그리고 Priority Queue는 Null을 허용하지 않습니다. Natural Ordering에 기초하고 있기 때문에 정렬할 수 없는 Null은 허용하지 않습니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"Java :: Collection Framework","slug":"java-collection-framework","date":"2018-03-08T07:46:14.000Z","updated":"2020-04-22T07:47:14.143Z","comments":true,"path":"2018/03/08/java-collection-framework/","link":"","permalink":"https://woovictory.github.io/2018/03/08/java-collection-framework/","excerpt":"","text":"Collection Framework 컬렉션 프레임워크 핵심 인터페이스 Collection 인터페이스 Array 배열의 복사 여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 Collection Framework에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데, 일반적으로 많이 사용되는 자료구조는 리스트, 스택, 큐, 해쉬 테이블이 있습니다. 이전에 포스팅했던 자료들은 자료구조별로 정리했었는데, 모두 삭제하고 하나의 포스팅에 압축해서 공부하고 올리도록 하겠습니다. :) CollectionFramework 자바에서 컬렉션 프레임워크(collection framework)란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다. 즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다. 이러한 컬렉션 프레임워크는 자바의 인터페이스를 사용하여 구현됩니다. 컬렉션 프레임워크 핵심 인터페이스 컬렉션 프레임워크에서는 컬렉션(데이터 그룹)을 크게 3가지 타입으로 구분하여 3가지 인터페이스를 정의했습니다. 그리고 인터페이스 중 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였습니다. 인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통 부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했습니다. 주요 인터페이스 간의 상속 관계 List : 순서가 있는 데이터의 집합. 데이터의 중복을 허용합니다. 구현 클래스 : ArrayList, LinkedList, Stack, Vector 등 Set : 순서를 유지하지 않는 데이터의 집합(순서가 없음). 데이터의 중복을 허용하지 않습니다.(Key) 구현 클래스 : HashSet, TreeSet 등 Map : 키(Key)와 값(value)의 쌍(Pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며(순서가 없음), 키는 중복을 허용하지 않고, 값은 중복을 허용합니다. 구현 클래스: HashMap, TreeMap, Hashtable, Properties 등 Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임워크의 명명법을 따르지 않습니다. Vector나 Hashtable과 같은 기존의 컬렉션들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다고 합니다. 그 대신 새로 추가된 ArrayList나 HashMap을 사용하는 것이 성능 면에서도 더 나은 결과를 얻을 수 있습니다. Collection 인터페이스 List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고, 두 인터페이스는 그것을 상속받습니다. 따라서 Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고, 그것을 메소드로 제공하고 있습니다. boolean add(Object o) : 지정된 객체(o)를 Collection에 추가합니다. boolean addAll(Collection c) : 지정된 Collection©의 객체들을 Collection에 추가합니다. void clear() : Collection의 모든 객체를 삭제합니다. boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어 있는지 확인합니다. boolean equals(Object o) : 동일한 Collection인지 비교합니다. int hashCode() : Collection의 hash code를 반환합니다. boolean isEmpty() : Collection이 비어있는지 확인합니다. Iterator iterator() : Collection의 Iterator를 얻어서 반환합니다 boolean remove(Object o) : 지정된 객체를 삭제합니다. int size() : Collection에 저장된 객체의 개수를 반환합니다. Object[] toArray() : Collection에 저장된 객체를 객체배얄(Object[])로 반환합니다. Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환합니다. Array(배열) 많은 데이터를 관리할 떄 용이 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 자료구조 배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있고, 반복문과 결합하면 많은 정보도 효율적으로 처리할 수 있습니다. 배열 인덱스는 값에 대한 유일무이한 식별자(리스트에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가짐) 크기가 정해져 있고 기능이 없습니다. 인덱스를 가지며, Element의 인덱스는 변경되지 않습니다. 인덱스를 활용하여 빠르게 조회가 가능합니다. 유관 데이터를 메모리에 순차적으로 나열할 수 있다. 인덱스를 이용하여 데이터를 가져오려면 데이터에 대한 인덱스 값이 고정되어야 합니다. (삭제된 Element의 공간이 그대로 남습니다.-&gt;메모리의 낭비) Arrays 클래스에는 배열을 다루는데 유용한 메소드가 정의되어 있습니다. Arrays에 정의된 메소드는 모두 static 메소드입니다. 배열의 복사 **copyOf()는 배열 전체를, copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환합니다. ** copyOfRange() 메소드에서 지정된 범위의 끝은 포함되지 않습니다.(즉, 지정된 범위의 끝의 바로 앞까지만!) 배열 채우기 fill()은 배열의 모든 요소를 지정된 값으로 채웁니다. setAll()은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받습니다. 이 메소드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야 합니다. 배열의 정렬과 검색 sort()는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 binarySearch()를 사용합니다. binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻습니다. (검색한 값과 일치하는 요소가 여러 개 있다면, 이 중 어떤 것의 위치가 반환될지는 알 수 없습니다.) 문자열의 비교와 출력 toString()은 배열의 모든 요소를 문자열로 편하게 출력할 수 있게 도와줍니다. toString()은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에서는 deepToString()을 사용해야 합니다. deepToString()은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하므로 2차원뿐만 아니라 3차원 이상의 배열에 대해서도 동작합니다. equals()는 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환합니다. equals()도 일차원 배열에만 사용 가능하므로, 다차원 배열의 비교에는 deepEquals()를 사용해야 합니다. 배열을 List로 변환 asList()는 배열을 List에 담아서 반환합니다. 한 가지 주의할 점은 asList()가 반환한 List의 크기를 변경할 수 없다는 것입니다. 저장된 내용은 변경 가능하나, 추가 또는 삭제가 불가능합니다. 만약 크기를 변경할 수 있는 List가 필요하다면 다음과 같이 하면 됩니다. 1List list = new ArrayList(Arrays.asList(1,2,3,4,5)); parallelXXX(), spliterator(), stream() parallel로 시작하는 이름의 메소드는 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 합니다. spliterator()는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환하며, stream()은 컬렉션을 스트림으로 변환합니다. 사용법 아래의 사용법에서 메소드를 사용해볼 수 있습니다. 1234567int[] number = new int[4];number[0]=10;number[1]=20;number[2]=30;System.out.println(number.length); // 길이:4 장/단점 장점 데이터의 크기가 확정적일 때 배열을 사용하면 메모리나 처리속도 면에서 좋습니다. 다른 데이터 Structure의 부품이 되기도 합니다. 단점 배열의 크기를 배열을 생성할 때 지정하는 것이나, 배열의 크기를 변경할 수 없습니다. 배열에서 설정된 Element(요소)의 개수를 알아낼 수 없습니다. 한계 배열은 길이를 바꿀 수 없습니다. 가변 배열과 길이가 변경 가능한 배열의 겅우 기존의 배열은 그대로 두고, 새로운 길이로 지정된 배열을 따로 할당 후 데이터의 복사를 진행하고, 기존의 배열을 삭제한다. 총 3번의 작업 + 메모리 탐색이 필요하기 때문에 리소스 낭비가 크다. 이런 한계를 해결하기 위해서 linked list 자료형을 활용할 수 있다. (탐색, 할당, 복사, 삭제 등의 리소스 낭비가 없습니다.) 배열은 인덱스에 따라서 값을 유지하기 떄문에, Element가 삭제되어도 빈자리(null)가 남게 됩니다.(메모리 낭비) 조건문을 통해서 제외할 수 있으나, 조건문을 많이 사용하면 좋지 않습니다. 인덱스가 중요한 경우는 배열을 사용, 인덱스가 중요하지 않은 경우는 리스트를 사용합니다. 삭제한 데이터를 뒤에 위치한 Element로 메꾸면, 데이터가 순서에 따라서 빈틈없이 연속적으로 위치하며 이를 list(리스트)라고 합니다. 배열 : 삭제된 데이터의 빈 공간을 그래도 남겨둠. 리스트 : 빈 공간을 채움. 이러한 문제점을 극복한 것이 List 입니다. List 인터페이스 List는 배열의 한계 때문에 만들어졌으며, List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음과 같은 특징을 가지고 있습니다. 리스트 자료구조의 핵심은 Element간의 순서. 즉, 순서가 있는 데이터의 모임이 리스트입니다. 같은 요소의 중복 저장을 허용합니다. 리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 빈틈 없는 데이터의 적재라는 장점을 취한 데이터 Structure입니다. 리스트에서 인덱스는 몇 번쨰 데이터인가 정도의 의미 빈 Element는 허용하지 않습니다. 데이터 개수가 확실하게 정해져 있고, 자주 사용된다면 Array가 더 효율적입니다. 대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같습니다. ArrayList LinkedList Vector Stack ArrayList List 인터페이스를 구현하기 때문에 데이터의 저장 순서가 유지되고 중복을 허용한다는 특징을 갖습니다. ArrayList는 Obejct 배열을 이용해서 데이터를 순차적으로 저장합니다. 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장됩니다. (Vector는 capacity가 부족할 경우 자동적으로 기존의 크기보다 2배의 크기로 증가됩니. 그러나 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 됩니다.) ArryaList는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 사용합니다. 배열은 크기를 변경할 수 없기 때문에 ArrayList나 Vector와 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야 하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있습니다. capacity : 현재 ArrayList가 수용할 수 있는 데이터의 수를 의미합니다. size : 현재 ArrayList에 저장된 데이터의 수를 의미합니다. Indexoutofbounds exception : capacity가 아닌 size에 의해 발생합니다. 데이터의 유무가 중요 예제 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;public class Collection &#123; public static void main(String[] args)&#123; ArrayList&lt;Integer&gt; items = new ArrayList&lt;&gt;(); // add를 이용한 요소 추가 items.add(40); items.add(20); items.add(10); items.add(30); // for와 get() 메소드를 이용한 요소 출력 for(int i=0;i&lt;items.size();i++)&#123; System.out.print(items.get(i)+\" \"); &#125; System.out.println(); // Enhanced for 문과 get() 메소드를 이용한 요소의 출력 for (int e :items) &#123; System.out.print(e+\" \"); &#125; System.out.println(); // Collections.sort() 메소드를 이용한 요소의 정렬 Collections.sort(items); // iterator와 get() 메소드를 이용한 요소의 출력 Iterator&lt;Integer&gt; iterator = items.iterator(); while(iterator.hasNext())&#123; System.out.print(iterator.next()+\" \"); &#125; System.out.println(); // set() 메소드를 이용한 요소의 값 변경 items.set(0, 100); for(int e : items)&#123; System.out.print(e+\" \"); &#125; System.out.println(); // 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수. 반환값은 있으면 true 없으면 false System.out.println(items.contains(100)); // add() 함수의 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 값이 추가됩니다. 하지만, 위치를 알 수 없을 때는 indexOf() 함수를 이용해서 위치값을 찾은 뒤 add()함수를 이용하면 됩니다. int index = items.indexOf(20); items.add(index, 110); for(int e : items)&#123; System.out.print(e+\" \"); &#125; System.out.println(); // index가 1인 요소 즉, 110 삭제, 인덱스로 삭제하면 어떤 인덱스로 삭제했는지 알려줌 System.out.println(items.remove(1)); for(int e : items)&#123; System.out.print(e+\" \"); &#125; System.out.println(); // 오브젝트를 넘겨서 오브젝트의 모든 요소 삭제 items.removeAll(items); // size() 메소드를 이용한 요소의 총 개수 System.out.println(items.size()); &#125;&#125;// 결과40 20 10 30 40 20 10 30 10 20 30 40 100 20 30 40 true100 110 20 30 40 110100 20 30 40 items size : 0 add() : List에 요소를 추가합니다. get() : 인덱스를 통한 요소 조회합니다. set() : 원하는 인덱스에 원하는 요소를 추가합니다. contains() : 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수, 반환값은 있으면 true 없으면 false indexOf() : 메소드의 인자로 오브젝트를 넘기면 이 오브젝트의 인덱스를 반환해줍니다. add(int index, Obejct o) : 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 두 번째 인자인 오브젝트가 추가됩니다. remove() : 인덱스를 이용해서 해당 인덱스를 삭제해줍니다. 인덱스로 삭제하게 되면 어떤 데이터를 삭제했는지 리턴값으로 알려줍니다. remove(Object element) : 오브젝트를 인수로 넘기면 검색해서 삭제시켜줍니다. 오브젝트를 이용해서 삭제를 하게 되면 삭제 결과가 성공인지 실패인지만 알려줍니다. LinkedList 배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있습니다. 크기를 변경할 수 없다. 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요합니다. 실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비됩니다. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다. 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야만 합니다. 이러한 배열의 단점을 보완하기 위해서 LinkedList(링크드 리스트)라는 자료구조가 고안되었습니다. 배열은 모든 데이터가 연속적으로 존재하지만 LinkedList는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있습니다. 링크드 리스트의 각 요소(node)들은 자신과 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있습니다. 1234class Node&#123; Node next; // 다음 요소의 주소를 저장 Object obj; // 데이터를 저장&#125; 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵습니다. 이 점을 보완한 것이 이중 연결리스트(doubly linked list, 더블 링크드 리스트)입니다. 더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용됩니다. 12345class Node&#123; Node next; // 다음 요소의 주소를 저장 Node previous; // 이전 요소의 주소를 저장 Object obj; // 데이터를 저장&#125; 더블 링크드 리스트의 접근성을 보다 향상시킨 것이 **더블 쎠큘러 링크드 리스트(이중 연결형 연결 리스트)**입니다. 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것입니다. 실제로 LinkedList 클래스는 이름과 달리 '링크드 리스트’가 아닌 '더블 링크드 리스트’로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것입니다. 순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠릅니다. : 만약 ArrayList의 크기가 충분하지 않으면, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하게 되므로 순차적으로 데이터를 추가해도 ArrayList보다 LinkedList가 더 빠를 수 있습니다. 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하며, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠릅니다. (단지 마지막 요소의 값을 null로만 바꾸면 되기 때문입니다.) 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠릅니다. : LinkedList는 각 요소 간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠릅니다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦습니다. 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지 않습니다. 데이터의 개수가 많아질수록 데이터를 읽어오는 시간, 즉 접근시간(access time)은 ArrayList가 LinkedList보다 빠릅니다. : ArrayList는 인덱스 기반의 자료 구조이며, get(index)를 통해 O(1)의 시간 복잡도를 가집니다. 배열의 경우 만일 n번째 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결됩니다. (배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문입니다.) n번째 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기 그러나, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이 아니기 때문에 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있습니다. 검색시 거의 모든 요소를 탐색해야 하기 때문에 최악의 경우에는 O(N)의 시간 복잡도를 갖습니다. 요약 LinkedList : 데이터의 추가/삭제가 많을 때 유리 Vector/ArrayList : 데이터 항목 검색이 많을 때 유리 ArrayList와 LinkedList 데이터를 가져오는 것인 빈번하다면 내부적으로 배열을 이용하는 ArraysList가 훨씬 빠릅니다. 하지만, 데이터의 추가/삭제가 빈번하다면 LinkedList가 훨씬 효과적입니다. LikedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다고 보면 됩니다. ArrayList와 같이 데이터의 추가, 삭제 시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, 데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리합니다. Iterator 사용 이유 linked 특성상 항상 처음부터 같은 경로를 반복적으로 지나면서 데이터의 위치를 검색해야 하기 때문에 마지막으로 접근한 데이터를 기준으로 그 다음 데이터를 알아내는 것이 더 쉽습니다. - 벡터나 ArrayList 처럼 사용되는 것입니다. Iterator(추출 전용 인터페이스) 데이터를 추출하기 위한 데이터 임시 저장공간 주로 순서가 없는 자료구조의 값들을 추출할 때 사용합니다. 보통 hasNext와 next 메소드를 이용한 while문으로 값을 추출합니다. 예제 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.LinkedList;public class Collection &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; lnkList = new LinkedList&lt;String&gt;(); lnkList.add(\"넷\"); lnkList.add(\"둘\"); lnkList.add(\"셋\"); lnkList.add(\"하나\"); for (int i = 0; i &lt; lnkList.size(); i++) &#123; System.out.print(lnkList.get(i) + \" \"); &#125; System.out.println(); // 삭제 lnkList.remove(1); for (String e : lnkList) &#123; System.out.print(e + \" \"); &#125; System.out.println(); // 원하는 위치에 요소 삽입 lnkList.set(2, \"둘\"); for (String e : lnkList) &#123; System.out.print(e + \" \"); &#125; System.out.println(); // size() 메소드를 이용한 요소의 총 개수 System.out.println(\"리스트의 크기 : \" + lnkList.size()); &#125;&#125;// 결과넷 둘 셋 하나 넷 셋 하나 넷 셋 둘 리스트의 크기 : 3 Vector ArrayList와 동일하게 사용이 가능합니다. ArrayList와 Vector의 차이점은 Stringbuilder와 StringBuffer의 차이로 이해할 수 있습니다. 한 데이터에 동시접속이 발생했을 때 처리 가능한 기능이 있나, 없나의 차이입니다. 동시접속을 고려하여 만들어진 리스트는 Vector입니다. ArrayList는 동시접속을 고려하지 않았지만, 그만큼 Vector보다 가볍다는 장점이 있습니다. 또한 웹에서 사용할 때 서버가 동시접속에 대한 처리를 해주기 때문에 ArrayList를 사용하면 됩니다. Vector는 현재 기존 코드와의 호환성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다. List 인터페이스 메소드 void add(int index, Object element) : 지정된 위치(index)에 객체(element)또는 컬렉션에 포함된 객체들을 추가합니다. Object get(int index) : 지정된 위치(index)에 있는 객체를 반환합니다. int indexOf(Object o) : 지정된 객체의 위치(index)를 반환합니다. (List의 첫 번째 요소부터 순방향으로 찾습니다.) lastIndexOf(Object o) : 지정된 객체의 위치(indx)를 반환합니다. (List의 마지막 요소부터 역방향으로 찾습니다.) ListIterator listIterator() : List의 객체에 접근할 수 있는 ListIterator를 반환합니다. Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환합니다. Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장합니다. void sort(Comparator c) : 지정된 비교자(comparator)로 List를 정렬합니다. List subList(int formIndex, int toIndex) : 지정된 범위(formIndex부터 toIndex)에 있는 객체를 반환합니다. 참고 List와 ArrayList 이 둘의 차이는 무엇인가? 12List list1 = new ArrayList();ArrayList list2 = new ArrayList(); 예를 들어서 설명하면, 클래스를 생성할 때 도형 타입으로 생성하게 되면 정사각형이 아닌 다른 직사각형, 삼각형등 도형 인터페이스를 구현한 클래스에서 사용될 수 있습니다. 하지만, 정사각형타입으로 클래스르 생성하게 되면 직사각형, 삼각형등에서는 사용할 수 없습니다. 12345List list1 = new ArrayList(); // 도형 list = new 정사각형(); ArrayList list2 = new ArrayList(); // 정사각형 list = new 정사각형(); List는 인터페이스입니다. 인터페이스는 공통되는 메소드를 추출해 놓은 클래스입니다. Java Collection FrameWork Stack과 Queue 순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 비효율적입니다. 그래서 큐는 ArrayList보다는 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합합니다. Stack 스택이란 사전적으로는 더미, 쌓아 올림이라는 의미를 갖습니다. '더미’란 많은 물건이 모여서 쌓인 큰 덩어리를 의미합니다. 스택은 같은 타입의 자료를 하나 다음 하나라는 개념으로 순차적으로 저장하는 직선형 자료구조입니다. Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다. 스택은 한쪽이 막혀있고, 한쪽에서만 삽입이나 삭제가 가능합니다. 그러므로 가장 마지막 데이터의 위치에 대해 삽입이나 삭제가 발생하므로, 이러한 구조에 사용될 때 간단하며 더욱 효율적이고 쉽게 사용이 가능합니다. 또한 스택은 데이터를 쌓아올리는 형태로 데이터를 저장하여 추출할 때는 맨 위에 있는 데이터를 먼저 꺼내는 형태이기 때문에 제일 마지막에 저장한 데이터를 제일 먼저 꺼내는 후입선출(LIFO - Last In First Out) 형태라고도 합니다. Stack 용어 push : 스택에 자료를 넣는 연산 pop : 스택에 자료를 빼는 연산 top : 스택의 가장 위에 있는 자료를 보는 연산 bottom : 스택에 가장 먼저 입력된 데이터 empty : 스택이 비어있는지 아닌지를 알아보는 연산 size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산 스택은 top에서만 삽입, 삭제, 읽기 동작이 발생할 수 있습니다. top은 데이터의 수에 따라 유동적으로 변하며 데이터가 하나 삽입될 경우 하나 증가하고 데이터가 하나 삭제될 경우 하나 감소하도록 작성됩니다. 스택의 경우에는 순차적으로 데이터를 추가하고 삭제하므로 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합합니다. Stack 메소드 boolean empty() : Stack이 비어있는지 알려줍니다. Object peek() : Stack의 맨 위에(top) 저장된 객체를 반환, pop()과 달리 Stack에서 객체를 꺼내지 않습니다. 단지 보기만 합니다. Object pop() : Stack의 맨 위에 저장된 객체를 꺼냅니다. Object push(Object item) : Stack에 객체(item)를 저장합니다. int search(Object o) : 해당 Stack에서 전달된 객체가 존재하는 위치의 인덱스를 반환합니다. 이 때, 인덱스는 제일 상단에 있는(제일 마지막으로 저장된)요소의 위치부터 0이 아닌 1부터 시작하게 됩니다. clear() : Stack에 존재하는 모든 자료들을 삭제합니다. 사용방법 123456789101112131415161718192021222324252627282930313233343536373839// 스택 객체 stack 생성Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 데이터 입력stack.push(5);stack.push(4);stack.push(3);stack.push(2);stack.push(1);// 스택의 사이즈System.out.println(\"스택 크기 : \"+stack.size());System.out.println(\"마지막에 넣은 데이터부터 출력..\");// 가장 최근에 넣은 데이터부터 추출System.out.println(stack.pop());System.out.println(stack.pop());System.out.println(stack.pop());System.out.println(stack.pop());System.out.println(stack.pop()); System.out.println(\"-----------\"); stack.push(5);stack.push(4);stack.push(3); System.out.println(\"스택크기: \"+stack.size());// 데이터를 빼지 않고 현재 가장 위에 위치하는 데이터를 확인System.out.println(stack.peek());// 사이즈 확인System.out.println(\"스택 크기 : \"+stack.size());// System.out.println(stack.search(3));System.out.println(stack.search(4));System.out.println(stack.search(5)); 123456789101112131415결과스택 크기 : 5마지막에 넣은 데이터부터 출력..12345-----------스택크기: 33스택 크기 : 3123 더욱 복잡하고 빠른 스택을 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다. 단, Stack 클래스와는 달리 search() 메소드를 지원하지 않습니다. 1Deque&lt;Integer&gt; st = new ArrayDeque&lt;Integer&gt;(); 스택의 활용 사례 Operating Systems 프로그램에서 불러지는 함수(Method)들을 모두 Stack이라는 자료형에 저장합니다. Compilers(컴파일러) 컴파일러에서 수학기호들으 기계어(Machine Code)로 변환시, 괄호들을 매칭하거나 할 때 JVM(Java Virtual Machine) - 자바 가상 머신 자바 프로그램이 실행될 때 사용되는 JVM에서도 스택은 사용됩니다. 각각의 스레드는 1개의 스택을 가지고 모든 메소드들을 트랙킹합니다. 새로운 메소드들이 호출될 때마다, 새로운 프레임이 스택에 삽입되고, 메소드가 끝날 때 마다 스택에서 제거됩니다. Queue 큐는 줄이라는 의미를 가지고 있습니다. 큐(Queue)에서 데이터의 제거는 대기 줄의 가장 앞에서 수행되며 데이터의 삽입은 대기 줄의 가장 뒤에서 수행이 되는 제한된 리스트 구조를 말하며 가장 먼저 삽입된 데이터가 가장 먼저 제거되는 선입선출(FIFO-First In First Out) 형태의 자료구조입니다. 가장 오래전에 입력된 데이터를 front라고 하면 가장 최근에 입력된 데이터를 rear라고 합니다. 데이터의 삽입은 rear에서 이루어지고 삭제는 front에서 이루어지기 때문에 큐를 구현하기 위해서는 front와 rear를 관리하는 배열을 이용하거나 front노드와 rear노드를 관리하는 연결 리스트를 이용할 수 있습니다. 자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있지만 큐는 Queue 인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있진 않습니다. 대신 Queue 인터페이스를 구현한 클래스들이 있어서 이들 중의 하나를 선택해서 사용하면 됩니다. 따라서 Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많습니다. 그 중에서도 Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됩니다. 그리고 Queue는 타입이 될 수 없습니다. 123Queue&lt;Integer&gt; q = new Queue&lt;Integer&gt;();// 이렇게 선언이 되지 않고Queue&lt;Integer&gt; q1 = new LinkedList&lt;Integer&gt;(); Queue의 동작 삽입 - offer,add 큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다. add : 큐의 뒤 쪽(rear)에 데이터를 삽입합니다. push : 큐의 앞 쪽(front)에 데이터를 삽입합니다. 제거 - pop,remove 큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다. poll은 큐가 비어있다면 null을 반환 remove는 큐가 비어있다면 예외 발생 읽기 - peek,element 큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다. peek은 큐가 비어있다면 null을 반환 element은 큐가 비어있다면 예외 발생 peekFirst()는 Queue에 가장 먼저 들어온 데이터 즉, front에 있는 데이터를 보여줍니다. peekLast()는 Queue에 가장 나중에 들어온 데이터 즉, rear에 있는 데이터를 보여줍니다. 사용 1234567891011121314151617181920212223242526272829303132import java.util.LinkedList;public class queue &#123; public static void main(String[] args)&#123; LinkedList&lt;String&gt; queue = new LinkedList&lt;&gt;(); // add() 메소드를 이용한 요소의 저장 queue.add(\"하나\"); queue.add(\"둘\"); queue.add(\"셋\"); queue.add(\"넷\"); // element() 메소드를 이용한 요소의 반환 System.out.println(\"element() 메소드 사용 : \"+queue.element()); // peek() 메소드를 이용한 요소의 반환 System.out.println(\"peek() 메소드 사용 : \"+queue.peek()+\"\\n\"); // peekFirst() 메소드는 큐의 맨 위의 요소를 반환 즉, 가장 처음에 삽입된 요소를 반환 System.out.println(\"Queue의 첫 번째 요소 : \"+queue.peekFirst()); // peekLast() 메소드는 큐의 맨 마지막 요소를 반환 즉, 마지막에 삽입된 요소 반환 System.out.println(\"Queue의 마지막 요소 : \"+queue.peekLast()+\"\\n\"); System.out.println(queue); // poll() 메소드를 사용한 요소의 삭제 System.out.println(\"삭제한 요소 : \"+queue.poll()); System.out.println(queue+\"\\n\"); // remove() 메소드를 사용한 요소의 삭제 System.out.println(\"삭제한 요소 : \"+queue.remove()); System.out.println(queue+\"\\n\"); &#125;&#125; 12345678910111213결과element() 메소드 사용 : 하나peek() 메소드 사용 : 하나Queue의 첫 번째 요소 : 하나Queue의 마지막 요소 : 넷[하나, 둘, 셋, 넷]삭제한 요소 : 하나[둘, 셋, 넷]삭제한 요소 : 둘[셋, 넷] 큐 구현 클래스 1. PriorityQueue Queue 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있습니다. 그리고 null은 저장할 수 없습니다. PIPO(Priority-in, Priority Out) 2. PriorityBlockingQueue -&gt; Priority Queue의 동기화된 버전 -&gt; 동기화 메소드 보유 -&gt; PriorityQueue보다 느린 속도 -&gt; null 요소를 허용하지 않음 3. LinkedList -&gt; 끝에 요소를 추가하는 것이 용이 -&gt; List 인터페이스 구현 -&gt; 요소에 null 허용 4. Deque(Double-Ended Queue) -&gt; Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, Deque은 양쪽 끝에 추가/삭제가 가능합니다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있습니다. 문제 : https://www.acmicpc.net/problem/10866 Deque의 사용법 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); int test_case = Integer.parseInt(bf.readLine()); for(int i=0;i&lt;test_case;i++)&#123; StringTokenizer st = new StringTokenizer(bf.readLine(), \" \"); String command = st.nextToken(); int num = 0; switch (command)&#123; // first, front, 앞 쪽에 데이터를 삽입 // 가장 먼저 삽입된 것처럼 할 수 있음 // push() 메소드도 동일하게 동작 case \"push_front\": num = Integer.parseInt(st.nextToken()); deque.addFirst(num); break; // last, rear, 뒤 쪽에 데이터를 삽입 // 가장 나중에 삽입된 것처럼 할 수 있음 // add() 메소드도 동일하게 동작 case \"push_back\": num = Integer.parseInt(st.nextToken()); deque.addLast(num); break; case \"pop_front\": // 덱이 비어있는지 확인할 수 있음 if(deque.isEmpty())&#123; System.out.println(-1); &#125;else&#123; // 덱의 가장 앞쪽의 데이터를 삭제 // 어떻게 보면 가장 먼저 삽입된 데이터를 삭제 System.out.println((deque.removeFirst())); &#125; break; case \"pop_back\": if(deque.isEmpty())&#123; System.out.println(-1); &#125;else&#123; // 덱의 가장 뒤쪽의 데이터를 삭제 // 어떻게 보면 가장 나중에 삽입된 데이터를 삭제 System.out.println((deque.removeLast())); &#125; break; case \"size\": // 덱의 사이즈를 확인 System.out.println(deque.size()); break; case \"empty\": if(deque.isEmpty())&#123; System.out.println(1); &#125;else &#123; System.out.println(0); &#125; break; case \"front\": if(deque.isEmpty())&#123; System.out.println(-1); &#125;else &#123; // 덱에서 가장 앞쪽의 데이터를 확인(first, front) System.out.println(deque.peekFirst()); &#125; break; case \"back\": if(deque.isEmpty())&#123; System.out.println(-1); &#125;else &#123; // 덱의 가장 뒤쪽의 데이터를 확인(last, rear) System.out.println(deque.peekLast()); &#125; break; &#125; &#125; &#125;&#125; Java SE 6부터 지원되는 ArrayDeque 클래스는 스택과 큐 메모리 구조를 모두 구현하는데 가장 적합한 클래스입니다. Vector 클래스 List 인터페이스를 구현한 클래스이며, java.util.Vector에 있습니다. 그리고 아래와 같은 특징을 갖습니다. 객체들을 삽입, 삭제, 검색할 수 있는 컨테이너 클래스입니다. 배열의 길이 제한 단점을 극복할 수 있습니다. 삽입되는 객체의 수가 많아지면 자동으로 크기가 조절됩니다. 아이템을 벡터의 맨 마지막이나 중간에 삽입할 수 있습니다. 벡터 맨 뒤에 객체 추가 : 벡터 공간이 모자라면 자동으로 늘림 벡터 중간에 객체 삽입 : 뒤에 존재하던 객체는 한칸씩 뒤로 이동 임의의 위치에 있는 객체 삭제 : 객체 삭제 후 한칸씩 앞으로 자동으로 이동 사용방법 위의 그림은 벡터 객체 내부의 구조와 add(),get() 메소드를 이용하여 객체를 다루는 모습을 보여주고 있습니다. 벡터에는 String,Integer,Person등의 다양한 타입의 객체가 삽입 가능합니다. 벡터 내부에 삽입된 요소들은 인덱스로 관리하며 인덱스는 0부터 시작합니다. add()메소드를 이용하여 객체를 삽입하고, get()메소드를 이용하여 인덱스에 해당하는 객체를 얻습니다. 벡터의 생성 12Vector v = new Vector();Vector&lt;String&gt; v2 = new Vector&lt;String&gt;(3); v는 어떠한 타입이라도 담을 수 있습니다. v2는 Vector 객체에 String 객체를 담을 수 있으며, 용량은 3이며 size가 용량을 초과했을 때, 3의 크기만큼 증가합니다. (매개변수를 지정하지 않았을 경우에는 기본 용량:10,증가 용량:10) 벡터에 요소 삽입 벡터에 삽입할 수 있는 요소는 Object를 상속받은 모든 종류의 객체들이 가능하며 다음과 같이 벡터에 요소를 삽입할 수 있습니다. 1234567891011v.add(\"Hello\");v.add(new Integer(4));v.add(new Person());v2.addElement(\"이승우\");v2.addElement(\"정지현\");v2.addElement(\"탁형민\");v2.addElement(\"홍주영\");v.add(1); // int형 데이터(Integer 타입으로 전환되어 벡터에 저장)v.add('r'); // char형 데이터(Character 타입으로 전환되어 벡터에 저장)v.add(3.14); // double형 데이터(Double 타입으로 전환되어 저장) add() 메소드는 요소를 벡터의 맨 뒤에 삽입합니다. v2에는 addElement() 메소드를 이용해서 String 객체를 담을 수 있습니다. 자바에서 제공하는 기본 타입 역시 벡터에 삽입할 수 있습니다. 벡터 내의 객체 알아내기 벡터 내에 존재하는 요소 객체를 알아내기 위해서는 get(), elementAt()등의 메소드를 이용합니다. 12Integer obj = (Integer)v.get(1); // 벡터의 1번째 요소를 Integer 타입으로 형 변환int i = obj.intValue(); // obj에 있는 정수를 알아냅니다. 값은 4 벡터의 용량과 개수 알아내기 1234int n = v.size(); // 4int c = v.capacity(); // 10int n2 = v2.size(); // 4int c2 = v2.capacity(); // 6 벡터의 크기(size) : 벡터에 들어 있는 요소의 개수 벡터의 용량(capacity) : 요소를 수용할 수 있는 크기[벡터는 자동으로 조절 가능] 요소 객체 중간에 삽입하기 벡터에 있는 데이터는 인덱스로 관리할 수 있기 때문에, 인덱스 값을 이용해서 중간에 객체 삽입이 가능합니다. 1v.add(2,\"Sahni\"); 벡터 v 내의 인덱스가 2인 위치에 “Shani” 삽입하였으며, 아래 그림과 같은 구조를 가지게 됩니다. 벡터에서 요소 삭제 remove() : 벡터 내에 임의의 인덱스에 있는 요소를 삭제할 수 있습니다. 1v.remove(1); // 정수 4가 삭제됨 벡터에서 모든 요소 삭제하기 removeAllElements() : 벡터 내에 존재하는 모든 요소를 한번에 삭제할 수 있습니다. 1v.removeAllElements(); // 벡터 내 모든 요소 삭제 벡터 클래스의 주요 메소드 벡터 생성자 정렬 자바에서 정렬하기 위해 사용하는 Comparable과 Comparator를 공부해보았습니다 Comparator와 Comparable은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메소드를 정의하고 있으며, Comparable을 구현하고 있는 클래스들은 같은 타입의 인터페이스끼리 서로 비교할 수 있는 클래스들(주로 Wrapper 클래스)이 있으며, 기본적으로 오름차순으로 구현되어 있습니다. 그래서 Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미합니다. 배열이나 Collection프레임워크 등에서 sort()를 사용하면 컴퓨터에서 알아서 정렬을 해줍니다. 여기서 사용되는 sort()는 Comparable 구현에 의한 정렬이고, Comparable과 Comparator에 대해서 공부해보았습니다. 먼저 Arrays 클래스에서 제공하는 sort() 메소드를 이용해서 배열을 정렬하는 예입니다. Arrays.sort() 1234567891011121314151617181920String[] sports=&#123;\"Soccer\",\"Baseball\",\"Tennis\",\"Football\",\"Basketball\",\"Ski\",\"Hockey\",\"Aerobics\"&#125;; // 영어String[] names=&#123;\"하정우\",\"장동건\",\"김수현\",\"박보검\",\"송중기\",\"송승헌\",\"조승우\",\"조정석\",\"강동원\",\"김우빈\",\"박서준\"&#125;; // 한글 Arrays.sort(sports);Arrays.sort(names); for(int i=0;i&lt;sports.length;i++)&#123; System.out.print(sports[i]+\" \");&#125; System.out.print(\"\\n\"); for(int j=0;j&lt;names.length;j++)&#123; System.out.print(names[j]+\" \");&#125;// 결과Aerobics Baseball Basketball Football Hockey Ski Soccer Tennis 강동원 김수현 김우빈 박보검 박서준 송승헌 송중기 장동건 조승우 조정석 하정우 먼저, Arryays.sort()의 동작을 확인하였습니다. String 타입의 배열을 2개 만들었고, Arrays.sort()를 통해 정렬을 수행하였습니다. 영어는 ABC 순서대로, 한글은 가나다 순서대로 정렬이 된 것을 확인할 수 있습니다. 영어의 경우 같은 알파벳으로 시작하는 단어들도 정확하게 정렬이 되었습니다. 여기서 Arrays.sort(sports),Arryas.sort(names)는 String의 Comparable구현에 의해 정렬된 것이다. Comparable을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, String, Integer, Date, File등과 같은 것들입니다. 그리고 기본적으로는 작은 값에서 큰 값의 순서, 오름차순 형태로 구현되도록 만들어져 있습니다. Collections.sort() 1234567891011121314151617List&lt;String&gt; sportsList = new ArrayList&lt;String&gt;(); sportsList.add(\"Soccer\");sportsList.add(\"Baseball\");sportsList.add(\"Tennis\");sportsList.add(\"Football\");sportsList.add(\"Basktball\");sportsList.add(\"Ski\");sportsList.add(\"Hockey\");sportsList.add(\"Aerobics\"); Collections.sort(sportsList); Iterator it = sportsList.iterator();while(it.hasNext())&#123; System.out.print(it.next()+\" \");&#125; 이번에는 배열이 아닌 ArrayList의 형태로 sort()를 사용해보았다. 위에서 사용했던 방식과 똑같지만, String 타입의 배열을 ArrayList로 바꿨습니다. 여기서는 Arrays.sort()가 아니라 Collections.sort()를 적용해야 합니다. Comparable 인터페이스 Comparable 인터페이스는 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드를 정의하고 있습니다. 자바에서 같은 타입의 인스턴스를 서로 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있습니다. 따라서 Boolean을 제외한 래퍼 클래스나 String, Time, Date와 같은 클래스의 인스턴스는 모두 정렬 가능합니다. 이 때 기본 정렬 순서는 작은 값에서 큰 값으로 정렬되는 오름차순이 됩니다. 이제부터는 기본 정렬기준이 아닌 다른 정렬기준으로 시도해보겠습니다. 축구선수를 뜻하는 SoccerPlayer라는 클래스를 하나 만들고, 축구선수의 객체배열을 이용해 sort를 해보려고 합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.ArrayList;import java.util.Collections;class Cars implements Comparable&lt;Cars&gt;&#123; private String modelName; private String color; private int modelYear; public Cars(String modelName, String color, int modelYear)&#123; this.modelName = modelName; this.modelYear = modelYear; this.color = color; &#125; public String getModel()&#123; return this.modelYear+\"식\"+this.modelName+\" \"+this.color; &#125; public String getModelName() &#123; return modelName; &#125; public void setModelName(String modelName) &#123; this.modelName = modelName; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public int getModelYear() &#123; return modelYear; &#125; public void setModelYear(int modelYear) &#123; this.modelYear = modelYear; &#125; @Override public int compareTo(Cars obj) &#123; if(this.modelYear &gt;obj.modelYear)&#123; return 1; &#125; else if(this.modelYear &lt; obj.modelYear)&#123; return -1; &#125; else &#123; return 0; &#125; &#125;&#125;public class arraysExam &#123; public static void main(String[] args)&#123; ArrayList&lt;Cars&gt; list = new ArrayList&lt;&gt;(); Cars cars1 = new Cars(\"아반떼\",\"Black\",2016); Cars cars2 = new Cars(\"소나타\",\"White\",2018); Cars cars3 = new Cars(\"그랜져\",\"Brown\",2002); Cars cars4 = new Cars(\"벤츠\",\"Yellow\",2009); list.add(cars1); list.add(cars2); list.add(cars3); list.add(cars4); Collections.sort(list); for(int i=0;i&lt;list.size();i++)&#123; System.out.println(list.get(i).getModelYear()); &#125; &#125;&#125;// 결과2002200920162018 Cars는 자동차 모델의 이름과 연식, 색상을 속성으로 가지고 각각 setter와 getter를 선언해주었습니다. 위의 경우와 동일하게 Arrays.sort(), Collections.sort()는 작동하지 않고 오류가 발생합니다. 이유는 정렬을 시도했지만, 객체 내의 어떤 변수를 기준으로 정렬할 지 정하지 않았기 때문입니다. String 타입의 배열이나 ArrayList는 값이 하나지만, 객체를 정렬할 경우 객체 내의 어떤 변수로 정렬할지 기준을 만들어줘야 합니다. Comparable을 implements한 뒤 comparaTo메소드를 구현하면 해결할 수 있습니다. [오름차순만 가능] Cars 클래스에서 Comparable&lt;Cars&gt;를 implements 하였습니다. 그리고 하단에 compareTo() 메소드를 오버라이드하여 코드를 추가했습니다. 매개변수로 Cars 객체를 받고 리턴값으로는 객체의 이름을 비교하는 구문을 넣어주었습니다. 여기서 본인이 정렬하고자 하는 클래스를 Comparable&lt;클래스명&gt; 형태로 넣어주는 것을 잊어서는 안됩니다. 이 경우에 정렬하고자 하는 클래스는 Cars라는 클래스! 자동차 객체를 4개 만들어서 ArrayList에 추가하였습니다. 그리고 Collections.sort()를 이용해 정렬을 시도하니 가나다 연식 순서로 정렬되어 나오는 결과를 확인할 수 있었습니다. 바로 Cars 클래스에서 Comparable을 implements하였고, 하단에 compareTo를 Override하며 연식 비교 코드를 만들어주었기 때문입니다. 이 부분을 연식이 아닌 자동차 모델 이름으로 바꿀 수 있습니다. Comparator 인터페이스 Comparable을 implements 하지 않고도 오브젝트의 특정 변수를 기준으로 정렬하는 방법이 있습니다. 이 때 사용하는 방법이 바로 Comparator입니다. Comparator를 사용하면 정렬 기준을 본인이 원하는대로 바꾸는 것이 가능합니다.[오름차순, 내림차순 가능]. 주로 객체의 특정 변수를 기준으로 정렬할 때 주로 이용합니다. 이 때 Comparator 인터페이스를 구현한 클래스에서는 compare() 메소드를 재정의하여 사용하게 됩니다. 다음 예제는 SoccerPlayer라는 클래스의 객체를 Comparator 인터페이스를 통해 원하는 기준으로 정렬하는 예제입니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;class Cars &#123; private String modelName; private String color; private int modelYear; public Cars(String modelName, String color, int modelYear) &#123; this.modelName = modelName; this.modelYear = modelYear; this.color = color; &#125; public String getModel() &#123; return this.modelYear + \"식\" + this.modelName + \" \" + this.color; &#125; public String getModelName() &#123; return modelName; &#125; public void setModelName(String modelName) &#123; this.modelName = modelName; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public int getModelYear() &#123; return modelYear; &#125; public void setModelYear(int modelYear) &#123; this.modelYear = modelYear; &#125;&#125;public class arraysExam &#123; public static void main(String[] args) &#123; ArrayList&lt;Cars&gt; list = new ArrayList&lt;&gt;(); Cars cars1 = new Cars(\"아반떼\", \"Black\", 2016); Cars cars2 = new Cars(\"소나타\", \"White\", 2018); Cars cars3 = new Cars(\"그랜져\", \"Brown\", 2002); Cars cars4 = new Cars(\"벤츠\", \"Yellow\", 2009); list.add(cars1); list.add(cars2); list.add(cars3); list.add(cars4); // 자동차 연식을 기준으로 내림차순 정렬 Collections.sort(list, new Comparator&lt;Cars&gt;() &#123; @Override public int compare(Cars o1, Cars o2) &#123; if (o1.getModelYear() &gt; o2.getModelYear()) &#123; return -1; &#125; else if (o1.getModelYear() &lt; o2.getModelYear()) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; &#125;); System.out.println(\"내림 차순 정렬\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i).getModelYear()); &#125; System.out.println(); // 자동차 연식을 기준으로 오름차순 정렬(원래 방식) Collections.sort(list, new Comparator&lt;Cars&gt;() &#123; @Override public int compare(Cars o1, Cars o2) &#123; if (o1.getModelYear() &gt; o2.getModelYear()) &#123; return 1; &#125; else if (o1.getModelYear() &lt; o2.getModelYear()) &#123; return -1; &#125; else &#123; return 0; &#125; &#125; &#125;); System.out.println(\"오름 차순 정렬\"); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i).getModelYear()); &#125; &#125;&#125;// 결과내림 차순 정렬2018201620092002오름 차순 정렬2002200920162018 SoccerPlayer 클래스에 Comparable을 implements하지 않은 상태로 Main에 Collections.sort()를 만들었습니다. 여기서는 Collections.sort(playerList,new Comparator&lt;SoccerPlayer&gt;(){..}형태로 구현해야 하며, 내부에 있는 compare() 메소드에서 객체의 어떤 필드를 기준으로 졍렬할 지 정해주면 도비니다. 자동차 클래스의 연식을 기준으로 오름차순과 내림차순으로 구현했습니다. 결론 Comparable 구현 후 내부의 compareTo 메소드를 오버라이드해서 정의해야 하는데, 이 정의 결과에 따라 정렬 값이 나옵니다. 또한, 오브젝트의 다른 값으로 비교를 원한다면 compareTo를 하나하나 바꿔줄 필요 없이, Comparator를 이용하면 됩니다. Comparator의 compare()와 Comparable의 compareTo()는 두 객체를 비교한다는 같은 기능을 목적으로 만들어 졌습니다. compareTo() 메소드는 반환값은 int지만 실제로는 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구혀해야 합니다. compare()도 객체를 비교해서 음수, 0, 양수 중 하나를 반환하도록 구현해야 합니다. Comparable - 기본 정렬 기준(오름차순)을 구현하는데 사용 Comparator - 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용 Collections.sort() , Arrays.sort() 등 ~~.sort()는 배열이나 리스트를 정렬할 때 Comparator를 지정하지 않았을 경우 Comprarable을 구현하면 구현한 클래스의 객체에 구현된 내용에 따라 정렬!! Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬됩니다. 12static void sort(Object[] a) // 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬static void sort(Object[] a, Comparator c) // 지정한 Comparator에 의한 정렬 다음과 같은 함수들도 존재합니다. Arrays.sort() Arrays.reverse() Collections.sort() Collections.reverse() Set 특징 순서가 없습니다. 집합이므로 중복된 데이터가 들어갈 수 없습니다. 중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용합니다. Collection의 일부인데 중복되는 element를 포함하지 않는 것이 가장 큰 특징이며, 집합을 의미합니다. Set인터페이스는 Collection를 상속받아서 만들어진 인터페이스입니다. 때문에 대부분의 함수들이 Collection에서 제공하는 함수들과 동일합니다. List와 Set은 Collection 인터페이스를 구현한다는 점에서 비슷하다고 할 수 있습니다. 그러나 가장 큰 차이점은 중복에 대한 부분에서의 차이입니다. List는 같은 값에 대한 중복 추가가 가능합니다. 그러나 Set은 같은 값을 넣었을 때 size()로 내부 엘리먼트의 개수를 출력해보면 1이 나오는 것을 확인할 수 있습니다. 즉, 값(value)에 대한 중복을 허용하지 않습니다. 대표적인 Set 컬렉션 클래스에 속하는 클래스는 다음과 같습니다. HashSet TreeSet HashSet 클래스 HashSet 클래스는 Set 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. JDK 1.2부터 제공된 HashSet 클래스는 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠릅니다. 이러한 HashSet 클래스는 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다. HashSet 클래스는 Set 인터페이스를 구현하므로, 요소를 순서에 상관없이 저장하고, 중복된 값은 저장하지 않습니다. 만약 요소의 저장 순서를 유지해야 한다면 JDK 1.4부터 제공하는 LinkedHashSet 클래스를 사용하면 됩니다. 사용법 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.company;import java.util.HashSet;public class setExam &#123; public static void main(String[] args) &#123; HashSet&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;(); hs.add(1); hs.add(2); hs.add(3); hs.add(4); hs.add(5); // 1번 System.out.println(hs.add(10)); System.out.println(hs.add(10)); HashSet&lt;Integer&gt; hs2 = new HashSet&lt;Integer&gt;(); hs2.add(3); hs2.add(4); hs2.add(5); hs2.add(6); hs2.add(7); // 교집합을 구하기 위해서는 retainAll()이라는 메소드를 사용합니다. hs.retainAll(hs2); System.out.println(\"교집합 : \" + hs.toString()); // 집합 hs2는 hs의 부분집합이다. // 이것이 맞는지 알아보기 위해서는 containsAll()을 사용하면 된다. System.out.println(hs.containsAll(hs2)); // 차집합을 구하기 위해서는 removeAll()이라는 메소드를 사용합니다 // 집합 hs와 집합 hs2에서 집합 hs의 값들 중에서 집합 hs2에도 있는 값을 // 뺀 값들이 나옵니다. hs.removeAll(hs2); System.out.println(\"차집합: \" + hs.toString()); // 합집합을 구하기 위해서는 addAll()이라는 메소드를 사용하면 됩니다. hs.addAll(hs2); System.out.println(\"합집합 : \" + hs.toString()); &#125;&#125; containsAll() : 부분집합임을 알아보기 위해서 사용 addAll() : 합집합을 구하기 위해서 사용[합집합으로 합쳐집니다.] removeAll() : 차집합을 구하기 위해서 사용[hs에서 hs2를 뺀 부분을 보여줍니다.] retainAll() : 교집합을 구하기 위해서 사용[두 집합 중 공통된 값을 뽑아냅니다.] 1번에서와 같이 add() 메소드를 사용하여 해당 HashSet에 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false를 반환하는 것을 볼 수 있습니다. 이때 해당 HashSet에 이미 존재하는 요소인지를 파악하기 위해서는 내부적으로 다음과 같은 과정을 거치게 됩니다. 해당 요소에서 hasCode() 메소드를 호출하여 반환된 해시값으로 검색할 범위를 결정합니다. 해당 범위 내의 요소들을 equals() 메소드로 비교합니다. 따라서 HashSet에서 add() 메소드를 사용하여 중복 없이 새로운 요소를 추가하기 위해서는 hashCode()와 equals() 메소드를 상황에 맞게 오버라이딩해야 합니다. 오버라이딩을 통해 작성된 hashCode()는 다음의 세 가지 조건을 만족 시켜야 합니다. 실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int 값을 반환해야 합니다. 하지만, 실행 시마다 동일한 int값을 반환할 필요는 없습니다. (String 클래스는 문자열의 내용으로 해시코드를 만들어 내기 때문에 내용이 같은 문자열에 대한 hashCode() 호출은 항상 동일한 해키코드를 반환합니다. 반면에 Object 클래스는 객체의 주소로 해시코드를 만들어 내기 때문에 실행할 때마다 해시코드 값이 달라질 수 있습니다.) equals 메소드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 합니다. equals() 메소드를 호출했을 때 false를 반환하는 두 객체는 hashCode() 호출에 대해 같은 int 값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int 값을 반환하는 것이 좋습니다. 12345678910111213141516Set&lt;String&gt; hSet = new HashSet&lt;String&gt;(); hSet.add(\"자바\");hSet.add(\"서블릿\");hSet.add(\"스프링\");hSet.add(\"안드로이드\");hSet.add(\"자바\"); // 중복된 데이터// 사이즈는 4가 나옵니다. 중복을 제거함System.out.println(\"hSet의 개수:\"+hSet.size());// Iterator의 사용Iterator&lt;String&gt; it = hSet.iterator();while(it.hasNext())&#123; System.out.println(it.next());&#125; HashSet은 Iterator를 사용합니다. 이유는 set은 순서가 없기 때문에 데이터에 순서를 정해서 추출해야하기 때문입니다. 중복이 안되는 것을 생각하면 Hashtable이나 HashMap과 같은 Map 형태가 떠오를 수 있습니다. 그러나 다른 점이라면, Map에서는 형태를 가진다는 점이 가장 큰차이입니다. 중복을 검사하는 대상 자체가 Key,Value이기 때문에 Key를 기준으로 중복검사를 하게 됩니다. 이것은 중복되는 key 값을 가져서는 안되고, value는 중복되더라도 상관없다는 이야기입니다. TreeSet 클래스 TressSet 클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리(binary search three)의 형태로 요소를 저장합니다. 이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. JDK 1.2부터 제공되는 TreeSet 클래스는 NavigableSet 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현합니다. TreeSet 클래스는 Set 인터페이스를 구현하므로, 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장 순서를 유지하지도 않습니다. 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashSet;import java.util.Iterator;import java.util.TreeSet;public class setExam &#123; public static void main(String[] args) &#123; TreeSet&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(); // add() 메소드를 이용한 요소의 저장 treeSet.add(30); treeSet.add(40); treeSet.add(20); treeSet.add(10); // Enhanced for문을 이용한 요소의 출력 for (int e : treeSet) &#123; System.out.print(e + \" \"); &#125; // remove() 메소드를 이용한 요소의 제거 treeSet.remove(40); System.out.println(); // iterator() 메소드를 이용한 요소의 출력 Iterator&lt;Integer&gt; iterator = treeSet.iterator(); while (iterator.hasNext()) &#123; System.out.print(iterator.next() + \" \"); &#125; System.out.println(); // size() 메소드를 이용한 요소의 크기 출력 System.out.println(\"이진 검색 트리의 크기 : \" + treeSet.size()); // subSet() 메소드를 이용한 부분 집합의 출력 System.out.println(treeSet.subSet(10, 20)); // 1 System.out.println(treeSet.subSet(10, true, 20, true)); // 2 &#125;&#125; 123456결과10 20 30 40 10 20 30 이진 검색 트리의 크기 : 3[10][10, 20] 위의 예제처럼 TreeSet 인스턴스에 저장되는 요소들은 모두 정렬된 상태로 저장됩니다. 또한, 위에서 사용된 subSet() 메소드는 TreeSet() 인스턴스에 저장되는 요소가 모두 정렬된 상태이기에 동작이 가능한 해당 트리의 부분 집합만을 보여주는 메소드입니다. 1번 라인에서 사용된 subSet() 메소드는 첫 번째 매개변수로 전달된 값에 해당하는 요소부터 시작하여 두 번째 매개변수로 전달된 값에 해당하는 요소의 바로 직전 요소까지를 반환합니다. 2번 라인에서 사용된 subSet() 메소드는 두 번째와 네 번째 매개변수로 각각 첫 번째와 세 번째 매개변수로 전달된 값에 해당하는 요소를 포함할 것인지 아닌지를 명시할 수 있습니다. 즉, 2번 라인에서 네 번째 매개변수를 false로 변경하면 20을 포함하지 않게 되므로, 1번 라인과 같은 결과를 출력할 것입니다. Set을 정렬하는 방법 Set은 중복 없이 값을 넣기 위한 객체입니다. 여기서는 List를 사용해서 Set을 정렬할 수 있습니다. 이 방법을 이용해서 공부해보고 사용해보았습니다. 먼저, fruits의 객체가 있고, banana, apple, peach의 중복없는 값을 삽입합니다. 이렇게 삽입한 Set을 정렬하기 위해서는 fruits의 객체를 List로 변환을 해야합니다. 변환하는 방법은 ArrayList를 만드는 방식과 동일하고 생성자에 fruits를 넣어주면 리스트 형태로 변환이 됩니다. 여기서 공부했던 것을 떠올려보면 List를 정렬하기 위해서는 Collections를 사용하면 됩니다!!! 123456789101112131415161718Set fruits = new HashSet();fruits.add(\"banana\"):fruits.add(\"apple\"):fruits.add(\"peach\"):// Set을 List로 변환List fruitsList = new ArrayList(fruits);// List 정렬Collections.sort(fruitsList);for(String s : fruitsList)&#123; System.out.println(s);&#125;// 결과applebananapeach Set 인터페이스 Set 인터페이스는 Collection 인터페이스를 상속받으므로, Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있습니다. Set 인터페이스에서 제공하는 주요 메소드는 다음과 같습니다. Map Map 인터페이스는 Collection 인터페이스와는 다른 저장 방식을 가집니다. Map 인터페이스를 구현한 Map 컬렉션 클래스들은 키와 값을 하나의 쌍으로 저장하는 방식을 사용합니다. (key-value) 여기서 key란 실질적인 value를 찾기 위한 이름의 역할을 합니다. 특징 요소의 저장 순서를 유지하지 않습니다. key는 중복을 허용하지 않지만, 값의 중복은 허용합니다. 대표적인 Map 컬렉션 클래스에 속하는 클래스는 다음과 같습니다. HashMap&lt;K,V&gt; Hashtable&lt;K,V&gt; TreeMap&lt;K,V&gt; HashMap&lt;K,V&gt; Map 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. 그리고 JDK 1.2부터 제공된 HashMap 클래스는 해시 알고리즘을 사용하여 검색 속도가 매우 빠릅니다. HashMap 클래스는 Map 인터페이스를 구현하므로, Map의 특징인 키(Key)와 값(value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖고 있습니다. 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보입니다. 또한, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class setExam &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // put 메소드를 이용한 요소의 저장 map.put(\"십\", 10); map.put(\"삼십\", 30); map.put(\"사십\", 40); map.put(\"이백\", 200); map.put(\"십\",30); // 1 map.put(\"십\",1010); // ketSet()을 이용해서 해당 맵에 포함된 모든 키 값들을 하나의 집합(Set)으로 반환해줍니다. System.out.println(\"Map에 저장된 키들의 집합:\" + map.keySet()); System.out.println(); // get() 메소드는 해당 key에 맞는 value 값을 반환합니다. for (String key : map.keySet()) &#123; System.out.println(String.format(\"키: %s, 값: %s\", key, map.get(key))); &#125; // remove() 메소드를 이용한 요소 제거 System.out.println(\"remove : \"+map.remove(\"사십\")); System.out.println(); // iterator() 메소드와 get() 메소드를 이용한 요소의 출력 Iterator&lt;String&gt; keys = map.keySet().iterator(); while (keys.hasNext()) &#123; String key = keys.next(); System.out.println(\"키 : \" + key + \", \" + \"값 : \" + map.get(key)); &#125; // replace() 메소드를 이용한 요소의 수정 map.replace(\"이백\", 20); System.out.println(\"값을 수정 한 후 =&gt; \"+String.format(\"키 : %s, 값 : %s\",\"이백\",map.get(\"이백\"))); // 2 // map 사이즈 출력 System.out.println(\"Map의 크기 : \" + map.size()); &#125;&#125;// 결과Map에 저장된 키들의 집합:[이백, 삼십, 사십, 십]키: 이백, 값: 200키: 삼십, 값: 30키: 사십, 값: 40키: 십, 값: 1010remove : 40키 : 이백, 값 : 200키 : 삼십, 값 : 30키 : 십, 값 : 1010값을 수정 한 후 =&gt; 키 : 이백, 값 : 20Map의 크기 : 3 1번 라인에서와 같이 동일한 키 값으로 데이터를 저장하게 되면 가장 나중에 저장된 데이터가 반영됩니다. 자주 사용되는 for문인 Enhanced for문은 배열과 컬렉션 프레임워크에서 해당 인스턴스에 저장된 모든 요소를 순회해야 할 경우에 자주 사용됩니다. 특징 요소의 저장순서를 유지하지 않습니다. 메소드 V replace(K key, V value) : 해당 맵에서 전달된 키에 대응하는 값을 특정 값으로 대체 boolean replace(K key, V oldValue, V newV) : 해당 맵에서 특정 값에 대응하는 전달된 키의 값을 새로운 값으로 대체함 void clear() : Map의 모든 객체를 삭제한다. boolean containsKey(Object key) : 지정된 key객체와 일치하는 Map의 Key객체가 있는지 확인한다. boolean containsValue(Object value) : 지정된 value객체와 일치하는 Map의 Value객체가 있는지 확인한다. Set entrySet() : Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다. booelan equals(Object o) : 동일한 Map인지 비교한다. Object get(Object key) : 지정한 key객체에 대응하는 value객체를 찾아서 반환한다. int hashCode() : 해시코드를 반환한다. boolean isEmpty() : Map이 비어있는지 확인한다. Set keySet() : Map에 저장된 모든 Key객체를 반환한다. Object put(Object key, Object value) : Map에 value객체를 key객체에 연결(mapping)하여 저장한다. void putAll(Map t) : 지정된 Map의 모든 key-value 쌍을 추가한다. Object remove(Object key) : 지정한 key객체와 일치하는 key-value객체를 삭제한다. int size() : Map에 저장된 key-value 쌍의 개수를 반환한다. Collection values() : Map에 저장된 모든 value객체를 반환한다. V remove(Object key) : 해당 맵에서 전달된 키에 대응하는 매핑을 제거함. boolean remove(Object key, Object value) : 해당 맵에서 특정 값에 대응하는 특정 키의 매핑을 제거함. 자바 공식 문서에서는 키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술하고 있습니다. Map 인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환하고, 키(Key)는 중복을 허용하지 않기 때문에 Set 타입으로 반환합니다. 참고 123456789public class HashMap extends AbstractMap implements Map, Cloneable, Serializable &#123; transient Entry[] table; // Entry 타입의 배열 //... static class Entry implements Map.Entry &#123; // 내부 클래스 final Object key; Object value; //... &#125;&#125; HashMap은 Entry라는 내부 클래스를 다시 정의하고, 다시 Entry 타입의 배열을 선언하고 있습니다. 키(key)와 값(value)은 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직하기 때문입니다. HashMap은 키와 값을 각각 Object 타입으로 저장합니다. 즉 어떠한 객체도 저장할 수 있지만 키는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 합니다. Hashtable&lt;Key,Value&gt; Hashtable 클래스는 JDK 1.0부터 사용해 온 HashMap 클래스와 같은 동작을 하는 클래스입니다. 현재의 Hashtable 클래스는 HashMap 클래스와 마찬가지로 Map 인터페이스를 상속받습니다. 따라서 Hashtable 클래스에서 사용할 수 있는 메소드는 HashMap 클래스에서 사용할 수 있는 메소드와 거의 같습니다. 하지만 현재에는 기존 코드와의 호환성을 위해서만 남아있으므로, Hashtable 클래스보다는 HashMap 클래스를 사용하는 것이 좋습니다. TreeMap&lt;Key,Value&gt; TreeMap 클래스는 Key와 Value를 한 쌍으로 하는 데이터를 이진 검색 트리의 형태로 저장합니다. 이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 Red-Black Tree로 구현합니다. TreeMap 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class setExam &#123; public static void main(String[] args) &#123; TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;Integer, String&gt;(); // put() 메소드를 이용한 요소의 저장 tm.put(30, \"삼십\"); tm.put(10, \"십\"); tm.put(40, \"사십\"); tm.put(20, \"오십\"); // Enhanced for 문과 get() 메소드를 이용한 요소의 출력 System.out.println(\"맵에 저장된 키들의 집합 : \" + tm.keySet()); for (Integer key : tm.keySet()) &#123; System.out.println(String.format(\"키 : %s, 값 : %s\", key, tm.get(key))); &#125; System.out.println(); // remove() 메소드를 이용한 요소의 제거 tm.remove(40); // iterator() 메소드와 get() 메소드를 이용한 요소의 출력 Iterator&lt;Integer&gt; keys = tm.keySet().iterator(); while (keys.hasNext()) &#123; Integer key = keys.next(); System.out.println(String.format(\"키 : %s, 값 : %s\", key, tm.get(key))); &#125; System.out.println(); // replace() 메소드를 이용한 요소의 수정 tm.replace(20, \"twenty\"); for (Integer key : tm.keySet()) &#123; System.out.println(String.format(\"키 : %s, 값 : %s\", key, tm.get(key))); &#125; System.out.println(); // size() 메소드를 이용한 요소의 총 개수 System.out.println(\"맵의 크기 : \" + tm.size()); &#125;&#125;// 결과맵에 저장된 키들의 집합 : [10, 20, 30, 40]키 : 10, 값 : 십키 : 20, 값 : 오십키 : 30, 값 : 삼십키 : 40, 값 : 사십키 : 10, 값 : 십키 : 20, 값 : 오십키 : 30, 값 : 삼십키 : 10, 값 : 십키 : 20, 값 : twenty키 : 30, 값 : 삼십맵의 크기 : 3 위의 결과와 같이 TreeMap은 이진 검색 트리를 사용하므로 Map에 저장된 값들은 키(Key)를 기준으로 정렬된 형태로 데이터가 저장됩니다. Map.Entry 인터페이스 Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스입니다. 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스를 정의하는 것이 가능합니다. Map에 저장되는 key-value(Entry) 쌍으 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았습니다. boolean equals(Object o) : 동일한 Entry인지 비교합니다. Object getKey() : Entry의 key 객체를 반환합니다. Object getValue() : Entry의 value 객체를 반환합니다. int hashCode() : Entry의 해시코드를 반환합니다. Object setValue(Object value) : Entry의 value 객체를 지정된 객체로 바꿉니다. 해시 알고리즘(hash algorithm) 해시 알고리즘(hash algorithm)이란 해시 함수(hash function)를 사용하여 데이터를 해시 테이블(hash table)에 저장하고, 다시 그것을 검색하는 알고리즘입니다. 해시 함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있습니다. 자바에서 해시 알고리즘을 이용한 자료 구조는 위의 그림과 같이 배열과 연결 리스트로 구현됩니다. 저장할 데이터의 키 값을 해시 함수에 넣어 반환되는 값으로 배열의 인덱스를 구합니다. 그리고서 해당 인덱스에 저장된 연결 리스트에 데이터를 저장하게 됩니다. 예를 들어, 정수형 데이터를 길이가 10인 배열에 저장한다고 한다면 1,000,002를 검색하는 방법은 다음과 같을 수 있습니다. 1,000,002를 10으로 나눈 나머지가 2이므로 배열의 세 번째 요소에 연결된 연결 리스트에서 검색을 시작합니다. 매우 간략화한 예제이지만, 이렇게 해시 알고리즘을 이용하면 매우 빠르게 검색 작업을 수행할 수 있습니다. 저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 됩니다. 검색하고자 하는 값의 키로 해시함수를 호출합니다. 해시함수의 계산결괴인 해시코드를 이용해서 해당 값이 저장되어 있는 링크드 리스트를 찾습니다. 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾습니다. 링크드 리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 됩니다. 하나의 링크드 리스트에 최소한의 데이터만 저장되려면, 저장될 데이터의 크기를 고려해서 HashMap의 크기를 적절하게 지정해주어야 하고, 해시 함수가 서로 다른 키에 대해서 중복된 해시코드의 반환을 최소화해야 합니다. 그래야 HashMap에서 빠른 검색시간을 얻을 수 있습니다. 실제로는 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object 클래스에서 정의된 hashCode()를 해시함수로 사용합니다. Object 클래스에 정의된 hashCode()는 각 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 hashCode()를 호출한 결과가 서로 다른 좋은 방법입니다. String 클래스의 경우 Object로부터 상속받은 hashCode()를 오버라이딩해서 문자열의 내용으로 해시코들 ㄹ만들어 냅니다. 그래서 서로 다른 String 인스턴스일지라도 같은 문자열을 가졌다면 hashCode()를 호출하면 같은 해시코드를 얻어냅니다. HashSet과 마찬가지로 HashMap에서도 서로 다른 두 객체에 대해 equals()로 비교한 결과가 true인 동시에 hashCode()의 반환값이 같아야 같은 객체로 인식합니다.(이미 존재하는 키에 대한 값을 저장하면 기존의 값을 새로운 값으로 덮어씁니다.) 그래서 새로운 클래스를 정의할 때 equals()를 오버라이딩해야 한다면 hashCode()도 같이 오버라이딩해서 equals()의 결과가 true인 두 객체의 해시코드가 항상 같도록 해주어야 합니다. 그렇지 않으면 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 equals()의 호출 결과가 true이지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장할 것입니다. Properties Properties는 HashMap의 구 버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키와 값을 (Object, Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 보다 단순한 컬렉션 클래스입니다. 주로 애플리케이션의 환경설정과 관련된 속성(property)을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공합니다. Iterator, ListIterator, Enumeration 위에서 공부를 하던 중에 컬렉션 프레임워크 중에서 List, Map, Set 등을 이용한 자료 구조에서 데이터에 접근하기 위해서는 가장 익숙한 for문을 사용해서 접근할 수 있습니다. for문을 사용하면 가장 간단하고 쉽게 접근할 수 있죠! 하지만, 내가 크기를 모른다면? 혹은 Set,Map과 같이 순서를 유지하지 않는다면 어떻게 접근할 수 있을까요?? 라는 의문에서 나온 것이 Iterator라고 생각합니다. Iterator, ListIterator, Enumeration은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스입니다. Enumeration은 Iterator의 구 버전이며, ListIterator는 Iterator의 기능을 향상 시킨 것 입니다. Iterator 컬렉션 프레임워크에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였습니다. 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고, Collection 인터페이스에는 Iterator를 반환하는 iterator() 함수를 정의하고 있습니다. iterator()는 Collection 인터페이스에 정의된 메소드이므로 Collection 인터페이스의 자손인 List와 Set에도 포함되어 있습니다. 그래서 List나 Set 인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있습니다. 추가적으로 Map에서도 iterator()를 사용할 수 있는데, 이는 Map의 키 집합을 반환하는 keySet() 함수는 Set을 반환하므로 iterator()를 사용할 수 있습니다. boolean hasNext() : 읽어 올 다음 요소가 남아있는지 확인합니다. 해당 이터레이션이 다음 요소를 가지고 있으면 true를 반환하고, 더 이상 다음 요소를 가지고 있지 않으면 false를 반환합니다. Object next() : 다음 요소를 읽어 옵니다. next()를 호춣하기 전에 hasNext()를 호출해서 읽어 올 요소가 남아있는지 확인하는 것이 안전합니다. void remove() : next()로 읽어 온 요소를 삭제합니다.(선택적 기능) 하지만 현재 자바에서는 될 수 있으면 JDK 1.5부터 추가된 Enhaced for문을 사용하도록 권장하고 있습니다. Enhanced for문을 사용하면 같은 성능을 유지하면서도 코드의 명확성을 확보하고 발생할 수 있는 버그를 예방해 줍니다. 하지만 요소의 선택적 제거나 대체 등을 수행하기 위한 경우에는 반복자(iterator)를 사용해야만 합니다. ListIterator와 Enumeration Enumeration은 컬렉션 프레임워크가 만들어지기 이전에 사용하던 것으로 Iterator의 구 버전이라고 생각하면 됩니다. ListIterator는 Iterator를 상속 받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있는데 반해 ListIterator는 양방향으로의 이동이 가능합니다. 다만, List 인터페이스를 구현한 컬렉션에서만 사용할 수 있습니다. 12345678910111213141516171819202122232425262728293031import java.util.*;public class setExam &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); list.add(4); list.add(2); list.add(9); list.add(1); ListIterator&lt;Integer&gt; iterator = list.listIterator(); System.out.println(\"순방향 접근\"); while (iterator.hasNext())&#123; System.out.print(iterator.next()+\" \"); &#125; System.out.println(); System.out.println(\"역방향 접근\"); while (iterator.hasPrevious())&#123; System.out.print(iterator.previous()+\" \"); &#125; &#125;&#125;// 결과순방향 접근4 2 9 1 역방향 접근1 9 2 4 Collections Arrays가 배열과 관련된 메소드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메소드를 제공합니다. fill(), copy(), sort(), binarySearch() 등의 메소드는 두 클래스에 포함되어 있으며 같은 기능을 합니다. 컬렉션의 동기화 멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 공유되는 객체의 동기화(synchrnization)가 필요합니다. Vector와 Hashtable과 같은 구버전(JDK 1.2 이전)의 클래스들은 자체적으로 동기화 처리가 되어 있는데, 멀티 쓰레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨리는 요인이 됩니다. 그래서 새로 추가된 ArrayList나 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 java.util.Collections 클래스의 동기화 메소드를 이용해서 동기화 처리가 가능하도록 변경하였습니다. 123456static Collection synchronizedCollection(Collection c)static List synchronizedList(List list)static Set synchronizedSet(Set s)static Map synchronizedMap(Map m)static SortedSet synchronizedSortedSet(SortedSet s)static SortedMap synchronizedSortedMap(SortedMap m) 변경불가 컬렉션 만들기 컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게 읽기 전용으로 만들어야 할 때가 있습니다. 123456static Collection unmodifiableCollection(Collection c)static List unmodifiableList(List list)static Set unmodifiableSet(Set s)static Map unmodifiableMap(Map m)static SortedSet unmodifiableSortedSet(SortedSet s)static SortedMap unmodifiableSortedMap(SortedMap m) 컬렉션 클래스 정리 &amp; 요약 ArrayList : 배열기반, 데이터의 추가와 삭제에 불리합니다. 순차적인 추가/삭제는 제일 빠르고 임의의 요소에 대한 접근성이 뛰어납니다. LinkedList : 연결기반, 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않습니다. HashMap : 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어나고, 검색에는 최고 성능을 보입니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":" [안드로이드] 4대 컴포넌트","slug":"Android-ActivityLifeCycle","date":"2018-03-02T04:35:59.000Z","updated":"2020-03-01T10:27:58.192Z","comments":true,"path":"2018/03/02/Android-ActivityLifeCycle/","link":"","permalink":"https://woovictory.github.io/2018/03/02/Android-ActivityLifeCycle/","excerpt":"","text":"이번에는 안드로이드의 4대 컴포넌트에 대해서 배워보았습니다. 안드로이드의 4대 컴포넌트 안드로이드의 앱은 컴포넌트(Component)로 구성되어 있으며 Activity, Service, Broadcast Receiver, Content Provider가 있다. 각 컴포넌트들은 하나의 독립된 형태로 존재하며, 정해진 역할을 수행한다. 그러면 이 컴포넌트들 간의 상호 통신은 어떻게 하는지 생각해볼 필요가 있다. 그것은 바로 Intent라는 일종의 메시지 객체를 사용하여 상호 통신을 진행한다. Activity(액티비티) 액티비티는 사용자 인터페이스 화면을 가지며 특정한 작업을 담당하는 컴포넌트 일반적으로 UI를 갖는 하나의 스크린을 나타냅니다. 안드로이드 애플리케이션은 반드시하나의 activity를 가지고 있어야 합니다. 각 액티비티는 매니페스트 파일에 등록되어 있어야 합니다. 하나 이상의 View를 가질 수 있습니다. Service(서비스) 서비스는 백그라운드에서 실행되는 컴포넌트로 오랫동안 실행되는 작업이나 원격 프로세스를 위한 작업을 할 때 사용됩니다. UI가 없습니다. 한번 시작된 Service는 애플리케이션이 종료되고 다른 애플리케이션으로 이동해도 계속 백그라운드에서 실행됩니다. 모든 서비스는 Service 클래스를 상속받아서 작성됩니다. 네트워크를 통하여 데이터를 꺼내 올 수도 있습니다. ex) 배경음악이나 안드로이드 사용량 모니터링, 주기적으로 특정 웹사이트에서 데이터를 읽어오는 것 등등 Broadcast Receiver(방송 수신자) 방송 수신자는 안드로이드 단말기에서 발생하는 다양한 이벤트/정보를 받고 반응하는 컴포넌트입니다. 단말기에서 발생하는 일 중에서 애플리케이션이 알아야 하는 상황이 발생하면 방송을 해줍니다. 수신기를 통해 상황을 감지하고 적절한 작업을 수행합니다. 일반적으로 UI가 없습니다. ex) 시스템 부팅, 배터리 부족, 전화/문자 수신, 네트워크 끊김을 알려주는 것 등등 Content Provider(콘텐트 제공자) 데이터를 관리하고 다른 애플리케이션 데이터를 제공하는 컴포넌트입니다. 데이터는 파일 시스템이나 SQLite 데이터베이스, 웹 상에 저장될 수 있습니다. 콘텐트 제공자를 통해서 다른 애플리케이션의 데이터를 쿼리하거나 변경 가능합니다. Intent(인텐트) 인텐트는 서로 독립적으로 동작하는 4가지 컴포넌트들의 상호 통신을 위한 장치입니다. 4대 컴포넌트의 통신 수단 인텐트를 통하여 다른 애플리케이션의 컴포넌트를 활성화 시킬 수 있습니다. Activity의 생명주기 onCreate() 액티비티가 만들어지고 나서 최초에 실행될 때 호출됩니다.[한번만 호출됨.] 액티비티에 필요한 리소스들을 초기화하거나 화면에 보이는 View들의 일반적인 상태들을 여기서 설정합니다. 이전 상태가 저장되어 있을 경우, 번들 객체를 참조하여 이전 상태로 복원이 가능합니다. 이 다음에는 항상 onStart()가 호출됩니다. onStart() 액티비티가 화면에 보이기 바로 전에 호출됩니다. 액티비티가 화면상에 보이면 이 메소드 다음에 onResume()메소드가 호출된 것입니다. 매우 빠르게 끝나고, onResume() 단계로 넘어갑니다. 보통 Broadcast Receiver는 이 단계에서 등록하는 것이 좋습니다. 액티비티가 시작되기 전에 호출되는 함수 / 액티비티가 멈춘 후 다시 시작되기 전에 호출되는 함수 onResume() 액티비티가 사용자와 상호 작용하기 바로 직전에 호출되는 함수입니다. 이 메소드가 호출되고 나서 바로 액티비티가 사용자에게 보이기 시작합니다. 액티비티가 화면에 보여집니다. 사용자에게 focus를 잡은 상태입니다. onRestart() 액티비티가 중지된(Stopped) 이후에 호출되는 메소드로 다시 시작되기 바로 전에 호출됩니다. 액티비티가 멈춰 있다가 다시 다시 호출될 때 불리는 함수입니다. 다른 액티비티가 호출되는 경우 onPause() 액티비티 위에 액티비티가 올라와서 focus를 잃었을 때 호출되는 함수 액티비티가 완전히 가려지지 않고 부분만 가려진 상태에서 호출되는 함수, 즉 일부분이 보이거나 투명상태일 경우에 호출됩니다. 다른 액티비티가 호출되기 전에 실행되기 때문에 onPause() 함수에서 시간이 많이 소요되는 작업이나 많은 일을 처리하면 다른 액티비티가 호출되는 시간이 지연되기 때문에 많은 일을 처리하지 않도록 주의합니다. [ex) A 액티비티에서 B 액티비티를 호출하는 경우, A 액티비티의 onPause() 함수가 먼저 호출되고 나서 B 액티비티가 실행되는 흐름이다.] 영구적인 Data는 여기서 저장합니다. 이 메소드가 리턴하기 전에는 다음 액티비티가 시작될 수 없으므로 이 작업은 빠르게 리턴되어야 합니다. 액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료할 수 있습니다. onStop() 액티비티 위에 다른 액티비티가 완전히 올라와 100% 가려질 때 호출되는 함수 액티비티가 사용자에게 더 이상 보이지 않을 때 호출되는 함수 만약 이 상태에서 액티비티가 다시 불려지면 onRestart()함수가 호출됩니다. 시스템이 onStop() 상태에 들어오면, onSaveInstanceState()이라는 메소드를 호출하는데, 이 단계에서는 key-value 형태로 값을 저장할 수 있고, 이 값을 onCreate()에서 복원할 수 있습니다. ex) 홈 키를 누른 경우, 또는 다른 액티비티 페이지로 이동이 있는 경우에 호출됩니다. onDestroy() 액티비티가 완전히 스택에서 없어질 때 호출되는 함수 즉 제거되는 경우입니다. Finish() 메소드가 호출되거나 시스템 메모리 확보를 위해서 시스템이 강제로 종료시키는 경우에 호출될 수 있습니다. 참고 사항 onStop(), onDestroy() 함수는 호출되지 않을 수도 있습니다. 메모리 부족으로 인해 onStop()이 호출되지 않을 수 있습니다. Q &amp; A Q. 앱을 사용하는 도중에 카카오톡 메시지가 온다면 사용하던 앱의 TopActivity의 생명주기는 어떤 상태가 되나? A. onPause() Q. 데이터를 불러오는 작업은 어디서 해야 하나? A. onCreate() Q. 다른 액티비티가 상단에 올라오면 어떤 상태인가? A. 실행 중이던 액티비티는 onPause() -&gt; onStop() Q. onRestart()는 언제 호출되는가? A. 다른 액티비티 밑에 깔려 있어서 onStop() 상태에 있다가 다시 돌아오면 호출된다. Q. 화면이 회전하면 액티비티 생명주기는? A. onPause() -&gt; onStop() -&gt; onCreate() -&gt; onStart() -&gt; onResume() 현재 액티비티를 destroy하고 새로 생성하기 때문에 기존 데이터를 유지하기 위해서는 onSaveInstanceState()에서 Bundle에 데이터를 저장하도록 오버라이드 해야 한다. Q. A 액티비티에서 B 액티비티를 실행할 경우 생명주기는? A. A.onPause() -&gt; B.onCreate() -&gt; B.onStart() -&gt; B.onResume() -&gt; A.onStop() : B는 사용자에게 보여짐.","categories":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://woovictory.github.io/tags/Android/"},{"name":"Basic","slug":"Basic","permalink":"https://woovictory.github.io/tags/Basic/"},{"name":"Component","slug":"Component","permalink":"https://woovictory.github.io/tags/Component/"}]},{"title":"자바 :: deque?","slug":"Javadepue","date":"2018-03-01T11:41:19.000Z","updated":"2020-04-22T07:47:10.240Z","comments":true,"path":"2018/03/01/Javadepue/","link":"","permalink":"https://woovictory.github.io/2018/03/01/Javadepue/","excerpt":"","text":"자료구조란 자료(data)를 컴퓨터에서 효율적으로 사용하도록 해주는 알고리즘을 뜻합니다. (효율적 : 실행시간 최소화, 계산의 간편화 등등) Deque java.util.Deque를 import합니다. Double-Ended Queue의 줄임말으로, 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생할 수 있는 큐를 말합니다. 또한, &quot;Queue + Stack&quot;의 기능을 가지고 있습니다. 위의 그림이 일반적으로 deque를 찾으면 나오는 그림입니다. 하지만, 저는 이해가 잘 가지 않아서 그림으로 간단하게 표현했습니다. Method 추가하기 add add(E e) : Deque의 마지막에 Element를 삽입 addFirst(E e) : Deque의 front에 요소 삽입 addLast(E e) : Deque의 rear에 요소 삽입 put add와 동일하게 작용합니다. put(E e) : Deque의 마지막에 Element를 삽입 putFirst(E e) : Deque의 front에 Element를 삽입 putLast(E e) : Deque의 rear에 Element를 삽입 offer add와 동일하게 작용합니다. offer(E e) : Deque의 마지막에 Element를 삽입 offerFirst(E e) : Deque의 front에 Element를 삽입 offerLast(E e) : Deque의 rear에 Element를 삽입 push push(E e) : Deque의 앞 부분에 Element를 삽입 사용법 1234567891011Deque&lt;String&gt; test = new ArrayDeque&lt;String&gt;();test.add(&quot;add : 0&quot;);test.add(&quot;add : 1&quot;);test.addFirst(&quot;First : 2&quot;);test.addLast(&quot;Last : 3&quot;);Iterator&lt;String&gt; e = test.iterator();while(e.hasNext())&#123; System.out.println(e.next());&#125; 결과 삭제하기 poll poll() : Deque의 제일 앞 Element를 제거합니다. Queue에서 Element를 제거하는 것이라고 생각하면 됩니다. pollFirst() : Deque의 제일 앞 Element를 제거합니다. pollLast() : Deque의 제일 마지막 Element를 제거합니다. pop pop() : Deque의 제일 앞 Element를 제거합니다. Stack에서 Element를 제거하는 것이라고 생각하면 됩니다. 참고 Queue의 경우에는 FIFO:선입선출이기 때문에 제거해야 할 Element가 제일 처음에 들어온 것입니다. [add로 맨 처음에 들어온 것], 즉 제일 앞에 있는 Element Stack의 경우에는 LIFO:후입선출이기 때문에 제거해야 할 Element가 제일 나중에 들어온 것입니다. [push로 맨 나중에 들어온 것], 즉 제일 앞에 있는 Element 값을 제거하지 않고 확인만 하기 peek 1.peek : Deque의 제일 앞 Element를 return 받습니다. Element를 제거하지 않습니다. 2.peekFirst : Deque의 제일 앞 Element를 return 받습니다. peekLast : Deque의 제일 마지막 Element를 return 받습니다. get getFirst : First에 있는 Element를 return 받습니다. getLast : Last에 있는 Element를 return 받습니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"Java :: 개념 다지기","slug":"Java개념","date":"2018-02-28T03:37:18.000Z","updated":"2020-04-22T07:47:05.718Z","comments":true,"path":"2018/02/28/Java개념/","link":"","permalink":"https://woovictory.github.io/2018/02/28/Java개념/","excerpt":"","text":"변수와 자료형 변수 변수는 데이터의 저장과 참조를 위한 공간이라고 표현할 수 있습니다. 12int num1=10; // 변수를 선언하고 10을 저장했습니다.System.out.println(num1); // 변수 num1에 접근해서 10을 출력 변수의 이름 1.변수의 이름은 대소문자를 구분합니다. 2.그리고 변수의 이름은 숫자로 시작할 수 없습니다. 3.키워드는 변수의 이름으로 사용할 수 없습니다. 자바의 문법을 구성하는 단어들 : 키워드 4.$과 _ 이외의 다른 특수문자는 사용할 수 없습니다. 자료형 자바의 자료형은 크게 두 가지로 나뉜다. Primitive type : 기본 자료형으로 일반적으로 제공하는 자료형 Non-Primitive type : 기본형이 아닌 자료형, 오브젝트와 관련된 자료형 자료형은 변수를 선언하기 위해서 필요하기 때문에, 반드시 알아야 합니다. 자료형의 선언은 메모리 공간의 데이터 저장 및 참조 방식을 결정 자료형의 종류 자바는 총 8개의 자료형을 제공하고 있지만, 포현하는 데이터의 종류에 따라서 크게 4가지로 구분이 됩니다. 그리고 실수의 표현 및 저장에는 오차가 존재 정수 표현 : byte, short, int, long 실수 표현 : float, double 문자 표현 : char 참과 거짓의 표현 : boolean 정수 자료형 short(2byte)와 int(4byte) 중 어떤 것을 사용할까? 단순하게 메모리 공간만 생각한다면 short가 좋다고 할 수 있습니다. 하지만, 우리가 사용하는 CPU는 int형 정수 연산을 가장 고속으로 처리하도록 설계되어 있습니다. 따라서 자바는 정수 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거칩니다. 때문에 short를 int형으로 변환하는 것보다 int형으로 선언하는 것이 더 빠릅니다. 그래서 정수를 선언할 때 short보다 int로 선언하는 것이 더 빠릅니다. byte와 short는 필요할까? 데이터들 중에는 연산이 중심이 되는 데이터도 존재하지만, 데이터가 지니는 값 자체가 중심이 되는 경우도 있습니다. 노래와 같은 음원 정보를 저장하려면 수십만, 수백만 이상의 숫자 정보를 저장해야 하기 때문에, 이러한 경우에는 연산보다는 데이터의 표현이 중심이 됩니다. 실수 자료형 float과 double 정밀도를 포기하고 표현의 범위를 넓힌 자료형이기 때문에 float과 double의 선택 기준은 값의 표현범위에 있지 않습니다. 선택 기준은 정밀도에 있습니다. 실수를 표현하는데 사용이 되는 바이트의 수가 많으면 오차가 발생할 확률은 낮아진다. float : 6자리의 정밀도 double : 15자리의 정밀도 문자 자료형 char 하드웨어는 숫자밖에 인식을 하지 못합니다. 그래서 문자를 숫자로 포현하는 방법밖에 존재하지 않습니다. 자바는 유니코드라는 표준을 근거로 하여 문자를 표현합니다. 유니코드는 문자 하나를 2바이트로 표현합니다. 12char ch1 = &apos;A&apos;; // 2bytechar ch2 = &apos;한&apos;; // 2byte char형 변수에 저장되는 것은 문자의 유니코드 상수 값입니다. '참’과 '거짓’을 표현하는 boolean 자료형 true : 참을 의미(1) false : 거짓을 의미(0) 상수(literal) 상수는 변수와 마찬가지로 메모리 공간에 저장이 됩니다. 상수는 자료형을 기반으로 저장이 됩니다. 기본적으로 모든 정수형 상수는 int형으로 표현 및 저장합니다. 기본적으로 모든 실수형 상수는 double형으로 포현 및 저장합니다. 12int num=1+5; // 1과5는 메모리 공간에 4바이트씩 할당된다.System.out.println(2.4+7.5); // 2.4와7.5는 메모리 공간에 8바이트씩 할당된다. 접미사 10000000000의 표현?? -&gt; 명시적 선언 12int num1 = 10000000000; // 1long num2 = 10000000000; // 2 1은 int형이 표현할 수 있는 범위를 벗어났기 때문에 에러가 발생합니다. 2는 long형이 표현할 수 있지만, 정수형 상수는 int형으로 표현되기 때문에 에러가 발생합니다. 12long num3 = 10000000000L; // 3float num4 = 12.45F; // 4 3에서 숫자 뒤에 붙는 접미사 L은 정수를 long형으로 표현해라!의 의미입니다. 4에서도 마찬가지로 해당 실수를 float형으로 표현하라는 의미입니다. 자료형의 변환 형 변환이란? 값의 표현 방식을 바꾸는 것을 의미합니다. 1.자동 형 변환 12double num1 = 20; // 자동 형 변환의 예[성공]int num2 = 20.5; // 자동 형 변환의 예[실패] 이 경우에는 int형 정수 20이 double형 실후 20.0으로 자동 형 변환되어 변수 num1에 저장이 됩니다. 두 번째 경우는 8바이트 double형 상수를 4바이트 int형 상수에 저장하려고 하고 있습니다. 이는 데이터의 손실로 인해서 형 변환이 일어나지 않습니다. [byte] -&gt;[short,char] -&gt;[int] -&gt;[long] -&gt;[float] -&gt;[double] 자바의 자동 형 변환 규칙은 바이트 크기가 아닌, 값의 표현 범위를 기준으로 정의되어있습니다. 2.명시적 형 변환 자동 형 변환 규칙에 위배되는 상황임에도 불구하고 형 변환이 필요한 경우에는 명시적 형 변환을 통해서 형 변환이 이루어지도록 할 수 있습니다. 1int num1 = (int)3.15; 12int num3=100;int num4=(long)num3; // int형-&gt;long형 이기 때문에 상위 4바이트가 0으로 채워짐 실수형 데이터를 형 변환하는 경우에는 소수점 이하가 잘려나가는 데이터 손실의 문제가 발생합니다. 그리고 형 변환도 값을 반환하는 하나의 연산입니다. 즉, 변수에 저장된 값이 변경되는 것이 아니라 변수에 저장된 값을 참조하여 int형, long형으로 변환된 새로운 값을 만들어서 새로운 변수에 저장합니다. 연산자 이항 연산자 피연산자가 둘인 연산자 복합 대입 연산자 대입 연산자가 다른 연산자와 묶여서 정의되어 있는 형태의 연산자 관계 연산자 크기 및 동등 관계를 따지는 연산자이며 true 또는 false를 반환 논리 연산자 true 또는 false를 반환하는 연산자 true와 false를 피연산자로 연산을 진행하는 것! 진리표 논리 연산자의 연산 결과를 나타낸 표를 진리표라 합니다. 단항 연산자 피연산자가 하나인 연산자 prefix : 피연산자의 앞부분에 붙는다. 값이 증가/감소 하고 대입이나 그 다음 연산이 진행된다. postfix : 피연산자의 뒤에 붙는 연산자. 값을 대입하고 연산을 하고 다음 문장에서 값이 증가/감소 한다. 비트 연산자 비트 단위로 연산을 진행하는 연산자이며, 피연산자는 반드시 정수이어야 합니다. 실수에 대해서는 비트 연산이 불가능합니다. 비트 쉬프트 연산자 피연산자의 비트 열을 왼쪽 또는 오른쪽으로 이동시키는 연산자[이항 연산자] 피연산자는 모두 정수이어야 합니다. 왼쪽으로의 비트 열 이동은 2의 배수의 곱으로 이어집니다. 오른쪽으로의 비트 열 이동은 2의 배수의 나눗셈으로 이어집니다. 비트 쉬프트 연산은 음의 정수에서도 동일하게 적용될까? &lt;&lt;와 &gt;&gt; 연산자는 값의 부호를 결정하는 MSB를 그대로 유지하기 떄문입니다. 즉, MSB가 1이면 &gt;&gt;연산에 따른 빈 공간을 1로 채우고, MSB가 0이면 &gt;&gt; 연산에 따른 빈 공간을 0으로 채웁니다. 이번에는 if~else, switch, for, while문등에 대해서 배워보겠습니다. 조건문 if문과 if~else문 특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 if를 사용! 1234567891011121314int num = 10;if(num&gt;0)&#123; System.out.println(&quot;num은 0보다 크다.&quot;);&#125;if((num%2)==0))&#123; System.out.println(&quot;num은 짝수&quot;);&#125;else&#123; System.out.println(&quot;num은 홀수&quot;);&#125; 한 문장이 있을 때는 중괄호 생략가능 if~else문은 하나의 문장으로 생각! if~else문과 유사한 성격의 조건 연산자 123int num1=50, num2=100;int big = (num1&gt;num2)? num1 : num2;System.out.println(big); (num1&gt;num2)가 true이면 : 왼쪽에 있는 숫자가 false이면 : 오른쪽에 있는 숫자가 big에 대입됩니다. switch와 break 조건에 따른 실행의 경우 수가 많다면 switch문이 유용! 123456789101112131415161718192021int n = 3;switch(n)&#123; case 1: System.out.println(&quot;1&quot;); break; case 2: System.out.println(&quot;2&quot;); break; case 3: System.out.println(&quot;3&quot;); break; case 4: System.out.println(&quot;4&quot;); break; case 5: System.out.println(&quot;5&quot;); break; &#125;System.out.println(&quot;Bye&quot;); switch문에 들어오는 n에 따라서 레이블 별로 실행되고 해당 레이블 영역이 실행이 끝나면 break문을 통해서 switch문을 빠져나갑니다. 123456switch(n)&#123; case 1 : case 2 : case 3 : System.out.println(&quot;Java&quot;); break; &#125; 위의 코드처럼 레이블을 한 줄에 둘 이상 붙일 수 있습니다. 반복문 while문 사용법 123456int num = 0;while(num&lt;5)&#123; System.out.println(&quot;Java&quot;+num); num++;&#125; 순서 : 반복 조건 검사 -&gt; treu면 반복 영역 실행 - &gt; 반복 조건 검사 -&gt; true면 반복 영역 실행 … 반복 조건을 먼저 검사하기 때문에 반복 영역이 한 차례도 실행되지 않을 수도 있습니다. do~while문 123456int num = 0;do&#123; System.out.println(&quot;Java&quot;+num); num++;&#125;while(num&lt;5); 순서 : 반복 영역 실행 -&gt; 반복 조건 검사 -&gt; true면 반복 영역 실행 -&gt; 반복 조건 검사 -&gt; true면 … 반복 영역을 먼저 실행하기 때문에, 반복 조건을 만족하지 않더라도 한 차례는 실행됩니다. for 반복문 정해진 횟수의 반복이 존재하면 for문 사용 123for(int i=0;i&lt;3;i++)&#123; System.out.println(&quot;Java&quot;+i);&#125; continue &amp; break 반복문 내에 삽입되어, 반복문의 실행 흐름을 조절하는데 사용되는 키워드 break 자신을 감싸고 있는 가장 가까운 반복문을 빠져나가는 용도로 사용됩니다. 123456789101112131415int num=1;boolean search = false;while(num&lt;50)&#123; if(num%5==0 &amp;&amp; num%7==0) &#123; search = true; break; &#125; num++;&#125;if(search) System.out.println(&quot;찾는 정수:&quot;+num);else System.out.println(&quot;찾지 못했습니다.&quot;); 중첩된 반복문을 벗어나기 위해서는 빠져나갈 위치를 명시해 주면 됩니다. 12345678910outerLoop : for(int i=1;i&lt;10;i++)&#123; for(int j=1;j&lt;10;j++) &#123; System.out.println(&quot;[&quot;+i+&quot;, &quot;+j+&quot;]&quot;); if(i%2==0 &amp;&amp; j%2==0) break outerLoop; &#125;&#125; continue 실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 조건검사 부분으로 이동시킵니다. 123456789101112int num=0;int count=0;while(num++&lt;100)&#123; if(num%5!=0 || num%7!=0) // 5의 배수가 아니거나 7의 배수가 아니면 조건검사로 이동 continue; count++; System.out.println(num); // 5의 배수이면서 7의 배수인 수와 개수를 찾는다. &#125;System.out.println(&quot;count : &quot;+ count);","categories":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://woovictory.github.io/tags/Java/"}]},{"title":"[Hexo] Theme BeanTech","slug":"hexo-theme-beantech","date":"2017-03-18T01:51:24.000Z","updated":"2018-02-28T07:54:04.000Z","comments":true,"path":"2017/03/18/hexo-theme-beantech/","link":"","permalink":"https://woovictory.github.io/2017/03/18/hexo-theme-beantech/","excerpt":"","text":"Ported Theme of Hux Blog, Thank Huxpro for designing such a flawless theme. This BeanTech theme created by YuHsuan modified from the original Porter Kaijun Live Demo Usage I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog! Let’s begin!!! Init 123git clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantechcd hexo-beantechnpm install Modify Modify _config.yml file with your own info. Especially the section: Deployment Replace to your own repo! 1234deploy: type: git repo: https://github.com/&lt;yourAccount&gt;/&lt;repo&gt; branch: &lt;your-branch&gt; Sidebar settings Copy your avatar image to &lt;root&gt;/img/ and modify the _config.yml: 123sidebar: true # whether or not using Sidebar.sidebar-about-description: \"&lt;your description&gt;\"sidebar-avatar: img/&lt;your avatar path&gt; and activate your personal widget you like 1234567widgets: # here are widget you can use, you can comment out- featured-tags- short-about- recent-posts- friends-blog- archive- category if you want to add sidebar widget, please add at layout/_widget. Signature Setup Copy your signature image to &lt;root&gt;/img/signature and modify the _config.yml: 12signature: true # show signaturesignature-img: img/signature/&lt;your-signature-ID&gt; Go to top icon Setup My icon is using iron man, you can change to your own icon at css/image. Post tag You can decide to show post tags or not. 1home_posts_tag: true 1home_posts_tag: false Markdown render My markdown render engine plugin is hexo-renderer-markdown-it. 12345678910# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: '“”‘’' and if you want to change the header anchor ‘ℬ’, you can go to layout/post.ejs to change it. 123456async(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function()&#123; anchors.options = &#123; visible: 'hover', placement: 'left', icon: ℬ // this is the header anchor \"unicode\" icon &#125;; Hexo Basics Some hexo command: 1234hexo new post \"&lt;post name&gt;\" # you can change post to another layout if you wanthexo clean &amp;&amp; hexo generate # generate the static filehexo server # run hexo in local environmenthexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo! Have fun ^_^ Please Star this Project if you like it! Follow would also be appreciated! Peace!","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://woovictory.github.io/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://woovictory.github.io/tags/Blog/"}]}]}