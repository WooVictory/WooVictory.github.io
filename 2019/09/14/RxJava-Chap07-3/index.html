
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>[RxJava] Chap07. 디버깅 - 흐름 제어 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"articleBody":"흐름 제어\n\n흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다.\nRxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.\n\nsample()\n\n특정한 시간 동안 가장 최근에 발행한 데이터만 걸러준다. 즉, 최근에 발행된 데이터만 넘겨주고 나머지는 무시한다.\n해당 시간에는 아무리 많은 데이터가 들어와도 해당 구간의 마지막 데이터만 발행하고 나머지는 무시한다.\n\n\n123@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; sample(long period, TimeUnit unit)public final Observable&lt;T&gt; sample(long period, TimeUnit unit, boolean emitLast)\n\nemitLast 인자는 sample() 함수의 데이터 발행이 완료되지 않고 마지막에 데이터가 남아 있을 때, 해당 데이터를 발행할 것인지 결정한다. true로 설정하면 마지막 데이터를 발행한다.\n\n123456789101112131415161718192021222324252627282930public class sampleTest &#123;    public static void main(String[] args) &#123;        String[] data = &#123;\"1\", \"7\", \"2\", \"3\", \"6\"&#125;;        // 시간 측정용.        CommonUtils.exampleStart();        // 앞의 4개의 데이터는 100ms 간격으로 발행.        Observable&lt;String&gt; earlySource = Observable.fromArray(data)                .take(4)                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 마지막 데이터는 300ms 후에 발행.        Observable&lt;String&gt; lateSource = Observable.just(data[4])                .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 2개의 Observable 을 결합하고 300ms 로 샘플링.        Observable&lt;String&gt; source = Observable.concat(earlySource, lateSource)                .sample(300L, TimeUnit.MILLISECONDS);        source.subscribe(Log::it);        CommonUtils.sleep(1000);    &#125;&#125;// 결과RxComputationThreadPool-1 | 552 | value = 7RxComputationThreadPool-1 | 849 | value = 3\n\n먼저, 100ms 간격으로 data 배열에 있는 데이터 4개를 발행한다. 그리고 마지막 데이터인 6을 300ms 후에 발행한다.\n또한 내가 원하는 특정 시간 후에 발행하기 위해 concat() 함수를 호출해 2개의 데이터 흐름(Observable)을 결합했다. 이렇게 전체 데이터 흐름을 세부 데이터 흐름으로 나누면 코드의 가독성이 좋아진다.\nsample() 함수는 300ms 간격으로 수행한다. 매 300ms 마다 가장 최근에 들어온 값만 최종적으로 발행한다.\n처음에 데이터를 발행하기 위해 약간의 지연 시간이 있어서(100ms+a) 다이어그램을 보면 시작할 때 약간의 간격이 있음을 볼 수 있다. 다음 데이터 발행이 3XXms이기 때문에 300ms일 때는 가장 최근 데이터가 이전에 발행했던 7이 되는 것이다.(처음 기준!)\n마지막 인자를 true로 설정하면 마지막 데이터를 발행한다. 기본값이 false이다.\n\nbuffer()\n\n일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해준다.\n따라서 넘치는 데이터 흐름을 제어할 필요가 있을 때 활용한다. 컴퓨터의 버퍼 같은 기능을 한다.\n\n\n\n처음에 빨,노,초 원을 발행하면 그것을 모아서 List 객체에 전달해준다. 그 다음 다시 하늘,파,보 원이 모이면 그것을 모아서 한 번에 발행해준다. 매우 단순한 로직이다.\n함수의 원형은 다음과 같다.\n\n기본적으로 스케줄러 없이 현재 스레드에서 동작하며 입력되는 값을 count에 저장된 수만큼 모아서 List에 한꺼번에 발행한다.\n\n\n\n12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;List&lt;T&gt;&gt; buffer(int count)\n1234567891011121314151617181920212223242526272829303132public class bufferSample &#123;    public static void main(String[] args) &#123;        String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;;        CommonUtils.exampleStart();        // 앞의 3개는 100ms 간격으로 발행.        Observable&lt;String&gt; earlySource = Observable.fromArray(data)                .take(3)                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 가운데 1개는 300ms 후에 발행.        Observable&lt;String&gt; middleSource = Observable.just(data[3])                .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 마지막 2개는 100ms 후에 발행.        Observable&lt;String&gt; lataSource = Observable.just(data[4], data[5])                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        Observable&lt;List&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lataSource)                .buffer(3);        source.subscribe(Log::it);        CommonUtils.sleep(1000);    &#125;&#125;// 결과RxComputationThreadPool-1 | 562 | value = [1, 2, 3]RxComputationThreadPool-3 | 1067 | value = [4, 5, 6]\n\nbuffer(3)는 데이터를 3개씩 모았다가 List에 채운 후 값을 한꺼번에 발행해준다. 그래서 위의 결과를 보면 확인 가능하다.\nbuffer() 함수에는 모으거나(count) 무시할(skip) 데이터 개수를 입력할 수 있다.\nskip 변수는 count보다 값이 커야 한다. count가 2이고 skip이 3이면 2개 데이터를 모으고 3번째 데이터 1개는 스킵한다.\n코드는 위와 같으면 buffer(2,3)으로 호출하면 아래와 같은 결과를 얻을 수 있다.\n\n12RxComputationThreadPool-1 | 562 | value = [1, 2]RxComputationThreadPool-3 | 1067 | value = [4, 5]\n\nObservable에서 onNext 이벤트가 발생하면 내부 데이터는 3개가 아니라 2개 값을 모아 바로 List에 채운 후 구독자에게 데이터를 발행한다.\n\nthrottleFirst(), throttleLast()\n\nthrottle는 조절판이라는 뜻이다. 그것에 맞게 throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행한다. throttleLast() 함수는 주어진 조건에서 가장 마지막에 입력된 값을 발행한다.\nthrottleFirst()와 throttleLast()는 정반대의 의미가 아니다. throttleFirst() 함수는 어떤 데이터가 입력된 후 일정 시간 동안 다른 데이터가 발행되지 못하도록 방지하지만, throttleLast() 함수는 sample() 함수처럼 고정된 시간 간격안에서 마지막 데이터만 발행한다.\nthrottleFirst() : sample() 함수와 비슷하지만 다르다. sample() 함수가 주어진 시간 동안 입력된 마지막 값을 발행한다면 throttleFirst() 함수는 어떤 데이터를 발행하면 지정된 시간 동안 다른 데이터를 발행하지 않도록 막는다.\nthrottleLast() : sample() 함수와 기본 개념은 동일하다. 주어진 시간 동안 입력된 값 중 마지막 값을 발행한다.\n\n\n\n함수 원형은 다음과 같다.\n\n계산 스케줄러에서 실행한다. 즉, 비동기로 동작하도록 설계된 함수다.\nwindowDuration는 시간 간격을 지정하며 unit은 시간의 단위다.\n\n\n\n12@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; throttleFirst(long windowDuration, TimeUnit unit)\n123456789101112131415161718192021222324252627282930313233343536public class throttleFirstSample &#123;    public static void main(String[] args) &#123;        String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;;        CommonUtils.exampleStart();        // 앞의 1개는 100ms 간격으로 발행.        Observable&lt;String&gt; earlySource = Observable.just(data[0])                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 다음 1개는 300ms 후에 발행.        Observable&lt;String&gt; middlerSource = Observable.just(data[1])                .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 마지막 4개는 100ms 후에 발행.        Observable&lt;String&gt; lateSource = Observable.just(data[2], data[3], data[4], data[5])                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a)                .doOnNext(Log::dt); // 디버깅 정보 출력.        Observable&lt;String&gt; source = Observable.concat(earlySource, middlerSource, lateSource)                .throttleFirst(200L, TimeUnit.MILLISECONDS);        source.subscribe(Log::it);        CommonUtils.sleep(1000);    &#125;&#125;// 결과RxComputationThreadPool-1 | 371 | value = 1RxComputationThreadPool-3 | 673 | value = 2RxComputationThreadPool-4 | 779 | debug = 3RxComputationThreadPool-4 | 876 | debug = 4RxComputationThreadPool-4 | 975 | debug = 5RxComputationThreadPool-4 | 975 | value = 5RxComputationThreadPool-4 | 1077 | debug = 6\n\n처음 100ms가 지난 후에 1을 발행한 후, 300ms 동안 기다린 다음 2를 발행한다. 그리고 100ms 간격으로 나머지 값들을 발행한다. 마지막으로 throttleFirst() 함수를 호출해 200ms 간격으로 타임 윈도에 맨 먼저 입력된 값을 발행한다.\n위에서는 1,2,4,6이 다운 스트림으로 발행된다.\n\nwindow()\n\ngroupBy() 함수와 개념적으로 비슷하다.\nthrottleFirst()나 sample() 함수처럼 내가 처리할 수 있는 일부의 값들만 받아들일 수 있다. 흐름 제어 기능에 groupBy() 함수와 비슷한 별도의 Observable 분리 기능을 모두 갖추었다고 생각하면 된다.\n\n\n\ncount를 인자로 받는다. 예를 들어, 3을 인자로 받으면 앞으로 데이터 3개가 발행될 때마다 새로운 Observable을 생성하겠다는 뜻이다.\n함수의 원형은 다음과 같다.\n\n현재 스레드를 그대로 활용한다. 왜 그런지 window() 함수의 다른 변형을 비교하면 알 수 있다.\n\n\n\n12@SchedulerSupport(SchedulerSupport.NONE)public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)\n123456@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;Observable&lt;T&gt;&gt; window(    long timespan, long timeskip, TimeUnit unit)&#123;     // 생략.&#125;\n\ncount만을 인자로 갖는 window() 함수는 입력된 값을 그대로 발행하기 때문에 비동기 작업이라고 보기 어렵다.\n위의 함수 원형에는 timespan이라는 시간 동안 입력된 값 중에서 일부를 무시하는 기능을 포함한다.\n어떤 필터링 작업을 해줘야 하기 때문에 계산 스케줄러를 활용하게 된다.\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445public class windowSample &#123;    public static void main(String[] args) &#123;        String[] data = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"&#125;;        CommonUtils.exampleStart();        // 앞의 3개는 100ms 간격으로 발행.        Observable&lt;String&gt; earlySource = Observable.fromArray(data)                .take(3)                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 가운데 1개는 300ms 후에 발행.        Observable&lt;String&gt; middleSource = Observable.just(data[3])                .zipWith(Observable.interval(300L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 마지막 2개는 100ms 후에 발행.        Observable&lt;String&gt; lateSource = Observable.just(data[4], data[5])                .zipWith(Observable.interval(100L, TimeUnit.MILLISECONDS),                        (a, b) -&gt; a);        // 데이터 3개씩 모아서 새로운 Observable 생성.        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lateSource)                .window(3);        source.subscribe(observable -&gt; &#123;            Log.dt(\"New Observable Started!!\");            observable.subscribe(Log::it);        &#125;);        CommonUtils.sleep(1000);        CommonUtils.exampleComplete();    &#125;&#125;// 결과RxComputationThreadPool-1 | 365 | debug = New Observable Started!!RxComputationThreadPool-1 | 366 | value = 1RxComputationThreadPool-1 | 461 | value = 2RxComputationThreadPool-1 | 560 | value = 3RxComputationThreadPool-2 | 861 | debug = New Observable Started!!RxComputationThreadPool-2 | 861 | value = 4RxComputationThreadPool-3 | 963 | value = 5RxComputationThreadPool-3 | 1062 | value = 6\n\nwindow() 함수의 인자로 3을 넣었다. 처음에 Observable을 생성하고 3개의 데이터를 전달받으면 새로운 Observable을 다시 생성하여 값을 발행한다.\n1 값을 발행할 때와 4 값을 발행할 때 각각 새로운 Observable이 생성되었다.\n\ndebounce()\n\n빠르게 연속 이벤트를 처리하는 흐름 제어 함수다.\n안드로이드와 같은 UI 기반의 프로그래밍에서는 유용하게 활용할 수 있다.\n예를 들어, 버튼을 빠르게 누르는 상황에서 마지막에 누른 이벤트만 처리해야할 때 간단하게 적용할 수 있다. RxJava를 이용하지 않는다면 마지막에 버튼을 누른 시간을 멤버 변수에 저장하고 일정 시간 동안 if문으로 예외 처리해야 하기 때문에 매우 번거롭고 실수할 가능성도 크다.\n\n\n\n첫 번째 원은 지정한 시간 간격 안에 들어왔고 다른 이벤트는 없어서 그대로 발행되었다. 두 번째 원의 경우 시간 간격 안에 세 번째 원이 다시 들어왔으므로 두 번째가 아닌 세 번째 원을 발행한다. 마지막도 마찬가지다.\n함수의 원형은 다음과 같다.\n\n계산 스케줄러에서 동작한다.\n어떤 이벤트가 입력되고 timeout에서 지정한 시간 동안 추가 이벤트가 발생하지 않으면 마지막 이벤트를 최종적으로 발행한다.\n\n\n\n12@SchedulerSupport(SchedulerSupport.COMPUTATION)public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)\n123456789101112131415161718public class debounceSample &#123;    public static void main(String[] args) &#123;        String[] data = &#123;\"1\", \"2\", \"3\", \"5\"&#125;;        Observable&lt;String&gt; source = Observable.concat(                Observable.timer(100L, TimeUnit.MILLISECONDS).map(i -&gt; data[0]),                Observable.timer(300L, TimeUnit.MILLISECONDS).map(i -&gt; data[1]),                Observable.timer(100L, TimeUnit.MILLISECONDS).map(i -&gt; data[2]),                Observable.timer(300L, TimeUnit.MILLISECONDS).map(i -&gt; data[3])        ).debounce(200L, TimeUnit.MILLISECONDS);        source.subscribe(Log::i);        CommonUtils.sleep(1000);    &#125;&#125;// 결과RxComputationThreadPool-2 | value = 1RxComputationThreadPool-2 | value = 3RxComputationThreadPool-2 | value = 5\n\n데이터를 발행하는 부분이 특이하다. 각각의 시간 간격이 서로 다르기 때문에 concat() 함수를 활용해 각가 데이터를 발행했다.\ntimer() 함수는 이벤트를 한 번만 발생시키고 완료하기 때문에 concat()과 timer() 함수의 조합은 유용하다.\ndebounce()를 활용해 어떤 이벤트가 입력되고 지정된 timeout인 200ms 안에 더 이상의 이벤트가 없으면 마지막에 입력된 값을 발행한다.\n여기서 이해가 잘 안되었던 부분이 있었다. 결과를 예상해봤을 때, 1,2,5라고 생각했지만 아니었다. 왜냐면 정의 자체가 어떤 이벤트가 입력되고 나서 timout 내에 더 이상의 이벤트가 없으면 마지막 이벤트를 발행하는 것이다. 그러니까 어떤 이벤트가 입력되고 나서 timout 내에 이벤트가 있는지 찾는 것이다. 그래서 결과는 1,3,5가 맞다.\n\n","dateCreated":"2019-09-14T23:23:20+09:00","dateModified":"2020-08-05T15:30:51+09:00","datePublished":"2019-09-14T23:23:20+09:00","description":"","headline":"[RxJava] Chap07. 디버깅 - 흐름 제어","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"},"publisher":{"@type":"Organization","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg","logo":{"@type":"ImageObject","url":"Victory.jpeg"}},"url":"https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/","keywords":"Android, RxJava, 흐름 제어, 디버깅"}</script>
    <meta name="description" content="흐름 제어  흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다. RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.  sample()  특정한 시간 동안 가장 최근에 발행한 데이터만 걸">
<meta name="keywords" content="Android,RxJava,흐름 제어,디버깅">
<meta property="og:type" content="blog">
<meta property="og:title" content="[RxJava] Chap07. 디버깅 - 흐름 제어">
<meta property="og:url" content="https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="흐름 제어  흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다. RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.  sample()  특정한 시간 동안 가장 최근에 발행한 데이터만 걸">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://woovictory.github.io/img/sample.png">
<meta property="og:image" content="https://woovictory.github.io/img/buffer.png">
<meta property="og:image" content="https://woovictory.github.io/img/throttleFirst.png">
<meta property="og:image" content="https://woovictory.github.io/img/window.png">
<meta property="og:image" content="https://woovictory.github.io/img/debounce.png">
<meta property="og:updated_time" content="2020-08-05T06:30:51.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[RxJava] Chap07. 디버깅 - 흐름 제어">
<meta name="twitter:description" content="흐름 제어  흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다. RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.  sample()  특정한 시간 동안 가장 최근에 발행한 데이터만 걸">
<meta name="twitter:image" content="https://woovictory.github.io/img/sample.png">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            [RxJava] Chap07. 디버깅 - 흐름 제어
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-09-14T23:23:20+09:00">
	
		    Sep 14, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="흐름-제어">흐름 제어</h1>
<ul>
<li>흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다.</li>
<li>RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.</li>
</ul>
<h2 id="sample">sample()</h2>
<ul>
<li>특정한 시간 동안 가장 최근에 발행한 데이터만 걸러준다. <strong>즉, 최근에 발행된 데이터만 넘겨주고 나머지는 무시한다.</strong></li>
<li>해당 시간에는 아무리 많은 데이터가 들어와도 해당 구간의 마지막 데이터만 발행하고 나머지는 무시한다.</li>
</ul>
<img src="/img/sample.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit, <span class="keyword">boolean</span> emitLast)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>emitLast</code> 인자는 sample() 함수의 데이터 발행이 완료되지 않고 마지막에 데이터가 남아 있을 때, 해당 데이터를 발행할 것인지 결정한다. true로 설정하면 마지막 데이터를 발행한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sampleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"7"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 시간 측정용.</span></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 4개의 데이터는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">4</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 데이터는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2개의 Observable 을 결합하고 300ms 로 샘플링.</span></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, lateSource)</span><br><span class="line">                .sample(<span class="number">300L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">552</span> | value = <span class="number">7</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">849</span> | value = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>먼저, 100ms 간격으로 data 배열에 있는 데이터 4개를 발행한다. 그리고 마지막 데이터인 6을 300ms 후에 발행한다.</li>
<li>또한 내가 원하는 특정 시간 후에 발행하기 위해 concat() 함수를 호출해 2개의 데이터 흐름(Observable)을 결합했다. 이렇게 전체 데이터 흐름을 세부 데이터 흐름으로 나누면 코드의 가독성이 좋아진다.</li>
<li>sample() 함수는 300ms 간격으로 수행한다. 매 300ms 마다 가장 최근에 들어온 값만 최종적으로 발행한다.</li>
<li>처음에 데이터를 발행하기 위해 약간의 지연 시간이 있어서(100ms+a) 다이어그램을 보면 시작할 때 약간의 간격이 있음을 볼 수 있다. 다음 데이터 발행이 3XXms이기 때문에 300ms일 때는 가장 최근 데이터가 이전에 발행했던 7이 되는 것이다.(처음 기준!)</li>
<li>마지막 인자를 true로 설정하면 마지막 데이터를 발행한다. 기본값이 false이다.</li>
</ul>
<h2 id="buffer">buffer()</h2>
<ul>
<li>일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해준다.</li>
<li>따라서 넘치는 데이터 흐름을 제어할 필요가 있을 때 활용한다. 컴퓨터의 버퍼 같은 기능을 한다.</li>
</ul>
<img src="/img/buffer.png" width="500" height="200">
<ul>
<li>처음에 빨,노,초 원을 발행하면 그것을 모아서 List 객체에 전달해준다. 그 다음 다시 하늘,파,보 원이 모이면 그것을 모아서 한 번에 발행해준다. 매우 단순한 로직이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>기본적으로 스케줄러 없이 현재 스레드에서 동작하며 입력되는 값을 count에 저장된 수만큼 모아서 List<t>에 한꺼번에 발행한다.</t></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lataSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Observable&lt;List&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lataSource)</span><br><span class="line">                .buffer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>buffer(3)는 데이터를 3개씩 모았다가 List<string>에 채운 후 값을 한꺼번에 발행해준다. 그래서 위의 결과를 보면 확인 가능하다.</string></li>
<li>buffer() 함수에는 모으거나(count) 무시할(skip) 데이터 개수를 입력할 수 있다.</li>
<li>skip 변수는 count보다 값이 커야 한다. count가 2이고 skip이 3이면 2개 데이터를 모으고 3번째 데이터 1개는 스킵한다.</li>
<li>코드는 위와 같으면 <code>buffer(2,3)</code>으로 호출하면 아래와 같은 결과를 얻을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Observable에서 onNext 이벤트가 발생하면 내부 데이터는 3개가 아니라 2개 값을 모아 바로 List<string>에 채운 후 구독자에게 데이터를 발행한다.</string></li>
</ul>
<h2 id="throttlefirst-throttlelast">throttleFirst(), throttleLast()</h2>
<ul>
<li>throttle는 <strong>조절판</strong>이라는 뜻이다. 그것에 맞게 throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행한다. throttleLast() 함수는 주어진 조건에서 가장 마지막에 입력된 값을 발행한다.</li>
<li>throttleFirst()와 throttleLast()는 정반대의 의미가 아니다. throttleFirst() 함수는 어떤 데이터가 입력된 후 일정 시간 동안 다른 데이터가 발행되지 못하도록 방지하지만, throttleLast() 함수는 sample() 함수처럼 고정된 시간 간격안에서 마지막 데이터만 발행한다.</li>
<li><strong>throttleFirst()</strong> : sample() 함수와 비슷하지만 다르다. sample() 함수가 주어진 시간 동안 입력된 마지막 값을 발행한다면 <code>throttleFirst()</code> 함수는 <strong>어떤 데이터를 발행하면 지정된 시간 동안 다른 데이터를 발행하지 않도록 막는다.</strong></li>
<li><strong>throttleLast()</strong> : sample() 함수와 기본 개념은 동일하다. 주어진 시간 동안 입력된 값 중 마지막 값을 발행한다.</li>
</ul>
<img src="/img/throttleFirst.png" width="500" height="200">
<ul>
<li>함수 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 실행한다. 즉, 비동기로 동작하도록 설계된 함수다.</li>
<li>windowDuration는 시간 간격을 지정하며 unit은 시간의 단위다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">throttleFirst</span><span class="params">(<span class="keyword">long</span> windowDuration, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">throttleFirstSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 1개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.just(data[<span class="number">0</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 다음 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middlerSource = Observable.just(data[<span class="number">1</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 4개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">2</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a)</span><br><span class="line">                .doOnNext(Log::dt); <span class="comment">// 디버깅 정보 출력.</span></span><br><span class="line"></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, middlerSource, lateSource)</span><br><span class="line">                .throttleFirst(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">371</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">673</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">779</span> | debug = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">876</span> | debug = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | debug = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">1077</span> | debug = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>처음 100ms가 지난 후에 1을 발행한 후, 300ms 동안 기다린 다음 2를 발행한다. 그리고 100ms 간격으로 나머지 값들을 발행한다. 마지막으로 throttleFirst() 함수를 호출해 200ms 간격으로 타임 윈도에 맨 먼저 입력된 값을 발행한다.</li>
<li>위에서는 1,2,4,6이 다운 스트림으로 발행된다.</li>
</ul>
<h2 id="window">window()</h2>
<ul>
<li>groupBy() 함수와 개념적으로 비슷하다.</li>
<li>throttleFirst()나 sample() 함수처럼 내가 처리할 수 있는 일부의 값들만 받아들일 수 있다. 흐름 제어 기능에 groupBy() 함수와 비슷한 별도의 Observable 분리 기능을 모두 갖추었다고 생각하면 된다.</li>
</ul>
<img src="/img/window.png" width="500" height="200">
<ul>
<li>count를 인자로 받는다. 예를 들어, 3을 인자로 받으면 앞으로 데이터 3개가 발행될 때마다 새로운 Observable을 생성하겠다는 뜻이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>현재 스레드를 그대로 활용한다. 왜 그런지 window() 함수의 다른 변형을 비교하면 알 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="keyword">long</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(</span><br><span class="line">    <span class="keyword">long</span> timespan, <span class="keyword">long</span> timeskip, TimeUnit unit</span><br><span class="line">)&#123; </span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count만을 인자로 갖는 window() 함수는 입력된 값을 그대로 발행하기 때문에 비동기 작업이라고 보기 어렵다.</li>
<li>위의 함수 원형에는 timespan이라는 시간 동안 입력된 값 중에서 일부를 무시하는 기능을 포함한다.</li>
<li>어떤 필터링 작업을 해줘야 하기 때문에 계산 스케줄러를 활용하게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">windowSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 데이터 3개씩 모아서 새로운 Observable 생성.</span></span><br><span class="line">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lateSource)</span><br><span class="line">                .window(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(observable -&gt; &#123;</span><br><span class="line">            Log.dt(<span class="string">"New Observable Started!!"</span>);</span><br><span class="line">            observable.subscribe(Log::it);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">        CommonUtils.exampleComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">365</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">366</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">461</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">560</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">963</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1062</span> | value = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>window() 함수의 인자로 3을 넣었다. 처음에 Observable을 생성하고 3개의 데이터를 전달받으면 새로운 Observable을 다시 생성하여 값을 발행한다.</li>
<li>1 값을 발행할 때와 4 값을 발행할 때 각각 새로운 Observable이 생성되었다.</li>
</ul>
<h2 id="debounce">debounce()</h2>
<ul>
<li>빠르게 연속 이벤트를 처리하는 흐름 제어 함수다.</li>
<li>안드로이드와 같은 UI 기반의 프로그래밍에서는 유용하게 활용할 수 있다.</li>
<li>예를 들어, 버튼을 빠르게 누르는 상황에서 마지막에 누른 이벤트만 처리해야할 때 간단하게 적용할 수 있다. RxJava를 이용하지 않는다면 마지막에 버튼을 누른 시간을 멤버 변수에 저장하고 일정 시간 동안 if문으로 예외 처리해야 하기 때문에 매우 번거롭고 실수할 가능성도 크다.</li>
</ul>
<img src="/img/debounce.png" width="500" height="200">
<ul>
<li>첫 번째 원은 지정한 시간 간격 안에 들어왔고 다른 이벤트는 없어서 그대로 발행되었다. 두 번째 원의 경우 시간 간격 안에 세 번째 원이 다시 들어왔으므로 두 번째가 아닌 세 번째 원을 발행한다. 마지막도 마찬가지다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 동작한다.</li>
<li><strong>어떤 이벤트가 입력되고 timeout에서 지정한 시간 동안 추가 이벤트가 발생하지 않으면 마지막 이벤트를 최종적으로 발행한다.</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">debounce</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">debounceSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>&#125;;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">0</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">1</span>]),</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">2</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">3</span>])</span><br><span class="line">        ).debounce(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>데이터를 발행하는 부분이 특이하다. 각각의 시간 간격이 서로 다르기 때문에 concat() 함수를 활용해 각가 데이터를 발행했다.</li>
<li>timer() 함수는 이벤트를 한 번만 발생시키고 완료하기 때문에 concat()과 timer() 함수의 조합은 유용하다.</li>
<li>debounce()를 활용해 어떤 이벤트가 입력되고 지정된 timeout인 200ms 안에 더 이상의 이벤트가 없으면 마지막에 입력된 값을 발행한다.</li>
<li>여기서 이해가 잘 안되었던 부분이 있었다. 결과를 예상해봤을 때, 1,2,5라고 생각했지만 아니었다. <strong>왜냐면 정의 자체가 어떤 이벤트가 입력되고 나서 timout 내에 더 이상의 이벤트가 없으면 마지막 이벤트를 발행하는 것이다.</strong> 그러니까 어떤 이벤트가 입력되고 나서 timout 내에 이벤트가 있는지 찾는 것이다. 그래서 결과는 1,3,5가 맞다.</li>
</ul>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Android/">Android</a> <a class="tag tag--primary tag--small t-link" href="/tags/RxJava/">RxJava</a> <a class="tag tag--primary tag--small t-link" href="/tags/디버깅/">디버깅</a> <a class="tag tag--primary tag--small t-link" href="/tags/흐름-제어/">흐름 제어</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/09/15/RxJava-Chap08/"
                    data-tooltip="[RxJava] Chap08. 테스팅과 Flowable"
                    aria-label="PREVIOUS: [RxJava] Chap08. 테스팅과 Flowable"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/08/21/Android-network-check/"
                    data-tooltip="[Android] Network State Check"
                    aria-label="NEXT: [Android] Network State Check"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/09/15/RxJava-Chap08/"
                    data-tooltip="[RxJava] Chap08. 테스팅과 Flowable"
                    aria-label="PREVIOUS: [RxJava] Chap08. 테스팅과 Flowable"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/08/21/Android-network-check/"
                    data-tooltip="[Android] Network State Check"
                    aria-label="NEXT: [Android] Network State Check"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://woovictory.github.io/2019/09/14/RxJava-Chap07-3/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
