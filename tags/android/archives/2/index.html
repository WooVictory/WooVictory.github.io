
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Android - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Android/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/06/13/Android-Share-ViewModel/"
                            aria-label=": [Android] Koin을 통한 Activity, Fragment의 ViewModel 공유"
                        >
                            [Android] Koin을 통한 Activity, Fragment의 ViewModel 공유
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-06-13T20:47:36+09:00">
	
		    Jun 13, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>최근에 간단하게 개발하면서 Fragment -&gt; Activity로 값을 전달하는 경우가 있었다. Activity -&gt; Fragment 방향으로 데이터를 전달할 때는 <code>Bundle</code> 객체를 사용하여 값을 담아서 전달한다. 그렇다면 반대의 경우는 어떻게 전달할 수 있을까??</p>
                    
                        <a
                            href="/2020/06/13/Android-Share-ViewModel/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] Koin을 통한 Activity, Fragment의 ViewModel 공유"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/06/12/Android-Font/"
                            aria-label=": [Android] Font 적용"
                        >
                            [Android] Font 적용
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-06-12T15:57:33+09:00">
	
		    Jun 12, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>안드로이드 스튜디오에서 기본으로 제공하는 폰트가 아닌 다른 폰트를 적용할 경우가 생긴다. 필자도 그랬다. 그래서 폰트 적용 방법을 소개하려고 한다.</p>
                    
                        <a
                            href="/2020/06/12/Android-Font/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] Font 적용"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/06/12/Android-Drawable/"
                            aria-label=": [Android] Drawable, Drawable v24 차이점"
                        >
                            [Android] Drawable, Drawable v24 차이점
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-06-12T15:05:04+09:00">
	
		    Jun 12, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>drawable, drawable-v24의 차이점에 대해 간략하게 정리하려고 한다. 많은 내용은 없고, 단지 차이점을 기록한다.</p>
<h3 id="차이점">차이점</h3>
<ul>
<li>drawable
<ul>
<li>비교적 오래된 <strong>Android version</strong>을 사용하는 기기에 호환하기 위한 폴더</li>
<li>API 24 누가 이전 버전의 기기를 호환한다.</li>
</ul>
</li>
<li>drawable-v24
<ul>
<li>비교적 최근에 나온 <strong>Android version</strong>을 사용하는 기기에 호환하기 위한 폴더</li>
<li>API 24 즉, 누가 버전 이상의 기기를 호환한다.</li>
</ul>
</li>
</ul>
<p>이렇게 나눠진 이유는 기기 호환성 및 <strong>Android version</strong>마다 다른 화면 밀도에 맞춰서 프로그램을 제공하기 위함이다.</p>
<h3 id="stack-overflow">stack overflow</h3>
<p>뭔가 내용이 부족하다. 그래서 조금 더 검색해서 찾아보니 <a href="https://stackoverflow.com/questions/34343611/newer-versions-of-android-studio-and-only-two-drawable-directory-drawable-and" target="_blank" rel="noopener">스택 오버플로우</a>에서 어떤 답변의 글을 링크하는 걸 볼 수 있었다.</p>
<p><strong>질문 내용</strong><br>
이전에는 Android Studio에서 모든 Drawable 폴더가 'drawable-mdpi, drawable-hdpi 등’처럼 생성되었다. 새로운 버전에서는 drawable, drawable-v21을 제공하는 데 왜 그런걸까?</p>
<p>이에 대한 답변이 달렸고 해석하면서 봤는데, 잘 이해가 가지 않았다. 결국 SVG를 가져와서 PNG로 변환한 뒤, 다음 빌드 시퀀스 중에 자동으로 생성한 해상도별 폴더에 배치한다고 한다. API 21 이전의 모든 버전에 대해 이 작업을 수행한다고 한다.</p>
<p>다른 내용은 이해가 잘 가지 않아서 적지는 않았고, 링크만 첨부하겠다. <a href="https://stackoverflow.com/questions/34343611/newer-versions-of-android-studio-and-only-two-drawable-directory-drawable-and" target="_blank" rel="noopener">스택오버플로우</a></p>
<p><strong>결국에는 drawable, drawable-v24 2개의 폴더로 나누었고, 이를 Android 내부에서 처리하여 자동으로 해상도별로 배치하는 것으로 이해가 된다. 따라서 개발자들이 여러 해상도의 이미지를 넣을 필요가 없어졌다는 것과 폴더가 2개이므로 관리가 쉬워졌다는 장점이 있는 것 같다.</strong></p>
<p>참고하면 좋은 글 : <a href="https://doolyit.tistory.com/114" target="_blank" rel="noopener">동해둘리</a></p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://atomic0x90.github.io/android-studio/2020/03/02/android-studio-drawable-v24-error.html" target="_blank" rel="noopener">drawable 과 drawable-v24 차이</a></li>
<li><a href="https://stackoverflow.com/questions/34343611/newer-versions-of-android-studio-and-only-two-drawable-directory-drawable-and" target="_blank" rel="noopener">stack overflow</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/06/12/Android-Drawable/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/06/12/Android-String-Resource/"
                            aria-label=": [Android] String Resource 관리하기"
                        >
                            [Android] String Resource 관리하기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-06-12T14:36:44+09:00">
	
		    Jun 12, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>오랜만에 포스팅하는 것 같다. 공부하면서 블로그보다 깃헙에 정리하다보니 블로그가 소홀했던 것 같다. 내 자신을 반성해야지…</p>
<p>아무튼, 오늘은 가벼운 내용을 정리하려고 한다. [<strong>안드로이드에서 문자열을 관리하는 방법</strong>]이다. 이 방법이 정답은 아니며, 모든 곳에서 통용되고 있는 건지도 모르겠다. 다만, 이렇게 관리하는 개발자가 많다는 건 사실인 것 같다.</p>
<h3 id="string-resource-관리">String Resource 관리</h3>
<p>사실, String을 관리하는 가장 쉬운 방법은 필요한 파일에서 정의해서 쓰는 것이다. 예를 들어, MainActivity에서 &quot;이름&quot;이라는 String이 필요하다면 해당 파일에서 정의하여 사용하면 된다. 그리고 xml에서 TextView에 text가 필요하다면 “text” 처럼 작성해도 된다.</p>
<p>하지만, 단기적으로 봤을 때는 이게 편하지만 장기적으로 보면 굉장히 불편한 작업이다. 화면이 많아지면서 &quot;이름&quot;이 필요한 곳이 많아질 수 있다. 그렇다면 필요한 파일마다 정의하는 건 번거로운 작업이다. 또한, 다국어 서비스를 지원한다면 더 번거로운 작업이 된다.</p>
<p>그렇다면 한 곳에서 관리하고 이를 사용하면 번거로운 작업을 벗어날 수 있을 것 같다는 생각이 든다. 역시나 안드로이드는 이러한 작업을 지원해준다.</p>
<ul>
<li>res/values 밑에 strings.xml 파일이 있다. 이 곳에 &quot;이름&quot;을 저장하고 필요한 곳에서 불러와 사용한다.</li>
<li>Code 상에서는 <code>context.getString(R.string.XXX)</code>와 같은 방식으로 접근한다.</li>
<li>XML에서는 <code>@string/name</code>과 같은 방식으로 접근한다.</li>
</ul>
<p>이를 통해 문자열을 한 곳에서 관리할 수 있게 된다. 따라서 번거로움이 줄어들고 문자열 관리의 통일성을 유지할 수 있게 되었다. 또한, 다국어 서비스를 지원할 때도 이전보다 번거로움이 줄어들었다는 장점이 존재한다.</p>
<p>추가적으로 <code>string-array</code>도 정의할 수 있어 로컬에서 필요한 문자열 배열이 있고, 이 배열의 값이 추가되거나 수정될 수 있으며 관리의 통일성을 유지하고 싶다면 strings.xml 파일에 저장하여 사용하는 것이 좋다고 생각한다.</p>
<p>이 방법이 강제되는 방법은 아니지만, 개발하면서 효율성을 조금은 향상시켜 줄 것이라고 생각한다. 이렇게 관리하지 않았다면 이 글을 보고 앞으로 효율적인 문자열 관리를 하기 바라고, 이런 방식으로 관리했다면 멋지다고 말하고 싶다.</p>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://developer.android.com/guide/topics/resources/string-resource?hl=ko" target="_blank" rel="noopener">Developers</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/06/12/Android-String-Resource/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/02/KotlinInAction-Chap7/"
                            aria-label=": [Kotlin in Action] Chap7. 연산자 오버로딩과 기타 관례"
                        >
                            [Kotlin in Action] Chap7. 연산자 오버로딩과 기타 관례
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-02T15:52:56+09:00">
	
		    Apr 02, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="목차">목차</h2>
<ul>
<li>연산자 오버로딩</li>
<li>관례 : 여러 연산을 지원하기 위해 특별한 이름이 붙은 메소드</li>
<li>위임 프로퍼티</li>
</ul>
<h3 id="overviews">OverViews</h3>
<p>어떤 클래스 안에 pluse라는 이름의 특별한 메소드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다. 이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법 -&gt; <code>관례</code></p>
<p>언어 기능을 타입에 의존하는 자바와 달리 코틀린은 함수 이름을 통한 관례에 의존한다.</p>
<p>이 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다. 기존 자바 클래스가 구현하는 인터페이스는 이미 고정되어 있다. 그래서 코틀린 쪽에서 자바 클래스가 새로운 인터페이스를 구현하도록 할 수 없다.</p>
<p>반면, 확장 함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다. 따라서 기존 자바 클래스에 대해 확장 함수를 구현하면서 관례에 따라 이름을 붙이면 기존 자바 코드를 바꾸지 않아도 새로운 기능을 부여할 수 있다.</p>
<p>이번 장에서는 Point라는 클래스를 예제로 사용할 것이다. 코드는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<h3 id="71-산술-연산자-오버로딩">7.1 산술 연산자 오버로딩</h3>
<p>자바는 원시 타입에 대해서만 산술 연산자를 정의할 수 있고, 추가적으로 String에 대해 + 연산자 사용이 가능하다.</p>
<p>하지만 다른 클래스에서도 유용한 경우가 있을 수 있다.</p>
<p>Ex) BigInteger 클래스의 add를 호출하기 보다는 +연산을 사용하는 편이 낫다.</p>
<p>어떻게 하는지 알아보자.</p>
<h4 id="711-이항-산술-연산-오버로딩">7.1.1 이항 산술 연산 오버로딩</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + other.x, y + other.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `포인트 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">val</span> p2 = Point(<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">        println(p + p2) <span class="comment">// p.plus(p2) 로 컴파일된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">Point(x=<span class="number">40</span>, y=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>연산자를 오버로딩 하는 함수 앞에 operator 키워드가 있어야 한다. 이를 통해 이 함수가 관례를 따르는 함수임을 명확하게 알 수 있다.</li>
<li>operator 없이 관례에서 사용하는 함수 이름을 쓰면 &quot;operator modifier is required … &quot; 오류를 접하게 된다.</li>
<li>즉, plus 처럼 미리 정해진 이름의 함수를 operator 키워드를 통해 선언하면 +와 연결되어 + 호출로 연산을 수행할 수 있다.</li>
</ul>
<p>연산자를 확장 함수로 정의할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">plus</span><span class="params">(other: <span class="type">Point</span>)</span></span>: Point&#123;</span><br><span class="line">  <span class="keyword">return</span> Point(x+other.x, y+other.y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고, 언어에서 미리 정해둔 연산자만 오버로딩할 수 있으며, 관례에 따르기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다.</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">식</th>
<th>함수 이름</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a*b</td>
<td>times</td>
</tr>
<tr>
<td style="text-align:left">a/b</td>
<td>div</td>
</tr>
<tr>
<td style="text-align:left">a%b</td>
<td>mod(1.1부터 rem)</td>
</tr>
<tr>
<td style="text-align:left">a+b</td>
<td>plus</td>
</tr>
<tr>
<td style="text-align:left">a-b</td>
<td>minus</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선순위와 같다.</li>
<li>연산자를 정의할 때, 두 피연산자는(연산자 함수의 두 파라미터) 같은 타입일 필요는 없다.</li>
<li>Ex) 어떤 점을 비율에 따라 확대 및 축소하는 연산자를 정의하면 아래와 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">times</span><span class="params">(scale: <span class="type">Double</span>)</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point((x * scale).toInt(), (y * scale).toInt())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `포인트 times 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  println(p.times(<span class="number">1.5</span>))</span><br><span class="line">  println(p * <span class="number">1.5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">Point(x=<span class="number">15</span>, y=<span class="number">30</span>)</span><br><span class="line">Point(x=<span class="number">15</span>, y=<span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린 연산자는 자동으로 교환 법칙을 지원하지 않는다.</li>
<li>따라서 <code>p * 1.5</code> 가 된다고 해서 <code>1.5 * p</code> 가 되지는 않는다. 역을 지원하기 위해서는 마찬가지로 역의 식에 대응하는 연산자 함수를 정의해야 한다.</li>
<li>또한, 연산자 함수의 반환 타입이 두 피연산자 중 하나와 일치하지 않아도 된다.</li>
<li>일반 함수와 마찬가지로 operator 함수도 오버로딩 가능하다. 따라서 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다.</li>
<li>대신 operator 함수는 파라미터의 개수는 1개밖에 정의하지 못한다. 이항 연산이기 때문!</li>
</ul>
<blockquote>
<p>비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다.</p>
</blockquote>
<p>코틀린은 표준 숫자 타입에 대해 비트 연산자를 정의하지 않는다. 따라서 커스텀 타입에서 비트 연산자를 정의할 수도 없다.</p>
<p>대신, 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산을 수행한다.</p>
<h4 id="712-복합-대입-연산자-오버로딩">7.1.2 복합 대입 연산자 오버로딩</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">point +=Point(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">println(point)</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">Point(x=<span class="number">4</span>, y=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>+=, -= 등의 연산자를 복합 대입 연산자라 부른다.</li>
<li>point +=Point(3,4) 식은 point = point + Point(3,4) 라고 쓴 식과 동일하다. 물론, 변경 가능한 경우에만 복합 대입 연산자를 사용할 수 있다.</li>
<li>+= 연산은 객체에 대한 참조를 다른 참조로 바꿔치기 한다.
<ul>
<li>point = point + Point(3,4)의 실행을 살펴보자. point의 plus는 새로운 객체를 반환한다.</li>
<li>point + Point(3,4)는 두 점의 좌표 각각 더한 값을 좌표로 갖는 새로운 Point 객체를 반환한다. 그 후 대입이 이뤄지면 point 변수는 새로운 Point 객체를 가리키게 된다.</li>
</ul>
</li>
<li>코틀린 표준 라이브러리는 MutableCollection에 대해 plusAssign을 정의하며, 아래와 같다. 이는 원래 객체의 내부 상태를 변경한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableCollection<span class="type">&lt;T&gt;</span>.<span class="title">plusAssign</span><span class="params">(element: <span class="type">T</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.add(element)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>+=를 plus와 plusAssign 양쪽으로 컴파일 할 수 있다. 어떤 클래스가 이 두 함수를 모두 정의하고 둘 다 +=에 사용 가능한 경우 컴파일러는 오류를 보여준다.</li>
<li>일반 연산자를 이용해 해결하거나 var를 val로 바꿔서 plusAssign 적용을 불가능하게 할 수도 있다.</li>
<li>하지만, 일반적으로 새로운 클래스를 일관성 있게 설계하는 게 가장 좋다. plus와 plusAssign을 동시에 정의하는 것을 피해야 한다.</li>
<li>코틀린은 컬렉션에 대해 두 가지 접근 방법을 제공한다.</li>
<li>+, -는 항상 새로운 컬렉션을 반환한다.</li>
<li>+=, -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다.</li>
<li>또한, 읽기 전용 컬렉션에서 +=, 0-는 변경을 적용한 복사본을 반환한다.</li>
<li>이런 연산자의 피연산자로 개별 원소를 사용하거나 원소 타입이 일치하는 다른 컬렉션을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">list +=<span class="number">3</span> <span class="comment">// 변경 가능한 컬렉션 list에 대해 +=을 통해 객체 상태를 변경.</span></span><br><span class="line"><span class="keyword">val</span> newList = list + listOf(<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// 두 리스트를 +로 합쳐 새로운 리스트를 반환.</span></span><br><span class="line">println(list)</span><br><span class="line">println(newList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="713-단항-연산자-오버로딩">7.1.3 단항 연산자 오버로딩</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">unaryMinus</span><span class="params">()</span></span>: Point &#123;</span><br><span class="line">    <span class="keyword">return</span> Point(-x, -y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `단항 연산자 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> p = Point(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">  println(-p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">Point(x=<span class="number">-10</span>, y=<span class="number">-20</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>이항 연산자의 오버로딩과 마찬가지로 미리 정해진 이름의 함수를 멤버나 확장 함수로 선언하면서 operator를 표시하면 된다.</li>
<li>단항 연산자를 오버로딩하기 위해 사용하는 함수는 인자를 취하지 않는다.</li>
</ul>
<p><strong>[오버로딩할 수 있는 단항 산술 연산자]</strong></p>
<table>
<thead>
<tr>
<th>식</th>
<th>함수 이름</th>
</tr>
</thead>
<tbody>
<tr>
<td>+a</td>
<td>unaryPlus</td>
</tr>
<tr>
<td>-a</td>
<td>unaryMinus</td>
</tr>
<tr>
<td>!a</td>
<td>not</td>
</tr>
<tr>
<td>++a, a++</td>
<td>inc</td>
</tr>
<tr>
<td>–a, a–</td>
<td>dec</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> BigDecimal.<span class="title">inc</span><span class="params">()</span></span> = <span class="keyword">this</span> + BigDecimal.ONE</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `증가 연산자 테스트`<span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bd= BigDecimal.ZERO</span><br><span class="line">  println(bd++) <span class="comment">// 0</span></span><br><span class="line">  println(bd) <span class="comment">// 1</span></span><br><span class="line">  println(++bd) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>후위 ++ 연산은 bd 값을 반환한 후, bd의 값을 증가시킨다.</li>
<li>전휘 ++ 연산은 그 반대로 동작한다.</li>
<li>전위와 후위 연산을 처리하기 위해 별다른 처리를 해주지 않아도 제대로 동작한다.</li>
</ul>
<h3 id="72-비교-연산자-오버로딩">7.2 비교 연산자 오버로딩</h3>
<p>equals, compareTo를 호출해야 하는 자바와 달리 코틀린에서는 == 비교 연산자를 직접 사용함으로써 코드가 간결하며 이해하기 쉬운 장점이 있다.</p>
<h4 id="721-동등성-연산자-equals">7.2.1 동등성 연산자 : equals</h4>
<ul>
<li>!= 연산자도 equals로 컴파일된다. 이는 비교 결과를 뒤집은 값을 결과값으로 사용한다.</li>
<li>==와 !=는 내부에서 인자가 널인지 검사하므로 다른 연산과 달리 널이 될 수 있는 값에도 적용할 수 있다. 아래 코드를 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a == b</span><br><span class="line"><span class="comment">// 위의 식은 아래처럼 컴파일 된다.</span></span><br><span class="line">a?.equals(b) ?: (b == <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>a가 널인지 판단해서 널이 아닌 경우에만 a.equals(b)를 호출한다.</li>
<li>만약 a가 널이라면 b도 널인 경우에만 결과가 true가 된다.</li>
<li>Point는 data class이므로 컴파일러가 자동으로 equals를 생성해준다. 구현한다면 아래와 같을 것이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)&#123;</span><br><span class="line">  <span class="keyword">override</span> equals(obj: Any?): <span class="built_in">Boolean</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> === obj) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(obj !<span class="keyword">is</span> Point) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x == obj.x &amp;&amp; y == obj.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>===(식별자 비교 연산자)를 사용해 equals의 파라미터가 수신 객체와 같은지 확인한다.</li>
<li>===는 자바의 == 연산자와 같다. 따라서 ===는 자신의 두 핀연산자가 서로 같은 객체를 가리키는지(원시 타입인 경우 두 값이 같은지) 비교한다.</li>
<li>===를 사용해 자기 자신과의 비교를 최적화하는 경우가 많으며, ===는 오버로딩할 수 없다.</li>
<li>Any의 equals에는 operator가 붙어있지만 그 메소드를 오버라이드하는 하위 클래스의 메소드 앞에는 operator를 붙이지 않아도 자동으로 상위 클래스의 operator 지정이 적용된다. 또한, Any에서 상속받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수 없다.</li>
</ul>
<h4 id="722-순서-연산자-compareto">7.2.2 순서 연산자 : compareTo</h4>
<ul>
<li>자바에서 정렬이나 최댓값, 최솟값 등 값을 비교하는 알고리즘에 사용할 클래스는 Comparable 인터페이스를 구현한다.</li>
<li>코틀린도 똑같은 Comparable 인터페이스를 지원한다. 게다가 코틀린은 Comparable 인터페이스 안에 있는 compareTo 메소드를 호출하는 관례를 제공한다.</li>
<li>따라서 비교 연산자 (&lt;, &gt;, &lt;=, &gt;=)는 compareTo 호출로 컴파일 된다.</li>
<li>반환값은 Int이다. 다른 비교 연산자도 동일한 방식으로 동작한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &gt;= b</span><br><span class="line"><span class="comment">// 위의 코드는 아래로 컴파일된다.</span></span><br><span class="line">a.compareTo(b) &gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"abc"</span> &lt; <span class="string">"bac"</span>)</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="73-컬렉션과-범위에-대해-쓸-수-있는-관례">7.3 컬렉션과 범위에 대해 쓸 수 있는 관례</h3>
<h4 id="731-인덱스로-원소에-접근-get-set">7.3.1 인덱스로 원소에 접근 : get, set</h4>
<ul>
<li>배열, 리스트, 맵에 접근할 때 []를 통해서 접근이 가능하다.</li>
<li>[]는 원소를 읽는 연산일 때는 get 연산자 메소드로 변환되고, 원소를 쓰는 연산은 set 연산자 메소드로 변환된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Point.<span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> (index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; x</span><br><span class="line">        <span class="number">1</span> -&gt; y</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">"Invalid coordinate <span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `<span class="keyword">get</span> 테스트`<span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> p = Point(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">  println(p[<span class="number">1</span>]) <span class="comment">// p[1] -&gt; p.get(1) 호출로 변환된다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>get 연산자를 정의한다.</li>
<li>get 메소드의 파라미터로 Int가 아닌 타입도 사용할 수 있다. 맵의 경우는 키 타입이 될 수도 있다.</li>
<li>여러 파라미터를 사용하는 get을 정의할 수도 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(rowIndex: <span class="type">Int</span>, colIndex:<span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matrix[row, col]로 호출한다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스에 해당하는 컬렉션 원소를 쓰고 싶을 때는 set 함수를 정의하면 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePoint</span></span>(</span><br><span class="line">    <span class="keyword">var</span> x: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> y: <span class="built_in">Int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> MutablePoint.<span class="title">set</span><span class="params">(index: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (index) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; x = value</span><br><span class="line">        <span class="number">1</span> -&gt; y = value</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IndexOutOfBoundsException(<span class="string">"Invalid coordinate <span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `<span class="keyword">set</span> 테스트`<span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> p = MutablePoint(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">  p[<span class="number">0</span>] = <span class="number">30</span> <span class="comment">// p[0] = 30 -&gt; p.set(30)</span></span><br><span class="line">  p[<span class="number">1</span>] = <span class="number">60</span> <span class="comment">// p[1] = 60 -&gt; p.set(60)</span></span><br><span class="line">  println(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">MutablePoint(x=<span class="number">30</span>, y=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>
<h4 id="732-in-관례">7.3.2 in 관례</h4>
<ul>
<li>객체가 컬렉션에 들어있는지 검사한다.</li>
<li>in 연산자와 대응하는 함수는 <strong>contains</strong>이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> upperLeft: Point, <span class="keyword">val</span> lowerRight: Point)</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> Rectangle.<span class="title">contains</span><span class="params">(p: <span class="type">Point</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.x <span class="keyword">in</span> upperLeft.x until lowerRight.x &amp;&amp;</span><br><span class="line">            p.y <span class="keyword">in</span> upperLeft.y until lowerRight.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `<span class="keyword">in</span> 테스트`<span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> rect = Rectangle(Point(<span class="number">10</span>, <span class="number">20</span>), Point(<span class="number">50</span>, <span class="number">50</span>))</span><br><span class="line">  println(Point(<span class="number">10</span>, <span class="number">30</span>) <span class="keyword">in</span> rect) <span class="comment">// a in rect -&gt; rect.contains(a)</span></span><br><span class="line">  println(Point(<span class="number">10</span>, <span class="number">50</span>) <span class="keyword">in</span> rect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>범위를 만들고 x, y 좌표가 그 범위 안에 있는지 검사한다.</li>
<li>until 함수를 사용해 열린 범위를 만든다.</li>
<li>열린 범위 : 끝 값을 포함하지 않는 범위를 말한다.
<ul>
<li>Ex) 10…20 식을 사용해 일반적인 (닫힌) 범위를 만들면 10 이상 20 이하인 범위가 생긴다.(20을 포함.)</li>
<li>Ex) 1o until 20으로 만드는 열린 범위는 10 이상 19이하인 범위며, 20은 범위 안에 포함되지 않는다.</li>
</ul>
</li>
</ul>
<h4 id="733-rangeto-관례">7.3.3 rangeTo 관례</h4>
<ul>
<li>1…10 : 1부터 10까지 모든 수가 들어있는 범위를 가리킨다.</li>
<li>… 연산자는 rangeTo 함수를 간략하게 표현하는 방법이다.</li>
<li>따라서 … 는 rangeTo로 컴파일된다.</li>
<li>범위를 반환하며, 아무 클래스에나 정의할 수 있다.</li>
<li>rangeTo 연산자는 다른 산술 연산자보다 우선순위가 낮다. 하지만 혼동을 피하기 위해 괄호로 감싸주는 것이 더 좋다.</li>
<li>또한, 범위 연산자는 우선 순위가 낮아서 범위의 메소드를 호출하려면 범위를 괄호로 둘러싸야 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> n = <span class="number">9</span></span><br><span class="line">println(<span class="number">0</span> .. (n + <span class="number">1</span>))</span><br><span class="line"><span class="number">0.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래 식은 컴파일할 수 없다.</span></span><br><span class="line"><span class="number">0.</span>.n.forEach&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래 코드처럼 범위의 메소드를 호출하려면 범위를 괄호로 둘러싸면 된다.</span></span><br><span class="line">(<span class="number">0.</span>.n).forEach&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>추가적으로 코틀린에서는 모든 Comparable 객체에 대해 적용 가능한 rangeTo 함수를 제공한다. rangeTo는 ClosedRange 객체를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Comparable&lt;T&gt;</span>&gt; T.<span class="title">rangeTo</span><span class="params">(that: <span class="type">T</span>)</span></span>: ClosedRange&lt;T&gt;</span><br></pre></td></tr></table></figure>
<h4 id="734-for-루프를-위한-iterator-관례">7.3.4 for 루프를 위한 iterator 관례</h4>
<ul>
<li>2장에서 살펴봤듯이 코틀린의 for 루프는 범위 검사와 똑같이 in 연산자를 사용한다.</li>
<li>하지만 의미는 다르다.</li>
<li>아래 코드는 list.iterator()를 호출해서 이터레이터를 얻은 다음, 자바와 마찬가지로 그 이터레이터에 대해 hasNext, next 호출을 반복하는 식으로 변환된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> list)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 또한 관례이므로 iterator 메소드를 확장 함수로 정의할 수 있다. 이런 성질로 인해 자바 문자열에 대한 for 루프가 가능하다.</li>
<li>코틀린은 String의 상위 클래스인 CharSequence에 대한 iterator 확장 함수를 제공한다. 따라서 아래와 같은 구문이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">iterator</span><span class="params">()</span></span>: CharIterator</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(c <span class="keyword">in</span> <span class="string">"abc"</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 안에 직접 iterator를 구현한 예이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> ClosedRange<span class="type">&lt;LocalDate&gt;</span>.<span class="title">iterator</span><span class="params">()</span></span>: Iterator&lt;LocalDate&gt; =</span><br><span class="line">        <span class="keyword">object</span> : Iterator&lt;LocalDate&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> current = start</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNext</span><span class="params">()</span></span> =</span><br><span class="line">                current &lt;= endInclusive</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">next</span><span class="params">()</span></span> = current.apply &#123;</span><br><span class="line">                current = plusDays(<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> newYear = LocalDate.ofYearDay(<span class="number">2017</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> daysOff = newYear.minusDays(<span class="number">1</span>)..newYear</span><br><span class="line">    <span class="keyword">for</span> (dayOff <span class="keyword">in</span> daysOff) &#123; println(dayOff) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>앞에서 rangeTo 함수가 ClosedRange 인스턴스를 반환한다. 코드에서 ClosedRange&lt; LocaDate &gt; 에 대한 확장 함수 Iterator를 정의했기 때문에 LocalDate의 범위 객체를 for 루프에서 사용할 수 있다.</li>
</ul>
<h3 id="74-구조-분해-선언과-component-함수">7.4 구조 분해 선언과 component 함수</h3>
<ul>
<li>구조 분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화할 수 있다.</li>
<li>구조 분해 선언은 일반 변수 선언과 비슷하다. 다만, = 좌변에 여러 변수를 괄호로 묶었다는 점이 다르다.</li>
</ul>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p = Point(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="keyword">val</span> (x,y) = p</span><br><span class="line">println(x)</span><br><span class="line">println(y)</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>내부에서 구조 분해 선언은 관레를 사용한다. 구조 분해 선언의 각 변수를 초기화하기 위해 componentN이라는 함수를 호출한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> (a,b) = p</span><br><span class="line"><span class="comment">// 위의 구조 분해 선언은 아래의 componentN() 함수 호출로 변환된다.</span></span><br><span class="line"><span class="keyword">val</span> a = p.component1()</span><br><span class="line"><span class="keyword">val</span> b = p.component2()</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>data class의 주 생성자에 있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN 함수를 만들어준다.</p>
</li>
<li>
<p>일반 클래스에서는 아래와 같이 구현한다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>, <span class="keyword">val</span> y: <span class="built_in">Int</span>)&#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = x</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>또한, 구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다.</li>
<li>여러 값을 반환해야 하는 함수가 있다면 반환해야 하는 모든 값이 들어갈 holder 역할의 데이터 클래스를 정의하고 함수의 반환 타입을 그 데이터 클래스로 바꾼다. 구조 분해 선언 구문을 사용해 이 함수가 반환하는 값을 쉽게 풀어 여러 변수에 넣을 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NameComponents</span></span>(<span class="keyword">val</span> name: String,</span><br><span class="line">                          <span class="keyword">val</span> extension: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">splitFilename</span><span class="params">(fullName: <span class="type">String</span>)</span></span>: NameComponents &#123;</span><br><span class="line">    <span class="keyword">val</span> result = fullName.split(<span class="string">'.'</span>, limit = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> NameComponents(result[<span class="number">0</span>], result[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> (name, ext) = splitFilename(<span class="string">"example.kt"</span>)</span><br><span class="line">  	<span class="comment">// 구조 분해 선언 구문을 사용해 데이터 클래스를 푼다.</span></span><br><span class="line">    println(name)</span><br><span class="line">    println(ext)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">example</span><br><span class="line">kt</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린은 맨 앞의 다섯 원소에 대한 componentN 함수를 제공한다. 따라서 컬렉션의 크기가 5보다 작아도 1~5까지접근이 가능하다. 하지만, IndexOutOfBoundsException이 발생한다.</li>
<li>여섯 개 이상의 변수를 사용하는 구조 분해를 컬렉션에 대해 적용하면 컴파일 오류가 발생한다.</li>
</ul>
<h4 id="741-구조-분해-선언과-루프">7.4.1 구조 분해 선언과 루프</h4>
<ul>
<li>변수 선언이 들어갈 수 있는 장소라면 어디든 구조 분해 선언을 사용할 수 있다.</li>
<li>맵의 원소에 대해 이터레이션할 때, 구조 분해 선언이 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(map: <span class="type">Map</span>&lt;<span class="type">String</span>, String)</span></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>((key, value) <span class="keyword">in</span> map)&#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$key</span> -&gt; <span class="variable">$value</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">"Oracle"</span> to <span class="string">"Java"</span>, <span class="string">"JetBrains"</span> to <span class="string">"Kotlin"</span>)</span><br><span class="line">print(map)</span><br><span class="line"><span class="comment">//Result</span></span><br><span class="line">Oracle -&gt; Java</span><br><span class="line">JetBrains -&gt; Kotlin</span><br></pre></td></tr></table></figure>
<ul>
<li>객체를 이터이션하는 관례, 구조 분해 선언 2가지 관례를 사용한다.</li>
<li>코틀린의 맵은 확장 함수로 iterator가 들어있다. 그 iterator는 맵 원소에 대한 이터레이터를 반환한다. 따라서 자바와 달리 코틀린에서는 맵을 직접 이터레이션할 수 있다.</li>
</ul>
<h3 id="75-프로퍼티-접근자-로직-재활용-위임-프로퍼티">7.5 프로퍼티 접근자 로직 재활용 : 위임 프로퍼티</h3>
<ul>
<li>위임이란 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 맡기는 디자인 패턴.</li>
<li>작업을 처리하는 객체를 위임 객체(delegate)라고 한다.</li>
</ul>
<h4 id="751-위임-프로퍼티">7.5.1 위임 프로퍼티</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> p : Type <span class="keyword">by</span> Delegate()</span><br><span class="line">  <span class="comment">// by 키워드는 프로퍼티와 위임 객체를 연결한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>p 프로퍼티는 접근자 로직을 다른 객체에게 위임한다. 여기서는 Delegate 클래스의 인스턴스를 위임 객체로 사용한다.</li>
<li>by 뒤에 있는 식을 계산해서 위임에 쓰일 객체를 얻는다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> delegate = Delegate()</span><br><span class="line">  <span class="keyword">val</span> p: Type</span><br><span class="line">  <span class="keyword">set</span>(value: Type) = delegate.setValue(..., value)</span><br><span class="line">  <span class="keyword">get</span>() = delegate.getValue(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드처럼 컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다.</li>
<li>p 프로퍼티는 바로 그 위임 객체에게 자신의 작업을 위임한다.</li>
<li>Delegate 클래스를 단순화하면 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span></span>&#123;</span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// getter를 구현하는 로직을 담는다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// setter를 구현하는 로직을 담는다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo = Foo()</span><br><span class="line"><span class="keyword">val</span> oldValue = foo.p <span class="comment">// 1</span></span><br><span class="line">foo.p = newValue <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1번과 같은 프로퍼티 호출은 내부에서 delegate.getValue()을 호출한다.</li>
<li>2번처럼 프로퍼티 값을 변경하는 문장은 내부에서 delegate.setValue(…, newValue)를 호출한다.</li>
</ul>
<h4 id="752-by-lazy를-사용한-프로퍼티-초기화-지연">7.5.2 by lazy()를 사용한 프로퍼티 초기화 지연</h4>
<ul>
<li>지연 초기화는 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우, 초기화할 때 흔히 쓰이는 패턴이다.</li>
<li>초기화 과정에 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화하지 않아도 되는 프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">loadEmails</span><span class="params">(person: <span class="type">Person</span>)</span></span>: List&lt;Email&gt; &#123;</span><br><span class="line">    println(<span class="string">"Load emails for <span class="subst">$&#123;person.name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> listOf(<span class="comment">/*...*/</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _emails: List&lt;Email&gt;? = <span class="literal">null</span></span><br><span class="line">  	<span class="comment">// 데이터를 저장하고 emails의 위임 객체 역할을 하는 _emails 프로퍼티.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> emails: List&lt;Email&gt;</span><br><span class="line">       <span class="keyword">get</span>() &#123;</span><br><span class="line">           <span class="keyword">if</span> (_emails == <span class="literal">null</span>) &#123;</span><br><span class="line">               _emails = loadEmails(<span class="keyword">this</span>) <span class="comment">// 최초 접근 시 이메일을 가져온다.</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> _emails!! <span class="comment">// 저장해둔 데이터가 있으면 그 데이터를 반환한다.</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person(<span class="string">"Alice"</span>)</span><br><span class="line">    p.emails <span class="comment">// 최초로 emails를 읽을 때 단 한번만 이메일을 가져온다.</span></span><br><span class="line">    p.emails</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>뒷받침하는 프로퍼티라는 기법을 사용한다.</li>
<li>_emails 프로퍼티는 값을 저장하고, emails 프로퍼티는 _emails 프로퍼티에 대한 읽기 연산을 제공한다. _emails는 Nullable 하고, emails는 널이 될 수 없는 타입이므로 프로퍼티 2개를 사용해야 한다. 이런 기법은 자주 사용된다.</li>
<li>이와 같은 방법은 성가시며, 스레드 안전하지 않아서 언제나 제대로 동작한다고 말할 수 없다.</li>
<li>대신 위임 프로퍼티를 사용해보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> emails <span class="keyword">by</span> lazy &#123; loadEmails(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person(<span class="string">"Alice"</span>)</span><br><span class="line">    p.emails</span><br><span class="line">    p.emails</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lazy 함수는 코틀린 관례에 맞는 시그니처의 getValue() 메소드가 들어있는 객체를 반환한다. 따라서 lazy와 by 키워드와 함께 사용해 위임 프로퍼티를 만들 수 있다.</li>
<li>lazy 함수의 인자는 값을 초기화할 때 호출할 람다다. 그리고 lazy 함수는 기본적으로 스레드 안전하다. 추가적으로 필요에 따라 동기화에 사용할 락을 lazy 함수에 전달할 수도 있고, 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 lazy 함수가 동기화를 하지 못하게 막을 수도 있다.</li>
</ul>
<h4 id="753-위임-프로퍼티-사용">7.5.3  위임 프로퍼티 사용</h4>
<ul>
<li>위임 프로퍼티를 사용해서 변경을 통지해주는 부분의 코드를 작성해 처음부터 리팩토링 해나가는 과정을 보여주고 있습니다.</li>
<li>설명하기 보다는 직접 읽어보는 것이 좋을 것 같아서 정리하지 않았으니 양해 바랍니다 😁</li>
</ul>
<h4 id="754-위임-프로퍼티-컴파일-규칙">7.5.4 위임 프로퍼티 컴파일 규칙</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prop : Type <span class="keyword">by</span> MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c = C()</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 MyDelegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티는 <delegate> 라는 이름으로 부른다. 또한, 컴파일러는 프로퍼티를 표현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 <property>라고 부른다.</property></delegate></li>
<li>컴파일러는 다음의 코드를 생성한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> &lt;delegate&gt; = MyDelegate()</span><br><span class="line">  <span class="keyword">var</span> prop : Type</span><br><span class="line">  <span class="keyword">get</span>() = &lt;delegate&gt;.getValue(<span class="keyword">this</span>, &lt;property&gt;)</span><br><span class="line">  <span class="keyword">set</span>(value: Type) = &lt;delegate&gt;.setValue(<span class="keyword">this</span>, &lt;property&gt;, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this는 C 클래스를 가리킨다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 모든 프로퍼티 접근자 안에 getValue, setValue 호출 코드를 생성해준다.</li>
<li>이 매커니즘은 상당히 단순하지만, 상당히 흥미로운 활용법이 많다고 한다.</li>
<li>프로퍼티 값이 저장될 장소를 바꿀 수도 있고(맵, 데이터베이스 테이블, 사용자 세션의 쿠키 등) 프로퍼티를 읽거나 쓸 때 벌어질 일을 변경할 수도 있다.(값 검증, 변경 통지 등) 이 모두를 간결한 코드로 달성할 수 있다.</li>
<li>아직까지 위임 프로퍼티를 사용해 본 경험은 없다. 그래서 이 내용이 와닿지 않지만, 저런 식으로 사용하면 확실히 간결하게 코드를 작성할 수 있고 여러 일을 수행하는 객체가 있다면 Delegate 패턴을 사용해 역할을 어느 정도 위임해 분리할 수 있지 않을까란 생각을 해봤다.</li>
<li>아래의 링크가 Delegate 패턴에 대해 설명하고 있으니 참고하면 좋을 것 같습니다.
<ul>
<li><a href="https://the-earth.tistory.com/entry/Delegate-pattern-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener">Delegate 패턴</a></li>
<li><a href="https://skkcha.tistory.com/32" target="_blank" rel="noopener">[Java][정리] 위임(delegation)과 구현/포함(Composite) 개념</a></li>
</ul>
</li>
</ul>
<h4 id="755-프로퍼티-값을-맵에-저장">7.5.5 프로퍼티 값을 맵에 저장</h4>
<ul>
<li>자신의 프로퍼티를 동적으로 정의할 수 있는 객체를 만들 때, 위임 프로퍼티를 활용하는 경우가 자주 있다. 그런 객체를 <strong>확장 가능한 객체</strong>(expando object)라고한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 추가 정보</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 필수 정보</span></span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">        <span class="keyword">get</span>() = _attributes[<span class="string">"name"</span>]!!</span><br><span class="line">  	<span class="comment">// 수동으로 맵에서 정보를 꺼낸다.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = mapOf(<span class="string">"name"</span> to <span class="string">"Dmitry"</span>, <span class="string">"company"</span> to <span class="string">"JetBrains"</span>)</span><br><span class="line">    <span class="keyword">for</span> ((attrName, value) <span class="keyword">in</span> <span class="keyword">data</span>)</span><br><span class="line">       p.setAttribute(attrName, value)</span><br><span class="line">  </span><br><span class="line">    println(p.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result</span></span><br><span class="line">Dmitry</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드를 위임 프로퍼티를 활용하여 변경할 수 있다. by 키워드 뒤에 맵을 직접 넣으면 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _attributes = hashMapOf&lt;String, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAttribute</span><span class="params">(attrName: <span class="type">String</span>, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        _attributes[attrName] = value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name: String <span class="keyword">by</span> _attributes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Person()</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = mapOf(<span class="string">"name"</span> to <span class="string">"Dmitry"</span>, <span class="string">"company"</span> to <span class="string">"JetBrains"</span>)</span><br><span class="line">    <span class="keyword">for</span> ((attrName, value) <span class="keyword">in</span> <span class="keyword">data</span>)</span><br><span class="line">       p.setAttribute(attrName, value)</span><br><span class="line">    println(p.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이와 같은 코드가 동작하는 이유는 표준 라이브러리가 Map과 MutableMap 인터페이스에 대해 getValue, setValue 확장 함수를 제공하기 때문이다.</li>
<li>getValue에서 맵에 프로퍼티 값을 저장할 때는 자동으로 프로퍼티 이름을 키로 활용한다.</li>
<li><a href="http://p.name" target="_blank" rel="noopener">p.name</a> -&gt; _attributes.getValue(p, prop)라는 호출을 대신한다.</li>
<li>이는 다시 _attributes.getValue(p, prop) -&gt; _attributes[<a href="http://prop.name" target="_blank" rel="noopener">prop.name</a>]을 통해 구현된다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/02/KotlinInAction-Chap7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/02/KotlinInAction-Chap6/"
                            aria-label=": [Kotlin in Action] Chap6. 코틀린 타입 시스템"
                        >
                            [Kotlin in Action] Chap6. 코틀린 타입 시스템
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-02T15:40:07+09:00">
	
		    Apr 02, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h4 id="1-널-가능성nullability">1. 널 가능성(Nullability)</h4>
<ul>
<li>물음표 기호 ’ ? '를 사용하여 Null이 될 수 있는 여부를 컴파일러가 미리 감지하게 함.</li>
<li>NPE처리를 위해 Nullable타입을 명시적으로 지원</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">strLen</span><span class="params">(@NotNull String s1, @Nullable String s2)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s1 : <span class="type">String</span>, s2 : <span class="type">String</span>?)</span></span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLen</span><span class="params">(s : <span class="type">String</span>)</span></span> = s.length</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe</span><span class="params">(s : <span class="type">String</span>?)</span></span> = s!!.length	<span class="comment">//모순...</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">strLenSafe2</span><span class="params">(s : <span class="type">String</span>?)</span></span> = <span class="keyword">if</span>(s != <span class="literal">null</span>) s.length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(strLen(<span class="string">"abc"</span>))			<span class="comment">// 3</span></span><br><span class="line">    println(strLenSafe(<span class="string">"abc"</span>))		<span class="comment">// 3</span></span><br><span class="line">    println(strLenSafe2(<span class="string">"abc"</span>))		<span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> x: String? = <span class="literal">null</span></span><br><span class="line">    println(strLenSafe(x))			<span class="comment">// ? </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Kotlin에서는 NPE가 일어나지 않는가?</strong></p>
</blockquote>
<ul>
<li>NullPointerException을 상속한 KotlinNullPointerException이 발생</li>
<li>인자로 넘겨준 값이 Nullable이라면 함수내에서도 Nullable 통일!</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinNullPointerException</span> : <span class="type">NullPointerException &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(message: String?) : <span class="keyword">super</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-safe-call-연산자">1.1 Safe Call 연산자</h4>
<ul>
<li>Safe Call 연산자는 ’ .? ’ 을 붙여 사용</li>
<li>Null검사와 메소드 호출을 한 번의 연산으로 수행</li>
</ul>
<p>Ex.1) Safe Call 연쇄시키기1</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAllCaps</span><span class="params">(s: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> allCaps: String? = s?.toUpperCase()</span><br><span class="line">    println(allCaps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    printAllCaps(<span class="string">"abc"</span>)			<span class="comment">//ABC</span></span><br><span class="line">    printAllCaps(<span class="literal">null</span>)			<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ex.2) Safe Call 연쇄시키기2</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(<span class="keyword">val</span> streetAddress: String, <span class="keyword">val</span> zipCode: <span class="built_in">Int</span>,</span><br><span class="line">              <span class="keyword">val</span> city: String, <span class="keyword">val</span> country: String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> address: Address?)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> company: Company?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">countryName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">val</span> country = <span class="keyword">this</span>.company?.address?.country</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">if</span> (country != <span class="literal">null</span>) country <span class="keyword">else</span> <span class="string">"Unknown"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(name = <span class="string">"Dmitry"</span>, company = <span class="literal">null</span>)</span><br><span class="line">    println(person.countryName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>생각해보자!</strong></p>
</blockquote>
<p>위의 <strong>Safe Call 연산자</strong>를 보고 처음엔 읽기 불편했지만 아래의 예시를 보고 느낌이 왔다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> country = <span class="keyword">this</span>.company?.address?.country</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> (country != <span class="literal">null</span>) country <span class="keyword">else</span> <span class="string">"Unknown"</span></span><br></pre></td></tr></table></figure>
<p>저 부분만 Java로 변환하면</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.getCompany() != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.getCompany().getAddress() != <span class="keyword">null</span> </span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.getCompany().getAddress().getCountry() != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"> String country = <span class="keyword">this</span>.getCompany().getAddress().getCountry();</span><br><span class="line"> <span class="keyword">return</span> country;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"Unknown"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-elvis-연산자">1.2 Elvis 연산자</h4>
<ul>
<li><strong>널복합 연산자</strong>(Null coalescing) 라고도 함</li>
<li>이항연산자로 좌항을 계산한 값이 Null인 경우, 특정 값(우항)으로 값을 할당</li>
<li>예외 처리에 유용</li>
<li>삼항 연산자 + Null 처리(Kotlin에서는 삼항 연산자를 지원하지 않음)</li>
</ul>
<p>Ex .1)  Safe Call 연산자 vs Elvis 연산자</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Safe Call 연산자</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">countryName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">val</span> country = <span class="keyword">this</span>.company?.address?.country</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">if</span> (country != <span class="literal">null</span>) country <span class="keyword">else</span> <span class="string">"Unknown"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Elvis 연산자</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">countryName</span><span class="params">()</span></span> = <span class="keyword">this</span>.company?.address?.country ?: <span class="string">"Unknown"</span></span><br></pre></td></tr></table></figure>
<p>Ex.2) Elvis 연산자를 이용한 예외 처리</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>(<span class="keyword">val</span> streetAddress: String, <span class="keyword">val</span> zipCode: <span class="built_in">Int</span>,</span><br><span class="line">              <span class="keyword">val</span> city: String, <span class="keyword">val</span> country: String)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> address: Address?)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> company: Company?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printShippingLabel</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> address = person.company?.address</span><br><span class="line">      ?: <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"No address"</span>)</span><br><span class="line">    with (address) &#123;</span><br><span class="line">        println(streetAddress)</span><br><span class="line">        println(<span class="string">"<span class="variable">$zipCode</span> <span class="variable">$city</span>, <span class="variable">$country</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> address = Address(<span class="string">"Elsestr. 47"</span>, <span class="number">80687</span>, <span class="string">"Munich"</span>, <span class="string">"Germany"</span>)</span><br><span class="line">    <span class="keyword">val</span> jetbrains = Company(<span class="string">"JetBrains"</span>, address)</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">"Dmitry"</span>, jetbrains)</span><br><span class="line">    printShippingLabel(person)	<span class="comment">//Elsestr. 47</span></span><br><span class="line">    <span class="comment">//80687 Munich, Germany</span></span><br><span class="line">    printShippingLabel(Person(<span class="string">"Alexey"</span>, <span class="literal">null</span>))	  <span class="comment">//java.lang.IllegalArgumentException: No address</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-type-cast-연산자-as-와-safe-cast-as">1.3  Type Cast 연산자  : as 와 Safe Cast :as?</h4>
<ul>
<li>as?는 변환 가능한 타입인지 검사 후, 아니면 Null값 반환</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> firstName: String, <span class="keyword">val</span> lastName: String) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">equals</span><span class="params">(o: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> otherPerson = o <span class="keyword">as</span>? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> otherPerson.firstName == firstName &amp;&amp;</span><br><span class="line">            otherPerson.lastName == lastName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hashCode</span><span class="params">()</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">    firstName.hashCode() * <span class="number">37</span> + lastName.hashCode()</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p1 = Person(<span class="string">"Dmitry"</span>, <span class="string">"Jemerov"</span>)</span><br><span class="line">    <span class="keyword">val</span> p2 = Person(<span class="string">"Dmitry"</span>, <span class="string">"Jemerov"</span>)</span><br><span class="line">    println(p1 == p2)					<span class="comment">//true</span></span><br><span class="line">    println(p1.equals(<span class="number">42</span>))				<span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    println(<span class="string">"p1 HashCode : "</span> + p1.hashCode())</span><br><span class="line">    println(<span class="string">"p1 HashCode : "</span> + p2.hashCode())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>심화학습…</strong>	//혼자 다 설명할 수 없음…</p>
</blockquote>
<p>위의 코드를 보면, 뜬금없이 hashCode를 재정의한 것을 볼 수 있는데</p>
<p>그 이유를 간략히 설명하자면, Effective Java에서는 다음과 같이 설명한다.<br>
<code>equals를 재정의한 클래스에서는 hashcode도 재정의 해야한다.</code><br>
그렇지 않으면 hash를 사용하는 HashMap, HashSet과 같은 컬렉션의 원소로 사용될 때 문제가 발생할 것이다.</p>
<p>따라서, eqauls를 재정의 하는 경우 다음 3가지 규약을 지켜야한다.</p>
<ul>
<li>equals비교에 사용되는 정보가 변경되지 않았다면, 객체의 hashcode 메서드는 몇번을 호출해도 항상 일관된 값을 반환해야 한다.<br>
(단, Application을 다시 실행한다면 값이 달라져도 상관없다. (메모리 소가 달라지기 때문))</li>
<li>equals메서드 통해 두 개의 객체가 같다고 판단했다면, 두 객체는 똑같은 hashcode 값을 반환해야 한다.</li>
<li>equals메서드가 두 개의 객체를 다르다고 판단했다 하더라도, 두 객체의 hashcode가 서로 다른 값을 가질 필요는 없다. (Hash Collision) 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.</li>
<li>참고
<ol>
<li>HashCode() 재정의 이유 : <a href="https://jaehun2841.github.io/2019/01/12/effective-java-item11/#%EC%84%9C%EB%A1%A0" target="_blank" rel="noopener">https://jaehun2841.github.io/2019/01/12/effective-java-item11/#서론</a></li>
<li>37을 곱한 이유 : <a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">https://d2.naver.com/helloworld/831311</a></li>
</ol>
</li>
</ul>
<h4 id="14-널-아님-단언not-null-assertion">1.4 널 아님 단언(Not-null Assertion)</h4>
<ul>
<li>널 아님 단언은 ’ !! '로 표현</li>
<li>컴파일러에게 &quot;나는 이 값이 null이 아님을 잘 알고있으며, 예외가 발생해도 감수하겠다&quot;라는 표현</li>
</ul>
<p>Ex.1) Swing(프레임워크)에서 널 아님 단언 사용</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyRowAction</span></span>(<span class="keyword">val</span> list: JList&lt;String&gt;): AbstractAction()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> = list.selectedValue != <span class="literal">null</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">actionPerformed</span><span class="params">(e : <span class="type">ActionEvent</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> value = list.selectedValue!!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>한 줄에 나란히 널 아님 단언이 쓰였을 경우, 어떤 식에서 발생한 예외인지 알 수 없으니 나란히 사용은 피하자</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.company!!.address!!.country</span><br></pre></td></tr></table></figure>
<h4 id="15-let함수">1.5 let함수</h4>
<ul>
<li>널이 될 수 있는 값(Nullable)을 널이 아닌 값(NotNull)만 인자로 받을 때, 용이하게 사용</li>
<li>여러 값에 대한 null 체크 시, let을 중첩해서 사용하면 코드가 복잡해지므로 피하는 것이 좋다.
<ul>
<li>(if (something != null) 사용을 권장)</li>
</ul>
</li>
</ul>
<p>Ex.1) let을 사용해 Null이 아닌 인자로 함수 호출하기</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendEmailTo</span><span class="params">(email: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Sending email to <span class="variable">$email</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> email: String? = <span class="string">"yole@example.com"</span></span><br><span class="line">    email?.let &#123; sendEmailTo(it) &#125;		<span class="comment">//Sending email to yole@example.com</span></span><br><span class="line">    email = <span class="literal">null</span></span><br><span class="line">    email?.let &#123; sendEmailTo(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>let을 호출하면 람다의 인자인 it은 널이 될 수 있는 타입으로 추론됨</p>
</blockquote>
<h4 id="16-lateinit-변경자">1.6 lateinit 변경자</h4>
<ul>
<li>lateinit 변경자를 사용하면 Nullable, NotNull을 난잡하게 사용하지않고 프로퍼티를 나중에 초기화 할 수 있다.</li>
<li>프로퍼티가 val인 경우는 적용할 수 없고, 항상 var여야만 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">performAction</span><span class="params">()</span></span>: String = <span class="string">"foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> myService: MyService? = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//lateinit 변경자 선언 시</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">lateinit</span> myService : MyService</span><br><span class="line">    <span class="meta">@Before</span> <span class="function"><span class="keyword">fun</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        myService = MyService()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="function"><span class="keyword">fun</span> <span class="title">testAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Assert.assertEquals(<span class="string">"foo"</span>, myService!!.performAction())</span><br><span class="line">        <span class="comment">//lateinit 변경자로 선언 시,</span></span><br><span class="line">        Assert.assertEquals(<span class="string">"foo"</span>, myService.performAction())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lateinit에 대한 초기화진행 여부를 확인하기 위해서는 ex) ::myService.isInitialized 형태로 분기처리하여 확인할 수 있다</li>
</ul>
<h4 id="17-널-가능-타입의-확장">1.7 널 가능 타입의 확장</h4>
<ul>
<li>null이 될 수 있는 타입에 대한 확장함수를 정의하면, Safe Call을 하지않아도 된다.</li>
</ul>
<p>Ex.1) Null이 될 수 있는 수신 객체에 대해 확장 함수 호출</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">verifyUserInput</span><span class="params">(input: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input.isNullOrBlank()) &#123;	<span class="comment">//&lt;- input이 Nullable이지만 Safe Call 연산자를 쓰지않음</span></span><br><span class="line">        println(<span class="string">"Please fill in the required fields"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    verifyUserInput(<span class="string">" "</span>)		<span class="comment">//Please fill in the required fields</span></span><br><span class="line">    verifyUserInput(<span class="literal">null</span>)		<span class="comment">//Please fill in the required fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//String에서의 확장함수 정의</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> CharSequence?.<span class="title">isNullOrBlank</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        returns(<span class="literal">false</span>) implies (<span class="keyword">this</span><span class="symbol">@isNullOrBlank</span> != <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == <span class="literal">null</span> || <span class="keyword">this</span>.isBlank()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="18-타입-파라미터의-널-가능성">1.8 타입 파라미터의 널 가능성</h4>
<ul>
<li>Kotlin에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다.(t를 Any 타입으로 추론하기 때문)</li>
<li>타입 파라미터는 타입 상한을 지정하지 않는다면 Null이 될 수 있다.(t를 Any?의 타입으로 추론하기 때문)</li>
</ul>
<p>Ex.)  널이 될 수 있는 타입파라미터와 상한 지정</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//널이 될 수 있는 타입 파라미터</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    println(t?.hashCode())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    printHashCode(<span class="literal">null</span>)		<span class="comment">//null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//상한을 지정한 타입 파라미터</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> <span class="title">printHashCode</span><span class="params">(t: <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    println(t.hashCode())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    printHashCode(<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">//Type parameter bound for T in fun &lt;T : Any&gt; printHashCode(t: T): Unit is not satisfied</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>참고: <a href="https://stackoverflow.com/questions/54760309/why-i-cant-assign-nullable-type-to-any-in-kotlin" target="_blank" rel="noopener">https://stackoverflow.com/questions/54760309/why-i-cant-assign-nullable-type-to-any-in-kotlin</a></p>
<h4 id="19-플랫폼-타입">1.9 플랫폼 타입</h4>
<ul>
<li>플랫폼 타입은 Kotlin이 널 관련 정보를 알 수 없는 Java 타입을 지칭</li>
<li>Kotlin은 보통 NotNull타입의 값에 대해 널 안정성을 검사하지만 플랫폼 타입의 값에 대해서는 경고하지않음</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">yellAtSafe</span><span class="params">(person: <span class="type">Person</span>)</span></span> &#123;</span><br><span class="line">    println(person.name.toUpperCase() + <span class="string">"!!!"</span>)</span><br><span class="line">    <span class="comment">//toUpperCase()의 수신객체의 person.name이 non-null인데 null이라 컴파일 에러 </span></span><br><span class="line">    println((person.name ?: <span class="string">"Anyone"</span>).toUpperCase() + <span class="string">"!!!"</span>)</span><br><span class="line">    <span class="comment">//ANYONE!!!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    yellAtSafe(Person(<span class="literal">null</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>전부 다 널이 될 수 있는 타입으로 하면 되지않을까?</strong><br>
모든 자바 타입을 널이 될 수 있는 타입으로 처리하기엔 널 안정성 검사로 인해 얻는 이익보다 쓸데없는 비용이 늘어나 프로그래머에게 타입의 널 가능성의 책임을 부여함.</p>
</blockquote>
<h4 id="110-상속">1.10 상속</h4>
<ul>
<li>자바클래스를 코틀린에서 상속할때, 파라미터나 반환타입의 Null처리를 결정해야함</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StringProcessor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPrinter</span> : <span class="type">StringProcessor&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">String</span>)</span></span>&#123;		<span class="comment">// notnull 선언</span></span><br><span class="line">        println(value)		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullableStringPrinter</span> : <span class="type">StringProcessor&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(value: <span class="type">String</span>?)</span></span>&#123;		<span class="comment">//nullable 선언</span></span><br><span class="line">        value?.let&#123;println(it)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-코틀린의-원시-타입">2. 코틀린의 원시 타입</h4>
<ul>
<li>Kotlin은 원시타입과 참조타입을 구분하지 않고, 항상 같은 타입을 사용</li>
<li>대부분, Kotlin의 Int타입은 Java의 int 타입으로 컴파일 되고, Int를 타입인자로 넘기는 경우 Integer로 컴파일된다.</li>
</ul>
<h4 id="21-null이-될-수-있는-원시타입-int-boolean-등">2.1 null이 될 수 있는 원시타입 : Int?, Boolean? 등</h4>
<ul>
<li>코틀린에서 null이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일 된다.</li>
</ul>
<p>Ex.)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>? = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isOlderThan</span><span class="params">(other: <span class="type">Person</span>)</span></span> : <span class="built_in">Boolean</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> (age == <span class="literal">null</span> || other.age == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> age &gt; other.age    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(Person(<span class="string">"Sam"</span>, <span class="number">35</span>).isOlderThan(Person(<span class="string">"Amy"</span>, <span class="number">42</span>))) <span class="comment">//false</span></span><br><span class="line">    println(Person(<span class="string">"Sam"</span>, <span class="number">35</span>).isOlderThan(Person(<span class="string">"Jane"</span>)))	  <span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>age는 컴파일러에 의해 널 안정성 검사를 마친 후 값을 비교가 허용되므로, age의 프로퍼티값은래퍼 타입으로 저장된다.</li>
</ul>
<h4 id="22-숫자-변환">2.2 숫자 변환</h4>
<ul>
<li>Kotlin은 Boolean을 제외한 모든 원시 타입에 대한 변환 함수를 제공</li>
<li>Kotlin은 한 타입의 숫자를 다른 타입으로 자동변환 하지 않음.</li>
<li>명시적으로 변환 메소드를 사용해야함</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> l = <span class="built_in">Long</span> = i  <span class="comment">// "Error: type mismatch" 컴파일 오류 발생</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> l: <span class="built_in">Long</span> = i.toLong()	<span class="comment">// 명시적으로 변환 메소드 사용</span></span><br><span class="line"></span><br><span class="line">---------------------------명시 이유---------------------------</span><br><span class="line"><span class="keyword">val</span> x = <span class="number">1</span>  <span class="comment">// Int</span></span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>L, <span class="number">2</span>L, <span class="number">3</span>L) <span class="comment">// Long 리스트 </span></span><br><span class="line">x <span class="keyword">in</span> list <span class="comment">// 묵시적 타입 변환으로 인해 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">1</span></span><br><span class="line">println(x.toLong() <span class="keyword">in</span> listOf(<span class="number">1</span>L, <span class="number">2</span>L, <span class="number">3</span>L)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(l: <span class="type">Long</span>)</span></span> = pinrtln(l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// 상수 값는 적절한 타입으로 해석 된다.</span></span><br><span class="line"><span class="keyword">val</span> l = b + <span class="number">1</span>L  <span class="comment">// +는 Byte와 Long을 인자로 받을 수 있다.</span></span><br><span class="line">foo(<span class="number">42</span>)         <span class="comment">// 함수 인자이므로 42를 Long으로 해석한다.</span></span><br></pre></td></tr></table></figure>
<h4 id="23-any-any-최상위-타입">2.3 Any, Any? : 최상위 타입</h4>
<ul>
<li>Java는 Object, Kotlin은 Any가 널이 될 수 없는 타입의 최상위타입</li>
<li>내부적으로 Any는 자바의 java.lang.Object로 컴파일 된다.</li>
<li>모든 코틀린 클래스에는 toString, equals, hashCode 라는 3개의 메소드가 있다. 하지만 java.lang.Object에 있는 다른 메소드(wait나 notify 등)는 Any에서 사용할 수 없다. 그런 메소드를 사용하고 싶다면 java.lang.Object로 캐스트해야 한다.</li>
</ul>
<h4 id="24-unit-타입-kotlin의-void">2.4 Unit 타입 : Kotlin의 void</h4>
<ul>
<li>Kotlin의 Unit타입은 Java의 void와 같은 기능을 함.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span>: <span class="built_in">Unit</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">f</span><span class="params">()</span></span>&#123;...&#125;		<span class="comment">//fun의 기본 선언은 void라고 생각</span></span><br></pre></td></tr></table></figure>
<p>Ex.) void 와Unit의 차이</p>
<ul>
<li>반환 타입으로 Unit을 반환가능</li>
<li>타입 매개변수로 Unit을 쓸 수 있다</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Processor</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//반환 타입으로 Unit을 묵시적으로 반환 가능</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoResultProcessor</span> : <span class="type">Processor</span>&lt;<span class="type">Unit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 업무 처리 코드</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultProcessor</span> : <span class="type">Processor</span>&lt;<span class="type">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 업무 처리 코드</span></span><br><span class="line">        <span class="keyword">return</span> someInt</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Kotlin은 왜 void가 아닌 Unit을 만들었을까?</strong><br>
Kotlin의 Unit은 Java의 void와 다르게 두 가지 특징을 가진다</p>
</blockquote>
<ol>
<li>Unit은 싱글톤 인스턴스이다. 그래서 Kotlin에서 Unit이라는 키워드는 타입이면서도 동시에 객체</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unit : <span class="built_in">Unit</span> = <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Unit은 객체이기도 하기때문에 Any를 상속하는 서브 클래스이다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unit : Any = <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>
<h4 id="25-nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다">2.5 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다.</h4>
<ul>
<li>함수가 정상적으로 끝나지 않는 사실을 표현할 때 사용</li>
<li>Nothing 타입은 아무 값도 포함하지 않음 = return이라는 행위 자체를 하지않음</li>
</ul>
<p>Ex. 1) 함수가 리턴 될 일이 없을 경우</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">infiniteLoop</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        println(<span class="string">"Hi there!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ex. 2) 예외를 던지는(throw Exception)함수의 리턴 타입</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">throwException</span><span class="params">()</span></span>: <span class="built_in">Nothing</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ex. 3) 함수의 리턴 타입이 Nothing? 일 경우</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mayThrowAnException</span><span class="params">(throwException: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Nothing</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (throwException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> IllegalStateException()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">"Exception not thrown :)"</span>)</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = mayThrowAnException(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123; <span class="comment">// Always true</span></span><br><span class="line">        println(<span class="string">"Ignored code"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-컬렉션과-배열">3. 컬렉션과 배열</h4>
<h4 id="31-널-가능성과-컬렉션">3.1 널 가능성과 컬렉션</h4>
<p>Ex.1)null이 될 수 있는 값으로 이뤄진 컬렉션</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumbers</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: List&lt;<span class="built_in">Int</span>?&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;<span class="built_in">Int</span>?&gt;()</span><br><span class="line">    <span class="keyword">for</span> (line <span class="keyword">in</span> reader.lineSequence()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> number = line.toInt()</span><br><span class="line">            result.add(number)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(e: NumberFormatException) &#123;</span><br><span class="line">            result.add(<span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addValidNumbers</span><span class="params">(numbers: <span class="type">List</span>&lt;<span class="type">Int</span>?&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sumOfValidNumbers = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> invalidNumbers = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="literal">null</span>) &#123;</span><br><span class="line">            sumOfValidNumbers += number</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invalidNumbers++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Sum of valid numbers: <span class="variable">$sumOfValidNumbers</span>"</span>)</span><br><span class="line">    println(<span class="string">"Invalid numbers: <span class="variable">$invalidNumbers</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">"1\nabc\n42"</span>))</span><br><span class="line">    <span class="keyword">val</span> numbers = readNumbers(reader)</span><br><span class="line">    addValidNumbers(numbers)		<span class="comment">//Sum of valid numbers: 43</span></span><br><span class="line">								  <span class="comment">//Invalid numbers: 1</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>List&lt;Int?&gt; 과 List<int>?과 List&lt;Int?&gt;? 잘 구분해서 쓸 것!</int></li>
</ul>
<h4 id="32-읽기-전용과-변경-가능한-컬렉션">3.2 읽기 전용과 변경 가능한 컬렉션</h4>
<ul>
<li>Kotlin 컬렉션은 자바와 다르게 읽기 전용 컬렉션(Collection<t>)과 변경가능 컬렉션(MutableCollection<t>)이 분리되어있다.</t></t></li>
</ul>
<p>Ex) Collection(size, iterator(), contains())    /    MutableCollection(add(), remove(), clear())</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyElements</span><span class="params">(source: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                    target: <span class="type">MutableCollection</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> source) &#123;</span><br><span class="line">        target.add(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source: Collection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> target: MutableCollection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">1</span>)</span><br><span class="line">    copyElements(source, target)</span><br><span class="line">    println(target)		<span class="comment">//[1, 3, 5, 7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ex) Thread-safe하지않은 읽기전용 Collection</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MutableCollection이 Collection 참조</span></span><br><span class="line"><span class="keyword">val</span> collection: Collection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> mutableCollection: MutableCollection&lt;<span class="built_in">Int</span>&gt; = collection</span><br><span class="line">error: type mismatch: inferred type <span class="keyword">is</span> Collection&lt;<span class="built_in">Int</span>&gt; but MutableCollection&lt;<span class="built_in">Int</span>&gt; was expected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Collection이 MutableCollection 참조</span></span><br><span class="line"><span class="keyword">val</span> mutableCollection: MutableCollection&lt;<span class="built_in">Int</span>&gt; = arrayListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> collection: Collection&lt;<span class="built_in">Int</span>&gt; = mutableCollection <span class="comment">//가능 </span></span><br><span class="line">&gt;&gt;&gt; collection</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; mutableCollection</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt; mutableCollection.add(<span class="number">5</span>)</span><br><span class="line">&gt;&gt;&gt; mutableCollection</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt; collection</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]    <span class="comment">// mutalbeCollection에 5를 추가했지만 collection에도 영향을 미친다</span></span><br><span class="line"><span class="comment">// 같은 객체를 다른 타입의 참조들이 가리키고 있다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>따라서, ConcurrentModificationException등의 오류가 발생할 수 있으므로, 다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화 하거나 동시 접근을 허용하는 데이터 구조를 활용해야한다.</li>
</ul>
<h4 id="33-코틀린-컬렉션과-자바">3.3 코틀린 컬렉션과 자바</h4>
<ul>
<li>코틀린에서 읽기 전용인 Collection으로 선언된 객체라도 자바코드에서는, 이를 구분하지 않으므로 수정가능</li>
<li>코틀린 컴파일러가 컬렉션이 어떤 일을 하는지 정확한 분석이 어려움</li>
<li>어차피 ImmutableList가 나와도 자바로 가면 변경이 가능하니 차라리 변경 가능한 컬렉션을 넘기고 명시를 정확히 해두는 것이 좋다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">uppercaseAll</span><span class="params">(List&lt;String&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.size(); i++) &#123;</span><br><span class="line">            items.set(i, items.get(i).toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printInUppercase</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(CollectionUtils.uppercaseAll(list))</span><br><span class="line">    println(list.first())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">    printInUppercase(list)			<span class="comment">//[A, B, C]</span></span><br><span class="line">    							   <span class="comment">//A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="34-자바의-콜렉션-타입을-플랫폼-타입으로-다루기">3.4 자바의 콜렉션 타입을 플랫폼 타입으로 다루기</h4>
<ul>
<li>자바의 콜렉션 타입은 읽기전용이나 변경 가능으로 다룰 수 있음</li>
<li>시그니처에서 콜렉션 타입을 사용한 자바 메서드를 오버라이드할 경우 코틀린 타입 선택 필요
<ul>
<li>선택 사항
<ul>
<li>컬렉션이 널이 될 수 있는가?</li>
<li>컬렉션의 원소가 널이 될 수 있는가?</li>
<li>오버라이드하는 메서드가 컬렉션을 변경할 수 있는가?</li>
</ul>
</li>
<li>자바 인터페이스나 클래스가 어떤 맥락에서 사용되는지 정확히 알아야한다.</li>
</ul>
</li>
</ul>
<h4 id="35-객체의-배열과-원시타입의-배열">3.5 객체의 배열과 원시타입의 배열</h4>
<ul>
<li>코틀린에서 배열을 만드는 방법
<ul>
<li>arrayOf : 함수에 원소를 넘김</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> strings = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">    println(<span class="string">"%s/%s/%s"</span>.format(*strings.toTypedArray()))		<span class="comment">// a/b/c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>arrayOfNuls : 원소타입이 널이 될 수 있는 타입인 경우에만 호출할 수 있고, 인자에 배열의 크기를 넘김</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nullStorableArray = arrayOfNulls&lt;String&gt;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Array() : 배열의 크기와 람다를 인자로 받아, 람다를 호출하여 각 배열 원소를 초기화</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squares = IntArray(<span class="number">5</span>) &#123; i -&gt; (i+<span class="number">1</span>) * (i+<span class="number">1</span>) &#125;</span><br><span class="line">    println(squares.joinToString())		<span class="comment">//1, 4, 9, 16, 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li>Made by <a href="https://github.com/iyj9328" target="_blank" rel="noopener">iyj9328</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/02/KotlinInAction-Chap6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/02/KotlinInAction-Chap5/"
                            aria-label=": [Kotlin in Action] Chap5. 람다"
                        >
                            [Kotlin in Action] Chap5. 람다
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-02T15:27:53+09:00">
	
		    Apr 02, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="람다-식-람다">람다 식 | 람다</h3>
<p>기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.</p>
<h4 id="람다-식과-멤버-참조">람다 식과 멤버 참조</h4>
<p>람다는 자바 8에 도입되어 자바에서도 비로소 람다를 사용할 수 있게 되었다.</p>
<h5 id="람다-소개-코드-블록을-함수-인자로-넘기기">람다 소개: 코드 블록을 함수 인자로 넘기기</h5>
<p><strong>[자바에서 익명 클래스를 통해 버튼 클릭 리스너 구현]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 자바 */</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 클릭시 동작 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>[람다로 리스너 구현]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener &#123; <span class="comment">/* 클릭시 동작 */</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>두 구현은 동일한 동작이지만 람다를 이용한 경우 코드가 훨씬 간결하고 읽기 쉬워진다.</li>
</ul>
<h5 id="람다와-컬렉션">람다와 컬렉션</h5>
<p><strong>[컬렉션에서 가장 큰 값 찾기: 직접 구현]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findTheOldest</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxAge = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> theOldest: Person? = <span class="literal">null</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (person <span class="keyword">in</span> people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (person.age &gt; maxAge) &#123;</span><br><span class="line">            maxAge = person.age</span><br><span class="line">            theOldest = person</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(theOldest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line">findTheOldest(people)</span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31)</span></span><br></pre></td></tr></table></figure>
<p><strong>[컬렉션에서 가장 큰 값 찾기: 람다 이용]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line">println(people.maxBy &#123; it.age &#125;) <span class="comment">// 나이 프로퍼티를 비교해서 가장 큰 원소 찾기</span></span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31)</span></span><br><span class="line"></span><br><span class="line">println(people.maxBy(Person::age)) <span class="comment">// 나이 프로퍼티를 비교해서 가장 큰 원소 찾기</span></span><br><span class="line"><span class="comment">// 결과: Person(name=Bob, age=31</span></span><br></pre></td></tr></table></figure>
<ul>
<li>자바 컬렉션에 대해 (자바 8 이전, 람다 지원 전) 수행하던 대부분의 불편했던 작업들은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선이 가능하다. 이렇게 개선된 후에는 코드가 한결 짧아지고 더 이해하기 쉬워졌다.</li>
</ul>
<h5 id="람다-식의-문법">람다 식의 문법</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y &#125;</span><br><span class="line"><span class="comment">//    파라미터     -&gt;   본문</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다는 <strong>값처럼</strong> 여기저기 전달할 수 있는 동작의 모음이다.
<ul>
<li>추가로 람다를 따로 선언해서 변수에 저장도 가능하다. 그렇다곤 해도 보통은 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; x + y&#125; <span class="comment">// 람다식 변수에 저장</span></span><br><span class="line">println(sum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 변수에 저장된 람다식 호출</span></span><br><span class="line"><span class="comment">// 결과: 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>심지어는 람다식을 직접 호출도 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; println(<span class="number">42</span>) &#125;()</span><br><span class="line"><span class="comment">//  결과: 42</span></span><br></pre></td></tr></table></figure>
<p>굳이 이렇게 쓰는 것보다는 가독성 때문에라도 람다 본문을 직접 실행하는 편이 낫다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자로 받은 람다를 실행해주는 라이브러리 함수인 run을 사용하여 람다 본문 실행</span></span><br><span class="line">run &#123; println(<span class="number">42</span>) &#125;</span><br><span class="line"><span class="comment">// 결과: 42</span></span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린 람다 식은 <strong>항상 중괄호</strong>로 둘러싸여있다.</li>
<li>인자 목록 주변에 괄호가 없다.</li>
<li>화살표(-&gt;)를 통해 인자 목록과 람다 본문을 구분한다.</li>
</ul>
<p><strong>람다식 사용 예제</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"Alice"</span>, <span class="number">29</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인자가 한 개고 타입 추론 가능하면 디폴트 이름인 it 사용 가능</span></span><br><span class="line">println(people.maxBy &#123; it. age &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">people.maxBy(&#123; p: Person -&gt; p.age&#125;)</span><br><span class="line"><span class="comment">// 람다가 마지막 인자면, 괄호 밖에 위치 가능</span></span><br><span class="line">people.maxBy() &#123; p: Person -&gt; p.age&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다가 마지막 인자고, 괄호 뒤에 람다를 썼을 경우 괄호 생략 가능</span></span><br><span class="line">people.maxBy &#123; p: Person -&gt; p.age&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>간단한 경우라면 괄호 없이 람다식만으로 명시해도 나쁘지 않을 것으로 생각되지만 웬만하면 괄호를 사용하여 해당 람다식이 메소드에 포함된 람다식이라는 것을 확실히 하는 것이 가독성에 더 좋을 것 같다.</p>
</blockquote>
<p><strong>이름 붙인 인자를 사용해 람다 넘기기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = listOf(Person(<span class="string">"이몽룡"</span>, <span class="number">29</span>), Person(<span class="string">"성춘향"</span>, <span class="number">31</span>))</span><br><span class="line"><span class="keyword">val</span> names = people.joinToString(seprator = <span class="string">" "</span>, transform = &#123; p: Person -&gt; p.name &#125;)</span><br><span class="line">println(names)</span><br><span class="line"><span class="comment">// 결과: 이몽룡 성춘향</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 괄호 밖으로 처리</span></span><br><span class="line"><span class="keyword">val</span> names = people.joinToString(<span class="string">" "</span>) &#123; p: Person -&gt; p.name&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>개인적인 생각이지만 이 예제를 보니 개인적인 프로젝트에서 특정 메소드에 대한 완벽한 이해가 있고 람다식을 사용하는 곳도 완벽한 이해가 있는 경우에는 람다식을 괄호 밖으로 빼서 표현하는 것이 코드도 간결하고 보기도 더 좋지만 <strong>협업을 하는 상황</strong>이라면 누구라도 코드를 이해하기 쉽도록 괄호를 사용하여 일반적인 메소드 호출을 이용하여 람다식을 표현하는 것이 더 좋을 것으로 생각된다.</p>
</blockquote>
<p><strong>람다 파라미터 타입 제거하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; p: Person -&gt; p.age &#125; <span class="comment">// 파라미터 타입 명시</span></span><br><span class="line">people.maxBy &#123; p -&gt; p.age &#125; <span class="comment">// 파라미터 타입 생략 (컴파일러가 추론)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 람다식 담는 경우 컴파일러가 타입 추론 불가</span></span><br><span class="line"><span class="keyword">val</span> getAge = &#123; p: Person -&gt; p.age &#125;</span><br><span class="line">people.maxBy(getAge)</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 람다 파라미터의 타입도 <strong>추론</strong> 할 수 있다.</li>
<li>people은 Person을 담은 컬렉션이므로 컴파일러는 Person 객체가 파라미터로 들어올 것을 추론할 수 있다.
<ul>
<li><s>컴파일러가 람다 파라미터의 타입을 추론하지 못하는 경우도 있으나 이번 장에서는 다루지 않는다.</s></li>
</ul>
</li>
<li>단, 람다식을 변수에 담는 경우 파라미터의 타입을 추론할 문맥이 존재하지 않으므로 파라미터를 명시해야만 한다.</li>
</ul>
<p><strong>디폴트 파라미터 이름 it 사용하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">people.maxBy &#123; it.age &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>it</code>는 자동 생성된 파라미터 이름이다.</li>
<li>람다의 파라미터가 <strong>하나</strong>뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 <code>it</code>를 사용할 수 있다.</li>
</ul>
<blockquote>
<p>람다 내에 람다가 중첩되는 경우나 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에는 파라미터를 명시적으로 선언하는 것이 가독성에 더 좋다.</p>
</blockquote>
<p><strong>본문이 여러줄로 이뤄진 람다식</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123; x: <span class="built_in">Int</span>, y: <span class="built_in">Int</span> -&gt; </span><br><span class="line">    println(<span class="string">"Computing the sum of <span class="variable">$x</span> and <span class="variable">$y</span>..."</span>)</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>본문이 여러줄로 이루어진 경우 <strong>맨 마지막에 있는 식</strong>이 람다식의 결과값이 된다.</li>
</ul>
<h5 id="현재-영역에-있는-변수에-접근">현재 영역에 있는 변수에 접근</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printMessageWithPrefix</span><span class="params">(messages: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;, prefix: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    messages.forEach &#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$prefix</span> <span class="variable">$it</span>"</span>) <span class="comment">// 람다 내부에서 함수의 "prefix" 변수 사용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; val errors = listOf("403 Forbidden", "404 Not Found")</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; printMessagesWithPrefix(errors, "Error:")</span></span><br><span class="line"><span class="comment">// 결과: Error: 403 Forbidden</span></span><br><span class="line"><span class="comment">//      Error: 404 Not Found</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다를 함수 안에서 정의하면 함수의 파라미터에 접근이 가능하다.</li>
<li>뿐만 아니라 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProblemCounts</span><span class="params">(response: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clientErrors = <span class="number">0</span> <span class="comment">// 람다 외부에 로컬 변수 선언</span></span><br><span class="line">    <span class="keyword">var</span> serverErrors = <span class="number">0</span> <span class="comment">// 람다 외부에 로컬 변수 선언</span></span><br><span class="line">    </span><br><span class="line">    response.forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.startsWith(<span class="string">"4"</span>)) &#123;</span><br><span class="line">            clientErrors++ <span class="comment">// 람다 내부에서 외부의 로컬 변수 값 변경</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.startsWith(<span class="string">"5"</span>)) &#123;</span><br><span class="line">            serverErrors++ <span class="comment">// 람다 내부에서 외부의 로컬 변수 값 변경</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"<span class="variable">$ClientErrors</span> client errors, <span class="variable">$serverErrors</span> server errors"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error"</span></span><br><span class="line"><span class="comment">// &gt;&gt;&gt; printProblemCounts(responses)</span></span><br><span class="line"><span class="comment">// 결과: 1 client errors, 1 server errors</span></span><br></pre></td></tr></table></figure>
<ul>
<li>람다 내부에서는 <code>final</code> 변수가 아닌 변수에 접근이 가능하다.</li>
<li>람다 내부에서 람다 외부의 변수 변경도 가능하다.
<ul>
<li>람다 내부에서 사용하는 람다 외부 변수를 <code>람다가 포획한 변수</code>라고 부른다. (위 예제들의 prefix, clientErrors, serverErrors)</li>
</ul>
</li>
</ul>
<blockquote>
<p>람다를 실행 시점에 표현하는 데이터 구조는 람다에서 시작하는 모든 참조가 포함된 닫힌(closed) 객체 그래프를 람다 코드와 함께 저장해야 한다. 그런 데이터 구조를 <strong>클로저(closure)</strong> 라고 부른다. 함수를 쓸모 있는 1급 시민으로 만들려면 포획한 변수를 제대로 처리해야 하고, 포획한 변수를 제대로 처리하려면 클로저가 꼭 필요하다. 그래서 람다를 클로저라고 부르기도 한다.</p>
</blockquote>
<p>TODO 무슨 말인지 이해가 가지 않는다… 코틀린 스터디 팀원들에게 물어보고 내용을 추가하도록 하자…!</p>
<p><strong>로컬 변수의 생명주기와 함수의 생명주기가 다른 경우</strong></p>
<p>(예를 들면, 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장하는 경우가 있다.)</p>
<ul>
<li>포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다.
<ul>
<li><code>final</code> 변수인 경우: 람다 코드를 변수 값과 함께 저장하여 함수가 끝난 뒤에도 포획한 변수에 접근이 가능하다.</li>
<li><code>final</code> 변수가 아닌 경우: 변수를 특별한 <strong>래퍼</strong>로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다.</li>
<li>코틀린에서도 자바와 같이 약간의 꼼수(?)로 변경 가능한 변수를 포획하게 된다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 실제 코드</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> inc = &#123; counter++ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 내부 동작을 보여주는 코드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ref</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">var</span> value: T)</span><br><span class="line"><span class="keyword">val</span> counter = Ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> inc = &#123; counter.value++ &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Ref</code> 라는 클래스로 래핑하여 해당 클래스를 <code>final</code> 하게 선언하고 그 내부에 멤버 변수에 counter 값을 저장한다.</li>
<li>그 이후 람다식에서는 클래스의 변수값에 접근하여 변경 가능한 변수를 포획한다.</li>
</ul>
<p><strong>람다를 이벤트 핸들러 등 비동기 실행 코드로 활용하는 경우</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryToCountButtonClicks</span><span class="params">(button: <span class="type">Button</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> clicks = <span class="number">0</span></span><br><span class="line">    button.onClick &#123; clicks++ &#125;</span><br><span class="line">    <span class="keyword">return</span> clicks</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>람다를 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다는 점을 인지해 유의하여 사용해야 한다.</li>
<li>위 예시 코드에서 해당 함수는 항상 0을 반환한다.
<ul>
<li>onCiick 핸들러는 버튼이 클릭될 때마다 clicks 변수를 증가시키지만 그 때에는 함수 호출이 종료된 이후이기 때문이다.</li>
<li>즉, 해당 clicks 변수를 확인할 수 있도록 <strong>클래스의 프로퍼티</strong>나 전역 프로퍼티 등의 위치로 빼서 나중에 해당 변수를 확인할 수 있도록 해야 한다.</li>
</ul>
</li>
</ul>
<h5 id="멤버-참조">멤버 참조</h5>
<p><strong>이미 선언된 함수를 값으로 사용해야 할 때 멤버 참조 <code>::</code> 를 사용하면 된다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모두 같은 동작</span></span><br><span class="line">people.maxBy(Person::age) <span class="comment">// 멤버 참조</span></span><br><span class="line">people.maxBy &#123; p -&gt; p.age &#125;</span><br><span class="line">people.maxBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">isAdult</span><span class="params">()</span></span> = age &gt;= <span class="number">21</span></span><br><span class="line"><span class="keyword">val</span> predicate = Person::isAdult <span class="comment">// 확잠 함수도 동일하게 멤버 참조를 사용할 수 있음</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">salute</span><span class="params">()</span></span> = println(<span class="string">"Salute!"</span>)</span><br><span class="line">run(::salute) <span class="comment">// 최상위 함수 참조</span></span><br><span class="line"><span class="comment">// 결과: Salute!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendEmail 함수에게 작업 위임</span></span><br><span class="line"><span class="keyword">val</span> action = &#123; person: Person, message: String -&gt; sendEmail(person, message) &#125;</span><br><span class="line"><span class="comment">// 람다 대신 멤버 참조 사용</span></span><br><span class="line"><span class="keyword">val</span> nextAction = ::sendEmail</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 참조</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">val</span> createPerson = ::Person <span class="comment">// 생성자 참조 저장</span></span><br><span class="line"><span class="keyword">val</span> p = createPerson(<span class="string">"Alice"</span>, <span class="number">29</span>) <span class="comment">// 생성자 참조를 이용해 인스턴스 생성</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>멤버 참조</strong>는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다.</li>
<li><code>::</code> 는 클래스 이름과 참조하려는 멤버(프로퍼티나 메소드) 이름 사이에 위치한다.</li>
<li><strong>멤버 참조</strong> 뒤에는 괄호를 넣으면 안된다. (메소드여도!!)</li>
<li><strong>멤버 참조</strong>는 그 멤버를 호출하는 람다와 같은 타입이다.</li>
<li>최상위 함수, 최상위 프로퍼티 참조도 가능하다.
<ul>
<li>클래스 이름을 생략하고 <code>::</code> 로 참조를 바로 시작하면 된다.</li>
</ul>
</li>
<li><strong>생성자 참조</strong>를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.
<ul>
<li><code>::</code> 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.</li>
</ul>
</li>
</ul>
<p><strong>바운드 멤버 참조 (1.1부터 사용 가능)</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.0 멤버 참조</span></span><br><span class="line"><span class="keyword">val</span> p = Person(<span class="string">"Dmistry"</span>, <span class="number">34</span>)</span><br><span class="line"><span class="keyword">val</span> personAgeFunction = Person::age</span><br><span class="line">println(personAgeFunction(p))</span><br><span class="line"><span class="comment">// 결과: 34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 바운드 멤버 참조</span></span><br><span class="line"><span class="keyword">val</span> p = Person(<span class="string">"Dmistry"</span>, <span class="number">34</span>)</span><br><span class="line"><span class="keyword">val</span> ageFunction = p::age <span class="comment">// p에 엮인 멤버 참조</span></span><br><span class="line">println(ageFunction())</span><br><span class="line"><span class="comment">// 결과: 34</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>TODO 바운드 멤버 참조는 한 인스턴스에 대해서만 동작이 될 것으로 생각이 드는데 이걸 사용할만한 곳이 있을까? 하는 의문이 든다.</p>
</blockquote>
<h4 id="컬렉션-함수형-api">컬렉션 함수형 API</h4>
<h5 id="필수적인-함수-filter와-map">필수적인 함수: filter와 map</h5>
<p><strong>filter 함수</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(list.filter &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;) <span class="comment">// 짝수만 filtering</span></span><br><span class="line"><span class="comment">// 결과: [2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> personList = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterList = personList.filter &#123; it.age &gt; <span class="number">30</span> &#125;</span><br><span class="line">println(filterList)</span><br><span class="line"><span class="comment">// 결과: [Person(name=Bob, age=31)]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨 람다가 <strong>true</strong>인 원소를 모은다.</li>
<li>만족하는 원소들을 모아 <strong>새로운 컬렉션</strong>으로 반환한다.</li>
</ul>
<p><strong>map 함수</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">println(list.map &#123; it * it &#125;) <span class="comment">// 자기자신을 곱함</span></span><br><span class="line"><span class="comment">// 결과: [1, 4, 9, 16]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> personList = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> mapList = personList.map &#123; it.age &#125; <span class="comment">// 나이만으로 컬렉션을 만듦</span></span><br><span class="line">println(mapList)</span><br><span class="line"><span class="comment">// 결과: [31, 29]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 멤버 참조 사용</span></span><br><span class="line"><span class="keyword">val</span> memberRefMapList = personList.map(Person::name)</span><br><span class="line">println(memberRefMapList)</span><br><span class="line"><span class="comment">// 결과: [Bob, Alice]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>주어진 람다를 컬렉션의 각 원소에 <strong>적용한 결과</strong>를 모아서 <strong>새 컬렉션</strong>을 만든다.</li>
</ul>
<p><strong>filter + map 조합</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterAndMap = list.filter &#123; it.age &gt; <span class="number">30</span> &#125;.map &#123; it.name &#125;</span><br><span class="line"><span class="comment">// 결과: [Bob]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>연쇄로 호출하여 사용도 가능하다.</li>
</ul>
<p><strong>maxBy + filter 조합</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> filterAndMaxBy = list.filter &#123; it.age == list.maxBy(Person::age)!!.age&#125;</span><br><span class="line"><span class="comment">// 결과: [Person(name=Bob, age=31)]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위 코드의 단점은 filter가 이터레이션하기 때문에 maxby 함수가 컬렉션 수 만큼 호출되며 처리된다는 것이다.</li>
<li>개선해보면…</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"Alice"</span>, <span class="number">29</span>))</span><br><span class="line"><span class="keyword">val</span> maxAge = list.maxBy(Person::age)!!.age</span><br><span class="line"><span class="keyword">val</span> filterAndMaxBy = list.filter &#123; it.age == maxAge &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이터레이션 된다는 것을 항상 기억하고 불필요한 작업을 반복하지 않도록 유의해야 한다.</li>
</ul>
<p><strong>컬렉션 맵에서의 filter, map</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = mapOf(<span class="number">0</span> to <span class="string">"zero"</span>, <span class="number">1</span> to <span class="string">"one"</span>, <span class="number">2</span> to <span class="string">"two"</span>, <span class="number">3</span> to <span class="string">"three"</span>, <span class="number">4</span> to <span class="string">"four"</span>)</span><br><span class="line"><span class="keyword">val</span> filterValuesMap = numbers.filterValues &#123; it == <span class="string">"zero"</span>&#125;</span><br><span class="line"><span class="keyword">val</span> mapValuesMap = numbers.mapValues &#123; it.value.toUpperCase() &#125;</span><br><span class="line">println(filterValuesMap)</span><br><span class="line">println(mapValuesMap)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> filterKeysMap = numbers.filterKeys &#123; it == <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">val</span> mapKeysMap = numbers.mapKeys &#123; it.key % <span class="number">2</span> &#125;</span><br><span class="line">println(filterKeysMap)</span><br><span class="line">println(mapKeysMap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: filterValuesMap = &#123;0=zero&#125;</span></span><br><span class="line"><span class="comment">//      mapValuesMap = &#123;0=ZERO, 1=ONE, 2=TWO, 3=THREE, 4=FOUR&#125;</span></span><br><span class="line"><span class="comment">//      filterKeysMap = &#123;1=one&#125;</span></span><br><span class="line"><span class="comment">//      mapKeysMap = &#123;0=four, 1=three&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>맵에서의 filter와 map은 별도의 API가 존재한다.</li>
<li>맵의 <code>filterValues</code>, <code>filterKeys</code> 의 <code>it</code> 는 각각 value와 key를 가르킨다.</li>
</ul>
<h5 id="컬렉션에-술어-사용-all-any-count-find">컬렉션에 술어 사용: all, any, count, find</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"Bob"</span>, <span class="number">31</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 술어 선언</span></span><br><span class="line"><span class="keyword">val</span> canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= <span class="number">27</span> &#125;</span><br><span class="line">println(<span class="string">"all: <span class="subst">$&#123;list.all(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"any: <span class="subst">$&#123;list.any(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"count: <span class="subst">$&#123;list.count(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"find: <span class="subst">$&#123;list.find(canBeInClub27)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: all: false</span></span><br><span class="line"><span class="comment">//      any: true</span></span><br><span class="line"><span class="comment">//      count: 3</span></span><br><span class="line"><span class="comment">//      find: Person(name=Alice, age=27)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>all</code>: 컬렉션의 모든 원소가 조건을 만족하는지 판단</li>
<li><code>any</code>: 컬렉션의 모든 원소 중 하나라도 조건을 만족하는지 판단</li>
<li><code>count</code>: 조건을 만족하는 원소의 갯수를 반환</li>
<li><code>find</code>: 조건을 만족하는 첫 번째 원소를 반환, 만족하는 원소가 없을 경우 <strong>null</strong>을 반환</li>
</ul>
<blockquote>
<p>함수형 API 사용시 고려할 점</p>
</blockquote>
<ul>
<li>함수형 API <code>count</code> 와 컬렉션에 포함된 함수 <code>size()</code> 의 차이?</li>
<li><code>count</code>의 경우 조건을 만족하는 원소의 개수만 추적할 뿐 원소를 따로 저장하지 않는다.</li>
<li><code>size()</code>의 경우 만족하는 원소를 가진 객체를 생성 시키게 된다.</li>
<li>위 예제 코드의 결과에서 보듯이 all과 any는 서로 부정으로 대응한다. 하지만 가독성을 이유로 <code>any</code> 대신 <code>!all</code> 이나 <code>all</code> 대신 <code>!any</code>는 사용하지 않는 것이 좋다.</li>
</ul>
<h5 id="groupby">groupBy</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line">println(<span class="string">"groupBy: <span class="subst">$&#123;list.groupBy &#123; it.age &#125;</span>&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: groupBy: &#123;27=[Person(name=Alice, age=27), Person(name=WooVictory, age=27)], </span></span><br><span class="line"><span class="comment">//              25=[Person(name=hzoou, age=25)], </span></span><br><span class="line"><span class="comment">//              28=[Person(name=txxbro, age=28), Person(name=iyj, age=28)]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strs = listOf(<span class="string">"12"</span>, <span class="string">"345"</span>, <span class="string">"11"</span>, <span class="string">"456"</span>)</span><br><span class="line">println(strs.groupBy &#123; it.length &#125;)</span><br><span class="line"><span class="comment">// 결과: &#123;2=[12, 11], 3=[345, 456]&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>groupBy: 리스트를 특정 기준에 맞춰 맵으로 변경하여 반환</li>
</ul>
<h5 id="flatmap과-flatten-중첩된-컬렉션-안의-원소-처리">flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"abc"</span>, <span class="string">"def"</span>)</span><br><span class="line">println(strings.flatMap &#123; it.toList() &#125;)</span><br><span class="line"><span class="comment">//결과: [a, b, c, d, e, f]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> authors: List&lt;String&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> books = listOf(Book(<span class="string">"책1"</span>, listOf(<span class="string">"작가1"</span>)),</span><br><span class="line">                 Book(<span class="string">"책2"</span>, listOf(<span class="string">"작가2"</span>, <span class="string">"작가3"</span>)), </span><br><span class="line">                 Book(<span class="string">"책3"</span>, listOf(<span class="string">"작가4"</span>, <span class="string">"작가1"</span>)))</span><br><span class="line"></span><br><span class="line">println(<span class="string">"toSet(): <span class="subst">$&#123;books.flatMap &#123; it.authors &#125;</span>.toSet()&#125;"</span>)</span><br><span class="line">println(<span class="string">"기본: <span class="subst">$&#123;books.flatMap &#123; it.authors &#125;</span>&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: toSet(): [작가1, 작가2, 작가3, 작가4]</span></span><br><span class="line"><span class="comment">//      기본: [작가1, 작가2, 작가3, 작가4, 작가1]</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"flatten(): <span class="subst">$&#123;books.map &#123; it.authors &#125;</span>.flatten()&#125;"</span>)</span><br><span class="line"><span class="comment">// 결과: flatten(): [작가1, 작가2, 작가3, 작가4, 작가1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>flatMap</code>: 인자로 주어진 람다를 컬렉션의 모든 객체에 적용(매핑)하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 모은다(flatten). <strong>즉, 리스트의 리스트가 있을 때 중첩된 리스트의 원소를 한 리스트로 모을 때 사용한다.</strong></li>
<li><code>toSet()</code>: 컬렉션의 중복을 제거리</li>
<li><code>flatten()</code>: 변환할 내용 없이 펼치기만 하는 경우 사용</li>
</ul>
<blockquote>
<p>책에서 다루지 않은 이외에도 많은 컬렉션 API가 존재한다.<br>
이외의 API 는 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html" target="_blank" rel="noopener">Kotlin Collection Reference</a> 를 참고하자.</p>
</blockquote>
<h5 id="지연-계산lazy-컬렉션-연산">지연 계산(lazy) 컬렉션 연산</h5>
<p>콜렉션의 연산자(e.g. map, filter)는 결과 컬렉션을 <strong>즉시</strong> 생성한다. 이는 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.</p>
<p><code>시퀀스(sequence)</code>를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poeple.map(Person::name).filter &#123; it.startsWith(<span class="string">"A"</span>) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>map</code>과 <code>filter</code>는 둘 다 리스트를 반환한다. 즉 위 코드에서 연쇄 호출로 인해 리스트를 2개 만들어졌다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people.asSequence() <span class="comment">// 원본 컬렉션을 시퀀스로 변환</span></span><br><span class="line">    .map(Person::name).filter &#123; it.startsWith(<span class="string">"A"</span>)&#125;</span><br><span class="line">    .toList() <span class="comment">// 결과 시퀀스를 다시 리스트로 변환</span></span><br></pre></td></tr></table></figure>
<ul>
<li>시퀀스의 원소는 필요할 때 비로소 계산되기 때문에 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해 효율적으로 계산을 수행할 수 있다.</li>
<li><code>asSequence()</code>: 어떤 컬렉션이든 시퀀스로 바꿀 수 있다.</li>
<li><code>toList()</code>: 시퀀스를 리슷트로 바꿀 때 사용한다.</li>
</ul>
<blockquote>
<p>리스트 대신에 시퀀스를 쓰는 것이 더 낫지 않은가?</p>
</blockquote>
<ul>
<li>“항상 그렇지는 않다.”</li>
<li>인덱스를 사용해 접근하는 등 다른 API 메소드를 사용하기 위해서는 리스트로 변환해야 한다.</li>
</ul>
<h5 id="시퀀스-연산-실행-중간-연산과-최종-연산">시퀀스 연산 실행: 중간 연산과 최종 연산</h5>
<p>중간 연산과 최종 연산은 p225의 그림 5.7을 참고하자.</p>
<ul>
<li>중간 연산: 다른 시퀀스를 반환하며 최초 시퀀스의 원소를 변환하는 방법을 알고 있다.
<ul>
<li><strong>항상 지연 계산된다.</strong> 즉, 최종 연산을 하지 않으면 계속 지연이 되어 결과를 반환하지 않는다.</li>
</ul>
</li>
<li>최종 연산: 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자, 객체이다.</li>
</ul>
<p><strong>즉시 계산의 수행 순서와 지연 계산의 수행 순서</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eagerly</span></span><br><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).map &#123; println(<span class="string">"eagerly map(<span class="variable">$it</span>)"</span>); it * it &#125;</span><br><span class="line">                .filter &#123; println(<span class="string">"eagerly filter(<span class="variable">$it</span>)"</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// 결과: eagerly map(1)</span></span><br><span class="line"><span class="comment">//      eagerly map(2)</span></span><br><span class="line"><span class="comment">//      eagerly map(3)</span></span><br><span class="line"><span class="comment">//      eagerly map(4)</span></span><br><span class="line"><span class="comment">//      eagerly filter(1)</span></span><br><span class="line"><span class="comment">//      eagerly filter(4)</span></span><br><span class="line"><span class="comment">//      eagerly filter(9)</span></span><br><span class="line"><span class="comment">//      eagerly filter(16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lazy</span></span><br><span class="line">listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).asSequence()</span><br><span class="line">                .map &#123; println(<span class="string">"lazy map(<span class="variable">$it</span>)"</span>); it * it&#125;</span><br><span class="line">                .filter &#123; println(<span class="string">"lazy filter(<span class="variable">$it</span>)"</span>); it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br><span class="line">                .toList()</span><br><span class="line"><span class="comment">//결과: lazy map(1)</span></span><br><span class="line"><span class="comment">//     lazy filter(1)</span></span><br><span class="line"><span class="comment">//     lazy map(2)</span></span><br><span class="line"><span class="comment">//     lazy filter(4)</span></span><br><span class="line"><span class="comment">//     lazy map(3)</span></span><br><span class="line"><span class="comment">//     lazy filter(9)</span></span><br><span class="line"><span class="comment">//     lazy map(4)</span></span><br><span class="line"><span class="comment">//     lazy filter(16)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>즉시 계산의 경우 <strong>모든 원소</strong>에 대해 먼저 map을 끝낸 후 이후 filter를 수행하게 된다.</li>
<li>시퀀스(지연 계산)의 경우 <strong>각 원소</strong>에 대해 순차적으로 적용이 된다.</li>
<li>p226의 그림 5.8을 참고하자.</li>
</ul>
<p><strong>map과 filter 호출 순서에 따른 성능 차이의 발생</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(Person(<span class="string">"Alice"</span>, <span class="number">27</span>), Person(<span class="string">"hzoou"</span>, <span class="number">25</span>), Person(<span class="string">"txxbro"</span>, <span class="number">28</span>), Person(<span class="string">"iyj"</span>, <span class="number">28</span>), Person(<span class="string">"WooVictory"</span>, <span class="number">27</span>))</span><br><span class="line"></span><br><span class="line">list.asSequence().map(Person::name) <span class="comment">// map 먼저 실행</span></span><br><span class="line">    .filter &#123; it.length &lt; <span class="number">4</span> &#125;.toList()</span><br><span class="line"></span><br><span class="line">list.asSequence().filter &#123; it.length &lt; <span class="number">4</span> &#125; <span class="comment">// filter 먼저 실행</span></span><br><span class="line">    .map(Person::name).toList()</span><br></pre></td></tr></table></figure>
<ul>
<li>p227의 그림 5.9를 참고하자.
<ul>
<li>filter 보다 map을 호출할 경우 map은 모든 원소를 변환하므로 더 많은 이터레이션이 발생하게 된다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>자바 스트림과 코틀린 시퀀스 비교</strong></p>
</blockquote>
<p>자바 8의 스트림과 코틀린의 시퀀스는 개념적으로 같다. 다만, 자바 8일 경우 코틀린 컬렉션과 시퀀스에서 제공하지 않는 <strong>스트림 연산(map과 filter)을 여러 CPU에서 병렬적으로 실행하는 기능</strong>이 존재한다. 그렇기 때문에 자바 버전에 따라서 시퀀스와 스트림 중에 적절한 것을 사용하면 된다.<br>
자바 8에 대해서는 다른 개발자의 블로그의 글인 <a href="https://12bme.tistory.com/461" target="_blank" rel="noopener">자바 8 스트림 이란?</a> 을 참고하자.</p>
<h5 id="시퀀스-만들기">시퀀스 만들기</h5>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                  첫번째 인자: 초기값 / 두번째 인자: 다음 값 생성 로직</span></span><br><span class="line"><span class="keyword">val</span> numbers = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125; <span class="comment">// 시퀀스 생성</span></span><br><span class="line"><span class="keyword">val</span> numbersTo100 = numbers.takeWhile &#123; it &lt;= <span class="number">100</span> &#125; <span class="comment">// while loop 시퀀스 생성</span></span><br><span class="line">println(numbersTo100.sum()) <span class="comment">// 위의 모든 시퀀스는 sum의 결과를 계산할 때 수행된다.</span></span><br><span class="line"><span class="comment">// 결과: 5050</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// File의 확장함수 선언</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> File.<span class="title">isInsideHiddenDirectory</span><span class="params">()</span></span> = generateSequence(<span class="keyword">this</span>) &#123; it.parentFile &#125;.any &#123; it.isHidden &#125;</span><br><span class="line"><span class="keyword">val</span> file = File(<span class="string">"/Users/svtk/.HiddenDir/a.txt"</span>)</span><br><span class="line">println(file.isInsideHiddenDirectory())</span><br><span class="line"><span class="comment">// 결과: true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>generateSequence</code>: 이전의 원소를 인자로 받아 다음 원소를 계산하는 시퀀스를 만드는 함수</li>
<li>최종 연산인 <code>sum()</code> 을 호출 하기 전에는 계산되지 않다가 최종 연산이 호출될 때에 계산이 수행된다.</li>
</ul>
<h4 id="자바-함수형-인터페이스-활용">자바 함수형 인터페이스 활용</h4>
<h5 id="함수형-인터페이스">함수형 인터페이스</h5>
<p>추상 메소드가 단 하나 있는 인터페이스를 <strong>함수형 인터페이스</strong> 또는 <strong>SAM(단일 추상 메소드, Single Abstract method) 인터페이스</strong>라고 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 8 이전 익명클래스로 표현</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* TODO */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 8 이후 함수형 인터페이스를 람다로 표현</span></span><br><span class="line">button.setOnClickListener &#123;view -&gt; <span class="comment">/* TODO */</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바에서는 함수형 인터페이스 즉, SAM 인터페이스인 경우 자바 8버전 이후 람다를 이용하여 더 간결하게 표현할 수 있다. (코틀린도 너무나 당연하게 사용 가능하다.)</li>
</ul>
<h5 id="자바-메소드에-람다를-인자로-전달">자바 메소드에 람다를 인자로 전달</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 함수형 인터페이스를 인자로 전달</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postponeComputation</span><span class="params">(<span class="keyword">int</span> delay, Runnable computation)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 위의 자바 코드에 코틀린에서 람다를 전달하여 호출</span></span><br><span class="line">postponeComputation(<span class="number">1000</span>) &#123; println(<span class="number">42</span>) &#125; <span class="comment">// 함수형 인터페이스에 람다를 전달</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 식을 전달</span></span><br><span class="line">postponeComputation(<span class="number">1000</span>, <span class="keyword">object</span>: Runnable &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="number">42</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 자동으로 람다를 Runnable 인스턴스(Runnable을 구현한 익명 클래스 인스턴스)로 변환하여 전달한다.</li>
<li>Runnable을 구현하는 무명 객체를 명시적으로 만들어서 사용하는 것도 가능하다.</li>
</ul>
<blockquote>
<p>람다를 넘길 때와 무명 객체를 생성하여 넘길 때의 차이점?</p>
</blockquote>
<ul>
<li>무명 객체를 생성하여 넘기는 경우, 메소드를 호출할 때마다 새로운 인스턴스가 생성된다.</li>
<li>생성된 Runnable 인스턴스는 단 하나만 생성되며 메소드 호출 시 반복 사용된다.</li>
<li>단, 람다 내에서 람다 외부의 변수를 포획하는 경우에는 무명 객체처럼 새로운 인스턴스가 생성된다.</li>
</ul>
<blockquote>
<p>Java 8 언어 기능과 Jack을 활성화 방법</p>
</blockquote>
<ul>
<li>app 단 build.gradle 내에 <strong>compileOptions</strong> 를 통해 지정해준다.<br>
<img src="/img/compileOptions.png" width="500" height="200"></li>
</ul>
<p>코틀린 컴파일 시 자바 8 바이트 코드생성 방법</p>
<ul>
<li>jvm-target 1.8 이라고 kotlinc 호출할 때 커맨드라인에서 옵션 설정을 지정</li>
<li>메이븐이나 그래들 프로젝트 설정에 명시</li>
</ul>
<h5 id="sam-생성자-람다를-함수형-인터페이스로-명시적으로-변경">SAM 생성자: 람다를 함수형 인터페이스로 명시적으로 변경</h5>
<p>컴파일러가 자동으로 람다를 함수형 인터페이스 익명 클래스로 바꾸지 못하는 경우 <code>SAM 생성자</code>를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listener = OnClickListener &#123; view -&gt; </span><br><span class="line">    <span class="keyword">val</span> text = <span class="keyword">when</span> (view.id) &#123;</span><br><span class="line">        R.id.button1 -&gt; <span class="string">"First button"</span></span><br><span class="line">        R.id.button2 -&gt; <span class="string">"Second button"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">"Unknown button"</span></span><br><span class="line">    &#125;</span><br><span class="line">    toast(text)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button1.setOnClickListener(listener)</span><br><span class="line">button2.setOnClickListener(listener)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>람다와 리스너 등록/해제</p>
</blockquote>
<ul>
<li>람다는 코드 블럭이기 때문에 <code>this</code> 가 없다. 즉, 객체처럼 익명 클래스의 인스턴스를 참조할 수 없다.</li>
<li>람다 내에서 <code>this</code>는 그 람다를 둘러싼 클래스의 인스턴스를 가르킨다. 주의하자.</li>
<li>리스너를 가르키고 싶다면 람다가 아닌 <strong>무명 객체</strong>를 사용해야 한다.</li>
<li>무명 객체 내에서 <code>this</code>는 객체 인스턴스 자신을 가르킨다.</li>
</ul>
<h4 id="수신-객체-지정-람다-with와-apply">수신 객체 지정 람다: with와 apply</h4>
<p>자바의 람다에는 없는, 코틀린 람다만의 독특한 기능인 <code>수신 객체 지정 람다</code>는 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다.</p>
<h5 id="with-함수">with 함수</h5>
<p><code>with</code> 함수는 파라미터가 2개인 메소드로 첫 번째 인자는 객체를 두 번째 인자는 람다를 받는다.</p>
<ul>
<li>첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> sb = StringBuilder()</span><br><span class="line">    <span class="keyword">return</span> with(sb) &#123;</span><br><span class="line">        <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.append(letter) <span class="comment">// this를 통해 수신 객체에 접근</span></span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">"\nNow I know alphabet!"</span>) <span class="comment">// this 없이 수신 객체의 메소드 호출</span></span><br><span class="line">        <span class="keyword">this</span>.toString() <span class="comment">// 람다에서 값 반환</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>수신 객체 지정 람다는 확장 함수와 비슷한 동작을 정의하는 한 방법이다.</li>
<li><code>&lt;T, R&gt; with(receiver: T, block: T.() ‐&gt; R)</code>: block 함수의 수신 객체는 T</li>
</ul>
<h5 id="apply-함수">apply 함수</h5>
<p><code>apply</code> 함수는 <code>with</code> 함수와 동일한 동작이지만 항상 자신에게 전달된 객체(수신 객체)를 반환한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = StringBuilder().apply &#123;</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nNow I know the alphabet!"</span>)</span><br><span class="line">&#125;.toString()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fun &lt;T&gt; T.apply(block: T.() ‐&gt; Unit): T</code>: apply 함수는 확장 함수로 정의되어 있다.</li>
<li>객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화 해야 하는 경우 유용하다.</li>
</ul>
<p><strong>apply를 이용해 TextView 만들면서 초기화 하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createViewWithCustomAttributes</span><span class="params">(context: <span class="type">Context</span>)</span></span> =</span><br><span class="line">    TextView(context).apply &#123;</span><br><span class="line">        text = <span class="string">"Sample Text"</span> <span class="comment">// this 생략하여 TextView의 프로퍼티 사용</span></span><br><span class="line">        textSize = <span class="number">20.0</span> </span><br><span class="line">        setPadding(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// this 생략하여 TextView의 멤버 함수 사용</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="buildstring-함수">buildString 함수</h5>
<p><code>buildString</code> 함수는 StringBuilder 객체를 만들어 toString()을 호출해주는 작업을 해준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">alphabet</span><span class="params">()</span></span> = buidlString &#123;</span><br><span class="line">    <span class="keyword">for</span> (letter <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span>) &#123;</span><br><span class="line">        append(letter)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">"\nNow I know the alphabet!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li><a href="https://taehyungk.github.io/tag/#Kotlin" target="_blank" rel="noopener">탤로우 월드#Kotlin</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/02/KotlinInAction-Chap5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/01/KotlinInAction-Chap4/"
                            aria-label=": [Kotlin in action] Chap4. 클래스와 인터페이스"
                        >
                            [Kotlin in action] Chap4. 클래스와 인터페이스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-01T20:26:32+09:00">
	
		    Apr 01, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="목차">목차</h2>
<ul>
<li>클래스와 인터페이스</li>
<li>뻔하지 않은 생성자와 프로퍼티</li>
<li>데이터 클래스</li>
<li>클래스 위임</li>
<li>object 키워드 사용</li>
</ul>
<h3 id="411-코틀린-인터페이스">4.1.1 코틀린 인터페이스</h3>
<ul>
<li>인터페이스 안에는 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의 가능하다. 다만 아무런 상태(필드)도 들어갈 수 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Clickable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"Show~"</span>) <span class="comment">// 디폴트 구현. </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">Clickable &#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = println(<span class="string">"Hi~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Button().onClick()</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 이름 뒤에 콜론(:)을 붙여 인터페이스와 클래스 이름을 적는 것으로 상속과 인터페이스 구현을 모두 처리한다.
<ul>
<li>자바 : extends, implements</li>
</ul>
</li>
<li>자바와 마찬가지로 다중 구현은 허용되지만, 다중 상속은 불가능하다.</li>
<li>@Override 어노테이션과 override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드 한다는 뜻이다. 다만, override 변경자는 코틀린에서 꼭 표시해야 한다.</li>
<li>디폴트 구현을 제공할 수 있으며, 특별한 키워드를 붙이지 않고 메소드 본문을 적어주면 된다.
<ul>
<li>이 경우, Clickable을 구현하는 하위 클래스에서 showOff를 새롭게 정의할 수도 있고, 정의를 생략해서 디폴트 구현을 사용할 수도 있다.</li>
</ul>
</li>
<li>아래 코드를 함께 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Focusable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">setFocus</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm Focus"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이제 한 클래스에서 Clickable, Focusable  두 인터페이스를 구현하면 어떻게 될까? 두 인터페이스 모두 디폴트 구현이 들어있다.</li>
<li>결론은 어느 쪽의 showOff() 메소드도 호출되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 아래와 같은 컴파일 오류가 발생한다.</li>
</ul>
<blockquote>
<p>The class ‘Button’ must override public open fun showOff()</p>
<p>because it inherits many implementations of it.</p>
</blockquote>
<ul>
<li>코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 강제한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">Clickable</span>, <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> = ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>&lt;Clickable&gt;.showOff()</span><br><span class="line">    <span class="keyword">super</span>&lt;Focusable&gt;.showOff()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>즉, 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 존재하는 경우, 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다.</li>
<li>자바와 달리 상위 타입의 이름을 꺽쇠 괄호(&lt;&gt;) 사이에 넣어서 super를 지정하면 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.</li>
</ul>
<h3 id="412-open-final-abstract-변경자">4.1.2 open, final, abstract 변경자</h3>
<ul>
<li>자바에서는 기본적으로 상위 클래스에 대해 하위 클래스에서 상속하는 걸 막지 않는다. 막기 위해서는 final을 붙여 상속을 할 수 없게 한다.</li>
<li>기본적으로 상속이 가능하면 편리하지만, 문제가 생기는 경우도 있다.</li>
<li><code>취약한 기반 클래스</code> 라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 존재한다.</li>
<li>즉, 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 <strong>취약</strong>하다.</li>
<li>이런 점을 보완하기 위해 코틀린에서는 클래스와 메소드는 기본적으로 <strong>final</strong>이다.</li>
<li>클래스의 상속을 허용하려면 클래스 앞에 <strong>open</strong> 변경자를 붙여야 한다.</li>
<li>오버라이드를 허용하고 싶은 메소드나 프로퍼티 앞에도 붙일 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">RichButton</span> : <span class="type">Clickable&#123;</span></span></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">animate</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span> </span><br><span class="line">  <span class="comment">// 오버라이드한 메소드의 구현을 하위 클래스에서 오버라이드 하지 못하게 막을 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RichButton 클래스는 다른 클래스가 상속할 수 있다.(open)</li>
<li>disable() : final이며, 오버라이드 할 수 없다.</li>
<li>animate() : oepn으로 오버라이드 가능.</li>
<li>onClick() : 상위 클래스에서 선언된 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.</li>
</ul>
<ul>
<li>abstract로 선언한 추상 클래스는 인스턴스화 할 수 없으며, 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드 해야 하는게 보통이다.</li>
<li>추상 멤버는 항상 열려 있기 때문에 open 변경자를 명시할 필요가 없다.</li>
</ul>
<p>Todo 표 추가</p>
<h3 id="413-가시성-변경자">4.1.3 가시성 변경자</h3>
<ul>
<li>코틀린의 기본 가시성은 자바와 다르며, 아무 변경자도 없는 경우 public이다.</li>
<li>자바의 기본 가시성인 package private이 없다. 코틀린은 패키지를 네임스페이스를 관리하기 위한 용도로만 사용한다.</li>
<li>코틀린은 <code>internal</code>이라는 새로운 가시성을 도입했다.
<ul>
<li>이는 모듈 내부에서만 볼 수 있음을 뜻한다.</li>
<li>모듈 : 한 번에 한꺼번에 컴파일되는 파일들을 의미한다.</li>
<li>모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.</li>
</ul>
</li>
<li>코틀린에서는 최상위 선언에 대해 private 가시성을 허용한다.</li>
</ul>
<blockquote>
<p>? 모듈에 대해 생각해볼 필요가 있어 보인다.</p>
</blockquote>
<table>
<thead>
<tr>
<th>변경자</th>
<th>클래스멤버</th>
<th>최상위 선언</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>모든 곳에서 볼 수 있다.</td>
<td>모든 곳에서 볼 수 있다.</td>
</tr>
<tr>
<td>internal</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
<td>같은 모듈 안에서만 볼 수 있다.</td>
</tr>
<tr>
<td>protected</td>
<td>하위 클래스에서만 볼 수 있다.</td>
<td>적용할 수 없음.</td>
</tr>
<tr>
<td>private</td>
<td>같은 클래스 안에서만 볼 수 있다.</td>
<td>같은 파일 안에서만 볼 수 있다.</td>
</tr>
</tbody>
</table>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkativeButton</span>: <span class="type">Focusable&#123;</span></span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">yell</span><span class="params">()</span></span> = println(<span class="string">"Hey~"</span>)</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">wishper</span><span class="params">()</span></span> = println(<span class="string">"Let's talk!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> TalkativeButton.<span class="title">giveSpeech</span><span class="params">()</span></span>&#123;</span><br><span class="line">  yell()</span><br><span class="line">  </span><br><span class="line">  whisper()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>public 멤버가 자신의 internal 수신 타입인 TalkativeButton을 노출함</p>
<ul>
<li>Public 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은 internal 타입인 TalkativeButton을 참조하지 못하게 한다.</li>
<li>이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 한다.</li>
<li>이는 일반적인 규칙에 해당한다.</li>
</ul>
</li>
<li>
<p>yell은 private이라 접근이 불가능.</p>
</li>
<li>
<p>whisper는 상속 관계에서 하위 클래스만 접근이 가능. 따라서 불가능.</p>
</li>
<li>
<p>컴파일 오류를 없애기 위해서는 TalkativeButton을 public으로 바꾸거나 giveSpeech 확장 함수의 가시성을 internal로 바꾸면 된다.</p>
</li>
<li>
<p><strong>자바와 달리 코틀린에서의 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.</strong></p>
</li>
<li>
<p><strong>클래스를 확장한 함수는 그 클래스의 private, protected 멤버에 접근할 수 없다는 사실을 알아야 한다.</strong></p>
</li>
</ul>
<blockquote>
<p>코틀린의 가시성 변경자와 자바</p>
</blockquote>
<p>코틀린의 public, protected, private 변경자는 컴파일된 자바 바이트 코드 안에서도 그대로 유지된다.</p>
<p>유일한 예외는 private이며, 자바에서는 클래스를 private으로 만들 수 없으므로 코틀린은 내부적으로 private 클래스는 package private으로 컴파일한다.</p>
<p>internal은 자바에서 딱 맞는 가시성이 없다. package private과는 다르다. 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어있을 수도 있다. 따라서 internal은 자바 바이트 코드에서 public이 된다.</p>
<p>코틀린과 자바 선언에 차이가 존재하기 때문에 다음과 같은 접근이 가능하다.</p>
<ul>
<li>다른 모듈에 정의된 internal 클래스나 internal 최상위 선언을 모듈 외부의 자바 코드에서 접근 가능.</li>
<li>protected로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서 접근 가능.</li>
</ul>
<h3 id="414-내부-클래스와-중첩된-클래스">4.1.4 내부 클래스와 중첩된 클래스</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">State</span>: <span class="type">Serializable</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCurrentState</span><span class="params">()</span></span>: State = ButtonState()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">restoreState</span><span class="params">(state: <span class="type">State</span>)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ButtonState</span>: <span class="type">State&#123;</span></span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 내부 클래스</span></span><br><span class="line">  inner ButtonState: State&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서 ButtonState는 중첩 클래스에 해당되며 아무런 변경자가 붙지 않으면 자바의 static 중첩 클래스와 같다. 따라서 바깥쪽 클래스에 대한 참조가 없고, 이로 인해서 직렬화가 가능하다.</li>
<li>이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하고 싶으면 <code>inner</code> 변경자를 붙이면 된다. 이렇게 되면 <strong>NoSerializableException: Button</strong> 이라는 예외가 발생한다.
<ul>
<li>왜 Button을 직렬화할 수 없을까?</li>
<li>내부 클래스는 바깥쪽 클래스에 대한 참조를 포함한다. 그 참조로 인해 직렬화할 수 없다. Button 클래스가 직렬화할 수 있는 상태가 아니기 때문에 결론적으로 ButtonState도 직렬화할 수 없는 것이다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>📌 알고 넘어가기~</p>
</blockquote>
<ul>
<li>내부 클래스 : 바깥쪽 클래스에 대한 참조를 갖는다.</li>
<li>중첩 클래스 : 바깥쪽 클래스에 대한 참조를 갖지 않는다.</li>
</ul>
<table>
<thead>
<tr>
<th>클래스 B안에 정의된 클래스 A</th>
<th>자바에서는</th>
<th>코틀린에서는</th>
</tr>
</thead>
<tbody>
<tr>
<td>중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음)</td>
<td>Static class A</td>
<td>class A</td>
</tr>
<tr>
<td>내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)</td>
<td>class A</td>
<td>inner class A</td>
</tr>
</tbody>
</table>
<h3 id="415-sealed-class">4.1.5 Sealed Class</h3>
<ul>
<li>
<p>기존에는 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 그래서 새로운 클래스에 대한 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 버그가 발생할 가능성이 높다.</p>
</li>
<li>
<p>해법을 제공한다. 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.</p>
</li>
<li>
<p>sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.</p>
</li>
<li>
<p>Sealed 클래스는 자동으로 open이다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>): Expr()</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr): Expr()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">	<span class="keyword">when</span>(e)&#123;</span><br><span class="line">    <span class="keyword">is</span> Expr.Num -&gt; e.value</span><br><span class="line">    <span class="keyword">is</span> Expr.Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>When 식이 모든 하위 클래스를 검사하므로 else 분기가 없어도 된다.</li>
<li>클래스 외부에 sealed 클래스 자신을 상속한 클래스를 둘 수 없다.</li>
<li>나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가하면 when 식이 컴파일되지 않는다. 따라서 식을 고쳐야 한다는 사실을 파악하기 쉽다.</li>
<li>내부적으로 Expr 클래스는 private 생성자를 갖는다. 그 생성자는 클래스 내부에서만 호출할 수 있다.</li>
</ul>
<h2 id="뻔하지-않은-생성자와-프로퍼티">[뻔하지 않은 생성자와 프로퍼티]</h2>
<ul>
<li>주 생성자 : 클래스를 초기화할 때, 주로 사용하는 간략한 생성자로 클래스 본문 밖에서 정의한다.</li>
<li>부 생성자 : 클래스 본문 안에서 정의한다.</li>
</ul>
<h3 id="421-클래스-초기화-주-생성자와-초기화-블록">4.2.1 클래스 초기화 : 주 생성자와 초기화 블록</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<ul>
<li>중괄호도 없고 괄호 사이에 val만 존재한다.</li>
<li>이처럼 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드는 <strong>주 생성자</strong>라 부른다.</li>
<li>주 생성자는 생성자 파라미터를 정의하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  init&#123;</span><br><span class="line">    nickname = _nickname</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Constructor : 주 생성자나 부 생성자 정의를 할 때 사용되며, 주 생성자의 경우 어노테이션이나 가시성 변경자가 없으면 생략해도 된다.</li>
<li>Init : 초기화 블록으로 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다.</li>
<li>초기화 블록은 주 생성자와 함께 쓰인다. 이유는 주 생성자가 제한적이기 때문에 별도의 코드를 포함할 수 없기 때문!</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(_nickname: String)&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname = _nickname</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 초기화 블록 없이 프로퍼티 선언에 초기화를 포함시킬 수 있다.</li>
<li>그렇다면 더 간단하게 할 수 있을까? 아래의 코드를 보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> lee = User(<span class="string">"VictoryWoo"</span>) <span class="comment">// new 없이 바로 생성자 호출!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름 앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.</li>
<li>함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String)&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwitterUser</span></span>(name: String) : User(name)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>상위 클래스 초기화를 위해서 클래스 뒤에 괄호 안에 생성자로 인자를 넘긴다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Button</span></span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Click</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadioButton</span>: <span class="type">Button</span></span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> : <span class="type">Click</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>Button : 별도의 생성자를 정의하지 않아 컴파일러가 자동으로 아무 일도 하지 않는 인자 없는 디폴트 생성자를 만든다.</li>
<li>RadioButton : Button 클래스를 상속했기 때문에 Button의 생성자를 호출해야 한다.</li>
<li>CustomView : Click이 인터페이스이므로 이름만 명시.</li>
</ul>
<h3 id="422-부-생성자">4.2.2 부 생성자</h3>
<ul>
<li>코틀린의 디폴트 값 + 이름 있는 인자를 사용해 생성자가 여럿 있는 경우 처리가 가능하다.</li>
<li><strong>인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여럿 만들지 말고 대신 파라미터의 디폴트 값을 생성자 시그니처에 명시하라.</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(context: Context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> : <span class="type">View&#123;</span></span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 디폴트 값을 넘겨 같은 클래스의 다른 생성자 호출. </span></span><br><span class="line">  <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context, WOO_STYLE)&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(context: Context, attr: AttributeSet)</span><br><span class="line">  	: <span class="keyword">super</span>(context, attr)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyButton에서는 super()를 통해 상위 클래스의 생성자를 호출함으로써 객체 생성을 위임한다.</li>
<li>클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다.</li>
</ul>
<blockquote>
<p>프로퍼티란?</p>
</blockquote>
<ul>
<li>
<p>코틀린은 프로퍼티를 언어의 기본 기능으로 제공.</p>
</li>
<li>
<p>이는 필드와 접근자를 통칭하는 것이다.</p>
</li>
<li>
<p>즉, 데이터를 저장하고 get, set이 가능함을 의미한다.</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린의 기본 가시성은 public이기 때문에 getter, setter도 동일하게 가져간다. 그런데, 필드에 저장된 데이터의 가시성은 public이 아니다. <strong>생성자에 선언된 데이터는 private이 된다.</strong></li>
</ul>
<p><code>Q. 외부에서 Person 객체를 생성한 뒤, name, isMarried에 접근이 가능할까??</code></p>
<p>— 고민의 시간 —</p>
<ul>
<li><strong>[반면, 일반 클래스 필드에 넣은 데이터는 private으로 지정해주지 않을 경우 public이 된다.]</strong> 라고 하는데 확인해 본 결과 필드에 넣은 데이터 또한 private으로 선언되며, getter가 public으로 지정된다.</li>
<li><strong>선언된 데이터가 private이 된다는 것은 자바 코드로 변환했을 때, 필드의 선언이 private이 되며 getter, setter는 public인 상태가 된다는 것을 의미한다.</strong> 만약, 생성자의 프로퍼티를 private으로 지정한다면 getter, setter도 private이 되어 접근이 불가능하다. (위의 질문에 대한 답이 된다.)</li>
</ul>
<p><strong>[생성자 파라미터의 val, var의 차이]</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name: String) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>1번의 경우 자바 코드로 변환되면 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.09.35](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.09.35.png)</p>
<ul>
<li>생성자에 있는 name은 프로퍼티가 되며, 외부에서도 접근이 가능하다.</li>
</ul>
<p>2번의 경우 자바 코드로 변환시 아래와 같다.</p>
<p>![스크린샷 2020-02-27 오후 3.10.03](/Users/woo/Desktop/스크린샷 2020-02-27 오후 3.10.03.png)</p>
<ul>
<li>이 경우 name은 생성자에서 프로퍼티를 초기화하는 역할만을 하고, 사용할 수 없다. 따라서 클래스의 생성자 외 다른 메소드에서 사용할 수 없다. (프로퍼티가 아니기 때문)</li>
</ul>
<p><strong>[주의할 점]</strong></p>
<p>위에서 설명했지만, 한번 더 짚고 넘어간다.</p>
<p>디컴파일한 자바 코드를 보면 필드가 private으로 되어 있는 것을 볼 수 있다.</p>
<p>이렇다고 하더라도 코틀린의 프로퍼티가 private은 아니다. 여기서 우리는 <strong>필드와 프로퍼티를 다르게 인식할 줄 알아야 한다.</strong> 자바는 기본적으로 필드로 다루고, 코틀린은 프로퍼티(필드+접근자)를 기본으로 다루는 언어이기 때문에 약간의 차이가 존재한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">setName</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>필드인 name 자체만 보면 private 키워드가 붙어있으므로 private이 맞지만, 프로퍼티 전체를 보면 다르다. getter/setter로 접근이 모두 가능하기 때문에 프로퍼티는 private하다고 볼 수 없다.</p>
<p>위의 코드에서 name 프로퍼티가 private이기 위해서는 아래와 같이 수정해야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Property</span><span class="params">(@NotNull String name)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getter/setter가 없어 프로퍼티는 private이라고 볼 수 있다.</p>
<ul>
<li><a href="https://wooooooak.github.io/kotlin/2019/05/24/property/" target="_blank" rel="noopener">참고</a></li>
</ul>
<h3 id="423-인터페이스에-선언된-프로퍼티-구현">4.2.3 인터페이스에 선언된 프로퍼티 구현</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인터페이스에 추상 프로퍼티 선언이 있고, 상태를 저장하기 위해서는 해당 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티 등을 만들어야 한다.</li>
<li>아래는 각기 다른 방식으로 이를 구현한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateUser</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> nickname: String): User</span><br><span class="line"><span class="comment">// 주 생성자에 있는 프로퍼티</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribingUser</span></span>(<span class="keyword">val</span> email: String): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> name: String</span><br><span class="line">  	<span class="keyword">get</span>() = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 커스텀 게터</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FacebookUser</span></span>(<span class="keyword">val</span> accountId: <span class="built_in">Int</span>): User&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> nickname = getFacebookNam(accountId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 프로퍼티 초기화 식</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SubscribingUser</strong> : nickname은 매번 호출될 때마다 substringBefore()를 호출해 새로운 값을 계산하는 커스텀 getter를 사용한다.</li>
<li><strong>FacebookUser</strong> : nickname은 객체 초기화 시 계산한 데이터를 저장했다가 불러오는 방식을 이용한다.</li>
</ul>
<h3 id="424-게터와-세터에서-뒷받침하는-필드-접근">4.2.4 게터와 세터에서 뒷받침하는 필드 접근</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">"unspecified"</span></span><br><span class="line">        <span class="keyword">set</span>(value: String) &#123;</span><br><span class="line">            println(<span class="string">"""</span></span><br><span class="line"><span class="string">                Address was changed for <span class="variable">$name</span>:</span></span><br><span class="line"><span class="string">                "<span class="variable">$field</span>" -&gt; "<span class="variable">$value</span>"."""</span>.trimIndent())</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="string">"Alice"</span>)</span><br><span class="line">    user.address = <span class="string">"Elsenheimerstrasse 47, 80687 Muenchen"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setter 접근자의 본문에서 field를 통해 뒷받침하는 필드에 접근할 수 있다.(<strong>address</strong>)</li>
<li>getter는 field 값을 읽을 수만 있고, setter는 field 값을 읽거나 쓸 수 있다.</li>
</ul>
<h3 id="425-접근자의-가시성-변경">4.2.5 접근자의 가시성 변경</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addWord</span><span class="params">(word: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        counter += word.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lengthCounter = LengthCounter()</span><br><span class="line">    lengthCounter.addWord(<span class="string">"Hi!"</span>)</span><br><span class="line">    println(lengthCounter.counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>기본 가시성을 가지는 getter를 컴파일러가 생성하게 냅두고 setter의 가시성을 private으로 지정하여 외부 코드에서 단어 길이의 합을 마음대로 바꾸지 못하게 하였다.</li>
</ul>
<h2 id="컴파일러가-생성한-메소드-데이터-클래스와-클래스-위임">[컴파일러가 생성한 메소드 : 데이터 클래스와 클래스 위임]</h2>
<h3 id="431-모든-클래스가-정의해야-하는-메소드">4.3.1 모든 클래스가 정의해야 하는 메소드</h3>
<p>자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다.</p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>자바는 == 를 원시 타입과 참조 타입을 비교할 때 사용한다.</p>
<p>원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교하고, 참조 타입의 경우 == 는 두 피연산자의 주소가 같은지 비교한다. 따라서 자바에서 두 객체의 동등성을 알려면 equals()를 호출해야 한다.</p>
<p><strong>코틀린에서는 == 연산자가 두 객체를 비교하는 기본적인 방법이다.</strong> ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 따라서 클래스가 equals()를 오버라이드하면 == 을 통해 안전하게 클래스의 인스턴스를 비교할 수 있다.</p>
<p>참조 비교를위해서는. === 연산자를 사용할 수 있다.</p>
<p>=== 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 ==와 같다.</p>
<h3 id="432-data-class">4.3.2 data class</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> postalCode: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>class 앞에 data를 붙이면 자동으로 toString(), copy(), equals(), hashCode()를 포함한다.</li>
<li>이를 데이터 클래스라고 부르며 주로 데이터를 저장하는 역할을 한다.</li>
<li>주의할 점은 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 아니다.</li>
</ul>
<p><strong>[copy() 메소드]</strong></p>
<ul>
<li>데이터 클래스의 프로퍼티가 모두 val일 필요는 없다. var여도 된다. 하지만 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어 불변 클래스로 만들라고 권장한다.</li>
<li>불변의 장점 : 다중 스레드에서 동기화를 고려하지 않아도 됨.</li>
<li>Copy() : 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해준다.</li>
<li>객체를 메모리 상에서 직접 바꾸는 대신 복사본을 만드는 편이 더 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향을 끼치지 않는다.</li>
</ul>
<h3 id="433-클래스-위임-by">4.3.3 클래스 위임 : by</h3>
<ul>
<li>인터페이스를 구현할 때, by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임 중이라는 사실을 명시할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingCollection</span>&lt;<span class="type">T</span>&gt;</span>(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()) : Collection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러가 전달 메소드를 자동으로 생성하며, 자동 생성한 코드의 구현은 책에 실린 코드와 비슷하다.</li>
<li>Collection의 구현을 innerList에게 위임한다.</li>
<li>메소드 중 일부의 동작을 변경하고 싶을 때는 메소드를 오버라이드 하면 컴파일러가 오버라이드한 메소드를 쓴다.</li>
</ul>
<p>Ex)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountingSet</span>&lt;<span class="type">T</span>&gt;</span>(</span><br><span class="line">        <span class="keyword">val</span> innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()</span><br><span class="line">) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerSet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> objectsAdded = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded++</span><br><span class="line">        <span class="keyword">return</span> innerSet.add(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(c: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        objectsAdded += c.size</span><br><span class="line">        <span class="keyword">return</span> innerSet.addAll(c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cset = CountingSet&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line">    cset.addAll(listOf(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;cset.objectsAdded&#125;</span> objects were added, <span class="subst">$&#123;cset.size&#125;</span> remain"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>add, addAll을 오버라이드해서 count를 증가시키고 MutableCollection 인터페이스의 나머지 메소드는 내부 컨테이너인 innerSet에게 위임한다.</p>
</li>
<li>
<p>CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 생기지 않는다. CountingSet 코드는 위임 대상 내부 클래스인 MutableCollection의 API를 활용하므로 API를 변경하지 않는 한 CountingSet 코드가 계속 잘 작동할 것임을 확신할 수 있다.</p>
<p>-&gt; <strong>CountingSet의 생성자 파라미터에 존재하는 innerSet 프로퍼티에게 MutableCollection의 구현을 위임했기 때문에 CountingSet은 MutableCollection의 구현 방식에 대한 의존 관계가 없다. innerSet이 MutableCollection에 의존 관계를 가지고 있다.</strong></p>
</li>
</ul>
<h2 id="object-키워드-클래스-선언과-인스턴스-생성">object 키워드 : 클래스 선언과 인스턴스 생성</h2>
<h3 id="441-객체-선언-싱글톤">4.4.1 객체 선언 : 싱글톤</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Payroll&#123;</span><br><span class="line">  <span class="keyword">val</span> allEmployees = arrayListOf&lt;Person&gt;()</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">calculateSalary</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(person <span class="keyword">in</span> allEmployees)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object를 통해 기본적으로 싱글톤 기능을 언어 레벨에서 제공한다.</li>
<li>객체 선언 = 클래스 선언 + 그 클래스에 속한 단일 인스턴스의 선언</li>
<li>생성자는 쓸 수 없다. 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문에 생성자 정의가 필요없다.</li>
<li>object 선언도 클래스나 인터페이스 상속이 가능하다.</li>
<li>클래스 안에 object 선언도 가능하다. 이 객체도 인스턴스는 단 하나뿐이다. (바깥쪽 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 따로 하나씩 생기는 것이 아니다.)</li>
</ul>
<h3 id="442-동반-객체">4.4.2 동반 객체</h3>
<ul>
<li>kotlin에서는 static 개념이 존재하지 않는다.</li>
<li>패키지 수준의 최상위 함수가 정적 메소드 역할을 대신할 수 있다.  객체 선언은 정적 필드를 대신할 수도 있다.</li>
<li>최상위 함수를 권장하지만, 클래스에 비공개 멤버를 포함하면 이 멤버에 접근할 수 없다.</li>
<li>그래서 클래스의 인스턴스와 관계 없이 호출해야 하지만, 클래스 내부 정보에 접근해야 할 때 companion object를 사용하면 된다.</li>
<li>companion object는 외부 클래스의 private한 멤버 접근이 가능하기 때문에 팩토리 메소드를 만들 때 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"Companion object called"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    A.bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>호출할 때, 클래스 이름으로 바로 호출이 가능하다.</li>
<li>이름을 따로 지정하지 않아도 되며, 사용 예를 보면 자바의 정적 메소드 호출이나 정적 필드 사용 구문과 같아진다.</li>
<li>즉, 자바의 static 함수 호출과 동일하다.</li>
</ul>
<p>Ex)</p>
<p><strong>부 생성자가 여럿 있는 클래스</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> nickname: String</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(email: String)&#123;</span><br><span class="line">    nickname = email.substringBefore(<span class="string">'@'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(accountId: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    nickname = getFacebookName(accountId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>팩토리 메소드로 부 생성자 대신하기</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId:<span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> user = User.newSubscribinUser(<span class="string">"Victory@gmail.com"</span>)</span><br><span class="line">  println(user.nickname)</span><br><span class="line">  <span class="comment">// Victory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>User는 private constructor를 가지기 때문에 외부에서 생성하지 못한다. 따라서 외부에서는 companion object로 제공되는 팩토리 메소드를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</li>
</ul>
<h3 id="433-동반-객체를-일반-객체처럼-사용">4.3.3 동반 객체를 일반 객체처럼 사용</h3>
<p>동반 객체 = 클래스 안에 정의된 일반 객체</p>
<p>따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object 이름 명명 가능.</li>
<li>companion object 내부에 확장 함수와 프로퍼티 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">  Person.Loader.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">  Person.fromJson(<span class="string">"&#123;name: 'Lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 두 방법 모두 제대로 fromJson을 호출할 수 있다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> : JSONFactory&lt;Person&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span>: Person &#123;</span><br><span class="line">            <span class="keyword">return</span> Person(<span class="string">"Lee"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">loadFromJSON</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    loadFromJSON(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 companion object가 특정 인터페이스를 구현할 수도 있고, <strong>동반 객체가 구현한 JSONFactory 인터페이스를 넘길 때 Person 클래스(외부 클래스)의 이름을 사용한다.</strong></p>
<blockquote>
<p>알고 넘어가기!</p>
</blockquote>
<p>때로 자바에서 사용하기 위해 코틀린 클래스의 멤버를 정적인 멤버로 만들어야 할 필요가 있다.</p>
<p>그런 경우 <code>@JvmStatic</code> 어노테이션을 코틀린 멤버에 붙이면 된다.</p>
<p>정적 필드가 필요하다면 <code>@JvmField</code> 어노테이션을 최상위 프로퍼티나 객체에서 선언된 프로퍼티 앞에 붙인다.</p>
<p>이는 10장에서 더 자세히 알아보자!</p>
<p>동반 객체를 이용해 외부에서 확장 함수를 정의할 수 있다고 했다. 아래 코드를 통해서 확인해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">  <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.Companion.<span class="title">fromJSON</span><span class="params">(json: <span class="type">String</span>)</span></span> : Person&#123;</span><br><span class="line">  <span class="comment">// 확장 함수 정의.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Person.fromJSON(<span class="string">"json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>마치 동반 객체 안에 fromJSON을 정의한 것처럼 함수를 호출할 수 있다.</li>
<li>동반 객체에 대한 확장 함수를 정의하기 위해서는 원래 클래스에 동반 객체를 꼭 선언해야 한다.(비어있어도 괜찮다.)</li>
</ul>
<h3 id="444-무명-클래스">4.4.4 무명 클래스</h3>
<ul>
<li>무명 객체를 정의할 때도 object 키워드를 쓴다.</li>
<li>무명 객체는 자바의 무명 내부 클래스를 대신한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> listener = <span class="keyword">object</span> : ClickListener&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">"Clicked Listener!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">      println(<span class="string">"Clicked!!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  setClickAction(listener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">  clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object 선언과 달리 익명 클래스는 싱글톤이 아니다. 따라서 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다.</li>
<li>또한, 무명 객체 즉, 익명 클래스 안에서 함수에 정의된 로컬 변수를 사용할 수도 있다.
<ul>
<li>자바와 조금 다른 점이다. 자바는 익명 클래스에서 접근 시 무조건 final이어야 한다.</li>
</ul>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li>Made by <a href="https://github.com/WooVictory" target="_blank" rel="noopener">Me</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/01/KotlinInAction-Chap4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/01/KotlinInAction-Chap3/"
                            aria-label=": [Kotlin in action] Chap3. 함수 정의와 호출"
                        >
                            [Kotlin in action] Chap3. 함수 정의와 호출
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-01T20:02:44+09:00">
	
		    Apr 01, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="함수-정의와-호출">함수 정의와 호출</h3>
<p><strong>코틀린 컬렉션</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">7</span>, <span class="number">53</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">"one"</span>, <span class="number">7</span> to <span class="string">"seven"</span>, <span class="number">53</span> to <span class="string">"fifty-three"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="keyword">set</span>.javaClass)	<span class="comment">//class java.util.HashSet</span></span><br><span class="line">    println(list.javaClass)  <span class="comment">//class java.util.ArrayList</span></span><br><span class="line">    println(map.javaClass)  <span class="comment">//class java.util.HashMap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바 컬렉션을 활용한 <strong>코틀린 컬렉션</strong></li>
<li>자바보다 더 많은 기능을 쓸 수 있음</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"fourteenth"</span>)</span><br><span class="line">println(strings.last())	<span class="comment">//fourteenth</span></span><br><span class="line"><span class="keyword">val</span> numbers = setOf(<span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>)</span><br><span class="line">println(numbers.max())	<span class="comment">//14</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>last()</code>, <code>max()</code> 는 코틀린에서 편의를 위해 추가한 <strong>확장함수</strong></li>
</ul>
<p><strong>직관적인 함수 호출</strong></p>
<ul>
<li>toString()함수 응용한 함수</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        collection: <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        separator: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        prefix: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        postfix: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: String &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> collection.withIndex()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> alphabets = listOf(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">    println(joinToString(list, separator = <span class="string">"; "</span>, prefix = <span class="string">"("</span>, postfix = <span class="string">")"</span>))</span><br><span class="line">    println(joinToString(alphabets, separator = <span class="string">"; "</span>, prefix = <span class="string">"("</span>, postfix = <span class="string">")"</span>))</span><br><span class="line">    <span class="comment">//(1; 2; 3)</span></span><br><span class="line">    <span class="comment">//(a; b; c)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인자 이름 &amp; 기본 파라미터 값</li>
</ul>
<ul>
<li>인자의 이름을 명시 가능</li>
</ul>
<p><strong>Java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joinToString(collection, <span class="comment">/* separator */</span> <span class="string">""</span>, <span class="comment">/* prefix */</span> <span class="string">""</span>, <span class="comment">/*postfix */</span> <span class="string">"."</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Kotlin</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">joinToString(collection, prefix = <span class="string">"("</span>, separator = <span class="string">";"</span>, postfix = <span class="string">")"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>차이점?</strong> 파라미터 이름이 같다면 순서를 바꿔도 가능!<br>
<strong>주의!</strong> 자바에서 작성한 코드를 코틀린에서 호출한 경우에는 인자 이름 명시 불가능!<br>
함수 파라미터에 정보를 넣는 것은 자바 8이후, 코틀린은 JDK 6과 호환!</p>
<ul>
<li>기본 파라미터 값 초기화</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    collection : <span class="type">Collection</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        postfix: <span class="type">String</span> = <span class="string">""</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: String &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    println(joinToString(list))	</span><br><span class="line">    <span class="comment">//1, 2, 3</span></span><br><span class="line">    println(joinToString(list, separator = <span class="string">";"</span>))	</span><br><span class="line">    <span class="comment">//1;2;3</span></span><br><span class="line">    println(joinToString(list, separator = <span class="string">"; "</span>, prefix = <span class="string">"("</span>))	</span><br><span class="line">    <span class="comment">//(1; 2; 3</span></span><br><span class="line">    println(joinToString(list, separator = <span class="string">"; "</span>, prefix = <span class="string">"("</span>, postfix = <span class="string">")"</span>))</span><br><span class="line">      <span class="comment">//(1; 2; 3;)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>값을 지정하지 않은 모든 인자는 디폴트 값을 적용</li>
</ul>
<p><strong>주의!</strong>   자바에는 디폴트 파라미터 값이라는 개념이 없기때문에 코틀린 함수를 자바에서 호출하는 경우<br>
@JvmOverloads 애노테이션을 추가하면 컴파일러가 자동으로 오버로딩 함수 생성</p>
<p><strong>최상위 함수와 프로퍼티</strong></p>
<ul>
<li>최상위 함수
<ul>
<li>Java</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinKt</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">joinToString</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Kotlin</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> strings</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">joinToString</span><span class="params">(...)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바에서 함수 호출</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.JointKt; </span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">JoinKt.joinToStirng(list,<span class="string">","</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>파일에 대응하는 클래스 이름 변경</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//코틀린</span></span><br><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">"StringFunctions"</span>)	<span class="comment">//패키지명 선언보다 이전에 위치</span></span><br><span class="line"><span class="keyword">package</span> strings</span><br></pre></td></tr></table></figure>
<pre><code>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//자바에서 호출</span></span><br><span class="line"><span class="keyword">import</span> strings.StringFunctions;</span><br><span class="line">StringFunctions.joinToString(list, <span class="string">","</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p><s>UtilClass를 대신해서 사용할 수 있다는 장점이 있다고 했는데, Util이 더 편하지않나…?</s></p>
</blockquote>
<ul>
<li>최상위 프로퍼티</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt;		<span class="comment">//최상위 프로퍼티</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">performOperation</span><span class="params">()</span></span>&#123;	<span class="comment">//최상위 함수</span></span><br><span class="line">	cnt++</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>프로퍼티를 클래스보다 더 이전에 위치</li>
<li>최상위 프로퍼티도 접근자 메소드를 통해 접근가능</li>
<li><code>const</code> 변경자를 추가하면 <code>public static final</code> 필드로 만들 수 있다.</li>
</ul>
<p><strong>확장함수와 확장 프로퍼티</strong></p>
<ul>
<li>
<p>클래스의 멤버 메서드처럼 호출되지만 클래스 밖에 호출되는 함수</p>
</li>
<li>
<p>확장함수를 만들기 위해서는 <strong>수신객체타입</strong>(<code>Receiver Type</code>)과 <strong>수신객체</strong>(<code>Receiver Object</code>)가 필요</p>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span> : <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line">println(<span class="string">"Kotlin"</span>.lastChar())</span><br><span class="line"><span class="comment">//n</span></span><br></pre></td></tr></table></figure>
<ul>
<li>수신객체타입(<code>Receiver Type</code>): 확장이 정의될 클래스 ex) String</li>
<li>수신객체(<code>Receiver Object</code>): 위 클래스의 인스턴스 객체 ex)“Kotlin”, this</li>
<li>확장함수 안에서는 <code>private</code>나 <code>protected</code> 접근 불가능, 해당 클래스의 <code>public</code>함수에만 접근 가능</li>
<li>확장함수의 Import</li>
<li>확장함수를 사용하기 위해서는 import를 통해서 사용</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.lastChar		</span><br><span class="line"><span class="comment">//import strings.*</span></span><br><span class="line"><span class="keyword">val</span> c = <span class="string">"Kotlin"</span>.lastChar()</span><br></pre></td></tr></table></figure>
<p><strong>주의!</strong> : 한 클래스 내의 같은 이름의 확장함수가 둘 이상일 경우 이름이 충돌할 수 있으니 <code>as</code>를 사용</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> strings.lastChar <span class="keyword">as</span> last</span><br><span class="line"><span class="keyword">val</span> c = <span class="string">"Kotlin"</span>.last()</span><br></pre></td></tr></table></figure>
<ul>
<li>joinToString함수를 이용한 확장함수</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Collection<span class="type">&lt;T&gt;</span>.<span class="title">joinToString</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        postfix: <span class="type">String</span> = <span class="string">""</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> result = StringBuilder(prefix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ((index, element) <span class="keyword">in</span> <span class="keyword">this</span>.withIndex()) &#123;	<span class="comment">//this는 수신객체</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) result.append(separator)</span><br><span class="line">        result.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.append(postfix)</span><br><span class="line">    <span class="keyword">return</span> result.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//문자열의 컬렉션만 받음</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Collection<span class="type">&lt;String&gt;</span>.<span class="title">join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        separator: <span class="type">String</span> = <span class="string">", "</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        prefix: <span class="type">String</span> = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        postfix: <span class="type">String</span> = <span class="string">""</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> = joinToString(separator, prefix, postfix)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(listOf(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"eight"</span>).join(<span class="string">" "</span>))	<span class="comment">//one two eight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>내부적으로 확장함수는 <strong>수신객체</strong>를 <strong>첫 번째 인자</strong>로 받음</li>
<li>자바에서 호출시 <strong>수신객체</strong>를 첫 번째 인자로 넘겨줘야함</li>
</ul>
<p><strong>확장함수의 오버라이드</strong></p>
<ul>
<li>멤버함수 오버라이드</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">"View clicked"</span>)	<span class="comment">//멤버함수</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">View</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">"Button clicked"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view: View = Button()</span><br><span class="line">    view.click()	<span class="comment">//Button Clicked</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>확장 함수가 정적 메소드와 같은 특징을 가지므로 확장함수를 하위 클래스에서 오버라이드 할 수 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">"View clicked"</span>)	<span class="comment">//멤버함수</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>: <span class="type">View</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">()</span></span> = println(<span class="string">"Button clicked"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm a view!"</span>)		<span class="comment">//확장함수</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Button.<span class="title">showOff</span><span class="params">()</span></span> = println(<span class="string">"I'm a button!"</span>)	<span class="comment">//확장함수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> view: View = Button()</span><br><span class="line">    view.showOff()	<span class="comment">//I'm a view!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>확장 함수는 클래스의 밖에 선언되며 확장함수 호출 시, 수신 객체로 지정한 변수의 정적 타입에 의해 어떤 확장함수가 올 지 결정되는 것이지, 변수의 객체에 저장된 동적인 타입에 의해 확장 함수가 결정되지 않는다.</li>
</ul>
<p>&lt;그림 3.2 참고&gt;</p>
<p><code>TODO - 알고가자!</code></p>
<ol>
<li><code>open class</code> : 코틀린에서의 모든 클래스는 암시적으로 상위 클래스로 <code>Any</code>클래스를 가지는데,명시적으로 상위클래스를 지정하기 위해서는 <code>open</code>을 명시</li>
<li>멤버메서드? 정적메서드? 확장메서드?</li>
<li>특정 클래스에 추가된 확장함수가 멤버함수와 이름이 같다면 우선순위는 <strong>멤버함수 &gt; 확장함수</strong></li>
</ol>
<p><strong>확장 프로퍼티</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> String.lastChar : <span class="built_in">Char</span></span><br><span class="line">	<span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)		<span class="comment">//getter만</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> StringBuilder.lastChar : <span class="built_in">Char</span></span><br><span class="line">	<span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">set</span>(value : <span class="built_in">Char</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setChartAt(length - <span class="number">1</span>, value)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>일반 프로퍼티와 같은데 대신 <strong>수신객체클래스</strong>가 추가 되었을 뿐</li>
<li>확장 프로퍼티는 <code>backing field</code>를 가지고 있지않으니 최소한 getter()는 구현해야 함.</li>
</ul>
<p><strong>컬렉션 처리</strong></p>
<ul>
<li>가변인자함수</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> strings = listOf(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> listOf<span class="type">&lt;T&gt;</span><span class="params">(<span class="keyword">vararg</span> <span class="keyword">var</span>: <span class="type">T</span>)</span></span> : List&lt;T&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>vararg</code>를 변경자로 선언타입 앞에 붙임</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">vararg</span> numbers: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        println(number)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbers = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">printNumbers(*numbers)</span><br><span class="line">printNumbers(<span class="number">10</span>, <span class="number">20</span>, *numbers, <span class="number">30</span>, <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>자바의 <code>스프레드 연산자</code>: <code>...</code> / 코틀린의 <code>스프레드 연산자</code> <code>*</code></li>
<li>배열(Array)을 함수에 전달할 수 있다.</li>
<li>중위 호출</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> to <span class="string">"one"</span>		<span class="comment">//중위함수 호출</span></span><br><span class="line"><span class="number">1.</span>to(<span class="string">"one"</span>)		<span class="comment">//확장함수 호출</span></span><br></pre></td></tr></table></figure>
<ul>
<li>중위함수 to</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Any.<span class="title">to</span><span class="params">(other : <span class="type">Any</span>)</span></span> = Pair(<span class="keyword">this</span>, other)    <span class="comment">// to는 중위함수이자 확장함수</span></span><br></pre></td></tr></table></figure>
<ul>
<li>구조 분해 선언(7장에서 자세히 다룸)</li>
</ul>
<ul>
<li>data class 형태로 나오는 여러 값을 동시에 반환할 수 있다.</li>
<li>자동으로 componentN함수가 생성됨.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> <span class="keyword">this</span>.withIndex()) &#123;	<span class="comment">//this는 수신객체 Collection&lt;Int&gt; / (1, 2, 3)</span></span><br><span class="line">     println(<span class="string">"<span class="variable">$index</span>: <span class="variable">$element</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Size</span></span>(<span class="keyword">val</span> width : <span class="built_in">Int</span>, <span class="keyword">val</span> height : <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> size = Size(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> (w, h) = size</span><br><span class="line">    <span class="keyword">val</span> a = size.component1()</span><br><span class="line">    <span class="keyword">val</span> b = size.component2()</span><br><span class="line">    </span><br><span class="line">    println(a) <span class="comment">// 10</span></span><br><span class="line">    println(b) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>문자열과 정규식</strong></p>
<ul>
<li>문자열 나누기 / split()</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String.kt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">split</span><span class="params">(regex: <span class="type">Regex</span>, limit: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: List&lt;String&gt; = regex.split(<span class="keyword">this</span>, limit)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">split</span><span class="params">(<span class="keyword">vararg</span> delimiters: <span class="type">String</span>, ignoreCase: <span class="type">Boolean</span> = <span class="literal">false</span>, limit: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: List&lt;String&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"12.345-6.A"</span>.split(<span class="string">"\\.|-"</span>.toRegex()))		<span class="comment">//정규식을 파라미터로 받는 함수</span></span><br><span class="line"><span class="comment">//[12, 345, 6, A]</span></span><br><span class="line">println(<span class="string">"12.345-6.A"</span>.split(<span class="string">"."</span>, <span class="string">"-"</span>))			    <span class="comment">//String을 파라미터로 받는 함수</span></span><br><span class="line"><span class="comment">//[12, 345, 6, A]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>마침표 <code>.</code> 를 문자로 읽기위해 <code>\\.</code>을 사용하여 escape 시킴</li>
<li>코틀린에서는 split()의 확장함수를 제공함으로써 Java의 와일크카드 문자(?)로 인한 혼동을 피함.
<ul>
<li>정규식 표현 <a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a>,  <a href="https://ihateregex.io/playground%EC%97%90%EC%84%9C" target="_blank" rel="noopener">https://ihateregex.io/playground에서</a> 찾으면 쉽다.</li>
</ul>
</li>
</ul>
<ul>
<li>정규식과 3중 따옴표</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parsePath</span><span class="params">(path: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> regex = <span class="string">"""(.+)/(.+)\.(.+)"""</span>.toRegex()</span><br><span class="line">    <span class="comment">//group#1: /Users/yole/kotlin-book</span></span><br><span class="line">    <span class="comment">//group#2: chapter</span></span><br><span class="line">    <span class="comment">//group#3: adoc</span></span><br><span class="line">    <span class="keyword">val</span> matchResult = regex.matchEntire(path)</span><br><span class="line">    <span class="keyword">if</span> (matchResult != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> (directory, filename, extension) = matchResult.destructured</span><br><span class="line">        <span class="comment">// val directory = matchResult.destructured.component1()</span></span><br><span class="line">        <span class="comment">// val filename = matchResult.destructured.component2()</span></span><br><span class="line">        <span class="comment">// val extension = matchResult.destructured.component3()</span></span><br><span class="line">        println(<span class="string">"Dir: <span class="variable">$directory</span>, name: <span class="variable">$filename</span>, ext: <span class="variable">$extension</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    parsePath(<span class="string">"/Users/yole/kotlin-book/chapter.adoc"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3중 따옴표를 사용하면, <code>\</code>, <code>\n</code>등을 포함한 어떤 문자도 따로 escape  시킬 필요가 없다.</li>
<li><strong>주의!</strong> : 역슬래쉬(<code>\</code>)나 줄바꿈(<code>\n</code>)등을 3중 따옴표 안에 넣으면 문자로 인식해서 그냥 출력된다.</li>
</ul>
<p><strong>중첩함수(Local method)</strong></p>
<ul>
<li>함수에서 추출한 함수를 원 함수 내부에 중첩시키는 것을 말함.</li>
<li>코드중복을 보여주는 예제  //아직 중첩함수 X</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.name.isEmpty()) &#123;					<span class="comment">//-----------검증 중복</span></span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Name"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user.address.isEmpty()) &#123;				<span class="comment">//------------검증 중복</span></span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">            <span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty Address"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save user to the database</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    saveUser(User(<span class="number">1</span>, <span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">    <span class="comment">//Can't save user $&#123;user.id&#125;: empty Name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>중첩함수를 이용한 중복 줄이기</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(user: <span class="type">User</span>,				<span class="comment">//중첩함수 validate(...)선언</span></span></span></span><br><span class="line"><span class="function"><span class="params">                 value: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 fieldName: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: empty <span class="variable">$fieldName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(user, user.name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(user, user.address, <span class="string">"Address"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save user to the database</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    saveUser(User(<span class="number">1</span>, <span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>중첩함수는 자신이 속한 바깥함수의 모든 파라미터와 변수를 참조 가능</li>
<li>따라서 validate의 파라미터인 user까지 제거</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;	<span class="comment">//불필요한 user파라미터 제거</span></span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Can't save user <span class="subst">$&#123;user.id&#125;</span>: "</span> +</span><br><span class="line">                    <span class="string">"empty <span class="variable">$fieldName</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(user.name, <span class="string">"Name"</span>)							<span class="comment">//user.name만 전달</span></span><br><span class="line">    validate(user.address, <span class="string">"Address"</span>)					<span class="comment">//user.address만 전달</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save user to the database</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    saveUser(User(<span class="number">1</span>, <span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>확장함수를 이용해서 검증로직 개선</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">validateBeforeSave</span><span class="params">()</span></span> &#123;			<span class="comment">//User클래스의 확장함수</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">validate</span><span class="params">(value: <span class="type">String</span>, fieldName: <span class="type">String</span>)</span></span> &#123;	<span class="comment">//중첩함수</span></span><br><span class="line">        <span class="keyword">if</span> (value.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(</span><br><span class="line">               <span class="string">"Can't save user <span class="variable">$id</span>: empty <span class="variable">$fieldName</span>"</span>)	<span class="comment">//&#123;$user.id&#125;를 쓸 필요 X, $id O </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validate(name, <span class="string">"Name"</span>)</span><br><span class="line">    validate(address, <span class="string">"Address"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saveUser</span><span class="params">(user: <span class="type">User</span>)</span></span> &#123;</span><br><span class="line">    user.validateBeforeSave()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save user to the database</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    saveUser(User(<span class="number">1</span>, <span class="string">"2"</span>, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TODO - 생각해보자!</code></p>
<p>좋은 구조인가??<br>
<strong>과유불급</strong>이라고 중첩된 함수의 깊이가 깊어지면 깊어질수록 코드 읽기가 어려우니<br>
일반적으로는 <strong>한 단계</strong>만 함수를 중첩시키는 것을 권장한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.yes24.com/Product/Goods/55148593" target="_blank" rel="noopener">Kotlin In Action</a></li>
<li>Made by <a href="https://github.com/iyj9328" target="_blank" rel="noopener">iyj9328</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/01/KotlinInAction-Chap3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/01/KotlinInAction-Chap2/"
                            aria-label=": [Kotlin in Action] Chap2. 코틀린 기초"
                        >
                            [Kotlin in Action] Chap2. 코틀린 기초
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-01T19:49:20+09:00">
	
		    Apr 01, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>현재 진행하고 있는 스터디에서 <a href="http://m.yes24.com/Goods/Detail/55148593" target="_blank" rel="noopener">코틀린 인 액션</a>을 가지고 공부를 진행하고 있습니다. Github에 Repository를 생성하여 내용을 정리하여 관리하고 있지만, 블로그에서도 확인할 수 있도록 마이그레이션 하고 있습니다.</p>
<h3 id="코틀린-기초">코틀린 기초</h3>
<h4 id="1-함수">1. 함수</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록이 본문인 함수</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 식이 본문인 함수</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max2</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br><span class="line"><span class="comment">// 식입 본문인 함수는 return type 생략 가능 (feat. 타입 추론)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max3</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = inf (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 선언은 <code>fun</code> 키워드로 시작</li>
<li>fun 다음에 <code>함수명</code>을 명시</li>
<li>함수 이름 뒤에 괄호 안에 파라미터들 명시
<ul>
<li>변수 선언과 마찬가지로 파라미터 뒤에 <code>:</code>을 통해 타입을 명시</li>
</ul>
</li>
<li>본문
<ul>
<li>블록이 본문인 함수: 중괄호로 본문을 감싼 형태</li>
<li>식이 본문인 함수: 중괄호 대신 등호와 식을 이용한 형태</li>
</ul>
</li>
</ul>
<p><strong>TODO - 알고가자!</strong></p>
<blockquote>
<p>문(statement)과 식(expression)의 차이</p>
</blockquote>
<ul>
<li>식은 <strong>값을 만들어</strong> 내며 다른 식의 하위 요소로 계산에 참여할 수 있으나 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 <strong>아무런 값도 만들어내지 않는다</strong></li>
</ul>
<h4 id="2-변수">2. 변수</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입 표기 생략 (feat. 타입 추론)</span></span><br><span class="line"><span class="keyword">val</span> question = <span class="string">"TEAM-Android Study Coworker !"</span></span><br><span class="line"><span class="keyword">val</span> answer1 = <span class="number">42</span></span><br><span class="line"><span class="comment">// 타입 명시</span></span><br><span class="line"><span class="keyword">val</span> answer2: <span class="built_in">Int</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">// 초기화를 하지 않는 경우 타입 명시 필수!</span></span><br><span class="line"><span class="keyword">val</span> answer3: <span class="built_in">Int</span></span><br><span class="line">answer3 = <span class="number">42</span></span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린은 변수를 선언할 때에 변수명 뒤에 <code>:</code>을 통해 명시</li>
</ul>
<p><strong>TODO - 알고가자 !</strong></p>
<blockquote>
<p>변수명을 뒤에 명시하는 이유?</p>
</blockquote>
<ul>
<li>
<p>타입을 생략할 경우 식과 변수 선언이 구별을 할 수 없기 때문에 변수명 뒤에 명시하거나 생략하도록 설계되었다.</p>
</li>
<li>
<p>자바와 마찬가지로 부동소수점 사용시 <code>Double</code> 타입이 된다.</p>
</li>
</ul>
<p>변경 가능한 변수와 변경 불가 함수</p>
<ul>
<li><code>val</code>: <strong>변경 불가능한 값</strong>을 저장하는 변수. 일단 초기화하면 재대입이 불가.
<ul>
<li>딱 1번만 초기화가 가능</li>
<li>자바의 <code>final 변수</code>에 해당</li>
<li>val 참조 자체가 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.</li>
</ul>
</li>
</ul>
<p>아래 코드는 올바른 코드이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> languages = arrayListOf(<span class="string">"java"</span>) <span class="comment">// 불변 참조 선언</span></span><br><span class="line">languages.add(<span class="string">"kotlin"</span>) <span class="comment">// 참조가 가리키는 객체 내부를 변경</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message를 한번만 초기화한다는 것을 컴파일러가 알 수 있어 올바른 코드이다.</span></span><br><span class="line"><span class="keyword">val</span> message: Strin</span><br><span class="line"><span class="keyword">if</span> (canPerformOperation()) &#123;</span><br><span class="line">    message = <span class="string">"Success</span></span><br><span class="line"><span class="string">&#125; else &#123;</span></span><br><span class="line"><span class="string">    message = "</span>Failed<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>TODO - 의논해보자!</strong></p>
<blockquote>
<p>val 객체의 내부 값이 변경 가능한 이유는 무엇일까?</p>
</blockquote>
<ul>
<li>태형’s Think
<ul>
<li>코틀린은 자바와 동일하게 기본적으로 <code>call by value</code> 이며 객체 전달 시 메모리 주소를 전달하므로 객체 내부를 변경하여도 메모리 값이 변하는 것이 아니기 때문에 변경이 가능하다.</li>
</ul>
</li>
</ul>
<p><strong>TODO - 고민해보자!</strong><br>
호출되는 순서를 고민해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Main &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        callByValue(funA())</span><br><span class="line">        <span class="comment">// funA</span></span><br><span class="line">        <span class="comment">// callByValue</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callByValue</span><span class="params">(b: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">"callByValue"</span>)</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> funA: () -&gt; <span class="built_in">Boolean</span> = &#123;</span><br><span class="line">        println(<span class="string">"funA"</span>)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Main &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        callByName(funA)</span><br><span class="line">        <span class="comment">// callByName</span></span><br><span class="line">        <span class="comment">// funA</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callByName</span><span class="params">(f: ()</span></span> -&gt; <span class="built_in">Boolean</span>): <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        println(<span class="string">"callByName"</span>)</span><br><span class="line">        <span class="keyword">return</span> f()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> funA: () -&gt; <span class="built_in">Boolean</span> = &#123;</span><br><span class="line">        println(<span class="string">"funA"</span>)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>callByValue정답: funA() -&gt; callByValue()</em></p>
<p><em>callByName 정답: callByName() -&gt; funA()</em></p>
<p>callByName의 이점?</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Main &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> condition = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        callByValue(condition, doSomething())</span><br><span class="line">        <span class="comment">//doSomething</span></span><br><span class="line">        <span class="comment">//callByValue</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callByValue</span><span class="params">(condition: <span class="type">Boolean</span>, value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"callByValue"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> doSomething: () -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">        <span class="comment">// 굉장히 오래 걸리는 연산</span></span><br><span class="line">        println(<span class="string">"doSomething"</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Main &#123;</span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> condition = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        callByName(condition, doSomething)</span><br><span class="line">        <span class="comment">//callByName</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callByName</span><span class="params">(condition: <span class="type">Boolean</span>, value: ()</span></span> -&gt; <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">"callByName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">            println(value())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> doSomething: () -&gt; <span class="built_in">Int</span> = &#123;</span><br><span class="line">        <span class="comment">// 굉장히 오래 걸리는 연산</span></span><br><span class="line">        println(<span class="string">"doSomething"</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>callByValue의 경우 condition에 상관 없이 doSomething()이 실행되며 비효율적으로 동작하게 되지만, callByName을 사용하는 경우 condition 값에 따라 doSomething()이 실행되므로 효율적인 측면에서 더 뛰어나다.</p>
</li>
<li>
<p><code>var</code>: 변경 가능한 참조. 변수 타입은 고정.</p>
<ul>
<li>자바의 일반 변수에 해당</li>
<li>타입은 변환시킬 수 없음</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> answer = <span class="number">42</span></span><br><span class="line">answer = <span class="string">"no answer"</span> <span class="comment">// "error: type mismatch" 컴파일 오류 발생</span></span><br></pre></td></tr></table></figure>
<ul>
<li>문자열 템플릿</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name =<span class="string">"TEAM-ASC"</span></span><br><span class="line">println(<span class="string">"Hello, <span class="variable">$name</span>"</span>)</span><br><span class="line">println(<span class="string">"Hello, <span class="subst">$&#123;name&#125;</span>"</span>)</span><br><span class="line">println(<span class="string">"\$name의 값 = <span class="variable">$name</span>"</span>) <span class="comment">// \$ 탈출문자 사용</span></span><br><span class="line">println(<span class="string">"max(1, 2) = <span class="subst">$&#123;max(<span class="number">1</span>, <span class="number">2</span>)&#125;</span>"</span>) <span class="comment">// 중괄호 안에서 식 사용</span></span><br><span class="line">println(<span class="string">"args: <span class="subst">$&#123;if (args.isEmpty()) "empty" else args[<span class="number">0</span>]&#125;</span>"</span>) <span class="comment">// 식에서 큰 따옴표 사용</span></span><br></pre></td></tr></table></figure>
<h4 id="클래스">클래스</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린 클래스의 기본 접근지정자가 <strong>public</strong> 으로 생략 가능</li>
<li>getter/setter 메소드를 기본적으로 제공하여 생략 가능</li>
</ul>
<h4 id="프로퍼티">프로퍼티</h4>
<p>자바의 필드와 접근자 메소드(getter/setter 메소드)를 완전히 대신함</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">	<span class="keyword">val</span> name: String, <span class="comment">// 읽기 전용(val) 프로퍼티</span></span><br><span class="line">    <span class="keyword">var</span> isMarried: <span class="built_in">Boolean</span> <span class="comment">// 변경 가능(var) 프로퍼티</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person(<span class="string">"Bob"</span>, <span class="literal">false</span>)</span><br><span class="line">println(p.name)</span><br><span class="line">println(p.isMarried)</span><br><span class="line">p.isMarried = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>val 프로퍼티: 읽기 전용 프로퍼티로 <strong>private 필드</strong>와 필드를 읽는 <strong>pulbic getter()</strong> 를 생성함(backing 필드)</li>
</ul>
<p><strong>TODO - 찾아보자 !</strong></p>
<p>프로퍼티에 접근지정자 (private)을 지정했을 경우에 private 필드 + private getter()가 되어 접근이 안되는 것인가? 아니면 접근 지정자 지정을 안했을 때에 default가 public 필드인가?</p>
<ul>
<li>var 프로퍼티: 읽고 쓰기가 가능한 프로퍼티로 <strong>private 필드</strong>와 <strong>public getter()/public setter()</strong> 를 생성함(backing 필드)</li>
<li>뿐만 아니라 <strong>생성자가 필드를 초기화 하는 구현</strong>이 내부적으로 구현되어 있음</li>
</ul>
<p><strong>TODO - 알고가자!</strong></p>
<blockquote>
<p>backing 필드 ?</p>
</blockquote>
<ul>
<li>프로퍼티의 값을 저장하기 위한 비공개 필드<br>
프로퍼티 이름이 is로 시작할 경우</li>
<li>프로퍼티 이름과 동일한 getter() 생성: 예, isMarried()</li>
</ul>
<h4 id="커스텀-접근자">커스텀 접근자</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>(<span class="keyword">val</span> height: <span class="built_in">Int</span>, <span class="keyword">val</span> width: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> isSquare: <span class="built_in">Boolean</span></span><br><span class="line">    	<span class="keyword">get</span>() &#123; <span class="comment">// 프로퍼티 getter 선언, 블록 사용</span></span><br><span class="line">            <span class="keyword">return</span> height == width;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> size: <span class="built_in">Int</span></span><br><span class="line">    	<span class="keyword">get</span>() = height * width <span class="comment">// 식 사용</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 사용 시 해당 프로퍼티에 접근할 때마다 getter가 프로퍼티 값을 매번 다시 계산함</li>
</ul>
<h4 id="소스코드-구조">소스코드 구조</h4>
<ul>
<li>파일의 맨 앞에 package 문 사용해서 패키지 지정</li>
<li>파일의 모든 선언 (클래스, 함수, 프로퍼티 등)이 해당 패키지에 속함</li>
<li>디렉토리 구조와 패키지 구조가 일치할 필요 없음</li>
<li>같은 패키지에 속해있다면 다른 파일에서 임포트 없이 정의한 선언 사용 가능</li>
<li>다른 패키지에서 사용하려면 <code>import</code> 키워드로 사용할 선언을 임포트해야 함</li>
</ul>
<h4 id="enum">enum</h4>
<p><code>enum</code> 키워드를 사용하여 <strong>열거타입</strong> 지정</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>자바는 <code>enum</code>, 코틀린은 <code>enum class</code></li>
<li>코틀린에서의 enum은 <strong>소프트 키워드(soft keyword)</strong> 라고 부름</li>
<li>class 앞에 붙여질 경우 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있음(예약어처럼 사용이 불가하지 않음)</li>
</ul>
<p>프로퍼티와 메소드 선언 가능 (메소드 선언시 마지막 열거 값 뒤에 세미콜론 <strong>필수</strong>)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>(<span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    READ(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>), YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">    BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), VIOLET(<span class="number">238</span>, <span class="number">130</span>, <span class="number">238</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(Color.BLUE.rgb()) <span class="comment">// 결과: 255</span></span><br></pre></td></tr></table></figure>
<h4 id="when">when</h4>
<p>자바의 <code>switch</code>와 유사하며 코틀린의 <code>when</code>은 <code>if</code>와 마찬가지로 <strong>값을 만들어내는 식</strong> 임</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getColorString</span><span class="params">(color: <span class="type">Color</span>)</span></span> =</span><br><span class="line">	<span class="keyword">when</span> (color) &#123;</span><br><span class="line">        Color.RED -&gt; <span class="string">"It is RED !"</span></span><br><span class="line">        Color.ORANGE -&gt; <span class="string">"It is ORANGE !"</span></span><br><span class="line">        Color.YELLOW -&gt; <span class="string">"It is YELLOW !"</span></span><br><span class="line">        Color.GREEN, Color.BLUE -&gt; <span class="string">"It is GREEN OR BLUE !"</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">"What is Color..?"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">println(getColorString(Color.ORANGE)) <span class="comment">// 결과: It is ORANGE</span></span><br></pre></td></tr></table></figure>
<ul>
<li>각 분기에 <code>break</code> 키워드 필요 없음</li>
<li><code>,</code>를 통해 여러 매치 패턴을 지정할 수 있음</li>
<li>모든 분기 식에 만족하지 않으면 else 분기가 실행됨</li>
</ul>
<p>when 식은 객체의 동등성 사용</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mix</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> =</span><br><span class="line">	<span class="keyword">when</span> (setOf(c1, c2)) &#123;</span><br><span class="line">        setOf(RED, YELLOW) -&gt; ORANGE</span><br><span class="line">        setOf(YELLOW, BLUE) -&gt; GREEN</span><br><span class="line">        setOf(BLUE, VIOLET) -&gt; INDIGO</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">"Dirty color"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>setOf()</code>: 자바로 치면 set을 만들어 주는 메소드로 HashSet과 비슷하다고 생각하면 됨</li>
<li>c1, c2가 들어오는 순서에 상관이 없음</li>
</ul>
<p>인자 없는 when 식</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">mixOptimized</span><span class="params">(c1: <span class="type">Color</span>, c2: <span class="type">Color</span>)</span></span> = </span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        (c1 == RED &amp;&amp; c2 == YELLOW) ||</span><br><span class="line">        (c1 == YELLOW &amp;&amp; c2 == RED) -&gt; </span><br><span class="line">            ORANGE</span><br><span class="line">        (c1 == YELLOW &amp;&amp; c2 == BLUE) ||</span><br><span class="line">        (c1 == BLUE &amp;&amp; c2 == YELLOW) -&gt; </span><br><span class="line">            GREEN</span><br><span class="line">        (c1 == BLUE &amp;&amp; c2 == VIOLET) ||</span><br><span class="line">        (c1 == VIOLET &amp;&amp; c2 == BLUE) -&gt;</span><br><span class="line">            INDIGO</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">"Dirty color"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">println(mixOptimized(BLUE, YELLOW)) <span class="comment">//결과: GREEN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>when에 인자가 없으려면 각 분기의 조건이 Boolean 결과를 계산하는 식이어야 함</li>
</ul>
<p><strong>TODO - 생각해보자!</strong></p>
<ul>
<li>불필요한 인스턴스를 생성하지 않아 불필요한 가비지 객체가 늘어나지 않는 장점이 있으나 가독성이 매우 떨어지는 코드가 될 수 있어 주의하여 사용하는 것이 좋을 것 같다.</li>
</ul>
<h4 id="스마트-캐스트">스마트 캐스트</h4>
<p>Object의 타입 확인과 변환을 한번에 해주는 기능</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Num) &#123;</span><br><span class="line">        <span class="keyword">val</span> n = e <span class="keyword">as</span> Num <span class="comment">// 명시적 형변환, 스마트 캐스트로 사실상 필요 없음</span></span><br><span class="line">        <span class="keyword">return</span> n.value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">is</span> Sum) &#123;</span><br><span class="line">        <span class="keyword">return</span> eval(e.left) + eval(e.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown expression"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">when</span> (e) &#123;</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; &#123;</span><br><span class="line">            println(<span class="string">"num: <span class="subst">$&#123;e.value&#125;</span>"</span>)</span><br><span class="line">            e.value <span class="comment">// 블록에서는 마지막 식이 반환값이 됨</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.right) + eval(e.left)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"Unknown expression"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>is</code> 연산자를 통해 변수 타입 검사
<ul>
<li>검사한 이후에는 명시적인 캐스팅 없이 해당 타입으로 바로 사용 가능</li>
</ul>
</li>
<li>블록으로 되어있는 경우 마지막 식이 반환값이 되어 반환됨</li>
</ul>
<h4 id="while-루프">while 루프</h4>
<p>자바의 <code>while 루프</code>와 동일하게 사용된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건) &#123;</span><br><span class="line">    <span class="comment">// TODO 조건이 참인 경우 반복 실행</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 최초 1번 실행 후 조건이 참인 경우 반복 실행</span></span><br><span class="line">&#125; <span class="keyword">while</span> (조건)</span><br></pre></td></tr></table></figure>
<h4 id="for-루프">for 루프</h4>
<ul>
<li>범위(CloseRange 인터페이스): 두 값으로 이루어진 구간</li>
<li>수열(Progression): 범위에 속한 값을 일정한 순서로 이터레이션</li>
<li>예시
<ul>
<li><code>1 rangeTo 10 step 2</code> 또는 <code>1..10 step 2</code>: 1~10 까지 2씩 증가하며 이터레이션</li>
<li><code>100 downTo 1 step 2</code>: 100부터 1로 줄어들며 2씩 감소하며 이터레이션</li>
<li><code>0 until 10</code>: 0부터 10까지 이터레이션(단, 10은 미포함)</li>
</ul>
</li>
</ul>
<p>자바의 <code>for (int i = 0; i &lt; length; i++)</code>에 해당하는 루프가 없다. 대신 <code>범위</code>를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 범위 1~100 (100 포함)</span></span><br><span class="line"><span class="keyword">val</span> oneToTen = <span class="number">1.</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>
<h4 id="맵-리스트에-대한-이터레이션">맵, 리스트에 대한 이터레이션</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binaryReps = TreeMap&lt;<span class="built_in">Char</span>, String&gt;()</span><br><span class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'F'</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> binary = Integer.toBinaryString(c.toInt())</span><br><span class="line">    binaryReps[c] = binary; <span class="comment">// 자바의 put(), get() 대신에 이와 같이 사용함</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 맵에 대한 이터레이션</span></span><br><span class="line"><span class="comment">// letter에는 키, binary에는 값(2진 표현)이 들어감</span></span><br><span class="line"><span class="keyword">for</span> ((letter, binary) <span class="keyword">in</span> binaryReps) &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$letter</span> = <span class="variable">$binary</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: A = 1000001</span></span><br><span class="line"><span class="comment">//      B = 1000010</span></span><br><span class="line"><span class="comment">//      C = 1000011</span></span><br><span class="line"><span class="comment">//      D = 1000100</span></span><br><span class="line"><span class="comment">//      E = 1000101</span></span><br><span class="line"><span class="comment">//      F = 1000110</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = arrayListOf(<span class="string">"10"</span>, <span class="string">"11"</span>, <span class="string">"1001"</span>)</span><br><span class="line"><span class="keyword">for</span> ((index, element) <span class="keyword">in</span> list.withIndex()) &#123;</span><br><span class="line">    print(<span class="string">"<span class="variable">$index</span> = <span class="variable">$element</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과: 0 = 10</span></span><br><span class="line"><span class="comment">//      1 = 11</span></span><br><span class="line"><span class="comment">//      2 = 1001</span></span><br></pre></td></tr></table></figure>
<h4 id="in을-통해-값이-범위에-속하는지-검사하기"><code>in</code>을 통해 값이 범위에 속하는지 검사하기</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span> || c <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c !<span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span></span><br><span class="line"></span><br><span class="line">println(isLetter(<span class="string">'q'</span>)) <span class="comment">// 결과: true</span></span><br><span class="line">println(isNotDigit(<span class="string">'x'</span>)) <span class="comment">// 결과: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparable 구현 클래스</span></span><br><span class="line">println(<span class="string">"Kotlin"</span> <span class="keyword">in</span> <span class="string">"Java"</span>..<span class="string">"Scala"</span>)</span><br><span class="line">println(<span class="string">"Kotlin"</span> <span class="keyword">in</span> setOf(<span class="string">"Java"</span>, <span class="string">"Scala"</span>, <span class="string">"Kotlin"</span>)) <span class="comment">// 결과: true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>in</code>은 <code>contains</code>와 동일</li>
</ul>
<h4 id="익셉션exception">익셉션(Exception)</h4>
<p>자바나 다른 언어의 예외 처리와 비슷하다. 즉, 함수 실행 중 오류가 발생하면 예외를 던질(throw) 수 있고 함수를 호출하는 쪽에서는 그 예외를 잡아 처리(catch)할 수 있다. 예외에 대해 처리를 하지 않은 경우 함수 호출 스택을 거슬러 올라가면서 예외를 처리하는 부분이 나올 때까지 예외를 다시던진다(rethrow).</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (percentage !<span class="keyword">in</span> <span class="number">0.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">"message: <span class="variable">$percentage</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> line = reader.readLine()</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(line)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">"239"</span>))</span><br><span class="line">println(readNumber(reader)) <span class="comment">// 결과: 239</span></span><br></pre></td></tr></table></figure>
<ul>
<li>자바와의 가장 큰 차이점은 함수명 뒤에 <code>throws</code> 절이 없다는 것임
<ul>
<li>자바에서 상기 코드는 함수 뒤에 throws IOException을 붙여야 함</li>
<li>IOException이 <strong>체크 예외</strong>이기 때문에 자바는 명시적으로 표현해야 함</li>
</ul>
</li>
</ul>
<p><strong>TODO - 알고가자!</strong><br>
Java에서의 체크 예외</p>
<ul>
<li>ClassNotFoundException</li>
<li>CloneNotSupportedException</li>
<li>InstantiationException</li>
<li>IOException</li>
</ul>
<p>Java에서의 언체크 예외</p>
<ul>
<li>RuntimeException을 상속받는 Exception</li>
<li>ArithmeticException</li>
<li>IllegalArgumentException</li>
<li>IndexOutOfBoundsException</li>
</ul>
<h4 id="try는-식">try는 식</h4>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readNumber</span><span class="params">(reader: <span class="type">BufferedReader</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number = <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer.parseInt(reader.readLine())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: NumberFormatException) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// null로 수정 시 null을 반환하게 된다.</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        reader.close</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println(number) <span class="comment">// Exception 발생 시 호출되지 않음</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> reader = BufferedReader(StringReader(<span class="string">"not a number"</span>))</span><br><span class="line">readNumber(readNumber(reader)) <span class="comment">// 결과: 아무것도 출력되지 않음.</span></span><br></pre></td></tr></table></figure>
<h6 id="참조">참조</h6>
<ul>
<li><a href="https://javacan.tistory.com/entry/Kotlin-in-action-study-summary" target="_blank" rel="noopener">코틀린 인 액션 스터디 정리 자료 :: 자바캔(Java Can Do IT)</a></li>
<li><a href="https://taehyungk.github.io/tag/#Kotlin" target="_blank" rel="noopener">탤로우 월드#Kotlin</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/01/KotlinInAction-Chap2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/archives/3/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 10</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
