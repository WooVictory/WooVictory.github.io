
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Android - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Android/archives/6/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/03/RxJava-Chap04/"
                            aria-label=": [RxJava] Chap04"
                        >
                            [RxJava] Chap04
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-03T17:59:09+09:00">
	
		    Jun 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>해당 글은 직접 책을 구매하여 공부의 목적으로 정리하는 글임을 알려드립니다.</p>
<p>이번에는 리액티브 연산자를 카테고리별로 알아보도록 하겠다. 이유는 연산자의 종류가 많기도 하고 카테고리로 쓰임새를 어느 정도 짐작할 수 있기 때문이다.</p>
<p><code>생성 연산자</code>는 Observable로 데이터 흐름을 만들고 <code>변환 연산자와 필터 연산자</code>는 데이터 흐름을 내가 원하는 방식으로 변형한다. 결합 연산자는 1개의 Observable이 아니라 여러 개의 Observable을 조합할 수 있도록 해준다.</p>
<h2 id="생성-연산자">생성 연산자</h2>
<ul>
<li>생성 연산자의 역할은 데이터 흐름을 만드는 것이다.</li>
<li>Observable(Observable, Single, Maybe 객체 등)을 만든다고 생각하면 된다.</li>
<li>앞선 챕터에서는 just(), fromXXX(), create() 함수 등을 봤고, 이번에는 다른 연산자들을 확인해보도록 하겠다.</li>
</ul>
<p><strong>1. interval()</strong></p>
<ul>
<li>일정 시간 간격으로 데이터 흐름을 생성한다.</li>
<li>주어진 시간 간격으로 0부터 1씩 증가하는 Long 객체를 발행한다.</li>
<li>두 가지의 함수 원형을 가지고 있으며, 최초 지연 시간을 조절하는 함수와 그렇지 않은 함수가 존재한다.</li>
<li>period(일정 시간)동안 쉬었다가 데이터를 발행한다.</li>
<li>기본적으로 영원히 지속되기 때문에 폴링 용도로 많이 사용한다.</li>
<li>함수의 동작이 현재 스레드가 아닌 계산을 위한 별도의 스케줄러(스레드)에서 동작한다.</li>
</ul>
<img src="/img/interval.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 원형</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeInterval</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 시작 시간을 표시하는 유틸리티 메소드이다.</span></span><br><span class="line"><span class="comment">    * RxJava - 비동기 프로그래밍이기 때문에 시간에 대한 이해가 중요하다.</span></span><br><span class="line"><span class="comment">    * 시작 시간을 기준으로 RxJava 각 함수의 실행 시간을 측정하기 위함이다.</span></span><br><span class="line"><span class="comment">    * sleep()을 호출하는 이유는 다른 스레드에서 실행이 완료될 때까지 기다려야 하기 때문이다.</span></span><br><span class="line"><span class="comment">    * 해당 문장을 주석 처리하게 되면 기다리지 않고 바로 프로그램이 종료되는 것을 확인할 수 있다.</span></span><br><span class="line"><span class="comment">    * 이유는 메인 스레드에서 할 일이 없기 때문이다.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                (<span class="keyword">data</span> + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(TIME)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">247</span> | value = <span class="number">100</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">347</span> | value = <span class="number">200</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">445</span> | value = <span class="number">300</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">545</span> | value = <span class="number">400</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">645</span> | value = <span class="number">500</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>2. timer()</strong></p>
<ul>
<li>interval() 함수와 유사하지만 <code>time()</code> 함수는 <strong>한 번만 실행되는 함수</strong>이다.</li>
<li><strong>일정 시간이 지난 후 한 개의 데이터를 발행하고 onComplete() 이벤트가 발생한다.</strong></li>
<li>전반적으로 interval() 함수와 유사하다. 계산 스케줄러에서 실행되며 함수의 발행되는 데이터도 interval() 함수의 첫 번째 값인 0L이다.</li>
<li>보통 일정 시간이 지난 후 어떤 동작을 실행할 때 활용한다. 우리가 사용하는 타이머를 맞춘다고 생각하면 된다.</li>
</ul>
<img src="/img/timer.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.timer(<span class="number">500</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; notUsed -&gt;</span><br><span class="line">                SimpleDateFormat(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>)</span><br><span class="line">                        .format(Date())</span><br><span class="line">            &#125;</span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * timer() 함수도 메인 스케줄러가 아닌 계산 스케줄러에서 실행되기 때문에</span></span><br><span class="line"><span class="comment">    * 계산 스케줄러가 완료될 때까지 기다리기 위해서 sleep() 함수를 호출하여 준다.</span></span><br><span class="line"><span class="comment">    * 즉, 계산 스케줄러의 동작이 완료될 때까지 메인 스케줄러가 기다리는 것이다.</span></span><br><span class="line"><span class="comment">    * 그렇지 않으면 메인 스케줄러에서 할 일이 없기 때문에 프로그램이 바료 종료된다.</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">708</span> | value = <span class="number">2019</span>/<span class="number">06</span>/<span class="number">03</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">26</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>3. range()</strong></p>
<ul>
<li>주어진 값(n)부터 m개의 Integer 객체를 발행한다.</li>
<li>interval(), timer() 함수는 Long 객체를 발행했지만, range() 함수는 Integer 객체를 발행한다.</li>
<li>특정한 스케줄러에서 실행되지 않는다. 즉, 현재 스레드에서 실행한다.</li>
<li>반복문(for, while문)을 대체할 수 있다.</li>
</ul>
<img src="/img/chapter4_range.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* range() 함수로 1부터 10까지 숫자를 생성한다.</span></span><br><span class="line"><span class="comment">* 그리고 filter() 함수를 이용해 짝수만 걸러낸다.</span></span><br><span class="line"><span class="comment">* 현재 쓰레드에서 실행된다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            .filter &#123; num -&gt;</span><br><span class="line">                num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">2</span></span><br><span class="line">main | value = <span class="number">4</span></span><br><span class="line">main | value = <span class="number">6</span></span><br><span class="line">main | value = <span class="number">8</span></span><br><span class="line">main | value = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>4. intervaleRange()</strong></p>
<ul>
<li>interval()과 range() 함수를 혼합해놓은 함수이다.</li>
<li>interval() 함수처럼 일정한 시간 간격으로 값을 출력하지만, range() 함수처럼 시작 숫자(n)로부터 m개만큼의 값만 생성하고 onComplete 이벤트가 발생한다.</li>
<li>interval() 함수처럼 무한히 데이터 흐름을 발행하지 않는다. 반환 타입은 Long 타입이다.</li>
<li>계산 스케줄러에서 실행된다.</li>
</ul>
<img src="/img/intervalRange.png" width="500" height="200">
<p>사실 intervalRange() 함수는 interval() 함수와 다른 함수를 조합해서 만들 수 있다. 이유는 intervalRange() 함수가 직관적이지 않기 때문이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* main 스레드에서 실행되는 것이 아니기 때문에 sleep() 함수를 호출한다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.intervalRange(<span class="number">1</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            TimeUnit.MILLISECONDS)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>interval() 함수 -&gt; intervalRange() 함수 만들기</p>
<ul>
<li>interval() 함수 사용</li>
<li>map() 함수 사용</li>
<li>take() 함수 사용</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRangeUsingIntervalAndMapAndTake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="keyword">data</span> + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. defer()</strong></p>
<ul>
<li>데이터 흐름 생성을 구독자가 subscribe() 함수를 호출할 때까지 미룰 수 있다. 이때 새로운 Observable이 생성된다.</li>
<li>Observable의 생성이 구독할 때까지 미뤄지기 때문에 최신 데이터를 얻을 수 있다.</li>
<li>현재 스레드에서 실행되며, 인자로는 Callable&lt;Observable<t>&gt;를 받는다. Callable 객체이므로 구독자가 subscribe()를 호출할 때까지 call() 메소드의 호출을 미룰 수 있다.</t></li>
</ul>
<img src="/img/defer.png" width="500" height="200">
<p><code>defer()</code> 함수는 구독자가 구독할 때까지 Observable의 데이터 발행을 미루는 역할을 한다. 따라서 구독자가 subscribe()를 호출하는 시점에 최신의 데이터를 받을 수 있다. defer() 함수를 사용하지 않은 상황에서 구독자 두명이 그대로 구독을 하게 되면 같은 5에 대한 데이터를 발행하고 구독자가 받게 된다.</p>
<p><strong>개념이 조금 어렵다;; 천천히 다시 볼 필요가 있다.</strong></p>
<p>여기에서 다룬 Observable은 모두 차가운 Observable이다. Observable을 생성할 때 입력값이 결정되고 구독자가 subscribe() 함수를 호출하면 그때 해당 데이터 흐름을 그대로 발행한다. 즉, defer() 함수를 활용하면 subscribe() 함수를 호출할 때의 상황을 반영하여 데이터 흐름의 생성을 지연하는 효과를 보여준다. 내부적으로 구독자가 subscribe() 함수를 호출하면 그때 supplier의 call() 메소드를 호출한다.</p>
<p><strong>6. repeat()</strong></p>
<ul>
<li>단순히 반복 실행을 하는 함수이다.</li>
<li>서버와 통신을 할 때 해당 서버가 살아있는지 확인(이 확인 과정을 보통 ping 혹은 heart beat라고 한다.)하는 코드를 작성할 때 주로 사용한다.</li>
<li>인자를 입력하지 않으면 영원히 실행된다. 따라서 반복하길 원하는 숫자만큼 인자로 전달하는게 좋다.</li>
</ul>
<img src="/img/repeat.png" width="500" height="200">
<p><strong>예제로 heart beat를 간단하게 구현해보기</strong></p>
<p>서버와 연동하는 앱을 작성하다 보면 통신하는 서버가 동작하는지 확인하는 코드가 필요하다. 지속적인 통신을 해야 하는 서버의 경우 명세서에 동작 확인 코드를 작성할 것을 명시하기도 한다.</p>
<p>보통 일정 시간 안데 heart beat 패킷을 보내지 않으면 서버는 클라이언트와의 연결이 종료된 것으로 판단하고 연결을 해제한다. (보통 30초 간격으로 heart beat 신호를 보낸다.) 이럴 때 repeat() 함수를 활용하면 heart beat 패킷을 보내는 프로그램을 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> serverUrl: String = <span class="string">"https://api.github.com/zen"</span></span><br><span class="line"></span><br><span class="line">    Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">            .map &#123; it -&gt;</span><br><span class="line">                serverUrl</span><br><span class="line">            &#125;</span><br><span class="line">            .map(OkHttpHelper::<span class="keyword">get</span>)</span><br><span class="line">            .repeat()</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result: <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result fail: <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래는 OkHttpHelper 클래스이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static OkHttpClient client = new OkHttpClient();</span><br><span class="line">    <span class="keyword">public</span> static String ERROR = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String <span class="keyword">get</span>(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.e(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getT(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.et(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getWithLog(String url) throws IOException &#123;</span><br><span class="line">        Log.d(<span class="string">"OkHttp call URL = "</span> + url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">get</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timer() 함수를 사용해 2초마다 반복 실행되도록 했다. 약 2초 간격으로 실행된다. 원래 timer() 함수는 한 번 호출된 후에는 종료된다. 그런데 계속 반복해서 실행되는 것을 볼 수 있다.</p>
<p>이유는 repeat() 함수 때문이다. repeat() 함수는 동작이 한 번 끝난 다음에 다시 구독하는 방식으로 동작한다. 그리고 다시 구독할 때마다 동작하는 스레드의 번호가 달라진다.</p>
<p>만약 동작하는 스레드를 동일하게 맞추고 싶다면 timer()와 repeat() 함수를 빼고 interval() 함수를 대신 넣어 호출하면 된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/03/RxJava-Chap04/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/kotlin-chap3/"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            [커니의 Kotlin] Chap3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T21:52:08+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/커니의-Kotlin/">커니의 Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>해당 글은 <strong>커니의 코틀린</strong> 책을 구매하여 공부하고 작성한 글입니다.</p>
                    
                        <a
                            href="/2019/05/28/kotlin-chap3/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy2/"
                            aria-label=": [Android] 백그라운드 실행 정책 Oreo"
                        >
                            [Android] 백그라운드 실행 정책 Oreo
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T17:58:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>안드로이드 Oreo(8.0)</code> 버전에서 등장한 백그라운드 실행 제한을 확인해보도록 하겠다. 안드로이드에서 백그라운드 실행은 상용 서비스에서 많이 사용되는 부분이기도 하고 꼭 알아야 하는 부분이라서 공부하면서 정리하려고 한다.</p>
<h2 id="1-oreo-버전-백그라운드-제한-개요">1. Oreo 버전 백그라운드 제한 개요</h2>
<p>앱이 백그라운드에서 실행될 때마다 디바이스의 리소스(예:RAM, 배터리)를 사용한다. 이는 사용자들에게 좋지 못한 경험을 제공한다. 예를 들어 백그라운드 작업으로 인해 디바이스의 배터리 수명이 저하되거나 비디오 시청, 게임, 카메라 사용과 같은 사용자의 디바이스 성능 저하가 발생할 수 있다.</p>
<p>동시에 실행되는 앱이 많은 수록 시스템에 많은 부하가 걸린다. 추가적인 앱이나 서비스가 백그라운드에서 실행 중이면 시스템에 추가적인 부하가 걸리고 사용자 환경이 나빠질 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 <strong>Android Oreo</strong> 버전에서는 사용자가 앱과 직접적으로 상호작용하지 않을 때 이 앱이 수행할 수 있는 작업을 제한한다. 두 가지 방식으로 제한된다.(여기서는 <code>백그라운드 서비스 제한</code>만 살펴보도록 하겠다.)</p>
<ol>
<li>
<p><strong>백그라운드 서비스 제한</strong> : 앱이 유휴 상태인 경우 백그라운드 서비스의 사용이 제한된다. 이 기능은 사용자에게 잘 보이는 포그라운드 서비스에는 적용되지 않는다.</p>
</li>
<li>
<p><strong>브로드캐스트 제한</strong> : 제한된 예외의 경우, 앱이 암시적 브로드캐스트에 등록하기 위해 자체 매니페스트를 사용할 수 없다. 그렇지만 앱이 런타임에 브로드캐스트에 등록할 수 있으며, 특정 앱을 대상으로 하는 명시적 브로드캐스트에 등록하기 위해 매니페스트를 사용할 수 있다.</p>
</li>
</ol>
<ul>
<li>
<p>기본적으로 이와 같은 제한은 Oreo 버전을 대상으로 하는 앱에만 적용된다. 하지만, 안드로이드 개발자라면 모든 버전을 고려해서 개발해야 하기 때문에 피할 수 없는 부분임이 분명하다. 그렇기 때문에 반드시 알고 넘어가야 한다.</p>
</li>
<li>
<p>추가적으로 이전에 살펴본 Service는 백그라운드에서 동작하는 컴포넌트이다. 하지만, Oreo 처럼 백그라운드 작업을 제한하게 된다면 우리가 원하는 작업을 수월하게 진행할 수 없다. 이 부분을 어떻게 해결할 수 있는지 고민해야 할 필요가 있다.</p>
</li>
</ul>
<p>대부분의 경우, 앱은 <strong>JobScheduler</strong> 작업을 사용해 이 제한을 해결할 수 있다. JobScheduler를 통해 앱이 실행되지 않을 때 작업을 수행하면서도, 사용자 환경에 영향을 미치지 않는 방식으로 이러한 작업을 예약할 수 있는 여지를 제공할 수 있다. 하지만, JobScheduler 역시 제한이 걸리는 점이 존재한다. 이 부분은 <strong>WorkManager</strong> 부분에서 공부하면서 살펴보자.</p>
<h2 id="2-백그라운드-실행-변화">2. 백그라운드 실행 변화</h2>
<p>앞선 포스팅에서 확인한 내용을 한번 더 정리하고 넘어가려 한다. 그리고 위에서 설명한 것처럼 사용자의 디바이스 배터리 수명을 개선하고 더 좋은 사용자 경험을 제공하기 위해 안드로이드는 몇가지 백그라운드 정책들을 변화시켜왔다.</p>
<ul>
<li>도즈모드와 앱 대기상태(Doze And App Standby) : 화면이 꺼지고 충전 상태가 아니며 대기 상태일 때 애플리케이션의 행동을 제한한다.</li>
<li>백그라운드 상태에서 위치 서비스 제약 : 백그라운드 상태에 있는 앱이 사용자의 현재위치를 검색할 수 있는 빈도를 제한한다.</li>
<li>백그라운드 서비스 제약 : 보이지 않는 CPU/Network 사용과 실행중인 백그라운드 서비스들을 제한한다.</li>
<li>가장 최근에는 사용자가 사용하지 않는 앱에서 사용할 수 있는 기기 리소스를 제한할 수 있는 <a href="https://developer.android.com/about/versions/pie/power#buckets" target="_blank" rel="noopener">앱 대기 버킷(App Standby Buckets)</a>과 앱이 좋지 않는 행동을 보이는 경우 백그라운드에서 시스템 리소스에 대한 앱의 접근을 제한하도록 사용자에게 경고하는 <a href="https://developer.android.com/topic/performance/background-optimization#bg-restrict" target="_blank" rel="noopener">앱 제한(App Restrictions)</a>과 <a href="https://developer.android.com/about/versions/pie/power#battery-saver" target="_blank" rel="noopener">배터리 절약 개선(Battery Saver improvements)</a> 정책이 추가되었다.</li>
</ul>
<h2 id="3-oreo-버전-백그라운드-실행-제한">3. Oreo 버전 백그라운드 실행 제한.</h2>
<p>위에서 언급한 것처럼 백그라운드에서 실행 중인 서비스가 디바이스의 리소스를 사용할 수 있으며, 그 결과로 사용자 경험이 악화될 가능성이 있다. 이러한 문제를 줄이기 위해 Oreo 버전부터 시스템은 여러가지 제한을 서비스에 적용한다.</p>
<p>먼저, 이를 이해하기 전에 애플리케이션이 <strong>Foreground</strong>인지 <strong>Background</strong>인지 명확하게 파악해야 한다. 아래와 같은 경우 애플리케이션이 Foreground에 있는 것으로 간주한다.</p>
<ul>
<li>액티비티가 시작되거나 일지 중지되거나 상관없이 액티비티가 가시적일 경우.</li>
<li>Foreground Service가 있는 경우.</li>
<li>Foreground 애플리케이션이 서비스를 갖는 애플리케이션에 바인딩하거나 콘텐츠 프로바이더를 사용하여 앱에 연결할 때.<br>
예를 들어 다른 앱이나 시스템이 아래의 내용에 바인딩하면 애플리케이션이 Foreground에 있는 것이다.
<ul>
<li>IME</li>
<li>Wallpaper Service</li>
<li>Notification listener</li>
<li>Voice 또는 text 서비스</li>
<li>자동차에서 스트리밍을 듣는 음악 앱(Android Auto일 때)</li>
</ul>
</li>
</ul>
<p>위의 조건들을 만족하지 못한다면 애플리케이션이 Background에 있는 것으로 간주된다.</p>
<blockquote>
<p><strong>바인드된 서비스는 영향을 받지 않는다.</strong></p>
</blockquote>
<ul>
<li>이러한 규칙은 바인드된 서비스에는 어떠한 영향도 미치지 않는다. 앱이 바인드된 서비스를 정의하는 경우, 해당 앱이 Foreground에 있는 없든 간에 다른 구성요소들이 이 서비스에 바인드할 수 있다.</li>
</ul>
<p>앱이 Foreground에 있는 동안에는 이 앱이 Foreground 및 Background 서비스를 자유롭게 생성하고 실행할 수 있다. 앱이 백그라운드로 이동하더라도 몇 분 동안은 앱이 서비스를 생성하고 사용하는 것이 여전히 허용된다. 이 기간이 끝나게 되면 앱이 유휴 상태로 간주된다. 이때 마치 앱이 서비스의 <code>Service.stopSelf()</code> 메소드를 호출한 것처럼 시스템이 앱의 백그라운드 서비스를 중지시킨다.</p>
<p>어떠한 상황에서는 백그라운드 앱이 몇 분 동안 임시 허용 목록이란 곳에 들어가기도 한다. 앱이 허용 목록에 있는 동안에는 제한 없이 서비스를 시작할 수 있으며 백그라운드 서비스도 실행이 허용된다. 사용자에게 보이는 다음과 같은 작업을 앱이 처리하는 경우에 앱이 허용 목록에 들어간다.</p>
<ul>
<li>우선순위가 높은 Firebase Cloud Messaging(FCM) 메시지 처리</li>
<li>SMS/MMS 메시지와 같은 브로드캐스트 수신</li>
<li>알림에서 <code>PendingIntent</code> 실행</li>
</ul>
<p>많은 경우 앱이 백그라운드 서비스를 <strong>JobScheduler</strong> 작업으로 대체할 수 있다. Android 8.0 이전에는 Foreground 서비스를 생성하는 일반적인 방법은 Background 서비스를 생성한 후 이 서비스를 Foreground 서비스로 승격시키는 것이었다.</p>
<p>Android 8.0에서는 좀 복잡하며 시스템은 백그라운드 앱이 Background 서비스를 생성하는 것을 허용하지 않는다. 이 때문에 Android 8.0에서는 새 서비스를 Foreground에서 시작하는 새로운 메소드 <code>Context.startForegroundService()</code>를 소개한다.</p>
<p>시스템이 서비스를 생성한 후, 앱은 5초 이내에 해당 서비스의 <strong>startForeground()</strong> 메소드를 호출하여 새 서비스의 알림을 사용자에게 표시해야 한다. 앱이 이 시간 내에 <strong>startForeground()</strong> 를 호출하지 않으면 시스템이 서비스를 중단하고 앱을 ANR로 선언하게 된다.</p>
<h2 id="5-사례와-해결-방법">5. 사례와 해결 방법</h2>
<p>백그라운드 실행 제한으로 인해 원하는 작업을 하는게 조금 어려워졌다. 개발자는 백그라운드 실행을 구현하기 위해 사용할 도구를 결정하려면 원하는 것을 명확하게 이해하고 어떤 제한 사항을 가지고 있어야 한다.</p>
<p>공식 문서에 나와있는 <strong>Guide to background Processing</strong>을 참고해서 알아보도록 하자.</p>
<p><strong>개요</strong><br>
안드로이드 앱은 UI 처리, 사용자와 상호작용, LifeCycle 이벤트 수신 등을 담당하는 Main Thread가 존재한다. Main Thread에서 너무 많은 작업이 발생하면 앱이 끊기거나 느려져서 사용자 경험이 좋지 않다. 즉, 사용자가 불편함을 느낄 수 있다.</p>
<p>비트맵 디코딩, 디스크 접근 또는 네트워크 요청 수행과 같은 시간이 오래 걸리는 실행 및 작업을 별도의 백그라운드 스레드에서 수행해야 한다. 일반적으로 몇 밀리초 이상 걸리는 것은 모두 백그라운드 스레드에 위임해야 한다. 이러한 작업 중 일부는 사용자가 앱을 활발하게 사용하는 동안 수행되어야 한다. 백그라운드 스레드에서 작업을 실행하고 앱을 사용하는 동안 기본 UI 스레드에서 작업을 실행하는 방법 그리고 두 스레드 간 통신 방법에 대해서는 다른 글을 참고하면 좋다.</p>
<p>애플리케이션은 또한 사용자가 백엔드 서버와 정기적으로 동기화하거나 앱 내에서 새로운 컨텐츠를 가져오는 등 앱을 사용하지 않을 때에도 실행해야 하는 일부 작업이 필요할 수 있다. 또한 애플리케이션은 사용자가 앱과 상호작용을 완료한 후에도 서비스가 즉시 실행되도록 요구할 수 있다. 이와 같은 경우를 해결하기 위해서 <strong>백그라운드 처리에 대한 고민이 필요하다.</strong></p>
<p><strong>백그라운드 처리의 과제</strong></p>
<p>백그라운드 작업은 RAM 및 배터리와 같은 기기의 제한된 리소스를 소비한다. 올바르게 사용하지 않을 경우 사용자에게 좋지 않은 경험을 제공할 수 있다.</p>
<p>안드로이드는 배터리를 극대화하고 좋은 앱 동작을 위해 앱 또는 Foreground Service Notification이 사용자에게 보이지 않을 때 백그라운드 작업을 제한한다.</p>
<p>다음은 위에서 언급한 버전별 백그라운드 정책의 변화를 보여준다.</p>
<ul>
<li>Android 6.0 : Doze 모드와 App Standby(앱 대기) 기능
<ul>
<li>도즈 모드는 화면이 꺼져 있고 기기가 정지해 있을 때 앱 동작을 제한한다.</li>
<li>앱 대기에서는 사용하지 않는 애플리케이션을 네트워크 접근, 작업 및 동기화를 제한하는 특수 상태로 전환한다.</li>
</ul>
</li>
<li>Android 7.0 : 암시적 브로드캐스트 리시버를 제한하고 개선된 도즈모드를 제공한다.</li>
<li>Android 8.0 : 백그라운드에서 위치를 파악하거나 캐시된 Wake lock을 해제하는 등 추가적인 백그라운도 동작 제한이 있다.</li>
<li>Android 9.0 : 앱 이용 패턴에 따라 자원에 대한 앱 요청이 동적으로 우선되는 App Standby Buckets를 소개했다.</li>
</ul>
<p>결국 내가 해야 할 작업을 정확히 이해하고 백그라운드 작업을 버전별 정책에 맞도록 개발하는 것이 중요하다.</p>
<p><strong>작업에 맞는 적합한 방법을 선택하자.</strong></p>
<p>아래의 예시를 확인해보고 생각해보자.</p>
<ul>
<li><strong>작업이 연기될 수 있거나 당장 일어날 필요가 있는가?</strong> 예를 들어, 사용자가 버튼을 클릭하는 것에 대응하여 네트워크에서 데이터를 가져와야 하는 경우 이 작업은 즉시 수행되어야 한다. 그러나 서버에 로그를 업로드하려면 앱의 성능이나 사용자 기대에 영향을 미치지 않고 작업을 연기할 수 있다.</li>
<li><strong>작업이 시스템에 상태에 따라 달라지는가?</strong> 장치에 전원 연결, 인터넷 연결 등과 같은 특정 조건을 충족할 때만 작업을 실행하기를 원할 수 있다. 예를 들어, 사용자의 앱은 주기적으로 저장된 데이터를 압축해야 할 수 있다. 사용자에게 영향을 주지 않도록 하려면 장치가 충전되고 유휴 상태일 때만 이 작업을 수행하기를 원할 것이다.</li>
<li><strong>작업이 정확한 시간에 실행되어야 하는가?</strong> 일정 관리 앱의 경우, 사용자가 특정 시간에 발생할 이벤트에 대해서 미리 알림을 설정하도록 할 수 있다. 사용자는 정확한 시간에 알림을 볼 수 있을 것으로 예상한다. 다른 경우, 앱은 작업이 실행될 때 정확하게 신경을 쓰지 않을 수 있다. 앱에는 &quot;작업 A가 먼저 실행되야 하고, 그 다음에 작업 B가 실행되어야 하며 다음에는 작업 C가 실행되어야 한다.&quot;와 같은 일반적인 요구 사항이 있을 수 있다. 하지만, 특정 시간에 실행되기 위해서는 작업이 필요하지 않다.</li>
</ul>
<img src="/img/android_background_way.png" width="600" height="300">
<ol>
<li>WorkManager</li>
</ol>
<p>모든 OS 백그라운드 실행 제한을 고려하여 백그라운드 실행에 권장되는 솔루션이다. 장치 또는 애플리케이션이 재시작되더라도, 작업이 연기될 수 있거나 작업이 실행될 것으로 예상되는 경우 <code>WorkManager</code>를 사용할 수 있다.</p>
<p>작업 조건(네트워크 가용성, 배터 등)이 만족될 때, 지연 가능한 백그라운드 작업을 멋지게 실행할 수 있다.</p>
<p>장점으로는 작업(일회성 또는 반복성)을 예약하거나 작업을 결합(체이닝)할 수 있다. 또한 장치가 유휴상태이거나 충전 중일 때 특정 이벤트를 트리거하거나 콘텐츠 프로바이더가 변경될 때 실행하는 것과 같은 실행 제한 조건을 적용할 수 있다.</p>
<p>한 가지 예로 로그를 압축하여 서버에 업로드 해야 하는 경우라면 두 가지 작업 요청을 만들어 수행할 수 있다.</p>
<ol>
<li>파일을 압축한다. -&gt; 이 단계에서 장치가 충전 중이어야 한다는 제한 조건을 추가할 수 있다.</li>
<li>서버에 업로드 한다. -&gt; 이 요청의 경우 네트워크가 사용 가능할 때만 작업이 실행되도록 네트워크 연결 제한 조건을 추가해야 한다.</li>
</ol>
<p>두 작업을 모두 큐에 넣은 뒤 WorkManager와 함께 필요한 리소스가 충족할 때 작업을 수행하도록 할 수 있다. 또 다른 장점으로는 전원 관리 기능을 존중하는 것이다. WorkManager는 제약 조건이 충족되며, Doze가 해제된다면 주어진 작업을 실행할 것이다.</p>
<p>자세한 내용은 다음 포스팅에서 정리할 예정이다.</p>
<ol start="2">
<li>Foreground Service</li>
</ol>
<p>앱에서 음악, 비디오 재생 또는 탐색과 같이 앱을 종료하거나 화면을 꺼도 지연되지 않고 사용자가 시작한 작업을 완료해야 하는 경우 Foreground Service를 사용해야 한다. Foreground Service를 사용한다는 것은 중요한 일을 하고 있으므로 죽여서는 안된다는 것을 시스템에 알린다. 그리고 Notification Bar에 띄워서 Foreground Service가 수행 중임을 표시해야 한다.</p>
<ol start="3">
<li>Alarm Manager</li>
</ol>
<p>정확한 시간에 작업을 실행해야 하고 사용자와 상호 작용이 포함되며 지연될 수 없는 경우 사용하면 된다. Alarm Manager는 사용자가 지정한 시간에 필요한 경우 사용자의 앱을 실행한다.</p>
<p>그러나 작업이 정확한 시간에 실행될 필요가 없다면 WorkManager가 더 나은 방법이다. WorkManager는 시스템 자원의 균형을 더 잘 맞출 수 있다. 예를 들어, 매 시간마다 작업을 실행해야 하지만 특정 시간에 작업을 실행할 필요가 없는 경우, WorkManager를 사용하여 반복 작업을 설정하면 된다.</p>
<p>또한, 알람이 발생하면 작업을 짧은 시간내에 끝내야 한다. 네트워크에 접근하지 못할 수도 있다.(도즈모드나 앱 대기 버킷 때문에) 네트워크가 필요하거나 시간이 오래 걸리는 작업을 수행하려면 위에서 언급한 WorkManager를 사용해야 한다. 알람이 울릴 때마다 장치는 저전력 모드를 벗어나 부분적 wake-lock을 유지하므로 시간이 지남에 따라 배터리 수명에 상당한 영향을 줄 수 있다.</p>
<ol start="4">
<li>Download Manager</li>
</ol>
<p>사용자가 앱을 통해서 시간이 오래 걸리는 Http 다운로드를 수행하고 있다면 Download Manager를 사용하면 된다. 클라이언트는 URI를 앱 프로세스 외부에 있을 수 있는 특정 대상 파일로 다운로드하도록 요청할 수 있다. Download Manager는 백그라운드에서 다운로드를 수행하여 Http 상호 작용을 관리하고 실패 후 또는 연결 변경 및 시스템 재부팅 전반에 걸쳐 다운로드를 재시도 한다.</p>
<p>요약하면 아래와 같다.</p>
<img src="/img/android_background_ways.png" width="600" height="300">
<p>파일을 다운로드 할 때 다운로드 매니저를 사용하면 될 것으로 예상이된다. 하지만, 다운로드 같은 경우 백그라운드에서 동작하고 시간이 오래 걸릴 수도 있기 때문에 백그라운드 정책에 위반될 상황이 생길 수도 있을 것 같다. 하지만, 다운로드 매니저가 내부적으로 어떻게 구현되어있는지 모르기 때문에 아직 확신할 수 없다. 관련 내용을 조금 더 찾아봐야 할 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=868" target="_blank" rel="noopener">새로운 안드로이드 백그라운드 실행 정책</a></li>
<li><a href="https://developer.android.com/guide/background/" target="_blank" rel="noopener">Guide to background processing - 공식 문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy/"
                            aria-label=": [Android] 버전별 백그라운드 정책"
                        >
                            [Android] 버전별 백그라운드 정책
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T11:49:28+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>백그라운드 작업이 필요한데, 그 전에 구글에서 제한하고 있는 백그라운드 작업에 대해서 알아보려고 한다.</p>
<h2 id="1-버전별-백그라운드-정책-변천사">1. 버전별 백그라운드 정책 변천사</h2>
<p>안드로이드는 큰 업데이트마다 배터리를 관리하기 위한 여러 기능들을 포함해왔다. 아래의 내용을 확인해보자.</p>
<ul>
<li>롤리팝 5.0 : Job Scheduler의 등장. 작업을 미루거나 스케쥴링 할 수 있도록 함.</li>
<li>마시멜로우 6.0 : <a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes#behavior-power" target="_blank" rel="noopener">도즈 모드 및 앱 대기모드</a> 등장.
<ul>
<li>디바이스 또는 앱이 장시간 사용중이 아닐 때 즉, 화면이 꺼지고 충전중이 아닐 때, 네트워크의 접근을 제한하고 백그라운드 작업을 유예하기 시작.</li>
</ul>
</li>
<li>누가 7.0 : <a href="https://developer.android.com/about/versions/nougat/android-7.0-changes#doze" target="_blank" rel="noopener">개선된 도즈모드</a>
<ul>
<li>화면이 꺼지고 움직이지 않을 때 도즈모드의 하위 제약 조건이 적용되기 시작.</li>
</ul>
</li>
<li>오레오 8.0 : 백그라운드 제약
<ul>
<li>백그라운드 서비스와 위치 갱신을 제약하기 시작.</li>
</ul>
</li>
<li>파이 9.0 : 앱 대기 버킷, 배터리 세이버 개선.</li>
</ul>
<p>Oreo 버전 이상을 대상으로 업데이트 할 때 아래의 체크리스트를 확인하여 백그라운드 작업을 설정할 수 있다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">현재 사용하고 있는 방법</th>
<th style="text-align:left">오레오 이상에서 사용해야 하는 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JobScheduler</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Firebase JobDispatcher</td>
<td style="text-align:left">Firebase JobDispatcher</td>
</tr>
<tr>
<td style="text-align:left">Background Service</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Foreground Service</td>
<td style="text-align:left">Foreground Service와 해당 서비스를 종료해야 할 액션(stopService)</td>
</tr>
</tbody>
</table>
<p>WorkManager 라이브러리가 현재는 Alpha 단계이기 때문에 위의 방법들로 개발해야 하지만 정식 버전이 출시된다면 거의 모든 경우를 <code>WorkManager</code>로 해결할 수 있을 것 같다. 기대해보자~</p>
<h2 id="2-올바른-앱을-만드는-전략">2. 올바른 앱을 만드는 전략</h2>
<ul>
<li>백그라운드에서 수행하는 작업은 지연 가능할만한 작업들로 만든다.</li>
<li>Foreground Service를 사용할 때는 노티피케이션을 반드시 제공하여 사용자가 서비스를 중지할 수 있도록 한다.</li>
<li>알람, 네트워크 및 FCM 메시지와 같은 OS 기반의 작업에서는 이와 관련된 전원 관리 제한사항에 대한 문서 내용을 확인해보자.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=737" target="_blank" rel="noopener">안드로이드 버전별 백그라운드 정책</a></li>
<li><a href="https://developer.android.com/about/versions/oreo/background?hl=ko" target="_blank" rel="noopener">백그라운드 실행 제한 - 공식문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/What-is-Service/"
                            aria-label=": [안드로이드] Service"
                        >
                            [안드로이드] Service
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T10:31:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-service란">1. Service란?</h2>
<p><strong>Service</strong>는 안드로이드 Application을 구성하는 4대 컴포넌트 중 하나이다. Activity처럼 사용자와 상호 작용을 하는 컴포넌트는 아니다. 때문에 UI가 존재하지 않으며 <strong>Background</strong>에서 동작하는 컴포넌트이다.</p>
<p>Service가 실행되고 있는 상태라면 안드로이드 OS에서는 해당 Process를 왠만하면 죽이지 않도록 방지하고 관리하게 된다. 그렇기 때문에 메모리 부족이나, 특별한 경우를 제외하고는 Background 동작을 수행하도록 설계되었다.</p>
<img src="/img/android_service.png" width="600" height="300">
<h2 id="2-service는-왜-필요할까">2. Service는 왜 필요할까?</h2>
<p>'Android Application을 구성하기 위해서 Service는 왜 필요할까?'라고 생각을 할 수 있다. 그 이유는 Activity 즉, 사용자가 보고 있는 화면이 종료된 상태에서도 동작하기 위해서 만들어졌고, 개발자는 구현을 해야 한다.</p>
<p>예를 들어서 Mp3 플레이어 같은 기능을 활용하는 경우가 될 수 있다. Mp3 플레이어는 화면이 종료된 상태에서도 계속 노래를 재생해야 하기 때문에 Background에서도 동작하도록 만들어야 한다. 따라서 <strong>Service</strong>를 사용해 구현하면 된다.</p>
<ul>
<li>파일 다운로드 같은 경우에도 사용할 수 있다.</li>
<li>애플리케이션이 실행 중이지 않을 때도 작업해야 하는 경우에도 사용할 수 있다.(애플리케이션이 실행 중일 때만 작업해야 하는 경우 <strong>스레드</strong> 사용을 권장한다.)</li>
</ul>
<p><strong><code>주의</code></strong><br>
Service가 Background에서 동작을 수행하는 컴포넌트라고 해서 Main Thread에서 실행되는 것이라고 생각하지 않을 수도 있다. 명심해야 할 점은 Android 4대 컴포넌트들은 모두 Main Thread에서 실행된다.</p>
<p>따라서 CPU 자원을 많이 소모하거나 네트워크 통신과 같은 시간이 오래 걸리는 작업은 별도의 Thread를 만들어서 처리해야 한다. 이 부분은 아래에서 ANR과 함께 설명하겠다.</p>
<h2 id="3-service-사용-방법">3. Service 사용 방법</h2>
<p>2가지 방법이 있으면 <code>startService()</code>와 <code>bindService()</code>이다.</p>
<ol>
<li><strong>startService() - 시작 타입의 서비스</strong></li>
</ol>
<ul>
<li>서비스를 상속받는 클래스를 작성하며, 정적 리시버와 유사하게 매니페스트 파일에 등록한다.</li>
<li>한 번 시작되면 백그라운드에서 무한정 실행된다.</li>
<li>작업을 완료하면 서비스가 종료된다.</li>
<li>간단한 작업들만 수행한다.</li>
<li>호출한 곳에 결과값을 반환하지 않고 계속해서 서비스한다.(음악 재생, 파일 다운로드 등)</li>
<li>하나의 프로세스 안에서 동작하며, 패키지내 컴포넌트들과 유기적으로 통신하는 역할을 한다.</li>
<li>생명 주기 : onCreate() -&gt; onStartCommand() -&gt; 실행 -&gt; onDestroy() -&gt; stopService()</li>
</ul>
<img src="/img/android_startService.png" width="600" height="300">
<ol start="2">
<li><strong>bindService() - 연결 타입의 서비스</strong></li>
</ol>
<ul>
<li>클라이언트 - 서버와 같이 동작하며 호출자(액티비티)에서 서비스에게 어떤 것을 요청하고 서비스는 요청을 처리한 후 결과값을 반환한다. (서비스가 서버의 역할을 수행.)</li>
<li>액티비티가 사라지면 서비스도 자동적으로 destroy되면서 없어진다.</li>
<li>하나의 서비스가 다수의 액티비티와 연결될 수 있다.</li>
<li>프로세스 내에서 다른 컴포넌트들과 서로 유기적으로 통신을 하며 <strong>또한, 어플 내의 기능을 외부에 제공하는 경우에 많이 사용된다. 즉, 다른 프로세스들 간에서도 Data 공유 및 통신이 유기적으로 가능하다.</strong></li>
<li>생명 주기 : onCreate() -&gt; onBind() -&gt; 실행 -&gt; onUnbind() -&gt; onDestory() -&gt; stopService()</li>
</ul>
<img src="/img/android_bindService.png" width="600" height="300">
<ol start="3">
<li><strong>intentService</strong></li>
</ol>
<ul>
<li>내부적으로 handlerThread가 동작하는 서비스</li>
<li>루퍼가 message Queue에 들어온 요청에 대해 순차적으로 처리한다.</li>
<li>Queue가 비게 되면 자동으로 서비스가 종료된다.</li>
<li>동시에 처리하는게 아니므로 성능은 조금 떨어지지만 순차적 실행이 보장된다.</li>
</ul>
<h2 id="4-service-사용시-주의사항">4. Service 사용시 주의사항.</h2>
<p>Android는 Linux 기반의 프로그램이다. 프레임워크 단에는 Linux로 구현되어 있다. 메모리 관리 또한 Linux 정책을 따르며 Linux Kernel에 의해서 관리된다.</p>
<img src="/img/android_linux_kernel.png" width="600" height="300">
<p>결국 여러 프로세스들을 커널에서 관리한다고 짐작할 수 있다.<br>
또한 하나의 프로세스 안에는 애플리케이션, 안드로이드 4대 컴포넌트, 스레드 등을 구성하고 있다. 즉, 4대 컴포넌트의 운명 또한 리눅스 커널에 달려있다는 걸 의미한다.</p>
<p>만약, 메모리 부족이나 과부하 등과 같은 현상이 발생했을 때 리눅스 커널이 프로세스를 강제로 종료시킬 수 있다.</p>
<img src="/img/android_process.png" width="600" height="300">
<p>여기서 주의해야 할 점이 있다. 바로 모든 컴포넌트들이 <strong>Main Thread</strong> 안에서 실행된다는 점이다. 안드로이드에서 Main Thread는 UI 작업을 처리하는 Thread이다. 따라서 Main Thread에서는 네트워크 작업이나 시간이 오래 걸리는 작업을 하게 되면 앱의 반응성이 낮아질 수 있다. 사용자의 불편함을 방지하고나 시스템이 <code>ANR</code> 상태로 전환시킬 수 있다.</p>
<p>Service 역시 Main Thread에서 동작하기 때문에 시간이 오래 걸리는 작업을 할 경우에는 별도의 작업 Thread를 만들어서 동작을 처리해야 한다. 그리고 작업 결과를 UI Thread에 반영하기 위해서 쓰레드 간 통신 방법을 이용해 반영해야 한다.</p>
<p>쓰레드간 통신 방법은 다음의 글을 참고하면 보면 될 것 같다.<br>
<strong><a href="https://woovictory.github.io/2019/01/07/Android-For-Interview-4/">쓰레드간 통신 방법</a></strong></p>
<p><strong>추가적인 내용들은 빠른 시일 내에 공부해서 포스팅할 예정이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://limkydev.tistory.com/43" target="_blank" rel="noopener">[Android] 서비스(Service) 전반적인 개념</a></li>
<li><a href="https://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-Service-%EC%82%AC%EC%9A%A9%EB%B2%95" target="_blank" rel="noopener">안드로이드/Android Service 사용법</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/What-is-Service/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/What-is-WorkManager/"
                            aria-label=": [Android] Work Manager"
                        >
                            [Android] Work Manager
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T10:29:10+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에 공부할 내용은 <strong>WorkManager</strong>이다.<br>
백그라운드를 다루는 안드로이드의 새 버전들의 출시로 인해, 백그라운드 다루기는 이전보다 더 복잡해져다. 그래서 구글은 <code>JetPack</code>의 일부로 이러한 백그라운드 작버을 도와주기 위해 WorkManager를 출시했다.</p>
<p>먼저, 왜 만들어지게 되었고, 왜 필요한지를 알 필요가 있다고 생각한다. 사용하는 것도 중요하지만 내가 왜 사용하는지 <strong>이유</strong>를 알고 쓰는게 더 중요하기 때문이다.</p>
<p>아래와 같은 3개의 구성으로 나누도록 하겠다.</p>
<ol>
<li>메모리</li>
<li>현재 존재하는 백그라운드 처리 방법</li>
<li>WorkManager</li>
</ol>
<h2 id="1-메모리">1. 메모리</h2>
<p>안드로이드 커널은 리눅스 커널을 기반으로 해서 만들어졌다. 안드로이드 커널과 모든 리눅스 커널들의 가장 큰 차이점은 <code>스왑 공간(Swap Space)</code>가 없다는 것이다.</p>
<p>리눅스의 스왑공간은 램이 꽉 찼을 때 사용된다. 시스템은 더 많은 메모리 리소스를 필요로 하지만 램이 꽉 찼을 때, 메모리 상의 비활성 페이지를 <strong>스왑 공간</strong>으로 이동시킨다. 스왑공간은 램의 용량이 작은 디바이스에 도움이 되긴 하지만, 램의 용량을 늘리는 것을 대체할 수는 없다. 스왑공간은 램보다 Access time이 훨씬 느린 하드 드라이브에 위치하기 때문이다.</p>
<p>안드로이드에서는 스왑공간 같은 개념이 없다. 시스템의 메모리가 다 소진되었을 때, OOM 킬러를 이용해 프로레스스 강제 종료시켜버린다. OOM 킬러는 <strong>Visible 상태</strong>와 <strong>소모된 메모리의 양</strong>에 기반하여 프로세스를 정리하여 여유 메모리를 확보한다.</p>
<p>모든 프로세스는 액티비티 매니저가 부여한 자신의 <code>oom_adj</code> 점수를 가지고 있다. 이 점수는 애플리케이션의 상태(Foreground, Background, Background Service 등등)의 조합이다. 아래는 모든 <code>oom_adj</code> 값을 보여준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Define the oom_adj values for the classes of processes that can be</span><br><span class="line"># killed by the kernel.  These are used in ActivityManagerService.</span><br><span class="line">    setprop ro.FOREGROUND_APP_ADJ 0</span><br><span class="line">    setprop ro.VISIBLE_APP_ADJ 1</span><br><span class="line">    setprop ro.SECONDARY_SERVER_ADJ 2</span><br><span class="line">    setprop ro.BACKUP_APP_ADJ 2</span><br><span class="line">    setprop ro.HOME_APP_ADJ 4</span><br><span class="line">    setprop ro.HIDDEN_APP_MIN_ADJ 7</span><br><span class="line">    setprop ro.CONTENT_PROVIDER_ADJ 14</span><br><span class="line">    setprop ro.EMPTY_APP_ADJ 15</span><br></pre></td></tr></table></figure>
<p>프로세스의 <code>oom_adj</code>의 값이 클수록 커널의 OOM 킬러에게 정리당하기 쉽다. OOM 킬러는 현재 사용 가능한 여유메모리 크기와 <code>oom_adj</code> 임계값을 기반으로 구성한 규칙을 사용한다. 즉, OOM 킬러의 조건은 아래와 같다.</p>
<p><strong>여유 메모리 공간의 크기가 X보다 작을 때, oom_adj 값이 Y보다 큰 프로세스를 정리하라!</strong></p>
<p>즉, 앱이 메모리를 적게 소비할수록 프로세스가 정리되지 않고 중요한 내용을 다룰 기회가 더 많아진다는 것이다. 두번째로 중요한 내용은 애플리케이션의 상태에 대해 이해하는 것이다. 그래서 앱이 백그라운드에 진입했을 때에도 뭔가를 지속적으로 하고 싶다면 <strong>서비스</strong> 컴포넌트를 사용해야 한다.</p>
<ul>
<li>서비스는 UI를 제공하지 않고, 백그라운드에서 오래 걸리는 동작을 수행할 수 있도록 하는 4대 컴포넌트 중 하나이다.</li>
<li>서비스를 사용해야 했던 이유는 아래와 같다.
<ol>
<li>시스템에게 이 프로세스가 오래 걸리는 작업이 있음을 알려주고, 그에 맞는 <strong>oom_adj</strong> 점수를 얻도록 하기 위함이다.</li>
<li>안드로이드 애플리케이션의 4대 컴포넌트 중 하나이다.</li>
<li>서비스를 별개의 프로세스에서 실행시킬 수 있다.</li>
</ol>
</li>
</ul>
<p>사용했을 때의 이점이 있기 때문에 좋아 보인다. 하지만, 서비스 사용의 단점이 있다.</p>
<ol>
<li>프로세스가 계속 실행되고 있는 것이므로 배터리를 엄청나게 소모한다.</li>
<li>마시멜로우 버전부터 도즈 모드(Doze)가 도입되었다.</li>
<li>누가 버전에서 더 발전되었고 오레오 버전에서 더욱 강화되었다.</li>
</ol>
<p>도즈 모드는 사용자가 디바이스의 스크린을 끄고 나면 네트워크 통신, Sync, GPS, 알람, 와이파이 스캔 등을 비활성화 시켜버린다. 사용자가 스크린을 켜거나 디바이스를 충전기에 연결할 때까지 유지된다. 그리고 중요하지 않은 일을 수행하는 앱의 개수를 줄임으로써 디바이스의 배터리를 절약하도록 한다.</p>
<p>또한, 오레오 버전으로 타게팅된 앱이 백그라운드 서비스 생성을 허가받지 않은 채로 <code>startService()</code> 메소드를 호출하려고 하면 백그라운드 서비스 제한이 있어서 <code>IllegalStateException</code> 예외를 던진다.</p>
<p>'그럼 오레오 버전으로 타게팅 하지 않으면 되잖아?'라고 생각할 수 있다. 구글의 정책을 살펴보도록 하자.</p>
<ul>
<li>2018년 8월 : 새로 출시되는 앱들은 반드시 API 26(Oreo 8.0) 이상</li>
<li>2018년 11월 : 기존 앱들도 API 26(Oreo 8.0) 이상.</li>
<li>2019년 이후 : 매년 targetSdkVersion 요구사항이 향상될 것이다. 안드로이드가 매년 새로운 버전을 낼 때마다, 모든 앱들은 해당 API 레벨 이상을 타겟팅 해야 한다.</li>
</ul>
<p><strong>이를 통해 알 수 있는 것은 백그라운드 작업을 위해 더 이상 서비스를 사용하지 않게 될 것이라는 것이다.</strong></p>
<h2 id="2-현재-존재하는-백그라운드-처리-방법">2. 현재 존재하는 백그라운드 처리 방법</h2>
<p><strong>AlarmManager와 BroadcastReceiver 사용</strong></p>
<p>지정한 타이밍에 시스템에서 알림이 오고 여기에 맞춰 백그라운드 작업을 수행할 수 있었다. 하지만, 킷캣(K, API 19) 버전에서는 알림이 미뤄지거나 한 번에 몰아서 오는 등 정확한 실행을 보장하지 않게 된다.</p>
<p><code>BroadcastReceiver</code>를 통해서 기기의 부팅, 네트워크 연결 등의 디바이스 이벤트를 시스템으로부터 전파받아서 특정 작업을 수행해왔는데 누가(N, API 24)버전에서 특정 인텐트에 대한 동작이 제한되고, 오레오(O, API 26)버전에서 암시적 브로드캐스트 리시버 등록을 차단하는 등 제한이 추가되고 있다.</p>
<p>그래서 대안책이 <strong>Job</strong>을 사용하는 것이다.</p>
<p><strong>JobScheduler 사용</strong></p>
<p>롤리팝(L, API 21) 버전에서 <code>JobScheduler</code>를 제공한다. 부정확해진 Alarm Manager의 대안이기도 했고, 결국 백그라운드 작업을 배제할 수 없었기 때문이다. 하지만, API 2에서 사용할 수 있다는 제약으로 인해 API 21 이전과 이후 버전을 나누어 <code>AlarmManager</code>와 <code>JobScheduler</code>를 각각 사용해서 구현해야 하는 번거로운 문제가 생겼다.</p>
<p><strong>JobDispatcher 사용</strong></p>
<p>이후에 구글은 Firebase JobDispatcher를 제공하기 시작했다. JobDispatcher는 진저브레드(G, API 9) 버전 이상을 지원한다. 그리고 내부적으로 <code>AlarmManager</code>와 <code>JobScheduler</code>를 선택해준다. 이를 통해서 개발자가 하는 일은 한 가지로 줄었으나, 구글 플레이 서비스에 의존하게 되어 아마존/주욱 제조사 디바이스에서는 기능을 사용할 수 없다. 결국, 구글 플레이 서비스를 지원하지 않는 디바이스에서는 <code>AlarmManager</code>와 <code>JobScheduler</code>를 각각 사용해서 구현해야 한다.</p>
<p><strong>JobIntentService 사용</strong></p>
<p>다른 대안으로 <code>JobIntentService</code>를 사용하는 방법이 있다. 하지만, 정확한 시간에 작업이 수행되지 않기 때문에 오레오에서 Job을 빨리 수행하는데는 도움이 되지 않는다.</p>
<p><strong>Android-Job(Evernote) 라이브러리(Third party library) 사용</strong></p>
<p>이는 자동으로 안드로이브 버전에 따라 <code>AlarmManager</code>, <code>JobScheduler</code>, <code>JobDispatcher</code>들 중 어떤 것을 사용할지 결정해주는 라이브러리이다. WorkManager를 제외하고 생각한다면 가장 좋은 라이브러리라고 평가받고 있다.</p>
<p>하지만, Evernote가 새로운 가이드 안을 발표했다. 안드로이드 버전에 따라 백그라운드 API가 수시로 변경되어서 버전별로 분기가 필요하고 복잡한 API 사용이 힘들었을텐데 앞으로 Evernote는 Android Job 라이브러리를 배포하여 개발자들에게 편의를 제공해왔지만 더 이상 지원하지 않고 <code>WorkManager</code> 사용을 권장한다는 내용이다.</p>
<p>결국, 현재 실행 중인 안드로이드 버전에 따라서 백그라운드 서비스 API를 다르게 호출시키고 관리해야 한다. 디바이스의 안드로이드 버전과 구글 플레이 서비스 여부에 따라 백그라운드 서비스를 지원하기 까다롭다. 그래서 Google I/O에서 <code>WorkManager</code>라는 해결책을 제공해주었다.</p>
<h2 id="3-workmanager">3. WorkManager</h2>
<p>2018년 Google I/O에서는 안드로이드의 백그라운드 작업을 도와줄 WorkManager가 공개되었다.<br>
WorkManager는 Android JetPack의 아키텍처의 구성 요소이다.</p>
<p>WorkManager는 다음과 같은 특징을 갖는다.</p>
<img src="/img/workmanager_feature.png" width="600" height="300">
<ul>
<li>실행이 보장된다. 또한 제약 조건을 가지고 실행할 수 있다. 예를 들어, 네트워크 연결시에만 처리되는 작업을 추가하면 네트워크가 연결되면 반드시 실행된다.</li>
<li>장치의 상태를 존중한다. 도즈 모드에 진입하면 일을 처리하기 위해 기기를 깨우거나 하지 않는다.</li>
<li>실행 중인가, 대기 중인가, 완료되었는가 등의 상태 조회가 가능하다.</li>
<li>작업 A의 결과에 따라 B 또는 C를 선택하여 처리하고 D를 이어서 처리하는 등의 작업 연결 처리가 가능하다.(체이닝)</li>
<li>첫 번째 특징과 비슷하며 기회주의적이다. 즉, 어떤 제한 조건이 충족되었을 때 즉시 실행된다.</li>
</ul>
<p>WorkManager는 내부적으로 아래의 그림과 같이 동작한다.</p>
<img src="/img/WorkManager_run.png" width="600" height="300">
<p>API의 버전에 맞게 <code>AlarmManager</code>와 <code>JobScheduler</code>를 사용하고 개발자가 Firebase JobDispatcher 의존성을 추가했다면(즉, 구글 플레이 서비스 사용이 가능하다면)<code>JobDispatcher</code>를 적극 사용한다.</p>
<p>개발자는 WorkManager를 사용함으로써 상황에 맞는 고민이나 별도의 구현 없이 앱의 종료나 기기의 재부팅된 경우에도 항상 장치에 맞는 가장 적합한 방법을 사용하여 백그라운드 작업을 처리할 수 있게 된다.</p>
<p><code>그러나 WorkManager가 항상 최선은 아니다.</code></p>
<p>앱의 종료 여부와 상관없이 수행되어야 하는 작업, 즉 앱의 프로세스 수명과 별도로 살아남기 위한 작업에 사용하는 것을 추천한다.</p>
<p>예를 들어 이미지를 서버에 업로드해야 하거나, 데이터를 분석하고 이를 데이터베이스에 저장해야 하는 작업에는 <strong>WorkManager</strong>를 사용하는 것이 좋다.</p>
<p>그러나 사용자가 현재 보고 있는 UI를 빠르게 변경해야 하는 작업이나 물건 구입 과정에서의 결제 진행 등 즉시 처리해야 하는 작업은 WorkManager를 사용하지 않는 것이 좋다.</p>
<img src="/img/when_to_use_workmanager.png" width="600" height="300">
<p>WorkManager의 작업은 반드시 실행되지만 그 처리가 상황에 따라 지연되거나 도중에 중단될 경우 다시 실행될 수 있다는 것을 꼭 기억해야 한다.</p>
<p>적절한 상황에서는 WorkManager는 AlarmManager나 JobScheduler, JobDispatcher를 대체하는 훌륭한 백그라운드 작업 처리 방법이다.</p>
<p>다음에는 WorkManager를 사용해보는 시간을 갖도록 하겠다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://duzi077.tistory.com/222" target="_blank" rel="noopener">WorkManager로 안드로이드 하위 버전부터 오레오 버전까지 백그라운드 작업 통합</a></li>
<li><a href="http://dktfrmaster.blogspot.com/2018/06/workmanager.html" target="_blank" rel="noopener">[안드로이드] WorkManager에 관하여</a></li>
<li><a href="https://medium.com/@limgyumin/%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-%EC%9E%91%EC%97%85-%EC%B2%98%EB%A6%AC%EB%B2%95-workmanager-f625e07b384c" target="_blank" rel="noopener">새로운 안드로이드 백그라운드 작업 처리법 : WorkManager</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/What-is-WorkManager/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/How-to-initialize-of-viewModel/"
                            aria-label=": [안드로이드] ViewModel 초기화 - 1"
                        >
                            [안드로이드] ViewModel 초기화 - 1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T00:45:47+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번 포스팅에서 다룰 주제는 Android Architecture Components 중 하나인 <code>ViewModel</code>이다. 해당</p>
<p>안드로이드 앱 개발을 하다보면 겪는 문제 중 하나는 생명주기와 관련된 것이다. 그 중에서 액티비티와 프래그먼트의 생명주기는 많은 상태와 여러 가지 케이스에 따른 복잡함으로 예전부터 지금까지도 우리에게 까다로운 존재임이 분명하다.</p>
<p>예를 들면, 런타임에 화면 방향이 전환되거나 언어, 글꼴 배율과 같은 기기 구성이 변경되는 경우를 다루려면 세심한 처리가 필요하다. 이러한 변경이 일어나는 경우, 안드로이드는 실행 중인 액티비티를 종료하고 메모리에서 제거한 후 다시 생성하기 때문에 이 과정에서 액티비티에 종속된 UI 데이터를 유지하는 것은 손이 많이 가는 작업이다.</p>
<h2 id="화면-회전에-대한-해결책">화면 회전에 대한 해결책</h2>
<p>액티비티가 종료되기 직전 호출되는 <code>onSaveInstanceState()</code> 콜백에서 액티비티의 상태 또는 데이터를 저장할 수 있지만 <strong>직렬화할 수 없는 객체는 저장할 수 없다.</strong> 왜냐하면 이 방법은 애초에 많은 양의 데이터를 저장하기 위해 디자인되지 않았기 때문이다.</p>
<p>이번에 공부하면서 처음 본 방법이 또 있다. <strong>유보된 프래그먼트(Retained Fragment)를 사용하는 방법</strong>이다. UI가 없는 워크(헤드리스) 프래그먼트 개념을 도입해 이곳에서 UI에 필요한 데이터를 관리하고 프래그먼트를 setRetainInstance(true)로 설정함으로써 액티비티 재생성시, 프래그먼트를 메모리에 유지(즉, 소멸시키지 않고 유보)시키는 것이다.</p>
<p>이때 프래그먼트는 액티비티에서 분리(onDetach)된 후 새로운 액티비티로 다시 호스팅(onAttach)될 뿐 소멸과 생성을 반복하지 않는다. 하지만, 프래그먼트 도입은 또 다른 **엣지 케이스(일정한 범위를 넘었을 때, 발생하는 문제)**를 다뤄야 한다는 점에서 새로운 고난의 장을 여는 것을 의미하기도 한다. 그리고 이곳이 데이터를 보관하기에 적합한 곳인가? 혹은 오버 엔지니어링이 아닐까?라는 논쟁의 여지가 존재했다.</p>
<p>프래그먼트 이슈에 지친 개발자들은 프래그먼트 없이 개발하기와 같은 방법론에 매료될 정도로, 프래그먼트는 혼란스러움을 대표했다.</p>
<h2 id="viewmodel로-해결하기">ViewModel로 해결하기.</h2>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/How-to-initialize-of-viewModel/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/07/kotlin-chap2/"
                            aria-label=": [커니의 Kotlin] Chap2"
                        >
                            [커니의 Kotlin] Chap2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-07T17:15:30+09:00">
	
		    May 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/커니의-Kotlin/">커니의 Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2># 코틀린의 특징</h2>
                    
                        <a
                            href="/2019/05/07/kotlin-chap2/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [커니의 Kotlin] Chap2"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/03/kotlin-chap1-2/"
                            aria-label=": [커니의 Kotlin] Chap1.2"
                        >
                            [커니의 Kotlin] Chap1.2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-03T20:47:16+09:00">
	
		    May 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/커니의-Kotlin/">커니의 Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>1부에 이어서 작성…</p>
                    
                        <a
                            href="/2019/05/03/kotlin-chap1-2/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [커니의 Kotlin] Chap1.2"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/02/What-is-ViewModel/"
                            aria-label=": [안드로이드] ViewModel"
                        >
                            [안드로이드] ViewModel
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-02T18:34:38+09:00">
	
		    May 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="viewmodel"># ViewModel</h2>
<p><strong>ViewModel</strong> 클래스는 라이프 사이클을 고려하여 UI 관련된 데이터를 저장하고 관리하기 위해 설계되었다. 화면 전환과 같이 설정이 변경되는 상황에서도 data가 계속 남아있을 수 있도록 해준다.</p>
<p>안드로이드 프레임워크는 Activity, Fragment와 같은 UI 컨트롤러의 라이프사이클(즉, 생명주기)을 관리한다. 프레임워크는 사용자의 특정한 동작이나 완전히 예상치 못한 장치의 이벤트에 대한 응답으로 UI 컨트롤러를 파괴(Destroy)하고 재생성(re-create)하는 것을 결정하기도 한다.(액티비티가 종료되고 재생성되는 경우가 해당된다.)</p>
<p>시스템이 UI 컨트롤러를 파괴, 재생성하면 그 안에 저장해두었던 UI 관련 데이터들은 모두 사라진다. 예를 들어, 앱에는 사용자의 목록과 같은 데이터가 포함되어 있을 수 있다. 갑자기 설정이 변경되어 Activity가 재 생성될 때, 새로운 Activity 인스턴스는 사용자의 목록을 다시 불러와야 한다.</p>
<p>단순한 데이터를 다룰 때에는 Activity의 <code>onSaveInstanceState()</code> 함수를 이용해 Bundle 객체에 저장하고 <code>onCreate()</code> 함수에서 Bundle 객체에 저장된 데이터를 불러올 수 있다. 하지만, 이 경우에는 bitmap과 리스트 형식의 많은 양의 데이터가 아닌 직렬화, 역직렬화가 가능한 작은 데이터에 적합하다.<br>
즉, 잠재적으로 데이터의 양이 많다면 적절한 방법이 아니다.</p>
<p>또 다른 문제는 UI 컨트롤러가 자주 비동기 호출을 만들어서 반환하는데 다소 시간이 걸릴 수 있다는 것이다. 잠재적인 메모리 누수를 피하기 위해 UI 컨트롤러는 Destroy 된 후에 시스템이 instance를 정리하기 전에 비동기 호출을 관리할 필요가 있다.<br>
이런 관리 작업은 엄청난 유지보수를 필요로 하고, 상태 변화로 인해 객체를 재생성하는 경우, 이미 만들어진 객체를 다시 호출해야 하므로 리소스가 낭비된다.</p>
<p>Activity, Fragment와 같은 UI 컨트롤러는 사용자에게 UI 데이터를 보여주고, 사용자 액션에 반응하고, 권한 요청과 같은 OS의 요청을 처리하는 용도로 사용된다.</p>
<p>데이터베이스나 네트워크로부터 데이터를 불러오는 동작은 UI 컨트롤러에서 수행하면 클래스의 크기가 커지게 된다. 따라서 UI 컨트롤러에 과도한 책임이 할당되면 클래스가 단일화되어 테스트가 매우 어려워질 수 있다.</p>
<p>그래서 <code>ViewModel</code>을 사용함으로써 UI 컨트롤러의 로직으로부터 UI 로직과 데이터 소유권을 분리할 수 있는 매우 효과적인 방법이다.</p>
<h2 id="viewmodel-예시"># ViewModel 예시.</h2>
<p>Google의 Android Architecture Components(이하 AAC)에서 UI 컨트롤러들을 위한 헬퍼 클래스인 <code>ViewModel</code>을 제공한다.<br>
ViewModel 객체는 자동으로 화면 회전 같은 상태 변화동안 자동으로 유지되고 새로운 액티비티 또는 프래그먼트에서도 데이터를 즉시 사용할 수 있다.</p>
<p><strong>MainViewModel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; userList;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers()&#123;</span><br><span class="line">        <span class="keyword">if</span>(userList == <span class="keyword">null</span>)&#123;</span><br><span class="line">            userList = <span class="keyword">new</span> MutableLiveData&lt;List&lt;User&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch userList.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainActivity</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MainViewModel viewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(MainViewModel.class);</span><br><span class="line">        viewModel.getUsers().observe(<span class="keyword">this</span>, userList -&gt;&#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 액티비티가 재생성이 된다면 처음 만들어진 <code>MainViewModel</code> 인스턴스를 받게 된다. 이 인스턴스를 호출한 액티비티 또는 프래그먼트가 destroy 되어 메모리 해제가 되기 전까지 데이터를 유지하고 있어서 데이터를 보관하고 있다가 화면 회전 같은 상태 변화가 발생해도 데이터를 유지하게 된다.</p>
<p>안드로이드 프레임워크는 내부적으로 class, ViewModel의 Map을 관리하므로 이미 존재하는 ViewModel의 레퍼런스를 가져올 때마다 그 인스턴스를 반환하게 된다.</p>
<p>ViewModel을 소유한 액티비티가 종료되면 프레임워크는 자동으로 ViewModel 객체의 onCleared() 메소드를 호출할 것이다. 그렇다면 우리는 이 함수를 오버라이드하여 리소스를 해제하면 된다.</p>
<p>ViewModel 인스턴스는 뷰나 <code>LifecycleOwners</code>의 특정 인스턴스보다 오래 유지되도록 설계되었다. 이런 설계는 ViewModel 인스턴스가 뷰나 Lifecycle 인스턴스를 모르기 때문에 ViewModel에 대해 더 쉽게 테스트를 작성할 수 있게 해준다.</p>
<p>ViewModel 인스턴스는 <strong>LiveData</strong> 인스턴스와 같은 <code>LifecycleObservers</code>를 포함할 수 있다. 하지만, LiveData와 같은 라이프사이클 기반의 Observable 클래스의 변화를 관찰해서는 안된다. 만약, ViewModel이 시스템 서비스를 찾는 등의 이유로 Application Context가 필요하다면, <code>AndroidViewModel</code> 클래스를 상속받아서 생성자에서 Application 객체를 받도록 구현할 수 있다.</p>
<ul>
<li>주의 : ViewModel 인스턴스는 반드시 뷰, Lifecycle, Activity 참조를 가지고 있는 어떤 클래스도 참조를 유지하면 안된다. 이유는 메모리 누수가 발생할 수 있기 때문이다.</li>
</ul>
<h2 id="viewmodel-생명주기"># ViewModel 생명주기.</h2>
<p>ViewModel의 생명주기는 <code>ViewModelProvider</code>에 전달된 Lifecycle에 생명주기 범위가 지정된다.<br>
즉, 주어진 액티비티가 살아있는 동안 ViewModel 객체는 메모리에 계속 남아있는다.<br>
액티비티의 경우에는 finish될 때, 프래그먼트의 경우에는 액티비티로부터 detached될 때까지이다.</p>
<img src="/img/viewmodel-lifecycle.png" width="600" height="200">
<p>위의 그림에서 ViewModel의 스코프를 확인할 수 있다. 그림은 Activity가 화면 회전되었을 때의 생명주기를 나타낸다. 화면이 회전해도 상태 변경이 되는 상황에서도 살아 있음을 보여준다. Fragment의 기본 생명주기에 따른 ViewModel의 생존시간도 동일하다.</p>
<p>일반적으로 ViewModel 인스턴스를 Activity의 시작점인 onCreate()에서 요청할 것이다. onCreate() 함수는 상황에 따라 여러 번 호출될 수 있지만, ViewModel 객체는 최초 요청부터 Activity가 소멸될 때까지 메모리에 유지된다.</p>
<h2 id="의문점"># 의문점?!</h2>
<p><strong>A 액티비티에서 ViewModel 객체를 생성하면 scope는 A 액티비티의 생명주기를 따르낟. 만약, B 액티비티에서 ViewModel에 저장된 값을 재사용하고 싶다면??</strong></p>
<p>B 액티비티에서 ViewModelProviders로 객체를 다시 구해오면 A 액티비티에서 만든 객체가 아닌 새로운 객체를 만들어낸다.</p>
<p><a href="https://stackoverflow.com/questions/49364550/android-livedata-how-to-reuse-the-same-viewmodel-on-different-activities" target="_blank" rel="noopener">how to reuse the same ViewModel on different activites</a></p>
<p>위의 글을 보면 싱글톤 팩토리로 동작하는 custom ViewModel Factory를 전달하여 다른 액티비티에서도 동일한 ViewModel 인스턴스를 받을 수 있는 방법이 있다.<br>
하지만, 다른 액티비티의 생명주기에서 ViewModel 객체를 유지하는 것은 안티패턴이다.</p>
<p>RxJava와 다르게 생명주기에 따라 데이터를 보관/관리 해주는 LiveData의 장점을 버리는 방식이라고 생각된다.</p>
<p>따라서 ViewModel의 객체를 유지시키는 것이 아닌 DataSource나 Repository를 싱글톤으로 유지하는 것이 더 추천되는 방식이다.<br>
<a href="https://stackoverflow.com/questions/49364550/android-livedata-how-to-reuse-the-same-viewmodel-on-different-activities/49365126#49365126" target="_blank" rel="noopener">https://stackoverflow.com/questions/49364550/</a></p>
<img src="/img/viewmodel-viewModel_reuse.png" width="600" height="200">
<p>ViewModel의 객체를 유지시키는 방식이 아닌 Other data layers(data source, data source를 관리하는 Repository)를 싱글톤 객체로 만들어 데이터를 유지시켜 다른 Activity들에서 새로운 ViewModel 객체를 만들어 Repository를 통해 보관중이 데이터를 가져오는 방식이다.</p>
<h2 id="fragment-간-데이터-공유"># Fragment 간 데이터 공유.</h2>
<p>하나의 액티비티 안에서 2개 이상의 프래그먼트 간에 데이터를 주고 받는 구조는 흔한 경우다. 이럴 때는 프래그먼트의 scope를 사용하는 것이 아닌 프래그먼트들을 감싸고 있는 액티비티의 scope를 전달하면 된다.</p>
<p>즉, 프래그먼트들이 액티비티 scope의 ViewModel을 서로 공유하도록 구현하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewModelProvider</code>를 얻을 때, 두 프래그먼트 모두 <strong>getActivity()</strong> 메소드를 이요하고 있다. 같은 Activity를 이용하여 같은 ViewModel 객체를 요청하므로 동일한 객체가 얻어진다.</p>
<p>이 접근 방법은 다음과 같은 이점이 존재한다.</p>
<ul>
<li>Activity가 각 Fragment간 데이터 전달 시에 추가적인 작업을 할 필요가 없다.</li>
<li>각 Fragment는 ViewModel 외에 다른 객체나 상태에 대해 더 알 필요가 없다. 그러므로 다른 Fragment가 사라지더라도 정상적으로 동작할 것이다.</li>
<li>각 Fragment는 다른 Fragment의 라이프사이클을 신경쓰지 않고, 자신의 라이프사이클 대로 작업을 수행할 수 있다.</li>
</ul>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="https://duzi077.tistory.com/196" target="_blank" rel="noopener">Android Architecture Components ViewModel이란?</a></li>
<li><a href="http://dktfrmaster.blogspot.com/2018/02/viewmodel.html" target="_blank" rel="noopener">[안드로이드] Architecture Component 1 - ViewModel 공식문서 번역</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/02/What-is-ViewModel/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/archives/5/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/archives/7/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 6 of 10</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
