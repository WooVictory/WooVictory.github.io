
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Android - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Android/archives/3/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/01/KotlinInAction-Chap2/"
                            aria-label=": [Kotlin in Action] Chap2. 코틀린 기초"
                        >
                            [Kotlin in Action] Chap2. 코틀린 기초
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-01T19:49:20+09:00">
	
		    Apr 01, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/Kotlin-in-Action/">Kotlin in Action</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>현재 진행하고 있는 스터디에서 <a href="http://m.yes24.com/Goods/Detail/55148593" target="_blank" rel="noopener">코틀린 인 액션</a>을 가지고 공부를 진행하고 있습니다. Github에 Repository를 생성하여 내용을 정리하여 관리하고 있지만, 블로그에서도 확인할 수 있도록 마이그레이션 하고 있습니다.</p>
                    
                        <a
                            href="/2020/04/01/KotlinInAction-Chap2/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Kotlin in Action] Chap2. 코틀린 기초"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/27/Android-Room-Concept/"
                            aria-label=": [Android] Room 개념편"
                        >
                            [Android] Room 개념편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-27T14:22:06+09:00">
	
		    Mar 27, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Room 내용에 대해 정리한 포스팅의 클릭수와 노출수가 상당히 높았다. 그래서 필자가 정리한 내용을 보니 Room에 필요한 내용이 정리되어있지만, 잘 정리되어 있다는 느낌을 받지는 못했다.</p>
<p>필자는 Room에 관한 내용을 더 깔끔하게 정리하여 이 글을 읽는 분들이 더 쉽게 이해할 수 있게 하기 위해 글을 다시 작성하려 한다.</p>
<p><strong>Android Architecture Components</strong>(이하 AAC) 중 하나인 Room의 개념에 대해 알아보는 포스팅이다.</p>
<h3 id="orm">ORM</h3>
<ul>
<li>먼저, ORM이 무엇인지 알 필요가 있다.</li>
<li>ORM은 <strong>Objectg Relational Mapping</strong>으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 <code>DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것을 의미한다.</code></li>
</ul>
<h3 id="room">Room</h3>
<ul>
<li><code>Room</code>은 ORM 기반의 라이브러리이다.</li>
<li>SQLite 위에 추상화 계층을 제공하여 SQLite의 기능을 최대한 활용하는 동시에 데이터베이스에 원활하게 접근할 수 있도록 고안된 라이브러리이다.</li>
</ul>
<h4 id="사용법">사용법</h4>
<p><strong>1) Gradle 설정 (androidX 기준)</strong></p>
<ul>
<li>version은 사용하는 시점에 최신 버전을 사용하면 된다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.1.0-alpha03"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// use kapt for Kotlin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Coroutines support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-coroutines:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2) Room의 구성요소</strong></p>
<ul>
<li>
<p><code>Database</code></p>
<ul>
<li>Database 접근 지점을 제공하며 DAO를 관리한다.</li>
<li>Annotaion 내에 사용할 Entity 목록을 배열로 작성해야 한다.</li>
</ul>
</li>
<li>
<p><code>DAO</code></p>
<ul>
<li>Database에 접근하는데 사용되는 메소드들을 포함하며, Annotation으로 관리된다.</li>
<li>Select, Insert, Delete 등 데이터를 쓰거나 읽을 때 사용한다.</li>
</ul>
</li>
<li>
<p><code>Entity</code></p>
<ul>
<li>Database 내의 테이블을 의미한다.</li>
</ul>
</li>
</ul>
<img src="/img/room_st.png" width="400" height="300">
<p><strong>[Database의 특징]</strong></p>
<ul>
<li>Database 접근 지점을 제공하며, DAO를 관리한다.</li>
<li>클래스에 <code>@Database</code> 어노테이션을 붙이며, 아래의 조건을 만족해야 한다.
<ul>
<li>RoomDatabase 클래스를 상속받는 추상 클래스여야 한다.</li>
<li>어노테이션 내에 Database에 들어갈 Entity 목록을 배열로 포함해야 한다.</li>
<li>파라미터가 0개인 추상 메소드를 포함하고 @Dao 어노테이션된 클래스를 반환한다. 이를 통해 RoomDatabase에게 관리 권한을 위임하여 직접적으로 접근하는 것을 막는다.</li>
</ul>
</li>
<li>Runtime에 Room.databaseBuilder()를 호출해 데이터베이스 인스턴스를 얻을 수 있다.</li>
<li><strong>인스턴스를 만드는 과정을 많은 비용이 든다. 하지만 접근은 자주하기 때문에 문서에서는 싱글톤 패턴을 이용해 만드는 것을 권장하고 있다.</strong></li>
</ul>
<p><strong>[DAO(Data Access Object)의 특징]</strong></p>
<ul>
<li>Database에 접근하는데 사용되는 메소드들을 갖고 있으며, 어노테이션으로 관리된다.</li>
<li>SELECT, INSERT, DELETE 등 데이터를 읽거나 쓸 때 사용한다.</li>
<li>LiveData를 사용하면 Observable Query를 이용할 수 있다.</li>
<li><code>@DAO</code> 어노테이션을 활용하며, <code>interface</code> or <code>abstract class</code>로 작성해야 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getUsers</span><span class="params">()</span></span>: List&lt;UserEntity&gt;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Insert</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">UserEntity</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[Entity 특징]</strong></p>
<ul>
<li>Database 내의 테이블을 의미한다. 이름을 지정할 수도 있고, 지정하지 않을 경우 default 값으로 클래스의 이름이 Entity의 이름으로 지정되며, 대소문자를 구분하지 않는다.</li>
<li>컬럼 값도 위의 규칙과 동일하다.</li>
<li>관련 필드 집합을 Entity들로 정의한다.</li>
<li>각 Entity에 대해 항목을 보관하기 위해 연결된 데이터베이스 객체 내에 테이블이 생성된다.</li>
<li>필드를 유지하려면 Room은 필드에 접근할 수 있어야 한다. 따라서 필드를 public으로 만들거나 getter/setter를 제공할 수 있어야 한다. 그렇지 않고 private으로 필드를 만든다면 에러가 발생한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span></span>(</span><br><span class="line">	<span class="keyword">val</span> userId: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="keyword">val</span> name: String=<span class="string">""</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@gus0000123/mvvm-aac-room%EC%82%AC%EC%9A%A9%EB%B2%95-1-%EA%B0%9C%EB%85%90%ED%8E%B8-59ad680ea6fe" target="_blank" rel="noopener">MVVM AAC Room사용법(1.개념편)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/27/Android-Room-Concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/07/Android-Mockito-Advanced/"
                            aria-label=": [Android] Mockito 심화편"
                        >
                            [Android] Mockito 심화편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-07T01:08:22+09:00">
	
		    Mar 07, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 심화편이다.<br>
이 글을 읽기 전에 <a href="https://woovictory.github.io/2020/03/06/Android-Mockito/">기본편</a>을 먼저 보고 오면 좋다.</p>
<h2 id="gradle">Gradle</h2>
<ul>
<li>Mockito는 기본적으로 Java 기반의 라이브러리이다.</li>
<li>그렇기 때문에 Kotlin을 함께 사용하면 모호한 부분이 존재하기 마련이다.</li>
<li>예를 들면 다음과 같은 구문들이 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person p = mock(Person.class);</span><br><span class="line">        assertTrue(p!=<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        when(p.getName()).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여기서 <code>when</code>문을 보면 그냥 쓰였다.</li>
<li>이는 자바이기 때문에 그대로 쓰이지만 코틀린에서는 다음과 같이 쓰인다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">personMockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> p: Person = mock(Person::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        assertTrue(p != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        `<span class="keyword">when</span>`(p.name).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>표현이 다르다. when의 앞뒤로 `가 붙는다.</li>
<li>자바와 코틀린을 사용할 때, 구문이 맞지 않아서 생기는 문제이다. 크게 신경 쓰이지 않을 수도 있지만, 필자는 신경이 쓰인다.</li>
<li>이뿐만 아니라, 앞서 말했던 Kotlin에서는 모든 클래스가 기본적으로 final로 선언되어 있어 Mockito는 기본적으로 Mocking을 할 수 없는 등의 여러 문제가 있다.</li>
<li>그래서 Niek Haarman이라는 분이 유지 및 관리하는 <code>mockito-kotlin</code> 라이브러리를 사용하면 깔끔하게 해결할 수 있다.</li>
</ul>
<h2 id="mockito-kotlin"><a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="noopener">Mockito-Kotlin</a></h2>
<p>app/build.gradle 파일에 아래와 같이 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-inline:2.21.0'</span></span><br><span class="line">testImplementation <span class="string">"com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>첫 번째는 Mockito-Kotlin 의존성이다.</li>
<li>두 번째는 Kotlin의 클래스는 기본이 final이기 때문에 mockito-inline을 추가해주어 open 클래스로 매번 선언해야 하는 번거로움을 제거한다.</li>
</ul>
<h2 id="mock-객체-만들기">Mock 객체 만들기</h2>
<ul>
<li><strong>mockito-kotlin</strong>에서는 mock을 생성할 때, 더이상 클래스를 파라미터로 전달할 필요가 없다. 코틀린의 특성처럼 타입을 유추할 수 있다면 생략이 가능하다.</li>
<li>또한, p2처럼 타입을 추론할 수 없다면 아래와 같이 &lt;&gt; 안에 타입을 명시해준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p: Person = mock()</span><br><span class="line"><span class="keyword">val</span> p2 = mock&lt;Person&gt;()</span><br></pre></td></tr></table></figure>
<h2 id="stubbing"># Stubbing</h2>
<ul>
<li><code>Stub</code> : 토막, 꽁초, 남은 부분, 몽당연필이라는 뜻으로 dummy 객체가 마치 실제로 동작하는 것처럼 보이도록 만들어놓은 것을 말한다.</li>
</ul>
<p>위키피디아에서는 test stub을 아래와 같이 정의한다.</p>
<blockquote>
<p>Test stubs provide <strong>canned answers</strong> to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</p>
</blockquote>
<ul>
<li><strong>스텁은 &quot;canned answer&quot;를 호출한 쪽에 제공한다는 것이다.</strong></li>
<li><code>canned answer</code> : 미리 준비된 답변은 일반적인 질문에 대한 미리 정해진 답변이라는 뜻이다. 즉, stub은 실제 코드나 아직 준비되지 못한 코드를 미리 정해진 답변으로 가장하는 매커니즘이다.</li>
</ul>
<h2 id="stub-특징"># Stub 특징</h2>
<ul>
<li>dummy 객체가 실제로 동작하는 것처럼 보이게 만들어 놓은 객체</li>
<li>실제 코드나 아직 준비되지 못한 코드의 행동을 가장하는 행위</li>
<li>호출자를 실제 구현물로부터 격리시키는 목적으로 사용가능</li>
<li><strong>인터페이스 or 기본클래스가 최소한으로 구현된 상태</strong></li>
<li><strong>테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.</strong></li>
</ul>
<h2 id="stub이-주로-사용되는-경우"># Stub이 주로 사용되는 경우</h2>
<ul>
<li>구현이 되지 않은 함수나 라이브러리에서 제공하는 함수를 사용하고자 할때</li>
<li>함수가 반환하는 값을 임의로 생성하고 싶을때</li>
<li>복잡한 논리 흐름을 가지는 경우, 테스트를 단순화하고 싶을때</li>
<li>의존성을 가지는 유닛의 응답을 모사하여 독립적인 시험 수행을 하고자할 때</li>
</ul>
<h2 id="test-stub을-사용하여-얻을-수-있는-이점"># Test Stub을 사용하여 얻을 수 있는 이점</h2>
<ul>
<li>의존하는 것에 대하여 독립적으로 개발/테스트가 가능하다.
<ul>
<li>Interface만 존재하는 것을 Stub으로 개발하고 테스트할 수 있다.</li>
</ul>
</li>
<li>촘촘한 테스트가 가능하다.
<ul>
<li>Stub으로 다양한 응답결과 케이스를 만들어 테스트할 수 있다.</li>
</ul>
</li>
</ul>
<ul>
<li>mockito-kotlin은 when을 쓰지 않고 whenever를 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p : Person = mock()</span><br><span class="line">whenever(p.name).thenReturn(<span class="string">"VIC"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 식처럼 stubbing을 하거나 혹은 람다식을 사용할 수도 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p: Person = mock &#123;</span><br><span class="line">    on &#123; name &#125; doReturn <span class="string">"LEE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assertTrue(<span class="string">"LEE"</span> == p.name) <span class="comment">// 테스트 통과.</span></span><br></pre></td></tr></table></figure>
<h2 id="mockito-다양한-함수">Mockito 다양한 함수</h2>
<p>Mockito에서 자주 사용되거나 유용한 함수들에 대해서 알아볼 것이다.</p>
<p>더 자세한 내용은 <a href="https://aroundck.tistory.com/5851" target="_blank" rel="noopener">돼지왕 왕돼지 놀이터</a> 블로그 글을 참고하면 될 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://beomseok95.tistory.com/296" target="_blank" rel="noopener">Mockito-Kotlin 알아보기</a></li>
<li><a href="https://beomseok95.tistory.com/294" target="_blank" rel="noopener">Test Stub이란 ?</a></li>
<li><a href="https://jdm.kr/blog/222" target="_blank" rel="noopener">mockito 사용법(mockito usage)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/07/Android-Mockito-Advanced/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/06/Android-Mockito/"
                            aria-label=": [Android] Mockito 기본편"
                        >
                            [Android] Mockito 기본편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-06T00:24:52+09:00">
	
		    Mar 06, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="mockito">Mockito</h2>
<p><strong>Mockito</strong>는 객체를 Mocking하는데 사용되는 Java 기반의 라이브러이다. JUnit과 함께 Unit Test를 작성하는데 사용된다. Android도 Unit Test를 작성하는데 공식적으로 Mockito를 사용하도록 권장하고 있다.</p>
<p>이전에 Test와 관련된 글에서도 살펴봤듯이 Android는 <strong>JVM에서 동작하는 Test</strong>와 디바이스 또는 애뮬레이터에서 동작하는 <strong>Instrumentation Test</strong>가 있다.</p>
<blockquote>
<p>mocking : 쉽게 말해서 흉내낸다는 것을 의미한다.</p>
</blockquote>
<p>이번에는 Mockito를 이용해서 Unit Test를 작성하는 방법에 대해서 알아보려고 한다.</p>
<h2 id="gradle">Gradle</h2>
<p>자바를 사용한다면 다음과 같이 한 줄을 <code>app/build.gralde</code> 파일에 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-core:2.24.5'</span></span><br></pre></td></tr></table></figure>
<p>아래의 줄은 안드로이드 Test를 위해 <strong>mockito</strong>를 사용할 때, 필요한 의존성이다. 추가하지 않아도 테스트 코드로 검증할 때 필요하지 않기 때문에 필요시 추가하도록 하자!</p>
<p><strong>아래는 androidTest 파일에서 mockito를 사용할 때, 필요하다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation(<span class="string">"org.mockito:mockito-android:2.24.5"</span>)</span><br></pre></td></tr></table></figure>
<p>하지만 코틀린을 사용한다면, 이렇게 의존성을 추가하여 사용할 경우에 다음과 같은 문제가 발생한다.</p>
<p><code>Mockito cannot mock/spy final class</code>라는 에러가 발생한다.</p>
<p>에러 로그를 확인해보면, Mockito가 final class를 Mock으로 만들려고 했기 때문이다. Kotlin은 기본적으로 final class로 설정되기 때문에 이러한 문제가 발생한 것이다.</p>
<p>해결하기 위해서 <code>open</code> 키워드를 Mock으로 만들려는 클래스 앞에 붙여주면 에러가 발생하지 않는다. 그러나 이런 작업을 매번 해주는 것은 귀찮은 작업이다. 그러나 우리에겐 라이브러리가 있다. 행복한 일이다~ ^__^</p>
<p>아래의 줄을 <code>app/build.gradle</code> 파일에 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-inline:2.13.0'</span></span><br></pre></td></tr></table></figure>
<p>간단히 Person이라는 클래스를 만들어서 Mockito를 사용해 mock 객체를 만들고 Mockito에서 제공하는 함수를 이용해서 person 객체의 반환 값을 지정해주는 예제이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mockito.Mockito.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">personMockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> p: Person = mock(Person::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        assertTrue(p != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        `<span class="keyword">when</span>`(p.name).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">        `<span class="keyword">when</span>`(p.age).thenReturn(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        assertTrue(<span class="string">"VictoryWoo"</span> == p.name)</span><br><span class="line">        assertTrue(<span class="number">27</span> == p.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mock을 통해서 Person 클래스의 객체를 생성한다.</li>
<li>when() 함수를 통해서 p 객체의 name, age의 반환값을 정해준다.</li>
<li>마지막으로 p의 반환값이 기대하는 값과 같은지 비교한다.</li>
<li>성공적으로 2개의 테스트를 통과할 수 있다.</li>
<li>여기서 <code>org.mockito.Mockito.*</code>를 import하였기 때문에 <strong>Mockito</strong>.을 생략해서 쓸 수 있다.</li>
</ul>
<p>이처럼 객체의 반환값을 임의로 정해 Unit Test를 할 수 있는 단순한 기능 외에도 Mockito는 객체에 데이터를 추가하는 다양한 기능 및 검증을 할 수 있는 함수를 많이 제공한다.</p>
<p>이번에는 Mockito와 관련된 기본 개념들에 대해서 살펴봤다.<br>
다음에는 조금 더 심화된 내용과 <strong>Mockito를 Kotlin과 함께 사용할 때, 모호한 구문을 어떻게 해결할 수 있는지에 대해서 알아볼 예정이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://codechacha.com/ko/android-mockito-cannot-mock-final-error/" target="_blank" rel="noopener">Mockito cannot mock/spy final class 에러 해결 방법</a></li>
<li><a href="https://black-jin0427.tistory.com/108" target="_blank" rel="noopener">[Android, Mockito] Unit Test using Mockito</a></li>
<li><a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito</a></li>
<li><a href="https://codechacha.com/ko/android-mockito-for-test/" target="_blank" rel="noopener">Android Mockito로 테스트 코드 작성하기 (kotlin)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/06/Android-Mockito/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/04/Android-Test/"
                            aria-label=": [Android] Test 개념"
                        >
                            [Android] Test 개념
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-04T20:22:26+09:00">
	
		    Mar 04, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Test Code를 짜는 것은 중요하다. 하지만 짜려는 습관이 없다보니 계속해서 Test Code를 짜지 않고 개발하는 습관이 들었다. 최근에 Test Code에 관심을 가지게 되어 공부를 하고 테스트 코드를 짜보려고 한다.</p>
<p>이와 관련된 글은 <code>개념편</code>과 <code>실전편</code>(적용편)으로 나누어 작성할 예정이다.</p>
<h2 id="unit-test">Unit Test</h2>
<p>컴퓨터 프로그래밍에서 <strong>소스 코드</strong>의 특정 모듈이 의도된 대로 정확히 동작하는지 검증하는 절차이다.</p>
<p>단위 테스트를 적용하기 위해서는 러닝 커브도 필요하고, 무엇보다도 직접적인 기능 개발 이외에도 공수가 들어가기 때문에 꺼리는 부분이 있는데, 단위 테스트를 하면 아래와 같은 여러 장점이 있다.</p>
<ul>
<li>잘못된 부분을 빠르게 확인할 수 있다. -&gt; 프로그램의 안정성이 높아진다.</li>
<li>디버깅 시간을 단축시켜준다. -&gt; 개발 시간을 줄여준다.</li>
<li>모듈이 의도대로 동작하고 있음을 확인할 수 있다. -&gt; 리팩토링 시 부담을 줄여준다.</li>
<li>프로그램의 각 부분을 검증한다. -&gt; 유닛 자체의 불확실성을 제거해준다. -&gt; 유닛을 합쳐서 다시 검증하는 통합 테스트에 유용하다.</li>
</ul>
<img src="/img/test_pyramid.jpeg" width="400" height="300">
<h2 id="안드로이드의-테스트-종류">안드로이드의 테스트 종류</h2>
<ol>
<li>Unit Test</li>
</ol>
<ul>
<li>일반적으로 코드의 유닛 단위(메소드, 클래스, 컴포넌트)의 기능을 실행하는 방식</li>
<li>Tool : JUnit, Mockito, PowerMock</li>
</ul>
<ol start="2">
<li>UI Test</li>
</ol>
<ul>
<li>사용자 인터랙션(버튼 클릭, 텍스트 입력 등)을 평가</li>
<li>Tool : Espresso, UIAutomator etc…</li>
</ul>
<img src="/img/test_dir.png" width="600" height="300">
<p><strong>src/androidTest</strong> 파일과 <strong>src/test</strong> 파일이 있는 것을 사진을 통해 확인할 수 있다.</p>
<p>androidTest 파일이 UI Test를 진행하는 파일들이 있는 곳이고, 아래의 test 파일이 Unit Test를 진행하는 파일들이 있는 곳이다.</p>
<p>기본적으로 안드로이드에서는 JUnit을 지원하여 이를 활용해 Unit Test를 진행할 수 있다.</p>
<p>Unit 테스트를 통해서 안드로이드 UI와 관련이 없는 부분을 테스트할 수 있다. 가령, 계산기 클래스를 만들어서 그 안의 메소드 동작을 검증할 수 있다.</p>
<h2 id="junit-amp-mockito">JUnit &amp; Mockito</h2>
<ul>
<li><strong>JUnit</strong> : Java 프로그래밍 언어용으로 설계된 단위 테스트 프레임워크.</li>
<li><strong>Mockito</strong> : 자바에서 단위 테스트를 하기 위해 Mock을 만들어주는 프레임워크.</li>
</ul>
<p><code>모의 객체(Mock Object)</code>란 주로 객체 지향 프로그래밍으로 개발한 프로그램을 테스트할 경우, 테스트를 수행할 모듈과 연결되는 외부의 다른 서비스나 모듈들을 실제 사용하는 모듈을 사용하지 않고 실제의 모듈을 <strong>흉내내는 가짜</strong> 모듈을 작성하여 테스트의 효용성을 높이는 데 사용하는 객체이다.</p>
<p>다른 포스팅에서 Mockito에 관해서 더 알아볼 예정이다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://black-jin0427.tistory.com/107?category=727620" target="_blank" rel="noopener">[Android, Test ] UnitTest, UiTest 기본 예제</a></li>
<li><a href="https://brunch.co.kr/@oemilk/76" target="_blank" rel="noopener">MVP unit test</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/04/Android-Test/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/02/13/Android-Dagger2/"
                            aria-label=": [Android] Dagger 개념"
                        >
                            [Android] Dagger 개념
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-02-13T13:00:21+09:00">
	
		    Feb 13, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="didependency-injection">DI(Dependency Injection)</h2>
<ul>
<li>
<p>구성 요소 간의 의존 관계가 소스 코드 내부가 아닌 외부 설정 파일 등을 통해 정의되게 하는 디자인 패턴.</p>
</li>
<li>
<p>분리시켜 놓음으로써 객체의 생성과 사용을 분리시킬 수 있고, 재사용이 유연해진다.</p>
</li>
<li>
<p>크게 3가지 유형으로 나누어 볼 수 있다.</p>
<ol>
<li><strong>생성자 주입</strong> : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입한다.(가장 권장된다.)</li>
<li><strong>Setter를 통한 주입</strong> : 의존성을 입력 받는 Setter 메소드를 만들고 이를 통해 의존성을 주입한다.</li>
<li><strong>Interface를 통한 주입</strong> : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행 시에 이를 통해 의존성을 주입한다.</li>
</ol>
</li>
<li>
<p><code>주의할 점</code> : 생성자 주입이 권장되는 방법이지만, Activity 같은 경우에는 멤버 인젝션을 해야 한다. 이유는 Activity에서 생성자를 쓰지 않기 때문이다. 물론 할 수도 있지만, onCreate()보다 먼저 실행되어버리기 때문에 절대로 권장하지 않는다.</p>
</li>
<li>
<p><strong>장점</strong></p>
<ul>
<li>클래스 간의 결합도를 낮춰 유지 보수를 용이하게 할 수 있다.</li>
<li>코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스 코드의 수정 없이 사용할 수 있다.</li>
<li>Mock 객체 등을 이용한 단위 테스트의 편의성을 높여준다.</li>
</ul>
</li>
</ul>
<img src="/img/di.png" width="600" height="200">
<p>위의 그림에서 A 클래스가 B 클래스를 의존할 때, B의 Object를 A가 직접 생성하지 않고 외부에서 생성하여 넘겨주면 의존성을 주입했다고 할 수 있다.</p>
<p>결국, DI를 위해서는 객체를 생성하고 넘겨주는 외부의 무언가가 필요하다. 직접 DI를 제공하는 Provide 형태의 클래스를 만들 수 있고, 라이브러리로 넘겨서 대신 처리하도록 구현할 수도 있다.</p>
<p>DI는 이렇게 의존성이 있는 객체의 제어를 외부 Framework로 올리면서 <code>IoC(Inversion of Control)</code> 개념을 구현한다. -&gt; 제 3자에 의해 정의 당하기 때문에 의존 관계가 역전되었다고 이해할 수 있다.</p>
<p>이를 지원하는 라이브러리 중 Dagger2와 koin이 있으며, 저번에는 koin에 대해 알아봤고 이번에는 Dagger2에 대해 알아볼 예정이다.</p>
<img src="/img/di2.png" width="600" height="200">
<p><strong>DI의 필요성?</strong></p>
<ol>
<li>의존성 파라미터를 생성자에 작성하지 않아도 되므로 보일러 플레이트 코드를 많이 줄일 수 있다. 보일러 플레이트 코드를 줄이는 것만으로도 유연한 프로그래밍이 가능.</li>
<li>Interface에 구현체를 쉽게 교체하면서 상황에 따라 적절한 행동을 정의할 수 있다. Mock 객체와 실제 객체를 바꿔가며 테스트할 때, 유용.</li>
</ol>
<h3 id="dagger2의-핵심-키워드">Dagger2의 핵심 키워드</h3>
<ul>
<li>
<p><code>Inject</code><br>
의존성 주입을 요청한다. Inject 어노테이션으로 주입을 요청하면 연결된 <strong>Component가 Module로부터 객체를 생성하여 Inject를 요청한 쪽으로 넘겨준다.</strong></p>
</li>
<li>
<p><code>Component</code><br>
연결된 Module을 이용해 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다.</p>
</li>
</ul>
<p>의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다.</p>
<ul>
<li>
<p><code>Module</code><br>
Component에 연결되어 의존성 객체를 생성하여 제공한다. 생성 후 Scope에 따라 관리도 한다.</p>
</li>
<li>
<p><code>Scope</code><br>
생성된 객체의 Lifecycle 범위를 뜻한다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서 Scope을 보고 객체를 관리한다.</p>
</li>
</ul>
<ul>
<li><code>Subcomponent</code><br>
Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위 계층 Component이다. Sub의 Sub도 가능하다.</li>
</ul>
<p>Subcomponent는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고 없으면 부모로 올라가면서 검색한다.</p>
<p><strong>@Module + @Provides</strong> -&gt; 의존성 제공<br>
<strong>@Inject</strong> -&gt; 의존성 요청<br>
<strong>@Component</strong> -&gt; Module과 Inject 사이의 브릿지 역할 수행<br>
<strong>@Qualifier</strong> -&gt; 동이한 유형이지만, 다른 인스턴스를 가진 객체를 구별하는 데 사용된다.</p>
<p><strong>Flow</strong><br>
@Inject -&gt; Subcomponent -&gt; Modulce -&gt; Scope에 있으면 return. 없으면 생성.<br>
Subcomponent Module에서 맞는 타입을 못찾으면 상위 Component -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성.</p>
<h3 id="그림으로-한번-더-이해하기">그림으로 한번 더 이해하기</h3>
<img src="/img/dagger2_flow.png" width="600" height="200">
<ul>
<li>Module, Provides -&gt; 공급자의 역할.
<ul>
<li><strong>Module</strong> : 의존성을 제공하는 @Provides 메소드를 가진 클래스에 이용한다. 모든 @Provides 메소드는 @Module 클래스 안에 속해야 한다.</li>
<li><strong>Provides</strong> : 어떻게 의존성을 구성하고 제공하는지 정의하는 메소드에 사용한다.</li>
</ul>
</li>
<li>Inject -&gt; 소비자.</li>
<li>Component -&gt; 위의 둘을 연결해주는 역할을 한다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/02/13/Android-Dagger2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/02/11/Android-Clean-Architecture2/"
                            aria-label=": [Android] Clean Architecture 2."
                        >
                            [Android] Clean Architecture 2.
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-02-11T18:16:23+09:00">
	
		    Feb 11, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>지난 포스팅에서는 간략하게 Clean Architecture에 대해 알아보고, 이를 적용할 시 어떠한 장점을 갖는지만 정리를 해봤다.</p>
<p>이번에는 4개의 계층으로 나뉘어진 아키텍처에서 각각의 계층이 어떠한 역할을 하는지 알아보려고 한다.</p>
<h2 id="clean-architecture">Clean Architecture</h2>
<p>좋은 코드란? 가독성이 좋은 코드? 테스트 커버리지가 높은 코드?</p>
<p>여러가지 기준이 있겠지만, 그 중 하나인 유지보수하기 쉬운 코드(변화에 잘 대응할 수 있는 코드)또한 좋은 코드의 기준 중 하나일 것이다.</p>
<p>유지보수하기 쉬운 코드는 변화에 따른 코드 변경이 적다는 것일 가능성이 높다. 그러기 위해서는 코드가 잘 분리되어 있어야 한다. 그 방법 중 하나로 Clean Architecture를 예로 들 수 있고, 우리가 알아봐야 할 개념이다.</p>
<img src="/img/ca.jpeg" width="600" height="200">
<ul>
<li>위의 그림은 Robert Martin이 소개한 Clean Architecture 다이어그램이다. 양파 모양의 4개의 Layer가 존재한다.</li>
<li>가장 바깥쪽의 Frameworks &amp; Drivers가 사용자와 접점에 있는 Presentation이다.</li>
<li>가장 안쪽의 Entities가 사용자가 실제로 생각하는 개념의 단위이다.</li>
<li>Clean Architecture는 실제로 서버쪽 내용이라고 한다. 하지만, 안드로이드에서도 이 개념을 적용시켜 UI를 독립시키고 데이터베이스를 분리시키고 외부적인 설정에 독립적인 구조를 적용하여 프레임워크에 의존적이지 않은 독립적인 코드를 짤 수 있다.</li>
</ul>
<img src="/img/ca2.png" width="600" height="200">
<p>android에서 Clean Architecture를 적용할 때, 4개의 레이어로 분리하면 위와 같은 사진으로 적용된다.</p>
<h2 id="4-layer">4 Layer</h2>
<img src="/img/layer.png" width="600" height="200">
<p>안드로이드 계층을 4개로 나눌 수 있다.</p>
<ul>
<li>사용자에게 보여지는 로직과 관련된 Presentation Layer</li>
<li>Network를 포함한 데이터를 가져오는 Data Layer</li>
<li>사용자의 use case로 분리되는 Domain Layer</li>
<li>사용자의 개념을 정의하는 Entity Layer</li>
</ul>
<p>위의 4개의 <code>레이어 간의 의존성은 안쪽으로만 발생해야 한다.</code> 가장 하단부의 레이어일수록 의존성이 낮아야 한다.</p>
<p><strong>Presentation Layer</strong>는 <strong>Data Layer</strong>를 알지만, Data Layer는 Presentation Layer를 몰라야 한다. 이 덕분에 맨 아래 Entity Layer는 순수한 Java 또는 Kotlin 모듈이 될 수 있고 안드로이드에 의존성을 가질 수도 있고 안드로이드 의존성을 가지지 않을 수도 있다. (즉, 의존성이 적기 때문에 다른 플랫폼에서도 사용이 가능하다.)</p>
<p>이러한 분리를 통해서 어떤 데이터베이스에 저장될지, 어떤 뷰에 보일지 고민하지 않고 Entity를 작성할 수 있고, 이에 대한 유스 케이스로 Domain Layer를 작성할 수 있다. 또한, 트랜잭션을 가져오는 것은 Data에서 어떻게 보여줄 것인지를 Presentation에서 정할 수 있다.</p>
<h3 id="각-layer별-설명">각 Layer별 설명.</h3>
<p><strong>1. Entity Layer</strong></p>
<ul>
<li>Entity는 순수한 Java 또는 Kotlin 모듈이므로 안드로이드와 의존성이 없다. 안드로이드에서만 사용하는 것이 아니라고 생각하고 작성해야 한다.</li>
<li>다른 플랫폼의 같은 서비스를 만든다면 Android, iOS, Server 모두 같은 이름과 타입을 사용하는 동일한 형태여야 한다.</li>
<li>따라서 넘기는 데이터를 Parcelable 등으로 정의하는 등의 행위는 삼가해야 한다.</li>
<li>정리하자면, 사용자가 생각하는 형태대로 도메인(비즈니스 로직)에서 파생되는 개념을 표현한다.</li>
</ul>
<p><strong>2. Domain Layer</strong></p>
<ul>
<li><code>Domain Layer</code>도 순수한 Java나 Kotlin 모듈이다.</li>
<li>실제로 사용자가 하는 일련의 행동들, 즉, <strong>유스 케이스</strong>를 적용하는 것인데, 이 역시 안드로이드에 의존할 필요가 없기 때문이다.</li>
<li>유스 케이스를 구성할 때는 데이터베이스가 무엇인지 뷰가 어떤 것인지 고민하지 않고, 도메인에서 정의한 적당한 레포지토리를 이용하여 구축하므로 코드가 사고의 흐름처럼 구성될 수 있다.</li>
</ul>
<p><strong>3. Data Layer</strong></p>
<ul>
<li><code>Data Layer</code>에서 하는 한 가지 일을 고르자면, Domain Layer를 알고 있으므로 Domain Layer에 정의된 Repository를 실제로 구현하는 것이다.</li>
<li>또한 여기에서는 Data Source에 의존성이 생기므로, 안드로이드 의존성이 생길 수 있다.</li>
</ul>
<p><strong>4. Presentation Layer</strong></p>
<ul>
<li>마지막 최상위 레이어인 Presentation Layer는 UI 레벨에서의 처리이고 Android 의존성이 높다. MVP 구조를 사용한다면 presenter가 생성되는 시점에 유스 케이스를 주입받을 수 있는 구조로 작성한다.</li>
<li>이처럼 작성하게 될 시에 테스트하기에 좀 더 편리하다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://beomseok95.tistory.com/213" target="_blank" rel="noopener">범석의 안드로이드 메모장</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/02/11/Android-Clean-Architecture2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/02/11/Android-Clean-Architecture/"
                            aria-label=": [Android] Clean Architecture Intro."
                        >
                            [Android] Clean Architecture Intro.
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-02-11T16:56:24+09:00">
	
		    Feb 11, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>Clean Architecture</code>라는 말은 안드로이드에만 국한되는 것이 아니다. 소프트웨어 개발을 하고 있다면 이에 대해서 관심을 가져봤을 법하다고 생각한다.</p>
<p>필자는 지금까지 <code>Clean Architecture</code>를 들어봤지만, 실제로 무엇인지 제대로 살펴본 적이 없다. 그래서 이번에 간단한 프로젝트를 하게 되었는데 <code>Clean Architecture</code>를 왜 사용하는지와 사용했을 때의 장점을 알아보려고 한다.</p>
<p>아직, 제대로 된 공부를 하지 않았기에 '어떤 장점이 있어서 써야된다.'라고 말하지 못할 것 같다.</p>
<p>머릿속에 정리하고 개념을 이해한 뒤, 실제 적용하면서 느끼는 점이 있지 않을까 하면서 공부를 시작한다.</p>
<h2 id="clean-architecture">Clean Architecture</h2>
<img src="/img/the-clean-architecture.png" width="600" height="200">
<p>클린 아키텍처를 검색했을 때, 만날 수 있는 그림이다. 이 그림이 의미하는 바를 알아보자.</p>
<p>Robert C Martin 블로그의 글에서 대부분의 아키텍처는 세부적인 차이는 있어도 공통적인 목표는 계층을 분리하여 관심사의 분리를 하는 것이라고 말한다. 이런 아키텍처가 동작하기 위해서는 <strong>의존성 규칙</strong>을 지켜야 한다고 한다.</p>
<p>의존성 규칙은 모든 소스코드의 의존성은 반드시 외부에서 내부로, 고수준 정책을 향해야 한다고 말한다. 즉, 업무의 업무 로직을 담당하는 코드들이 DB 또는 Web 같이 구체적인 세부 사항에 의존하지 않아야 한다. 이를 통해 업무 로직(고수준 정책)은 세부 사항들(저수준 정책)의 변경에 영향을 받지 않도록 할 수 있다.</p>
<p>이번에는 <a href="https://fernandocejas.com/2018/05/07/architecting-android-reloaded/" target="_blank" rel="noopener">Fernando</a> 분이 설명하신 글을 살펴보자.</p>
<img src="/img/clean_architecture_reloaded_main.png" width="600" height="200">
<p>이와 같은 구조는 다음과 같은 측면에서 도움을 준다.</p>
<ul>
<li>Problem Solving</li>
<li>Scalability(확장성)</li>
<li>Modularization(모듈화)</li>
<li>Testability(테스트 가능한 코드)</li>
<li>Independence of frameworks, UI and Databases.</li>
</ul>
<p>클린 아키텍처는 크게 3개의 architecture로 나눌 수 있다.</p>
<img src="/img/clean_architecture_reloaded_layers2.png" width="600" height="200">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://codechacha.com/ko/android-clean-architecture/" target="_blank" rel="noopener">안드로이드 - Clean Architecture 연습하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/02/11/Android-Clean-Architecture/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/09/15/RxJava-Chap08/"
                            aria-label=": [RxJava] Chap08. 테스팅과 Flowable"
                        >
                            [RxJava] Chap08. 테스팅과 Flowable
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-15T20:51:07+09:00">
	
		    Sep 15, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="testobserver-클래스">TestObserver 클래스</h2>
<ul>
<li>RxJava에서 제공하는 TestObserver 클래스다.</li>
<li>JUnit 기반의 테스트 코드와 다른 점은 test()와 assertResult() 함수다.</li>
<li>코드는 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnitBasic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetShapeObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2-R"</span>, <span class="string">"3-T"</span>&#125;;</span><br><span class="line">        <span class="comment">// source : 실제 결과.</span></span><br><span class="line">        Observable&lt;String&gt; source = Observable.fromArray(data)</span><br><span class="line">                .map(Shape::getShape);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expected : 예상 결과.</span></span><br><span class="line">        String[] expected = &#123;Shape.BALL, Shape.RECTANGLE, Shape.TRIANGLE&#125;;</span><br><span class="line">        source.test().assertResult(expected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>assertResult()</strong> : 예상된 결과와 실제 결과를 비교하는 메소드. JUnit의 assertEquals() 메소드와 같다.</li>
<li><strong>assertFailure()</strong> : Observable에서 기대했던 에러가 발생하는지 확인하는 코드다. 만약, 기대했던 에러가 발생하지 않으면 테스트 코드 실행은 실패한다.
<ul>
<li>총 3개의 값을 넣어 앞 두 번째 값까지는 정상적으로 발행하고 마지막 값에서 기대했던 예외가 발생하는지 확인한다.</li>
<li>세번째 데이터는 %를 붙여서 Integer.parseInt()에서 변환이 안되기 때문에 NumberFormatException이 발생하고 onError 이벤트로 종료된다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertFailureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"%300"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(data)</span><br><span class="line">                .map(Integer::parseInt);</span><br><span class="line"></span><br><span class="line">        source.test().assertFailure(NumberFormatException.class, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>assertFailureAndMessage()</strong> : 기대했던 에러 발생시 에러 메시지까지 확인할 수 있다.
<ul>
<li>에러 메시지를 확인하기 위한 message 인자가 추가되었다.</li>
<li>에러가 발생했을 때 메시지를 확인하기 위해 아래와 같은 구문을 추가한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertFailureAndMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] data = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"%300"</span>&#125;;</span><br><span class="line">    Observable&lt;Integer&gt; source = Observable.fromArray(data)</span><br><span class="line">            .map(Integer::parseInt);</span><br><span class="line"></span><br><span class="line">    source.test().assertFailureAndMessage(NumberFormatException.class,</span><br><span class="line">            <span class="string">"For input string : \"%300\""</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>awaitDone()</strong> : interval() 함수처럼 비동기로 동작하는 Observable 코드를 테스트할 수 있다.</li>
<li><strong>assertComplete()</strong> : Observable을 정상적으로 완료했는지(onComplete 이벤트) 확인한다.</li>
<li></li>
</ul>
<h2 id="비동기-코드-테스트">비동기 코드 테스트</h2>
<ul>
<li>RxJava는 다양한 상황에서 비동기 코드를 직관적으로 작성할 수 있다. 하지만, 비동기 코드를 테스트하는 것은 어려우므로 RxJava는 비동기로 동작하는 코드를 테스트할 방법을 제공한다.</li>
<li>Observable.interval() 메소드는 main 스레드가 아닌 계산 스케줄러에서 실행되기 때문에 비동기 코드를 테스트할 필요가 있다. <code>awaitDone()</code> 함수를 사용하면 된다.</li>
<li>awaitDone() 함수는 test() 함수가 실행되는 스레드에서 onComplete() 함수를 호출할 때까지 기다려준다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAsync</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(<span class="number">5</span>)</span><br><span class="line">                .map(Long::intValue);</span><br><span class="line"></span><br><span class="line">        source.doOnNext(Log::d)</span><br><span class="line">                .test()</span><br><span class="line">                .awaitDone(<span class="number">1L</span>, TimeUnit.SECONDS)</span><br><span class="line">                .assertResult(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTTP 서버와 통신하는 코드를 테스트하는 것은 소스 코드만 봐도 충분히 이해할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String url = <span class="string">"http://api.github.com/users/yudong80"</span>;</span><br><span class="line">    Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .map(OkHttpHelper::get)</span><br><span class="line">            .doOnNext(Log::d) <span class="comment">// json 을 로그로 찍는다.</span></span><br><span class="line">            .map(json -&gt; GsonHelper.parseValue(json, <span class="string">"name"</span>))</span><br><span class="line">            .observeOn(Schedulers.newThread());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// json 중에서 name 만 뽑은 것을 로그로 찍는다.</span></span><br><span class="line">    String expected = <span class="string">"Dong Hwan Yu"</span>;</span><br><span class="line">    source.doOnNext(Log::i)</span><br><span class="line">            .test()</span><br><span class="line">            .awaitDone(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">            .assertResult(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 호출은 IO 스케줄러에서 실행되었고 JSON 파싱 결과는 뉴 스레드 스케줄러에서 출력한다. UI 프로그래밍을 할 때는 뉴 스레드 스케줄러 대신 UI 스레드로 변경하면 된다.</li>
</ul>
<h2 id="flowable-클래스">Flowable 클래스</h2>
<ul>
<li>배압 이슈를 위해 별도로 분리한 클래스다.</li>
<li>Flowable 클래스를 도입한 이유는 Observable 클래스의 성능을 향상시키기 위해서다.</li>
<li>기존의 Observable 클래스(배압 관련 함수들을 포함했었다.)는 배압에 관한 처리가 불필요한 경우에는 초기 로딩 때문에 약간의 오버헤드가 있었지만, RxJava 2.X의 Observable 클래스에는 배압으로 인한 성능 오버헤드가 사라졌다.</li>
<li>Flowable -&gt; Observable로 변환하는 것뿐만 아니라 반대도 어렵지 않다.</li>
</ul>
<h3 id="observabler과-flowable의-선택-기준">Observabler과 Flowable의 선택 기준</h3>
<p><strong>1. Observable을 사용해야 할 때</strong></p>
<ul>
<li>최대 1000개 미만의 데이터 흐름.</li>
<li>예를 들어, 응용 프로그램에서 OOM이 발생할 확률이 거의 없는 경우다</li>
<li>마우스 이벤트나 터치 이벤트를 다루는 GUI 프로그래밍. 이 경우에는 배압의 이슈가 거의 발생하지 않는다. Observable로는 초당 1000회 이하의 이벤트를 다루는데 이때 sample()이나 debounce() 같은 흐름 제어 함수를 활용하면 된다.</li>
<li>데이터 흐름이 본질적으로 동기 방식이지만, 프로젝트에서 사용하는 플랫폼이 자바 Stream API나 그에 준하는 기능을 제공하지 않을 때, Observable은 보통 Flowable과 비교했을 때 성능 오버헤드가 낮다.</li>
</ul>
<p><strong>2. Flowable을 사용해야 할 때</strong></p>
<ul>
<li>특정 방식으로 생성된 1000개 이상의 데이터를 처리하는 경우. 이때 메소드 체인에서 데이터 소스에 데이터 개수 제한을 요청해야 한다.</li>
<li>디스크에서 파일을 읽어 들일 경우, 본질적으로 블로킹 I/O 방식을 활용하고 내가 원하는 만큼 가져오는 방식(pull-based)으로 처리해야 하기 때문이다. 예를 들면, 특정 단위로 잘라 몇 행씩 가져오도록 제어할 수 있다.</li>
<li>JDBC를 활용해 데이터베이스의 쿼리 결과를 가져오는 경우, 블로킹 방식을 이용하므로 ResultSet.next()를 호출하는 방식으로 쿼리의 결과를 읽어오도록 제어할 수 있다.</li>
<li>네트워크 I/O를 실행하는 경우, 네트워크나 프로토콜을 통해 서버에서 가져오길 원하는 만큼의 데이터양을 요청할 수 있을 때이다.</li>
<li>다수의 블로킹 방식을 사용하거나 가져오는 방식(pull-based)의 데이터 소스가 미래에는 논 블로킹 방식의 리액티브 API나 드라이버를 제공할 수도 있는 경우다.</li>
</ul>
<p>디스크에서 파일 읽기, JDBC를 활용한 데이터베이스 쿼리하기, 네트워크 I/O 등은 차가운 Observable(구독자가 구독하면 데이터의 처음부터 모두 발행하는 Observable)에 해당한다. 이는 결과 데이터를 처리할 수 있는만큼 조금씩 가져오는 것이 아니라 한 번에 모두 가져온다. 따라서 이 경우에는 반드시 Flowable을 활용해야 하는 것은 아니다.</p>
<p>업스트림에서 발생하는 데이터의 속도와 다운스트림에서 처리하는 속도의 차이가 작다면 Observable을 활용해도 된다. 즉, 데이터 발행과 처리 속도가 차이나더라도 먼저 <strong>sample(), throttle(), debounce()</strong> 같은 흐름 제어 함수를 활용해 해결하는 것이 좋다. 이러한 함수로도 해결하기 어려울 때는 Flowable 클래스로 전환하면 된다.</p>
<h3 id="flowable을-활용한-배압-이슈-대응">Flowable을 활용한 배압 이슈 대응</h3>
<ul>
<li>onBackpressureBuffer() : 배압 이슈가 발생했을 때 별도의 버퍼에 저장한다. Flowable 클래스는 기본적으로 128개의 버퍼가 있다.</li>
<li>onBackpressureDrop() : 배압 이슈가 발생했을 때 해당 데이터를 무시한다.</li>
<li>onBackpressureLatest() : 처리할 수 없어서 쌓이는 데이터를 무시하면서 최신의 데이터만 유지한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowableSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        PublishSubject&lt;Integer&gt; subject = PublishSubject.create();</span><br><span class="line">        subject.observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>); <span class="comment">// 100ms 후에 데이터 처리.</span></span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, err -&gt; Log.e(err.toString()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 뜨거운 Observable 로 50,000,000개의 데이터를 연속으로 발행함.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;</span><br><span class="line">            subject.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subject.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PublishSubject 객체를 생성한 후, 처리 결과는 계산 스케줄러로 전달한다. subscribe() 함수를 호출한 후 Subject 객체가 발행한 데이터는 100ms 후에 로그를 찍는다.</p>
<p>한편 PublishSubject 객체는 뜨거운 Observable이다. 데이터를 발행하는 속도와 데이터를 처리하는 속도의 차이가 발생했을 때 어떠한 보호 장치도 없다. 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-1 | 604 | value = 0</span><br><span class="line">RxComputationThreadPool-1 | 742 | value = 1</span><br><span class="line">RxComputationThreadPool-1 | 3172 | value = 2</span><br><span class="line">RxComputationThreadPool-1 | 5158 | value = 3</span><br><span class="line">RxComputationThreadPool-1 | 7426 | value = 4</span><br><span class="line">RxComputationThreadPool-1 | 7528 | value = 5</span><br><span class="line">RxComputationThreadPool-1 | 8017 | value = 6</span><br><span class="line">RxComputationThreadPool-1 | 8570 | value = 7</span><br><span class="line">RxComputationThreadPool-1 | 9180 | value = 8</span><br><span class="line">RxComputationThreadPool-1 | 15089 | value = 9</span><br><span class="line">RxComputationThreadPool-1 | 15675 | value = 10</span><br></pre></td></tr></table></figure>
<p>처리 결과를 보면 100ms 간격보다 상당히 느리게 데이터를 처리한다. 그리고 데이터는 반복문을 통해서 PublishSubject 객체에서 매우 빠르게 발행되는데 데이터는 겨우 10개만 처리되었다. 만약, 발행하는 데이터의 개수가 훨씬 많아지면 JVM은 곧 OOM 예외를 발생하고 실행을 중단할 것이다. <strong>이런 배압 이슈가 발생했을 때 Flowable 클래스를 활용한다.</strong></p>
<p>위와 같은 배압 이슈에 대응하기 위해서 첫 번째 방법은 사용해보자.</p>
<ul>
<li>버퍼 만들기</li>
<li>onBackpressureBuffer() 함수에는 다음과 같은 오버로딩이 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본값(128)의 버퍼 개수가 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// delayError 여부를 지정할 수 있다. </span></span></span><br><span class="line"><span class="function"><span class="comment">// true : 예외가 발생했을 때 버퍼에 쌓인 데이터를 모두 처리할 때가지 예외를 던지지 않는다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// false : 예외가 발생했을 때 바로 다운스트림에 예외를 던진다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 기본값은 false다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">boolean</span> delayError)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// capacity 인자로 버퍼의 개수를 지정한다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// onOverflow 인자에 버퍼가 넘쳤을 때 실행할 동작을 지정한다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">int</span> capacity, Action onOverflow)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 버퍼가 가득찼을 때 추가로 실행하는 전략을 지정할 수 있다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">long</span> capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy)</span></span></span><br></pre></td></tr></table></figure>
<p>지정할 수 있는 전략은 아래와 같다.</p>
<ul>
<li><code>ERROR</code> : MissingBackpressureException 예외를 던지고 데이터 흐름을 중단한다.</li>
<li><code>DROP_LATEST</code> : 버퍼에 쌓여있는 최근 값을 제거한다.</li>
<li><code>DROP_OLDEST</code> : 버퍼에 쌓여있는 가장 오래된 값을 제거한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureBufferSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureBuffer(<span class="number">128</span>, () -&gt; &#123;</span><br><span class="line">                &#125;, BackpressureOverflowStrategy.DROP_OLDEST)</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flowable.range() 함수를 활용해 동일한 개수의 데이터를 발행한다. 그리고 128개의 버퍼를 생성한 후 버퍼가 넘치면 버퍼의 가장 오래된 데이터를 버리도록 지정한다. 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-1 | 356 | value = 1</span><br><span class="line">RxComputationThreadPool-1 | 459 | value = 2</span><br><span class="line">RxComputationThreadPool-1 | 561 | value = 3</span><br><span class="line">RxComputationThreadPool-1 | 662 | value = 4</span><br><span class="line">RxComputationThreadPool-1 | 766 | value = 5</span><br><span class="line">RxComputationThreadPool-1 | 869 | value = 6</span><br><span class="line">RxComputationThreadPool-1 | 972 | value = 7</span><br><span class="line">RxComputationThreadPool-1 | 1072 | value = 8</span><br><span class="line">RxComputationThreadPool-1 | 1176 | value = 9</span><br><span class="line">RxComputationThreadPool-1 | 1276 | value = 10</span><br><span class="line">RxComputationThreadPool-1 | 1380 | value = 11</span><br><span class="line">RxComputationThreadPool-1 | 1485 | value = 12</span><br><span class="line">RxComputationThreadPool-1 | 1586 | value = 13</span><br><span class="line">RxComputationThreadPool-1 | 1688 | value = 14</span><br><span class="line">RxComputationThreadPool-1 | 1793 | value = 15</span><br><span class="line">RxComputationThreadPool-1 | 1895 | value = 16</span><br></pre></td></tr></table></figure>
<p>이처럼 버퍼를 활용해 데이터를 훨씬 빠르게 다운스트림으로 발행하는 것을 알 수 있다. 거의 10배의 속도이다. 발행하는 속도도 이전보다 빨라졌고 더 많은 데이터를 발행한다. 데이터의 발행 속도가 워낙 빠르기 때문에 128개의 버퍼로는 모두 대응하기 어렵다.</p>
<p>배압 이슈에 대응하는 두 번째 방법은 <code>onBackpressureDrop()</code> 함수를 활용하는 것이다. onBackpressureBuffer() 함수가 버퍼를 만들어 쌓아 두었다가 처리하는 방식이라면, onBackpressureDrop() 함수는 버퍼가 가득 찼을 때, 이후 데이터를 그냥 무시한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureDropSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureDrop()</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">... 생략</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13004</span> | value = <span class="number">124</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13105</span> | value = <span class="number">125</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13207</span> | value = <span class="number">126</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13309</span> | value = <span class="number">127</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13411</span> | value = <span class="number">128</span></span><br></pre></td></tr></table></figure>
<p>버퍼에 128개의 데이터가 가득 찼을 때, 데이터를 계산 스케줄러에서 출력하기도 전에 예제가 끝난다. 따라서 계산 스케줄러에서 데이터를 다운스트림으로 발행할 수 있도록 충분한 시간(여기서는 20초)을 기다려줘야 한다. UI 프로그래밍(안드로이드)에서는 이와 같은 기다림이 필요하지 않다.</p>
<p>기본 버퍼 개수만큼만 버퍼에 저장하고 나머지는 모두 무시했기 때문에 128개의 데이터만 출력하고 종료한다.</p>
<p>마지막 방법은 <code>onBackpressureLatest()</code> 함수를 활용하는 것이다. 위의 두 함수의 기능을 섞을 것으로 데이터가 많이 쌓이면 무시하면서 최신의 데이터 즉, 마지막 데이터를 유지하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureLatest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureLatest()</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13416</span> | value = <span class="number">127</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13518</span> | value = <span class="number">128</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13622</span> | value = <span class="number">50000000</span></span><br></pre></td></tr></table></figure>
<p>함수만 교체해주었고, 결과는 위와 같다. 버퍼가 꽉찼을 때, 데이터를 무시하면서 마지막 데이터를 다운 스트림으로 발행하는 것을 확인할 수 있다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/09/15/RxJava-Chap08/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/09/14/RxJava-Chap07-3/"
                            aria-label=": [RxJava] Chap07. 디버깅 - 흐름 제어"
                        >
                            [RxJava] Chap07. 디버깅 - 흐름 제어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-14T23:23:20+09:00">
	
		    Sep 14, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="흐름-제어">흐름 제어</h1>
<ul>
<li>흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다.</li>
<li>RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.</li>
</ul>
<h2 id="sample">sample()</h2>
<ul>
<li>특정한 시간 동안 가장 최근에 발행한 데이터만 걸러준다. <strong>즉, 최근에 발행된 데이터만 넘겨주고 나머지는 무시한다.</strong></li>
<li>해당 시간에는 아무리 많은 데이터가 들어와도 해당 구간의 마지막 데이터만 발행하고 나머지는 무시한다.</li>
</ul>
<img src="/img/sample.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit, <span class="keyword">boolean</span> emitLast)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>emitLast</code> 인자는 sample() 함수의 데이터 발행이 완료되지 않고 마지막에 데이터가 남아 있을 때, 해당 데이터를 발행할 것인지 결정한다. true로 설정하면 마지막 데이터를 발행한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sampleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"7"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 시간 측정용.</span></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 4개의 데이터는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">4</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 데이터는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2개의 Observable 을 결합하고 300ms 로 샘플링.</span></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, lateSource)</span><br><span class="line">                .sample(<span class="number">300L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">552</span> | value = <span class="number">7</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">849</span> | value = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>먼저, 100ms 간격으로 data 배열에 있는 데이터 4개를 발행한다. 그리고 마지막 데이터인 6을 300ms 후에 발행한다.</li>
<li>또한 내가 원하는 특정 시간 후에 발행하기 위해 concat() 함수를 호출해 2개의 데이터 흐름(Observable)을 결합했다. 이렇게 전체 데이터 흐름을 세부 데이터 흐름으로 나누면 코드의 가독성이 좋아진다.</li>
<li>sample() 함수는 300ms 간격으로 수행한다. 매 300ms 마다 가장 최근에 들어온 값만 최종적으로 발행한다.</li>
<li>처음에 데이터를 발행하기 위해 약간의 지연 시간이 있어서(100ms+a) 다이어그램을 보면 시작할 때 약간의 간격이 있음을 볼 수 있다. 다음 데이터 발행이 3XXms이기 때문에 300ms일 때는 가장 최근 데이터가 이전에 발행했던 7이 되는 것이다.(처음 기준!)</li>
<li>마지막 인자를 true로 설정하면 마지막 데이터를 발행한다. 기본값이 false이다.</li>
</ul>
<h2 id="buffer">buffer()</h2>
<ul>
<li>일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해준다.</li>
<li>따라서 넘치는 데이터 흐름을 제어할 필요가 있을 때 활용한다. 컴퓨터의 버퍼 같은 기능을 한다.</li>
</ul>
<img src="/img/buffer.png" width="500" height="200">
<ul>
<li>처음에 빨,노,초 원을 발행하면 그것을 모아서 List 객체에 전달해준다. 그 다음 다시 하늘,파,보 원이 모이면 그것을 모아서 한 번에 발행해준다. 매우 단순한 로직이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>기본적으로 스케줄러 없이 현재 스레드에서 동작하며 입력되는 값을 count에 저장된 수만큼 모아서 List<t>에 한꺼번에 발행한다.</t></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lataSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Observable&lt;List&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lataSource)</span><br><span class="line">                .buffer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>buffer(3)는 데이터를 3개씩 모았다가 List<string>에 채운 후 값을 한꺼번에 발행해준다. 그래서 위의 결과를 보면 확인 가능하다.</string></li>
<li>buffer() 함수에는 모으거나(count) 무시할(skip) 데이터 개수를 입력할 수 있다.</li>
<li>skip 변수는 count보다 값이 커야 한다. count가 2이고 skip이 3이면 2개 데이터를 모으고 3번째 데이터 1개는 스킵한다.</li>
<li>코드는 위와 같으면 <code>buffer(2,3)</code>으로 호출하면 아래와 같은 결과를 얻을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Observable에서 onNext 이벤트가 발생하면 내부 데이터는 3개가 아니라 2개 값을 모아 바로 List<string>에 채운 후 구독자에게 데이터를 발행한다.</string></li>
</ul>
<h2 id="throttlefirst-throttlelast">throttleFirst(), throttleLast()</h2>
<ul>
<li>throttle는 <strong>조절판</strong>이라는 뜻이다. 그것에 맞게 throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행한다. throttleLast() 함수는 주어진 조건에서 가장 마지막에 입력된 값을 발행한다.</li>
<li>throttleFirst()와 throttleLast()는 정반대의 의미가 아니다. throttleFirst() 함수는 어떤 데이터가 입력된 후 일정 시간 동안 다른 데이터가 발행되지 못하도록 방지하지만, throttleLast() 함수는 sample() 함수처럼 고정된 시간 간격안에서 마지막 데이터만 발행한다.</li>
<li><strong>throttleFirst()</strong> : sample() 함수와 비슷하지만 다르다. sample() 함수가 주어진 시간 동안 입력된 마지막 값을 발행한다면 <code>throttleFirst()</code> 함수는 <strong>어떤 데이터를 발행하면 지정된 시간 동안 다른 데이터를 발행하지 않도록 막는다.</strong></li>
<li><strong>throttleLast()</strong> : sample() 함수와 기본 개념은 동일하다. 주어진 시간 동안 입력된 값 중 마지막 값을 발행한다.</li>
</ul>
<img src="/img/throttleFirst.png" width="500" height="200">
<ul>
<li>함수 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 실행한다. 즉, 비동기로 동작하도록 설계된 함수다.</li>
<li>windowDuration는 시간 간격을 지정하며 unit은 시간의 단위다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">throttleFirst</span><span class="params">(<span class="keyword">long</span> windowDuration, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">throttleFirstSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 1개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.just(data[<span class="number">0</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 다음 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middlerSource = Observable.just(data[<span class="number">1</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 4개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">2</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a)</span><br><span class="line">                .doOnNext(Log::dt); <span class="comment">// 디버깅 정보 출력.</span></span><br><span class="line"></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, middlerSource, lateSource)</span><br><span class="line">                .throttleFirst(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">371</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">673</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">779</span> | debug = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">876</span> | debug = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | debug = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">1077</span> | debug = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>처음 100ms가 지난 후에 1을 발행한 후, 300ms 동안 기다린 다음 2를 발행한다. 그리고 100ms 간격으로 나머지 값들을 발행한다. 마지막으로 throttleFirst() 함수를 호출해 200ms 간격으로 타임 윈도에 맨 먼저 입력된 값을 발행한다.</li>
<li>위에서는 1,2,4,6이 다운 스트림으로 발행된다.</li>
</ul>
<h2 id="window">window()</h2>
<ul>
<li>groupBy() 함수와 개념적으로 비슷하다.</li>
<li>throttleFirst()나 sample() 함수처럼 내가 처리할 수 있는 일부의 값들만 받아들일 수 있다. 흐름 제어 기능에 groupBy() 함수와 비슷한 별도의 Observable 분리 기능을 모두 갖추었다고 생각하면 된다.</li>
</ul>
<img src="/img/window.png" width="500" height="200">
<ul>
<li>count를 인자로 받는다. 예를 들어, 3을 인자로 받으면 앞으로 데이터 3개가 발행될 때마다 새로운 Observable을 생성하겠다는 뜻이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>현재 스레드를 그대로 활용한다. 왜 그런지 window() 함수의 다른 변형을 비교하면 알 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="keyword">long</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(</span><br><span class="line">    <span class="keyword">long</span> timespan, <span class="keyword">long</span> timeskip, TimeUnit unit</span><br><span class="line">)&#123; </span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count만을 인자로 갖는 window() 함수는 입력된 값을 그대로 발행하기 때문에 비동기 작업이라고 보기 어렵다.</li>
<li>위의 함수 원형에는 timespan이라는 시간 동안 입력된 값 중에서 일부를 무시하는 기능을 포함한다.</li>
<li>어떤 필터링 작업을 해줘야 하기 때문에 계산 스케줄러를 활용하게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">windowSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 데이터 3개씩 모아서 새로운 Observable 생성.</span></span><br><span class="line">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lateSource)</span><br><span class="line">                .window(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(observable -&gt; &#123;</span><br><span class="line">            Log.dt(<span class="string">"New Observable Started!!"</span>);</span><br><span class="line">            observable.subscribe(Log::it);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">        CommonUtils.exampleComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">365</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">366</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">461</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">560</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">963</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1062</span> | value = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>window() 함수의 인자로 3을 넣었다. 처음에 Observable을 생성하고 3개의 데이터를 전달받으면 새로운 Observable을 다시 생성하여 값을 발행한다.</li>
<li>1 값을 발행할 때와 4 값을 발행할 때 각각 새로운 Observable이 생성되었다.</li>
</ul>
<h2 id="debounce">debounce()</h2>
<ul>
<li>빠르게 연속 이벤트를 처리하는 흐름 제어 함수다.</li>
<li>안드로이드와 같은 UI 기반의 프로그래밍에서는 유용하게 활용할 수 있다.</li>
<li>예를 들어, 버튼을 빠르게 누르는 상황에서 마지막에 누른 이벤트만 처리해야할 때 간단하게 적용할 수 있다. RxJava를 이용하지 않는다면 마지막에 버튼을 누른 시간을 멤버 변수에 저장하고 일정 시간 동안 if문으로 예외 처리해야 하기 때문에 매우 번거롭고 실수할 가능성도 크다.</li>
</ul>
<img src="/img/debounce.png" width="500" height="200">
<ul>
<li>첫 번째 원은 지정한 시간 간격 안에 들어왔고 다른 이벤트는 없어서 그대로 발행되었다. 두 번째 원의 경우 시간 간격 안에 세 번째 원이 다시 들어왔으므로 두 번째가 아닌 세 번째 원을 발행한다. 마지막도 마찬가지다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 동작한다.</li>
<li><strong>어떤 이벤트가 입력되고 timeout에서 지정한 시간 동안 추가 이벤트가 발생하지 않으면 마지막 이벤트를 최종적으로 발행한다.</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">debounce</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">debounceSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>&#125;;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">0</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">1</span>]),</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">2</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">3</span>])</span><br><span class="line">        ).debounce(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>데이터를 발행하는 부분이 특이하다. 각각의 시간 간격이 서로 다르기 때문에 concat() 함수를 활용해 각가 데이터를 발행했다.</li>
<li>timer() 함수는 이벤트를 한 번만 발생시키고 완료하기 때문에 concat()과 timer() 함수의 조합은 유용하다.</li>
<li>debounce()를 활용해 어떤 이벤트가 입력되고 지정된 timeout인 200ms 안에 더 이상의 이벤트가 없으면 마지막에 입력된 값을 발행한다.</li>
<li>여기서 이해가 잘 안되었던 부분이 있었다. 결과를 예상해봤을 때, 1,2,5라고 생각했지만 아니었다. <strong>왜냐면 정의 자체가 어떤 이벤트가 입력되고 나서 timout 내에 더 이상의 이벤트가 없으면 마지막 이벤트를 발행하는 것이다.</strong> 그러니까 어떤 이벤트가 입력되고 나서 timout 내에 이벤트가 있는지 찾는 것이다. 그래서 결과는 1,3,5가 맞다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/09/14/RxJava-Chap07-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/archives/2/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/Android/archives/4/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 3 of 10</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
