
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Basic - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Basic/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-is-Intent/"
                            aria-label=": [안드로이드] 인텐트"
                        >
                            [안드로이드] 인텐트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T17:28:41+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="intent란">Intent란?</h2>
<p>안드로이드 어플리케이션을 구성하는 4가지 기본 요소에는 <strong>Activity, Service, Broadcast Receiver, Content Provider</strong>가 있다. <code>인텐트</code>는 이러한 어플리케이션 구성요소 즉, 컴포넌트간에 작업 수행을 위한 정보를 전달하는 역할을 한다.</p>
<p>인텐트를 가장 손쉽게 사용한 예로는 액티비티간 화면 전환을 들 수 있다. 즉 인텐트는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 <strong>명시적</strong>으로 표시되기도 하고, 속성들이 <strong>암시적</strong>으로 표시되기도 한다.</p>
<p>또한 호출된 컴포넌트 B가 호출한 컴포넌트 A로 어떠한 결과를 전달할 때도 인텐트가 사용된다. 어떠한 컴포넌트를 호출하느냐에 따라서 사용되는 대표적인 메소드는 다음과 같은 것들이 존재한다.</p>
<ul>
<li>startActivity() : 새로운 액티비티 화면을 띄울 때 사용</li>
<li>startService(), bindService() : 서비스와 관련된 메소드</li>
<li>broadcastIntent() : 브로드캐스팅을 수행할 때</li>
</ul>
<p>인텐트의 기본 구성 요소로는 액션(Action)과 데이터(Data)가 존재한다. <strong>액션</strong>은 수행할 기능이며, <strong>데이터</strong>는 액션이 수행될 대상 데이터을 의미한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예를 들어 아래의 코드가 있다고 하자.</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_DIAL, Uri.parse(<span class="keyword">data</span>))</span><br></pre></td></tr></table></figure>
<p>액션은 ACTION_DIAL 즉, 전화 다이얼을 걸라는 액션이며,<br>
data 값을 uri로 파싱한 Uri.pars(data)라는 것은 액션이 수행할 data 즉 전화번호일 것이다.</p>
<p>&quot;요약하면 Uri로 파싱한 전화번호 data를 대상으로 전화다이얼을 걸어라&quot;라는 뜻이고 이 뜻을 인텐트에 담아 안드로이드 시스템에게 전달하면 되는 것이다.</p>
<h2 id="인텐트-동작-순서">인텐트 동작 순서</h2>
<ul>
<li>Componenet가 ActivityManager에게 다른 컴포넌트의 실행을 요청</li>
<li>ActivityManager는 패키지 정보를 가지고 있는 PacakageManager에게 컴포넌트 정보 요청</li>
<li>유요한 컴포넌트임을 확인하면 컴포넌트를 실행</li>
<li>여기서 실행을 요청할 때 컴포넌트의 정보가 <strong>Intent</strong>이다.</li>
<li>Intent는 IPC 통신을 위한 직렬화 객체로 Parcelable을 통해 직렬화 되어 있다.</li>
<li>즉, 이 객체는 다른 프로세스로 전달하기 위한 데이터 그 자체이다.</li>
<li>활성화 될 컴포넌트 정보 + 활성화 될 컴포넌트에게 전달할 데이터</li>
<li>activity의 경우 startActivity()</li>
<li>service의 경우 startService()</li>
<li>Broadcast Recevier의 경우 sendBroadcast()</li>
<li>외부 패키지에서 접근하려면 <activity exported="true"> 이어야 한다.</activity></li>
</ul>
<h2 id="intent의-종류">Intent의 종류</h2>
<p>안드로이드의 4대 컴포넌트가 상호 통신을 위해 사용하는 인텐트는 크게 두가지로 나뉜다.</p>
<ol>
<li>명시적 인텐트</li>
</ol>
<p>인텐트에 클래스 객체네 컴포넌트 이름을 지정하여 호출될 대상을 확실히 알 수 있는 경우에 사용하는 것을 <strong>명시적 인텐트</strong>라고 한다. 주로 애플리케이션 내부에서 사용한다.</p>
<p>간단하게 현재 액티비티에서 SecondActivity로 화면 전환을 하는 코드는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener&#123;</span><br><span class="line">            <span class="comment">// 주의해서 볼 코드</span></span><br><span class="line">            <span class="keyword">var</span> intent = Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, SecondActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>새로운 인텐트 객체인 intent를 생성하면서 this@MainActivity 즉, getContext와 같은 현재 액티비티 정보가 담겨있는 정보와 SecondActivity 즉, 호출할 컴포넌트를 파라미터로 넘겨준다. 그리고 startActivity()에 인텐트 객체인 intent를 파라미터로 넘겨주면 새로운 화면인 SecondActivity가 실행된다. startActivity()는 새로 띄우는 액티비티로부터 받는 응답을 처리할 필요가 없을 때 간단하게 사용된다.</p>
<p>이에 반해 **startActivityForResult()**의 경우 새로 띄운 액티비티로부터 받는 응답을 처리할 경우에 사용된다.</p>
<ol start="2">
<li>암시적 인텐트</li>
</ol>
<p><strong>인텐트의 액션과 데이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다.</strong> 즉 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.</p>
<p>특정 컴포넌트에서 암시적 인텐트를 받기 위해서는 매니페스트 파일에서 <intent-filter> 요소와 함께 어플리케이션 컴포넌트 각각에 대해서 하나 이상의 인텐트 필터를 선언해야 한다. 각각의 컴포넌트는 action, data, category를 기반으로 해서 자신이 받길 원하는 인텐트의 유형을 명시해야 한다.</intent-filter></p>
<p>안드로이드 시스템은 전달되는 암시적 인텐트가 매니페스트에 존재하는 인텐트 필터 중의 하나와 매칭되는 경우 해당 컴포넌트로 암시적 인텐트를 전달해준다.</p>
<p>암시적 인텐트를 사용하는 대표적인 경우로 <strong>문서 편집기</strong>를 예로 들 수 있다. 카카오톡으로 친구가 자신의 자소서를 봐달라며 PDF 파일을 첨부했다. 우리는 그 PDF를 클릭하여 열기를 하면 해당 안드로이드 폰에 PDF를 편집하거나 보여줄 수 있는 많은 애플리케이션들이 서로 자기가 그 PDF 파일을 보여줄 수 있다고 손을 든다.</p>
<p>그러면 안드로이드 시스템에서는 ‘PDF를 열 수 있는 앱들이 이렇게 많은데 어떤거 선택할래?’ 라고 애플리케이션을 선택할 수 있는 위젯을 띄워준다. 이런 일련의 과정을 가능하게 하는 녀석이 <strong>암시적 인텐트</strong>이다.</p>
<blockquote>
<p>그럼 왜 암시적 인텐트를 사용할까??</p>
</blockquote>
<p>위의 예에서 우리는 친구의 자소서 PDF 파일을 열려고 한다. 여기서 PDF 파일을 열기 위해 이미 많은 PDF 리더 앱들이 존재한다. 그런데 굳이 우리가 PDF 리더를 만드는 것은 현실적으로 좋은 방법이 아니다. 따라서 <strong>이미 기존에 어떤 기능들을 지원하는 앱들이 있는 경우에 암시적 인텐트를 사용해서 그 앱들을 사용하면 되는 것</strong>이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 네이버 페이지</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"http://m.naver.com"</span>))</span><br><span class="line">startActivity(intent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전화 걸기</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"tel:010-0000-0000"</span>))</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<p>위와 같이 암시적 인텐트는 보통 액션(Action)과 데이터(data)라는 속성으로 구성되어 있다. 이 두 가지 속성 말고도 Category, Type, Component, Extras라는 속성을 가진다. 여기서 Component라는 속성을 지정할 경우 컴포넌트 클래스 이름을 명시적으로 지정하게 되는데 이 경우가 <strong>명시적 인텐트</strong>에 속하게 된다.</p>
<p>결국 암시적 인텐트는 Component 속성을 제외한 나머지 속성들로 구성되며, 이러한 속성들에 부합하는 컴포넌트가 실행된다.[호출할 대상들이 달라질 수 있다.]</p>
<p>안드로이드 폰에서 위의 코드 중 네이버에 접속하는 코드를 실행한 결과 화면은 아래와 같다.</p>
<img src="/img/android_intent.png" width="500" height="300">
<p>이와 같이 암시적 인텐트는 그 속성에 부합하는 컴포넌트가 여러 개 있을 때 선택할 수 있도록 해준다.</p>
<h2 id="intent-flag">Intent Flag</h2>
<p>안드로이드 애플리케이션 개발을 하다가 Activity에 대해 중복을 방지하거나 다른 상황에 대처할 때 Flag에 대해 잘 관리를 한다면 Activity에 대한 이해를 할 수 있고 관리 또한 용이하게 할 수 있다.</p>
<img src="/img/android_task.png" width="500" height="300">
<p><strong>안드로이드 태스크란?</strong>(Android Task, Activity Stack)</p>
<ul>
<li>Task는 애플리케이션에서 실행되는 액티비티를 보관하고 관리하며 Stack 형태의 연속된 Activity들로 이루어진다.</li>
<li>LIFO(Last In First Out) 즉, 후입 선출 형태로 나중에 적재된 액티비티일수록 가장 먼저 사용된다.</li>
<li>만약 1-&gt;2-&gt;3 페이지 순으로 액티비티를 이동했을 때 실행 순서대로 Task에 push 했다가 back 버튼을 누르면 3-&gt;2-&gt;1 페이지 순으로 Task에서 pop 시켜 돌아간다.</li>
<li>서로 다른 애플리케이션 간의 이동에도 Task를 이용해 사용자 경험(UX)를 유지시켜준다.</li>
<li>최초 적재 액티비티는 Root Activity라고도 하며 애플리에키션 런처로부터 시작된다.</li>
<li>마지막으로 적재되는 액티비티는 Top Activity라고 하며 현재 화면에 활성화 되어 있는 액티비티를 말한다.</li>
<li>Task 내에는 서로 다른 애플리케이션의 액티비티들이 포함될 수 있어 애플리케이션에 경계 없이 하나의 애플리케이션인 것처럼 보이게 해준다.</li>
<li>Task의 Stack내에 존재하는 액티비티들은 모두 묶여서 background와 foreground로 함께 이동한다.</li>
<li>홈버튼 클릭 : task interrupt -&gt; background</li>
<li>홈버튼 롱클릭 : recent task -&gt; foreground</li>
<li>Flag를 사용하여 Task 내의 액티비티의 흐름을 제어할 수 있다.</li>
</ul>
<p><strong>어피니티란?</strong>(Android Affinity)</p>
<ul>
<li>애플리케이션 내의 액티비티들은 하나의 어피니티(affinity : 친화력)을 가지고 있다.</li>
<li>AndroidManifest 파일에서 <activity> 요소의 taskAffinity 속성을 사용해 개별 affinity가 지정 가능하다.</activity></li>
<li>FLAG_ACTIVITY_NEW_TASK 플래그를 가진 인텐트 객체로부터 호출된 allowTaskReparenting 속성을 true로 가지고 있는 액티비티에 한해 affinity가 동작한다.</li>
<li>위 조건이 만족한 상황에서 시작된 액티비티는 자신과 동일한 어피니티를 갖는 태스크가 있을 경우 해당 태스크로 이동한다.</li>
<li>즉, [b] 어피니티를 가진 A 액티비티가 호출되어 해당 테스크에 속해있을 때 [b] 어피니티를 가진 태스크가 호출되면 A 액티비티는 [b] 어피니티를 가진 태스크로 이동한다.</li>
<li>어피니티에 의해 테스크가 이동된 후에 back 버튼으로 반환시 원래 해당하던 테스크로 돌아간다.</li>
<li>하나의 애플리케이션내에서 하나 이상의 기능을 갖는 애플리케이션이 존재할 경우 각 액티비티별로 다른 어피니티를 지정해 관리할 수 있다.</li>
</ul>
<p>Flag를 사용하는 방법은 AndroidManifest 파일에서 사용하는 방법과 Intent 코드로 사용하는 방법이 있다.</p>
<ol>
<li>AndroidManifest에서 사용하기</li>
</ol>
<p>안드로이드의 launchMode 속성을 사용하여 적용할 수 있다. 원하는 액티비티에 속성을 추가하여 적용하면 된다. launchMode에서 사용 가능한 속성은 다음과 같이 4가지만 가능하다.</p>
<ul>
<li>standard : 스택 중 어느 곳에나 위치 가능하며 <strong>여러 개의 인스턴스가 생성 가능하다.</strong></li>
<li>singleTop : 스택 중 어느 곳에나 위치 가능하며 여러 개의 인스턴스가 생성 가능하고 호출한 activity와 현재 최상위 activity가(top activity) <strong>동일한 경우 최상위 activity가 재사용</strong>된다.(기존 최상위 activity는 pop)</li>
<li>singleTask : 루트 액티비티로만 존재하며 <strong>하나의 인스턴스만 생성 가능</strong>하다. (타 task에서 동일 activity 사용 불가) 다른 액티비티 실행시 동일 Task 내에서 실행이 가능하다.</li>
<li>singleInstance : 루트 액티비티로만 존재하며 하나의 인스턴스만 생성 가능하고 <strong>태스크 내에 해당 액티비티 하나만 속할 수 있어</strong> 다른 액티비티를 실행시키면 새로운 Task가 생성되어 (FLAG_ACTIVITY_NEW_TASK와 동일) 그 Task 내에 포함된다.</li>
</ul>
<ol start="2">
<li>소스 코드에서 플래그를 사용하고 싶을 때는 Intent에 addFlags(), setFlags() 메소드를 사용한다.</li>
</ol>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK : 동일 affinity의 task가 있으면 그곳에 실행되고 아니면 새로운 task를 실행한다.[실행은 액티비티를 만들어 테스크에 넣는 것을 의미]</li>
<li>FLAG_ACTIVITY_SINGLE_TOP :  호출되는 액티비티가 최상위에 존재할 경우에는 해당 액티비티를 다시 생성하지 않고 존재하던 액티비티를 재사용한다. [실행시 재사용 액티비티의 실행은 onPause(), onNewIntent(), onResume() 순으로 호출된다.]
<ul>
<li>[B]를 single top 설정 : [A][B] 상태에서 [B] 호출 시 =&gt; [A][재사용된 B]</li>
<li>[A]를 single top 설정 : [B][A] 상태에서 [B] 호출 시 =&gt; [B][A][B]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_NO_HISTORY : 해당 액티비티는 재활성화시(back 키를 눌러 다시 활성화될 때) pop된다.
<ul>
<li>[B]를 no history 설정 : [A][B][A] 상태에서 back 키 사용시 [A]가 pop되고 [B] 역시 no history에 의해 pop =&gt; [A] 만 남음.</li>
</ul>
</li>
<li>FLAG_ACTIVITY_REORDER_TO_FRONT : activity 호출 시 이미 같은 activity가 task 내에 있으면 같은 activity는 pop시키고 해당 activity가 push 된다.
<ul>
<li>[A]를 reorder to front 설정 : [A][B] 상태에서 [A] 호출 시 같은 activity인 [A]가 pop되고 =&gt; [B][A]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_CLEAR_TOP : 해당 task에 있는 모든 activity를 pop시키고 해당 activity가 root activity로 task에 push된다.
<ul>
<li>[A]를 clear top 설정 : [A][B] 상태에서 [A] 호출시 모두 pop되고 =&gt; [A]</li>
<li>단, 해당 플래그는 액티비티를 모두 onDestroy()시킨 후 새롭게 onCreate()시키기 때문에 [A]를 유지하려면 FLAG_ACTIVITY_SINGLE_TOP 플래그와 함께 사용하면 된다.</li>
</ul>
</li>
<li>추가적인 플래그는 아래의 안드로이드 개발자 문서를 참고하자.</li>
<li><a href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT" target="_blank" rel="noopener">추가 정보</a></li>
</ul>
<p><strong>Clear Task</strong></p>
<ul>
<li>Task를 오랫동안 사용하지 않고 방치해두면 시스템은 Root Activity를 제외한 모든 액티비티를 Clear 시킨다.</li>
<li>이러한 동작은 Activity의 속성을 수정하여 제어할 수 있다.</li>
</ul>
<ol>
<li>alwaysRetainTaskState<br>
Task의 Root Activity에 true로 설정되어 있다면 상단에 언급되었던 동작은 발생하지 않으며 Task는 오랜 시간 이후에도 Stack에 있는 모든 Activity를 유지한다.</li>
</ol>
<ol start="2">
<li>clearTaskOnLaunch<br>
이 속성이 true로 설정되어 있으면 alwaysRetainTaskState과 정반대로 사용자가 Task를 떠났다가 다시 돌아올 때마다 항상 Stack은 Root Activity로 정리된다.</li>
</ol>
<ol start="3">
<li>finishOnTaskLaunch<br>
이 속성은 clearTaskOnLaunch와 유사하지만 전체 Task가 아닌 단일 Activity에서 동작한다. 그리고 그것은 Root Activity를 포함한 어떤 Activity가 사라지는 원인이 될 수도 있다. true로 설정되어 있을 때, Activity는 현재 Sessing 동안 Task의 일부만 유지한다. 만일 사용자가 해당 Task를 벗어났다가 다시 돌아오면 더 이상 존재하지 않는다.</li>
</ol>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://limkydev.tistory.com/35" target="_blank" rel="noopener">인텐트 (intent 명시적, 암시적)</a></li>
<li><a href="https://newgenerationkorea.wordpress.com/2015/07/09/%EC%9D%B8%ED%85%90%ED%8A%B8intent%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/" target="_blank" rel="noopener">인텐트란 무엇인가?</a></li>
<li><a href="http://androidhuman.tistory.com/262" target="_blank" rel="noopener">내가 누군지 말해줘! - 인텐트 필터</a></li>
<li><a href="http://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-%ED%83%9C%EC%8A%A4%ED%81%AC%EB%9E%80-Task-Activity-Stack-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EB%9E%80-Android-Affinity-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%9E%80" target="_blank" rel="noopener">안드로이드/Android 태스크란? (Task, Activity Stack) 어피니티란? (Android Affinity) 플래그란? (Android Flag)</a></li>
<li><a href="http://kylblog.tistory.com/21" target="_blank" rel="noopener">안드로이드 Intent Flag 정리(Activity 관리)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-is-Intent/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-Is-Fragment/"
                            aria-label=": [안드로이드] Fragment"
                        >
                            [안드로이드] Fragment
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T12:31:10+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="fragment란">Fragment란??</h2>
<p>Fragment란 하나의 Activity가 여러 개의 분할된 화면을 가지도록 만들기 위해 고안된 개념이다. 다양한 크기의 화면을 가진 모바일 환경이 늘어나고 태블릿의 큰 화면에 대한 <code>Activity의 비효율성</code>이 부각되었다. 이처럼 하나의 디스플레이 화면 안에서 다양한 화면을 보여주고 싶은 니즈를 충족시키기 위해 등장한 것이 Fragment이다.</p>
<p>Fragment를 사용하면 다른 Activity에서도 <strong>재사용</strong>할 수 있다는 장점이 있다. 또한 전체 화면인 Activity에서 부분 화면을 만드는 데 주로 사용된다.</p>
<p>Fragment는 항상 Activity 위에 올라가 있어야 한다. 자체 생명주기를 갖지만, Activity의 생명주기에 종속적이다. Activity가 소멸되면 그 위의 Fragment도 소멸된다.</p>
<p>안드로이드 4대 컴포넌트(Activity, Service, Broadcast Receiver, Content Provider)들은 <strong>인텐트</strong>를 이용하여 상호 간에 통신을 진행한다. 하지만 Fragment는 안드로이드의 4대 컴포넌트에 속하는 구성 요소가 아니다. 따라서 인텐트를 사용하여 값을 전달할 수 없다.</p>
<p>그래서 Fragment 간에 값을 전달하고 상호 통신을 하기 위해서 고안된 것이 <code>Bundle</code>이라는 것이다. Fragment는 Bundle이라는 객체를 통해서 Fragment 간의 데이터 전달을 수행한다.</p>
<blockquote>
<p>추가 내용</p>
</blockquote>
<p>Fragment는 자신이 속한 Activity와만 통신을 해야하며, 항상 자신이 속한 Activity를 통해서 다른 Fragment나 Activity와 통신해야 한다.<br>
Fragment와 Activity가 통신할 수 있는 방법에는 3가지 방법이 있다.</p>
<ol>
<li>Bundle - Acticity는 Fragment를 생성 후, 데이터를 넣은 bundle을 전달할 수 있다. Fragment는 onActivityCreated() 메소드에서 bundle을 받게 된다.</li>
<li>Method - Activity는 Fragment의 메소드를 호출할 수 있다.</li>
<li>Listener - Fragment는 interface를 사용하여 Activity에서 리스너 이벤트를 발생시킬 수 있다.</li>
</ol>
<p>하나의 Activity에 속하는 다수의 Fragment가 동시에 동작 가능하다. Activity는 한 화면을 다 차지해야 하는데 Fragment는 화면 일부만 점유해도 동작 가능하기 때문에 화면을 분할하여 부분마다 독립적인 유저 인터페이스를 구현할 수 있다. Activity의 일부분을 차지하는 각각의 Fragment는 자신만의 유저 인터페이스를 보여주고, 사용자의 입력에 반응한다.</p>
<p>기기의 화면 크기나 화면 방향 등에 따라 달라지는 Activity의 레이아웃에 맞추어 Fragment의 레이아웃을 재배열하거나 결합할 수 있다. 예를 들어 태블릿에서는 Activity에 두 개의 Fragment를 추가한 유저 인터페이스를 보여주지만 핸드폰에서는 Activity당 하나의 Fragment를 추가한 유저 인터페이스를 보여준다.</p>
<h2 id="fragments-lifecycle">Fragment’s LifeCycle</h2>
<p>Fragment는 생명 주기를 갖지만, Activity의 생명주기에 종속적인 특성이 있다.</p>
<img src="/img/fragment_lifecycle.png" width="500" height="300">
<ul>
<li>
<p>onAttach()</p>
<ul>
<li>Fragment가 Activity에 추가될 때 한번 호출된다.</li>
<li>하지만 아직 완벽하게 생성된 것은 아니다.</li>
<li>Fragment가 Activity에 대한 참조를 얻기 위해 사용되어진다.</li>
</ul>
</li>
<li>
<p>onCreate()</p>
<ul>
<li>본격적으로 Fragment가 Activity의 호출을 받아 생성되는 시점이다.</li>
<li>Fragment의 생명주기는 Activity의 생명주기에 <strong>종속적</strong>이라고 앞에서 언급했다. 이 단계에서는 Activity도 생성 중에 있는 시기이기 때문에 Activity에 있는 컨트롤을 참조하거나 Fragment의 요소들을 초기화할 때 불안정한 경우가 있다.</li>
<li>Activity의 onCreate()에서는 view, UI 작업을 할 수 있지만, Fragment의 onCreate()에서는 할 수 없다.</li>
<li>Activity의 onCreate 메소드가 아직 완료된 시점이 아니라서 유저 인터페이스와 관련있는 것을 제외한 Fragment에서 사용되는 리소스들이 초기화된다.</li>
<li>Fragment가 paused 또는 stop 되었다가 다시 resume되었을 때 유지하고 싶은 Fragment의 컴포넌트들을 여기서 초기화 해주어야 한다.</li>
</ul>
</li>
</ul>
<p>setRetainInstance(true)를 호출하여 Fragment의 인스턴스를 유지하도록 할 수 있다. 이 때 다음의 세가지가 기존과 달라진다.</p>
<ol>
<li>Activity가 재생성되어도 Fragment가 유지되기 때문에 onCreate는 호출되지 않는다.</li>
<li>onDestroy()가 호출되지 않지만, Activity로부터 Fragment가 detach될 때 onDetach()는 호출된다.</li>
<li>onAttach(Activity)와 onActivityCreated(Bundle)는 호출된다.</li>
</ol>
<ul>
<li>onCreateView(LayoutInflater, ViewGroup, Bundle)
<ul>
<li>Fragment에 속한 각종 View나 viewGroup에 대한 <strong>UI 바인딩 작업을 할 수 있다.</strong></li>
<li>Fragment의 유저 인터페이스가 화면에 그려지는 시점에 호출된다.</li>
<li>XML 레이아웃을 inflate하여 Fragment를 위한 View를 생성하고 Fragment 레이아웃의 root에 해당되는 View를 Activity에게 리턴해야 한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>inflate?</p>
</blockquote>
<p>inflate는 XML 레이아웃에 정의된 뷰나 레이아웃을 읽어서 메모리상의 view 객체를 생성해주는 것이다.</p>
<ul>
<li>
<p>onActivityCreated()</p>
<ul>
<li>Activity에서 Fragment를 모두 생성하고(View 생성) 난 다음에 호출된다.</li>
<li>Activity에서 onCreate() 다음에 호출되는 메소드이다.</li>
<li>Activity와 Fragment가 드디어 연결되는 시점이다.</li>
<li>Activity와 Fragment의 View가 모두 생성된 시점이라 findViewById()를 사용하여 View 객체에 접근하는게 가능하다.</li>
</ul>
</li>
<li>
<p>onStart()</p>
<ul>
<li>Fragment가 사용자에게 보여지기 전에 호출되는 함수이다.</li>
<li>Fragment가 속한 Activity가 start 된 것과 관련있음.</li>
</ul>
</li>
<li>
<p>onResume()</p>
<ul>
<li>Fragment가 비로소 화면에 보이는 단계이다.</li>
<li>사용자에게 <strong>focus</strong>를 잡은 상태.</li>
<li>사용자와의 상호 작용이 가능하다.</li>
<li>Fragment가 속한 Activity가 resume된 것과 관련있음.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 사용되지 않을 때 호출되는 함수들</strong></p>
<ul>
<li>
<p>onPause()</p>
<ul>
<li>Activity가 pause되어 Fragment는 사용자와의 상호작용을 중지한다.</li>
<li>Fragment가 중지되는 시점을 정의한다. Fragment의 정지가 반드시 Fragment의 소멸을 의미하는 것은 아니지만 다시 해당 Fragment로 돌아온다는 보장도 없기 때문에 이 시점에서 <strong>남겨두어야 하거나 보존해야 할 자료들을 저장</strong>한다.</li>
</ul>
</li>
<li>
<p>onStop()</p>
<ul>
<li>Activity에 의해 stop되었거나 Fragment의 수행이 Activity에 의해 수정되었을 경우로 Fragment는 더 이상 보이지 않게 되며, Fragment 기능은 중지한다.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 destroy될 때 다음 순서대로 호출된다.</strong></p>
<ul>
<li>
<p>onDestroyView()</p>
<ul>
<li>Fragment가 화면에서 보이지 않고 View의 현재 상태가 저장된 후 호출된다.</li>
<li><strong>Fragment의 View들을 제거(destroy)한다.</strong></li>
<li>Back Stack을 사용했다면, 해당 Fragment로 돌아올 때 onCreateView()가 호출된다.</li>
<li>onCreateView에서 초기화했던 UI들을 여기서 해제하면 된다.</li>
</ul>
</li>
<li>
<p>onDestroy()</p>
<ul>
<li>Fragment를 더 이상 사용하지 않을 때 호출된다.</li>
<li>Activity와 연결이 끊어진 상태는 아니지만 Fragment는 동작하지 않는다.</li>
<li>Fragment를 제거하기 직전.</li>
<li>시스템에서 onDestory()가 항상 호출되는 것을 보장해주지 않는다.</li>
</ul>
</li>
<li>
<p>onDetach()</p>
<ul>
<li>onDetach가 호출된 후, Fragment를 비로소 제거하고 Activity와의 연결도 해제한다.</li>
<li>Framgnet의 View hierarchy가 더 이상 존재하지 않게 된다.</li>
<li>부모 Activity가 즉, 종속된 Activity가 생명주기를 완전하게 마치지 않고 종료되었다면 onDetach()는 호출되지 않을 수도 있다.</li>
</ul>
</li>
</ul>
<h2 id="액티비티와-프래그먼트-차이">액티비티와 프래그먼트 차이</h2>
<p>위에서 언급했듯이 태블릿이 등장하면서 큰 화면에 대한 액티비티의 <strong>비효율성</strong>이 부각되었다. 태블릿의 큰 화면에 여러 액티비티를 보여주기 위해 나온 것이 프래그먼트이다. 하나의 액티비티에 여러 레이아웃을 배치하여 구성할 수도 있지만 <code>프래그먼트</code>를 사용하면 다른 액티비티에서도 <strong>재사용</strong>이 가능하고 <strong>자체 생명주기</strong>를 가지기에 생명주기에 따라 다양한 구현이 가능하다. 또한 자체 입력 이벤트를 가지기에 다이나믹한 인터렉션이 가능하다.</p>
<p>프래그먼트의 생명주기는 액티비티의 생명주기에 <strong>종속적</strong>이기에 액티비티에서 <code>onCreate()</code>가 호출되면 프래그먼트에서는 <code>onActivityCreated()</code>가 호출되고 액티비티에서 <code>onPause()</code>가 호출되면 프래그먼트도 <code>onPause()</code>가 된다.</p>
<p>프래그먼트에서 액티비티와 통신을 하려면 getActivity()를 호출하면 액티비티 객체를 사용할 수 있으며 프래그먼트에서 발생하는 이벤트는 <code>onAttach()</code>에서 _interfactionListener_를 호출하고 액티비티에서 이것을 구현함으로써 이벤트에 대한 처리와 프래그먼트간 통신이 가능하다.</p>
<p>액티비티를 관리하는 스택이 있듯이 프래그먼트에도 <strong>백스택</strong>이라는 스택 구조가 존재하며 이것은 액티비티가 관리한다. <code>FragmentTransaction</code> 객체의 addToBackStack() 함수를 사용하여 프래그먼트를 백스택에 저장하면 사용자가 뒤로가기 버튼을 눌렀을 때 프래그먼트의 이전 상태로 되돌려주는 기능을 제공할 수 있다.</p>
<img src="/img/android_compare_activity_fragment.png" width="500" height="300">
<img src="/img/android_compare_activity_fragment2.png" width="500" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/01/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%912/" target="_blank" rel="noopener">액티비티와 프래그먼트 차이</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-Is-Fragment/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/06/25/Android-Context/"
                            aria-label=":  [안드로이드] Context"
                        >
                             [안드로이드] Context
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-06-25T22:29:41+09:00">
	
		    Jun 25, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드를 공부하면서 항상 Context에 대해서 의문을 가지고 있었지만, 명확하게 설명해주는 글이 없어서 그냥 넘어갔습니다. 하지만, 다른 사람이 Context에 대해서 물어본다면 속 시원하게 대답해줄 수 없었습니다.</p>
<p>그 당시에는 공식처럼 넘겨주면 된다고 생각을 하였지만, 공부를 계속 할수록 저걸 '<strong>왜 넘겨주는 걸까</strong> <strong>?</strong>'라는 의문이 들어서 찾아보면서 공부하자고 마음 먹었습니다.</p>
<h1 id="context">Context</h1>
<hr>
<p>안드로이드 개발을 공부하면서 자주 사용하는 함수들이 있습니다. 예를 들면 간단한 메시지를 띄워주는 <strong>Toast</strong> 메시지, 다른 Activity로 화면 전환을 위해서 주로 사용되는 <strong>Intent</strong> 등은 <code>applicationContext</code>라는 것을 매개변수로 항상 넘겨주곤 합니다.</p>
<h2 id="context가-뭘까">Context가 뭘까??</h2>
<hr>
<p>안드로이드의 <code>Context</code> 개념은 안드로이드 Developer에 따르면 다음과 같습니다.</p>
<blockquote>
<p>Application 환경에 관한 글로벌 정보를 접근하기 위한 인터페이스. Abstract 클래스이며 실제 구현은 안드로이스 시스템에 의해 제공됩니다. Context를 통해 Application에 특화된 리소스나 클래스에 접근할 수 있을 뿐만 아니라 추가적으로 Application 레벨의 작업(Activity 실행, Intent 브로드캐스팅, Intent 수신 등등)을 수행하기 위한 API를 호출 할 수도 있습니다.</p>
</blockquote>
<p>Context는 크게 두 가지 역할을 수행하는 Abstract 클래스입니다.</p>
<ul>
<li>Application에 관하여 시스템이 관리하고 있는 정보에 접근하기<br>
– getPackageName(), getResource()</li>
<li>안드로이드 시스템 서비스에서 제공하는 API를 호출할 수 있는 기능<br>
– startActivity(), bindService()</li>
</ul>
<h2 id="왜-context가-필요할까">왜 Context가 필요할까??</h2>
<hr>
<p>Context가 왜 필요하지?? 라는 질문은 어렵습니다. 전역적인 Application 정보에 접근하거나 Application 연관된 시스템 기능을 수행하기 위해 시스템 함수를 호출하는 일은 안드로이드가 아닌 다른 플랫폼에서도 늘상 일어나는 일입니다. 또, 그러한 작업들은 어떠한 매개체를 거칠 필요 없이 직접적으로 시스템 API를 호출하면 됩니다. <strong>반면 안드로이드에서는 Context라는 인스턴스화된 매개체를 통해야만 유사한 작업들을 수행할 수 있습니다.</strong></p>
<p>C#의 경우에는 System 단에서 제공하는 정적 함수(static function)를 호출함으로서 간단하게 할 수 있는 일들을 안드로이드에서는 Context에 정의된 인스턴스 함수를 호출해야만 가능하게 되어있습니다. 즉, 반드시 인스턴스화된 Context 클래스를 사용해야 합니다.</p>
<blockquote>
<p>왜 이런 차이가 생기게 된 것일까요??</p>
</blockquote>
<p>안드로이드가 아닌 플랫폼에서는 <strong>어떻게 정적 함수 호출을 통해서 Application에 관한 정보를 가져오고, 시스템 함수를 호출할 수 있는 걸까요??</strong></p>
<p>OS에 대한 지식이 별로 없지만, 찾아보고 공부해본 바로는 일반적인 경우, Application이 프로세스와 아주 긴밀하게 연결되어 있습니다. OS 커널의 가장 중요한 일 중 하나는 프로세스를 관리하는 것입니다. 특정 프로세스가 특정 Application과 Mapping 된다면 우리는 별다른 매개체 없이 시스템에서 직접 프로세스의 정보에 관해서 물어볼 수 있고, 프로세스와 연관된 시스템 함수를 호출할 수 있습니다.</p>
<p>그런데 안드로이드에서 Application과 프로세스와의 관계는 조금 다릅니다. 안드로이드에서 Application과 Process는 서로 독립적으로 존재합니다.</p>
<p>예를 들면, 안드로이드 플랫폼에서는 프로세스가 없는 상황에도 Application은 살아있는 것처럼 사용자에게 표시되기도 하고, 메모리가 부족한 상황이 될 경우 작동 중이던 Process가 강제로 종료되고, 대신 해당 Process에서 작동 중이던 Application에 관한 일부 정보만 별도로 관리하고, 이 후에 메모리 공간이 확보되면 저장되어 있던 Application 정보를 바탕으로 새로운 Process를 시작하는 등의 일이 벌어집니다.</p>
<p>안드로이드에서도 Process는 당연히 OS 커널에서 관리됩니다. Application과 Process가 별도로 관리되고 있다면, Application 정보는 어디에서 관리하고 있을까요?? 안드로이드의 시스템 서비스 중 하나인 <strong>ActivityManagerService</strong>에서 책임을 지고 있습니다. <strong>ActivityuManagerService</strong>는 특정 토큰을 키값으로 <code>Key-Value</code> 쌍으로 이루어진 배열을 이용해서 현재 작동중인 Application 정보를 관리합니다.</p>
<p>결론에 가까워졌습니다. ^^ Context는 Application과 관련된 정보에 접근하고자 하거나 Application과 연관된 시스템 레벨의 함수를 호출하고자 할 때 사용됩니다. 그런데 안드로이드 시스템에서 Application 정보를 관리하고 있는 것은 시스템이 아닌, ActivityManagerService 라는 일종의 또 다른 Application입니다. 따라서 다른 일반적인 플랫폼과는 달리 안드로이드에서는 Application과 관련된 정보에 접근하고자 할 때는 ActivityManagerService를 통해야만 합니다. 당연히 정보를 얻고자 하는 Application이 어떤 Application인지에 관한 key 값도 필요해집니다.</p>
<p>즉, 안드로이드 플랫폼상에서의 관점으로 살펴보면 Context는 다음과 같은 두 가지 역할을 수행하기 때문에 꼭 필요한 존재입니다.</p>
<ul>
<li>자신이 어떤 Application을 나타내고 있는지 알려주는 ID 역할</li>
<li>ActivityManagerService에 접근할 수 있도록 하는 통로 역할</li>
</ul>
<p>일반적인 OS 플랫폼에서 Application은 곧 Process 입니다. 특정 Application이 OS에게 내가 어떤 Process인지만 알려주면 Application 관련된 정보를 얼마든지 획득할 수 있습니다. 이른바 자신의 존재 자체가 자신임을 증명해주는 ‘지문인식’ 혹은 ‘홍채인식’ 등의 '생채인식’과 비슷한 개념이기 때문에 Context와 같은 애매한 중간 매개체가 존재할 이유가 없습니다.</p>
<p>하지만 안드로이드 플랫폼은 조금 다릅니다. 비유하자면 ‘생채인식’ 보다는 'ID 카드’를 통한 보안 시스템과 유사한 구조를 가지고 있습니다. 특정 Application이 자신이 본인임을 확인 받을 수 있는 방법은 자신이 작동중인 Process를 보여주는 것이 아니라, 자신이 건네받은 ID 카드를 제시하는 것입니다. 이때, ID 카드의 역할을 수행하는 것이 바로 <code>Context</code>이고, 당연히 이 카드는 위변조가 가능하기 때문에, 자신의 권한을 제 3자의 Application에게 넘겨주는 PendingIntent와 같은 기농도 가능해집니다.</p>
<h2 id="context는-언제-생성될까">Context는 언제 생성될까??</h2>
<hr>
<p>Application이 생성될 때 입니다. 그렇다면 하나의 Application을 구성하는 각종 컴포넌트들(Activity, Service, BroadcastReceiver)은 모두 동일한 Context를 공유해서 사용하고 있을까요??<br>
대답은 그렇지 않습니다.</p>
<p>Activity와 Service가 생성될때 만들어지는 Context와 BroadcastReceiver가 호출될 때 전해지는 Context는 모두 서로 다른 인스턴스입니다. 즉, Context는 Application이 시작될 때는 물론, Application Component들이 생성될 때마다 만들어지게 됩니다. 새롭게 생성되는 Context는 부모와 완전히 독립되어 있는 존재는 아니고 ‘거의’ 비슷한 내용을 담고 있습니다.</p>
<blockquote>
<p>동일한 Context 인스턴스를 Application Component들이 공유해서 사용하지 않고, 모두 서로 다른(그러나 알고보면 알맹이는 거의 같은) 인스턴스를 만들어서 사용하고 있을까요???</p>
</blockquote>
<p>Context의 기능 중, 시스템 API를 호출하는 기능과 관련되어 한 가지 문제점이 있습니다. 어떤 Application 컴포넌트가 시스템 API를 호출하느냐에 따라서 서로 다른 결과가 나타나야 한다는 점입니다. 예를 들어, <a href="https://blog.naver.com/huewu/110084868855" target="_blank" rel="noopener">Service 에서 Activity 실행하기</a>에서 확인할 수 있는 것처럼, 동일한 형태로 startActivity 메소드를 호출하더라도, 일반적인 Activity에서는 정상적으로 새로운 Activity를 시작하게 되지만, Service에서 호출할 경우에는 예외가 발생합니다. 만일 Application을 구성하는 Service와 Activity가 서로 동일한 Context 인스턴스를 공유하고 있다면 동일한 메소드 호출에 대하여 서로 다른 결과를 나타내도록 구현하지 못했을 것입니다.</p>
<p>따라서 현재 안드로이드 시스템은 Application Context를 기반으로 Component를 위한 Context를 생성할 때 해당 Context가 어떤 종류의 Component인지 알 수 있도록 약간의 표시를 해두곤 합니다.</p>
<h2 id="android-multitasking">Android MultiTasking</h2>
<hr>
<p>안드로이드는 독특한 방법으로 동시에 여러 Application이 작동하는 멀티태스킹 기능을 지원합니다. 다른 플랫폼에서 개발을 하던 개발자들은 안드로이드가 멀티태스킹을 지원하는 방식을 보면 놀랄 것입니다. 몰티태스킹이 작동하는 방식을 이해하는 것은 잘 작동하는 동시에 안드로이드 플랫폼의 다른 요소들과 매끄럽게 결합될 수 있는 Application을 디자인하는데 매우 중요합니다. 아래의 내용은 안드로이드 멀티태스킹이 현재와 같이 작동하는 디자인적인 이유와 Application 작동에 끼치는 영향 그리고 개발자가 어떻게 안드로이드가 지원하는 기능들을 잘 활용할 수 있는지에 대해 다룹니다.</p>
<h3 id="desing-considerations">Desing Considerations</h3>
<hr>
<p>모바일 Device는 기술적인 한계점을 갖으며 일반적인 데스크탑 혹은 웹 환경과는 다른 사용자 경험이 요구됩니다. 다음은 안드로이드의 멀티태스킹 기능을 설계하는데 중요하게 여긴 4가지 제약 사항들입니다.</p>
<ol>
<li>
<p>사용자가 특정 Application 사용을 끝마쳤을 때, 명시적으로 Application을 종료하지 않아도 되기를 원합니다. 사용자들은 다양한 종류의 Application을 아주 짧게 그리고 반복적으로 사용하기 때문입니다.</p>
</li>
<li>
<p>휴대용 장치들은 풍족환 스왑 메모리 공간을 갖고 있지 못하며, 메모리 사용에 빡빡한 제한을 갖고 있습니다.</p>
</li>
<li>
<p>모바일 Device에서 Application 스위칭은 중요합니다. 새로운 Application이 1초 이내에 시작될 수 있도록 굉장한 노력을 기울입니다. 비디오를 보다가 새로 도착한 SMS 문자를 확인하고 다시 비디오 플레이 Application으로 돌아가는 등의 사용자 시나리오를 생각해 본다면, 몇몇 Application간의 빠른 스위칭은 특히 더 중요한 문제입니다.</p>
</li>
<li>
<p>사용할 수 있는 API는 안드로이드에 기본 내장된 구글 Application을 만들 수 있을 만큼 충분히 강력해야 합니다. 이것은 ‘모든 Application은 동등하다’ 라는 철학의 문제입니다. 즉, 백그라운드 음악 재생, 데이터 동기화, GPS 네비게이션, Application 다운로드 등의 기능은 서드 파티 Application 개발자들이 사용 가능한 API와 동일한 API를 이용해서 작성되어야 합니다.</p>
</li>
</ol>
<p>앞선 두 가지 요구사항은 한 가지 흥미로운 모순점을 가지고 있습니다. 우리는 사용자들이 Application 종료에 대해 신경쓰는 것 대신 <strong>모든 Application은 항상 실행 중</strong>인 것처럼 느낄 수 있기를 바랍니다. 하지만 동시에 모바일 Device는 메모리 사용에 빡빡한 제한이 있습니다. 시스템이 사용 가능한 램 영역보다 많은 메모리가 필요한 경우가 되면, 데스크탑 컴퓨터들은 단순히 페이지 스왑을 위해 작동이 조금 느려지게 됩니다. 반면, 모바일 Device는 성능상에 큰 문제점이 생기거나 아예 먹통이 되어버릴 수 있습니다. 이 도전할 만한 제약 조건이 안드로이드의 멀티태스킹 메커니즘을 설계하기 위한 핵심 동기가 되었습니다.</p>
<h3 id="when-dose-an-application-stop">When dose an application “stop”?</h3>
<hr>
<p>안드로이드의 멀티태스킹과 관련된 가장 일반적인 오해는 프로세스와 Application의 차이에 관한 점입니다. 안드로이드에서 프로세스와 Application은 밀접하게 연결되어 있는 요소가 아니며, Application은 해당 Application을 작동시키고 있는 프로세스가 없음에도 사용자에게 현재 작동하고 있는 것처럼 보일 수도 있고, 또 여러 Application이 프로세스를 공유할 수도 있습니다. 혹은 필요에 따라 하나의 Application이 여러 개의 프로세스를 사용할 수도 있고, 실제로 Application이 작동 중이 아님에도 Application을 구동했던 프로세스들은 종료되지 않고 안드로이드 시스템에 의해 유지될 수 있습니다.</p>
<p><strong>즉, 개발자가 Application이 프로세스가 Running 상태임을 확인할 수 있다고 해서 그것이 해당 Application이 현재 작동 중이거나 어떠한 일을 하고 있다는 것을 의미하지 않습니다.</strong> Application의 프로세스는 단순히 안드로이드 시스템이 해당 프로세스가 필요했었고, 이 후에 해당 프로세스가 다시 사용될 경웨 대비해서 프로세스를 유지하기로 결정했기 때문에 살아있는 것 뿐입니다. 이와 비슷하게 개발자가 아주 잠시동안 특정 Application을 떠나 곧 돌아오기를 원하고자 하는 경우라 할지라도 해당 Application을 작동시키고 있는 프로세스는 안드로이드 시스템에 의해 강제로 종료될 수 있습니다.</p>
<p>사실, 안드로이드가 Application을 관리하는 핵심은 <code>프로세스를 깔끔하게 종료시키지 않는 것</code>입니다. 사용자가 Application을 떠나는 순간, 해당 Application의 프로세스는 계속 유지되며, 백그라운드 상에서 필요한 경우 어떠한 작업을 수행할 수 있습니다. 그리고 사용자가 해당 Application으로 돌아오면 그 즉시 포그라운드로 전환됩니다. 만일 Device의 메모리가 충분하다면, 안드로이드는 모든 Application 프로세스들을 유지하게 되고, 말 그대로 모든 Application은 동시에 작동할 수 있습니다.</p>
<p>물론, 메모리는 무한하지 않습니다. 이러한 한계를 극복하기 위해 안드로이드 시스템은 더 이상 필요하지 않은 프로세스를 종료해야만 합니다. 즉, 각각의 프로세스들은 정해진 규칙에 따라 그 중요도가 결정되고, 가장 중요하지 않은 프로세스가 종료되게 됩니다. 이러한 과정이 안드로이드의 <strong>프로세스 생명주기</strong>(Process LifeCycle)를 만들어 냅니다. 프로세스의 중요도는 프로세스가 현재 사용자에게 얼마나 큰 영향을 미치고 있는지 그리고 사용자가 마지막으로 해당 프로세스를 필요로 한 것이 얼마나 오래전인지 두 가지 요소에 의해 결정됩니다.</p>
<p>안드로이드 시스템이 특정 프로세스를 제거하기로 결정하면, <strong>강제로 프로세스를 종료합니다.</strong> 따라서 커널은 해당 프로세스가 시스템으 프로세스 종료 요청에 대하여 사용중인 자원을 적절하게 반환하도록 작성되었는지 그렇지 않은지와 관계없이, 즉시 해당 프로세스에 의해 사용 중이던 리소스들을 사용할 수 있습니다. 커널이 Application이 사용 중이던 리소스를 즉시 사용할 수 있도록 함으로서, 시스템 메모리 부족으로 인해 발생하는 심각한 문제들을 훨씬 쉽게 회피할 수 있게 됩니다.</p>
<p>**모든 Application은 항상 작동하고 있다.**라는 사용자 경험을 만족시키기 위해 만일 사용자가 이미 종료된 Application으로 돌아가기를 원하는 경우, 해당 Application의 마지막 상황과 동일한 형태로 Application이 시작되어야 합니다. 이를 위해, 사용자에게 보여지는 Application 요소(즉, Activity)는 늘 기록 되며, 필요한 경우 특정 Activity가 화면 상에 보였던 상태 정보와 함께 Activity를 재시작합니다. Activity의 상태 정보는 Application 종료 시점이 아니라, 사용자가 Application을 떠날 때마다 생성됨으로 커널은 사용자가 Application을 벗어난 후에는 비교적 자유롭게 해당 Application을 종료할 수 있습니다.</p>
<p>어떤면으로 보면, 안드로이드가 프로세스를 관리하는 방법은 공간 교체(swap space)의 형식으로 여겨질 수 있습니다. Application 프로세스들은 사용 중인 메모리 공간을 나타냅니다. 메모리가 부족하게 될 경우 몇몇 프로세스들은 강제로 종료 되고(교체당함 - Swapped Out), 해당 프로세스들이 다시 필요하게 될 경우 마지막으로 저장된 상태 정보를 기반으로 다시 시작(교체 투입 - Swapped in)될 수 있습니다.</p>
<h3 id="explicitly-running-in-the-background">Explicitly running in the background</h3>
<hr>
<p>Application 프로세스가 안드로이드 시스템에 의해 강제로 종료되지 않는 한, 암시적으로 해당 백그라운드 작업을 수행할 수 있습니다. 하지만, 이런 기능이 웹 페이지를 로딩하는 등의 일을 하기에는 충분할 지 모르지만, 예를 들어 백그라운드에서 음악을 재생, 데이터를 동기화, 위치 정보를 기록, 알람 등과 같이 보다 엄밀한 요구사항이 필요한 경우에는 적절하지 못합니다.</p>
<p>이러한 작업들을 위해서 Application은 안드로이드 시스템에게 명시적으로 백그라운드 상에서 작업이 수행되어야 함을 알릴 필요가 있습니다. Application은 메니페스트 상에 <code>BroadcastReceiver</code> 혹은 <code>Service</code> 요소를 선언할 수 있으며, 이 두 가지 요소를 통해 명시적으로 백그라운드 작업을 수행할 수 있습니다.</p>
<ol>
<li>Broadcast Receivers</li>
</ol>
<p>Broadcast Receiver는 Application이 특정한 이벤트가 발생하는 경우에, 아주 짧은 시간 동안 백그라운드에서 작업할 수 있도록 해주며, 다양한 방식으로 보다 상위의 기능을 구현하는데 사용될 수 있습니다. 예를 들어 AlarmManager는 Application이 미래의 특정 시점에 Broadcast를 전송할 수 있도록 해주며, LocationManager는 위치 정보가 변경될 때마다 Broadcast를 전송할 수 있습니다. BroadcastReceiver에 관한  정보는 Application 메니페스트에 포함되기 때문에 안드로이드 시스템은 현재 작동하지 않는 Application의 BroadcastReceiver를 찾아서 실행시켜 줄 수 있으며, 물론 Application이 현재 작동 중이라면 그 Application에 속하는 BroadcastReceiver는 매우 효율적으로 실행됩니다.</p>
<h2 id="마무리">마무리</h2>
<hr>
<p>결국, 안드로이드 Context는 <a href="http://blog.naver.com/huewu/110085391353" target="_blank" rel="noopener">여러가지 이유</a>로 기존 플랫폼과는 다른 방식으로 Application을 관리하고 있고, 때문에 기존 플랫폼들에서는 단순하게 시스템 API를 통해 할 수 있는 일들을 Context 인스턴스라는 귀찮지만 강력한 녀석을 통해 대행 처리하고 있습니다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://arabiannight.tistory.com/entry/272" target="_blank" rel="noopener">안드로이드/Android Context 란?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/06/25/Android-Context/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/03/02/Android-ActivityLifeCycle/"
                            aria-label=":  [Android] 4대 컴포넌트"
                        >
                             [Android] 4대 컴포넌트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-03-02T13:35:59+09:00">
	
		    Mar 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는 <code>안드로이드의 4대 컴포넌트</code>에 대해서 배워보았습니다.</p>
                    
                        <a
                            href="/2018/03/02/Android-ActivityLifeCycle/"
                            class="postShorten-excerpt_link link"
                            aria-label=":  [Android] 4대 컴포넌트"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Basic/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
