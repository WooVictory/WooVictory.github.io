
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Java - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Java/archives/4/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/06/java-basic-4/"
                            aria-label=": [Java] 4. 배열"
                        >
                            [Java] 4. 배열
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-06T23:21:14+09:00">
	
		    Aug 06, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="배열array"># 배열(Array)</h1>
<ul>
<li><strong>같은 타입</strong>의 변수들로 이루어진 유한 집합</li>
<li>배열을 구성하는 각각의 값을 배열 요소라고 한다.</li>
<li>위치를 가리키는 숫자를 <strong>인덱스</strong>라고 한다. 인덱스는 0부터 시작하고 0을 포함한 양의 정수만을 가질 수 있다.</li>
<li><strong>같은 종류</strong>의 데이터를 많이 다뤄야 하는 경우에 사용.</li>
<li>1차원, 2차원, 다차원 배열이 존재</li>
</ul>
<h2 id="배열의-초기화">배열의 초기화</h2>
<ul>
<li>다양한 초기화 방법들이 존재한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열의 선언과 동시에 초기화할 수 있음</span></span><br><span class="line"><span class="keyword">int</span>[] grade1 = &#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열의 선언과 동시에 초기화할 수 있음</span></span><br><span class="line"><span class="keyword">int</span>[] grade2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함</span></span><br><span class="line"><span class="keyword">int</span>[] grade3;</span><br><span class="line">grade3 = &#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 이미 선언된 배열은 이 방법으로만 초기화 가능</span></span><br><span class="line"><span class="keyword">int</span>[] grade4;</span><br><span class="line">grade4 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>위의 grade1, grade2, grade4 배열은 초기화 블록에 맞춰 자동으로 배열의 길이가 설정된다.</p>
<h1 id="다차원-배열"># 다차원 배열</h1>
<ul>
<li>2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.</li>
<li>2차원 배열 : 배열 요소로 1차원 배열을 가지는 배열</li>
<li>3차원 배열 : 배열 요소로 2차원 배열을 가지는 배열</li>
</ul>
<p><strong>2차원 배열</strong></p>
<ul>
<li>배열의 요소로 1차원 배열을 가지는 배열.</li>
<li>자바에서 2차원 배열을 나타내는 타입을 따로 제공하지 않는다. - 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있다.</li>
</ul>
<img src="/img/two_dimesion_array.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        arr[i][j] = k;</span><br><span class="line">        k+=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(arr.length); <span class="comment">// 2</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr.length</code>는 2차원 배열인 arr의 배열 요소의 총 개수인 <strong>2</strong>를 반환.</li>
<li><code>arr[i].length</code>는 arr의 각 배열 요소인 1차원 배열이 가지고 있는 배열 요소의 총 개수인 <strong>3</strong>을 반환.</li>
</ul>
<ol>
<li>2차원 배열의 선언과 동시에 초기화하는 방법</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>가변 배열(dynamic arrya)</li>
</ol>
<ul>
<li>2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장할 수 있다.</li>
<li>이렇게 행마다 다른 길이의 배열을 저장할 수 있는 배열을 **가변 배열(dynami array)**이라고 한다.</li>
<li>배열을 생성할 때 열에 해당하는 인덱스를 생략하면 가변 배열을 만들 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>가변 배열도 초기화 블록을 사용해 배열을 선언과 동시에 초기화할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="배열의-복사"># 배열의 복사</h1>
<ul>
<li>배열은 한 번 생성하면 그 길이를 변경할 수 없다.</li>
<li>더 많은 데이터를 저장하기 위해서는 더 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다.</li>
<li>배열의 복사를 위해 다음과 같은 방법이 존재한다.</li>
</ul>
<ol>
<li>System 클래스의 <strong>arraycopy()</strong> 메소드
<ul>
<li>가장 좋은 성능을 보이며, 배열의 복사만을 위해 만들어짐</li>
</ul>
</li>
<li>Arrays 클래스의 <strong>copyOf()</strong> 메소드
<ul>
<li>현재 배열의 복사를 위해 가장 많이 사용되며, 좀 더 유연함</li>
</ul>
</li>
<li>Object 클래스의 <strong>clone()</strong> 메소드
<ul>
<li>이전 배열과 같은 길이의 배열밖에 만들 수 없음</li>
</ul>
</li>
<li>for문과 인덱스를 이용한 복사</li>
</ol>
<ul>
<li><code>arraycopy(), copyOf() 메소드와 for문을 이용한 복사</code>는 배열의 길이를 마음대로 늘일 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> newLen = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 1. System 클래스의 arraycopy() 메소드</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[newLen];</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr2, <span class="number">0</span>, arr1.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Arrays 클래스의 copyOf() 메소드</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = Arrays.copyOf(arr1, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Object 클래스의 clone() 메소드</span></span><br><span class="line"><span class="keyword">int</span>[] arr4 = (<span class="keyword">int</span>[])arr1.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for 문과 인덱스를 이용한 복사</span></span><br><span class="line"><span class="keyword">int</span>[] arr5 = <span class="keyword">new</span> <span class="keyword">int</span>[newLen];</span><br></pre></td></tr></table></figure>
<h1 id="enhanced-for문"># Enhanced for문</h1>
<ul>
<li>JDK 1.5부터는 배열과 컬렉션의 모든 요소를 참조하기 위한 <code>Enhanced for문</code>이라는 반복문이 새롭게 추가되었다.</li>
<li>이 반복문은 배열과 컬렉션 프레임워크에서 유용하게 사용됩니다.</li>
</ul>
<p><strong>Enhanced for문</strong>은 명시한 배열이나 컬렉션의 길이만큼 반복되어 실행됩니다. 루프마다 각 요소는 명시한 변수의 이름으로 저장되며, 명령문에서는 이 변수를 사용하여 각 요소를 참조할 수 있습니다.</p>
<p><strong>예시</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(타입 변수명 : 배열 또는 컬렉션)&#123;</span><br><span class="line">    <span class="comment">// 반복할 문장</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e : arr)&#123;</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>타입은 배열 또는 컬렉션의 요소 타입과 일치해야 한다.</li>
<li>배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.</li>
<li>하지만, Enhanced for문은 요소를 참조할 때만 사용하는 것이 좋으며, 요소의 값을 변경하는 작업에는 적합하지 않습니다. 다음 코드를 통해 확인할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">    arr1[i]+=<span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e : arr2)&#123;</span><br><span class="line">    e+=<span class="number">10</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : arr1)</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : arr2)</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>1번에서는 for문을 이용하여 각 배열 요소에 10을 더하고 있다. for문을 사용하면, 각 배열 요소의 값을 쉽게 변경할 수 있다.</li>
<li>2번에서는 Enhanced for문을 이용하여 각 배열 요소에 10을 더하고 있다. 하지만 실행 결과를 살펴보면, 원본 배열에는 아무런 변화가 없음을 알 수 있다.</li>
<li>이유는 Enhanced for문 내부에서 사용되는 배열 요소는 배열 요소 그 자체가 아닌 <strong>배열 요소의 복사본</strong>이기 때문이다. 따라서 Enhanced for문에서 배열 요소의 값을 변경하여도 원본 배열에는 아무런 영향을 주지 못하게 된다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/06/java-basic-4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/06/java-basic-3/"
                            aria-label=": [Java] 3. 제어문"
                        >
                            [Java] 3. 제어문
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-06T18:41:07+09:00">
	
		    Aug 06, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="제어문"># 제어문</h1>
<ul>
<li>원하는 결과를 얻기 위해서 순차적인 흐름을 제어해야 하는 경우가 생긴다. 이 때 사용하는 명령문을 <strong>제어문</strong>이라고 하며, 조건문과 반복문 등이 이에 해당한다.</li>
</ul>
<h2 id="조건문">조건문</h2>
<ul>
<li>주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.</li>
<li>가장 기본이 되는건 if문이다.</li>
</ul>
<p><strong>1. if문</strong></p>
<p>조건식의 결과가 <strong>참</strong>이면 주어진 명령문을 실행하며, <strong>거짓</strong>이면 아무것도 실행하지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"이승우"</span>;</span><br><span class="line"><span class="keyword">if</span>(name == <span class="string">"이승우"</span>)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">// 조건식의 결과가 참일 때 실행하고자 하는 명령문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. if / else 문</strong></p>
<p>if문과 함께 사용하는 else문은 if문과는 반대로 주어진 조건식의 결과가 <strong>거짓</strong>이라면 주어진 명령문을 실행한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"해당 문자는 영문 소문자입니다."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"해당 문자는 영문 소문자가 아닙니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. if/ else if / else 문</strong></p>
<p>if/else if/else문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if/else 문이 연달아 나온 것뿐입니다. 이러한 if/else if/else문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if문을 좀 더 간결하게 표현할 수 있습니다.</p>
<p><strong>4. switch문</strong></p>
<p>if/else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문이다. 이러한 switch문은 if/else 보다 <strong>가독성이 더 좋으며</strong>, 컴파일러가 최적화를 쉽게 할 수 있어 <strong>속도 또한 빠른 편</strong>이다.</p>
<p>하지만 switch문의 조건 값으로는 int형으로 승격할 수 있는(integer promotion) 값만이 사용될 수 있다. 즉, 자바에서는 switch 문의 조건 값으로 byte, short, char, int 형의 변수나 리터럴을 사용할 수 있다.</p>
<p>또한, 이러한 기본 타입에 해당하는 데이터를 객체로 포장해주는 래퍼 클래스(Wrapper class) 중에서 위에 해당하는 Byte, Short, Character, Integer 클래스의 객체도 사용할 수 있습니다.</p>
<p>enum 키워드를 사용한 열거체(enumeration type)와 String 클래스의 객체도 사용할 수 있습니다. 따라서 switch문은 if/else 문보다는 사용할 수 있는 상황이 적습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 a입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 e입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 i입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 o입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 u입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 모음이 아닙니다."</span>)</span><br><span class="line">        breakl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>각 case절, default 절은 반드시 <strong>break</strong> 키워드를 포함해야 한다.</li>
<li>switch문에서 사용된 break 키워드는 조건 값에 해당하는 case/default절이 실행된 뒤에 switch문을 빠져나가게 해준다.</li>
<li>break 키워드가 없다면 해당 조건 이후의 case절이 전부 실행된다.</li>
</ul>
<p><strong>5.삼항 연산자에 의한 조건문</strong></p>
<ul>
<li>간단한 if/else 문은 삼항 연산자를 이용하여 간결하게 표현할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">조건식? 반환값<span class="number">1</span> : 반환값<span class="number">2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">조건식의 결과가 참이라면 반환값<span class="number">1</span>을 반환하고, </span><br><span class="line">거짓이라면 반환값<span class="number">2</span>를 반환합니다.</span><br></pre></td></tr></table></figure>
<h1 id="반복문"># 반복문</h1>
<ul>
<li>프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다.</li>
<li>프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나이다.</li>
</ul>
<h2 id="while문">while문</h2>
<p>while문은 특정 조건을 만족할 때까지 계속해서 주어진 명령문을 반복 실행합니다.</p>
<img src="/img/while.png" width="600" height="200">
<ul>
<li>먼저 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행한다.</li>
<li>그리고 조건식의 결과를 변경하는 명령문이 실행된다.</li>
<li>내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단한다.</li>
<li>조건식을 만족할 때까지 반복문을 수행한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    System.out.println((i+<span class="number">1</span>)+<span class="string">"번째 실행중 입니다."</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while문의 내부에 조건식의 결과를 변경하는 명령문이 존재하지 않을 때는 프로그램이 <strong>무한루프</strong>에 빠지게 된다. 이 경우 영원히 종료되지 않습니다.</li>
<li>while문을 작성할 때는 조건식의 결과가 어느 순간 거짓을 갖도록 조건식의 결과를 변경하는 명령문을 반드시 포함시켜야 한다.</li>
<li>위의 코드에서 <code>i++</code> 명령문을 제거하면 무한 루프에 빠지게 된다.</li>
</ul>
<h2 id="do-while문">do / while문</h2>
<p>while문은 루프에 진입하기 전에 먼저 조건식부터 검사한다. 하지만, <code>do/while</code>문은 먼저 루프를 한 번 실행한 후에 조건식을 검사한다. 즉, do/while문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행한다.</p>
<img src="/img/do_while.png" width="600" height="200">
<h2 id="for문">for문</h2>
<p><strong>for문</strong>은 while문과는 달리 자체적으로 <code>초기식, 조건식, 증감식</code>을 모두 포함하고 있는 반복문이다. 따라서 while문보다는 좀 더 간결하게 표현할 수 있다.</p>
<img src="/img/for.png" width="600" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">"for 문이 "</span> + (i + <span class="number">1</span>) + <span class="string">"번째 반복 실행중입니다"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"for 문이 종료된 후 변수 i의 값은 "</span>+ i + <span class="string">"입니다."</span>);</span><br></pre></td></tr></table></figure>
<p>for문 안에서만 사용하는 변수를 초기식에서 직접 선언할 수 있습니다. 이렇게 for문에서 직접 선언된 변수는 for문이 종료되면 같이 <strong>소멸</strong>된다.</p>
<h1 id="기타-제어문"># 기타 제어문</h1>
<p>일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행한다. 하지만, <strong>continue</strong>문과 <strong>break</strong>문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와준다.</p>
<h2 id="continue문">continue문</h2>
<p>루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 <strong>다음 조건식의 판단으로 넘어가게 해준다.</strong> 보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span> || i%<span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="break문">break문</h2>
<p>루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행한다. 즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용한다. <strong>가장 가까운 반복문을 빠져나가는 것이다.</strong></p>
<h2 id="이름을-가지는-반복문break-with-label">이름을 가지는 반복문(break with label)</h2>
<p>일반적인 break문은 단 하나의 반복문만을 빠져나가게 해준다. 따라서 여러 반복문이 중첩된 상황에서 한 번에 모든 반복문을 빠져나가거나, 특정 반복문까지만 빠져나가고 싶을 때는 다른 방법을 사용해야 한다.</p>
<p>이때 사용할 수 있는 방법이 반복문에 <strong>이름</strong>(label)을 설정하는 것이다. 가장 바깥쪽 반복문이나 빠져나가고 싶은 특정 반복문에 이름을 설정한 후, break 키워드 다음에 해당 이름을 명시하면 된다.</p>
<p>그러면 해당 break 키워드는 현재 반복문이 아닌 해당 이름의 반복문 바로 다음으로 프로그램의 실행을 옮겨준다.</p>
<p>단, 이때 이름(label)은 가리키고자 하는 반복문의 키워드 바로 앞에 위치해야 한다. 이름과 반복문의 키워드 사이에 명령문이 존재하면, 자바 컴파일러는 오류를 발생시킨다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">llLoop :</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> llLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i + <span class="string">" * "</span> + j + <span class="string">" = "</span> + (i * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"구구단 4단까지 출력!"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line"><span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span></span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> * <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="number">4</span> * <span class="number">8</span> = <span class="number">32</span></span><br><span class="line"><span class="number">4</span> * <span class="number">9</span> = <span class="number">36</span></span><br></pre></td></tr></table></figure>
<ul>
<li>이름(label)을 가지는 반복문을 통해서 구구단 2단~4단까지 출력하는 코드이다.</li>
<li>C언어나 C++과는 달리 자바에는 goto문이 없다. 이렇게 반복문을 가리키는 <code>이름(label)</code>은 break문이나 continue문에만 사용될 수 있다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/06/java-basic-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/03/java-basic-2/"
                            aria-label=": [Java] 2. 연산자"
                        >
                            [Java] 2. 연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-03T23:41:53+09:00">
	
		    Aug 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="연산자"># 연산자</h1>
<ul>
<li>
<p>x&lt;&lt;2+1 : 쉬프트 연산자(&lt;&lt;)는 덧셈 연산자보다 우선순위가 낮습니다. 그래서 해당 식은 <code>x&lt;&lt;(2+1)</code>과 같습니다.</p>
</li>
<li>
<p>data &amp; 0xFF == 0 : 논리연산자(&amp;)는 비교연산자(==)보다 우선순위가 낮으므로 비교연산을 먼저 수행한 후에 논리연산이 수행됩니다. 따라서 해당 식은 <code>data &amp; (0xFF == 0)</code>과 같습니다.</p>
</li>
<li>
<p>x&lt;-1 || x&gt;3 &amp;&amp; x&lt;5 : 논리연산자 중에서 AND를 의미하는 &amp;&amp;가 OR을 의미하는 ||보다 우선순위가 높습니다. 그래서 해당 식은 <code>x&lt;-1 || (x&gt;3 &amp;&amp; x&lt;5)</code>과 같습니다.</p>
</li>
<li>
<p>증감 연산자의 연산 순서 : 증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라집니다. 다음 예제를 통하여 확인해볼 수 있습니다.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = x-- + <span class="number">5</span> + --x;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"x : "</span>+x+<span class="string">", y : "</span>+y);</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">x : <span class="number">8</span>, y : <span class="number">23</span></span><br></pre></td></tr></table></figure>
<img src="/img/operation_process.png" width="400" height="200">
<ul>
<li><strong>instanceof 연산자</strong> : 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환해준다. 즉, 해당 객체가 어떤 클래스나 인터페이스로부터 생성되었는지를 판별해 주는 역할을 한다.
<ul>
<li>instanceof 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 <code>true</code>를, 아니면 <code>false</code>를 반환한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	A a = <span class="keyword">new</span> A();</span><br><span class="line">	B b = <span class="keyword">new</span> B();</span><br><span class="line">	System.out.println(a <span class="keyword">instanceof</span> A);</span><br><span class="line">	System.out.println(b <span class="keyword">instanceof</span> A);</span><br><span class="line">	System.out.println(a <span class="keyword">instanceof</span> B);</span><br><span class="line">	System.out.println(b <span class="keyword">instanceof</span> B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h2 id="형-변환">형 변환</h2>
<ul>
<li><code>산술 변환</code> : 연산을 수행하기 전 피연산자 타입의 일치를 위해 <strong>자동 형 변환</strong>되는 것을 말한다. 이항 연산뿐만 아니라 단항 연산에서도 일어난다. 규칙은 다음과 같습니다.</li>
</ul>
<ol>
<li>
<p><strong>두 피연산자의 타입을 같게 일치시킨다.</strong> <strong>(보다 큰 타입으로 일치)</strong></p>
<ul>
<li>피연산자의 값 손실을 최소화한다.</li>
<li>long + int -&gt; long + long -&gt; long</li>
<li>float + int -&gt; float + float -&gt; float</li>
</ul>
</li>
<li>
<p><strong>피연산자의 타입이 int보다 작은 타입이면 int로 변환됩니다.</strong></p>
<ul>
<li>JVM의 피연산자 스택이 피연산자를 4 Byte로 저장하기 때문에 int형보다 작은 데이터 타입은 int형으로 변환된 후 연산이 수행된다.</li>
</ul>
<ul>
<li>byte + short -&gt; int + int -&gt; int</li>
<li>char + short -&gt; int + int -&gt; int</li>
</ul>
</li>
</ol>
<ul>
<li>그리고 int보다 작은 타입, 예를 들면 char나 short의 표현범위가 좁아서 연산 중에 <strong>오버플로우</strong>(Overflow)가 발생할 가능성이 높기 때문에 만들어진 것입니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">1000000</span> * <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">1000000</span> * <span class="number">1000000L</span>;</span><br><span class="line">System.out.println(<span class="string">"a = "</span>+a);</span><br><span class="line">System.out.println(<span class="string">"b = "</span>+b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">a = -<span class="number">727379968</span>;</span><br><span class="line">b = <span class="number">1000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 '1000000 * 1000000’의 결과가 1000000000000(2 * 10의 12승)임에도 불구하고, -727379968라는 결과가 출력된다.</p>
<p>그 이유는 int 타입과 int 타입의 연산 결과는 int 타입인데, 연산결과가 int 타입의 최대 값인 1000000000(2 * 10의 9승)을 넘으므로 오버플로우(Overflow)가 발생했기 때문이다. <strong>이미 오버플로우가 발생한 값을 아무리 long 타입의 변수에 저장해도 소용 없다.</strong></p>
<p>b에서 처럼 1000000L으로 <strong>형 변환</strong>을 통해서 1000000도 long형으로 타입을 맞춘 후에 연산을 수행한 값을 long형 타입의 변수 b에 저장한다면 올바른 결과를 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>; <span class="comment">// c1에는 문자 'a'의 코드값인 97이 저장됩니다.</span></span><br><span class="line"><span class="keyword">char</span> c2 = c1; <span class="comment">// c1에 저장되어 있는 값이 c2에 저장됩니다.</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">' '</span>; <span class="comment">// c3를 공백으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = c1 + <span class="number">1</span>; <span class="comment">// 'a'+1 -&gt; 97 + 1 -&gt; 98</span></span><br><span class="line"></span><br><span class="line">c3 = (<span class="keyword">char</span>)(c1+<span class="number">1</span>);</span><br><span class="line">c2++;</span><br><span class="line">c3++;</span><br></pre></td></tr></table></figure>
<p>위 예제에서 c2++; 대신에 c2 = c2+1;을 사용하면 에러가 발생하게 됩니다. 이유는 c2+1의 연산결과는 int형이며, 그 결과를 다시 c2에 담으려면 형변환 연산자를 이용해 char형으로 형변환해야 하기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = c2+<span class="number">1</span>; <span class="comment">// 컴파일 에러 발생 O</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'a'</span>+<span class="number">1</span>; <span class="comment">// 컴파일 에러 발생 X</span></span><br></pre></td></tr></table></figure>
<p>‘a’+1은 <strong>리터럴</strong>간의 연산이기 때문에 에러가 발생하지 않는다. 상수 또는 리터럴 간의 연산은 실행과정 동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. 컴파일러가 미리 덧셈 연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다. 수식에 변수가 들어가있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형 변환을 해줘야 한다.<br>
<code>char ch2 = (char)(c1+1)</code> 그렇지 않으면 컴파일 에러가 발생한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure>
<p>float 타입의 값을 double 타입으로 형 변환하면, 부호와 지수는 달라지지 않고 그저 기수의 빈자리를 0으로 채울뿐이므로 0.1f를 double 타입으로 형 변환해도 그 값은 여전히 달라지지 않는다.</p>
<p><strong>즉, float 타입의 값을 정밀도가 더 높은 double 타입으로 형변환했다고 해서 오차가 적어지는 것은 아니다.</strong></p>
<h2 id="와-equals-차이">==와 equals() 차이</h2>
<ol>
<li>형태의 차이<br>
가장 단순한 차이점은 형태의 차이다.</li>
</ol>
<ul>
<li>equals()는 메소드이다. 객체끼리 내용을 비교할 수 있도록 한다.</li>
<li>== 는 비교를 위한 연산자이다.</li>
</ul>
<ol start="2">
<li>주소값 비교와 내용 비교<br>
비교할 수 있는 대상에 대한 부분이다.</li>
</ol>
<ul>
<li>equals() 메소드는 비교하고자 하는 <strong>대상의 내용 자체를 비교</strong>한다.</li>
<li>== 연산자는 비교하고자 하는 대상의 <strong>주소값을 비교</strong>한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(str1 == str2)&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"같은 문자열입니다."</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 	System.out.println(<span class="string">"다른 문자열입니다."</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str1.equals(str2))&#123;</span><br><span class="line">	System.out.println(<span class="string">"같은 문자열입니다."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"다른 문자열입니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str1과 str2의 내용이 &quot;abc&quot;로 같은데도 <code>==</code>로 비교하면 false의 결과를 얻게 된다. <strong>내용은 같지만 str1과 str2가 서로 다른 객체이기 때문이다.</strong> 그러나 <strong>equals()는 객체가 달라도 내용이 같으면 true를 반환한다.그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다.</strong></p>
<h2 id="효율적인-연산">효율적인 연산</h2>
<ul>
<li>효율적인 연산
<ul>
<li>OR 연산 '||'의 경우, 두 피연산자 중 어느 한 쪽만 '참’이어도 전체 연산결과가 '참’이므로 좌측 피연산자가 'true(참)'이면, 우측 피연산자의 값은 평가하지 않는다.</li>
<li>AND 연산 '&amp;&amp;'의 경우, 어느 한 쪽만 '거짓(0)'이어도 전체 연산결과가 '거짓(0)'이므로 좌측 피연산자가 '거짓(0)'이면, 우측 피연산자의 값은 평가하지 않는다.</li>
</ul>
</li>
</ul>
<p>비트 XOR 연산자 '^'는 두 피연산자의 비트가 다를 때만 1이 된다. 그리고 <strong>같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아온다는 특징이 있어서 간단한 암호화에 사용된다.</strong></p>
<p>비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산 결과는 32자리의 2진수입니다.</p>
<p>쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int 타입으로 자동 변환되고 연산결과 역시 int 타입이 됩니다. 그러나 쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않습니다.</p>
<!--변수 앞에 키워드 `final`을 붙이면 상수가 됩니다. 상수는 반드시 선언과 동시에 값을 저장해야하며, 한 번 저장된 값은 바꿀 수 없습니다.-->

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/03/java-basic-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/01/java-basic-1/"
                            aria-label=": [Java] 1. 타입"
                        >
                            [Java] 1. 타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-01T01:45:03+09:00">
	
		    Aug 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바의 기초적인 문법과 개념을 정리하는 공간</p>
<h1 id="java-program"># Java Program</h1>
<ul>
<li>한 개 이상의 <strong>클래스</strong>로 구성된다.</li>
<li>클래스는 한 개 이상의 필드나 메소드로 구성된다.</li>
<li>main() 메소드를 가지는 클래스가 반드시 하나 존재해야 한다.</li>
<li><strong>소스 파일의 이름은 해당 public 클래스의 이름과 같아야 한다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Victory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Victory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="변수variable"># 변수(variable)</h1>
<ul>
<li>데이터를 저장할 수 있는 <strong>메모리 공간</strong>을 의미.</li>
<li>저장된 값은 변경 가능하다.</li>
</ul>
<h2 id="변수의-이름-생성-규칙">변수의 이름 생성 규칙</h2>
<ul>
<li>변수의 이름은 해당 변수에 저장될 <strong>데이터의 의미</strong>를 잘 나타내도록 짓는 것이 좋다.</li>
</ul>
<ol>
<li>영문자(대소문자), 숫자, 언더스코어,달러($)로만 구성할 수 있다.</li>
<li>숫자로 시작할 수 없다.</li>
<li>변수의 이름 사이에는 공백을 포함할 수 없다.</li>
<li>자바에서 미리 정의된 키워드를 사용할 수는 없다.</li>
</ol>
<h2 id="변수의-종류">변수의 종류</h2>
<ul>
<li>기본형 변수(primitive type)
<ul>
<li>계산을 위해 <strong>실제 연산</strong>에 사용되는 변수.</li>
<li>논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)</li>
</ul>
</li>
<li>참조형 변수(reference type)
<ul>
<li>8개의 기본형을 제외한 나머지 타입이다.</li>
<li>객체의 주소를 저장한다.</li>
</ul>
</li>
</ul>
<ul>
<li>덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합합니다.</li>
<li><strong>참조변수의 출력이나 덧셈 연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리합니다.</strong></li>
</ul>
<h2 id="변수의-선언과-초기화">변수의 선언과 초기화</h2>
<ul>
<li>변수 선언만 한다.
<ul>
<li>변수를 선언하여 메모리 공간을 할당 받는다.</li>
<li>초기화하지 않았으므로 쓰레기 값이 들어간다.</li>
<li>반드시 초기화 이후에 사용해야 한다. 그렇지 않으면 컴파일 오류 발생.</li>
</ul>
</li>
<li>변수 선언과 초기화를 동시에 한다.
<ul>
<li>선언과 동시에 초기화한다.</li>
<li>타입이 같으면 동시에 선언 및 초기화 가능.</li>
</ul>
</li>
</ul>
<h1 id="상수constant"># 상수(constant)</h1>
<ul>
<li>변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간.</li>
<li>변수와 다르게 저장된 데이터를 <strong>변경할 수 없다.</strong></li>
<li>선언과 동시에 초기화해야 한다.</li>
<li><code>final</code> 키워드를 사용하여 선언한다.</li>
<li>통상적으로 상수는 <strong>대문자</strong>를 사용해 선언한다. 길 경우 언더스코어 사용.</li>
</ul>
<p><strong>리터럴(literal)</strong></p>
<p>상수의 다른 이름이다.<br>
값 그 자체를 의미한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">30</span>; <span class="comment">// 30이 리터럴</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> AGES = <span class="number">100</span>; <span class="comment">// 100이 리터럴</span></span><br></pre></td></tr></table></figure>
<p><strong>리터럴 타입 접미사(literal type suffix)</strong></p>
<p>자바에서 3.14와 같은 실수형 리터럴을 그대로 사용하면, 해당 리터럴은 실수형 타입 중에서도 double로 인식할 것이다.<br>
하지만, 실수형 리터럴 맨 뒤에 F나 f를 추가하면, 자바는 해당 실수형 리터럴을 float형으로 인식할 것이다.</p>
<p>이처럼 리터럴 뒤에 추가되어 해당 리터럴의 타입을 명시해주는 접미사를 <strong>리터럴 타입 접미사</strong>(lister type suffix)라고 한다.</p>
<img src="/img/literal.png" width="800" height="300">
<center>자바에서 사용할 수 있는 리터럴 타입 접미사</center>
<h1 id="기본형-데이터-타입의-범위"># 기본형 데이터 타입의 범위</h1>
<img src="/img/primitive_type_range.png" width="800" height="300">
<ul>
<li>타입은 데이터가 메모리에 어떻게 저장되는지, 처리되는지 명시적으로 알려준다.</li>
</ul>
<p><strong>boolean</strong></p>
<ul>
<li>저장 가능한 범위 true / false</li>
<li>Java에서 데이터를 다루는 최소 범위가 1 Byte이기 때문에 낭비적이긴 하지만 1 Byte 사용.</li>
</ul>
<p><strong>char</strong></p>
<ul>
<li>Unicode를 사용. 동양 글자의 경우 2Byte가 필요하기 때문에 char의 경우 2Byte 사용.</li>
<li>유일하게 제공되는 Unsinged 형태(음수가 존재하지 않는다.)</li>
<li>맨 앞 1bit로 음수나 양수를 나타내지만 char형은 unsinged 형식이기 때문에 맨 앞 비트를 음수, 양수 형식으로 사용하지 않는다.</li>
<li>char 형은 유니코드 정수 형태로 저장한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = &apos;A&apos;</span><br><span class="line">a 변수에는 &apos;A&apos;의 정수 값인 65가 들어간다.</span><br></pre></td></tr></table></figure>
<p>JVM의 피연산자 스택이 피연산자를 4 Byte 단위로 저장하기 때문에 int 형보다 작은 자료형의 값을 계산할 때 int 형으로 형 변환하고 연산이 수행된다.</p>
<p>정수형 데이터를 사용하게 되면 JVM에서 기본적으로 int 형 데이터 타입의 데이터로 인식을 한다.</p>
<ul>
<li>int형 데이터 타입의 범위를 넘는 long 타입의 정수를 사용하고자 하는 경우에는 정수 데이터 맨 뒤쪽에 접미사 ‘l<br>
’ 또는 'L’을 붙여줘야 한다.</li>
</ul>
<img src="/img/data_type.png" width="600" height="300">
<center><b>정수형 데이터 타입</b></center>
<p><strong>오버플로우와 언더플로우</strong></p>
<p>데이터를 저장할 때는 데이터의 크기를 고려해서 적절한 데이터 타입을 사용해야 한다. 그렇지 않으면 데이터 손실이 생긴다.</p>
<ul>
<li>오버 플로우 : 해당 타입이 표현할 수 있는 최대 범위를 벗어난 데이터를 저장할 경우 발생한다. 다른 값이 저장될 수 있다.</li>
<li>언더 플로우 : 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생한다.</li>
</ul>
<h1 id="실수"># 실수</h1>
<p>실수란 <strong>소수부</strong>와 <strong>지수부</strong>가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다. double 형이 기본 데이터 타입이다.</p>
<ol>
<li><strong>float</strong></li>
<li><strong>double</strong></li>
</ol>
<img src="/img/float_double1.png" width="600" height="300">
<img src="/img/float_double2.png" width="600" height="300">
<p>컴퓨터에서 실수를 표현하는 방식은 오차가 발생할 수 밖에 없는 태생적 한계를 지닌다. 이러한 실수형 데이터의 오차는 자바뿐만 아니라 모든 프로그래밍 언어에서 발생하는 공통된 문제입니다.</p>
<h1 id="실수의-표현"># 실수의 표현</h1>
<p>컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡합니다. 왜냐하면, 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표현해야 하기 때문이다.<br>
두 가지의 방법이 사용되고 있다.</p>
<h2 id="고정-소수점-방식fixed-point">고정 소수점 방식(fixed point)</h2>
<p>실수는 보통 <strong>정수부</strong>와 <strong>소수부</strong>로 나눌 수 있다. 따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 고정하여 고정된 자릿수의 소수를 표현하는 것이다.</p>
<img src="/img/fixed_point.png" width="600" height="300">
<p>위 그림은 32비트 실수를 고정 소수점 방식으로 표현한 것이다. 하지만, 이 방식은 정수부와 소수부의 자릿수가 크지 않으므로 표현할 수 있는 범위가 매우 적다는 단점이 있다.</p>
<h2 id="부동-소수점-방식floating-point">부동 소수점 방식(floating point)</h2>
<p>실수는 보통 정수부와 소수부로 나누지만, <strong>가수부</strong>와 <strong>지수부</strong>로 나누어 표현할 수도 있다. 부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식이다.</p>
<p>앞서 살펴본 고정 소수점 방식은 제한된 자릿수로 인해 표현할 수 있는 범위가 매우 작다. 하지만, 부동 소수점 방식은 다음의 수식을 이용하여 매우 큰 실수까지도 표현할 수 있게 되었다.</p>
<img src="/img/operation.png" width="600" height="300">
<p>현재 대부분의 시스템에서는 부동 소수점 방식으로 실수를 표현하고 있다.</p>
<h2 id="ieee-부동-소수점-방식">IEEE 부동 소수점 방식</h2>
<p>현재 사용되고 있는 부동 소수점 방식은 대부분 <strong>IEEE 754</strong> 표준을 따르고 있다.</p>
<p>32비트(4바이트)의 float형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다.</p>
<img src="/img/floating.png" width="600" height="300">
<p>64비트의 double형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다.</p>
<img src="/img/floating2.png" width="600" height="300">
<p>지수 필드의 비트 수가 늘어나면 표현 가능한 수의 범위가 확장되고, 가수 필드의 비트 수가 늘어나면 정밀도가 증가한다.</p>
<h2 id="부동-소수점-방식의-오차">부동 소수점 방식의 오차</h2>
<p>부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있다. 하지만, <code>부동 소수점 방식</code>에 의한 실수의 표현은 <strong>항상 오차가 존재</strong>한다는 단점을 가지고 있다.</p>
<p>부동 소수점 방식에서의 오차는 앞에서 본 공식에 의해 발생한다. 이 공식을 사용하면 표현할 수 있는 범위는 늘어나지만, 10진수를 정확하게 표현할 수는 없게 된다. 따라서 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임을 항상 명심해야 한다.</p>
<h2 id="타입-변환">타입 변환</h2>
<ul>
<li>하나의 타입을 다른 타입으로 바꾸는 것이다.</li>
<li>boolean형을 제외한 나머지 기본 타입 간의 타입 변환을 자유롭게 수행할 수 있다.</li>
</ul>
<p>다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입 -&gt; 큰 타입으로의 변환은 생략할 수 있다.</p>
<p>하지만, 메모리에 할당받은 바이트의 크기가 큰 타입 -&gt; 작은 타입으로의 타입 변환은 데이터의 손실이 발생한다. 따라서 상대적으로 바이트의 크기가 작은 타입으로 타입 변환을 할 경우 자바 컴파일러는 오류를 발생시킨다.</p>
<h3 id="묵시적-타입-변환자동-타입-변환">묵시적 타입 변환(자동 타입 변환)</h3>
<p>대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환을 가리킨다. <strong>자바에서는 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환을 진행합니다.</strong><br>
또한, 자바에서는 데이터의 손실이 발생하는 대입 연산은 허용하지 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num1 = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">3.14</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">double</span> num3 = <span class="number">7.0f</span> + <span class="number">3.14</span>; <span class="comment">//3</span></span><br><span class="line">System.out.println(num1);</span><br><span class="line">System.out.println(num3);</span><br></pre></td></tr></table></figure>
<p>1번<br>
double형 변수에 int형 데이터를 대입한다.<br>
int형 데이터 -&gt; double형 데이터 : 자동 형 변환된다.</p>
<p>2번<br>
int형 변수가 표현할 수 있는 범위보다 더 큰 double형 데이터를 대입하므로 데이터의 손실이 발생한다.<br>
이 대입 연산의 경우 컴파일러가 오류를 발생시킨다.</p>
<p>3번<br>
데이터의 손실이 최소화되도록 float형 데이터 -&gt; double형 데이터로 자동 형 변환시킨다.</p>
<p><strong>자바 컴파일러가 자동으로 수행하는 타입 변환은 데이터의 손실이 최소화되는 방향으로 이루어진다.</strong> 따라서 자바에서는 타입의 표현 범위에 따라 다음과 같은 방향으로 자동 타입 변환이 이루어집니다.</p>
<img src="/img/java_type_conversion.jpg" width="600" height="300">
<h3 id="명시적-타입-변환강제-타입-변환">명시적 타입 변환(강제 타입 변환)</h3>
<p>사용자가 타입 캐스트 연산자 (())를 사용하여 강제적으로 수행하는 타입 변환을 말한다.</p>
<p>다음과 같은 방법으로 명시적 타입 변환을 수행할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(변환할 타입) 변환할 데이터</span><br></pre></td></tr></table></figure>
<p>변환시키고자 하는 데이터의 앞에 괄호 (())를 넣고, 그 괄호 안에 변환할 타입을 적으면 된다.이 괄호를 <code>타입 캐스트(type cast)</code> 연산자라고 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result1 = num1 / num2;</span><br><span class="line"><span class="keyword">double</span> resutl2 = (<span class="keyword">double</span>) num1 / num2; <span class="comment">// 강제 타입 변환</span></span><br><span class="line"></span><br><span class="line">System.out.println(result1);</span><br><span class="line">System.out.println(resutl2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>result1은 나눗셈의 결과로는 0이 반환된다. 자바에서 산술 연산을 수행하고 얻는 결과값의 타입은 언제나 피연산자의 타입과 일치해야 합니다. 즉, int형 데이터끼리 산술 연산에 대한 결과값은 언제나 int형 데이터의 결과가 나오게 된다.</p>
<p>따라서 <code>1/4</code>의 결과로는 0.25가 반환되지만, int형으로 자동 타입 변환되어 0이 반환되게 된다. 그리고서 double형 변수에 그 결과가 대입될 때, double형으로 자동 타입 변환되어 0.0이라는 결과가 출력된다. 데이터가 손실되었다.</p>
<p>정확한 결과를 얻고자 한다면 result2처럼 피연산자 중 하나의 타입을 double형으로 강제 타입 변환을 해야 한다. 이렇게 피연산자 중 하나의 타입이 double형이 되면, 나눗셈 연산을 위해 나머지 하나의 피연산자도 double형으로 자동 타입 변환된다. 따라서 그 결과 또한 double형인 0.25가 될 것이며, 이 결과가 double형 변수에 제대로 대입될 것이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/01/java-basic-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/03/19/JavaCollectionPriorityQueue/"
                            aria-label=": 자바 :: Priority Queue?"
                        >
                            자바 :: Priority Queue?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-03-19T17:11:16+09:00">
	
		    Mar 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 <code>Priority Queue</code>에 대해서 공부를 해보았습니다.</p>
<h2 id="priority-queue">Priority Queue</h2>
<p>일반적으로 Queue라는 자료구조는 <code>선입선출(First-In-First-Out)</code>의 대기열 규칙을 갖고 있습니다. 즉, 큐에 삽입될 때의 시간이 큐에서의 순서를 결정하게 됩니다.<br>
그러나 <code>우선순위 큐</code>는 입력 시간이 아닌 다른 조건으로 큐내에서의 순서를 결정할 수 있는데, 이 때 <strong>List</strong>에서 배운 <code>Comparator</code> 인터페이스가 큐 내에서의 순서를 결정하는 역할을 하게 됩니다.</p>
<h3 id="사용법">사용법</h3>
<blockquote>
<p>import.java.util.PriorityQueue를 <strong>import</strong>하여 사용합니다.</p>
</blockquote>
<p>사용법은 <strong>Queue</strong>와 동일한 메소드를 사용합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 기본 생성자. 객체의 기본 비교 CompareTo를 사용한다. </span><br><span class="line">PriorityQueue&lt;Integer&gt; pa = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">// 기본 배열크기, 비교함수를 인자로 받는 생성자.</span><br><span class="line">PriorityQueue&lt;Integer&gt; pa = new PriorityQueue&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="메소드">메소드</h3>
<h4 id="삽입-offeradd">삽입 - offer,add</h4>
<p>큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다.</p>
<h4 id="제거-pollremove">제거 - poll,remove</h4>
<p>큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다.</p>
<p><code>poll</code>은 큐가 비어있다면 <strong>null</strong>을 반환<br>
<code>remove</code>는 큐가 비어있다면 <strong>예외</strong> 발생</p>
<h4 id="읽기-peekelement">읽기 - peek,element</h4>
<p>큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다.<br>
<code>peek</code>은 큐가 비어있다면 <strong>null</strong>을 반환<br>
<code>element</code>은 큐가 비어있다면 <strong>예외</strong> 발생</p>
<h3 id="사용">사용</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PriorityQueue&lt;Prisoner&gt; pq = new PriorityQueue&lt;Prisoner&gt;();</span><br><span class="line">		</span><br><span class="line">Prisoner ps1 = new Prisoner(&quot;박보검&quot;,20);</span><br><span class="line">Prisoner ps2 = new Prisoner(&quot;하정우&quot;,3);</span><br><span class="line">Prisoner ps3 = new Prisoner(&quot;이준기&quot;,50);</span><br><span class="line">Prisoner ps4 = new Prisoner(&quot;강하늘&quot;,10);</span><br><span class="line">Prisoner ps5 = new Prisoner(&quot;박서준&quot;,2);</span><br><span class="line">		</span><br><span class="line">pq.offer(ps1);</span><br><span class="line">pq.offer(ps2);</span><br><span class="line">pq.offer(ps3);</span><br><span class="line">pq.offer(ps4);</span><br><span class="line">pq.offer(ps5);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;사이즈:&quot;+pq.size());</span><br><span class="line">		</span><br><span class="line">	while(!pq.isEmpty())&#123;</span><br><span class="line">		Prisoner prisoner = pq.poll();</span><br><span class="line">		System.out.println(prisoner.name);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">System.out.println(&quot;----------Reverse&quot;);</span><br><span class="line">		</span><br><span class="line">PriorityQueue&lt;Prisoner&gt; reversedPriorityQueue = new PriorityQueue&lt;Prisoner&gt;(pq.size(), Collections.reverseOrder());</span><br><span class="line">reversedPriorityQueue.addAll(pq);</span><br><span class="line">		</span><br><span class="line">	while(!reversedPriorityQueue.isEmpty())&#123;</span><br><span class="line">		Prisoner prisoner2 = reversedPriorityQueue.poll();</span><br><span class="line">		System.out.println(prisoner2.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Prisoner implements Comparable&lt;Prisoner&gt;&#123;</span><br><span class="line">	String name;</span><br><span class="line">	int weight;</span><br><span class="line">	</span><br><span class="line">	public Prisoner(String name, int weight)&#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">		this.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Prisoner ps) &#123;</span><br><span class="line">		if(this.weight&gt;ps.weight)&#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;else if(this.weight&lt;ps.weight)&#123;</span><br><span class="line">			return -1;</span><br><span class="line">		&#125;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	// 이 상태는 오름차순인데, </span><br><span class="line">	// Comparable을 구현하고, compareTo 메소드를 사용해서 내림차순을 구현하려면</span><br><span class="line">	// return 하는 값을 바꾸면 된다. 1 대신에 -1을 -1 대신에 1을!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>우선순위 큐에서 값을 <code>poll()</code>이라는 함수를 통해서 꺼내게 되면 가장 작은 값부터 꺼낼 수 있게 됩니다.<br>
그 이유는 우선순위 큐는 내부적으로 <code>Natural Ordering</code>에 따라서 정렬하는 큐이기 때문입니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pQueue = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">for (int i =10; i&gt;0; i--)</span><br><span class="line">&#123;</span><br><span class="line">      pQueue.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System. out .println(pQueue.peek());</span><br></pre></td></tr></table></figure>
<p>실제로 위의 예를 실행해보면 <code>peek()</code> 메소드를 통해서 <strong>head</strong> 에 있는 값을 가져오는데, 10이 아니라 1을 가져오는 것을 확인할 수 있습니다. 그것은 <code>Priority Queue</code>가 natural Ordering에 따라서 정렬하기 때문에 가장 작은 값이 <strong>head</strong> 부분에 위치하는 것을 알 수 있습니다.<br>
그리고 <code>Priority Queue</code>는 Null을 허용하지 않습니다. <strong>Natural Ordering</strong>에 기초하고 있기 때문에 정렬할 수 없는 Null은 허용하지 않습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/03/19/JavaCollectionPriorityQueue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/03/08/java-collection-framework/"
                            aria-label=": Java :: Collection Framework"
                        >
                            Java :: Collection Framework
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-03-08T16:46:14+09:00">
	
		    Mar 08, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#CollectionFramework">Collection Framework</a>
<ul>
<li><a href="#%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">컬렉션 프레임워크 핵심 인터페이스</a></li>
<li><a href="#Collection-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4">Collection 인터페이스</a></li>
</ul>
</li>
<li><a href="#Array">Array</a>
<ul>
<li><a href="#%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%B3%B5%EC%82%AC">배열의 복사</a></li>
</ul>
</li>
</ol>
<blockquote>
<p>여기에서는 자바를 이용해 알고리즘 문제를 풀 때나 다른 프로그래밍을 할 때 주로 사용하는 <strong>Collection Framework</strong>에 대해 공부해보았습니다. 알고리즘 공부를 하면서 자료구조에 대한 공부를 시작하게 되었는데, 일반적으로 많이 사용되는 자료구조는 <code>리스트, 스택, 큐, 해쉬 테이블</code>이 있습니다.</p>
</blockquote>
<p>이전에 포스팅했던 자료들은 자료구조별로 정리했었는데, 모두 삭제하고 하나의 포스팅에 압축해서 공부하고 올리도록 하겠습니다. :)</p>
<h1 id="collectionframework">CollectionFramework</h1>
<p>자바에서 컬렉션 프레임워크(collection framework)란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.<br>
즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것입니다.</p>
<p>이러한 <strong>컬렉션 프레임워크</strong>는 자바의 인터페이스를 사용하여 구현됩니다.</p>
<h2 id="컬렉션-프레임워크-핵심-인터페이스">컬렉션 프레임워크 핵심 인터페이스</h2>
<p>컬렉션 프레임워크에서는 컬렉션(데이터 그룹)을 크게 3가지 타입으로 구분하여 3가지 인터페이스를 정의했습니다. 그리고 인터페이스 중 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의하였습니다.</p>
<p>인터페이스 List와 Set을 구현한 컬렉션 클래스들은 서로 많은 공통 부분이 있어서, 공통된 부분을 다시 뽑아 Collection 인터페이스를 정의할 수 있었지만, Map 인터페이스는 이들과는 전혀 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 못했습니다.</p>
<blockquote>
<p>주요 인터페이스 간의 상속 관계</p>
</blockquote>
<img src="/img/collection_framework.png" width="500" height="200">
<ul>
<li><strong>List</strong> : 순서가 있는 데이터의 집합. 데이터의 중복을 허용합니다.
<ul>
<li>구현 클래스 : ArrayList, LinkedList, Stack, Vector 등</li>
</ul>
</li>
<li><strong>Set</strong> : 순서를 유지하지 않는 데이터의 집합(순서가 없음). 데이터의 중복을 허용하지 않습니다.(Key)
<ul>
<li>구현 클래스 : HashSet, TreeSet 등</li>
</ul>
</li>
<li><strong>Map</strong> : 키(Key)와 값(value)의 쌍(Pair)으로 이루어진 데이터의 집합. 순서는 유지되지 않으며(순서가 없음), 키는 중복을 허용하지 않고, <strong>값은 중복을 허용합니다.</strong>
<ul>
<li>구현 클래스: HashMap, TreeMap, Hashtable, Properties 등</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이기 때문에 컬렉션 프레임워크의 명명법을 따르지 않습니다. Vector나 Hashtable과 같은 기존의 컬렉션들은 호환을 위해, 설계를 변경해서 남겨두었지만 가능하면 사용하지 않는 것이 좋다고 합니다. 그 대신 새로 추가된 <strong>ArrayList</strong>나 <strong>HashMap</strong>을 사용하는 것이 성능 면에서도 더 나은 결과를 얻을 수 있습니다.</p>
</blockquote>
<h2 id="collection-인터페이스">Collection 인터페이스</h2>
<p>List와 Set 인터페이스의 많은 공통된 부분을 Collection 인터페이스에서 정의하고, 두 인터페이스는 그것을 상속받습니다. 따라서 <strong>Collection 인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 동작들을 정의하고, 그것을 메소드로 제공하고 있습니다.</strong></p>
<ul>
<li>boolean add(Object o) : 지정된 객체(o)를 Collection에 추가합니다.</li>
<li>boolean addAll(Collection c) : 지정된 Collection©의 객체들을 Collection에 추가합니다.</li>
<li>void clear() : Collection의 모든 객체를 삭제합니다.</li>
<li>boolean contains(Object o) : 지정된 객체(o)가 Collection에 포함되어 있는지 확인합니다.</li>
<li>boolean equals(Object o) : 동일한 Collection인지 비교합니다.</li>
<li>int hashCode() : Collection의 hash code를 반환합니다.</li>
<li>boolean isEmpty() : Collection이 비어있는지 확인합니다.</li>
<li>Iterator iterator() : Collection의 Iterator를 얻어서 반환합니다</li>
<li>boolean remove(Object o) : 지정된 객체를 삭제합니다.</li>
<li>int size() : Collection에 저장된 객체의 개수를 반환합니다.</li>
<li>Object[] toArray() : Collection에 저장된 객체를 객체배얄(Object[])로 반환합니다.</li>
<li>Object[] toArray(Object[] a) : 지정된 배열에 Collection의 객체를 저장해서 반환합니다.</li>
</ul>
<h1 id="array배열">Array(배열)</h1>
<ul>
<li>많은 데이터를 관리할 떄 용이</li>
<li>여러 데이터를 하나의 이름으로 <strong>그룹핑해서 관리</strong>하기 위한 자료구조</li>
<li>배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있고, <strong>반복문과 결합</strong>하면 많은 정보도 효율적으로 처리할 수 있습니다.</li>
<li>배열 인덱스는 값에 대한 <strong>유일무이한 식별자</strong>(리스트에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가짐)</li>
<li><strong>크기가 정해져 있고 기능이 없습니다.</strong></li>
<li><code>인덱스</code>를 가지며, Element의 인덱스는 변경되지 않습니다.</li>
<li>인덱스를 활용하여 빠르게 조회가 가능합니다.</li>
<li>유관 데이터를 메모리에 순차적으로 나열할 수 있다.</li>
<li>인덱스를 이용하여 데이터를 가져오려면 데이터에 대한 인덱스 값이 고정되어야 합니다. (삭제된 Element의 공간이 그대로 남습니다.-&gt;<strong>메모리의 낭비</strong>)</li>
</ul>
<blockquote>
<p><strong>Arrays</strong> 클래스에는 배열을 다루는데 유용한 메소드가 정의되어 있습니다. Arrays에 정의된 메소드는 모두 static 메소드입니다.</p>
</blockquote>
<h2 id="배열의-복사">배열의 복사</h2>
<p>**<code>copyOf()</code>는 배열 전체를, <code>copyOfRange()</code>는 배열의 일부를 복사해서 새로운 배열을 만들어 반환합니다. ** copyOfRange() 메소드에서 지정된 범위의 끝은 포함되지 않습니다.(즉, 지정된 범위의 끝의 바로 앞까지만!)</p>
<h2 id="배열-채우기">배열 채우기</h2>
<p><strong><code>fill()</code>은 배열의 모든 요소를 지정된 값으로 채웁니다. <code>setAll()</code>은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받습니다.</strong> 이 메소드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야 합니다.</p>
<h2 id="배열의-정렬과-검색">배열의 정렬과 검색</h2>
<p><strong><code>sort()</code>는 배열을 정렬할 때, 그리고 배열에 저장된 요소를 검색할 때는 <code>binarySearch()</code>를 사용합니다.</strong> binarySearch()는 배열에서 지정된 값이 저장된 위치(index)를 찾아서 반환하는데, 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻습니다. (검색한 값과 일치하는 요소가 여러 개 있다면, 이 중 어떤 것의 위치가 반환될지는 알 수 없습니다.)</p>
<h2 id="문자열의-비교와-출력">문자열의 비교와 출력</h2>
<p><code>toString()</code>은 배열의 모든 요소를 문자열로 편하게 출력할 수 있게 도와줍니다. toString()은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에서는 deepToString()을 사용해야 합니다. <code>deepToString()</code>은 배열의 모든 요소를 재귀적으로 접근해서 문자열을 구성하므로 2차원뿐만 아니라 3차원 이상의 배열에 대해서도 동작합니다.</p>
<p><code>equals()</code>는 두 배열에 저장된 모든 요소를 비교해서 같으면 true, 다르면 false를 반환합니다. equals()도 일차원 배열에만 사용 가능하므로, 다차원 배열의 비교에는 <code>deepEquals()</code>를 사용해야 합니다.</p>
<h2 id="배열을-list로-변환">배열을 List로 변환</h2>
<p><strong><code>asList()</code>는 배열을 List에 담아서 반환합니다.</strong> 한 가지 주의할 점은 asList()가 반환한 List의 크기를 변경할 수 없다는 것입니다. 저장된 내용은 변경 가능하나, 추가 또는 삭제가 불가능합니다. 만약 크기를 변경할 수 있는 List가 필요하다면 다음과 같이 하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h2 id="parallelxxx-spliterator-stream">parallelXXX(), spliterator(), stream()</h2>
<p><code>parallel</code>로 시작하는 이름의 메소드는 빠른 결과를 얻기 위해 여러 쓰레드가 작업을 나누어 처리하도록 합니다. <code>spliterator()</code>는 여러 쓰레드가 처리할 수 있게 하나의 작업을 여러 작업으로 나누는 Spliterator를 반환하며, <code>stream()</code>은 컬렉션을 스트림으로 변환합니다.</p>
<h2 id="사용법">사용법</h2>
<p>아래의 사용법에서 메소드를 사용해볼 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">number[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">number[<span class="number">1</span>]=<span class="number">20</span>;</span><br><span class="line">number[<span class="number">2</span>]=<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(number.length); <span class="comment">// 길이:4</span></span><br></pre></td></tr></table></figure>
<h2 id="장단점">장/단점</h2>
<ul>
<li>장점
<ul>
<li><code>데이터의 크기가 확정적</code>일 때 배열을 사용하면 <strong>메모리나 처리속도</strong> 면에서 좋습니다.</li>
<li>다른 데이터 Structure의 부품이 되기도 합니다.</li>
</ul>
</li>
<li>단점
<ul>
<li>배열의 크기를 배열을 생성할 때 지정하는 것이나, 배열의 크기를 변경할 수 없습니다.</li>
<li>배열에서 설정된 Element(요소)의 개수를 알아낼 수 없습니다.</li>
</ul>
</li>
</ul>
<h2 id="한계">한계</h2>
<ul>
<li>배열은 길이를 바꿀 수 없습니다. 가변 배열과 길이가 변경 가능한 배열의 겅우
<ul>
<li>기존의 배열은 그대로 두고,</li>
<li>새로운 길이로 지정된 배열을 따로 할당 후</li>
<li>데이터의 복사를 진행하고,</li>
<li>기존의 배열을 삭제한다.</li>
<li><code>총 3번의 작업</code> + <code>메모리 탐색</code>이 필요하기 때문에 리소스 낭비가 크다.</li>
</ul>
</li>
<li>이런 한계를 해결하기 위해서 <code>linked list 자료형</code>을 활용할 수 있다. (탐색, 할당, 복사, 삭제 등의 리소스 낭비가 없습니다.)</li>
<li>배열은 인덱스에 따라서 값을 유지하기 떄문에, Element가 삭제되어도 빈자리(null)가 남게 됩니다.<code>(메모리 낭비)</code></li>
<li>조건문을 통해서 제외할 수 있으나, 조건문을 많이 사용하면 좋지 않습니다.</li>
<li>인덱스가 중요한 경우는 배열을 사용, 인덱스가 중요하지 않은 경우는 리스트를 사용합니다.</li>
<li>삭제한 데이터를 뒤에 위치한 Element로 메꾸면, 데이터가 순서에 따라서 빈틈없이 연속적으로 위치하며 이를 <code>list(리스트)</code>라고 합니다.</li>
</ul>
<p><img src="/img/array.png" alt=""></p>
<ul>
<li>배열 : 삭제된 데이터의 빈 공간을 그래도 남겨둠.</li>
<li>리스트 : 빈 공간을 채움.</li>
</ul>
<p>이러한 문제점을 극복한 것이 <strong>List</strong> 입니다.</p>
<h1 id="list-인터페이스">List 인터페이스</h1>
<p>List는 배열의 한계 때문에 만들어졌으며, List 인터페이스를 구현한 모든 List 컬렉션 클래스는 다음과 같은 특징을 가지고 있습니다.</p>
<ol>
<li>리스트 자료구조의 핵심은 Element간의 <code>순서</code>. 즉, <strong>순서가 있는 데이터의 모임이 리스트입니다.</strong></li>
<li>같은 요소의 중복 저장을 허용합니다.</li>
<li>리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 <strong>빈틈 없는 데이터의 적재</strong>라는 장점을 취한 데이터 Structure입니다.</li>
<li>리스트에서 인덱스는 <strong>몇 번쨰 데이터인가</strong> 정도의 의미</li>
<li>빈 Element는 허용하지 않습니다.</li>
<li>데이터 개수가 확실하게 정해져 있고, 자주 사용된다면 Array가 더 효율적입니다.</li>
</ol>
<p>대표적인 List 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>ArrayList<e></e></li>
<li>LinkedList<e></e></li>
<li>Vector<e></e></li>
<li>Stack<e></e></li>
</ol>
<h2 id="arraylist">ArrayList</h2>
<p><strong>List 인터페이스를 구현하기 때문에 데이터의 저장 순서가 유지되고 중복을 허용한다는 특징을 갖습니다.</strong></p>
<p>ArrayList는 Obejct 배열을 이용해서 데이터를 순차적으로 저장합니다. 계속 배열에 순서대로 저장되며, 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장됩니다.</p>
<p>(Vector는 capacity가 부족할 경우 자동적으로 기존의 크기보다 2배의 크기로 증가됩니. 그러나 생성자 Vector(int initialCapacity, int capacityIncrement)를 사용해서 인스턴스를 생성한 경우에는 지정해준 capacityIncrement만큼 증가하게 됩니다.)</p>
<p>ArryaList는 내부적으로 데이터를 <code>배열</code>에서 관리하며 데이터의 추가, 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 사용합니다. <strong>배열은 크기를 변경할 수 없기 때문에 ArrayList나 Vector와 같이 배열을 이용한 자료구조는 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터 새로 생성된 배열로 데이터를 복사해야 하기 때문에 상당히 효율이 떨어진다는 단점을 가지고 있습니다.</strong></p>
<ul>
<li><strong>capacity</strong> : 현재 ArrayList가 수용할 수 있는 데이터의 수를 의미합니다.</li>
<li><strong>size</strong> : 현재 ArrayList에 저장된 데이터의 수를 의미합니다.</li>
<li><strong>Indexoutofbounds exception</strong> : capacity가 아닌 size에 의해 발생합니다. <strong>데이터의 유무가 중요</strong></li>
</ul>
<img src="/img/mm.png" width="400" height="200">
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add를 이용한 요소 추가</span></span><br><span class="line">        items.add(<span class="number">40</span>);</span><br><span class="line">        items.add(<span class="number">20</span>);</span><br><span class="line">        items.add(<span class="number">10</span>);</span><br><span class="line">        items.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for와 get() 메소드를 이용한 요소 출력</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;items.size();i++)&#123;</span><br><span class="line">            System.out.print(items.get(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for 문과 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e :items) &#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collections.sort() 메소드를 이용한 요소의 정렬</span></span><br><span class="line">        Collections.sort(items);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = items.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set() 메소드를 이용한 요소의 값 변경</span></span><br><span class="line">        items.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수. 반환값은 있으면 true 없으면 false</span></span><br><span class="line">        System.out.println(items.contains(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 함수의 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 값이 추가됩니다. 하지만, 위치를 알 수 없을 때는 indexOf() 함수를 이용해서 위치값을 찾은 뒤 add()함수를 이용하면 됩니다.</span></span><br><span class="line">        <span class="keyword">int</span> index = items.indexOf(<span class="number">20</span>);</span><br><span class="line">        items.add(index, <span class="number">110</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index가 1인 요소 즉, 110 삭제, 인덱스로 삭제하면 어떤 인덱스로 삭제했는지 알려줌</span></span><br><span class="line">        System.out.println(items.remove(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : items)&#123;</span><br><span class="line">            System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 오브젝트를 넘겨서 오브젝트의 모든 요소 삭제</span></span><br><span class="line">        items.removeAll(items);</span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(items.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">40</span> <span class="number">20</span> <span class="number">10</span> <span class="number">30</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">100</span> <span class="number">110</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">100</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line">items size : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> : List에 요소를 추가합니다.</li>
<li><strong>get()</strong> : 인덱스를 통한 요소 조회합니다.</li>
<li><strong>set()</strong> : 원하는 인덱스에 원하는 요소를 추가합니다.</li>
<li><strong>contains()</strong> : 리스트 안에 있는 데이터 중 찾고자 하는 값이 존재하는지 확인할 수 있는 함수, 반환값은 있으면 true 없으면 false</li>
<li><strong>indexOf()</strong> : 메소드의 인자로 오브젝트를 넘기면 이 오브젝트의 인덱스를 반환해줍니다.</li>
<li><strong>add(int index, Obejct o)</strong> : 첫 번째 인자로 인덱스를 넘기면 해당 위치 앞에 두 번째 인자인 오브젝트가 추가됩니다.</li>
<li><strong>remove()</strong> : 인덱스를 이용해서 해당 인덱스를 삭제해줍니다. 인덱스로 삭제하게 되면 어떤 데이터를 삭제했는지 리턴값으로 알려줍니다.</li>
<li><strong>remove(Object element)</strong> : 오브젝트를 인수로 넘기면 검색해서 삭제시켜줍니다. 오브젝트를 이용해서 삭제를 하게 되면 삭제 결과가 성공인지 실패인지만 알려줍니다.</li>
</ul>
<h2 id="linkedlist">LinkedList</h2>
<p><strong>배열은 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간(접근시간, access time)이 가장 빠르다는 장점을 가지고 있지만 다음과 같은 단점도 가지고 있습니다.</strong></p>
<ol>
<li><strong>크기를 변경할 수 없다.</strong>
<ul>
<li>크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요합니다.</li>
<li>실행속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리가 낭비됩니다.</li>
</ul>
</li>
<li><strong>비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.</strong>
<ul>
<li>차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만,</li>
<li>배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야만 합니다.</li>
</ul>
</li>
</ol>
<p>이러한 배열의 단점을 보완하기 위해서 <strong>LinkedList</strong>(링크드 리스트)라는 자료구조가 고안되었습니다. 배열은 모든 데이터가 연속적으로 존재하지만 LinkedList는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있습니다.</p>
<p>링크드 리스트의 각 요소(node)들은 자신과 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList1.png" width="500" height="200">
<p>링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵습니다. 이 점을 보완한 것이 이중 연결리스트(doubly linked list, 더블 링크드 리스트)입니다.</p>
<p><strong>더블 링크드 리스트는 링크드 리스트보다 각 요소에 대한 접근과 이동이 쉽기 때문에 링크드 리스트보다 더 많이 사용됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	Node next; <span class="comment">// 다음 요소의 주소를 저장</span></span><br><span class="line">	Node previous; <span class="comment">// 이전 요소의 주소를 저장</span></span><br><span class="line">	Object obj; <span class="comment">// 데이터를 저장</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/linkedList2.png" width="500" height="200">
<p>더블 링크드 리스트의 접근성을 보다 향상시킨 것이 **더블 쎠큘러 링크드 리스트(이중 연결형 연결 리스트)**입니다. 단순히 더블 링크드 리스트의 첫 번째 요소와 마지막 요소를 서로 연결시킨 것입니다.</p>
<p>실제로 <strong>LinkedList</strong> 클래스는 이름과 달리 '링크드 리스트’가 아닌 '더블 링크드 리스트’로 구현되어 있는데, 이는 링크드 리스트의 단점인 낮은 접근성(accessability)을 높이기 위한 것입니다.</p>
<ol>
<li><strong>순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: 만약 ArrayList의 크기가 충분하지 않으면, 새로운 크기의 ArrayList를 생성하고 데이터를 복사하는 일이 발생하게 되므로 순차적으로 데이터를 추가해도 ArrayList보다 LinkedList가 더 빠를 수 있습니다. 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하며, ArrayList는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 때문에 상당히 빠릅니다. (단지 마지막 요소의 값을 null로만 바꾸면 되기 때문입니다.)</li>
<li><strong>중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠릅니다.</strong><br>
: LinkedList는 각 요소 간의 연결만 변경해주면 되기 때문에 처리속도가 상당히 빠릅니다. 반면에 ArrayList는 각 요소들을 재배치하여 추가할 공간을 확보하거나 빈 공간을 채워야하기 때문에 처리속도가 늦습니다. 사실 데이터의 개수가 그리 크지 않다면 어느 것을 사용해도 큰 차이가 나지 않습니다.</li>
<li><strong>데이터의 개수가 많아질수록 데이터를 읽어오는 시간, 즉 접근시간(access time)은 ArrayList가 LinkedList보다 빠릅니다.</strong><br>
: ArrayList는 인덱스 기반의 자료 구조이며, get(index)를 통해 O(1)의 시간 복잡도를 가집니다. 배열의 경우 만일 n번째 원소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결됩니다. (배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문입니다.)</li>
</ol>
<blockquote>
<p>n번째 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기</p>
</blockquote>
<p>그러나, LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이 아니기 때문에 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있습니다. 검색시 거의 모든 요소를 탐색해야 하기 때문에 최악의 경우에는 O(N)의 시간 복잡도를 갖습니다.</p>
<blockquote>
<p>요약</p>
</blockquote>
<ul>
<li><code>LinkedList</code> : 데이터의 추가/삭제가 많을 때 유리</li>
<li><code>Vector/ArrayList</code> : 데이터 항목 검색이 많을 때 유리</li>
</ul>
<blockquote>
<p>ArrayList와 LinkedList</p>
</blockquote>
<p>데이터를 가져오는 것인 빈번하다면 내부적으로 배열을 이용하는 <strong>ArraysList</strong>가 훨씬 빠릅니다.<br>
하지만, 데이터의 추가/삭제가 빈번하다면 <strong>LinkedList</strong>가 훨씬 효과적입니다.</p>
<p>LikedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있다고 보면 됩니다. ArrayList와 같이 데이터의 추가, 삭제 시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리한 반면, <strong>데이터의 검색시에는 처음부터 노드를 순회해야 하기 때문에 성능상 불리합니다.</strong></p>
<img src="/img/kk.png" width="400" height="200">
<blockquote>
<p><code>Iterator</code> 사용 이유</p>
</blockquote>
<p>linked 특성상 항상 처음부터 같은 경로를 반복적으로 지나면서 데이터의 위치를 검색해야 하기 때문에 마지막으로 접근한 데이터를 기준으로 그 다음 데이터를 알아내는 것이 더 쉽습니다. - 벡터나 ArrayList 처럼 사용되는 것입니다.</p>
<ul>
<li><code>Iterator</code>(추출 전용 인터페이스)
<ul>
<li>데이터를 추출하기 위한 데이터 임시 저장공간</li>
<li>주로 순서가 없는 자료구조의 값들을 추출할 때 사용합니다.</li>
</ul>
</li>
<li>보통 hasNext와 next 메소드를 이용한 while문으로 값을 추출합니다.</li>
</ul>
<blockquote>
<p>예제</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; lnkList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        lnkList.add(<span class="string">"넷"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"둘"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"셋"</span>);</span><br><span class="line">        lnkList.add(<span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lnkList.size(); i++) &#123;</span><br><span class="line">            System.out.print(lnkList.get(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 삭제</span></span><br><span class="line">        lnkList.remove(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// 원하는 위치에 요소 삽입</span></span><br><span class="line">        lnkList.set(<span class="number">2</span>, <span class="string">"둘"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String e : lnkList) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">		<span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(<span class="string">"리스트의 크기 : "</span> + lnkList.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">넷 셋 하나 </span><br><span class="line">넷 셋 둘 </span><br><span class="line">리스트의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="vector">Vector</h2>
<p>ArrayList와 동일하게 사용이 가능합니다.<br>
ArrayList와 Vector의 차이점은 Stringbuilder와 StringBuffer의 차이로 이해할 수 있습니다. <strong>한 데이터에 동시접속이 발생했을 때 처리 가능한 기능이 있나, 없나의 차이입니다.</strong></p>
<p>동시접속을 고려하여 만들어진 리스트는 <code>Vector</code>입니다. <code>ArrayList</code>는 동시접속을 고려하지 않았지만, 그만큼 Vector보다 가볍다는 장점이 있습니다. 또한 웹에서 사용할 때 서버가 동시접속에 대한 처리를 해주기 때문에 ArrayList를 사용하면 됩니다.</p>
<p>Vector는 현재 기존 코드와의 호환성을 위해서만 남아있으므로, Vector 클래스보다는 ArrayList 클래스를 사용하는 것이 좋습니다.</p>
<h2 id="list-인터페이스-메소드">List 인터페이스 메소드</h2>
<ul>
<li>void add(int index, Object element) : 지정된 위치(index)에 객체(element)또는 컬렉션에 포함된 객체들을 추가합니다.</li>
<li>Object get(int index) : 지정된 위치(index)에 있는 객체를 반환합니다.</li>
<li>int indexOf(Object o) : 지정된 객체의 위치(index)를 반환합니다. (List의 첫 번째 요소부터 순방향으로 찾습니다.)</li>
<li>lastIndexOf(Object o) : 지정된 객체의 위치(indx)를 반환합니다. (List의 마지막 요소부터 역방향으로 찾습니다.)</li>
<li>ListIterator listIterator() : List의 객체에 접근할 수 있는 ListIterator를 반환합니다.</li>
<li>Object remove(int index) : 지정된 위치(index)에 있는 객체를 삭제하고 삭제된 객체를 반환합니다.</li>
<li>Object set(int index, Object element) : 지정된 위치(index)에 객체(element)를 저장합니다.</li>
<li>void sort(Comparator c) : 지정된 비교자(comparator)로 List를 정렬합니다.</li>
<li>List subList(int formIndex, int toIndex) : 지정된 범위(formIndex부터 toIndex)에 있는 객체를 반환합니다.</li>
</ul>
<h2 id="참고">참고</h2>
<blockquote>
<p>List와 ArrayList 이 둘의 차이는 무엇인가?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
<p>예를 들어서 설명하면, 클래스를 생성할 때 <code>도형</code> 타입으로 생성하게 되면 <strong>정사각형</strong>이 아닌 다른 <strong>직사각형, 삼각형</strong>등 도형 인터페이스를 구현한 클래스에서 사용될 수 있습니다. 하지만, <code>정사각형</code>타입으로 클래스르 생성하게 되면 <strong>직사각형, 삼각형</strong>등에서는 사용할 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 도형 list = new 정사각형();</span></span><br><span class="line"></span><br><span class="line"> 	ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"> <span class="comment">// 정사각형 list = new 정사각형();</span></span><br></pre></td></tr></table></figure>
<p><code>List</code>는 <strong>인터페이스</strong>입니다. 인터페이스는 공통되는 메소드를 추출해 놓은 클래스입니다.</p>
<ul>
<li>Java Collection FrameWork<br>
<img src="/img/sse.jpg" alt=""></li>
</ul>
<h1 id="stack과-queue">Stack과 Queue</h1>
<hr>
<p>순차적으로 데이터를 추가하고 삭제하는 스택에는 ArrayList와 같은 배열 기반의 컬렉션 클래스가 적합하지만, 큐는 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스를 사용한다면 데이터를 꺼낼 때마다 빈 공간을 채우기 위해서 데이터의 복사가 발생하므로 비효율적입니다. 그래서 큐는 ArrayList보다는 데이터의 추가/삭제가 쉬운 LinkedList로 구현하는 것이 더 적합합니다.</p>
<h2 id="stack">Stack</h2>
<p><strong>스택</strong>이란 사전적으로는 더미, 쌓아 올림이라는 의미를 갖습니다. '더미’란 많은 물건이 모여서 쌓인 큰 덩어리를 의미합니다. 스택은 같은 타입의 자료를 <code>하나 다음 하나</code>라는 개념으로 순차적으로 저장하는 직선형 자료구조입니다.<br>
Stack 클래스는 List 컬렉션 클래스의 Vector 클래스를 상속받아, 전형적인 스택 메모리 구조의 클래스를 제공합니다.</p>
<p>스택은 한쪽이 막혀있고, <strong>한쪽에서만 삽입이나 삭제가 가능합니다.</strong> 그러므로 가장 마지막 데이터의 위치에 대해 삽입이나 삭제가 발생하므로, 이러한 구조에 사용될 때 간단하며 더욱 효율적이고 쉽게 사용이 가능합니다.</p>
<p>또한 스택은 데이터를 쌓아올리는 형태로 데이터를 저장하여 추출할 때는 맨 위에 있는 데이터를 먼저 꺼내는 형태이기 때문에 제일 마지막에 저장한 데이터를 제일 먼저 꺼내는 <code>후입선출(LIFO - Last In First Out)</code> 형태라고도 합니다.</p>
<p><img src="/img/stack.png" alt=""></p>
<ul>
<li>Stack 용어
<ul>
<li>push : 스택에 자료를 넣는 연산</li>
<li>pop : 스택에 자료를 빼는 연산</li>
<li>top : 스택의 가장 위에 있는 자료를 보는 연산</li>
<li>bottom : 스택에 가장 먼저 입력된 데이터</li>
<li>empty : 스택이 비어있는지 아닌지를 알아보는 연산</li>
<li>size : 스택에 저장되어 있는 자료의 개수를 알아보는 연산</li>
</ul>
</li>
</ul>
<p>스택은 <strong>top</strong>에서만 삽입, 삭제, 읽기 동작이 발생할 수 있습니다. <strong>top</strong>은 데이터의 수에 따라 유동적으로 변하며 데이터가 하나 삽입될 경우 하나 증가하고 데이터가 하나 삭제될 경우 하나 감소하도록 작성됩니다.</p>
<p>스택의 경우에는 순차적으로 데이터를 추가하고 삭제하므로 <strong>ArrayList</strong>와 같은 배열 기반의 컬렉션 클래스가 적합합니다.</p>
<ul>
<li>Stack 메소드
<ul>
<li>boolean empty() : Stack이 비어있는지 알려줍니다.</li>
<li>Object peek() : Stack의 맨 위에(top) 저장된 객체를 반환, pop()과 달리 Stack에서 객체를 꺼내지 않습니다. 단지 보기만 합니다.</li>
<li>Object pop() : Stack의 맨 위에 저장된 객체를 꺼냅니다.</li>
<li>Object push(Object item) : Stack에 객체(item)를 저장합니다.</li>
<li>int search(Object o) : 해당 Stack에서 전달된 객체가 존재하는 위치의 인덱스를 반환합니다. 이 때, 인덱스는 제일 상단에 있는(제일 마지막으로 저장된)요소의 위치부터 0이 아닌 1부터 시작하게 됩니다.</li>
<li>clear() : Stack에 존재하는 모든 자료들을 삭제합니다.</li>
</ul>
</li>
</ul>
<h3 id="사용방법">사용방법</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스택 객체 stack 생성</span></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// 데이터 입력</span></span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 스택의 사이즈</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line">System.out.println(<span class="string">"마지막에 넣은 데이터부터 출력.."</span>);</span><br><span class="line"><span class="comment">// 가장 최근에 넣은 데이터부터 추출</span></span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">System.out.println(stack.pop());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">		</span><br><span class="line">stack.push(<span class="number">5</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">System.out.println(<span class="string">"스택크기: "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 빼지 않고 현재 가장 위에 위치하는 데이터를 확인</span></span><br><span class="line">System.out.println(stack.peek());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈 확인</span></span><br><span class="line">System.out.println(<span class="string">"스택 크기 : "</span>+stack.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">System.out.println(stack.search(<span class="number">3</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">4</span>));</span><br><span class="line">System.out.println(stack.search(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">스택 크기 : <span class="number">5</span></span><br><span class="line">마지막에 넣은 데이터부터 출력..</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">-----------</span><br><span class="line">스택크기: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">스택 크기 : <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>더욱 복잡하고 빠른 스택을 구현하고 싶다면 Deque 인터페이스를 구현한 ArrayDeque 클래스를 사용하면 됩니다. 단, Stack 클래스와는 달리 <strong>search()</strong> 메소드를 지원하지 않습니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; st = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="스택의-활용-사례">스택의 활용 사례</h3>
<ul>
<li><code>Operating Systems</code>
<ul>
<li>프로그램에서 불러지는 함수(Method)들을 모두 Stack이라는 자료형에 저장합니다.</li>
</ul>
</li>
<li><code>Compilers(컴파일러)</code>
<ul>
<li>컴파일러에서 수학기호들으 기계어(Machine Code)로 변환시, 괄호들을 매칭하거나 할 때</li>
</ul>
</li>
<li><code>JVM(Java Virtual Machine) - 자바 가상 머신</code>
<ul>
<li>자바 프로그램이 실행될 때 사용되는 JVM에서도 스택은 사용됩니다. 각각의 스레드는 1개의 스택을 가지고 모든 메소드들을 트랙킹합니다. 새로운 메소드들이 호출될 때마다, 새로운 프레임이 스택에 삽입되고, 메소드가 끝날 때 마다 스택에서 제거됩니다.</li>
</ul>
</li>
</ul>
<h2 id="queue">Queue</h2>
<img src="/img/queues.png" width="500" height="200">
<p>큐는 줄이라는 의미를 가지고 있습니다. <strong>큐(Queue)에서 데이터의 제거는 대기 줄의 가장 앞에서 수행되며 데이터의 삽입은 대기 줄의 가장 뒤에서 수행이 되는 제한된 리스트 구조를 말하며 가장 먼저 삽입된 데이터가 가장 먼저 제거되는 <code>선입선출(FIFO-First In First Out)</code> 형태의 자료구조입니다.</strong></p>
<p>가장 오래전에 입력된 데이터를 <strong>front</strong>라고 하면 가장 최근에 입력된 데이터를 <strong>rear</strong>라고 합니다. <code>데이터의 삽입</code>은 <strong>rear</strong>에서 이루어지고 <code>삭제</code>는 <strong>front</strong>에서 이루어지기 때문에 큐를 구현하기 위해서는 front와 rear를 관리하는 배열을 이용하거나 front노드와 rear노드를 관리하는 <code>연결 리스트</code>를 이용할 수 있습니다.</p>
<img src="/img/queue.jpg" width="300" height="200">
<p><strong>자바에서는 스택을 Stack 클래스로 구현하여 제공하고 있지만 큐는 Queue 인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있진 않습니다. 대신 Queue 인터페이스를 구현한 클래스들이 있어서 이들 중의 하나를 선택해서 사용하면 됩니다.</strong></p>
<p>따라서 Queue 인터페이스를 직간접적으로 구현한 클래스는 상당히 많습니다. 그 중에서도 Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됩니다.</p>
<p>그리고 Queue는 타입이 될 수 없습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 이렇게 선언이 되지 않고</span></span><br><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="queue의-동작">Queue의 동작</h3>
<ul>
<li>
<p>삽입 - offer,add</p>
<ul>
<li>큐에 새로운 데이터를 삽입하는 작업을 의미하며, 이는 리스트의 끝 부분을 가리키는 rear에서 발생하며 데이터가 삽입될 때 하나 증가시킨 후 새로운 데이터를 삽입합니다.</li>
<li>add : 큐의 뒤 쪽(rear)에 데이터를 삽입합니다.</li>
<li>push : 큐의 앞 쪽(front)에 데이터를 삽입합니다.</li>
</ul>
</li>
<li>
<p>제거 - pop,remove</p>
<ul>
<li>큐에서 데이터를 제거하는 작업을 의미하며 이는 항상 front에서 발생합니다. front값이 rear를 추월하게 되면 더이상 제거할 데이터가 없는 상태 즉, 자료가 하나도 없는 빈 큐를 의미합니다.</li>
<li><code>poll</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>remove</code>는 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
<li>
<p>읽기 - peek,element</p>
<ul>
<li>큐에서 front가 가리키는 데이터를 읽는 작업을 peek이라 합니다. 데이터를 제거하지 않고 읽는 작업만 수행하므로 front값을 변경시키지 않습니다.</li>
<li><code>peek</code>은 큐가 비어있다면 <strong>null</strong>을 반환</li>
<li><code>element</code>은 큐가 비어있다면 <strong>예외</strong> 발생</li>
</ul>
</li>
</ul>
<blockquote>
<p>peekFirst()는 Queue에 가장 먼저 들어온 데이터 즉, front에 있는 데이터를 보여줍니다. peekLast()는 Queue에 가장 나중에 들어온 데이터 즉, rear에 있는 데이터를 보여줍니다.</p>
</blockquote>
<h3 id="사용">사용</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">queue</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        queue.add(<span class="string">"하나"</span>);</span><br><span class="line">        queue.add(<span class="string">"둘"</span>);</span><br><span class="line">        queue.add(<span class="string">"셋"</span>);</span><br><span class="line">        queue.add(<span class="string">"넷"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// element() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"element() 메소드 사용 : "</span>+queue.element());</span><br><span class="line">        <span class="comment">// peek() 메소드를 이용한 요소의 반환</span></span><br><span class="line">        System.out.println(<span class="string">"peek() 메소드 사용 : "</span>+queue.peek()+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// peekFirst() 메소드는 큐의 맨 위의 요소를 반환 즉, 가장 처음에 삽입된 요소를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 첫 번째 요소 : "</span>+queue.peekFirst());</span><br><span class="line">        <span class="comment">// peekLast() 메소드는 큐의 맨 마지막 요소를 반환 즉, 마지막에 삽입된 요소 반환</span></span><br><span class="line">        System.out.println(<span class="string">"Queue의 마지막 요소 : "</span>+queue.peekLast()+<span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.poll());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 사용한 요소의 삭제</span></span><br><span class="line">        System.out.println(<span class="string">"삭제한 요소 : "</span>+queue.remove());</span><br><span class="line">        System.out.println(queue+<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">element() 메소드 사용 : 하나</span><br><span class="line">peek() 메소드 사용 : 하나</span><br><span class="line"></span><br><span class="line">Queue의 첫 번째 요소 : 하나</span><br><span class="line">Queue의 마지막 요소 : 넷</span><br><span class="line"></span><br><span class="line">[하나, 둘, 셋, 넷]</span><br><span class="line">삭제한 요소 : 하나</span><br><span class="line">[둘, 셋, 넷]</span><br><span class="line"></span><br><span class="line">삭제한 요소 : 둘</span><br><span class="line">[셋, 넷]</span><br></pre></td></tr></table></figure>
<h3 id="큐-구현-클래스">큐 구현 클래스</h3>
<p><strong>1. PriorityQueue</strong><br>
Queue 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있습니다. 그리고 null은 저장할 수 없습니다. PIPO(Priority-in, Priority Out)</p>
<p><strong>2. PriorityBlockingQueue</strong><br>
-&gt; Priority Queue의 동기화된 버전<br>
-&gt; 동기화 메소드 보유<br>
-&gt; PriorityQueue보다 느린 속도<br>
-&gt; null 요소를 허용하지 않음</p>
<p><strong>3. LinkedList</strong><br>
-&gt; 끝에 요소를 추가하는 것이 용이<br>
-&gt; List 인터페이스 구현<br>
-&gt; 요소에 null 허용</p>
<p><strong>4. Deque(Double-Ended Queue)</strong><br>
-&gt; Queue의 변형으로, 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, <strong>Deque</strong>은 양쪽 끝에 추가/삭제가 가능합니다. Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있습니다.</p>
<p>문제 : <a href="https://www.acmicpc.net/problem/10866" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10866</a></p>
<blockquote>
<p>Deque의 사용법</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">            String command = st.nextToken();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">switch</span> (command)&#123;</span><br><span class="line">				<span class="comment">// first, front, 앞 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 먼저 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// push() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_front"</span>: </span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addFirst(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">// last, rear, 뒤 쪽에 데이터를 삽입</span></span><br><span class="line">				<span class="comment">// 가장 나중에 삽입된 것처럼 할 수 있음</span></span><br><span class="line">                <span class="comment">// add() 메소드도 동일하게 동작</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">"push_back"</span>:</span><br><span class="line">                    num = Integer.parseInt(st.nextToken());</span><br><span class="line">                    deque.addLast(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_front"</span>:</span><br><span class="line">					<span class="comment">// 덱이 비어있는지 확인할 수 있음</span></span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 앞쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 먼저 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeFirst()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"pop_back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 삭제</span></span><br><span class="line">						<span class="comment">// 어떻게 보면 가장 나중에 삽입된 데이터를 삭제</span></span><br><span class="line">                        System.out.println((deque.removeLast()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"size"</span>:</span><br><span class="line">					<span class="comment">// 덱의 사이즈를 확인</span></span><br><span class="line">                    System.out.println(deque.size());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"empty"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"front"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱에서 가장 앞쪽의 데이터를 확인(first, front)</span></span><br><span class="line">                        System.out.println(deque.peekFirst());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"back"</span>:</span><br><span class="line">                    <span class="keyword">if</span>(deque.isEmpty())&#123;</span><br><span class="line">                        System.out.println(-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 덱의 가장 뒤쪽의 데이터를 확인(last, rear)</span></span><br><span class="line">                        System.out.println(deque.peekLast());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java SE 6부터 지원되는 ArrayDeque 클래스는 스택과 큐 메모리 구조를 모두 구현하는데 가장 적합한 클래스입니다.</p>
</blockquote>
<h1 id="vector-클래스">Vector 클래스</h1>
<hr>
<p><code>List 인터페이스를 구현한 클래스</code>이며, <strong>java.util.Vector</strong>에 있습니다. 그리고 아래와 같은 특징을 갖습니다.</p>
<ol>
<li>객체들을 <strong>삽입, 삭제, 검색</strong>할 수 있는 컨테이너 클래스입니다.</li>
<li>배열의 <strong>길이 제한 단점을 극복</strong>할 수 있습니다.</li>
<li>삽입되는 객체의 수가 많아지면 <code>자동으로 크기가 조절</code>됩니다.</li>
<li>아이템을 벡터의 <strong>맨 마지막</strong>이나 <strong>중간에 삽입</strong>할 수 있습니다.</li>
</ol>
<ul>
<li><code>벡터 맨 뒤에 객체 추가</code> : 벡터 공간이 모자라면 자동으로 늘림</li>
<li><code>벡터 중간에 객체 삽입</code> : 뒤에 존재하던 객체는 한칸씩 뒤로 이동</li>
<li><code>임의의 위치에 있는 객체 삭제</code> : 객체 삭제 후 한칸씩 앞으로 자동으로 이동</li>
</ul>
<h2 id="사용방법">사용방법</h2>
<img src="/img/dd.png" width="400" height="200">
<p>위의 그림은 벡터 객체 내부의 구조와 <code>add(),get() 메소드</code>를 이용하여 객체를 다루는 모습을 보여주고 있습니다. 벡터에는 <strong>String,Integer,Person등의 다양한 타입의 객체가 삽입 가능합니다.</strong> 벡터 내부에 삽입된 요소들은 <code>인덱스</code>로 관리하며 인덱스는 0부터 시작합니다. <code>add()</code>메소드를 이용하여 <strong>객체를 삽입</strong>하고, <code>get()</code>메소드를 이용하여 인덱스에 해당하는 <strong>객체를 얻습니다.</strong></p>
<blockquote>
<p>벡터의 생성</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">Vector&lt;String&gt; v2 = <span class="keyword">new</span> Vector&lt;String&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>v는 어떠한 타입이라도 담을 수 있습니다.</li>
<li>v2는 Vector 객체에 String 객체를 담을 수 있으며, 용량은 3이며 size가 용량을 초과했을 때, 3의 크기만큼 증가합니다. (매개변수를 지정하지 않았을 경우에는 기본 용량:10,증가 용량:10)<br>
<img src="/img/abc.png" width="400" height="200"></li>
</ul>
<blockquote>
<p>벡터에 요소 삽입</p>
</blockquote>
<p>벡터에 삽입할 수 있는 요소는 <code>Object</code>를 상속받은 모든 종류의 객체들이 가능하며 다음과 같이 벡터에 요소를 삽입할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="string">"Hello"</span>);</span><br><span class="line">v.add(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">v.add(<span class="keyword">new</span> Person());</span><br><span class="line">v2.addElement(<span class="string">"이승우"</span>);</span><br><span class="line">v2.addElement(<span class="string">"정지현"</span>);</span><br><span class="line">v2.addElement(<span class="string">"탁형민"</span>);</span><br><span class="line">v2.addElement(<span class="string">"홍주영"</span>);</span><br><span class="line"></span><br><span class="line">v.add(<span class="number">1</span>); <span class="comment">// int형 데이터(Integer 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="string">'r'</span>); <span class="comment">// char형 데이터(Character 타입으로 전환되어 벡터에 저장)</span></span><br><span class="line">v.add(<span class="number">3.14</span>); <span class="comment">// double형 데이터(Double 타입으로 전환되어 저장)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add()</strong> 메소드는 요소를 벡터의 맨 뒤에 삽입합니다.</li>
<li>v2에는 addElement() 메소드를 이용해서 String 객체를 담을 수 있습니다.</li>
<li>자바에서 제공하는 기본 타입 역시 벡터에 삽입할 수 있습니다.</li>
</ul>
<img src="/img/bcd.png" width="400" height="200">
<blockquote>
<p>벡터 내의 객체 알아내기</p>
</blockquote>
<p>벡터 내에 존재하는 요소 객체를 알아내기 위해서는 <code>get(), elementAt()</code>등의 메소드를 이용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer obj = (Integer)v.get(<span class="number">1</span>); <span class="comment">// 벡터의 1번째 요소를 Integer 타입으로 형 변환</span></span><br><span class="line"><span class="keyword">int</span> i = obj.intValue(); <span class="comment">// obj에 있는 정수를 알아냅니다. 값은 4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>벡터의 용량과 개수 알아내기</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = v.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c = v.capacity(); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">int</span> n2 = v2.size(); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c2 = v2.capacity(); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>벡터의 크기<code>(size)</code> : <strong>벡터에 들어 있는 요소의 개수</strong></li>
<li>벡터의 용량<code>(capacity)</code> : <strong>요소를 수용할 수 있는 크기</strong>[벡터는 자동으로 조절 가능]</li>
</ul>
<blockquote>
<p>요소 객체 중간에 삽입하기</p>
</blockquote>
<p>벡터에 있는 데이터는 <code>인덱스</code>로 관리할 수 있기 때문에, 인덱스 값을 이용해서 중간에 객체 삽입이 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.add(<span class="number">2</span>,<span class="string">"Sahni"</span>);</span><br></pre></td></tr></table></figure>
<p>벡터 v 내의 인덱스가 2인 위치에 “Shani” 삽입하였으며, 아래 그림과 같은 구조를 가지게 됩니다.</p>
<img src="/img/cde.png" width="400" height="200">
<blockquote>
<p>벡터에서 요소 삭제</p>
</blockquote>
<ul>
<li><code>remove()</code> : 벡터 내에 임의의 인덱스에 있는 요소를 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.remove(<span class="number">1</span>); <span class="comment">// 정수 4가 삭제됨</span></span><br></pre></td></tr></table></figure>
<img src="/img/def.png" width="400" height="200">
<blockquote>
<p>벡터에서 모든 요소 삭제하기</p>
</blockquote>
<ul>
<li><code>removeAllElements()</code> : 벡터 내에 존재하는 모든 요소를 한번에 삭제할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.removeAllElements(); <span class="comment">// 벡터 내 모든 요소 삭제</span></span><br></pre></td></tr></table></figure>
<img src="/img/efg.png" width="400" height="200">
<h2 id="벡터-클래스의-주요-메소드">벡터 클래스의 주요 메소드</h2>
<p><img src="/img/aad.png" alt=""></p>
<h2 id="벡터-생성자">벡터 생성자</h2>
<p><img src="/img/lmc.png" alt=""></p>
<h1 id="정렬">정렬</h1>
<hr>
<p>자바에서 정렬하기 위해 사용하는 <code>Comparable</code>과 <code>Comparator</code>를 공부해보았습니다<br>
<strong><code>Comparator</code>와 <code>Comparable</code>은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메소드를 정의하고 있으며, Comparable을 구현하고 있는 클래스들은 같은 타입의 인터페이스끼리 서로 비교할 수 있는 클래스들(주로 Wrapper 클래스)이 있으며, 기본적으로 오름차순으로 구현되어 있습니다. 그래서 Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미합니다.</strong></p>
<p><strong>배열</strong>이나 <strong>Collection</strong>프레임워크 등에서 sort()를 사용하면 컴퓨터에서 알아서 <code>정렬</code>을 해줍니다. 여기서 사용되는 <code>sort()</code>는 <strong>Comparable</strong> 구현에 의한 정렬이고, <strong>Comparable</strong>과 <strong>Comparator</strong>에 대해서 공부해보았습니다.</p>
<p>먼저 Arrays 클래스에서 제공하는 <strong>sort()</strong> 메소드를 이용해서 배열을 정렬하는 예입니다.</p>
<h2 id="arrayssort">Arrays.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String[] sports=&#123;<span class="string">"Soccer"</span>,<span class="string">"Baseball"</span>,<span class="string">"Tennis"</span></span><br><span class="line">,<span class="string">"Football"</span>,<span class="string">"Basketball"</span>,<span class="string">"Ski"</span>,<span class="string">"Hockey"</span>,<span class="string">"Aerobics"</span>&#125;; <span class="comment">// 영어</span></span><br><span class="line">String[] names=&#123;<span class="string">"하정우"</span>,<span class="string">"장동건"</span>,<span class="string">"김수현"</span>,<span class="string">"박보검"</span></span><br><span class="line">,<span class="string">"송중기"</span>,<span class="string">"송승헌"</span>,<span class="string">"조승우"</span>,<span class="string">"조정석"</span>,<span class="string">"강동원"</span>,<span class="string">"김우빈"</span>,<span class="string">"박서준"</span>&#125;; <span class="comment">// 한글</span></span><br><span class="line">		</span><br><span class="line">Arrays.sort(sports);</span><br><span class="line">Arrays.sort(names);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sports.length;i++)&#123;</span><br><span class="line">	System.out.print(sports[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">System.out.print(<span class="string">"\n"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;names.length;j++)&#123;</span><br><span class="line">	System.out.print(names[j]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Aerobics Baseball Basketball Football Hockey Ski Soccer Tennis </span><br><span class="line">강동원 김수현 김우빈 박보검 박서준 송승헌 송중기 장동건 조승우 조정석 하정우</span><br></pre></td></tr></table></figure>
<p>먼저, <strong>Arryays.sort</strong>()의 동작을 확인하였습니다. String 타입의 배열을 2개 만들었고, <strong>Arrays.sort</strong>()를 통해 정렬을 수행하였습니다.<br>
영어는 ABC 순서대로, 한글은 가나다 순서대로 정렬이 된 것을 확인할 수 있습니다. 영어의 경우 같은 알파벳으로 시작하는 단어들도 정확하게 정렬이 되었습니다.</p>
<p>여기서 Arrays.sort(sports),Arryas.sort(names)는 String의 <strong>Comparable</strong>구현에 의해 정렬된 것이다. <strong>Comparable</strong>을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들, String, Integer, Date, File등과 같은 것들입니다. 그리고 기본적으로는 작은 값에서 큰 값의 순서, 오름차순 형태로 구현되도록 만들어져 있습니다.</p>
<h2 id="collectionssort">Collections.sort()</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; sportsList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">sportsList.add(<span class="string">"Soccer"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Baseball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Tennis"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Football"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Basktball"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Ski"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Hockey"</span>);</span><br><span class="line">sportsList.add(<span class="string">"Aerobics"</span>);</span><br><span class="line">		</span><br><span class="line">Collections.sort(sportsList);</span><br><span class="line">		</span><br><span class="line">Iterator it = sportsList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.print(it.next()+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이번에는 배열이 아닌 ArrayList의 형태로 sort()를 사용해보았다. 위에서 사용했던 방식과 똑같지만, String 타입의 배열을 ArrayList로 바꿨습니다. 여기서는 <strong>Arrays.sort</strong>()가 아니라 <code>Collections.sort()</code>를 적용해야 합니다.</p>
<h2 id="comparable-인터페이스">Comparable<t> 인터페이스</t></h2>
<p>Comparable 인터페이스는 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드를 정의하고 있습니다. 자바에서 같은 타입의 인스턴스를 서로 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있습니다. 따라서 Boolean을 제외한 래퍼 클래스나 String, Time, Date와 같은 클래스의 인스턴스는 모두 정렬 가능합니다. 이 때 기본 정렬 순서는 작은 값에서 큰 값으로 정렬되는 오름차순이 됩니다.</p>
<p>이제부터는 기본 정렬기준이 아닌 다른 정렬기준으로 시도해보겠습니다. 축구선수를 뜻하는 <strong>SoccerPlayer</strong>라는 클래스를 하나 만들고, 축구선수의 객체배열을 이용해 sort를 해보려고 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cars</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cars</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cars</span><span class="params">(String modelName, String color, <span class="keyword">int</span> modelYear)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear+<span class="string">"식"</span>+<span class="keyword">this</span>.modelName+<span class="string">" "</span>+<span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModelYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelYear</span><span class="params">(<span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cars obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.modelYear &gt;obj.modelYear)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.modelYear &lt; obj.modelYear)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arraysExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Cars&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Cars cars1 = <span class="keyword">new</span> Cars(<span class="string">"아반떼"</span>,<span class="string">"Black"</span>,<span class="number">2016</span>);</span><br><span class="line">        Cars cars2 = <span class="keyword">new</span> Cars(<span class="string">"소나타"</span>,<span class="string">"White"</span>,<span class="number">2018</span>);</span><br><span class="line">        Cars cars3 = <span class="keyword">new</span> Cars(<span class="string">"그랜져"</span>,<span class="string">"Brown"</span>,<span class="number">2002</span>);</span><br><span class="line">        Cars cars4 = <span class="keyword">new</span> Cars(<span class="string">"벤츠"</span>,<span class="string">"Yellow"</span>,<span class="number">2009</span>);</span><br><span class="line"></span><br><span class="line">        list.add(cars1);</span><br><span class="line">        list.add(cars2);</span><br><span class="line">        list.add(cars3);</span><br><span class="line">        list.add(cars4);</span><br><span class="line"></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2002</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p><strong>Cars</strong>는 자동차 모델의 이름과 연식, 색상을 속성으로 가지고 각각 setter와 getter를 선언해주었습니다. 위의 경우와 동일하게 Arrays.sort(), Collections.sort()는 작동하지 않고 <code>오류</code>가 발생합니다. 이유는 <code>정렬을 시도했지만, 객체 내의 어떤 변수를 기준으로 정렬할 지 정하지 않았기 때문</code>입니다. String 타입의 배열이나 ArrayList는 값이 하나지만, 객체를 정렬할 경우 객체 내의 어떤 <strong>변수로 정렬할지 기준을 만들어줘야 합니다.</strong></p>
<p><strong>Comparable</strong>을 implements한 뒤 <strong>comparaTo</strong>메소드를 구현하면 해결할 수 있습니다. [오름차순만 가능]</p>
<p>Cars 클래스에서 <code>Comparable&lt;Cars&gt;</code>를 implements 하였습니다. 그리고 하단에 <strong>compareTo()</strong> 메소드를 오버라이드하여 코드를 추가했습니다. 매개변수로 Cars 객체를 받고 리턴값으로는 객체의 이름을 비교하는 구문을 넣어주었습니다.</p>
<p>여기서 본인이 정렬하고자 하는 클래스를 <code>Comparable&lt;클래스명&gt;</code> 형태로 넣어주는 것을 잊어서는 안됩니다. 이 경우에 정렬하고자 하는 클래스는 <strong>Cars</strong>라는 클래스!</p>
<p>자동차 객체를 4개 만들어서 ArrayList에 추가하였습니다. 그리고 Collections.sort()를 이용해 정렬을 시도하니 가나다 연식 순서로 정렬되어 나오는 결과를 확인할 수 있었습니다.</p>
<p>바로 Cars 클래스에서 Comparable을 implements하였고, 하단에 compareTo를 Override하며 연식 비교 코드를 만들어주었기 때문입니다. 이 부분을 연식이 아닌 자동차 모델 이름으로 바꿀 수 있습니다.</p>
<h2 id="comparator-인터페이스">Comparator<t> 인터페이스</t></h2>
<p>Comparable을 implements 하지 않고도 오브젝트의 특정 변수를 기준으로 정렬하는 방법이 있습니다. 이 때 사용하는 방법이 바로 <strong>Comparator</strong>입니다. <code>Comparator</code>를 사용하면 정렬 기준을 본인이 원하는대로 바꾸는 것이 가능합니다.<code>[오름차순, 내림차순 가능]</code>. <code>주로 객체의 특정 변수를 기준으로 정렬할 때 주로 이용합니다.</code> 이 때 Comparator 인터페이스를 구현한 클래스에서는 compare() 메소드를 재정의하여 사용하게 됩니다.</p>
<p>다음 예제는 SoccerPlayer라는 클래스의 객체를 Comparator 인터페이스를 통해 원하는 기준으로 정렬하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cars</span><span class="params">(String modelName, String color, <span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear + <span class="string">"식"</span> + <span class="keyword">this</span>.modelName + <span class="string">" "</span> + <span class="keyword">this</span>.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getModelYear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelYear</span><span class="params">(<span class="keyword">int</span> modelYear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arraysExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Cars&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Cars cars1 = <span class="keyword">new</span> Cars(<span class="string">"아반떼"</span>, <span class="string">"Black"</span>, <span class="number">2016</span>);</span><br><span class="line">        Cars cars2 = <span class="keyword">new</span> Cars(<span class="string">"소나타"</span>, <span class="string">"White"</span>, <span class="number">2018</span>);</span><br><span class="line">        Cars cars3 = <span class="keyword">new</span> Cars(<span class="string">"그랜져"</span>, <span class="string">"Brown"</span>, <span class="number">2002</span>);</span><br><span class="line">        Cars cars4 = <span class="keyword">new</span> Cars(<span class="string">"벤츠"</span>, <span class="string">"Yellow"</span>, <span class="number">2009</span>);</span><br><span class="line"></span><br><span class="line">        list.add(cars1);</span><br><span class="line">        list.add(cars2);</span><br><span class="line">        list.add(cars3);</span><br><span class="line">        list.add(cars4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 자동차 연식을 기준으로 내림차순 정렬</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Cars&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cars o1, Cars o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getModelYear() &gt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getModelYear() &lt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"내림 차순 정렬"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 자동차 연식을 기준으로 오름차순 정렬(원래 방식)</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Cars&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Cars o1, Cars o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getModelYear() &gt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getModelYear() &lt; o2.getModelYear()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"오름 차순 정렬"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).getModelYear());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">내림 차순 정렬</span><br><span class="line"><span class="number">2018</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2002</span></span><br><span class="line">오름 차순 정렬</span><br><span class="line"><span class="number">2002</span></span><br><span class="line"><span class="number">2009</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p>SoccerPlayer 클래스에 <strong>Comparable</strong>을 implements하지 않은 상태로 Main에 Collections.sort()를 만들었습니다. 여기서는 <code>Collections.sort(playerList,new Comparator&lt;SoccerPlayer&gt;(){..}</code>형태로 구현해야 하며, 내부에 있는 compare() 메소드에서 객체의 어떤 필드를 기준으로 졍렬할 지 정해주면 도비니다. 자동차 클래스의 연식을 기준으로 오름차순과 내림차순으로 구현했습니다.</p>
<h2 id="결론">결론</h2>
<p><strong>Comparable</strong> 구현 후 내부의 <strong>compareTo</strong> 메소드를 오버라이드해서 정의해야 하는데, 이 정의 결과에 따라 정렬 값이 나옵니다. 또한, 오브젝트의 다른 값으로 비교를 원한다면 <strong>compareTo</strong>를 하나하나 바꿔줄 필요 없이, <strong>Comparator</strong>를 이용하면 됩니다.</p>
<p>Comparator의 compare()와 Comparable의 compareTo()는 두 객체를 비교한다는 같은 기능을 목적으로 만들어 졌습니다. compareTo() 메소드는 반환값은 int지만 실제로는 비교하는 두 객체가 같으면 0, 비교하는 값보다 작으면 음수, 크면 양수를 반환하도록 구혀해야 합니다. compare()도 객체를 비교해서 음수, 0, 양수 중 하나를 반환하도록 구현해야 합니다.</p>
<blockquote>
<p>Comparable - 기본 정렬 기준(오름차순)을 구현하는데 사용<br>
Comparator - 기본 정렬 기준 외에 다른 기준으로 정렬하고자 할 때 사용</p>
</blockquote>
<p>Collections.sort() , Arrays.sort() 등 ~~.sort()는 배열이나 리스트를 정렬할 때 Comparator를 지정하지 않았을 경우<br>
<strong>Comprarable</strong>을 구현하면 구현한 클래스의 객체에 구현된 내용에 따라 정렬!!</p>
<p>Arrays.sort()는 배열을 정렬할 때, Comparator를 지정해주지 않으면 저장하는 객체에 구현된 내용에 따라 정렬됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span> <span class="comment">// 객체 배열에 저장된 객체가 구현한 Comparable에 의한 정렬</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, Comparator c)</span> <span class="comment">// 지정한 Comparator에 의한 정렬</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>다음과 같은 함수들도 존재합니다.
<ul>
<li>Arrays.sort()</li>
<li>Arrays.reverse()</li>
<li>Collections.sort()</li>
<li>Collections.reverse()</li>
</ul>
</li>
</ul>
<h1 id="set">Set</h1>
<hr>
<p><strong>특징</strong></p>
<ol>
<li>순서가 없습니다.</li>
<li>집합이므로 중복된 데이터가 들어갈 수 없습니다.</li>
<li>중복되지 않는 숫자(데이터)를 구할 때 사용하면 유용합니다.</li>
</ol>
<p>Collection의 일부인데 <code>중복되는 element를 포함하지 않는 것</code>이 가장 큰 특징이며, <code>집합</code>을 의미합니다. <strong>Set</strong>인터페이스는 Collection를 상속받아서 만들어진 인터페이스입니다. 때문에 대부분의 함수들이 Collection에서 제공하는 함수들과 동일합니다.</p>
<p><strong>List</strong>와 <strong>Set</strong>은 Collection 인터페이스를 구현한다는 점에서 비슷하다고 할 수 있습니다. 그러나 가장 큰 차이점은 <code>중복</code>에 대한 부분에서의 차이입니다.<br>
List는 같은 값에 대한 중복 추가가 가능합니다. 그러나 <code>Set</code>은 같은 값을 넣었을 때 size()로 내부 엘리먼트의 개수를 출력해보면 1이 나오는 것을 확인할 수 있습니다. 즉, 값(value)에 대한 중복을 허용하지 않습니다.</p>
<p>대표적인 Set 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>HashSet<e></e></li>
<li>TreeSet<e></e></li>
</ol>
<h2 id="hashset-클래스">HashSet<e> 클래스</e></h2>
<p>HashSet 클래스는 Set 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. JDK 1.2부터 제공된 HashSet 클래스는 해시 알고리즘(hash algorithm)을 사용하여 검색 속도가 매우 빠릅니다. 이러한 HashSet 클래스는 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다.</p>
<p>HashSet 클래스는 Set 인터페이스를 구현하므로, <strong>요소를 순서에 상관없이 저장하고, 중복된 값은 저장하지 않습니다.</strong> 만약 요소의 저장 순서를 유지해야 한다면 JDK 1.4부터 제공하는 LinkedHashSet 클래스를 사용하면 됩니다.</p>
<blockquote>
<p>사용법</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        hs.add(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="number">2</span>);</span><br><span class="line">        hs.add(<span class="number">3</span>);</span><br><span class="line">        hs.add(<span class="number">4</span>);</span><br><span class="line">        hs.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 1번</span></span><br><span class="line">        System.out.println(hs.add(<span class="number">10</span>));</span><br><span class="line">        System.out.println(hs.add(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; hs2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        hs2.add(<span class="number">3</span>);</span><br><span class="line">        hs2.add(<span class="number">4</span>);</span><br><span class="line">        hs2.add(<span class="number">5</span>);</span><br><span class="line">        hs2.add(<span class="number">6</span>);</span><br><span class="line">        hs2.add(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 교집합을 구하기 위해서는 retainAll()이라는 메소드를 사용합니다.</span></span><br><span class="line">        hs.retainAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"교집합 : "</span> + hs.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 집합 hs2는 hs의 부분집합이다.</span></span><br><span class="line">        <span class="comment">// 이것이 맞는지 알아보기 위해서는 containsAll()을 사용하면 된다.</span></span><br><span class="line">        System.out.println(hs.containsAll(hs2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 차집합을 구하기 위해서는 removeAll()이라는 메소드를 사용합니다</span></span><br><span class="line">        <span class="comment">// 집합 hs와 집합 hs2에서 집합 hs의 값들 중에서 집합 hs2에도 있는 값을</span></span><br><span class="line">        <span class="comment">// 뺀 값들이 나옵니다.</span></span><br><span class="line">        hs.removeAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"차집합: "</span> + hs.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 합집합을 구하기 위해서는 addAll()이라는 메소드를 사용하면 됩니다.</span></span><br><span class="line">        hs.addAll(hs2);</span><br><span class="line">        System.out.println(<span class="string">"합집합 : "</span> + hs.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>containsAll()</strong> : 부분집합임을 알아보기 위해서 사용</li>
<li><strong>addAll()</strong> : 합집합을 구하기 위해서 사용[합집합으로 합쳐집니다.]</li>
<li><strong>removeAll()</strong> : 차집합을 구하기 위해서 사용[hs에서 hs2를 뺀 부분을 보여줍니다.]</li>
<li><strong>retainAll()</strong> : 교집합을 구하기 위해서 사용[두 집합 중 공통된 값을 뽑아냅니다.]</li>
</ul>
<p>1번에서와 같이 add() 메소드를 사용하여 해당 HashSet에 이미 존재하는 요소를 추가하려고 하면, 해당 요소를 저장하지 않고 false를 반환하는 것을 볼 수 있습니다.</p>
<p>이때 해당 HashSet에 이미 존재하는 요소인지를 파악하기 위해서는 내부적으로 다음과 같은 과정을 거치게 됩니다.</p>
<ol>
<li>해당 요소에서 hasCode() 메소드를 호출하여 반환된 해시값으로 검색할 범위를 결정합니다.</li>
<li>해당 범위 내의 요소들을 equals() 메소드로 비교합니다.</li>
</ol>
<p>따라서 HashSet에서 add() 메소드를 사용하여 중복 없이 새로운 요소를 추가하기 위해서는 hashCode()와 equals() 메소드를 상황에 맞게 오버라이딩해야 합니다.</p>
<p><strong>오버라이딩을 통해 작성된 <code>hashCode()</code>는 다음의 세 가지 조건을 만족 시켜야 합니다.</strong></p>
<ol>
<li>실행 중인 애플리케이션 내의 동일한 객체에 대해서 여러 번 hashCode()를 호출해도 동일한 int 값을 반환해야 합니다. 하지만, 실행 시마다 동일한 int값을 반환할 필요는 없습니다. (String 클래스는 문자열의 내용으로 해시코드를 만들어 내기 때문에 내용이 같은 문자열에 대한 hashCode() 호출은 항상 동일한 해키코드를 반환합니다. 반면에 Object 클래스는 객체의 주소로 해시코드를 만들어 내기 때문에 실행할 때마다 해시코드 값이 달라질 수 있습니다.)</li>
<li>equals 메소드를 이용한 비교에 의해서 true를 얻은 두 객체에 대해 각각 hashCode()를 호출해서 얻은 결과는 반드시 같아야 합니다.</li>
<li>equals() 메소드를 호출했을 때 false를 반환하는 두 객체는 hashCode() 호출에 대해 같은 int 값을 반환하는 경우가 있어도 괜찮지만, 해싱(hashing)을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 int 값을 반환하는 것이 좋습니다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; hSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">		</span><br><span class="line">hSet.add(<span class="string">"자바"</span>);</span><br><span class="line">hSet.add(<span class="string">"서블릿"</span>);</span><br><span class="line">hSet.add(<span class="string">"스프링"</span>);</span><br><span class="line">hSet.add(<span class="string">"안드로이드"</span>);</span><br><span class="line">hSet.add(<span class="string">"자바"</span>); <span class="comment">// 중복된 데이터</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 사이즈는 4가 나옵니다. 중복을 제거함</span></span><br><span class="line">System.out.println(<span class="string">"hSet의 개수:"</span>+hSet.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator의 사용</span></span><br><span class="line">Iterator&lt;String&gt; it = hSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashSet</strong>은 <code>Iterator</code>를 사용합니다. 이유는 set은 순서가 없기 때문에 데이터에 순서를 정해서 추출해야하기 때문입니다. 중복이 안되는 것을 생각하면 <strong>Hashtable</strong>이나 <strong>HashMap</strong>과 같은 Map 형태가 떠오를 수 있습니다. 그러나 다른 점이라면, Map에서는 형태를 가진다는 점이 가장 큰차이입니다. 중복을 검사하는 대상 자체가 <strong>Key,Value</strong>이기 때문에 <code>Key를 기준으로 중복검사</code>를 하게 됩니다. <strong>이것은 중복되는 key 값을 가져서는 안되고, value는 중복되더라도 상관없다는 이야기입니다.</strong></p>
<h2 id="treeset-클래스">TreeSet<e> 클래스</e></h2>
<p><strong>TressSet 클래스는 데이터가 정렬된 상태로 저장되는 이진 검색 트리(binary search three)의 형태로 요소를 저장합니다.</strong><br>
이진 검색 트리는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. JDK 1.2부터 제공되는 TreeSet 클래스는 NavigableSet 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현합니다. TreeSet 클래스는 Set 인터페이스를 구현하므로, 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로 저장 순서를 유지하지도 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        treeSet.add(<span class="number">30</span>);</span><br><span class="line">        treeSet.add(<span class="number">40</span>);</span><br><span class="line">        treeSet.add(<span class="number">20</span>);</span><br><span class="line">        treeSet.add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for문을 이용한 요소의 출력</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : treeSet) &#123;</span><br><span class="line">            System.out.print(e + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소의 제거</span></span><br><span class="line">        treeSet.remove(<span class="number">40</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.print(iterator.next() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 크기 출력</span></span><br><span class="line">        System.out.println(<span class="string">"이진 검색 트리의 크기 : "</span> + treeSet.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// subSet() 메소드를 이용한 부분 집합의 출력</span></span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet.subSet(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet.subSet(<span class="number">10</span>, <span class="keyword">true</span>, <span class="number">20</span>, <span class="keyword">true</span>)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> </span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br><span class="line">이진 검색 트리의 크기 : <span class="number">3</span></span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 TreeSet 인스턴스에 저장되는 요소들은 모두 <strong>정렬</strong>된 상태로 저장됩니다. 또한, 위에서 사용된 subSet() 메소드는 TreeSet() 인스턴스에 저장되는 요소가 모두 정렬된 상태이기에 동작이 가능한 해당 트리의 부분 집합만을 보여주는 메소드입니다.</p>
<p>1번 라인에서 사용된 subSet() 메소드는 첫 번째 매개변수로 전달된 값에 해당하는 요소부터 시작하여 두 번째 매개변수로 전달된 값에 해당하는 요소의 바로 직전 요소까지를 반환합니다.<br>
2번 라인에서 사용된 subSet() 메소드는 두 번째와 네 번째 매개변수로 각각 첫 번째와 세 번째 매개변수로 전달된 값에 해당하는 요소를 포함할 것인지 아닌지를 명시할 수 있습니다. 즉, 2번 라인에서 네 번째 매개변수를 false로 변경하면 20을 포함하지 않게 되므로, 1번 라인과 같은 결과를 출력할 것입니다.</p>
<h2 id="set을-정렬하는-방법">Set을 정렬하는 방법</h2>
<p><strong>Set</strong>은 중복 없이 값을 넣기 위한 객체입니다. 여기서는 <code>List</code>를 사용해서 <strong>Set</strong>을 정렬할 수 있습니다. 이 방법을 이용해서 공부해보고 사용해보았습니다.</p>
<p>먼저, fruits의 객체가 있고, <strong>banana, apple, peach</strong>의 중복없는 값을 삽입합니다. 이렇게 삽입한 <code>Set</code>을 정렬하기 위해서는 fruits의 객체를 <code>List</code>로 변환을 해야합니다. 변환하는 방법은 ArrayList를 만드는 방식과 동일하고 생성자에 fruits를 넣어주면 리스트 형태로 변환이 됩니다. 여기서 공부했던 것을 떠올려보면 <code>List</code>를 정렬하기 위해서는 <strong>Collections</strong>를 사용하면 됩니다!!!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set fruits = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">fruits.add(<span class="string">"banana"</span>):</span><br><span class="line">fruits.add(<span class="string">"apple"</span>):</span><br><span class="line">fruits.add(<span class="string">"peach"</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 List로 변환</span></span><br><span class="line">List fruitsList = <span class="keyword">new</span> ArrayList(fruits);</span><br><span class="line"><span class="comment">// List 정렬</span></span><br><span class="line">Collections.sort(fruitsList);</span><br><span class="line"><span class="keyword">for</span>(String s : fruitsList)&#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">peach</span><br></pre></td></tr></table></figure>
<h2 id="set-인터페이스">Set 인터페이스</h2>
<p>Set 인터페이스는 Collection 인터페이스를 상속받으므로, Collection 인터페이스에서 정의한 메소드도 모두 사용할 수 있습니다. Set 인터페이스에서 제공하는 주요 메소드는 다음과 같습니다.</p>
<img src="/img/set_interface.png" width="500" height="200">
<h1 id="map">Map</h1>
<hr>
<p><code>Map</code> 인터페이스는 Collection 인터페이스와는 다른 저장 방식을 가집니다. Map 인터페이스를 구현한 Map 컬렉션 클래스들은 <strong>키와 값을 하나의 쌍으로 저장하는 방식을 사용합니다. (key-value)</strong><br>
여기서 key란 실질적인 value를 찾기 위한 이름의 역할을 합니다.</p>
<ul>
<li>특징</li>
</ul>
<ol>
<li>요소의 저장 순서를 유지하지 않습니다.</li>
<li>key는 중복을 허용하지 않지만, 값의 중복은 허용합니다.</li>
</ol>
<p>대표적인 Map 컬렉션 클래스에 속하는 클래스는 다음과 같습니다.</p>
<ol>
<li>HashMap&lt;K,V&gt;</li>
<li>Hashtable&lt;K,V&gt;</li>
<li>TreeMap&lt;K,V&gt;</li>
</ol>
<h2 id="hashmapltkvgt">HashMap&lt;K,V&gt;</h2>
<p>Map 컬렉션 클래스에서 가장 많이 사용되는 클래스 중 하나입니다. 그리고 JDK 1.2부터 제공된 <code>HashMap 클래스</code>는 <strong>해시 알고리즘</strong>을 사용하여 검색 속도가 매우 빠릅니다.</p>
<p><strong>HashMap 클래스는 Map 인터페이스를 구현하므로, Map의 특징인 키(Key)와 값(value)을 묶어서 하나의 데이터(entry)로 저장한다는 특징을 갖고 있습니다. 그리고 해싱(hashing)을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보입니다. 또한, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// put 메소드를 이용한 요소의 저장</span></span><br><span class="line">        map.put(<span class="string">"십"</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"삼십"</span>, <span class="number">30</span>);</span><br><span class="line">        map.put(<span class="string">"사십"</span>, <span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"이백"</span>, <span class="number">200</span>);</span><br><span class="line">        map.put(<span class="string">"십"</span>,<span class="number">30</span>); <span class="comment">// 1</span></span><br><span class="line">        map.put(<span class="string">"십"</span>,<span class="number">1010</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ketSet()을 이용해서 해당 맵에 포함된 모든 키 값들을 하나의 집합(Set)으로 반환해줍니다.</span></span><br><span class="line">        System.out.println(<span class="string">"Map에 저장된 키들의 집합:"</span> + map.keySet());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get() 메소드는 해당 key에 맞는 value 값을 반환합니다.</span></span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키: %s, 값: %s"</span>, key, map.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소 제거</span></span><br><span class="line">        System.out.println(<span class="string">"remove : "</span>+map.remove(<span class="string">"사십"</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;String&gt; keys = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">            String key = keys.next();</span><br><span class="line">            System.out.println(<span class="string">"키 : "</span> + key + <span class="string">", "</span> + <span class="string">"값 : "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace() 메소드를 이용한 요소의 수정</span></span><br><span class="line">        map.replace(<span class="string">"이백"</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"값을 수정 한 후 =&gt; "</span>+String.format(<span class="string">"키 : %s, 값 : %s"</span>,<span class="string">"이백"</span>,map.get(<span class="string">"이백"</span>))); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// map 사이즈 출력</span></span><br><span class="line">        System.out.println(<span class="string">"Map의 크기 : "</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Map에 저장된 키들의 집합:[이백, 삼십, 사십, 십]</span><br><span class="line"></span><br><span class="line">키: 이백, 값: <span class="number">200</span></span><br><span class="line">키: 삼십, 값: <span class="number">30</span></span><br><span class="line">키: 사십, 값: <span class="number">40</span></span><br><span class="line">키: 십, 값: <span class="number">1010</span></span><br><span class="line">remove : <span class="number">40</span></span><br><span class="line"></span><br><span class="line">키 : 이백, 값 : <span class="number">200</span></span><br><span class="line">키 : 삼십, 값 : <span class="number">30</span></span><br><span class="line">키 : 십, 값 : <span class="number">1010</span></span><br><span class="line">값을 수정 한 후 =&gt; 키 : 이백, 값 : <span class="number">20</span></span><br><span class="line">Map의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>1번 라인에서와 같이 동일한 키 값으로 데이터를 저장하게 되면 가장 나중에 저장된 데이터가 반영됩니다.</p>
<blockquote>
<p>자주 사용되는 for문인 Enhanced for문은 배열과 컬렉션 프레임워크에서 해당 인스턴스에 저장된 모든 요소를 순회해야 할 경우에 자주 사용됩니다.</p>
</blockquote>
<ul>
<li><strong>특징</strong>
<ul>
<li>요소의 저장순서를 유지하지 않습니다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>메소드</p>
</blockquote>
<ul>
<li>V replace(K key, V value) : 해당 맵에서 전달된 키에 대응하는 값을 특정 값으로 대체</li>
<li>boolean replace(K key, V oldValue, V newV) : 해당 맵에서 특정 값에 대응하는 전달된 키의 값을 새로운 값으로 대체함</li>
<li>void clear() : Map의 모든 객체를 삭제한다.</li>
<li>boolean containsKey(Object key) : 지정된 key객체와 일치하는 Map의 Key객체가 있는지 확인한다.</li>
<li>boolean containsValue(Object value) : 지정된 value객체와 일치하는 Map의 Value객체가 있는지 확인한다.</li>
<li>Set entrySet() : Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.</li>
<li>booelan equals(Object o) : 동일한 Map인지 비교한다.</li>
<li>Object get(Object key) : 지정한 key객체에 대응하는 value객체를 찾아서 반환한다.</li>
<li>int hashCode() : 해시코드를 반환한다.</li>
<li>boolean isEmpty() : Map이 비어있는지 확인한다.</li>
<li>Set keySet() : Map에 저장된 모든 Key객체를 반환한다.</li>
<li>Object put(Object key, Object value) : Map에 value객체를 key객체에 연결(mapping)하여 저장한다.</li>
<li>void putAll(Map t) : 지정된 Map의 모든 key-value 쌍을 추가한다.</li>
<li>Object remove(Object key) : 지정한 key객체와 일치하는 key-value객체를 삭제한다.</li>
<li>int size() : Map에 저장된 key-value 쌍의 개수를 반환한다.</li>
<li>Collection values() : Map에 저장된 모든 value객체를 반환한다.</li>
<li>V remove(Object key) : 해당 맵에서 전달된 키에 대응하는 매핑을 제거함.</li>
<li>boolean remove(Object key, Object value) : 해당 맵에서 특정 값에 대응하는 특정 키의 매핑을 제거함.</li>
</ul>
<blockquote>
<p>자바 공식 문서에서는 키와 값으로 구성되는 데이터를 매핑(mapping) 또는 엔트리(entry)라고 기술하고 있습니다.</p>
</blockquote>
<p><strong>Map 인터페이스에서 값(value)은 중복을 허용하기 때문에 Collection 타입으로 반환하고, 키(Key)는 중복을 허용하지 않기 때문에 Set 타입으로 반환합니다.</strong></p>
<blockquote>
<p>참고</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span> <span class="keyword">extends</span> <span class="title">AbstractMap</span> <span class="keyword">implements</span> <span class="title">Map</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Entry[] table; <span class="comment">// Entry 타입의 배열</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123; <span class="comment">// 내부 클래스</span></span><br><span class="line">        <span class="keyword">final</span> Object key;</span><br><span class="line">        Object value;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap은 Entry라는 내부 클래스를 다시 정의하고, 다시 Entry 타입의 배열을 선언하고 있습니다. 키(key)와  값(value)은 별개의 값이 아니라 서로 관련된 값이기 때문에 각각의 배열로 선언하기 보다는 하나의 클래스로 정의해서 하나의 배열로 다루는 것이 데이터의 무결성적인 측면에서 더 바람직하기 때문입니다.</p>
<p>HashMap은 키와 값을 각각 Object 타입으로 저장합니다. 즉 어떠한 객체도 저장할 수 있지만 키는 주로 String을 대문자 또는 소문자로 통일해서 사용하곤 합니다.</p>
<h2 id="hashtableltkeyvaluegt">Hashtable&lt;Key,Value&gt;</h2>
<p><code>Hashtable</code> 클래스는 JDK 1.0부터 사용해 온 <strong>HashMap</strong> 클래스와 같은 동작을 하는 클래스입니다. 현재의 Hashtable 클래스는 HashMap 클래스와 마찬가지로 Map 인터페이스를 상속받습니다.</p>
<p>따라서 Hashtable 클래스에서 사용할 수 있는 메소드는 HashMap 클래스에서 사용할 수 있는 메소드와 거의 같습니다. 하지만 현재에는 <strong>기존 코드와의 호환성</strong>을 위해서만 남아있으므로, Hashtable 클래스보다는 <code>HashMap</code> 클래스를 사용하는 것이 좋습니다.</p>
<h2 id="treemapltkeyvaluegt">TreeMap&lt;Key,Value&gt;</h2>
<p>TreeMap 클래스는 Key와 Value를 한 쌍으로 하는 데이터를 <code>이진 검색 트리</code>의 형태로 저장합니다. <code>이진 검색 트리</code>는 데이터를 추가하거나 제거하는 등의 기본 동작 시간이 매우 빠릅니다. TreeMap 클래스는 NavigableMap 인터페이스를 기존의 이진 검색 트리의 성능을 향상시킨 <code>Red-Black Tree</code>로 구현합니다.</p>
<p><code>TreeMap</code> 클래스는 Map 인터페이스를 구현하므로, 중복된 키로는 값을 저장할 수 없습니다. 하지만 같은 값을 다른 키로 저장하는 것은 가능합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, String&gt; tm = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put() 메소드를 이용한 요소의 저장</span></span><br><span class="line">        tm.put(<span class="number">30</span>, <span class="string">"삼십"</span>);</span><br><span class="line">        tm.put(<span class="number">10</span>, <span class="string">"십"</span>);</span><br><span class="line">        tm.put(<span class="number">40</span>, <span class="string">"사십"</span>);</span><br><span class="line">        tm.put(<span class="number">20</span>, <span class="string">"오십"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enhanced for 문과 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        System.out.println(<span class="string">"맵에 저장된 키들의 집합 : "</span> + tm.keySet());</span><br><span class="line">        <span class="keyword">for</span> (Integer key : tm.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove() 메소드를 이용한 요소의 제거</span></span><br><span class="line">        tm.remove(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// iterator() 메소드와 get() 메소드를 이용한 요소의 출력</span></span><br><span class="line">        Iterator&lt;Integer&gt; keys = tm.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">            Integer key = keys.next();</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// replace() 메소드를 이용한 요소의 수정</span></span><br><span class="line">        tm.replace(<span class="number">20</span>, <span class="string">"twenty"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer key : tm.keySet()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"키 : %s, 값 : %s"</span>, key, tm.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// size() 메소드를 이용한 요소의 총 개수</span></span><br><span class="line">        System.out.println(<span class="string">"맵의 크기 : "</span> + tm.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">맵에 저장된 키들의 집합 : [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : 오십</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line">키 : <span class="number">40</span>, 값 : 사십</span><br><span class="line"></span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : 오십</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line"></span><br><span class="line">키 : <span class="number">10</span>, 값 : 십</span><br><span class="line">키 : <span class="number">20</span>, 값 : twenty</span><br><span class="line">키 : <span class="number">30</span>, 값 : 삼십</span><br><span class="line"></span><br><span class="line">맵의 크기 : <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>위의 결과와 같이 TreeMap은 <strong>이진 검색 트리를 사용하므로 Map에 저장된 값들은 키(Key)를 기준으로 정렬된 형태로 데이터가 저장됩니다.</strong></p>
<img src="/img/clf2.png" width="650" height="200">
<img src="/img/clf3.png" width="650" height="200">
<h2 id="mapentry-인터페이스">Map.Entry 인터페이스</h2>
<p><strong>Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스</strong>입니다. 내부 클래스와 같이 인터페이스도 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스를 정의하는 것이 가능합니다.</p>
<p>Map에 저장되는 key-value(Entry) 쌍으 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았습니다.</p>
<ul>
<li>boolean equals(Object o) : 동일한 Entry인지 비교합니다.</li>
<li>Object getKey() : Entry의 key 객체를 반환합니다.</li>
<li>Object getValue() : Entry의 value 객체를 반환합니다.</li>
<li>int hashCode() : Entry의 해시코드를 반환합니다.</li>
<li>Object setValue(Object value) : Entry의 value 객체를 지정된 객체로 바꿉니다.</li>
</ul>
<h2 id="해시-알고리즘hash-algorithm">해시 알고리즘(hash algorithm)</h2>
<p><strong>해시 알고리즘(hash algorithm)이란 해시 함수(hash function)를 사용하여 데이터를 해시 테이블(hash table)에 저장하고, 다시 그것을 검색하는 알고리즘입니다. 해시 함수는 데이터가 저장되어 있는 곳을 알려주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있습니다.</strong></p>
<img src="/img/hashset_pic.png" width="500" height="200">
<p>자바에서 해시 알고리즘을 이용한 자료 구조는 위의 그림과 같이 배열과 연결 리스트로 구현됩니다. 저장할 데이터의 키 값을 해시 함수에 넣어 반환되는 값으로 배열의 인덱스를 구합니다. 그리고서 해당 인덱스에 저장된 연결 리스트에 데이터를 저장하게 됩니다.</p>
<p>예를 들어, 정수형 데이터를 길이가 10인 배열에 저장한다고 한다면 1,000,002를 검색하는 방법은 다음과 같을 수 있습니다. 1,000,002를 10으로 나눈 나머지가 2이므로 배열의 세 번째 요소에 연결된 연결 리스트에서 검색을 시작합니다. 매우 간략화한 예제이지만, 이렇게 해시 알고리즘을 이용하면 매우 빠르게 검색 작업을 수행할 수 있습니다.</p>
<p>저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 됩니다.</p>
<ol>
<li>검색하고자 하는 값의 키로 해시함수를 호출합니다.</li>
<li>해시함수의 계산결괴인 해시코드를 이용해서 해당 값이 저장되어 있는 링크드 리스트를 찾습니다.</li>
<li>링크드 리스트에서 검색한 키와 일치하는 데이터를 찾습니다.</li>
</ol>
<p>링크드 리스트는 검색에 불리한 자료구조이기 때문에 링크드 리스트의 크기가 커질수록 검색속도가 떨어지게 됩니다.</p>
<p>하나의 링크드 리스트에 최소한의 데이터만 저장되려면, 저장될 데이터의 크기를 고려해서 HashMap의 크기를 적절하게 지정해주어야 하고, 해시 함수가 서로 다른 키에 대해서 중복된 해시코드의 반환을 최소화해야 합니다. 그래야 HashMap에서 빠른 검색시간을 얻을 수 있습니다.</p>
<p>실제로는 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object 클래스에서 정의된 hashCode()를 해시함수로 사용합니다. Object 클래스에 정의된 hashCode()는 각 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 hashCode()를 호출한 결과가 서로 다른 좋은 방법입니다.</p>
<p>String 클래스의 경우 Object로부터 상속받은 hashCode()를 오버라이딩해서 문자열의 내용으로 해시코들 ㄹ만들어 냅니다. 그래서 서로 다른 String 인스턴스일지라도 같은 문자열을 가졌다면 hashCode()를 호출하면 같은 해시코드를 얻어냅니다.</p>
<p>HashSet과 마찬가지로 HashMap에서도 서로 다른 두 객체에 대해 equals()로 비교한 결과가 true인 동시에 hashCode()의 반환값이 같아야 같은 객체로 인식합니다.(이미 존재하는 키에 대한 값을 저장하면 기존의 값을 새로운 값으로 덮어씁니다.)</p>
<p>그래서 새로운 클래스를 정의할 때 equals()를 오버라이딩해야 한다면 hashCode()도 같이 오버라이딩해서 equals()의 결과가 true인 두 객체의 해시코드가 항상 같도록 해주어야 합니다.</p>
<p>그렇지 않으면 HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 equals()의 호출 결과가 true이지만 해시코드가 다른 두 객체를 서로 다른 것으로 인식하고 따로 저장할 것입니다.</p>
<h2 id="properties">Properties</h2>
<p><code>Properties</code>는 HashMap의 구 버전인 Hashtable을 상속받아 구현한 것으로, Hashtable은 키와 값을 (Object, Object)의 형태로 저장하는데 비해 Properties는 (String, String)의 형태로 저장하는 보다 단순한 컬렉션 클래스입니다.</p>
<p><strong>주로 애플리케이션의 환경설정과 관련된 속성(property)을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공합니다.</strong></p>
<h1 id="iterator-listiterator-enumeration">Iterator, ListIterator, Enumeration</h1>
<hr>
<p>위에서 공부를 하던 중에 컬렉션 프레임워크 중에서 List, Map, Set 등을 이용한 자료 구조에서 데이터에 접근하기 위해서는 가장 익숙한 for문을 사용해서 접근할 수 있습니다. for문을 사용하면 가장 간단하고 쉽게 접근할 수 있죠!</p>
<p>하지만, 내가 크기를 모른다면? 혹은 Set,Map과 같이 순서를 유지하지 않는다면 어떻게 접근할 수 있을까요?? 라는 의문에서 나온 것이 Iterator라고 생각합니다.</p>
<p><strong>Iterator, ListIterator, Enumeration</strong>은 모두 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스입니다. Enumeration은 Iterator의 구 버전이며, ListIterator는 Iterator의 기능을 향상 시킨 것 입니다.</p>
<h2 id="iterator">Iterator</h2>
<p><strong>컬렉션 프레임워크에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였습니다. 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고, Collection 인터페이스에는 Iterator를 반환하는 iterator() 함수를 정의하고 있습니다.</strong></p>
<p><strong><code>iterator()</code>는 Collection 인터페이스에 정의된 메소드이므로 Collection 인터페이스의 자손인 List와 Set에도 포함되어 있습니다.</strong> 그래서 List나 Set 인터페이스를 구현하는 컬렉션은 iterator()가 각 컬렉션의 특징에 알맞게 작성되어 있습니다. 추가적으로 Map에서도 iterator()를 사용할 수 있는데, 이는 Map의 키 집합을 반환하는 <strong>keySet()</strong> 함수는 Set을 반환하므로 iterator()를 사용할 수 있습니다.</p>
<ul>
<li>boolean hasNext() : 읽어 올 다음 요소가 남아있는지 확인합니다. 해당 이터레이션이 다음 요소를 가지고 있으면 true를 반환하고, 더 이상 다음 요소를 가지고 있지 않으면 false를 반환합니다.</li>
<li>Object next() : 다음 요소를 읽어 옵니다. next()를 호춣하기 전에 hasNext()를 호출해서 읽어 올 요소가 남아있는지 확인하는 것이 안전합니다.</li>
<li>void remove() : next()로 읽어 온 요소를 삭제합니다.(선택적 기능)</li>
</ul>
<blockquote>
<p>하지만 현재 자바에서는 될 수 있으면 JDK 1.5부터 추가된 Enhaced for문을 사용하도록 권장하고 있습니다. Enhanced for문을 사용하면 같은 성능을 유지하면서도 코드의 명확성을 확보하고 발생할 수 있는 버그를 예방해 줍니다. 하지만 요소의 선택적 제거나 대체 등을 수행하기 위한 경우에는 반복자(iterator)를 사용해야만 합니다.</p>
</blockquote>
<h2 id="listiterator와-enumeration">ListIterator와 Enumeration</h2>
<p><strong>Enumeration</strong>은 컬렉션 프레임워크가 만들어지기 이전에 사용하던 것으로 Iterator의 구 버전이라고 생각하면 됩니다.</p>
<p><strong>ListIterator</strong>는 Iterator를 상속 받아서 기능을 추가한 것으로, 컬렉션의 요소에 접근할 때 Iterator는 단방향으로만 이동할 수 있는데 반해 ListIterator는 양방향으로의 이동이 가능합니다. 다만, List 인터페이스를 구현한 컬렉션에서만 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">setExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">9</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;Integer&gt; iterator = list.listIterator();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"순방향 접근"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"역방향 접근"</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasPrevious())&#123;</span><br><span class="line">            System.out.print(iterator.previous()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">순방향 접근</span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">9</span> <span class="number">1</span> </span><br><span class="line">역방향 접근</span><br><span class="line"><span class="number">1</span> <span class="number">9</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<img src="/img/listIterator.png" width="700" height="300">
<h1 id="collections">Collections</h1>
<hr>
<p>Arrays가 배열과 관련된 메소드를 제공하는 것처럼, Collections는 컬렉션과 관련된 메소드를 제공합니다. fill(), copy(), sort(), binarySearch() 등의 메소드는 두 클래스에 포함되어 있으며 같은 기능을 합니다.</p>
<h2 id="컬렉션의-동기화">컬렉션의 동기화</h2>
<p>멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근할 수 있기 때문에 데이터의 일관성(consistency)을 유지하기 위해서는 공유되는 객체의 동기화(synchrnization)가 필요합니다.</p>
<p>Vector와 Hashtable과 같은 구버전(JDK 1.2 이전)의 클래스들은 자체적으로 동기화 처리가 되어 있는데, 멀티 쓰레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨리는 요인이 됩니다.</p>
<p>그래서 새로 추가된 ArrayList나 HashMap과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 java.util.Collections 클래스의 동기화 메소드를 이용해서 동기화 처리가 가능하도록 변경하였습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">synchronizedCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="변경불가-컬렉션-만들기">변경불가 컬렉션 만들기</h2>
<p>컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게 <strong>읽기 전용</strong>으로 만들어야 할 때가 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Collection <span class="title">unmodifiableCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> List <span class="title">unmodifiableList</span><span class="params">(List list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Set <span class="title">unmodifiableSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Map <span class="title">unmodifiableMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedSet <span class="title">unmodifiableSortedSet</span><span class="params">(SortedSet s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> SortedMap <span class="title">unmodifiableSortedMap</span><span class="params">(SortedMap m)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="컬렉션-클래스-정리-amp-요약">컬렉션 클래스 정리 &amp; 요약</h2>
<ul>
<li><strong>ArrayList</strong> : 배열기반, 데이터의 추가와 삭제에 불리합니다. 순차적인 추가/삭제는 제일 빠르고 임의의 요소에 대한 접근성이 뛰어납니다.</li>
<li><strong>LinkedList</strong> : 연결기반, 데이터의 추가와 삭제에 유리. 임의의 요소에 대한 접근성이 좋지 않습니다.</li>
<li><strong>HashMap</strong> : 배열과 연결이 결합된 형태. 추가, 삭제, 검색, 접근성이 모두 뛰어나고, 검색에는 최고 성능을 보입니다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/03/08/java-collection-framework/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/03/01/Javadepue/"
                            aria-label=": 자바 :: deque?"
                        >
                            자바 :: deque?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-03-01T20:41:19+09:00">
	
		    Mar 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>자료구조</strong>란 자료(data)를 컴퓨터에서 효율적으로 사용하도록 해주는 <strong>알고리즘</strong>을 뜻합니다.<br>
<code>(효율적 : 실행시간 최소화, 계산의 간편화 등등)</code></p>
<h1 id="deque">Deque</h1>
<blockquote>
<p><code>java.util.Deque</code>를 import합니다.<br>
<strong>Double-Ended Queue</strong>의 줄임말으로, 큐의 <code>양쪽 끝에서 삽입과 삭제</code>가 모두 발생할 수 있는 큐를 말합니다. 또한, &quot;Queue + Stack&quot;의 기능을 가지고 있습니다.</p>
</blockquote>
<p><img src="/img/deque.png" alt=""></p>
<p>위의 그림이 일반적으로 deque를 찾으면 나오는 그림입니다. 하지만, 저는 이해가 잘 가지 않아서 그림으로 간단하게 표현했습니다.<br>
<img src="/img/deque_image.png" width="600" height="300"></p>
<h2 id="method">Method</h2>
<h3 id="추가하기">추가하기</h3>
<h4 id="add">add</h4>
<ol>
<li><code>add(E e)</code> : Deque의 마지막에 Element를 삽입</li>
<li><code>addFirst(E e)</code> : Deque의 front에 요소 삽입</li>
<li><code>addLast(E e)</code> : Deque의 rear에 요소 삽입</li>
</ol>
<h4 id="put">put</h4>
<blockquote>
<p>add와 동일하게 작용합니다.</p>
</blockquote>
<ol>
<li><code>put(E e)</code> : Deque의 마지막에 Element를 삽입</li>
<li><code>putFirst(E e)</code> : Deque의 front에 Element를 삽입</li>
<li><code>putLast(E e)</code> : Deque의 rear에 Element를 삽입</li>
</ol>
<h4 id="offer">offer</h4>
<blockquote>
<p>add와 동일하게 작용합니다.</p>
</blockquote>
<ol>
<li><code>offer(E e)</code> : Deque의 마지막에 Element를 삽입</li>
<li><code>offerFirst(E e)</code> : Deque의 front에 Element를 삽입</li>
<li><code>offerLast(E e)</code> : Deque의 rear에 Element를 삽입</li>
</ol>
<h4 id="push">push</h4>
<ol>
<li><code>push(E e)</code> : Deque의 앞 부분에 Element를 삽입</li>
</ol>
<h4 id="사용법">사용법</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; test = new ArrayDeque&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">test.add(&quot;add : 0&quot;);</span><br><span class="line">test.add(&quot;add : 1&quot;);</span><br><span class="line">test.addFirst(&quot;First : 2&quot;);</span><br><span class="line">test.addLast(&quot;Last : 3&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; e = test.iterator();</span><br><span class="line">while(e.hasNext())&#123;</span><br><span class="line">	System.out.println(e.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>결과<br>
<img src="/img/result.png" alt=""></li>
</ul>
<h3 id="삭제하기">삭제하기</h3>
<h4 id="poll">poll</h4>
<ol>
<li><code>poll()</code> : Deque의 제일 앞 Element를 제거합니다. Queue에서 Element를 제거하는 것이라고 생각하면 됩니다.</li>
<li><code>pollFirst()</code> : Deque의 제일 앞 Element를 제거합니다.</li>
<li><code>pollLast()</code> : Deque의 제일 마지막 Element를 제거합니다.</li>
</ol>
<h4 id="pop">pop</h4>
<ol>
<li><code>pop()</code> : Deque의 제일 앞 Element를 제거합니다. Stack에서 Element를 제거하는 것이라고 생각하면 됩니다.</li>
</ol>
<h3 id="참고">참고</h3>
<ul>
<li><code>Queue</code>의 경우에는 <strong>FIFO:선입선출</strong>이기 때문에 제거해야 할 Element가 <code>제일 처음에 들어온 것</code>입니다. <strong>[add로 맨 처음에 들어온 것]</strong>, 즉 제일 앞에 있는 Element</li>
<li><code>Stack</code>의 경우에는 <strong>LIFO:후입선출</strong>이기 때문에 제거해야 할 Element가 <code>제일 나중에 들어온 것</code>입니다. <strong>[push로 맨 나중에 들어온 것]</strong>, 즉 제일 앞에 있는 Element</li>
</ul>
<h3 id="값을-제거하지-않고-확인만-하기">값을 제거하지 않고 확인만 하기</h3>
<h4 id="peek">peek</h4>
<p>1.<code>peek</code> : Deque의 제일 앞 Element를 return 받습니다. Element를 제거하지 않습니다.<br>
2.<code>peekFirst</code> : Deque의 제일 앞 Element를 return 받습니다.</p>
<ol start="3">
<li><code>peekLast</code> : Deque의 제일 마지막 Element를 return 받습니다.</li>
</ol>
<h4 id="get">get</h4>
<ol>
<li><code>getFirst</code> : First에 있는 Element를 return 받습니다.</li>
<li><code>getLast</code> : Last에 있는 Element를 return 받습니다.</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/03/01/Javadepue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/02/28/Java개념/"
                            aria-label=": Java :: 개념 다지기"
                        >
                            Java :: 개념 다지기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-02-28T12:37:18+09:00">
	
		    Feb 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>변수와 자료형</p>
<h1 id="변수">변수</h1>
<p>변수는 데이터의 저장과 참조를 위한 공간이라고 표현할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num1=10; // 변수를 선언하고 10을 저장했습니다.</span><br><span class="line">System.out.println(num1); // 변수 num1에 접근해서 10을 출력</span><br></pre></td></tr></table></figure>
<h2 id="변수의-이름">변수의 이름</h2>
<p>1.변수의 이름은 대소문자를 구분합니다.<br>
2.그리고 변수의 이름은 숫자로 시작할 수 없습니다.<br>
3.키워드는 변수의 이름으로 사용할 수 없습니다.<br>
<code>자바의 문법을 구성하는 단어들 : 키워드</code><br>
4.$과 _ 이외의 다른 특수문자는 사용할 수 없습니다.</p>
<h1 id="자료형">자료형</h1>
<p>자바의 자료형은 크게 두 가지로 나뉜다.</p>
<ol>
<li>Primitive type : 기본 자료형으로 일반적으로 제공하는 자료형</li>
<li>Non-Primitive type : 기본형이 아닌 자료형, 오브젝트와 관련된 자료형<br>
자료형은 변수를 선언하기 위해서 필요하기 때문에, 반드시 알아야 합니다.<br>
<code>자료형의 선언은 메모리 공간의 데이터 저장 및 참조 방식을 결정</code></li>
</ol>
<h2 id="자료형의-종류">자료형의 종류</h2>
<p>자바는 총 8개의 자료형을 제공하고 있지만, 포현하는 데이터의 종류에 따라서 크게 4가지로 구분이 됩니다. 그리고 <code>실수의 표현 및 저장에는 오차가 존재</code></p>
<ul>
<li>정수 표현 : byte, short, int, long</li>
<li>실수 표현 : float, double</li>
<li>문자 표현 : char</li>
<li>참과 거짓의 표현 : boolean</li>
</ul>
<h3 id="정수-자료형">정수 자료형</h3>
<blockquote>
<p>short(2byte)와 int(4byte) 중 어떤 것을 사용할까?</p>
</blockquote>
<ul>
<li>단순하게 메모리 공간만 생각한다면 short가 좋다고 할 수 있습니다. 하지만, 우리가 사용하는 CPU는 int형 정수 연산을 가장 고속으로 처리하도록 설계되어 있습니다. 따라서 자바는 정수 연산을 진행할 때, 모든 피연산자를 int형으로 변환하는 과정을 거칩니다. 때문에 short를 int형으로 변환하는 것보다 int형으로 선언하는 것이 더 빠릅니다.<br>
<code>그래서 정수를 선언할 때 short보다 int로 선언하는 것이 더 빠릅니다.</code></li>
</ul>
<blockquote>
<p>byte와 short는 필요할까?</p>
</blockquote>
<ul>
<li>데이터들 중에는 연산이 중심이 되는 데이터도 존재하지만, 데이터가 지니는 값 자체가 중심이 되는 경우도 있습니다. 노래와 같은 음원 정보를 저장하려면 수십만, 수백만 이상의 숫자 정보를 저장해야 하기 때문에, 이러한 경우에는 연산보다는 데이터의 표현이 중심이 됩니다.</li>
</ul>
<h3 id="실수-자료형">실수 자료형</h3>
<hr>
<blockquote>
<p>float과 double</p>
</blockquote>
<ul>
<li>정밀도를 포기하고 표현의 범위를 넓힌 자료형이기 때문에 float과 double의 선택 기준은 값의 표현범위에 있지 않습니다. 선택 기준은 <code>정밀도</code>에 있습니다.</li>
</ul>
<blockquote>
<p>실수를 표현하는데 사용이 되는 바이트의 수가 많으면 오차가 발생할 확률은 낮아진다.</p>
</blockquote>
<ul>
<li>float : 6자리의 정밀도</li>
<li>double : 15자리의 정밀도</li>
</ul>
<h3 id="문자-자료형">문자 자료형</h3>
<blockquote>
<p>char</p>
</blockquote>
<ul>
<li>하드웨어는 숫자밖에 인식을 하지 못합니다. 그래서 문자를 숫자로 포현하는 방법밖에 존재하지 않습니다. 자바는 유니코드라는 표준을 근거로 하여 문자를 표현합니다.</li>
<li>유니코드는 문자 하나를 2바이트로 표현합니다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ch1 = &apos;A&apos;; // 2byte</span><br><span class="line">char ch2 = &apos;한&apos;; // 2byte</span><br></pre></td></tr></table></figure>
<ul>
<li>char형 변수에 저장되는 것은 문자의 유니코드 상수 값입니다.</li>
</ul>
<h3 id="참과-거짓을-표현하는-boolean-자료형">'참’과 '거짓’을 표현하는 boolean 자료형</h3>
<blockquote>
<p>true : 참을 의미(1)<br>
false : 거짓을 의미(0)</p>
</blockquote>
<h1 id="상수literal">상수(literal)</h1>
<p>상수는 변수와 마찬가지로 <strong>메모리 공간에 저장</strong>이 됩니다.<br>
상수는 <strong>자료형을 기반으로 저장</strong>이 됩니다.</p>
<ol>
<li>기본적으로 모든 정수형 상수는 <code>int형</code>으로 표현 및 저장합니다.</li>
<li>기본적으로 모든 실수형 상수는 <code>double형</code>으로 포현 및 저장합니다.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num=1+5; // 1과5는 메모리 공간에 4바이트씩 할당된다.</span><br><span class="line">System.out.println(2.4+7.5); // 2.4와7.5는 메모리 공간에 8바이트씩 할당된다.</span><br></pre></td></tr></table></figure>
<h2 id="접미사">접미사</h2>
<blockquote>
<p>10000000000의 표현?? -&gt; <code>명시적 선언</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 10000000000; // 1</span><br><span class="line">long num2 = 10000000000; // 2</span><br></pre></td></tr></table></figure>
<ul>
<li>1은 int형이 표현할 수 있는 범위를 벗어났기 때문에 에러가 발생합니다.</li>
<li>2는 long형이 표현할 수 있지만, 정수형 상수는 int형으로 표현되기 때문에 에러가 발생합니다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long num3 = 10000000000L; // 3</span><br><span class="line">float num4 = 12.45F; // 4</span><br></pre></td></tr></table></figure>
<ul>
<li>3에서 숫자 뒤에 붙는 접미사 L은 <code>정수를 long형으로 표현해라!</code>의 의미입니다.</li>
<li>4에서도 마찬가지로 <code>해당 실수를 float형으로 표현</code>하라는 의미입니다.</li>
</ul>
<h1 id="자료형의-변환">자료형의 변환</h1>
<blockquote>
<p>형 변환이란? 값의 표현 방식을 바꾸는 것을 의미합니다.</p>
</blockquote>
<h2 id="1자동-형-변환">1.자동 형 변환</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double num1 = 20; // 자동 형 변환의 예[성공]</span><br><span class="line">int num2 = 20.5; // 자동 형 변환의 예[실패]</span><br></pre></td></tr></table></figure>
<ol>
<li>이 경우에는 int형 정수 20이 double형 실후 20.0으로 자동 형 변환되어 변수 num1에 저장이 됩니다.</li>
<li>두 번째 경우는 8바이트 double형 상수를 4바이트 int형 상수에 저장하려고 하고 있습니다. 이는 데이터의 손실로 인해서 형 변환이 일어나지 않습니다.</li>
</ol>
<blockquote>
<p>[byte] -&gt;[short,char] -&gt;[int] -&gt;[long] -&gt;[float] -&gt;[double]</p>
</blockquote>
<ul>
<li>자바의 자동 형 변환 규칙은 바이트 크기가 아닌, 값의 표현 범위를 기준으로 정의되어있습니다.</li>
</ul>
<h2 id="2명시적-형-변환">2.명시적 형 변환</h2>
<p>자동 형 변환 규칙에 위배되는 상황임에도 불구하고 형 변환이 필요한 경우에는 <code>명시적 형 변환</code>을 통해서 형 변환이 이루어지도록 할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num1 = (int)3.15;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int num3=100;</span><br><span class="line">int num4=(long)num3; // int형-&gt;long형 이기 때문에 상위 4바이트가 0으로 채워짐</span><br></pre></td></tr></table></figure>
<p>실수형 데이터를 형 변환하는 경우에는 소수점 이하가 잘려나가는 <strong>데이터 손실</strong>의 문제가 발생합니다. 그리고 <strong>형 변환도 값을 반환하는 하나의 연산</strong>입니다. 즉, <strong>변수에 저장된 값이 변경되는 것이 아니라 <code>변수에 저장된 값을 참조</code>하여 int형, long형으로 변환된 새로운 값</strong>을 만들어서 새로운 변수에 저장합니다.</p>
<p>연산자</p>
<h2 id="이항-연산자">이항 연산자</h2>
<p><code>피연산자</code>가 둘인 연산자<br>
<img src="/img/op.png" alt=""></p>
<h2 id="복합-대입-연산자">복합 대입 연산자</h2>
<p><code>대입 연산자</code>가 다른 연산자와 묶여서 정의되어 있는 형태의 연산자<br>
<img src="/img/op2.png" alt=""></p>
<h2 id="관계-연산자">관계 연산자</h2>
<p><code>크기 및 동등 관계</code>를 따지는 연산자이며 true 또는 false를 반환<br>
<img src="/img/rela.png" alt=""></p>
<h2 id="논리-연산자">논리 연산자</h2>
<p>true 또는 false를 반환하는 연산자<br>
true와 false를 피연산자로 연산을 진행하는 것!<br>
<img src="/img/aa.png" alt=""></p>
<h3 id="진리표">진리표</h3>
<p>논리 연산자의 연산 결과를 나타낸 표를 <strong>진리표</strong>라 합니다.<br>
<img src="/img/TruthTables.png" alt=""></p>
<h2 id="단항-연산자">단항 연산자</h2>
<p>피연산자가 하나인 연산자<br>
<img src="/img/op5.png" alt=""></p>
<ul>
<li><code>prefix</code> : 피연산자의 앞부분에 붙는다. 값이 증가/감소 하고 대입이나 그 다음 연산이 진행된다.</li>
<li><code>postfix</code> : 피연산자의 뒤에 붙는 연산자. 값을 대입하고 연산을 하고 다음 문장에서 값이 증가/감소 한다.</li>
</ul>
<h2 id="비트-연산자">비트 연산자</h2>
<p>비트 단위로 연산을 진행하는 연산자이며, 피연산자는 반드시 <code>정수</code>이어야 합니다.<br>
<strong>실수에 대해서는 비트 연산이 불가능합니다.</strong><br>
<img src="/img/op6.png" alt=""></p>
<h2 id="비트-쉬프트-연산자">비트 쉬프트 연산자</h2>
<p>피연산자의 비트 열을 왼쪽 또는 오른쪽으로 이동시키는 연산자[이항 연산자]<br>
피연산자는 모두 <code>정수</code>이어야 합니다.<br>
<img src="/img/jop7.png" alt=""></p>
<ul>
<li>왼쪽으로의 비트 열 이동은 <strong>2의 배수의 곱</strong>으로 이어집니다.</li>
<li>오른쪽으로의 비트 열 이동은 <strong>2의 배수의 나눗셈</strong>으로 이어집니다.</li>
</ul>
<blockquote>
<p>비트 쉬프트 연산은 음의 정수에서도 동일하게 적용될까?</p>
</blockquote>
<ul>
<li><code>&lt;&lt;</code>와 <code>&gt;&gt;</code> 연산자는 값의 부호를 결정하는 <code>MSB</code>를 그대로 유지하기 떄문입니다. 즉, MSB가 1이면 <code>&gt;&gt;</code>연산에 따른 빈 공간을 1로 채우고, MSB가 0이면 <code>&gt;&gt;</code> 연산에 따른 빈 공간을 0으로 채웁니다.</li>
</ul>
<p>이번에는 <code>if~else, switch, for, while문</code>등에 대해서 배워보겠습니다.</p>
<h1 id="조건문">조건문</h1>
<h2 id="if문과-if~else문">if문과 if~else문</h2>
<hr>
<blockquote>
<p>특정 조건이 만족될 때에만 실행하고픈 문장이 있다면 if를 사용!</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int num = 10;</span><br><span class="line">if(num&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(&quot;num은 0보다 크다.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if((num%2)==0))</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(&quot;num은 짝수&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(&quot;num은 홀수&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>한 문장이 있을 때는 중괄호 생략가능</li>
<li>if~else문은 하나의 문장으로 생각!</li>
</ul>
<h3 id="if~else문과-유사한-성격의-조건-연산자">if~else문과 유사한 성격의 조건 연산자</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num1=50, num2=100;</span><br><span class="line">int big = (num1&gt;num2)? num1 : num2;</span><br><span class="line">System.out.println(big);</span><br></pre></td></tr></table></figure>
<ul>
<li>(num1&gt;num2)가 true이면 : 왼쪽에 있는 숫자가 false이면 : 오른쪽에 있는 숫자가 big에 대입됩니다.</li>
</ul>
<h2 id="switch와-break">switch와 break</h2>
<blockquote>
<p><strong>조건에 따른 실행의 경우 수가 많다면 switch문이 유용!</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int n = 3;</span><br><span class="line"></span><br><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">	case 1:</span><br><span class="line">		System.out.println(&quot;1&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 2:</span><br><span class="line">		System.out.println(&quot;2&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 3:</span><br><span class="line">		System.out.println(&quot;3&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 4:</span><br><span class="line">		System.out.println(&quot;4&quot;);</span><br><span class="line">		break;</span><br><span class="line">	case 5:</span><br><span class="line">		System.out.println(&quot;5&quot;);</span><br><span class="line">		break;	</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Bye&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>switch문에 들어오는 n에 따라서 레이블 별로 실행되고 해당 레이블 영역이 실행이 끝나면 <code>break</code>문을 통해서 switch문을 빠져나갑니다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch(n)</span><br><span class="line">&#123;</span><br><span class="line">	case 1 : case 2 : case 3 :</span><br><span class="line">		System.out.println(&quot;Java&quot;);</span><br><span class="line">		break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드처럼 레이블을 한 줄에 둘 이상 붙일 수 있습니다.</li>
</ul>
<h1 id="반복문">반복문</h1>
<h3 id="while문">while문</h3>
<p><code>사용법</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">while(num&lt;5)&#123;</span><br><span class="line">	System.out.println(&quot;Java&quot;+num);</span><br><span class="line">	num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>순서</code> : 반복 조건 검사 -&gt; treu면 반복 영역 실행 - &gt; 반복 조건 검사 -&gt; true면 반복 영역 실행 …</li>
<li>반복 조건을 먼저 검사하기 때문에 반복 영역이 한 차례도 실행되지 않을 수도 있습니다.</li>
</ul>
<h3 id="do~while문">do~while문</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">do&#123;</span><br><span class="line">	System.out.println(&quot;Java&quot;+num);</span><br><span class="line">	num++;</span><br><span class="line">&#125;while(num&lt;5);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>순서</code> : 반복 영역 실행 -&gt; 반복 조건 검사 -&gt; true면 반복 영역 실행 -&gt; 반복 조건 검사 -&gt; true면 …</li>
<li>반복 영역을 먼저 실행하기 때문에, 반복 조건을 만족하지 않더라도 한 차례는 실행됩니다.</li>
</ul>
<h3 id="for-반복문">for 반복문</h3>
<blockquote>
<p><code>정해진 횟수의 반복</code>이 존재하면 for문 사용</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">	System.out.println(&quot;Java&quot;+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="continue-amp-break">continue &amp; break</h2>
<p>반복문 내에 삽입되어, <code>반복문의 실행 흐름을 조절</code>하는데 사용되는 키워드</p>
<h3 id="break">break</h3>
<p>자신을 감싸고 있는 가장 가까운 <code>반복문</code>을 빠져나가는 용도로 사용됩니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int num=1;</span><br><span class="line">boolean search = false;</span><br><span class="line"></span><br><span class="line">while(num&lt;50)&#123;</span><br><span class="line">	if(num%5==0 &amp;&amp; num%7==0)</span><br><span class="line">	&#123;</span><br><span class="line">		search = true;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	num++;</span><br><span class="line">&#125;</span><br><span class="line">if(search)</span><br><span class="line">	System.out.println(&quot;찾는 정수:&quot;+num);</span><br><span class="line">else</span><br><span class="line">	System.out.println(&quot;찾지 못했습니다.&quot;);</span><br></pre></td></tr></table></figure>
<ul>
<li>중첩된 반복문을 벗어나기 위해서는 빠져나갈 위치를 명시해 주면 됩니다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outerLoop : </span><br><span class="line">for(int i=1;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">	for(int j=1;j&lt;10;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;[&quot;+i+&quot;, &quot;+j+&quot;]&quot;);</span><br><span class="line">		if(i%2==0 &amp;&amp; j%2==0)</span><br><span class="line">			break outerLoop;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="continue">continue</h3>
<p>실행하던 반복문의 나머지 부분을 생략하고 프로그램의 흐름을 <code>조건검사 부분</code>으로 이동시킵니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int num=0;</span><br><span class="line">int count=0;</span><br><span class="line"></span><br><span class="line">while(num++&lt;100)&#123;</span><br><span class="line">	if(num%5!=0 || num%7!=0) // 5의 배수가 아니거나 7의 배수가 아니면 조건검사로 이동</span><br><span class="line">		continue;</span><br><span class="line"></span><br><span class="line">	count++;</span><br><span class="line">	System.out.println(num);</span><br><span class="line">	// 5의 배수이면서 7의 배수인 수와 개수를 찾는다. </span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;count : &quot;+ count);</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/02/28/Java개념/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Java/archives/3/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 4 of 4</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
