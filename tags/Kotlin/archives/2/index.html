
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: Kotlin - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/Kotlin/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/27/Android-Room-Concept/"
                            aria-label=": [Android] Room 개념편"
                        >
                            [Android] Room 개념편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-27T14:22:06+09:00">
	
		    Mar 27, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Room 내용에 대해 정리한 포스팅의 클릭수와 노출수가 상당히 높았다. 그래서 필자가 정리한 내용을 보니 Room에 필요한 내용이 정리되어있지만, 잘 정리되어 있다는 느낌을 받지는 못했다.</p>
<p>필자는 Room에 관한 내용을 더 깔끔하게 정리하여 이 글을 읽는 분들이 더 쉽게 이해할 수 있게 하기 위해 글을 다시 작성하려 한다.</p>
<p><strong>Android Architecture Components</strong>(이하 AAC) 중 하나인 Room의 개념에 대해 알아보는 포스팅이다.</p>
<h3 id="orm">ORM</h3>
<ul>
<li>먼저, ORM이 무엇인지 알 필요가 있다.</li>
<li>ORM은 <strong>Objectg Relational Mapping</strong>으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 <code>DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것을 의미한다.</code></li>
</ul>
<h3 id="room">Room</h3>
<ul>
<li><code>Room</code>은 ORM 기반의 라이브러리이다.</li>
<li>SQLite 위에 추상화 계층을 제공하여 SQLite의 기능을 최대한 활용하는 동시에 데이터베이스에 원활하게 접근할 수 있도록 고안된 라이브러리이다.</li>
</ul>
<h4 id="사용법">사용법</h4>
<p><strong>1) Gradle 설정 (androidX 기준)</strong></p>
<ul>
<li>version은 사용하는 시점에 최신 버전을 사용하면 된다.</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="keyword">def</span> room_version = <span class="string">"2.1.0-alpha03"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">"androidx.room:room-runtime:$room_version"</span></span><br><span class="line">    annotationProcessor <span class="string">"androidx.room:room-compiler:$room_version"</span> <span class="comment">// use kapt for Kotlin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-rxjava2:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-guava:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Coroutines support for Room</span></span><br><span class="line">    implementation <span class="string">"androidx.room:room-coroutines:$room_version"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test helpers</span></span><br><span class="line">    testImplementation <span class="string">"androidx.room:room-testing:$room_version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2) Room의 구성요소</strong></p>
<ul>
<li>
<p><code>Database</code></p>
<ul>
<li>Database 접근 지점을 제공하며 DAO를 관리한다.</li>
<li>Annotaion 내에 사용할 Entity 목록을 배열로 작성해야 한다.</li>
</ul>
</li>
<li>
<p><code>DAO</code></p>
<ul>
<li>Database에 접근하는데 사용되는 메소드들을 포함하며, Annotation으로 관리된다.</li>
<li>Select, Insert, Delete 등 데이터를 쓰거나 읽을 때 사용한다.</li>
</ul>
</li>
<li>
<p><code>Entity</code></p>
<ul>
<li>Database 내의 테이블을 의미한다.</li>
</ul>
</li>
</ul>
<img src="/img/room_st.png" width="400" height="300">
<p><strong>[Database의 특징]</strong></p>
<ul>
<li>Database 접근 지점을 제공하며, DAO를 관리한다.</li>
<li>클래스에 <code>@Database</code> 어노테이션을 붙이며, 아래의 조건을 만족해야 한다.
<ul>
<li>RoomDatabase 클래스를 상속받는 추상 클래스여야 한다.</li>
<li>어노테이션 내에 Database에 들어갈 Entity 목록을 배열로 포함해야 한다.</li>
<li>파라미터가 0개인 추상 메소드를 포함하고 @Dao 어노테이션된 클래스를 반환한다. 이를 통해 RoomDatabase에게 관리 권한을 위임하여 직접적으로 접근하는 것을 막는다.</li>
</ul>
</li>
<li>Runtime에 Room.databaseBuilder()를 호출해 데이터베이스 인스턴스를 얻을 수 있다.</li>
<li><strong>인스턴스를 만드는 과정을 많은 비용이 든다. 하지만 접근은 자주하기 때문에 문서에서는 싱글톤 패턴을 이용해 만드는 것을 권장하고 있다.</strong></li>
</ul>
<p><strong>[DAO(Data Access Object)의 특징]</strong></p>
<ul>
<li>Database에 접근하는데 사용되는 메소드들을 갖고 있으며, 어노테이션으로 관리된다.</li>
<li>SELECT, INSERT, DELETE 등 데이터를 읽거나 쓸 때 사용한다.</li>
<li>LiveData를 사용하면 Observable Query를 이용할 수 있다.</li>
<li><code>@DAO</code> 어노테이션을 활용하며, <code>interface</code> or <code>abstract class</code>로 작성해야 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">	<span class="meta">@Query(<span class="meta-string">"SELECT * FROM user"</span>)</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">getUsers</span><span class="params">()</span></span>: List&lt;UserEntity&gt;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Insert</span></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(user: <span class="type">UserEntity</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>[Entity 특징]</strong></p>
<ul>
<li>Database 내의 테이블을 의미한다. 이름을 지정할 수도 있고, 지정하지 않을 경우 default 값으로 클래스의 이름이 Entity의 이름으로 지정되며, 대소문자를 구분하지 않는다.</li>
<li>컬럼 값도 위의 규칙과 동일하다.</li>
<li>관련 필드 집합을 Entity들로 정의한다.</li>
<li>각 Entity에 대해 항목을 보관하기 위해 연결된 데이터베이스 객체 내에 테이블이 생성된다.</li>
<li>필드를 유지하려면 Room은 필드에 접근할 수 있어야 한다. 따라서 필드를 public으로 만들거나 getter/setter를 제공할 수 있어야 한다. 그렇지 않고 private으로 필드를 만든다면 에러가 발생한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span></span>(</span><br><span class="line">	<span class="keyword">val</span> userId: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="keyword">val</span> name: String=<span class="string">""</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@gus0000123/mvvm-aac-room%EC%82%AC%EC%9A%A9%EB%B2%95-1-%EA%B0%9C%EB%85%90%ED%8E%B8-59ad680ea6fe" target="_blank" rel="noopener">MVVM AAC Room사용법(1.개념편)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/27/Android-Room-Concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/07/Android-Mockito-Advanced/"
                            aria-label=": [Android] Mockito 심화편"
                        >
                            [Android] Mockito 심화편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-07T01:08:22+09:00">
	
		    Mar 07, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 심화편이다.<br>
이 글을 읽기 전에 <a href="https://woovictory.github.io/2020/03/06/Android-Mockito/">기본편</a>을 먼저 보고 오면 좋다.</p>
<h2 id="gradle">Gradle</h2>
<ul>
<li>Mockito는 기본적으로 Java 기반의 라이브러리이다.</li>
<li>그렇기 때문에 Kotlin을 함께 사용하면 모호한 부분이 존재하기 마련이다.</li>
<li>예를 들면 다음과 같은 구문들이 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person p = mock(Person.class);</span><br><span class="line">        assertTrue(p!=<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        when(p.getName()).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여기서 <code>when</code>문을 보면 그냥 쓰였다.</li>
<li>이는 자바이기 때문에 그대로 쓰이지만 코틀린에서는 다음과 같이 쓰인다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">personMockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> p: Person = mock(Person::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        assertTrue(p != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        `<span class="keyword">when</span>`(p.name).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>표현이 다르다. when의 앞뒤로 `가 붙는다.</li>
<li>자바와 코틀린을 사용할 때, 구문이 맞지 않아서 생기는 문제이다. 크게 신경 쓰이지 않을 수도 있지만, 필자는 신경이 쓰인다.</li>
<li>이뿐만 아니라, 앞서 말했던 Kotlin에서는 모든 클래스가 기본적으로 final로 선언되어 있어 Mockito는 기본적으로 Mocking을 할 수 없는 등의 여러 문제가 있다.</li>
<li>그래서 Niek Haarman이라는 분이 유지 및 관리하는 <code>mockito-kotlin</code> 라이브러리를 사용하면 깔끔하게 해결할 수 있다.</li>
</ul>
<h2 id="mockito-kotlin"><a href="https://github.com/nhaarman/mockito-kotlin" target="_blank" rel="noopener">Mockito-Kotlin</a></h2>
<p>app/build.gradle 파일에 아래와 같이 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-inline:2.21.0'</span></span><br><span class="line">testImplementation <span class="string">"com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>첫 번째는 Mockito-Kotlin 의존성이다.</li>
<li>두 번째는 Kotlin의 클래스는 기본이 final이기 때문에 mockito-inline을 추가해주어 open 클래스로 매번 선언해야 하는 번거로움을 제거한다.</li>
</ul>
<h2 id="mock-객체-만들기">Mock 객체 만들기</h2>
<ul>
<li><strong>mockito-kotlin</strong>에서는 mock을 생성할 때, 더이상 클래스를 파라미터로 전달할 필요가 없다. 코틀린의 특성처럼 타입을 유추할 수 있다면 생략이 가능하다.</li>
<li>또한, p2처럼 타입을 추론할 수 없다면 아래와 같이 &lt;&gt; 안에 타입을 명시해준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p: Person = mock()</span><br><span class="line"><span class="keyword">val</span> p2 = mock&lt;Person&gt;()</span><br></pre></td></tr></table></figure>
<h2 id="stubbing"># Stubbing</h2>
<ul>
<li><code>Stub</code> : 토막, 꽁초, 남은 부분, 몽당연필이라는 뜻으로 dummy 객체가 마치 실제로 동작하는 것처럼 보이도록 만들어놓은 것을 말한다.</li>
</ul>
<p>위키피디아에서는 test stub을 아래와 같이 정의한다.</p>
<blockquote>
<p>Test stubs provide <strong>canned answers</strong> to calls made during the test, usually not responding at all to anything outside what’s programmed in for the test.</p>
</blockquote>
<ul>
<li><strong>스텁은 &quot;canned answer&quot;를 호출한 쪽에 제공한다는 것이다.</strong></li>
<li><code>canned answer</code> : 미리 준비된 답변은 일반적인 질문에 대한 미리 정해진 답변이라는 뜻이다. 즉, stub은 실제 코드나 아직 준비되지 못한 코드를 미리 정해진 답변으로 가장하는 매커니즘이다.</li>
</ul>
<h2 id="stub-특징"># Stub 특징</h2>
<ul>
<li>dummy 객체가 실제로 동작하는 것처럼 보이게 만들어 놓은 객체</li>
<li>실제 코드나 아직 준비되지 못한 코드의 행동을 가장하는 행위</li>
<li>호출자를 실제 구현물로부터 격리시키는 목적으로 사용가능</li>
<li><strong>인터페이스 or 기본클래스가 최소한으로 구현된 상태</strong></li>
<li><strong>테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.</strong></li>
</ul>
<h2 id="stub이-주로-사용되는-경우"># Stub이 주로 사용되는 경우</h2>
<ul>
<li>구현이 되지 않은 함수나 라이브러리에서 제공하는 함수를 사용하고자 할때</li>
<li>함수가 반환하는 값을 임의로 생성하고 싶을때</li>
<li>복잡한 논리 흐름을 가지는 경우, 테스트를 단순화하고 싶을때</li>
<li>의존성을 가지는 유닛의 응답을 모사하여 독립적인 시험 수행을 하고자할 때</li>
</ul>
<h2 id="test-stub을-사용하여-얻을-수-있는-이점"># Test Stub을 사용하여 얻을 수 있는 이점</h2>
<ul>
<li>의존하는 것에 대하여 독립적으로 개발/테스트가 가능하다.
<ul>
<li>Interface만 존재하는 것을 Stub으로 개발하고 테스트할 수 있다.</li>
</ul>
</li>
<li>촘촘한 테스트가 가능하다.
<ul>
<li>Stub으로 다양한 응답결과 케이스를 만들어 테스트할 수 있다.</li>
</ul>
</li>
</ul>
<ul>
<li>mockito-kotlin은 when을 쓰지 않고 whenever를 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p : Person = mock()</span><br><span class="line">whenever(p.name).thenReturn(<span class="string">"VIC"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 식처럼 stubbing을 하거나 혹은 람다식을 사용할 수도 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> p: Person = mock &#123;</span><br><span class="line">    on &#123; name &#125; doReturn <span class="string">"LEE"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assertTrue(<span class="string">"LEE"</span> == p.name) <span class="comment">// 테스트 통과.</span></span><br></pre></td></tr></table></figure>
<h2 id="mockito-다양한-함수">Mockito 다양한 함수</h2>
<p>Mockito에서 자주 사용되거나 유용한 함수들에 대해서 알아볼 것이다.</p>
<p>더 자세한 내용은 <a href="https://aroundck.tistory.com/5851" target="_blank" rel="noopener">돼지왕 왕돼지 놀이터</a> 블로그 글을 참고하면 될 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://beomseok95.tistory.com/296" target="_blank" rel="noopener">Mockito-Kotlin 알아보기</a></li>
<li><a href="https://beomseok95.tistory.com/294" target="_blank" rel="noopener">Test Stub이란 ?</a></li>
<li><a href="https://jdm.kr/blog/222" target="_blank" rel="noopener">mockito 사용법(mockito usage)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/07/Android-Mockito-Advanced/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/03/06/Android-Mockito/"
                            aria-label=": [Android] Mockito 기본편"
                        >
                            [Android] Mockito 기본편
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-03-06T00:24:52+09:00">
	
		    Mar 06, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="mockito">Mockito</h2>
<p><strong>Mockito</strong>는 객체를 Mocking하는데 사용되는 Java 기반의 라이브러이다. JUnit과 함께 Unit Test를 작성하는데 사용된다. Android도 Unit Test를 작성하는데 공식적으로 Mockito를 사용하도록 권장하고 있다.</p>
<p>이전에 Test와 관련된 글에서도 살펴봤듯이 Android는 <strong>JVM에서 동작하는 Test</strong>와 디바이스 또는 애뮬레이터에서 동작하는 <strong>Instrumentation Test</strong>가 있다.</p>
<blockquote>
<p>mocking : 쉽게 말해서 흉내낸다는 것을 의미한다.</p>
</blockquote>
<p>이번에는 Mockito를 이용해서 Unit Test를 작성하는 방법에 대해서 알아보려고 한다.</p>
<h2 id="gradle">Gradle</h2>
<p>자바를 사용한다면 다음과 같이 한 줄을 <code>app/build.gralde</code> 파일에 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-core:2.24.5'</span></span><br></pre></td></tr></table></figure>
<p>아래의 줄은 안드로이드 Test를 위해 <strong>mockito</strong>를 사용할 때, 필요한 의존성이다. 추가하지 않아도 테스트 코드로 검증할 때 필요하지 않기 때문에 필요시 추가하도록 하자!</p>
<p><strong>아래는 androidTest 파일에서 mockito를 사용할 때, 필요하다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidTestImplementation(<span class="string">"org.mockito:mockito-android:2.24.5"</span>)</span><br></pre></td></tr></table></figure>
<p>하지만 코틀린을 사용한다면, 이렇게 의존성을 추가하여 사용할 경우에 다음과 같은 문제가 발생한다.</p>
<p><code>Mockito cannot mock/spy final class</code>라는 에러가 발생한다.</p>
<p>에러 로그를 확인해보면, Mockito가 final class를 Mock으로 만들려고 했기 때문이다. Kotlin은 기본적으로 final class로 설정되기 때문에 이러한 문제가 발생한 것이다.</p>
<p>해결하기 위해서 <code>open</code> 키워드를 Mock으로 만들려는 클래스 앞에 붙여주면 에러가 발생하지 않는다. 그러나 이런 작업을 매번 해주는 것은 귀찮은 작업이다. 그러나 우리에겐 라이브러리가 있다. 행복한 일이다~ ^__^</p>
<p>아래의 줄을 <code>app/build.gradle</code> 파일에 추가하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testImplementation <span class="string">'org.mockito:mockito-inline:2.13.0'</span></span><br></pre></td></tr></table></figure>
<p>간단히 Person이라는 클래스를 만들어서 Mockito를 사용해 mock 객체를 만들고 Mockito에서 제공하는 함수를 이용해서 person 객체의 반환 값을 지정해주는 예제이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mockito.Mockito.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">personMockTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">val</span> p: Person = mock(Person::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        assertTrue(p != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        `<span class="keyword">when</span>`(p.name).thenReturn(<span class="string">"VictoryWoo"</span>)</span><br><span class="line">        `<span class="keyword">when</span>`(p.age).thenReturn(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        assertTrue(<span class="string">"VictoryWoo"</span> == p.name)</span><br><span class="line">        assertTrue(<span class="number">27</span> == p.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mock을 통해서 Person 클래스의 객체를 생성한다.</li>
<li>when() 함수를 통해서 p 객체의 name, age의 반환값을 정해준다.</li>
<li>마지막으로 p의 반환값이 기대하는 값과 같은지 비교한다.</li>
<li>성공적으로 2개의 테스트를 통과할 수 있다.</li>
<li>여기서 <code>org.mockito.Mockito.*</code>를 import하였기 때문에 <strong>Mockito</strong>.을 생략해서 쓸 수 있다.</li>
</ul>
<p>이처럼 객체의 반환값을 임의로 정해 Unit Test를 할 수 있는 단순한 기능 외에도 Mockito는 객체에 데이터를 추가하는 다양한 기능 및 검증을 할 수 있는 함수를 많이 제공한다.</p>
<p>이번에는 Mockito와 관련된 기본 개념들에 대해서 살펴봤다.<br>
다음에는 조금 더 심화된 내용과 <strong>Mockito를 Kotlin과 함께 사용할 때, 모호한 구문을 어떻게 해결할 수 있는지에 대해서 알아볼 예정이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://codechacha.com/ko/android-mockito-cannot-mock-final-error/" target="_blank" rel="noopener">Mockito cannot mock/spy final class 에러 해결 방법</a></li>
<li><a href="https://black-jin0427.tistory.com/108" target="_blank" rel="noopener">[Android, Mockito] Unit Test using Mockito</a></li>
<li><a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito</a></li>
<li><a href="https://codechacha.com/ko/android-mockito-for-test/" target="_blank" rel="noopener">Android Mockito로 테스트 코드 작성하기 (kotlin)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/03/06/Android-Mockito/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/08/Kotlin-Double-Ref/"
                            aria-label=": [Kotlin] 더블콜론(::) 참조"
                        >
                            [Kotlin] 더블콜론(::) 참조
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-08T16:03:39+09:00">
	
		    Aug 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에서 사용하는 더블콜론 참조에 대해서 알아보려고 한다.</p>
<h2 id="리플렉션reflection이란">리플렉션(Reflection)이란</h2>
<p>코틀린에서 더블콜론(::)은 리플렉션을 위해 사용한다. 리플렉션이란 코드를 작성하는 시점에는 런타임상 컴파일된 바이트 코드에서 내가 작성한 코드가 어디에 위치하는지 알 수 없기 때문에 바이트 코드를 이용해 내가 참조하려는 값을 찾기위해 사용한다.</p>
<h2 id="자바와-코틀린에서의-리플렉션">자바와 코틀린에서의 리플렉션</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass.class -&gt; 클래스 그 자체를 리플렉션</span><br><span class="line">someInstance.getClass() -&gt; 인스턴스에서 클래스를 리플렉션</span><br></pre></td></tr></table></figure>
<ul>
<li>자바에서는 클래스를 참조할 때 위와 같이 사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass::class</span><br><span class="line">someInstance::class</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서는 더블콜론을 리플렉션을 위해 사용하며 위와 같은 형태로 사용한다.</li>
</ul>
<p>하지만 우리가 액티비티를 넘길 때는 <code>SomeClass::class.java</code>와 같이 끝에 <strong>.java</strong>가 붙는 것을 볼 수 있다. 그 이유는 자바에서 쓰는 클래스와 코틀린에서 쓰는 클래스가 다르기 때문이다.</p>
<p>자바에서의 <code>SomeClass.class</code>는 Class를 리턴한다. 반면, 코틀린에서는 <code>SomeClass::class</code>를 하면 <strong>KClass</strong>를 리턴한다. 그렇기 때문에 KClass를 Class로 바꾸어 주어야하는데 이때 .Java를 이용하여 자바 클래스 값을 받는다.</p>
<img src="/img/kclass.png" width="700" height="300">
<p>KClass 안의 java의 getter는 위 그림과 같이 확장함수 형태로 되어있으며 KClass에서 자바의 클래스 타입을 반환한다.</p>
<h2 id="코틀린에서의-함수참조">코틀린에서의 함수참조</h2>
<p>코틀린에서 SomeClass::class와 같이 클래스를 참조할 수도 있지만 SomeClass:Method와 같이 클래스 내의 메소드도 참조할 수 있고 ::Function 형식의 함수도 참조할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    numbers.filter(::isOdd)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단축형</span></span><br><span class="line"><span class="comment">//fun isOdd(x: Int) = x % 2 !=0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>isOdd() 함수를 filter를 사용한 코드이다. filter를 사용하면서 함수참조를 이용해 <code>::isOdd</code> 형태로 함수를 호출하였다.</li>
<li>필터의 원형은 IntArray에서 Int 값을 받아 Boolean을 반환하는 inline 함수이다. 마찬가지로 Int를 받아 Boolean을 반환하기 때문에 함수를 참조하여 동일한 형식의 isOdd를 사용할 수 있다.</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%EB%8D%94%EB%B8%94%EC%BD%9C%EB%A1%A0-%EC%B0%B8%EC%A1%B0-73ff25484586" target="_blank" rel="noopener">코틀린의 더블콜론(::) 참조</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/08/Kotlin-Double-Ref/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/08/Kotlin-isXXX-funcion-diff/"
                            aria-label=": [Kotlin] ixXXX() 함수들"
                        >
                            [Kotlin] ixXXX() 함수들
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-08T14:11:00+09:00">
	
		    Aug 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에서 제공되는 <strong>isEmpty, isNotEmpty, isBlank, isNotBlank, isNullOrBlank, isNullOrEmpty</strong> 함수의 차이점을 알아보려고 한다.</p>
<p>비교를 위해 사용할 문자열은 다음과 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emptyString = <span class="string">""</span></span><br><span class="line"><span class="keyword">val</span> blankString = <span class="string">" "</span></span><br><span class="line"><span class="keyword">val</span> blankNewLineString = <span class="string">" \n"</span></span><br><span class="line"><span class="keyword">val</span> withBlankString = <span class="string">" victory"</span></span><br><span class="line"><span class="keyword">val</span> nullString: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> standardString = <span class="string">"standard"</span></span><br></pre></td></tr></table></figure>
<h2 id="isempty">isEmpty</h2>
<ul>
<li>CharSequence가 아무 값도 포함하고 있지 않을 때, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isEmpty())</span><br><span class="line">    println(blankString.isEmpty())</span><br><span class="line">    println(blankNewLineString.isEmpty())</span><br><span class="line">    println(withBlankString.isEmpty())</span><br><span class="line">    println(nullString?.isEmpty())</span><br><span class="line">    println(standardString.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotempty">isNotEmpty</h2>
<ul>
<li>CharSequence가 어떠한 값을 포함하고 있을 때(공백 포함), true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotEmpty())</span><br><span class="line">    println(blankString.isNotEmpty())</span><br><span class="line">    println(blankNewLineString.isNotEmpty())</span><br><span class="line">    println(withBlankString.isNotEmpty())</span><br><span class="line">    println(nullString?.isNotEmpty())</span><br><span class="line">    println(standardString.isNotEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isblank">isBlank</h2>
<ul>
<li>CharSequence가 공백만을 가지고 있을 경우나 empty일 경우, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
<li>공백+개행문자 -&gt; 공백으로 판단한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isBlank())</span><br><span class="line">    println(blankString.isBlank())</span><br><span class="line">    println(blankNewLineString.isBlank())</span><br><span class="line">    println(withBlankString.isBlank())</span><br><span class="line">    println(nullString?.isBlank())</span><br><span class="line">    println(standardString.isBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotblank">isNotBlank</h2>
<ul>
<li>CharSequence가 empty 상황이 아니고, 값에 공백만 있지 않을 때 true를 반환한다.</li>
<li>즉, 아무 값도 없거나 공백만 있을 때는 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotBlank())</span><br><span class="line">    println(blankString.isNotBlank())</span><br><span class="line">    println(blankNewLineString.isNotBlank())</span><br><span class="line">    println(withBlankString.isNotBlank())</span><br><span class="line">    println(nullString?.isNotBlank())</span><br><span class="line">    println(standardString.isNotBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorempty">isNullOrEmpty</h2>
<ul>
<li>CharSequence가 비어있거나 null일 경우, true를 반환한다.</li>
<li>공백은 비어있는게 아니다. 그래서 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNullOrEmpty())</span><br><span class="line">    println(blankString.isNullOrEmpty())</span><br><span class="line">    println(blankNewLineString.isNullOrEmpty())</span><br><span class="line">    println(withBlankString.isNullOrEmpty())</span><br><span class="line">    println(nullString.isNullOrEmpty())</span><br><span class="line">    println(standardString.isNullOrEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorblank">isNullOrBlank</h2>
<ul>
<li>CharSequence가 null이거나 blank인 상황일 때, true를 반환한다.</li>
<li>공백+개행 -&gt; 비어있음(blank 상태)</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="summary">Summary</h2>
<p>어려운 내용은 아니지만, 헷갈리는 함수들이다. 그래서 사용할 때 자주 헷갈려서 정리를 했다. 주의해야 할 점은 다음과 같다.</p>
<ul>
<li>empty : 정말 아무 값도 가지지 않는 것을 말한다.
<ul>
<li>blank보다 empty가 작은 개념.</li>
</ul>
</li>
<li>blank : 공백만 있거나 정말 아무 값도 가지지 않는 것을 의미한다.
<ul>
<li>공백+개행문자도 공백으로 판단</li>
<li>blank가 더 큰 개념.</li>
</ul>
</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://thecommelier.tistory.com/16?category=718833#recentEntries" target="_blank" rel="noopener">[Android/Kotlin] isNotEmpty(), isNotBlank(), isNullOrEmpty(), isNullOrBlank() 차이점</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/08/Kotlin-isXXX-funcion-diff/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/04/Kotlin-inline/"
                            aria-label=": [Kotlin] inline, infix"
                        >
                            [Kotlin] inline, infix
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-04T14:59:31+09:00">
	
		    Aug 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>커니의 코틀린이라는 책을 참고하여 코틀린을 공부했다. inline이라는 개념이 나왔지만 간단하게만 설명이 되어있었고, 필자도 간단하게만 정리하고 넘어갔다. 그런데 다시 보니 무슨 개념인지 모르겠어서 정리하려고 한다.</p>
<h2 id="overview">OverView</h2>
<p>문서는 다음과 같이 설명되어있다.</p>
<blockquote>
<p>고차 함수를 사용하면 런타임 패널티가 있기 때문에 함수 구현 자체를 코드 내부에 넣음으로써 오버헤드를 없앨 수 있다.</p>
</blockquote>
<p>무슨 내용인지 잘 와닿지 않는다. 다음의 글을 보고 다시 생각해보자.</p>
<p><strong>일급 함수</strong></p>
<ul>
<li><strong>일급 함수</strong>는 스스로 객체로써 취급되는 함수로 다른 함수를 파라미터로 전달받고 반환할 수 있는 함수를 뜻한다.</li>
<li>코드를 통해서 확인해보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#123;a,b -&gt; a&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>위 함수는 두 개의 정수를 받아 하나의 정수값만을 출력하는 함수이다.</li>
<li>위와 같은 선언을 하게 된다면 Java에서 아래와 같은 코드로 변화을 하여 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(@NotNull Fuction2 body)</span></span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull(body, <span class="string">"body"</span>);</span><br><span class="line">    Object result = body.invoke(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 자동으로 컨버팅이 될 수 있기 때문에 아래와 같은 유동적인 방법도 사용이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printResult</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subtract</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a - b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    printResult(::sum)</span><br><span class="line">    printResult(::subtract)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드처럼 sum이나 subtract를 유동적으로 붙일 수 있다.</li>
</ul>
<h2 id="inline">inline</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        print(<span class="string">"문자열 출력!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드를 자바로 표현하면 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Function body)</span></span>&#123;</span><br><span class="line">    body.invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(System.out.println(<span class="string">"문자열 출력!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드와 같이 자바로 표현된다. 그리고 이 자바코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(<span class="keyword">new</span> Function()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>문제는 위의 sum이나 subtract처럼 조합하는 함수가 많아질수록 계속 N개만큼의 function 오브젝트가 생성된다. 이럴때 사용하게 되는 것이 <code>inline</code> 키워드이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        println(<span class="string">"문자열 출력"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>그리고 실제로 컴파일 시 doSomething()의 body()를 호출하는 부분에 저렇게 선언된 함수가 그대로 들어가게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body() 부분에 그대로 들어온다.</span></span><br><span class="line">System.out.println(<span class="string">"문자열 출력!"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 Fuction 인스턴스를 만들지 않고 callFunction 내부에 삽입되어 바로 선언되어지게 된다. 때문에 람다함수와 1급 함수가 호출된 곳에서 해당 함수를 가지게 된다.</li>
<li>하지만 inline 함수는 주의할 점이 있는데, <code>private</code> 키워드를 사용하여 함수를 정의할 수 없다. 대신 다른 접근 한정자인 <code>internal</code>을 사용해야 한다.</li>
</ul>
<h2 id="noinline">noinline</h2>
<ul>
<li>모든 람다함수에 inline을 쓰고싶지 않을 수 있다. 이 경우 아래와 같이 해당 람다 함수에 noinline 키워드를 추가해준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">callLambda</span><span class="params">(aLambda: ()</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> dontInlineLambda: () -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">    aLambda2: () -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="comment">// 실행.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>모든 함수를 <strong>inline</strong>을 사용하여 내부로 컨버팅 되어지길 원치않을 수 있다. 이 경우 위처럼 <strong>inline</strong>을 먼저 선언한 뒤 람다함수 중 사용하지 않을 함수에 <code>noinline</code> 키워드를 붙여준다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/kotlin-inline-noinline-%ED%95%9C%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1d54ff34151c" target="_blank" rel="noopener">[kotlin] inline, noinline 한번에 이해하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/04/Kotlin-inline/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/"
                            aria-label=": [Android] RecyclerView ClickListener"
                        >
                            [Android] RecyclerView ClickListener
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-05T12:34:18+09:00">
	
		    Jul 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 Android에서 RecyclerView를 사용할 때, 각 아이템의 ClickListener를 다는 방법에 대해서 설명하려고 한다. 여러가지 방법이 있겠지만, 이번에는 Kotlin의 특징 중 하나인 <strong>함수를 매개변수로 넘길 수 있다는 특징</strong>을 사용하려고 한다.</p>
<p>필자가 진행 중인 프로젝트의 일부 코드를 기반으로 설명할 예정이다.</p>
<h2 id="구현">구현</h2>
<ol>
<li>먼저, MainFragment에서 RecyclerView를 사용할 것이다. 그리고 RecyclerView의 각 아이템을 눌렀을 때 어떤 동작을 할 것인지를 미리 정의해둔다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startToDetailActivity</span><span class="params">(id: <span class="type">Int</span>, message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(context, MissionDetailActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        intent.putExtra(<span class="string">"id"</span>, id)</span><br><span class="line">        intent.putExtra(<span class="string">"completeMessage"</span>, message)</span><br><span class="line">        intent.putExtra(<span class="string">"main"</span>,<span class="string">"main"</span>)</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Int 타입인 id와 String 타입인 message를 매개변수로 받는 함수이다. 이 함수는 id, message를 가지고 MissionDetailActivity로 이동하는 함수이다.</p>
<ol start="2">
<li>이제는 이 함수를 RecyclerView에서 사용될 Adapter에 매개변수로 넘기는 과정이 필요하다. 이 과정은 두 단계로 나눠보도록 하겠다.</li>
</ol>
<ul>
<li>Adapter에서 함수를 인자로 받을 수 있도록 수정.</li>
<li>MainFragment에서 Adapter 객체를 만들 때 위에서 만든 함수를 전달한다.</li>
</ul>
<p>Adapter에서 함수를 인자로 받을 수 있도록 수정해보도록 하겠다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainMissionAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">var</span> onMainMissionItemClick: (<span class="built_in">Int</span>, String) -&gt; <span class="built_in">Unit</span>) :</span><br><span class="line">    RecyclerView.Adapter&lt;MainMissionViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> itemsMock = ArrayList&lt;MissionFeedResponse&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: MainMissionViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> binding = ItemListMainMissionBinding.inflate(</span><br><span class="line">            LayoutInflater.from(parent.context)</span><br><span class="line">            , parent, <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> MainMissionViewHolder(binding, onMainMissionItemClick)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainMissionAdapter의 기본 생성자를 호출하면서 <code>(Int, String) -&gt; Unit</code>을 확인할 수 있다. 이는 Int, String을 인자로 받고 반환값이 없는 함수를 의미한다. 따라서 Int, String을 인자로 받고 반환값이 없는 함수를 매개변수를 받겠다는 의미이다.</p>
<p>그리고 <strong>onCreateViewHodler</strong>에서 <strong>MainMissionViewHolder</strong>에 매개변수로 받은 <code>onMainMissionItemClick</code> 함수를 넘기고 있다. ViewHolder는 위의 남은 단계가 끝나고 살펴볼 예정이다.</p>
<p>그러면 MainFragment에서 함수를 전달해보도록 하자. 함수를 전달할 때는 람다식을 사용할 수 있다. 이유는 익명 함수이기 때문에 람다식을 이용해서 가독성을 높이고 쉽게 처리할 수 있기 때문이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mainMissionAdapter = MainMissionAdapter &#123; id, message -&gt;</span><br><span class="line">            startToDetailActivity(id, message)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>초기화 하는 코드이다. MainMissionAdapter의 인자로 id, message를 받는 익명함수가 전달되어야 하기 때문에 람다식을 통해서 id, message를 넘겨 받는다. 이는 위에서 구현해놓은 <code>startToDetailActivity()</code> 함수의 매개변수로 넘겨줘야 한다.</p>
<p>이것은 실제로 값을 받는 코드가 아니다. 이렇게 값을 받을 것이다라고 선언만 해놓은 것이지 아직 코드가 실행되지 않는다.<br>
어떻게 보면 <strong>startToDetailActivity</strong> 함수를 Adapter에 넘기는 것이다. 이 함수는 위치는 MainFragment에 존재하는 것이고 이 함수의 호출을 대신하기 위해서 함수를 넘기는 것이다.</p>
<p>따라서 함수를 넘긴다는 것의 의미는 실제로 이 함수를 넘기는 것이 아니라 원하는 값을 얻어 이 함수에 담아서 호출하기 위함이다. 그래서 Adapter에서 ViewHolder로 넘기면 ViewHolder에서 <strong>onMainMissionItemClick</strong> 이라는 익명 함수를 받는다. 코드를 먼저 보도록 하자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainMissionViewHolder</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: ItemListMainMissionBinding</span><br><span class="line">    , <span class="keyword">private</span> <span class="keyword">val</span> onMainMissionItemClick: (<span class="built_in">Int</span>, String) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(item: <span class="type">MissionFeedResponse</span>)</span></span> &#123;</span><br><span class="line">        binding.item = item</span><br><span class="line">        binding.executePendingBindings()</span><br><span class="line"></span><br><span class="line">        binding.itemMainImage.setOnClickListener &#123;</span><br><span class="line">            onMainMissionItemClick.invoke(item.mission.id, item.mission.category.completeMessage)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewHolder에서 필자가 원하는 아이템에 <strong>setOnClickListener</strong>를 통해서 클릭 리스너를 달아준다. 그리고 그 안에서 <code>onMainMissionItemClick.invoke()</code>를 호출함으로써 넘겨받은 함수를 대신 호출할 수 있도록 해준다. <strong>invoke()</strong> 함수가 함수를 대신 호출하는 의미를 가진듯 하다.</p>
<p>그래서 여기서 호출하게 되면 MainFragment에서 정의했던 startToDetailActivity() 함수가 호출되고 원하는 동작을 할 수 있게 된다.</p>
<p>내가 원하는 값을 인자로 받는 부분은 ViewHolder에서 이루어지게 되고 실제 함수는 MainFragment에 존재한다. 그리고 호출도 이 함수를 호출하게 되는 것이다.</p>
<p>설명을 두서없이 하였다. 다음에 Kotlin의 사용자 정의 get(), set()을 통해 변경된 코드로 다시 한번 설명하도록 하겠다. 그 때는 더 깔끔하게 글을 쓰도록 할 예정이다. 마지막으로 이 글을 쓴 목적은 코틀린스럽게 코드를 작성하고자 하는 사람들이 영어로 된 자료말고 이 자료를 통해서 더 쉽게 해당 지식을 얻어갔으면 하는 바램에서 작성하게 되었다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/kotlin-chap3/"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            [커니의 Kotlin] Chap3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T21:52:08+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>해당 글은 <strong>커니의 코틀린</strong> 책을 구매하여 공부하고 작성한 글입니다.</p>
<h2 id="조건-확인-함수">조건 확인 함수</h2>
<p><strong>특정 값의 일치 여부 확인</strong></p>
<ol>
<li>check() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalStateException 예외를 발생시킨다.</li>
<li>require() : 인자로 받은 표현식이 참인지 확인하며 참이 아닌 경우 IllegalArgumentException 예외를 발생시킨다.</li>
</ol>
<p>check(), require() 함수 모두 값을 확인하는 형태뿐만 아니라 조건이 일치하지 않았을 경우 수행할 작업을 함께 지정할 수 있는 형태의 함수를 지원한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(isPrepared: <span class="type">Boolean</span>, message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// isPrepared가 true가 아니면 IllegalStateException 발생.</span></span><br><span class="line">    check(isPrepared)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// message의 길이가 10 이상이 아니면 IllegalArgumentException 발생.</span></span><br><span class="line">    require(message.length&gt;<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>checkNotNull(), requireNotNull()</code> 함수를 사용해 특정 값의 널 여부를 확인하고 널이 아닌 값을 반환받을 수 있다. 이도 위의 함수처럼 <strong>단순히 값을 확인만 하는 형태와 함께 실행할 함수를 지정하는 형태를 지원한다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// message 값이 널이 아닐 때에만 해당 변수에 값이 할당된다.</span></span><br><span class="line">    <span class="keyword">val</span> msg = requireNotNull(message)</span><br><span class="line"></span><br><span class="line">    println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>명시적으로 실행 중단하기</strong></p>
<p>프로그램이 실행될 때, 호출될 가능성이 없는 영역이 있다. 하지만, 예기치 못한 이유로 이 영역이 실행되면 프로그램에 부작용이 발생하게 된다. 따라서 이 같은 영역에 진입하게 되는 경우 임의로 예외를 발생시킬 수 있다. <code>error()</code> 함수를 이용하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showMessage</span><span class="params">(isPrepared: <span class="type">Boolean</span>, message: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// isPrepared가 fals일 경우</span></span><br><span class="line">    <span class="comment">// IllegalArgumentException: Not prepared yet! 예외가 발생한다.</span></span><br><span class="line">    <span class="keyword">if</span>(!isPrepared)&#123;</span><br><span class="line">        error(<span class="string">"Not prepared yet!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다른 부분의 작업이 완료되어야 구현이 가능할 때, 보통 주석을 달아서 추가 작업이 필요하다고 표시하는 경우가 대부분이다. 하지만, 간혹 이런 주석을 확인하지 못하고 그냥 두면 버그가 발생하기도 한다. 이 문제를 해결하기 위해 코틀린에서는 <code>TODO()</code> 함수를 제공한다. 이를 통해서 <strong>NotImplementedError</strong>를 발생시켜 아직 이 부분이 완성되지 않았음을 알려준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 내부 구현이 아직 완료되지 않음.</span></span><br><span class="line">    <span class="comment">// 이 함수 호출 시 NotImplementedError가 발생.</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TODO(<span class="string">"Stop is not implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="컬렉션-생성-함수">컬렉션 생성 함수</h2>
<p><strong>1. 배열</strong></p>
<p>특정 원소를 담고 있는 배열을 생성하기 위해서 <code>arrayOf()</code> 함수를 사용한다.<br>
빈 배열을 생성하고 싶은 경우 <code>emptyArray()</code> 함수를 사용한다.<br>
널 값을 포함할 수 있는 배열을 생성하고 싶은 경우, <code>arrayOfNulls()</code> 함수를 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열을 포함하는 배열을 생성한다. 인자를 통해 타입 추론이 가능하다.</span></span><br><span class="line"><span class="keyword">val</span> cities = arrayOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 타입의 빈 배열을 생성한다. </span></span><br><span class="line"><span class="comment">// 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.</span></span><br><span class="line"><span class="keyword">val</span> emptyStringArray = emptyArray&lt;String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// size가 3이고 널 값을 포함할 수 있는 배열을 생성한다.</span></span><br><span class="line"><span class="comment">// 전달되는 인자가 없어 타입 추론이 불가능하므로 타입을 지정해줘야 한다.</span></span><br><span class="line"><span class="keyword">val</span> nullOfArray = arrayOfNulls&lt;String&gt;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>자바의 원시 타입을 포함하는 배열은 코틀린의 배열과 다른 타입으로 취급되므로, 위의 함수가 아닌 각 타입에 맞는 함수를 사용해야 한다. 아래에서 소개하는 것은 자바의 원시 타입을 포함하는 배열을 생성하는 함수들이다.</p>
<ul>
<li>booleanArrayOf() : BooleanArray 를 반환하며 자바의 boolean[] 배열과 호환된다.</li>
<li>byteArrayOf()</li>
<li>charArrayOf()</li>
<li>doubleArrayOf()</li>
<li>floatArrayOf()</li>
<li>intArrayOf()</li>
<li>longArrayOf()</li>
<li>shortArrayOf()</li>
</ul>
<p>결국 동일하기 때문에 나머지는 설명을 생략했다.</p>
<p><strong>2. 리스트</strong></p>
<ul>
<li><code>listOf()</code> : 포함하는 요소를 읽을 수만 있고 수정할 수 없는 읽기 전용 리스트를 생성할 수 있다. 다른 말로 immutable 하다고 한다.</li>
<li><code>listOfNotNull()</code> : 널 값은 무시하고 널이 아닌 값으로만 리스트를 구성할 수 있다. 인자로 전달된 모든 값이 널이라면 빈 리스트를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자가 null 값이므로 빈 리스트를 반환한다.</span></span><br><span class="line"><span class="keyword">val</span> countries = listOfNotNull(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 널 값인 인자는 무시하므로 Seoul, Tokyo만을 요소로 갖는 리스트가 생성된다.</span></span><br><span class="line"><span class="keyword">val</span> citiest = listOfNotNull(<span class="string">"Seoul"</span>, <span class="literal">null</span>, <span class="string">"Tokyo"</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>리스트에 포함된 요소를 수정할 수 있는 리스트는 <code>mutableListOf()</code> 함수를 사용하여 생성한다. 함수의 정의는 아래와 같다.</p>
<ul>
<li>fun <t> mutableListOf(vararg elements: T): MutableList<t>
<ul>
<li>인자로 받은 elements를 요소로 가지며 수정 가능한 리스트를 반환한다.</li>
</ul>
</t></t></li>
<li>fun <t> mutableListOf(): MutableList<t>
<ul>
<li>비어있는 수정 가능한 리스트를 반환한다.</li>
</ul>
</t></t></li>
</ul>
<p>또한, 자주 사용되는 ArrayList도 <code>arrayListOf()</code> 함수를 사용해 쉽게 생성할 수 있다.</p>
<p>이외에도 Map, Set(집합) 자료구조도 List와 비슷한 함수를 가지고 있다.<br>
읽기만 가능한 함수와 수정도 가능한 함수까지 이름만 다르고 동일한 형태를 취하기 때문에 설명은 생략하도록 하겠다.</p>
<ul>
<li>Map : Key, value 형태를 갖는다.</li>
<li>Set : 중복을 허용하지 않는 집합이며 순서가 없다.</li>
</ul>
<h2 id="스트림-함수">스트림 함수</h2>
<p>자바8 에서는 리스트나 맵과 같은 컬렉션에 포함된 자료를 쉽게 다룰 수 있도록 스트림 기능을 제공한다. 코틀린에서는 스트림 대신 유사한 역할을 하는 함수들을 표준 라이브러리에서 제공하며, 확장 함수 형태로 제공된다. 자바8의 스트림 기능을 사용하지 않지만, 편의상 <strong>스트림 함수</strong>라 칭하도록 하겠다.</p>
<p><strong>변환</strong></p>
<ul>
<li>map() : 함수는 컬렉션 내 인자를 다른 값이나 타입으로 변환할 때 사용한다.</li>
<li>mapIndexed() : 함수는 컬렉션 내 포함된 인자의 인덱스 값을 변환 함수 내에서 사용할 수 있다.</li>
<li>mapNotNull() : 함수는 컬렉션 내 인자를 변환함과 동시에, 변환한 값이 널 값인 경우 이를 무시한다.</li>
<li>flatMap() : 함수는 map() 함수와 달리 반환형이 Iterable이다. 따라서 하나의 인자에서 여러 개의 인자로 매핑이 필요한 경우에 사용한다.</li>
<li>groupBy() : 함수는 컬렉션 내 인자들을 지정한 기준에 따라 분류하며, 각 인자들의 리스트를 포함하는 맵 형태로 결과를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Russia"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시 이름을 대문자로 변환.</span></span><br><span class="line">    cities.map &#123; it -&gt;</span><br><span class="line">        it.toUpperCase()</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시의 이름을 받아서 길이로 변환.</span></span><br><span class="line">    cities.map &#123; it -&gt;</span><br><span class="line">        it.length</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(<span class="string">"length = <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapIndexed</span></span><br><span class="line">    cities.mapIndexed &#123; index, s -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$index</span> 번째 도시 =  <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapNotNull 길이가 5이하인 도시만 반환.</span></span><br><span class="line">    <span class="comment">// 아니면 null 반환해서 무시됨.</span></span><br><span class="line">    cities.mapNotNull &#123; it -&gt;</span><br><span class="line">        <span class="keyword">if</span> (it.length &lt;= <span class="number">5</span>) it <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// flatMap</span></span><br><span class="line">    <span class="comment">// flatMap 에서 각 인자를 끝으로 하는 새로운 범위를 반환하였으므로,</span></span><br><span class="line">    <span class="comment">// 이 범위에 해당하는 정수들이 새롭게 스트림에 추가된다.</span></span><br><span class="line">    <span class="keyword">val</span> numbers = <span class="number">1.</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">    numbers.flatMap &#123; number -&gt;</span><br><span class="line">        <span class="number">1.</span>.number</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        print(<span class="string">"<span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// groupBy</span></span><br><span class="line">    cities.groupBy &#123; city -&gt;</span><br><span class="line">        <span class="keyword">if</span> (city.length &lt;= <span class="number">5</span>) <span class="string">"A"</span> <span class="keyword">else</span> <span class="string">"B"</span></span><br><span class="line">    &#125;.forEach &#123; key, cities -&gt;</span><br><span class="line">        println(<span class="string">"key= <span class="variable">$key</span>, cities= <span class="variable">$cities</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>내 생각에 자주 사용할 함수들은 map(), flatMap() 이라고 생각한다. 까먹더라도 이 두 함수는 꼭 기억하자!</strong></p>
<p><strong>필터</strong></p>
<ul>
<li>filter() : 컬렉션 내 인자들 중 주어진 조건과 일치하는 인자만 걸러주는 역할</li>
<li>take() : 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다.</li>
<li>takeLast() : take() 함수와 반대로 뒤에서부터 이 함수의 인자로 받은 개수만큼만을 인자로 갖는 리스트를 반환한다.</li>
<li>takeWhile() : 첫 번째 인자부터 시작하여 <strong>주어진 조건을 만족하는 인자까지를 포함하는 리스트를 반환</strong>한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chap04</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 28/05/2019</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>,<span class="string">"spain"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. filter</span></span><br><span class="line">    cities.filter &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">5</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 2. take</span></span><br><span class="line">    cities.take(<span class="number">1</span>)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 3. takeLast</span></span><br><span class="line">    cities.takeLast(<span class="number">3</span>)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 4. takeWhile</span></span><br><span class="line">    <span class="comment">// spain도 문자열의 길이가 5이하지만, NewYork이 조건을 만족하지 않으므로</span></span><br><span class="line">    <span class="comment">// 이후의 인자들을 모두 무시한다.</span></span><br><span class="line">    cities.takeWhile &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">5</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// takeLastWhile</span></span><br><span class="line">    <span class="comment">// 리스트의 뒤에서부터 접근한다. 컬렉션 내 항목의 순서는 유지된다.</span></span><br><span class="line">    cities.takeLastWhile &#123; city -&gt;</span><br><span class="line">        city.length &lt; <span class="number">13</span></span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line">spain</span><br><span class="line"></span><br><span class="line"><span class="comment">// take</span></span><br><span class="line">Seoul</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeLast</span></span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br><span class="line">spain</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeWhile</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line"></span><br><span class="line"><span class="comment">// takeLastWhile</span></span><br><span class="line">spain</span><br></pre></td></tr></table></figure>
<p>drop() 함수라는 것이 존재하는데, 이는 take() 함수의 반대 역할을 한다. 조건을 만족하는 항목을 컬렉션에서 제외한 결과를 반환한다. take() 함수와 유사하게 dropLast(), dropWhile(), dropLastWhile() 함수를 지원한다. 사용 예제는 책을 참고하길 바란다.</p>
<p><strong>다른 종류의 함수</strong></p>
<ul>
<li>first() : 컬렉션 내 첫 번째 인자를 반환한다. 뿐만 아니라 조건을 만족하는 첫번째 인자를 반환할 수도 있다. 조건을 만족하는 인자가 없는 경우 <strong>NoSuchElementException</strong> 예외를 발생시킨다.</li>
<li>firstOrNull() : 예외 대신 널 값을 반환하도록 할 수 있다.</li>
<li>last() : 함수는 first() 함수와 반대 역할을 한다.</li>
<li>lastOfNull() : 함수도 지원한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>, <span class="string">"spain"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 첫 번째와 마지막 인자를 반환한다.</span></span><br><span class="line">    println(<span class="string">"first: <span class="subst">$&#123;cities.first()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"last: <span class="subst">$&#123;cities.last()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 조건에 맞는 첫 번째, 마지막 인자를 반환한다.</span></span><br><span class="line">    println(<span class="string">"first 조건: <span class="subst">$&#123;cities.first &#123; city -&gt; city.length &gt; <span class="number">5</span> &#125;</span>&#125;"</span>)</span><br><span class="line">    println(<span class="string">"first 조건: <span class="subst">$&#123;cities.last &#123; city -&gt; city.length &gt; <span class="number">5</span> &#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 없을 경우 예외가 아닌 널 값을 반환한다.</span></span><br><span class="line">    <span class="comment">// 비어있는 도시가 있으면 찾은 첫 번째 도시를 반환하지만, 없기 때문에 예외 대신 널을 반환한다.</span></span><br><span class="line">    println(cities.firstOrNull &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;)</span><br><span class="line">    println(cities.lastOrNull &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>distinct()</code> : <strong>함수는 컬렉션 내 포함된 항목 중 중복된 항목을 걸러낸 결과를 반환한다. 이때 항목의 중복 여부는 equals()로 판단하며, distinctBy() 함수를 사용하면 비교에 사용할 키 값을 직접 설정할 수 있다.</strong></li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"NewYork"</span>, <span class="string">"Singapore"</span>, <span class="string">"Mountain View"</span>, <span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 도시 목록 중 중복된 항목을 제거한다.</span></span><br><span class="line">    cities.distinct()</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 중복된 항목을 판단할 때, 도시 이름의 길이를 판단 기준으로 사용한다.</span></span><br><span class="line">    <span class="comment">// 즉, 문자열의 길이가 같은 경우 같은 항목으로 판단.</span></span><br><span class="line">    cities.distinctBy &#123; city -&gt;</span><br><span class="line">        city.length</span><br><span class="line">    &#125;.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="comment">// distinct</span></span><br><span class="line">Seoul</span><br><span class="line">Tokyo</span><br><span class="line">NewYork</span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br><span class="line"></span><br><span class="line"><span class="comment">// distincBy</span></span><br><span class="line">Seoul</span><br><span class="line">NewYork</span><br><span class="line">Singapore</span><br><span class="line">Mountain View</span><br></pre></td></tr></table></figure>
<p><strong>조합 및 합계</strong></p>
<ul>
<li><code>zip()</code> : 두 컬렉션 내의 자료들을 조합하여 새로운 자료를 만들 때 사용한다. 두 컬렉션 간 자료의 개수가 달라도 사용할 수 있으며, 이 경우에 반환되는 컬렉션의 자료 수는 조합에 사용하는 컬렉션 중 자료의 수가 더 적은 쪽을 따라간다.</li>
</ul>
<p>기본값으로는 조합된 결과를 Pair로 만들어주며, 원하는 경우 조합 규칙을 사용자가 정의하여 사용할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cityCodes = listOf(<span class="string">"SEO"</span>, <span class="string">"TOK"</span>, <span class="string">"MTV"</span>, <span class="string">"NYC"</span>)</span><br><span class="line">    <span class="keyword">val</span> cityNames = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 단순히 zip 함수를 호출.</span></span><br><span class="line">    cityCodes.zip(cityNames)</span><br><span class="line">            .forEach &#123; pair -&gt;</span><br><span class="line">                println(<span class="string">"<span class="subst">$&#123;pair.first&#125;</span> : <span class="subst">$&#123;pair.second&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line">    <span class="comment">// 조합할 자료의 타입을 zip 함수를 통해 지정하면 해당 형태로 바꿔준다.</span></span><br><span class="line">    cityCodes.zip(cityNames) &#123; code, name -&gt; <span class="string">"<span class="variable">$code</span>(<span class="variable">$name</span>)"</span> &#125;</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">SEO : Seoul</span><br><span class="line">TOK : Tokyo</span><br><span class="line">MTV : Mountain View</span><br><span class="line"></span><br><span class="line">SEO(Seoul)</span><br><span class="line">TOK(Tokyo)</span><br><span class="line">MTV(Mountain View)</span><br></pre></td></tr></table></figure>
<ul>
<li>joinToString() : 함수는 컬렉션 내 자료를 문자열 형태로 변환함과 동시에, 이를 조합하여 하나의 문자열로 생성한다. 이는 컬렉션 내 자료를 직렬화할 때 매우 유용하다.</li>
</ul>
<p>인자 없이 함수를 호출하는 경우 기본 설정을 바탕으로 컬렉션 내 자료를 문자열로 변환하며, 몇 가지 인자를 함께 전달하면 자신이 원하는 형태로 출력 문자열을 구성할 수도 있다.</p>
<ul>
<li>count() : 함수는 컬렉션 내 포함된 자료의 개수를 반환하며, 별도의 조건식을 추가하면 해당 조건을 만족하는 자료의 개수를 반환하도록 할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"기본 joinToString = <span class="subst">$&#123;cities.joinToString()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"인자 포함 joinToString = <span class="subst">$&#123;cities.joinToString(separator = " | ")&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"기본 count = <span class="subst">$&#123;cities.count()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"인자 포함 count = <span class="subst">$&#123;cities.count &#123; cities -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        cities.length &lt;= <span class="number">5</span></span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">기본 joinToString = Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">인자 포함 joinToString = Seoul | Tokyo | Mountain View | NYC | Singapore</span><br><span class="line">기본 count = <span class="number">5</span></span><br><span class="line">인자 포함 count = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>reduce()</code> : <strong>함수는 컬렉션 내 자료들을 모두 합쳐 하나의 값으로 만들어주는 역할을 한다.</strong> joinToString() 함수는 reduce() 함수의 일종이라고 볼 수 있다. 첫 번째 자료부터 조합을 시작하며, reduceRight() 함수는 동일한 작업을 컬렉션 내 마지막 자료부터 시작한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// acc 에는 지금까지 조합된 결과가, s 에는 새로 조합할 자료가 들어간다.</span></span><br><span class="line">    println(<span class="string">"reduce 결과 = <span class="subst">$&#123;cities.reduce &#123; acc, s -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        "$acc, $s"</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 마지막 인자부터 조합한다.</span></span><br><span class="line">    println(<span class="string">"reduceRight 결과 = <span class="subst">$&#123;cities.reduceRight &#123; s, acc -&gt;</span></span></span><br><span class="line"><span class="string"><span class="subst">        "$s, $acc"</span></span></span><br><span class="line"><span class="string"><span class="subst">    &#125;</span>&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">reduce 결과 = Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">reduceRight 결과 = Singapore, NYC, Mountain View, Tokyo, Seoul</span><br></pre></td></tr></table></figure>
<ul>
<li>fold() : 함수는 reduce() 함수와 거의 동일한 역할을 하나, 초기값을 지정할 수 있다. fold()도 컬렉션 내 마지막 인자부터 작업을 수행하는 foldRight() 함수를 지원한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * acc - 지금까지 조합된 결과가 들어간다.</span></span><br><span class="line"><span class="comment"> * s - 새로 조합할 자료가 들어간다.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(cities.fold(<span class="string">"초기값 지정"</span>) &#123; acc, s -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$acc</span>, <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    println(cities.foldRight(<span class="string">"마지막부터 간다."</span>)&#123; s, acc -&gt;</span><br><span class="line">        <span class="string">"<span class="variable">$acc</span>, <span class="variable">$s</span>"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">초기값 지정, Seoul, Tokyo, Mountain View, NYC, Singapore</span><br><span class="line">마지막부터 간다., Singapore, NYC, Mountain View, Tokyo, Seoul</span><br></pre></td></tr></table></figure>
<p><strong>기타 함수</strong></p>
<ul>
<li>any() : 함수는 컬렉션 내 단 하나의 자료라도 존재한다면 true를, 그렇지 않으면 false를 반환한다. 조건식을 전달할 경우, 해당 조건식을 만족하는 자료의 유무 여부를 반환한다.</li>
<li>none() : 함수는 any() 함수와 반대 작업을 수행하며, 컬렉션이 비어있는지 여부를 반환한다. 마찬가지로 조건식을 전달할 경우, 해당 조건식을 만족하는 자료가 하나도 존재하지 않는지 여부를 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="string">"Seoul"</span>, <span class="string">"Tokyo"</span>, <span class="string">"Mountain View"</span>, <span class="string">"NYC"</span>, <span class="string">"Singapore"</span>)</span><br><span class="line"></span><br><span class="line">    println(cities.any()) </span><br><span class="line">    println(cities.any &#123; city -&gt;</span><br><span class="line">        city.length &lt;= <span class="number">1</span></span><br><span class="line">    &#125;) </span><br><span class="line"></span><br><span class="line">    println(cities.none()) </span><br><span class="line">    println(cities.none &#123; city -&gt;</span><br><span class="line">        city.isEmpty()</span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="comment">// 빈 문자열을 가진 도시가 존재하지 않는지 확인한다.</span></span><br><span class="line">    <span class="comment">// 존재하지 않으므로 true 반환.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>max(), min() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내에서 각각 최대값 및 최소값을 찾아 반환한다.</li>
<li>average() : 함수는 숫자 타입의 자료를 갖는 컬렉션 내 자료들의 평균을 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = listOf(<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"max =&gt; <span class="subst">$&#123;cities.max()&#125;</span>"</span>)</span><br><span class="line">    println(<span class="string">"min =&gt; <span class="subst">$&#123;cities.min()&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">"average =&gt; <span class="subst">$&#123;cities.average().toInt()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">max =&gt; <span class="number">8</span></span><br><span class="line">min =&gt; <span class="number">0</span></span><br><span class="line">average =&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="범위-지정-함수">범위 지정 함수</h2>
<p>개발을 하다 보면 특정 객체에 있는 함수를 연속해서 사용하거나 다른 함수의 인자로 전달하기 위해 변수를 선언하고 이를 다른 곳에서는 사용하지 않는 경우가 있다. 코틀린에서는 이런 경우 유용하게 사용할 수 있는 함수를 표준 라이브러리를 통해 제공한다.</p>
<p><strong>let() 함수</strong></p>
<p>let() 함수는 이 함수를 호출한 객체를 이어지는 함수 블록의 인자로 전달한다.</p>
<ul>
<li>정의 =&gt; fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R
<ul>
<li>이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 인자로 전달하며, block 함수의 결과를 반환한다.</li>
</ul>
</li>
<li><strong>불필요한 변수 선언을 방지</strong>할 수 있다.</li>
<li><strong>널 값이 아닌 경우를 체크한 후 특정 작업을 수행</strong>할 때 사용할 수 있다.</li>
<li>Nullable 객체를 다른 Nullable 객체로 변환하는 경우</li>
<li>단일 지역 변수의 범위를 제한하는 경우</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이를 통해 불필요한 변수 선언을 방지할 수 있다.</span></span><br><span class="line">TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">16</span>f, resources.displayMetrics).toInt().let&#123;</span><br><span class="line">    <span class="comment">// 계산된 값을 인자로 받아서 함수에 바로 대입한다.</span></span><br><span class="line">    setPadding(it,<span class="number">0</span>,it,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// message가 null이 아닐 때만 블록 안의 문장을 실행한다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">do</span><span class="params">(message: <span class="type">String</span>?)</span></span>&#123;</span><br><span class="line">    message?.let&#123;</span><br><span class="line">        println(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nullable personal 객체를 nullable driversLicence 객체로 변경한다.</span></span><br><span class="line"><span class="keyword">val</span> driversLicence: Licence? = getNullablePerson?.let&#123;</span><br><span class="line">    licenceService.getDriversLicence(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단일 지역 변수의 범위를 제한한다.</span></span><br><span class="line"><span class="keyword">val</span> person: Person = getPerson()</span><br><span class="line">getPersonDao().let&#123; dao -&gt;</span><br><span class="line">    <span class="comment">// 변수 dao의 범위는 이 블록 안으로 제한된다.</span></span><br><span class="line">    dao.insert(person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>apply() 함수</strong></p>
<p>이 함수를 호출하는 객체를 이어지는 함수 블록의 리시버(receiver)로 전달한다.</p>
<ul>
<li>정의 =&gt; fun <t> T.apply(block: T.() -&gt; Unit): T
<ul>
<li>이 함수를 호출하는 객체를 이어지는 함수형 인자 block의 리시버로 전달하며, 함수를 호출한 객체를 반환한다.</li>
</ul>
</t></li>
<li>함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하므로, <strong>이 블록 내에서는 해당 객체 내의 프로퍼티나 함수를 직접 호출할 수 있다.</strong></li>
<li>따라서 객체 이름을 명시하지 않아도 되므로 <strong>코드를 간략</strong>하게 만들 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> perter = Person().apply&#123;</span><br><span class="line">    <span class="comment">// apply의 블록에서는 오직 프로퍼티만 사용한다.</span></span><br><span class="line">    name = <span class="string">"Perter"</span></span><br><span class="line">    age = <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>with() 함수</strong></p>
<p>인자로 받은 객체를 이어지는 함수 블록의 리시버로 전달한다.</p>
<ul>
<li>정의 =&gt; fun &lt;T,R&gt; with(receiver: T, block: T.() -&gt; R): R
<ul>
<li>인자로 받은 객체 receiver를 이어지는 함수형 인자 block의 리시버로 전달하며, block 결과를 반환한다.</li>
</ul>
</li>
<li>함수에서 사용할 객체를 매개변수를 통해서 받는다.</li>
<li>Non-nullable(Null이 될 수 없는) 객체에 이 함수를 사용한다.</li>
<li>그리고 결과가 필요하지 않은 경우에 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person: Person = getPerson()</span><br><span class="line">with(person)&#123;</span><br><span class="line">    println(name)</span><br><span class="line">    println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manipulateView</span><span class="params">(messageView: <span class="type">TextView</span>)</span></span>&#123;</span><br><span class="line">    with(messageView)&#123;</span><br><span class="line">        text = <span class="string">"Hello"</span></span><br><span class="line">        gravity = Gravity.CENTER</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>run() 함수</strong></p>
<p>인자가 없는 익명 함수처럼 사용하는 형태와 객체에서 호출하는 형태를 제공한다.</p>
<ul>
<li>정의 =&gt; fun <r> run(block: () -&gt; R): R
<ul>
<li>함수형 인자 block을 호출하고 그 결과를 반환한다.</li>
</ul>
</r></li>
<li>정의 =&gt; fun&lt;T,R&gt; run(block: T(). -&gt; R): R
<ul>
<li>이 함수를 호출한 객체를 함수형 인자 block의 리시버로 전달하고 그 결과를 반환한다.</li>
</ul>
</li>
</ul>
<p>run() 함수를 인자가 없는 익명 함수처럼 사용하는 경우, 복잡한 계산을 위해 여러 임시 변수가 필요할 때 유용하게 사용할 수 있다. run() 함수 내부에서 선언되는 변수들은 블록 외부에 노출되지 않으므로 변수 선언 영역을 확실히 분리할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> padding = run&#123;</span><br><span class="line">    <span class="comment">// 이 블록 내부에서 선언하는 값들은 외부에 노출되지 않는다.</span></span><br><span class="line">    <span class="keyword">val</span> defaultPadding = TypedValue.applyDimension(...)</span><br><span class="line">    <span class="keyword">val</span> extraPadding = TypedValue.applyDimension(...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 계산된 값을 반환한다.</span></span><br><span class="line">    defaultPadding+extraPadding</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>객체에서 run() 함수를 호출하는 경우 with() 함수와 유사한 목적으로 사용할 수 있다. 단, run() 함수는 안전한 호출을 사용할 수 있으므로 널 값일 수 있는 객체의 속성이나 함수에 연속적으로 접근해야 할 때 유용하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAge</span><span class="params">(person: <span class="type">Person</span>?)</span></span>&#123;</span><br><span class="line">    <span class="comment">// person을 수신 객체로 변환하여 age 값을 사용.</span></span><br><span class="line">    person?.run&#123;</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@limgyumin/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%98-apply-with-let-also-run-%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-4a517292df29" target="_blank" rel="noopener">코틀린 의 apply, with, let, also, run 은 언제 사용하는가?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/kotlin-chap3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/07/kotlin-chap2/"
                            aria-label=": [커니의 Kotlin] Chap2"
                        >
                            [커니의 Kotlin] Chap2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-07T17:15:30+09:00">
	
		    May 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="코틀린의-특징"># 코틀린의 특징</h2>
<h2 id="클래스"># 클래스</h2>
<p><strong>1. 데이터 클래스</strong></p>
<ul>
<li>자료를 저장하는 클래스를 만드는 과정을 단순하게 해준다.</li>
<li>자료를 구성하는 프로퍼티만 선언하면 컴파일러가 equlas(), hashcode(), toString(), copy() 함수를 자동으로 생성해준다.</li>
<li>코틀린에서 <code>==</code>는 자바의 equals() 메소드와 같은 동작을 한다. 즉, 값을 비교한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 주 생성자에서 데이터 클래스에 포함되는 프로퍼티를 함께 선언한다. </span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> lee = Person(<span class="string">"lee"</span>, <span class="number">26</span>)</span><br><span class="line">    <span class="keyword">val</span> park = Person(<span class="string">"park"</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="keyword">val</span> lim = Person(<span class="string">"lee"</span>,<span class="number">26</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 한정 클래스</strong></p>
<ul>
<li>한정 클래스(seald class)는 enum 클래스를 확장한 개념이다.</li>
<li>이를 상속하는 클래스는 한정 클래스로 정의되는 여러 종류 중 하나로 취급된다.</li>
<li>한정 클래스를 상속하는 클래스는 일반적으로 클래스 내에 중첩하여 선언한다. 외부에 선언할 수도 있다.</li>
<li>한정 클래스로 정의된 클래스의 종류에 따라 다른 작업을 처리해야 할 때 유용하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileApp</span></span>(<span class="keyword">val</span> os: String)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Android</span></span>(os: String, <span class="keyword">val</span> packageName: String) : MobileApp(os)</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iOS</span></span>(os: String, <span class="keyword">val</span> bundleId: String) : MobileApp(os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">whoAmI</span><span class="params">(app: <span class="type">MobileApp</span>)</span></span> = <span class="keyword">when</span>(app)&#123;</span><br><span class="line">    <span class="keyword">is</span> MobileApp.Android -&gt; println(<span class="string">"<span class="subst">$&#123;app.os&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">is</span> MobileApp.iOS -&gt; println(<span class="string">"<span class="subst">$&#123;app.os&#125;</span>"</span>)</span><br><span class="line">    <span class="comment">// 모든 경우를 처리했으므로 else를 쓰지 않아도 된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>한정 클래스에 새로운 클래스를 추가했고, 한정 클래스를 상속한 클래스의 종류에 따라 다른 동작을 처리해야 한다고 가정해보자. 새로 추가된 유형인 <strong>WindowsMobile</strong> 클래스를 처리하지 않으면 컴파일 에러가 발생하므로 새로운 유형에 대한 처리가 누락되는 것을 방지할 수 있다. <strong>따라서 동작을 처리하는 것의 누락을 방지할 수 있다는 이점을 가지고 있다.</strong></p>
<p><strong>3. 프로퍼티의 사용자 getter/setter</strong></p>
<ul>
<li>프로퍼티에는 내부에 저장된 필드의 값을 가져오거나 설정할 수 있도록 getter/setter를 내부적으로 구현하고 있다. 이는 단순히 필드의 값을 반환하거나 설정하도록 구현되어 있다.</li>
<li>사용자 지정 getter/setter의 구현을 원하는대로 변경할 수 있으며, 특정 객체의 값에 따른 다양한 정보를 속성 형태로 제공할 때 유용.</li>
<li>get(), set(value) 사용.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 나이에 따른 성인 여부를 속성 형태로 제공하는 예시.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> adult : <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age&gt;=<span class="number">19</span></span><br><span class="line">    <span class="comment">// 19세 이상이면 성인으로 간주한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용자 지정 setter를 사용하면 프로퍼티 내 필드에 설정되는 값을 제어할 수 있으나, <strong>읽고 쓰기가 모두 가능한 프로퍼티(var)에서만 사용할 수 있다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> adult : <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = age&gt;=<span class="number">19</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> address: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value)&#123;</span><br><span class="line">            field = value.subString(<span class="number">0.</span><span class="number">.9</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 사용자 지정 setter를 사용해 인자로 들어온 문자열의 앞 10자리만 필드에 저장한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="함수"># 함수</h2>
<p><strong>1. 명명된 인자</strong></p>
<ul>
<li>명명된 인자(named parameter)를 사용함으로써 함수를 호출할 때 매개변수의 순서와 상관없이 인자를 전달할 수 있다.</li>
<li>또한, 매개변수의 수가 많아지더라도 각 인자에 어떤 값이 전달되는지 쉽게 구분할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">drawCircle</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, radius: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    drawCircle(x = <span class="number">10</span>,y = <span class="number">5</span>,radius = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 순서를 바꿔도 명명된 인자를 통해서 순서를 바꿔도 동일하게 호출할 수 있다.</span></span><br><span class="line">    drawCircle(y = <span class="number">5</span>,x = <span class="number">10</span>,radius = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인자 중 일부에만 사용할 수도 있다.</span></span><br><span class="line">    drawCircle(<span class="number">10</span>,<span class="number">5</span>,radius = <span class="number">25</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 매개변수</strong></p>
<ul>
<li>함수의 매개변수에 기본값을 지정할 수 있으며, 이때 지정하는 값을 기본 매개변수라고 한다.</li>
<li>유용하게 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 반지름의 기본값으로 25를 갖는다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">drawCircle</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>, radius:<span class="type">Int</span> = <span class="number">25</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 반지름을 지정하지 않았으므로 원의 반지름은 기본 값인 25로 지정된다.</span></span><br><span class="line">    drawCircle(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 단일 표현식 표기</strong></p>
<ul>
<li>Unit 타입을 제외한 타입을 반환하는 함수라면 함수의 내용을 단일 표현식을 사용하여 정의할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본 형태.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단일 표현식.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> : <span class="built_in">Int</span> = <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반환 타입도 생략 가능.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure>
<p><strong>3. 확장 함수</strong></p>
<ul>
<li>확장 함수를 사용하여 상속 없이 기존 클래스에 새로운 함수를 추가할 수 있다.</li>
<li>확장 함수를 추가할 대상 클래스는 리시버 타입(receiver type)이라 부르며, 이 리시버 타입 뒤에 점(.)을 찍고 그 뒤에 원하는 함수의 형태를 적는 방식으로 정의한다.</li>
<li>확장 함수 구현부에서는 this를 사용하여 클래스의 인스턴스에 접근할 수 있으며 이를 리시버 객체(receiver object)라 부른다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> foo = <span class="string">"Foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> foobar = foo.withBar()</span><br><span class="line">    println(foobar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 클래스에 withPostfix() 함수 추가.</span></span><br><span class="line"><span class="comment">// this를 사용하여 인스턴스에 접근할 수 있다.</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">withPostfix</span><span class="params">(postFix: <span class="type">String</span>)</span></span> : String&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$this</span><span class="variable">$postFix</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this를 사용하여 인스턴스에 접근할 수 있으므로, 앞에서 정의한 확장 함수를 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">withBar</span><span class="params">()</span></span> = <span class="keyword">this</span>.withPostfix(<span class="string">"Bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">FooBar</span><br></pre></td></tr></table></figure>
<ul>
<li>확장 함수를 호출하는 모습이 클래스 내 정의된 함수의 경우와 똑같다 할지라도, 이는 클래스 외부에 정의하는 함수이다.</li>
<li>리시버 객체에서는 클래스 내 public으로 정의된 프로퍼티나 함수에만 접근할 수 있다.</li>
<li><strong>확장 함수는 리시버 타입에 직접 추가되는 함수가 아니다. 리시버 타입과 확장 함수의 인자를 인자로 받는 새로운 함수를 만들고, 확장 함수를 호출하면 이 새로운 함수가 호출되는 형태이다.</strong></li>
</ul>
<p><strong>4. 연산자 오버로딩</strong></p>
<ul>
<li>사용자 정의 타입에 한해 연산자 오버로딩을 지원한다.</li>
<li>각 연산자별로 사전 정의된 함수를 재정의하는 방식으로 연산자 오버로딩을 사용할 수 있다.</li>
<li><code>operator</code> 키워드를 사용하며, 기존의 연산자를 재정의하는 것만 허용된다.</li>
<li>연산자 재정의는 방법이 동일하기 때문에 사용자가 원하는 형태를 직접 구현하면 된다. 아래에 단항 연산자를 기준으로 예를 들어보겠다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volume</span></span>(<span class="keyword">var</span> left: <span class="built_in">Int</span>, <span class="keyword">var</span> right: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 단항 연산자 '-'를 재정의한다.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">unaryMinus</span><span class="params">()</span></span>: Volume&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = -<span class="keyword">this</span>.left</span><br><span class="line">        <span class="keyword">this</span>.right = -<span class="keyword">this</span>.right</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> voulme = Volume(<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Volume 클래스 내 left, right 값이 반전되어 할당된다.</span></span><br><span class="line"><span class="keyword">var</span> v1 = -volume</span><br></pre></td></tr></table></figure>
<p>주의할 점은 <strong>비교 연산자</strong>의 경우에는 다른 연산자와 달리 각 연산자가 모두 동일한 함수에 할당된다. 따라서 해당 함수가 반환하는 값의 크기에 따라 해당 연산자의 참, 거짓 여부를 판단한다. <strong>comparTo 함수의 반환형은 항상 Int 어야 한다.</strong></p>
<h2 id="람다-표현식"># 람다 표현식</h2>
<ul>
<li>람다 표현식을 통해 훨씬 간편하고 직관적인 문법을 사용할 수 있다.</li>
<li>특히 익명 클래스를 간결하게 표현할 때 유용하게 사용할 수 있다.</li>
<li>중괄호를 사용하여 앞뒤를 묶어준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식을 사용한 리스너 선언.</span></span><br><span class="line">button.setOnClickListener(&#123;v: View -&gt; doSomething()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인자 타입 생략 가능.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething()&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>람다 표현식에서 하나의 메소드만 호출한다면 <strong>멤버 참조</strong>를 이용해 더 간략하게 표현할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(v: <span class="type">View</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething() 함수 하나만을 호출하고 있다.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething(v)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 멤버 참조를 사용해 doSomething() 함수에 바로 대입할 수 있다.</span></span><br><span class="line">button.setOnClickListener(::doSomething)</span><br></pre></td></tr></table></figure>
<p>코틀린에서는 프로퍼티도 멤버 참조를 지원한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 성인 여부를 표시하는 프로퍼티</span></span><br><span class="line">    <span class="keyword">val</span> adult = age&gt;<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printAdults</span><span class="params">(people: <span class="type">List</span>&lt;<span class="type">Person</span>&gt;)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 필터링 조건을 람다 표현식을 사용해 대입.</span></span><br><span class="line">    people.filter(&#123;people -&gt; people.adult&#125;)</span><br><span class="line">        .forEach&#123; println(<span class="string">"Name= <span class="subst">$&#123;it.name&#125;</span>) &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 멤버 참조를 사용해 adult 프로퍼티를 바로 대입한다.</span></span><br><span class="line"><span class="string">    people.filter(Person::adult)</span></span><br><span class="line"><span class="string">        .forEach&#123; println("</span>Name= $&#123;it.name&#125;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>람다 표현식의 유용한 기능</strong></p>
<ul>
<li>함수가 단 하나의 함수 타입 매개변수를 가질 경우, 인자 대입을 위한 괄호를 생략하고 바로 람다 표현식을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setOnClickListener의 마지막 인자로 함수 타입을 대입한다.</span></span><br><span class="line">button.setOnClickListener(&#123;v -&gt; doSomething()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 다른 인자가 없으므로, 괄호 없이 바로 외부에 람다 표현식을 사용할 수 있다.</span></span><br><span class="line">button.setOnClickListener &#123; v -&gt; doSomething() &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>또한, 람다 표현식 내 매개변수의 개수가 하나인 경우 매개 변수 선언을 생략할 수 있으며, 참조가 필요한 경우 it을 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener&#123; doSomething(it) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>여러 개의 매개 변수를 갖는 람다 표현식에서 사용하지 않는 매개변수는 이름 대신 _를 사용하여 사용하지 않는 매개변수라는 것을 명시할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dialog = AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dialog 매개 변수를 사용하지 않아 _로 표시</span></span><br><span class="line">    .setNegativeButton(<span class="string">"Cancel"</span>) &#123;_, which -&gt; doCancel(which)&#125;</span><br><span class="line">    .create()</span><br></pre></td></tr></table></figure>
<p><strong>인라인 함수</strong></p>
<ul>
<li>람다 표현식을 사용하면, 함수를 인자로 넘길 수 있는 고차 함수(higher-order function)에 들어갈 함수형 인자를 쉽게 표현할 수 있다.</li>
<li>인라인 함수를 사용하면 함수의 매개변수로 받는 함수형 인자의 본체를 해당 인자가 사용되는 부분에 그대로 대입하므로 성능 하락을 방지할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 인자로 받은 함수를 내부에서 실행하는 함수.</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    println(<span class="string">"onPreExecute()"</span>)</span><br><span class="line">    body()</span><br><span class="line">    println(<span class="string">"onPostExecute()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인라인 함수 호출.</span></span><br><span class="line">doSomething&#123; println(<span class="string">"do Something()"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>인라인 함수는 컴파일 과정에서 아래와 같이 변환된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"onPreExecute()"</span>)</span><br><span class="line"><span class="comment">// 인자로 전달된 함수 본체의 내용이 그대로 복사된 것을 확인할 수 있다.</span></span><br><span class="line">println(<span class="string">"do Something()"</span>)</span><br><span class="line">println(<span class="string">"onPostExecute()"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="여타-특징"># 여타 특징</h2>
<p><strong>타입 별칭</strong></p>
<ul>
<li>복잡한 구조로 구성된 타입을 간략하게 표현할 수 있다.</li>
<li><code>typealias</code>를 사용한다.</li>
<li>클래스나 함수와 마찬가지로 타입을 인자로 받을 수도 있으며, 함수형 타입에도 타입 별칭을 지정할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;Person&gt;을 PeopleList라는 이름을 갖는 타입 별칭으로 선언.</span></span><br><span class="line">typealias PeopleList = List&lt;Person&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(people: <span class="type">PeopleList</span>)</span></span>&#123;</span><br><span class="line">    people.forEach&#123;</span><br><span class="line">        <span class="comment">// 메시지 전송.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>타입 별칭을 사용해 새롭게 선언한다고 해서 이 타입에 해당하는 새로운 클래스가 생성되는 것은 아니다. <strong>타입 별칭으로 선언된 타입은 컴파일 시점에 모두 원래 타입으로 변환되므로 실행 시점의 부하가 없다는 장점이 있다.</strong></p>
<p><strong>분해 선언</strong></p>
<ul>
<li>각 프로퍼티가 가진 자료의 값을 한번에 여러 개의 값(val) 혹은 변수(var)에 할당할 수 있다. 이 기능을 분해 선언이라고 부른다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: Strig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = Person(<span class="string">"Lee"</span>,<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사람 객체에 포함된 필드의 값을 한번에 여러 값에 할당한다.</span></span><br><span class="line"><span class="keyword">val</span> (ageOfPerson, nameOfPerson) = person</span><br></pre></td></tr></table></figure>
<p>분해 선언은 프로퍼티가 가진 자료의 값을 어떻게 전달할까? 이를 알아보기 위해 해당 코드가 어떻게 컴파일되는지 아래에서 알아보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ageOfPerson: <span class="built_in">Int</span> = person.component1()</span><br><span class="line"><span class="keyword">val</span> nameOfPerson: String = person.component2()</span><br></pre></td></tr></table></figure>
<p>이처럼 분해 선언을 사용하면 내부적으로 각 값에 component1(), component2() 함수의 반환값을 할당한다. 프로퍼티의 수가 늘어나면 3,4, … 와 같이 함수 뒤의 숫자가 증가하는 형태, 즉 componentN() 형태의 함수를 추가로 사용하게 된다.</p>
<p>분해 선언을 사용하려면 클래스에 프로퍼티의 수만큼 componentN() 함수가 있어야 하며, 이 함수들을 포함하고 있는 클래스에만 분해 선언을 사용할 수 있다. 아래는 분해 선언을 기본으로 제공하는 클래스들이다.</p>
<ul>
<li>data class로 선언된 클래스</li>
<li>kotlin.Pair</li>
<li>kotlin.Triple</li>
<li>kotlin.collections.Map.Entry</li>
</ul>
<p>특히, 맵 자료구조를 사용할 때 유용하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cities: Map&lt;String, String&gt; = ... <span class="comment">// 도시 정보를 저장하고 있는 맵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 맵 내 각 항목의 키와 값을 별도로 선언하여 사용한다.</span></span><br><span class="line"><span class="comment">// 따라서 keySet()과 같은 함수가 필요없어진다.</span></span><br><span class="line"><span class="keyword">for</span>((cityCode, name) <span class="keyword">in</span> cities)&#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$cityCode</span> = <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 람다 표현식 내 매개변수에서도 분해 선언을 사용할 수 있다.</span></span><br><span class="line">cities.forEach&#123; cityCode, name -&gt;</span><br><span class="line">    println(<span class="string">"<span class="variable">$cityCode</span> = <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>분해 선언을 지원하는 클래스를 제외한 개발자가 작성한 클래스에서 분해 선언을 사용하고 싶다면, <strong>해당 클래스 내에 별도로 componentN() 함수를 프로퍼티의 선언 순서 및 타입에 알맞게 추가해줘야 한다.</strong></p>
<p>componentN() 함수를 선언할 때는 앞에 operator를 붙여 줘야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="comment">// 첫 번째 프로퍼티의 값 반환.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = <span class="keyword">this</span>.age</span><br><span class="line">    <span class="comment">// 두 번째 프로퍼티의 값 반환.</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> person = Person(<span class="string">"lee"</span>,<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 분해 선언 사용.</span></span><br><span class="line"><span class="keyword">val</span> (age,name) = person</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용하지 않는 변수 혹은 값은 _로 표시한다.</span></span><br><span class="line"><span class="comment">// 따라서 아래는 name 만 사용하는 경우이다.</span></span><br><span class="line"><span class="keyword">val</span> (_, name) = person</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/07/kotlin-chap2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/03/kotlin-chap1-2/"
                            aria-label=": [커니의 Kotlin] Chap1.2"
                        >
                            [커니의 Kotlin] Chap1.2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-03T20:47:16+09:00">
	
		    May 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>1부에 이어서 작성…</p>
<h2 id="특징들"># 특징들</h2>
<p><strong>생성자</strong></p>
<ul>
<li>생성자 부분은 자바와 비교했을 때 조금 다른 면이 있다.</li>
<li>다음은 기본 생성자의 정의이다.
<ul>
<li>init 블록을 사용해 기본 생성자를 대체한다.</li>
</ul>
</li>
<li>생성자에 인자가 필요한 경우 인자처럼 받을 수 있다.
<ul>
<li>이를 주 생성자라고 부른다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        <span class="comment">// 기본 생성자에서 수행할 작업.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(a : <span class="built_in">Int</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    init&#123;</span><br><span class="line">        println(<span class="string">"<span class="variable">$a</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>생성자의 인자를 통해 클래스 내부의 프로퍼티에 값을 할당할 수 있다.</li>
<li>생성자의 인자를 통해 프로퍼티 선언을 대신한다. 따라서 추가로 프로퍼티 선언이 필요 없다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>생성자의 인자에서 프로퍼티 선언이 함께 이루어지고, 값 할당 또한 생성자 호출과 동시에 수행되므로 짧은 코드를 확인할 수 있다.</li>
<li>주 생성자 외에 다른 형태의 생성자가 필요한 경우 <code>constructor</code> 키워드를 사용해 선언할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a 값만 인자로 받는 추가 생성자.</span></span><br><span class="line">    <span class="comment">// 기본 생성자를 반드시 호출해야 한다.</span></span><br><span class="line">    <span class="keyword">constructor</span>(a: <span class="built_in">Int</span>) : <span class="keyword">this</span>(a,<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 두 인자의 값을 모두 0으로 지정하는 생성자.</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야 한다.(상속과 this를 사용해서!)</li>
<li>추가 생성자에서는 인자와 프로퍼티를 함께 선언할 수 없다. 따라서 프로퍼티 선언이 필요한 경우 주 생성자에서 이를 처리해야 한다.</li>
<li>생성자 앞에 접근 제한자를 붙여 가시성을 변경할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> a: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Char</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(a: <span class="built_in">Int</span>) : <span class="keyword">this</span>(a,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(): <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>생성자는 중요한 개념이므로 추후 더 추가할 예정.</p>
<p><strong>함수</strong></p>
<ul>
<li>메소드를 함수로 표현한다.</li>
<li>void -&gt; Unit이며 반환 값이 없음을 의미한다.</li>
<li>또한, 반환 값이 없는 함수는 Unit을 생략할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: <span class="built_in">Unit</span>&#123;</span><br><span class="line">        <span class="comment">// Unit 생략 가능.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>: <span class="built_in">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>상속 및 인터페이스 구현</strong></p>
<ul>
<li>클래스의 상속과 인터페이스 구현을 구분하지 않고 콜론(:)으로 통일한다.</li>
<li>클래스를 상속받는 경우 반드시 부모 클래스의 생성자를 호출해야 하며, 부모 클래스의 생성자는 super 키워드를 사용해 호출한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View&#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs)&#123;</span><br><span class="line">        <span class="comment">// 뷰 초기화</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자가 여럿일 경우 this 키워드를 사용해 자기 자신의 생성자를 호출할 수 있다.</span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">this</span>(context,<span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attrs: AttributeSet?) : <span class="keyword">super</span>(context, attrs)&#123;</span><br><span class="line">        <span class="comment">// 뷰 초기화</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>오버라이드 시 어노테이션을 사용하지 않고 <strong>override 키워드</strong>를 사용한다.</li>
<li>open 키워드를 사용해 클래스 혹은 함수의 상속 여부를 결정할 수 있다.
<ul>
<li>open 키워드가 있으면 상속 가능.</li>
<li>open 키워드가 없으면 상속 불가능(Java의 final과 비슷)</li>
</ul>
</li>
</ul>
<p><strong>this</strong></p>
<ul>
<li>해당 키워드를 사용한 클래스 자신을 지칭할 때 사용한다.</li>
<li>해당 위치에서 가장 가까운 범위의 클래스를 의미한다. 따라서 클래스 내에서 다른 클래스나 인터페이스의 객체를 동적으로 생성하여 사용하는 경우 키워드를 사용하는 위치에 따라 this가 의미하는 클래스가 달라질 수 있다.</li>
<li>따라서 <code>this@{클래스이름}</code> 처럼 명확하게 표시해준다.</li>
</ul>
<p><strong>동반객체</strong></p>
<ul>
<li>동반 객체(companion object)를 사용하면 클래스 내 모든 멤버에 접근할 수 있으면서 인스턴스 생성 없이 호출할 수 있는 함수를 작성할 수 있다.</li>
<li>어디서든 접근이 가능하다.</li>
<li>즉, 자바의 static 메소드, static 멤버와 같은 역할을 한다고 볼 수 있다.</li>
<li>왜냐하면 코틀린은 클래스 내에 정적 필드나 정적 함수를 둘 수 없다. 그러한 개념이 없기 때문이다. 대신에 클래스별로 하나씩 클래스의 인스턴스 생성 없이 사용할 수 있는 오브젝트를 정의할 수 있는데, 이를 동반 객체라고 한다.</li>
</ul>
<p><strong>싱글톤</strong></p>
<ul>
<li>단 하나의 인스턴스만 생성되도록 제약을 둔 패턴으로 코틀린에서 object를 사용해 <strong>간편</strong>하게 선언할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">"aa call!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> aValue = Singleton.a</span><br><span class="line">Singleton.aa()</span><br></pre></td></tr></table></figure>
<p>코틀린에서의 특징만 살펴보도록 하겠다. 다 정리하기에는 시간이 오래 걸릴 듯 싶어서이다…<br>
시간이 생긴다면 정리하지 않은 특징도 추구하도록 하겠다. :)</p>
<p><strong>is 연산자</strong></p>
<ul>
<li>자료형을 확인하기 위해 사용한다.</li>
<li>자바의 instanceOf 연산자와 동일한 기능을 한다.</li>
<li>특정 타입이 아닌 경우를 확인하기 위해서는 <code>!is</code>로 확인하면 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Test</span><span class="params">(obj : <span class="type">Any</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Int</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(obj <span class="keyword">is</span> <span class="built_in">Float</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>as 연산자</strong></p>
<ul>
<li>특정 변수를 원하는 자료형으로 변환하기 위한 연산자이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">porcessNumber</span><span class="params">(number: <span class="type">Number</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> foo : <span class="built_in">Int</span> = number <span class="keyword">as</span> <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>스마트 캐스트</strong></p>
<ul>
<li>자료형 추론이 가능할 경우 캐스팅 없이 해당하는 자료형으로 객체를 사용할 수 있도록 하는 기능이다.</li>
<li>값을 검사하는 시점과 사용하는 시점 사이에 값이 변하지 않았다는 것이 보장되는 경우에만 지원된다. 따라서 언제든지 값이 변할수 있는 <strong>var</strong>는 스마트 캐스트가 지원되지 않는다.</li>
</ul>
<p><strong>범위</strong></p>
<ul>
<li>특정 범위를 순회하거나 해당 범위 내에 특정 항목이 포함되어 있는지 확인할 때 사용한다.</li>
<li>… 연산자를 사용.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0부터 10까지, 시작과 끝을 포함하는 범위를 정의한다.</span></span><br><span class="line"><span class="keyword">val</span> myRange : IntRange = <span class="number">0.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> myRange)&#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>인덱스 순환을 위한 범위를 생성할 때는 <strong>until</strong> 함수를 사용하면 된다.</li>
<li>가장 마지막 값을 포함하지 않는다.</li>
<li>범위 내에 특정 항목이 있는지 확인할 때는 in 연산자를 사용한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0&lt;=N&lt;10</span></span><br><span class="line"><span class="keyword">val</span> myRagne : IntRange = <span class="number">0</span> until <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0&lt;=N&lt;=10</span></span><br><span class="line"><span class="keyword">val</span> myRange2 : IntRange = <span class="number">0.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5가 myRange2 내에 포함되어 있는지 확인.</span></span><br><span class="line"><span class="keyword">val</span> foo : <span class="built_in">Boolean</span> = <span class="number">5</span> <span class="keyword">in</span> myRange2 <span class="comment">// true 반환</span></span><br><span class="line"><span class="comment">// 5가 myRange 내에 포함되지 않는지 확인.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Boolean</span> = <span class="number">5</span> !<span class="keyword">in</span> myRange <span class="comment">// false 반환</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>downTo()</code> 함수를 이용해 항목들의 순서가 반대로 정렬된 범위를 생성한다.</li>
<li>시작과 끝을 포함한다.</li>
<li>기본적으로 1씩 감소 시킨다.</li>
<li><code>step()</code> 함수를 사용하여 감소/증가 폭을 변경할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span>)&#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과 : 54321</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span> step <span class="number">2</span>)&#123; <span class="comment">// 2씩 감소시킨다.</span></span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과 : 531</span></span><br></pre></td></tr></table></figure>
<p><strong>예외</strong></p>
<ul>
<li>사용법은 자바와 동일하다. 하지만, 코틀린에서는 값을 반환할 수 있다.</li>
<li><code>checked exception</code>(뭐지? 검색해보자.)을 따로 검사하지 않는다. 즉, 대부분의 예외를 try-catch문으로 감싸 처리해야 했던 자바와 달리 코틀린에서는 이를 선택적으로 사용할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">readFromJson</span><span class="params">(fileName : <span class="type">String</span>)</span></span> : String&#123;</span><br><span class="line">    <span class="comment">// IOException을 발생시킬 수 있는 코드</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// try-catch문을 사용하지 않아도 된다.</span></span><br><span class="line">    <span class="keyword">val</span> json : String = readFromJson(<span class="string">"foo.json"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="널안정성"># 널안정성</h2>
<p>코틀린은 컴파일 단계에서 발생하는 널 포인터 예외가 발생할 문제를 해결하기위해 모든 타입에 명시적으로 널 허용 여부를 함께 표기한다.<br>
코틀린의 중요한 특징 중 하나라고 생각한다.</p>
<p><strong>널 허용 여부 표기</strong></p>
<ul>
<li>널 값을 가질 수 있도록 하려면 명시적으로 타입 뒤에 ? 를 붙여주어야 한다.</li>
<li>널 값을 허용하지 않는 변수를 초기화하지 않거나, null을 대입하면 컴파일 오류를 발생시킨다.</li>
<li>함수의 파라미터나 반환 값에도 동일하게 적용된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a : String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> b : String = <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> name : String <span class="comment">// 오류 : 값이 초기화 되지 않음.</span></span><br><span class="line"><span class="keyword">val</span> address : String = <span class="literal">null</span> <span class="comment">// 오류 : null을 허용하지 않는 변수에 null 대입 불가.</span></span><br></pre></td></tr></table></figure>
<p><strong>엘비스(?:) 연산자</strong></p>
<ul>
<li>널 값을 허용하지 않는 값 혹은 변수에 널 값을 반환할 수 있는 함수의 결과를 대입해야 하는 경우 엘비스 연산자를 이용해 편리하게 처리할 수 있다.</li>
<li>널 값을 대신하는 방법으로 <code>?:</code>를 사용한다.</li>
<li>널 여부를 확인하는 작업을 별도로 하지 않아도 되므로 자바에 비해서 간편하게 함수의 로직을 작성할 수 있다.</li>
<li>값 반환 대신 예외를 발생시킬 수도 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo ?: bar</span><br><span class="line"><span class="comment">// foo가 null이 아닐 경우에는 foo를 반환</span></span><br><span class="line"><span class="comment">// foo가 null일 경우에는 bar를 반환</span></span><br></pre></td></tr></table></figure>
<p><strong>안전한 호출(?.) 연산자</strong></p>
<ul>
<li>널 값 확인을 위해 자바에서 if문으로 검사하던 것을 간편화 할 수 있다.</li>
<li>간단한 로직의 경우 상관이 없지만 복잡해질수록 if문의 향연이 펼쳐질 수 있다.</li>
<li><strong>안전한 호출</strong> 연산자를 사용하여 널 값 확인과 값 접근/함수 호출을 한 번에 할 수 있다.</li>
<li>이 연산자를 사용하는 객체가 널 값이 아닌 경우에만 연산자 뒤의 문장을 수행한다. 널 값일 경우에는 뒤의 문장을 수행하지 않고 null 값을 반환한다.</li>
<li>따라서 널 값인 객체의 프로퍼티를 참조하거나 함수를 호출하는 일을 방지할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar가 null이 아닐 경우에만 해당 값인 baz를 대입. 그렇지 않은 경우 null을 foo에 대입</span></span><br><span class="line"><span class="keyword">val</span> foo = bar?.baz</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo가 null이 아닐 경우에만 bar() 함수 호출.</span></span><br><span class="line">foo?.bar()</span><br></pre></td></tr></table></figure>
<p><strong>as? 연산자</strong></p>
<ul>
<li>자바에서 지원되지 않는 자료형으로 변환을 시도할 가능성이 있는 부분을 try-catch 블록으로 감싸서 처리한다.</li>
<li>코틀린에서는 <code>as?</code> 연산자를 사용해 간편하게 해결할 수 있다.</li>
<li>자료형 변환이 실패할 경우 예외를 발생시키는 대신 널 값을 반환한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo : String = <span class="string">"foo"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 자료형 변환에 실패하므로 bar로 null 값이 할당된다.</span></span><br><span class="line"><span class="comment">// 따라서 bar는 Int?를 통해 널 값을 허용하도록 선언한다.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Int</span>? = foo <span class="keyword">as</span>? <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>엘비스 연산자를 사용해 변환에 실패했을 때의 기본값을 지정할 수 있다.</li>
<li>변환된 값을 받은 자료형의 널 허용 여부를 수정할 필요가 없으므로 유연하게 대처할 수 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자료형 변환에 실패하는 경우 기본 값을 0으로 지정.</span></span><br><span class="line"><span class="keyword">val</span> bar : <span class="built_in">Int</span> = foo <span class="keyword">as</span>? <span class="built_in">Int</span> ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>널 값이 아님을 명시하기 : 비 널 값 보증</strong></p>
<ul>
<li>널 값을 포함할 수 있는 타입을 널 값을 포함하지 않는 타입으로 변환하여 사용할 수 있다.</li>
<li>보증하려는 항목 뒤에 !!을 붙여 사용한다.</li>
<li>비 널 값 보증을 사용했지만 실제로 객체나 값에 널 값이 들어가 있을 경우 널 포인ㅌ 예외가 발생하므로 유의해서 사용해야 한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 값 foo는 널 값을 포함할 수 있는 타입.</span></span><br><span class="line"><span class="keyword">val</span> foo : Foo? = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값 foo는 널 값을 포함하지 않음을 보증.</span></span><br><span class="line"><span class="keyword">val</span> nonNullFoo : Foo = foo!!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 값 foo가 널 값이 아님을 보장하면서 bar() 함수 호출.</span></span><br><span class="line">foo!!.bar()</span><br></pre></td></tr></table></figure>
<p><strong>비 널 값 보증 사용 주의</strong></p>
<p>비 널 값 보증은 아래처럼 중첩해서 사용하는 것을 권장하지 않는다.<br>
contact.address와 address.line2 중 하나라도 널 값이라면 널 포인터 예외가 발생한다.<br>
하지만 에러 로그에서 라인만 알 수 있을 뿐, 어느 요소로 예외가 발생했는지 알 수 없다.<br>
따라서 비 널 값 보증은 중첩되는 호출 단계보다는 하나의 호출 단계에만 사용할 것을 권장한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> contact : Contact = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// address와 line2 모두 널 값이 아님을 보장.</span></span><br><span class="line"><span class="keyword">val</span> line : String = contact.address!!.line2!!</span><br></pre></td></tr></table></figure>
<p><strong>lateinit 키워드</strong></p>
<ul>
<li>초기화 없이 변수만 선언할 수 있다. (var에만 사용할 수 있다.)</li>
<li>즉, 초기화를 나중에 한다는 의미이다.</li>
<li>초기화를 하지 않은 채로 사용하려고 하면 널 포인터 예외가 발생하기 때문에 초기화 작업을 반드시 해야 한다.</li>
<li>초기화가 되었는지 확인하는 방법이 있다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>: <span class="type">Activity</span></span>()&#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> api : Api</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// lateinit 키워드를 사용한 변수가 초기화 되었는지 확인한다.</span></span><br><span class="line">        <span class="keyword">if</span> (::api.isInitialized) &#123; </span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="주의">주의!</h2>
<p>코틀린에서는 값을 반환하는 구문들이 있다.<br>
for, while, when, try-catch, if 등등이 있다.<br>
이러한 구문들이 값을 반환한다는 특징을 알고 코드를 더 편리하게 짤 수 있으므로 알아두면 좋을 것 같다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/03/kotlin-chap1-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/tags/Kotlin/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/Kotlin/archives/3/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 3</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
