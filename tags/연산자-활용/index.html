
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: 연산자 활용 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/연산자-활용/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/19/RxJava-Chap05-Scheduler/"
                            aria-label=": [RxJava] Chap05. 스케줄러"
                        >
                            [RxJava] Chap05. 스케줄러
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-19T22:22:26+09:00">
	
		    Jun 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>지금까지 공부했던 예제의 공통점은 대부분의 동작이 현재 즉, main 스레드에서 동작한다는 것이었다. 하지만, 실무에서는 요구사항에 맞게 <strong>비동기</strong>로 동작할 수 있도록 이를 바꿔야 한다. 이때 스케줄러를 이용한다.</p>
<p>스케줄러는 스레드를 지정할 수 있게 해준다. 단순히 새로운 스레드를 생성하거나 기존의 Executors를 활용하는 것을 넘어 새로운 방식으로 볼 수 있다. 그동안 어렵게 다뤄야 했단 비동기 프로그래밍이 간결한 코드로 구성될 수 있다.</p>
<img src="/img/rx_flip.png" width="700" height="200">
<p>위의 그림에서 시간 표시줄에 주목해야 한다. 마블 다이어그램을 코드로 표현하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlipSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] objs = &#123;<span class="string">"1-T"</span>, <span class="string">"2-S"</span>, <span class="string">"3-P"</span>&#125;;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.fromArray(objs)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"Original data = "</span> + data))</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .map(Shape::flip);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">        CommonUtils.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">3</span>-P</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">3</span>-P</span><br></pre></td></tr></table></figure>
<ul>
<li><code>doOnNext()</code> : Observable 에서 onNext 이벤트가 발생하면 실행되며, 여기에서는 원래의 데이터 값을 확인한다.</li>
<li><code>subscribeOn()</code> : 구독자가 Observable 에 subscribe() 함수를 호출하여 구독할 때 실행되는 스레드를 지정한다. -&gt; 해당 작업을 어느 쓰레드에서 실행할 것인가?!</li>
<li><code>observeOn()</code> : Observable 에서 생성한 데이터 흐름이 여기저기 함수를 거치며 처리될 때, 동작이 어느 쓰레드에서 일어나는지 지정할 수 있다. -&gt; 받은 결과를 어느 쓰레드에서 수행할지?!</li>
</ul>
<p>결과를 보면 최초의 데이터 흐름이 발생하는 스레드와 flip() 함수를 거쳐서 구독자에게 전달되는 스레드가 다르다. 보통 우리는 새로운 스레드를 생성하거나 Runnable 혹은 Callable 객체를 생성하는데 우리는 전달한 적이 없다. 단지 <code>subscribeOn()</code>과 <code>observeOn()</code> 함수에 어떤 스케줄러를 지정했을 뿐이다.</p>
<p>이처럼 스케줄러를 활용하는 비동기 프로그래밍의 핵심은 바로 <strong>데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 전달하는 스레드를 분리할 수 있다는 것이다.</strong></p>
<p>위의 코드에서 observeOn() 함수 호출 부분을 제거해보면 어떤 결과가 나올까? 결과는 아래에서 확인할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">3</span>-P</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">3</span>-P</span><br></pre></td></tr></table></figure>
<p>observeOn() 함수를 지정하지 않으면 subscribeOn() 함수로 지정한 스레드에서 모든 로직을 실행한다.</p>
<p>지금까지 배운 내용을 간단하게 정리하면 아래와 같다.</p>
<ol>
<li>스케줄러는 RxJava 코드를 어느 스레드에서 실행할지 지정할 수 있다.</li>
<li>subscribeOn() 함수와 observeOn() 함수를 모두 지정하면 Observable에서 데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 발행하는 스레드를 분리할 수 있다.</li>
<li>subscribeOn() 함수만 호출하면 Observable의 모든 흐름이 동일한 스레드에서 실행된다.(observeOn() 함수를 생략했을 경우!)</li>
<li>스케줄러를 별도로 지정하지 않으면 현재(main) 스레드에서 동작을 실행한다.</li>
</ol>
<h2 id="스케줄러의-종류">스케줄러의 종류</h2>
<ul>
<li>특정 스케줄러를 사용하다가 다른 스케줄러로 변경하기 쉽다는 특징을 가지고 있다.</li>
<li>마치 map() 함수를 한 번 더 호출하는 것처럼 새롭게 스케줄러를 추가하거나 기존의 스케줄러를 다른 것으로 교체할 수 있다.</li>
</ul>
<p><strong>1. 뉴 스레드 스케줄러</strong></p>
<p>이름처럼 새로운 스레드를 생성한다. 새로운 스레드를 만들어 동작을 실행하고 싶을 때 <code>Schedulers.newThread()</code>를 인자로 넣어주면 된다. 그럼 뉴 스레드 스케줄러는 요청을 받을 때마다 새로운 스레드를 생성한다.</p>
<p>뉴 스레드 스케줄러는 새로운 스레드를 생성하여 내가 원하는 동작을 처리하는 방법이다. 하지만 적극적으로 추천하는 방법은 아니다. RxJava에는 뉴 스레드 스케줄러보다 활용도가 높은 계산 스케줄러와 IO 스케줄러와 같은 다른 스케줄러를 제공하기 때문이다.</p>
<p><strong>2. 계산 스케줄러</strong></p>
<p>4장에서 봤던 interval() 함수는 기본적으로 계산 스케줄러에서 동작한다. 물론 내가 원하는 스케줄러에서 동작하도록 변경할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span></span></span><br></pre></td></tr></table></figure>
<p>CUSTOM은 원하는 스케줄러를 지정할 수 있다는 의미이다. 리액티브 함수 대부분은 마지막 인자로 스케줄러를 지정할 수 있다. flatMap()이나 scan() 함수 등은 대표적인 연산자이지만 스케줄러를 인자로 받지 않는 경우도 있다.</p>
<p>계산 스케줄러는 CPU에 대응하는 계산용 스케줄러이다. <strong>계산 작업</strong>(입출력(I/O) 작업을 하지 않는)을 할 때는 대기 시간 없이 빠르게 결과를 도출하는 것이 중요하다. 내부적으로 스레드 풀을 생성하며 스레드 개수는 기본적으로 프로세서 개수와 동일하다.</p>
<p><strong>3. IO 스케줄러</strong></p>
<p>IO 스케줄러는 네트워크상의 요청을 처리하거나 각종 입,출력 작업을 실행하기 위한 스케줄러이다. 계산 스케줄러와 다른 점은 기본적으로 생성되는 스레드 개수가 다르다는 것이다.</p>
<p><strong>즉, 계산 스케줄러는 CPU 개수만큼 스레드를 생성하지만, IO 스케줄러는 필요할 때마다 스레드를 계속 생성한다</strong>. 입,출력 작업은 비동기로 실행되지만 결과를 얻기까지 대기 시간이 길다.</p>
<p>두 스케줄러의 비교</p>
<ul>
<li>계산 스케줄러 : 일반적인 계산 작업</li>
<li>IO 스케줄러 : 네트워크상의 요청, 파일 입출력, DB 쿼리 등</li>
</ul>
<p><strong>4. 트램펄린 스케줄러</strong></p>
<p>트램펄린 스케줄러는 <strong>새로운 스레드를 생성하지 않고 현재 스레드에 무한한 크기의 대기 행렬을 생성하는 스케줄러이다.</strong> RxJava 1.x에서는 repeat() 함수와 retry() 함수의 기본 스케줄러였으나 RxJava 2.x에서는 이러한 제약이 사라졌다.</p>
<p>새로운 스레드를 생성하지 않는다는 것과 대기 행렬을 자동으로 만들어준다는 것이 뉴 스레드 스케줄러, 계산 스케줄러, IO 스케줄러와 다른 점이다.</p>
<p><strong>5. 싱글 스레드 스케줄러</strong></p>
<p>싱글 스레드 스케줄러는 RxJava 내부에서 단일 스레드를 별도로 생성하여 구독 작업을 처리한다. 단, 생성된 스레드는 여러 번 구독 요청이 와도 공통으로 사용한다.</p>
<p>리액티브 프로그래밍이 비동기 프로그래밍을 지향하기 때문에 싱글 스레드 스케줄러를 활용할 확률은 낮다.</p>
<p>트팸펄린 스케줄러 예제와 비교해보면 실행 스레드가다르다는 사실을 알 수 있다.</p>
<ul>
<li>트램펄린 스케줄러 : 메인 스레드</li>
<li>싱글 스레드 스케줄러 : RxSingleScheduler-1</li>
</ul>
<p>뒤에 <code>-1</code>과 같이 번호가 붙있지만 <strong>결국 단일 스레드만 사용한다</strong>는 사실도 확인할 수 있다.</p>
<h2 id="스케줄러를-활용하여-콜백-지옥-벗어나기">스케줄러를 활용하여 콜백 지옥 벗어나기</h2>
<p>안드로이드 개발을 한다면 가장 쉽게 접근할 수 있고 유용하게 사용할 수 있는 부분이다. 서버와 통신하는 네트워크 프로그래밍을 할 때 마주치는 <code>콜백 지옥(Callback Hell)</code>을 해결하는 것에 집중해보자.</p>
<p>RxJava의 스케줄러를 활용하면 비동기 프로그래밍 방식이 달라진다. 계산 스케줄러나 IO 스케줄러의 예제에서도 살펴봤듯이 스레드를 생성하거나 Callable, Runnable 객체를 실행하는 코드가 사라진다. <strong>리액티브 프로그래밍은 서버와 연동하는 비동기 프로그래밍을 작성할 때 큰 힘을 발휘한다.</strong></p>
<h2 id="observeon-함수의-활용">observeOn() 함수의 활용</h2>
<p>RxJava 스케줄러의 핵심은 결국 제공되는 스케줄러의 종류를 선택한 후 subscribeOn()과 observeOn() 함수를 호출하는 것이다.</p>
<ul>
<li><code>subscribeOn()</code> : Observable에서 구독자가 subscribe() 함수를 호출했을 때 데이터 흐름을 발행하는 스레드를 지정한다.(즉, 작업 스레드를 지정한다.)</li>
<li><code>observeOn()</code> : 처리된 결과를 구독자에게 전달하는 스레드를 지정한다.(UI 갱신을 위한 스레드를 지정한다.)</li>
</ul>
<p>또한, subscribeOn() 함수는 처음 지정한 스레드를 고정시키므로 다시 subscribeOn() 함수를 호출해도 무시한다. 하지만, observeOn() 함수는 다르다.</p>
<img src="/img/schedulers.png" width="700" height="200">
<ul>
<li>subscribeOn(A)를 호출했을 때는 데이터를 발행하는 첫 줄이 스레드 A에서 실행된다. 이후에는 observeOn() 함수가 호출될 때까지 스레드 A에서 실행된다.</li>
<li>observeOn(B)를 호출하면 그 다음인 두 번째 줄부터는 스레드 B에서 실행된다.</li>
<li>map(o–&gt;D) 함수는 스레드 변겨와는 상관없으므로 세 번째 줄은 계속 스레드 B에서 실행된다.</li>
<li>이제 observeOn© 함수를 호출하면 그 다음 데이터 흐름은 스레드 C에서 실행된다.</li>
</ul>
<p>요약하면 다음과 같다.</p>
<ol>
<li>subscribeOn() 함수는 한번 호출했을 때 결정한 스레드를 고정하며 이후에는 다시 호출해도 스레드가 바뀌지 않는다.</li>
<li>observeOn() 함수는 여러 번 호출할 수 있으며 그 다음부터 동작하는 스레드를 바꿀 수 있다.</li>
</ol>
<p>전통적인 스레드 프로그래밍에서는 일일이 스레드를 만들어야 하고 스레드가 늘어날 때마다 동기화하는 것이 매우 부담스럽기 때문에 이러한 로직을 구현하는 것이 매우 힘들다. 하지만 observeOn() 함수는 스레드 변경이 쉬우므로 활용할 수 있는 범위가 매우 넓다.</p>
<p>책이 있다면 책에 나와있는 openWeatherMap 예제를 실행해보는 것을 추천한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/19/RxJava-Chap05-Scheduler/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/19/RxJava-Chap04-Condition/"
                            aria-label=": [RxJava] Chap04. 조건 및 기타 연산자"
                        >
                            [RxJava] Chap04. 조건 및 기타 연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-19T18:04:52+09:00">
	
		    Jun 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="조건-연산자">조건 연산자</h2>
<p>조건 연산자는 Observable의 흐름을 제어하는 역할을 한다. filter 연산자가 발행된 값을 채택하느냐 기각하느냐 여부에 초점을 맞춘다면, 조건 연산자는 지금까지의 흐름을 어떻게 제어할 것인지에 초점을 맞춘다.</p>
<p>다음과 같은 연산자가 있다.</p>
<ul>
<li>amb()</li>
<li>takeUntil()</li>
<li>skipUntil()</li>
<li>all()</li>
</ul>
<p><strong>1. amb()</strong></p>
<p>amb는 ambiguous(모호한)라는 영어 단어의 줄임말이다. 여러 개의 Observable 중에서 1개의 Observable을 선택하는데, <strong>선택 기준은 가장 먼저 데이터를 발행하는 발행하는 Observable이다. 이후에 나머지 Observable에서 발행하는 데이터는 모두 무시한다.</strong></p>
<img src="/img/rx_amb.png" width="500" height="200">
<p>List 인터페이스처럼 Iterable&lt;Observable<t>&gt; 객체를 인자로 넣으면 그 중에서 가장 먼저 데이터를 발행하는 Observable만 선택해서 계속 값을 발행하도록 해준다.</t></p>
<p><strong>2. takeUntil()</strong></p>
<p><code>takeUntil()</code> 함수는 take() 함수에 조건을 설정할 수 있다. 구체적으로 살펴보면 인자로 받은 Observable에서 어떤 값을 발행하면 현재 Observable의 데이터 발행을 중단하고 즉시 완료(onComplete 이벤트 발생)한다. <strong>즉, take() 함수처럼 일정 개수만 값을 발행하되 완료 기준을 다른 Observable에서 값을 발행하는지로 판단하는 것이다.</strong></p>
<img src="/img/rx_takeUntil.png" width="500" height="200">
<p><strong>3. skipUntil()</strong></p>
<p>takeUntil()과 정반대의 함수이다. other Observable을 인자로 받는다는 점은 같지만 Observable에서 데이터를 발행할 때까지 값을 건너뛴다.</p>
<img src="/img/rx_skipUntil.png" width="500" height="200">
<p>takeUntil() 함수와는 다르게 other Observable에서 화살표가 나올 때까지는 값을 발행하지 않고 건너뛰다가 other Observable에서 값을 발행하는 순간부터 원래 Observable에서 값을 정상적으로 발행하기 시작한다.</p>
<p><strong>4. all()</strong></p>
<p>all() 함수는 단순하다. 주어진 조건에 100% 맞을 때만 true 값을 발행하고 조건에 맞지 않는 데이터가 발행되면 바로 false 값을 발행한다.</p>
<img src="/img/rx_all.png" width="500" height="200">
<p>위의 마블 다이어그램은 ‘1’ 원부터 ‘6’ 원까지 모두 ‘원’ 모양이어야만 true를 발행한다.<br>
all() 함수의 원형은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Single&lt;Boolean&gt; <span class="title">all</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>
<p>predicate 인자는 filter() 함수의 인자와 동일하다. 주어진 람다 표현식이 true인지 false인지를 판정해주어야 한다.</p>
<h2 id="수학-및-기타-연산자">수학 및 기타 연산자</h2>
<p>max(), sum()과 같은 수학 함수와 기타 분류에 해당하는 함수가 있다.</p>
<p>RxJavaMath가 있지만, RxJava 2.x를 지원하지 않으므로 다른 라이브러리를 사용한다. <code>Rxjava2Extensions</code> 라이브러리를 활용해 간단한 수학 함수 및 집합 함수의 활용법을 공부해보자.</p>
<p><strong>1. 수학 함수</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        executeMath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeMath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer[] data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. count</span></span><br><span class="line">        Single&lt;Long&gt; source = Observable.fromArray(data)</span><br><span class="line">                .count();</span><br><span class="line">        source.subscribe(count -&gt; Log.i(<span class="string">"count is "</span> + count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. max</span></span><br><span class="line">        <span class="comment">// MathFlowable 클래스의 max() 함수를 호출해 구현한다.</span></span><br><span class="line">        <span class="comment">// to() 함수는 다른 타입으로 변환해주기 위한 함수.</span></span><br><span class="line">        Flowable.fromArray(data)</span><br><span class="line">                .to(MathFlowable::max)</span><br><span class="line">                .subscribe(max -&gt; Log.i(<span class="string">"max is "</span> + max));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. min</span></span><br><span class="line">        Flowable.fromArray(data)</span><br><span class="line">                .to(MathFlowable::min)</span><br><span class="line">                .subscribe(min -&gt; Log.i(<span class="string">"min is "</span> + min));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. sum</span></span><br><span class="line">        Flowable&lt;Integer&gt; flowable = Flowable.fromArray(data)</span><br><span class="line">                .to(MathFlowable::sumInt);</span><br><span class="line">        flowable.subscribe(sum -&gt; Log.i(<span class="string">"sum is "</span> + sum));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. average</span></span><br><span class="line">        Flowable&lt;Double&gt; flowable1 = Observable.fromArray(data)</span><br><span class="line">                .toFlowable(BackpressureStrategy.BUFFER)</span><br><span class="line">                .to(MathFlowable::averageDouble);</span><br><span class="line">        flowable1.subscribe(avg -&gt; Log.i(<span class="string">"avg is "</span> + avg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = count is <span class="number">4</span></span><br><span class="line">main | value = max is <span class="number">4</span></span><br><span class="line">main | value = min is <span class="number">1</span></span><br><span class="line">main | value = sum is <span class="number">10</span></span><br><span class="line">main | value = avg is <span class="number">2.5</span></span><br></pre></td></tr></table></figure>
<p><strong>2. delay()</strong></p>
<p>delay() 함수는 시간을 인자로 받는다. 앞에서 봤던 시간과 관련된 함수들(interval, timer, defer)이 Observable을 생성하는 역할이라면 delay() 함수는 유틸리티 연산자로서 보조 역할을 한다.</p>
<img src="/img/rx_delay.png" width="500" height="200">
<p><strong>delay() 함수의 원형</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">delay</span><span class="params">(<span class="keyword">long</span> delay, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>인자로 delay 변수와 시간 단위(ms 등)을 받는다. 그리고 intervale() 함수와 마찬가지로 계산 스케줄러에서 실행한다. <strong>즉, main 스레드가 아닌 계산을 위한 별도 스레드 풀에서 실행하는 것이다.</strong></p>
<p><strong>3. timeInterval()</strong></p>
<p>어떤 값을 발행했을 때 이전 값을 발행한 이후 얼마나 시간이 흘렀는지를 알려준다.</p>
<p><strong>timeInterval() 함수의 원형</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Timed&lt;T&gt;&gt; timeIntervale()</span><br></pre></td></tr></table></figure>
<p>Timed<t> 객체에는 다음처럼 시간을 얻어오거나 Observable의 데이터를 얻을 수 있는 메소드를 제공할 수 있다.</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">value</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TimeUnit <span class="title">unit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">time</span><span class="params">(TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/19/RxJava-Chap04-Condition/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/09/RxJava-Chap04-Combination/"
                            aria-label=": [RxJava] Chap04. 결합연산자"
                        >
                            [RxJava] Chap04. 결합연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-09T20:47:22+09:00">
	
		    Jun 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="결합-연산자">결합 연산자</h2>
<p>생성 연산자와 변환 연산자는 1개의 데이터 흐름(Observable)을 다뤘다. <strong>결합 연산자는 다수의 Observable을 하나로 합하는 방법을 제공한다.</strong> flatMap(), groupBy() 함수 등은 1개의 Observable을 확장해주는 반면, 결합 연산자들은 <strong>여러 개의 Observable을 내가 원하는 Observable로 결합해준다.</strong></p>
<p><strong>1. zip()</strong></p>
<ul>
<li>각각의 Observable을 모두 활용해 2개 혹은 그 이상의 Observable을 결합한다.</li>
<li>예를 들어, A, B 두 개의 Observable을 결합한다면 2개의 Observable에서 모두 데이터를 발행해야 결합할 수 있다. 그전까지는 발행을 기다린다.</li>
</ul>
<img src="/img/rx_zip.png" width="500" height="200">
<p>zip() 함수는 최대 9개의 Observable을 결합할 수 있지만 보통 2개 혹은 3개면 충분하다. 다음은 간단한 zip() 함수의 사용 예제이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    executeZipInteger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeZipInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.zip(</span><br><span class="line">                Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>),</span><br><span class="line">                Observable.just(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>),</span><br><span class="line">                Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                (a, b, c) -&gt; a + b + c</span><br><span class="line">        ).subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">111</span></span><br><span class="line">main | value = <span class="number">222</span></span><br><span class="line">main | value = <span class="number">333</span></span><br></pre></td></tr></table></figure>
<p><strong>2. zipWith()</strong></p>
<p>zipWith() 함수는 zip() 함수와 동일하지만 Observable을 다양한 함수와 조합하면서 틈틈이 호출할 수 있는 장점이 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipWithSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.zip(</span><br><span class="line">                Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>),</span><br><span class="line">                Observable.just(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>),</span><br><span class="line">                (a, b) -&gt; a + b)</span><br><span class="line">                .zipWith(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (ab, c) -&gt; ab * c);</span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">110</span></span><br><span class="line">main | value = <span class="number">440</span></span><br><span class="line">main | value = <span class="number">990</span></span><br></pre></td></tr></table></figure>
<p>두 Observable을 zip() 함수로 묶고 세 번째 Observable을 다시 zipWith() 함수로 결합했다. zipWith() 함수를 호출할 때는 앞서 a와 b를 결합했기 때문에 ab로 명명했다.</p>
<p><strong>3. combinLatest()</strong></p>
<p>2개 이상의 Observable을 기반으로 Observable 각각의 값이 변경되었을 때 갱신해주는 함수이다. 마지막 인자로 combiner가 들어가는데 그것이 각 Observable을 결합하여 어떤 결과를 만들어주는 역할을 하는 함수이다. zip() 함수의 zipper 인자와 동일하다.</p>
<p>예를 들어, 첫 번째 Observable과 두 번째 Observable을 결합하는 기능을 만든다고 하면 첫 번째 Observable의 값 혹은 두 번째 Observable의 값이 <strong>변경되었을 때 그 값을 자동으로 갱신해준다.</strong></p>
<img src="/img/rx_combinelatest.png" width="500" height="200">
<p>첫 번째 Observable에서만 데이터를 발행하거나 두 번째 Observable의 데이터 흐름만 있으면 구독자에게 어떤 데이터도 발행하지 않는다. 하지만 두 Observable 모두 값을 발행하면 그때는 결과값이 나온다. 그 다음부터는 둘 중에 어떤 것이 갱신되던지 최신 결과값을 보여준다. -&gt; 이 부분이 zip() 함수와 다른 점이다.</p>
<p>zip() 함수처럼 결합하고자 하는 첫 번째와 두 번쨰 Observable을 넣고 마지막으로 그것을 결합하는 combiner() 함수를 넣어주면 된다. 입력할 수 있는 Observable 인자의 개수는 9개이다.</p>
<p><strong>4. merge()</strong></p>
<ul>
<li>zip() 함수나 combineLatest() 함수와 비교하면 가장 단순한 결합 함수이다.</li>
<li>입력 Observable의 순서와 모든 Observable이 데이터를 발행하는지 등에 관여하지 않고 어느 것이든 업스트림에서 먼저 입력되는 데이터를 그대로 발행한다.</li>
</ul>
<img src="/img/rx_merge.png" width="500" height="200">
<p><strong>5. concat()</strong></p>
<ul>
<li>2개 이상의 Observable을 이어 붙여주는 함수이다.</li>
<li>첫 번째 Observable에 onComplete 이벤트가 발생해야 두 번째 Observable을 구독한다. 스레드를 활용한 일반적이 코드로 이와 같은 내용을 구현하기는 복잡하다.</li>
<li>결합할 수 있는 Observable은 최대 4개이다.</li>
</ul>
<img src="/img/rx_concat.png" width="500" height="200">
<p>첫 번째 Observable에 onComplete 이벤트가 발생하지 않게 되면 두 번째 Observable은 영원히 대기한다. 이는 잠재적인 메모리 누수의 위험을 내포한다. 따라서 입력 Observable이 반드시 완료(onComplete 이벤트)될 수 있게 해야 한다.</p>
<blockquote>
<p>Observable의 중간 상태를 확인하는 방법</p>
</blockquote>
<p>리액티브 프로그래밍을 할 때는 중간에 로그를 출력하는 것이 낯설게 느껴진다. 특히 함수형 프로그래밍 패러다임을 배우면서 &quot;로그나 화면 출력하는 등을 부수 효과를 발생시킨다&quot;라는 내용을 접하면 부수 효과를 최소화하려고 하는 경향이 생긴다.</p>
<p>하지만 부수 효과를 감내하고서라도 적절한 로그는 유지 보수성을 확보하기 위해 꼭 필요하다. RxJava에서는 Observable의 중간 결과를 간편하게 확인할 수 있는 함수들을 제공한다. 확실하지 않은 코드나 예제 코드를 실행할 때 찜찜한 부분이 있다면 doOnNext(), doOnComplete(), doOnError() 함수를 추가해보자.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/09/RxJava-Chap04-Combination/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/08/RxJava-Chap04-Transform/"
                            aria-label=": [RxJava] Chap04.변환연산자"
                        >
                            [RxJava] Chap04.변환연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-08T00:40:00+09:00">
	
		    Jun 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="변환-연산자">변환 연산자</h2>
<p>위에서 데이터 흐름(Observable)을 만들어내는 생성 연산자를 보았다면 이번에는 데이터 흐름을 원하는대로 변형할 수 있는 변환 연산자를 알아보자.</p>
<p><strong>1. concatMap()</strong></p>
<p>flatMap() 함수와 매우 비슷하다. 하지만, <code>concatMap()</code> 함수는 먼저 들어온 데이터 순서대로 처리해서 결과를 낼 수 있도록 보장한다. 즉, <strong>데이터의 순서를 보장한다.</strong> flatMap() 함수는 순서를 보장하지 않는다.</p>
<p>flatMap() 함수는 먼저 들어온 데이터를 처리하는 도중에 새로운 데이터가 들어오면 나중에 들어온 데이터의 처리 결과가 먼저 출력될 수도 있다. 이를 인터리빙(끼어들기)라고 한다.</p>
<img src="/img/rx_concatmap.png" width="500" height="200">
<p><strong>2.switchMap()</strong></p>
<p>concatMap() 함수가 인터리빙이 발생할 수 있는 상황에서 동작의 순서를 보장해준다면 <code>switchMap()</code> 함수는 순서를 보장하기 위해 기존에 진행중이던 작업을 바로 중단한다. 그리고 여러 개의 값이 발행되었을 때 마지막에 들어온 값만 처리하고 싶을 때 사용한다. 중간에 끊기더라도 마지막 데이터의 처리는 보장하기 때문이다.</p>
<img src="/img/rx_switchmap.png" width="500" height="200">
<p>마블 다이어그램이 조금 복잡하지만, 시간이 겹치지 않는다는 것을 유의하면 된다.<br>
빨간색 도형의 경우 정상적으로 처리했지만,<br>
<strong>초록색 도형을 처리하는 도중에 파란색 도형이 들어왔으므로 초록색 도형의 처리는 중단하고 파란색으로 도형을 처리한다.</strong></p>
<p>switchMap() 함수는 센서 등의 값을 얻어와서 동적으로 처리하는 경우에 매우 유용하다. 센서 값을 중간값보다는 최종적인 값으로 결과를 처리하는 경우가 많기 때문이다. 이럴 때는 flatMap() 함수로 매번 새로운 결과가 나왔는지 검사하지 말고 손쉽게 switchMap() 함수를 사용하자.</p>
<p><strong>3. groupBy()</strong></p>
<p>어떤 기준(KeySelector 인자)으로 단일 Observable을 여러 개로 이루어진 Observable 그룹(GroupedObservable)으로 만든다.</p>
<img src="/img/rx_groupby.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	String[] objs = &#123;PUPPLE, SKY, triangle(YELLOW), YELLOW, triangle(PUPPLE), triangle(SKY)&#125;;</span><br><span class="line">		Observable&lt;GroupedObservable&lt;String, String&gt;&gt; source = </span><br><span class="line">				Observable.fromArray(objs)</span><br><span class="line">				.groupBy(Shape::getShape);</span><br><span class="line">		</span><br><span class="line">		source.subscribe(obj -&gt; &#123;</span><br><span class="line">			obj.subscribe(val -&gt; </span><br><span class="line">			System.out.println(<span class="string">"GROUP:"</span> + obj.getKey() + <span class="string">"\t Value:"</span> + val));</span><br><span class="line">		&#125;);</span><br><span class="line">		CommonUtils.exampleComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>원래 코틀린으로 해결하려고 했는데, 어떻게 짜야될지 몰라서 자바로 진행해본다.<br>
코드가 조금 복잡하다. GroupedObservable 클래스는 Observable과 동일하지만 getKey() 메소드를 제공하여 구분된 그룹을 알 수 있게 해준다. source는 objs[] 배열에서 입력 데이터를 가져온다. 그룹을 구별하기 위해서 Shape.getShape() 함수를 사용한다.</li>
</ul>
<p>getShape() 함수의 내용은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShape</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj == <span class="keyword">null</span> || obj.equals(<span class="string">""</span>)) <span class="keyword">return</span> NO_SHAPE;		</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-H"</span>)) <span class="keyword">return</span> HEXAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-O"</span>)) <span class="keyword">return</span> OCTAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-R"</span>)) <span class="keyword">return</span> RECTANGLE;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-T"</span>)) <span class="keyword">return</span> TRIANGLE;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"&lt;&gt;"</span>)) <span class="keyword">return</span> DIAMOND;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-P"</span>)) <span class="keyword">return</span> PENTAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-S"</span>)) <span class="keyword">return</span> STAR;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"BALL"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>source.subscribe()에 전달하는 obj는 GroupedObservable 객체이다. 그룹별로 1개씩 생성되므로 생성된 obj 별로 다시 subscribe() 함수를 호출해야 한다. val은 그룹 안에서 각 Observable이 발행한 데이터를 의미한다.(즉, GroupedObservable이 발행한 데이터 ex. “BALL - 6”)</p>
<ul>
<li>만약, 모든 그룹을 처리하고 싶은게 아니라 특정 그룹만 처리하고 싶다면 filter() 함수를 이용해 조건을 추가해주면 된다.</li>
<li>getKey() : 메소드는 그룹의 구분자 값을 리턴한다.(즉, Key 값)</li>
</ul>
<blockquote>
<p>map(), flatMap(), groupBy() 비교</p>
</blockquote>
<ul>
<li>map() : 함수는 1개의 데이터를 다른 값이나 타입으로 변환해준다.</li>
<li>flatMap() : 함수는 1개의 값을 받아서 여러 개의 데이터(Observable)로 확장해준다.</li>
<li>groupBy() : 함수는 값들을 받아서 어떤 기준에 맞는 새로운 Observable 다수를 생성한다.</li>
</ul>
<p><strong>4. scan()</strong></p>
<ul>
<li>reduce() 함수와 비슷하다.</li>
<li>reduce() : Observable에서 모든 데이터가 입력된 후 그것을 종합하여 마지막 1개의 데이터만을 구독자에게 발행한다.</li>
</ul>
<p>반면, scan() 함수는 실행할 때마다 <strong>입력값에 맞는 중간 결과 및 최종 결과를 구독자에게 발행한다.</strong></p>
<img src="/img/rx_scan.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeScan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> source = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">            .scan &#123; ball1: String, ball2: String -&gt; <span class="string">"<span class="variable">$ball2</span> (<span class="variable">$ball1</span>)"</span> &#125;</span><br><span class="line"></span><br><span class="line">    source.subscribe(Log::i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">main | value = <span class="number">5</span> (<span class="number">3</span> (<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>reduce()와 다른점이 있다. 첫 번째는 source의 타입이 Maybe<string>이 아니라 Observable<string>이라는 것이다. <strong>reduce()</strong> 함수의 경우 마지막 값이 입력되지 않거나 onComplete 이벤트가 발생하지 않으면 구독자에게 값을 발행하지 않는다. 최악의 경우에는 값을 전혀 발해아지 않고 종료할 수도 있기 때문에 Maybe 클래스 타입으로 정의했다.</string></string></p>
<p>반면, <code>scan()</code> 함수는 값이 <code>입력될 때마다 구독자에게 값을 발행</code>한다. 따라서 Maybe가 아니라 Observable이다. 그리고 출력된 결과를 확인하면 main 스레드에서 실행되며 값이 입력될 때마다 발행하는 것을 확인할 수 있다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/08/RxJava-Chap04-Transform/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/03/RxJava-Chap04/"
                            aria-label=": [RxJava] Chap04"
                        >
                            [RxJava] Chap04
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-03T17:59:09+09:00">
	
		    Jun 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>해당 글은 직접 책을 구매하여 공부의 목적으로 정리하는 글임을 알려드립니다.</p>
<p>이번에는 리액티브 연산자를 카테고리별로 알아보도록 하겠다. 이유는 연산자의 종류가 많기도 하고 카테고리로 쓰임새를 어느 정도 짐작할 수 있기 때문이다.</p>
<p><code>생성 연산자</code>는 Observable로 데이터 흐름을 만들고 <code>변환 연산자와 필터 연산자</code>는 데이터 흐름을 내가 원하는 방식으로 변형한다. 결합 연산자는 1개의 Observable이 아니라 여러 개의 Observable을 조합할 수 있도록 해준다.</p>
<h2 id="생성-연산자">생성 연산자</h2>
<ul>
<li>생성 연산자의 역할은 데이터 흐름을 만드는 것이다.</li>
<li>Observable(Observable, Single, Maybe 객체 등)을 만든다고 생각하면 된다.</li>
<li>앞선 챕터에서는 just(), fromXXX(), create() 함수 등을 봤고, 이번에는 다른 연산자들을 확인해보도록 하겠다.</li>
</ul>
<p><strong>1. interval()</strong></p>
<ul>
<li>일정 시간 간격으로 데이터 흐름을 생성한다.</li>
<li>주어진 시간 간격으로 0부터 1씩 증가하는 Long 객체를 발행한다.</li>
<li>두 가지의 함수 원형을 가지고 있으며, 최초 지연 시간을 조절하는 함수와 그렇지 않은 함수가 존재한다.</li>
<li>period(일정 시간)동안 쉬었다가 데이터를 발행한다.</li>
<li>기본적으로 영원히 지속되기 때문에 폴링 용도로 많이 사용한다.</li>
<li>함수의 동작이 현재 스레드가 아닌 계산을 위한 별도의 스케줄러(스레드)에서 동작한다.</li>
</ul>
<img src="/img/interval.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 원형</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeInterval</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 시작 시간을 표시하는 유틸리티 메소드이다.</span></span><br><span class="line"><span class="comment">    * RxJava - 비동기 프로그래밍이기 때문에 시간에 대한 이해가 중요하다.</span></span><br><span class="line"><span class="comment">    * 시작 시간을 기준으로 RxJava 각 함수의 실행 시간을 측정하기 위함이다.</span></span><br><span class="line"><span class="comment">    * sleep()을 호출하는 이유는 다른 스레드에서 실행이 완료될 때까지 기다려야 하기 때문이다.</span></span><br><span class="line"><span class="comment">    * 해당 문장을 주석 처리하게 되면 기다리지 않고 바로 프로그램이 종료되는 것을 확인할 수 있다.</span></span><br><span class="line"><span class="comment">    * 이유는 메인 스레드에서 할 일이 없기 때문이다.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                (<span class="keyword">data</span> + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(TIME)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">247</span> | value = <span class="number">100</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">347</span> | value = <span class="number">200</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">445</span> | value = <span class="number">300</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">545</span> | value = <span class="number">400</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">645</span> | value = <span class="number">500</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>2. timer()</strong></p>
<ul>
<li>interval() 함수와 유사하지만 <code>time()</code> 함수는 <strong>한 번만 실행되는 함수</strong>이다.</li>
<li><strong>일정 시간이 지난 후 한 개의 데이터를 발행하고 onComplete() 이벤트가 발생한다.</strong></li>
<li>전반적으로 interval() 함수와 유사하다. 계산 스케줄러에서 실행되며 함수의 발행되는 데이터도 interval() 함수의 첫 번째 값인 0L이다.</li>
<li>보통 일정 시간이 지난 후 어떤 동작을 실행할 때 활용한다. 우리가 사용하는 타이머를 맞춘다고 생각하면 된다.</li>
</ul>
<img src="/img/timer.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.timer(<span class="number">500</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; notUsed -&gt;</span><br><span class="line">                SimpleDateFormat(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>)</span><br><span class="line">                        .format(Date())</span><br><span class="line">            &#125;</span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * timer() 함수도 메인 스케줄러가 아닌 계산 스케줄러에서 실행되기 때문에</span></span><br><span class="line"><span class="comment">    * 계산 스케줄러가 완료될 때까지 기다리기 위해서 sleep() 함수를 호출하여 준다.</span></span><br><span class="line"><span class="comment">    * 즉, 계산 스케줄러의 동작이 완료될 때까지 메인 스케줄러가 기다리는 것이다.</span></span><br><span class="line"><span class="comment">    * 그렇지 않으면 메인 스케줄러에서 할 일이 없기 때문에 프로그램이 바료 종료된다.</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">708</span> | value = <span class="number">2019</span>/<span class="number">06</span>/<span class="number">03</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">26</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>3. range()</strong></p>
<ul>
<li>주어진 값(n)부터 m개의 Integer 객체를 발행한다.</li>
<li>interval(), timer() 함수는 Long 객체를 발행했지만, range() 함수는 Integer 객체를 발행한다.</li>
<li>특정한 스케줄러에서 실행되지 않는다. 즉, 현재 스레드에서 실행한다.</li>
<li>반복문(for, while문)을 대체할 수 있다.</li>
</ul>
<img src="/img/chapter4_range.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* range() 함수로 1부터 10까지 숫자를 생성한다.</span></span><br><span class="line"><span class="comment">* 그리고 filter() 함수를 이용해 짝수만 걸러낸다.</span></span><br><span class="line"><span class="comment">* 현재 쓰레드에서 실행된다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            .filter &#123; num -&gt;</span><br><span class="line">                num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">2</span></span><br><span class="line">main | value = <span class="number">4</span></span><br><span class="line">main | value = <span class="number">6</span></span><br><span class="line">main | value = <span class="number">8</span></span><br><span class="line">main | value = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>4. intervaleRange()</strong></p>
<ul>
<li>interval()과 range() 함수를 혼합해놓은 함수이다.</li>
<li>interval() 함수처럼 일정한 시간 간격으로 값을 출력하지만, range() 함수처럼 시작 숫자(n)로부터 m개만큼의 값만 생성하고 onComplete 이벤트가 발생한다.</li>
<li>interval() 함수처럼 무한히 데이터 흐름을 발행하지 않는다. 반환 타입은 Long 타입이다.</li>
<li>계산 스케줄러에서 실행된다.</li>
</ul>
<img src="/img/intervalRange.png" width="500" height="200">
<p>사실 intervalRange() 함수는 interval() 함수와 다른 함수를 조합해서 만들 수 있다. 이유는 intervalRange() 함수가 직관적이지 않기 때문이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* main 스레드에서 실행되는 것이 아니기 때문에 sleep() 함수를 호출한다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.intervalRange(<span class="number">1</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            TimeUnit.MILLISECONDS)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>interval() 함수 -&gt; intervalRange() 함수 만들기</p>
<ul>
<li>interval() 함수 사용</li>
<li>map() 함수 사용</li>
<li>take() 함수 사용</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRangeUsingIntervalAndMapAndTake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="keyword">data</span> + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. defer()</strong></p>
<ul>
<li>데이터 흐름 생성을 구독자가 subscribe() 함수를 호출할 때까지 미룰 수 있다. 이때 새로운 Observable이 생성된다.</li>
<li>Observable의 생성이 구독할 때까지 미뤄지기 때문에 최신 데이터를 얻을 수 있다.</li>
<li>현재 스레드에서 실행되며, 인자로는 Callable&lt;Observable<t>&gt;를 받는다. Callable 객체이므로 구독자가 subscribe()를 호출할 때까지 call() 메소드의 호출을 미룰 수 있다.</t></li>
</ul>
<img src="/img/defer.png" width="500" height="200">
<p><code>defer()</code> 함수는 구독자가 구독할 때까지 Observable의 데이터 발행을 미루는 역할을 한다. 따라서 구독자가 subscribe()를 호출하는 시점에 최신의 데이터를 받을 수 있다. defer() 함수를 사용하지 않은 상황에서 구독자 두명이 그대로 구독을 하게 되면 같은 5에 대한 데이터를 발행하고 구독자가 받게 된다.</p>
<p><strong>개념이 조금 어렵다;; 천천히 다시 볼 필요가 있다.</strong></p>
<p>여기에서 다룬 Observable은 모두 차가운 Observable이다. Observable을 생성할 때 입력값이 결정되고 구독자가 subscribe() 함수를 호출하면 그때 해당 데이터 흐름을 그대로 발행한다. 즉, defer() 함수를 활용하면 subscribe() 함수를 호출할 때의 상황을 반영하여 데이터 흐름의 생성을 지연하는 효과를 보여준다. 내부적으로 구독자가 subscribe() 함수를 호출하면 그때 supplier의 call() 메소드를 호출한다.</p>
<p><strong>6. repeat()</strong></p>
<ul>
<li>단순히 반복 실행을 하는 함수이다.</li>
<li>서버와 통신을 할 때 해당 서버가 살아있는지 확인(이 확인 과정을 보통 ping 혹은 heart beat라고 한다.)하는 코드를 작성할 때 주로 사용한다.</li>
<li>인자를 입력하지 않으면 영원히 실행된다. 따라서 반복하길 원하는 숫자만큼 인자로 전달하는게 좋다.</li>
</ul>
<img src="/img/repeat.png" width="500" height="200">
<p><strong>예제로 heart beat를 간단하게 구현해보기</strong></p>
<p>서버와 연동하는 앱을 작성하다 보면 통신하는 서버가 동작하는지 확인하는 코드가 필요하다. 지속적인 통신을 해야 하는 서버의 경우 명세서에 동작 확인 코드를 작성할 것을 명시하기도 한다.</p>
<p>보통 일정 시간 안데 heart beat 패킷을 보내지 않으면 서버는 클라이언트와의 연결이 종료된 것으로 판단하고 연결을 해제한다. (보통 30초 간격으로 heart beat 신호를 보낸다.) 이럴 때 repeat() 함수를 활용하면 heart beat 패킷을 보내는 프로그램을 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> serverUrl: String = <span class="string">"https://api.github.com/zen"</span></span><br><span class="line"></span><br><span class="line">    Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">            .map &#123; it -&gt;</span><br><span class="line">                serverUrl</span><br><span class="line">            &#125;</span><br><span class="line">            .map(OkHttpHelper::<span class="keyword">get</span>)</span><br><span class="line">            .repeat()</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result: <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result fail: <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래는 OkHttpHelper 클래스이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static OkHttpClient client = new OkHttpClient();</span><br><span class="line">    <span class="keyword">public</span> static String ERROR = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String <span class="keyword">get</span>(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.e(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getT(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.et(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getWithLog(String url) throws IOException &#123;</span><br><span class="line">        Log.d(<span class="string">"OkHttp call URL = "</span> + url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">get</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timer() 함수를 사용해 2초마다 반복 실행되도록 했다. 약 2초 간격으로 실행된다. 원래 timer() 함수는 한 번 호출된 후에는 종료된다. 그런데 계속 반복해서 실행되는 것을 볼 수 있다.</p>
<p>이유는 repeat() 함수 때문이다. repeat() 함수는 동작이 한 번 끝난 다음에 다시 구독하는 방식으로 동작한다. 그리고 다시 구독할 때마다 동작하는 스레드의 번호가 달라진다.</p>
<p>만약 동작하는 스레드를 동일하게 맞추고 싶다면 timer()와 repeat() 함수를 빼고 interval() 함수를 대신 넣어 호출하면 된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/03/RxJava-Chap04/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
