
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: 안드로이드 기초 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/안드로이드-기초/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-4/"
                            aria-label=": [안드로이드] 안드로이드 면접 4"
                        >
                            [안드로이드] 안드로이드 면접 4
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T14:26:19+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C">안드로이드 백그라운드</a></li>
<li><a href="https://woovictory.github.io/2018/03/02/Android-ActivityLifeCycle/">액티비티 생명주기</a></li>
<li><a href="https://woovictory.github.io/2019/01/02/Android-What-Is-Fragment/">프래그먼트 생명주기</a></li>
<li><a href="#Content-Provider-VS-Content-Resolver">Content Provider VS Content Resolver</a></li>
</ol>
<h2 id="안드로이드-백그라운드">안드로이드 백그라운드</h2>
<p>안드로이드 UI는 기본적으로 싱글 스레드 모델로 작동하므로, 이 영향을 고려해서 개발하지 않으면 애플리케이션의 성능이 저하될 수 있다. 따라서 메인 스레드에서 긴 작업을 하는 것을 피하기 위해 여분의 스레드를 사용해야 한다. 다른 스레드에서 UI 스레드로 접근할 수 있도록 안드로이드에서 제공하는 스레드 간 통신 방법을 알아보자.</p>
<p><strong># 소개</strong><br>
안드로이드의 애플리케이션을 실행하면 시스템은 메인 액티비티를 메모리로 올려 프로세스를 만들며, 이 때 메인 스레드가 자동으로 생성된다. 메인 스레드는 안드로이드의 주요 컴포넌트를 실행하는 곳이자 UI를 그리거나 갱신하는 일을 담당할 수 있는 유일한 스레드이므로 이를 <code>UI 스레드</code>라고 부른다.</p>
<p>안드로이드 화면을 구성하는 뷰나 뷰 그룹을 하나의 스레드에서만 담당하는 원칙을 <strong>싱글 스레드 모델</strong>이라고 한다. 싱글 스레드 모델의 규칙은 다음과 같다.</p>
<ol>
<li>메인 스레드(UI 스레드)를 블럭하지 말 것.</li>
<li>안드로이드 UI 툴킷은 오직 UI 스레드에서만 접근할 수 있도록 할 것.</li>
</ol>
<p>이런 싱글 스레드 모델의 영향을 고려하지 않으면 애플리케이션의 성능이 저하될 수 있다. 긴 시간이 걸리는 작업을 메인 스레드에서 담당하면 애플리케이션의 반응성이 낮아질 수 있고, 급기야 사용자의 불편함을 방지하고자 시스템이 애플리케이션을 ANR 상태로 전환시킬 수도 있다.</p>
<p><strong>따라서 시간이 걸리는 작업을 하는 코드는 여분의 스레드를 사용하여 메인 스레드에서 분리해야 하고, 자연스럽게 메인 스레드와 다른 스레드가 통신하는 방법이 필요하게 된다.</strong></p>
<p>다른 스레드에서 메인 스레드로 접근하기 위해 <strong>Looper</strong>와 <strong>Handler</strong>를 사용할 수 있으며, 안드로이드는 Java의 Thread를 좀 더 쉽게 사용할 수 있도록 래핑한 <code>HandlerThread</code>. 더 나아가 Thread나 Message Loop 등의 작동 원리를 크게 고려하지 않고도 사용이 가능한 <code>AsyncTask</code> 등의 클래스를 제공한다. 그럼 먼저 Thread-Looper-Handler의 개념을 이해하고 다음 내용을 알아보자.</p>
<h2 id="looper와-handler의-사용-목적">Looper와 Handler의 사용 목적</h2>
<p>왜 안드로이드는 메인 스레드에서만 UI 작업이 가능하도록 제한할까? 메인 스레드가 아닌 스레드가 병렬적으로 실행되고 있을 때, 메인 스레드와 다른 스레드, 두 개 이상의 스레드가 동시에 같은 텍스트 뷰에 setText()를 시도하는 경우를 생각하면 간단하다.</p>
<img src="/img/android_thread_reason.png" width="400" height="300">
<p>위의 그림처럼 둘 중 어느 스레드의 setText()가 적용될지 예측할 수 없고, 사용자는 둘 중 하나의 값만을 볼 수 있어 다른 한 스레드의 결과는 버려진다. 이같이 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해서 Looper와 Handler를 사용하게 된다.</p>
<h2 id="looper와-handler의-작동-원리">Looper와 Handler의 작동 원리</h2>
<p><code>안드로이드 면접 3</code>에서도 살펴보았지만, 더 보도록 하겠다. 먼저 스레드와 Looper, Handler가 어떻게 작동하는지 보자. 메인 스레드는 내부적으로 <code>Looper</code>를 가지며 그 안에는 <strong>Message Queue</strong>가 포함된다. Message Queue는 스레드가 다른 스레드나 혹은 자기 자신으로부터 전달받은 Message를 기본적으로 FIFO(선입선출) 형식으로 보관하는 Queue이다.</p>
<p><strong>Looper</strong>는 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다. <strong>Handler</strong>는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다.</p>
<img src="/img/android_looper_handler.png" width="400" height="300">
<h2 id="handler">Handler</h2>
<p>Handler는 스레드의 Message Queue와 연계하여 Message나 Runnable 객체를 받거나 처리하여 스레드 간의 통신을 할 수 있도록 한다. Handler 객체는 하나의 스레드와 해당 스레드의 Message Queue에 종속된다. 새로 Handler 객체를 만든 경우 이를 만든 스레드와 해당 스레드의 Message Queue에 바인드 된다.</p>
<p>다른 스레드가 특정 스레드에게 메시지를 전달하려면 특정 스레드에 속한 Handler의 post나 sendMessage 등의 메소드를 호출하면 된다. 앞서 Message Queue는 전달받은 Message를 선입선출 형식으로 보관한다고 설명했지만, 전달 시점에 다른 메소드를 사용하여 Queue의 맨 위로 보내거나 원하는 만큼 Message나 Runnable 객체의 전송을 지연시킬 수도 있다. 자주 쓰이는 Handler의 메소드는 아래 글을 참고하자.</p>
<p><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">참고 글</a></p>
<p>외부, 혹은 자기 스레드로부터 받은 메시지를 어떤 식으로 처리할지는 <code>handleMessage()</code> 메소드를 구현하여 정리한다. <code>sendMessage()</code>나 <code>post()</code>로 특정 Handler에게 메시지를 전달할 수 있고, 재귀적인 호출도 가능하므로 딜레이를 이용한 타이머나 스케줄링 역할도 할 수 있어 편리하다.</p>
<h2 id="looper와-message-queue">Looper와 Message Queue</h2>
<p>Looper는 무한히 루프를 돌며 자신이 속한 스레드의 Message Queue에 들어온 Message나 Runnable 객체를 차례로 꺼내서 이를 처리할 Handler에 전달하는 역할을 한다. 메인 스레드는 Looper가 기본적으로 생성돼 있지만, 새로 생성한 스레드는 기본적으로 Looper를 가지고 있지 않고, 단지 run 메소드만 실행한 후 종료하기 때문에 메시지를 받을 수 없다.</p>
<p>따라서 기본 스레드에서 메시지를 전달받으려면 <code>prepare()</code> 메소드를 통해 <strong>Looper</strong>를 생성하고, loop() 메소드를 통해 Looper가 무한히 루프를 돌며 Message Queue에 쌓인 Message나 Runnable 객체를 꺼내 Handler에 전달하도록 한다. 이렇게 활성화된 Looper는 quit()이나 quitSafely() 메소드로 중단할 수 있다. quit() 메소드가 호출되면 Looper는 즉시 종료되고, quitSafely() 메소드가 호출되면 현재 Message Queue에 쌓인 메시지들을 처리한 후 종료된다.</p>
<img src="/img/android_looper_message_queue.png" width="400" height="300">
<h2 id="message와-runnable">Message와 Runnable</h2>
<p><strong>Message</strong><br>
Message란 스레드 간 통신할 내용을 담는 객체이자 Queue에 들어갈 일감의 단위로 Handler를 통해 보낼 수 있다. 일반적으로 Message가 필요할 때 새 Message 객체를 생성하면 성능 이슈가 생길 수 있으므로 안드로이드가 시스템에 만들어 둔 <strong>Message Pool</strong>의 객체를 재사용한다. obtain() 메소드는 빈 Message 객체를, obtain(Handler h, int what …)은 목적 Handler와 다른 인자들을 담은 Message 객체를 리턴한다.</p>
<p><strong>Runnable</strong><br>
새 스레드는 Thread() 생성자로 만들어서 내부적으로 run()을 구현하던지, Thread(Runnable runnable) 생성자로 만들어서 Runnable 인터페이스를 구현한 객체를 생성하여 전달하던지 둘 중 하나의 방법으로 스레드를 만들 수 있다. 후자에서 사용하는 것이 <strong>Runnable</strong>로 스레드의 run() 메소드를 분리한 것이다. 따라서 Runnable 인터페이스는 run() 추상 메소드를 가지고 있으므로 상속받은 클래스는 run() 코드를 반드시 구현해야 한다. 앞서 언급한대로 Message가 int나 Object 같이 <strong>스레드 간 통신할 내용</strong>을 담는다면 Runnable은 실행할 run()메소드와 그 내부에서 실행될 코드를 담는다는 차이점이 있다.</p>
<h2 id="handlerthread">HandlerThread</h2>
<p>Looper에서 언급했듯이 안드로이드의 스레드는 Java의 스레드를 사용하기 때문에 안드로이드에서 도입한 Looper를 기본으로 가지지 않는다는 불편함이 있다. 이같은 불편함을 개선하기 위해 생성할 때 Looper를 자동으로 보유한 클래스를 제공하는데, 이것이 바로 <code>HandlerThread</code>이다. HandlerThread는 일반적인 스레드를 확장한 클래스로 내부에 반복해서 루프를 도는 <strong>Looper</strong>를 가진다. 자동으로 Looper 내부의 Message Queue도 생성되므로 이를 통해 스레드로 Message나 Runnable을 전달받을 수 있다.</p>
<h2 id="asynctask">AsyncTask</h2>
<p><code>AsyncTask</code>는 스레드나 메시지 루프 등의 작동 원리를 잘 몰라도 하나의 클래스에서 UI 작업과 background 작업을 쉽게 할 수 있도록 안드로이드에서 제공하는 클래스이다. <strong>캡슐화</strong>가 잘되어 있기 때문에 사용시 코드 가독성이 증대되는 장점이 있으며, 태스크 스케줄을 관리할 수 있는 콜백 메소드를 제공하고 필요할 때 쉽게 UI 갱신도 가능하며 작업 취소도 쉽다. 따라서 리스트에 보여주기 위한 데이터 다운로드 등 UI와 관련된 독립된 작업을 실행할 경우 <code>AsyncTask</code>로 간단하게 구현할 수 있다.</p>
<img src="/img/android_AsyncTask.png" width="400" height="300">
<center>AsyncTask 구조</center>
<p>그러나 AsyncTask를 사용해서 스케줄링할 수 있는 작업 수의 제한이 있고, 몇 초 정도의 짧은 작업에서만 이상적으로 동작한다는 한계가 있다. 또한, 안드로이드의 버전 별로 병렬 처리 동작이 다르므로 허니콤 이후 버전에서 멀티 스레드로 병렬적인 동작을 원한다면 AsyncTask를 실행할 때 <code>AsyncTask.THREAD_POOL_EXECUTOR</code> 스케줄러를 지정해야 한다.</p>
<p>한편, 앞서 살펴본 Handler와 Looper를 사용한다면 동작 원리를 고려해야 하며 구현을 직접해야 하고 코드가 복잡해져서 가독성을 저해한다는 단점이 있지만 그만큼 개발 범위가 자유롭다. 또한 UI 스레드에서만 작업하지 않아도 되므로 보다 많은 자율성을 가지고 코드를 제어하기를 원한다면 Handler나 HandlerThread 사용을 고려해보는 것도 좋다.</p>
<p>무엇을 사용할지는 개발자가 어떤 기준을 가지고 개발하는지에 따라 다르다. 그럼에도 나는 AsyncTask를 사용할 것 같다. 왜냐하면 핸들러는 스레드 안에서 실행되어야 할 코드와 UI 접근을 위한 코드가 각각 다른 위치에서 구현을 한다. 그러므로 가독성이 떨어진다.</p>
<p>하지만, <code>AsyncTask</code>는 하나의 클래스 안에 스레드로 동작하는 부분과 화면을 갱신하는 부분을 함께 구현해놓을 수 있다. 이 때문에 스레드를 사용하는 하나의 작업단위가 하나의 클래스로 만들어질 수 있게 되므로 가독성이 훨씬 좋아지게 된다.</p>
<p>간단한 예제는 아래 블록를 참고하자^0^<br>
<a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">AsyncTask 예제</a></p>
<h2 id="content-provider-vs-content-resolver">Content Provider VS Content Resolver</h2>
<ul>
<li>
<p>Content Provider : 어플리케이션 내에서 사용할 수 있는 데이터를 <strong>공유</strong>하기 위한 컴포넌트<br>
ex) 연락처, 이미지 등(카카오톡)</p>
</li>
<li>
<p>Content Resolver : 앱이 Content Provider를 접근할 때에는 Content Resolver를 통해서 접근하게 됨. 기본적으로 <strong>CRUD</strong> 함수들 제공 -&gt; 다른 앱의 데이터베이스를 조작할 수 있음<br>
ex) contentResolver.query()</p>
</li>
</ul>
<h2 id="xml-기반-레이아웃이-중요한-이유">XML 기반 레이아웃이 중요한 이유</h2>
<p>동작을 제어하는 코드로부터 분리시킬 수 있고, UI의 구조를 시각화하기 더 쉽기 때문이다. 소스로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 재컴파일 해야 하는 번거로움이 있다.</p>
<h2 id="manifest">Manifest</h2>
<p>애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야 한다.</p>
<h2 id="vector-vs-bitmap">Vector Vs Bitmap</h2>
<ul>
<li>
<p>Vector : 리사이징이 되어도 전혀 깨지지 않는다. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심 ex)SVG</p>
</li>
<li>
<p>Bitmap : 픽셀로 구성되어 있다. 자유자재로 바꿀 수가 없고 움직일 수도 없다. ex)PNG, JPEG</p>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">안드로이드 백그라운드 잘 다루기 Thread, Looper, Handler</a></li>
<li><a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">[Android] AsyncTask</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-3/"
                            aria-label=": [안드로이드] 안드로이드 면접 3"
                        >
                            [안드로이드] 안드로이드 면접 3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T10:56:36+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%ED%99%94%EB%A9%B4%EC%9D%B4-%ED%9A%8C%EC%A0%84%ED%95%98%EB%A9%B4-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%8A%94?">화면이 회전하면 액티비티의 생명주기는?</a></li>
<li><a href="#%ED%8E%9C%EB%8E%85%EC%9D%B8%ED%85%90%ED%8A%B8%EB%9E%80?">펜딩인텐트란?</a></li>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-Task%EC%99%80-Process%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">안드로이드에서 Task와 Process의 차이점</a></li>
<li><a href="#A-%EC%95%B1%EC%97%90%EC%84%9C-B-%EC%95%B1%EC%9D%98-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EB%A5%BC-%EB%B6%80%EB%A5%BC-%EA%B2%BD%EC%9A%B0">A 앱에서 B 앱의 액티비티를 부를 경우</a></li>
<li><a href="#%ED%99%94%EB%A9%B4-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%86%8D%EB%8F%84%EB%A5%BC-%EA%B0%9C%EC%84%A0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">화면 렌더링 속도를 개선하는 방법</a></li>
<li><a href="#Thred%EA%B0%84-%ED%86%B5%EC%8B%A0-%EB%B0%A9%EB%B2%95">Thred간 통신 방법</a></li>
<li><a href="#ANR">ANR</a></li>
</ol>
<h2 id="화면이-회전하면-액티비티의-생명주기는">화면이 회전하면 액티비티의 생명주기는?</h2>
<p>안드로이드 애플리케이션을 사용하다 보면 화면이 가로 모드를 지원하는 애플리케이션들이 많다. 이런 경우 우리가 사용하는 액티비티의 생명주기는 어떻게 되는 것일까???</p>
<p>일단, 화면이 회전하면 뷰의 크기를 재측정하고 다시 달라진 크기대로 새롭게 그려야 된다. 먼저, <code>onPause</code>가 호출되고 <code>onStop</code>, <code>onDestroy</code>가 진행된 후 다시 <code>onCreate</code>, <code>onStart</code>, <code>onResume</code> 순서로 진행된다. 따라서 현재 액티비티를 destroy 시키고 새로 만들기 때문에 기존의 데이터는 사라지게 된다.</p>
<blockquote>
<p>그런데 우리가 사용하는 애플리케이션에서는 지워지지 않는데?</p>
</blockquote>
<p><code>onDestroy</code>가 호출되기 전에 액티비티는 <code>onSaveInstanceState</code>를 호출하게 되는데 이때 저장되어야 할 데이터를 <strong>Bundle</strong> 객체에 저장해두었다가 다시 <code>onCreate</code>가 호출되면 파라미터로 날아온 Bundle에서 이전 데이터를 받아 복구할 수 있다. 이 과정을 통해 화면이 회전되어도 데이터를 유지할 수 있는 것이다.</p>
<h2 id="펜딩인텐트란">펜딩인텐트란?</h2>
<p>펜딩 인텐트(Pending Intent)는 인텐트의 일종이다.</p>
<p>컴포넌트에서 다른 컴포넌트에게 작업을 요청하는 인텐트를 사전에 생성시키고 만든다는 점과 <strong>특정 시점</strong>에 자신이 아닌 다른 컴포넌트들이 펜딩 인텐트를 사용하여 다른 컴포넌트에게 작업을 요청시키는데 사용된다는 점이 일반적인 인텐트와의 차이점이다.</p>
<p>수행시킬 작업 및 인텐트와 그것을 수행하는 주체를 지정하기 위한 정보를 명시할 수 있는 기능의 클래스라고 보면 된다.</p>
<p>쉬운 예제는 아래와 같다.</p>
<blockquote>
<p><code>A한테 이 B인텐트를 C 시점에 실행하라고 해. 지금은 실행하지 말고.</code></p>
</blockquote>
<p>이 클래스의 인스턴스는 getActivity (Context, int, Intent, int), getActivities (Context, int, Intent [], int), getBroadcast (Context, int, Intent, int) 및  getService(Context, int, Intent, int) 가 반환 하는 객체를 다른 응용 프로그램으로 전달 할 수 있으므로 앱 개발자가 명시하는 작업을 수행 할 수 있다.</p>
<p><code>Pending Intent</code>를 다른 응용 프로그램에 제공하면 다른 응용 프로그램이 자신과 동일한 권한과 ID로 지정된 것처럼 작업을 수행할 수 있는 권한이 부여된다. 따라서 Pending Intent를 작성하는 방법에 주의해야 한다. 예를 들어, 제공하는 기본적인 인텐트는 컴포넌트 이름이 자신이 가진 컴포넌트들 중 하나를 명시적으로 지정해야 하며, 궁극적으로 그곳으로 보내지는 것을 보장해야 한다.</p>
<h3 id="사용되는-몇가지-사례">사용되는 몇가지 사례</h3>
<ul>
<li>사용자가 Notification을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(NotificationManager가 인텐트를 실행)</li>
<li>사용자가 AppWidget을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(홈 스크린이 인텐트를 실행)</li>
<li>미래의 특정 시점에 실행되는 인텐트를 선언함(안드로이드의 AlarmManager가 인텐트를 실행)</li>
</ul>
<p>안드로이드 앱을 구현할 때, 인터넷으로부터 파일을 다운로드 하는 로직은 대부분 서비스에서 이루어지도록 구성한다.  그런데 서비스는 액티비티와 달리 화면에 나타나지 않는다. 따라서 서비스는 다운로드의 진행중이라는 사실 및 진행 정도를 화면 상단에 위치한 <strong>노티피케이션의 상태바</strong>(Status bar)를 통해서 표현한다. 다운로드가 현재 진행 중이라는 상황을 표시하는 아이콘 등으로 말이다. 그리고 다운로드가 완료된 후에는 아이콘으로 다운로드 완료의 상태를 보여주게 된다.</p>
<p>사용자가 상태바의 아이콘을 확인하고 안드로이드 화면의 상태바를 누르면서 나타나는 바를 잡아 아래로 끌어당기면 나타나는 화면을 <strong>노티피케이션 리스트</strong> 또는 확장 메시지라 한다. 그리고 만약 서비스가 이 Notification List에 다운로드 완료를 표시를 추가해놓았고, 사용자가 이것을 클릭하면 노티피케이션은 사전에 서비스에서 작성한 <code>펜딩 인텐트</code>를 사용하여 다운로드된 파일을 읽을 수 있는 앱을 호출하고 다운로드 완료된 파일을 호출된 앱에서 재생 혹은 보여주게 된다.</p>
<p>펜딩 인텐트는 안드로이드 App의 각각의 컴포넌트들이 펜딩 인텐트를 생성할 수 있도록 다음과 같은 메소드를 제공한다. 아래의 메소드를 통해 펜딩 인텐트를 사용하고자 하는 컴포넌트 유형을 지정해야 한다는 뜻이다.</p>
<ul>
<li>getActivity(Context, int, Intent, int)</li>
<li>getBroadcast(Context, int, Intent, int)</li>
<li>getService(Context, int, Intent, int)</li>
</ul>
<p>여기서 Context는 <code>현재 App의 Context</code>이다.</p>
<p><strong># Example</strong><br>
노래를 재생하는 중이고 이것이 상태바에 Notification으로 보여질 때 사용자가 이 Noti를 클릭하면 Notification은 이전에 전달받은 Pending Intent를 실행한다. Pending Intent가 <code>getActivity()</code>에 의해 생성된 것이며 감싸고 있는 intent 또한 특정 화면을 실행시키는 intent라면 이것이 그대로 실행되어 노래 화면이 뜨게 된다.</p>
<p>이때 주의할 점은 Activity는 새로운 테스크를 생성하여 그곳에 쌓이게 된다. 마치 Intent의 flag가 <code>NEW_TASK</code>로 설정된 것처럼 실행되기 때문에 유의해야 한다. 하나의 Activity만 생성되도록 보장하기 위해선 AndroidManifest 파일에  lanunchMode = “singleTop” 으로 설정해주어야 한다.</p>
<h2 id="안드로이드에서-task와-process의-차이점">안드로이드에서 Task와 Process의 차이점</h2>
<p>애플리케이션 컴포넌트가 처음 시작될 때 실행 중인 다른 컴포넌트가 없으면 안드로이드 시스템은 프로세스를 새로 생성시킨다. 기본적으로 애플리케이션의 컴포넌트들은 같은 프로세스의 기본 스레드에서 실행된다. 이후의 컴포넌트들이 시작할 때는 이미 생성된 프로세스 내에서 시작되며 컴포넌트별로 별도의 프로세스에서 실행되도록 할 수도 있고 어느 프로세스에서든 추가적인 스레드를 생성하여 작업할 수 있다.</p>
<p>Manifest 파일에서 <code>android:process</code> 특성을 설정함으로써 다른 프로세스에 해당 컴포넌트를 실행시킬 수 있다. 안드로이드 시스템에서 메모리가 부족할 경우 우선순위가 낮은 프로세스부터 종료시킨다. 우선순위는 <code>Foregorund, Visible, Service, Background, Cached</code> 프로세스 순이다.</p>
<p>눈에 보이는 프로세스는 <strong>Foreground와 Service</strong> 프로세스이며 Visible은 다이얼로그가 뜨는 경우 뒤에 액티비티가 가려지지만 사용자에게 보이는 경우에 해당한다.</p>
<p><strong>Service</strong>는 사용자가 볼 수는 없지만 프로세스에 필요한 작업은 진행하기에 그 다음 우선순위를 가지며 <strong>Background</strong>는 뒤로 밀려난 프로세스이기에 종료될 수 있다. 마지막 <strong>Cached</strong> 프로세스는 컴포넌트가 없는 빈 프로세스이지만 다음에 실행할 때 로드 시간을 절약하기 위해 캐시된 상태이다.</p>
<p><strong>Task</strong>는 각 애플리케이션마다 사용하는 Activity들을 Stack 구조로 저장 및 관리하는 컬렉션이다. 따라서 사용자가 화면의 전환 흐름을 자연스럽게 경험하도록 보장한다. 또한 Task는 다른 애플리케이션이나 프로세스에 속하는 Activity를 같은 Task에 저장시킴으로써 사용자로 하여금 하나의 애플리케이션에서 작동하는 듯한 경험을 하도록 한다. 단말기에서 사용중인 애플리케이션 리스트를 보는 것이 Task 단위로 보여지는 것이다. 하지만 실질적으로 Activity는 다른 프로세스 상에서 돌아가는 컴포넌트이며 프로세스간 통신을 통해 정보를 주고 받는 것이다.</p>
<h2 id="a-앱에서-b-앱의-액티비티를-부를-경우">A 앱에서 B 앱의 액티비티를 부를 경우</h2>
<p>Task에는 해당 애플리케이션에 속한 컴포넌트뿐만 아니라 다른 애플리케이션 컴포넌트도 쌓일 수 있다. 다른 애플리케이션의 컴포넌트를 실행하는 방법으로 <code>PackageManager</code>의 getLaunchIntentForPackage()가 있고 Intent에 <code>setComponent()</code>를 사용하는 방법이 있는데 전자의 경우 항상 새로운 Task를 생성하여 그곳에서 컴포넌트를 실행시키며 후자의 경우 현재의 Task에서 컴포넌트를 실행시키게 된다.</p>
<p>이 부분은 추후 공부를 더 해볼 예정.</p>
<h2 id="화면-렌더링-속도를-개선하는-방법">화면 렌더링 속도를 개선하는 방법</h2>
<p>기본적으로 View의 움직임이 어색하거나 스크롤이 버벅거리거나 렌더링이 느린 경우는 <strong>뷰를 그리는 속도가 16ms 보다 오래걸리는 현상</strong>이다. 초당 60 프레임의 속도로 화면을 그려주어야 사람의 시각에 어색함이 없이 보이는데 그리는 시간이 이보다 오래 걸릴 경우 버벅이는 문제가 발생할 수 있다. 따라서 렌더링이 느리다면 2가지를 의심해 봐야 한다.</p>
<ol>
<li>View Hierarchy가 너무 많은지 의심해 볼 것.</li>
</ol>
<p>View는 그려지기 전에 Measure, Layout, Draw의 3단계를 계층적으로 실행한다. 만약 계층이 매우 길고 복잡하다면 당연히 View가 그려지는 시간 또한 오래 걸릴 것이기 때문이다. 계층을 줄이려 <code>ConstraintLayout</code>과 <code>FlexboxLayout</code>를 적극 사용한다면 줄일 수 있을 것이다.</p>
<ol start="2">
<li>onDraw()에서 오버드로우 현상이 일어나는지 확인할 것.</li>
</ol>
<p><code>onDraw()</code> 함수 안에서 객체 생성을 하였는지, 오래 걸리는 작업을 실행하지 않는지 확인하여 문제가 되는 로직을 수정하거나 제거할 것이다.</p>
<p><strong># ConstrainLayout?</strong><br>
ConstrainLayout은 뷰의 상하좌우를 주변 또는 부모 뷰와 연관을 지어 위치시킬 수 있다. bias를 통해 비율적으로 배치시킬 수도 있고, chain을 사용하여 마치 그룹화한 것처럼 사용도 가능하다. 또한 ratio를 사용하여 너비와 높이를 비율대로 설정할 수도 있는 등 매우 유연한 배치가 가능하다. <code>ConstrainLayout</code>의 가장 큰 장점은 <strong>View Hierarchy</strong>를 <strong>수평적으로 평평하게</strong> 만든다. 최대 8 계층으로 구성되어 있는 RelativeLayout 구조를 하나의 계층으로 줄일 수 있는 효과를 볼 수 있다.</p>
<p><strong># FlexBoxLayout?</strong><br>
태그와 같은 항목이 하나의 뷰 안에 일렬로 즐비할 경우 한 줄이 가득 차면 다음 줄로 View를 정렬시키는 기능이 필요할 때 사용할 수 있는 Layout이다. <code>FlexBoxLayout</code>은 부모 레이아웃의 너비에 따라 자식 뷰를 여러 행에 걸쳐 <strong>동적</strong>으로 맞추는 기능을 제공한다. 기존에는 LinearLayout을 통해 구현 가능하긴 하지만 ScrollView와 같이 사용하면서 View의 너비를 일일이 계산하여 다음 행으로 배치시키는 코드를 직접 구현하는 방식으로 커스텀을 해야했다. <code>FlexBoxLayout</code>을 사용하면 이러한 작업을 자동으로 처리해주기에 잘못된 구현으로 인해 오버헤드가 발생하는 문제를 방지할 수 있다.</p>
<h2 id="thred간-통신-방법">Thred간 통신 방법</h2>
<p>Android의 UI를 담당하는 쓰레드는 메인 쓰레드(UI 쓰레드)인데, 오랜 시간이 걸리는 작업을 메인 쓰레드에서 수행할 경우 앱의 성능이 저하된다. 따라서 여분의 쓰레드를 사용하여 작업을 수행해야 하고, 이 결과를 반영하기 위해 메인 쓰레드와의 통신이 필요하게 된다. 그래서 메인 쓰레드에 접근하는 방법은 <strong>Looper</strong>와 <strong>Handler</strong>를 이용하면 된다. <strong>그리고 UI 작업을 메인 쓰레드에서만 담당하는 이유는 두 개 이상의 쓰레드를 사용할 때의 동기화 이슈를 차단하기 위함이다.</strong></p>
<p><strong>Android는 Java의 쓰레드를 좀 더 쉽게 사용할 수 있도록 래핑한 HandlerThread, AsyncTask를 제공한다.</strong></p>
<p><strong>1. Looper</strong><br>
메인 쓰레드는 내부적으로 <strong>Looper</strong>를 가지며 그 안에는 Message Queue가 포함된다. <code>Message Queue</code>는 쓰레드가 다른 쓰레드나 혹은 자기 자신으로부터 전달받은 Message를 보관하는 Queue(FIFO)이다. Looper는 무한 루프를 돌며 자신이 속한 쓰레드의 Message Queue에서 Message 객체를 차례로 꺼내서 Handler가 처리하도록 전달한다.</p>
<p>메인 쓰레드는 기본적으로 Looper가 생성되어 있으나, 새로 생성한 쓰레드는 새로운 Looper를 생성해주어야 한다. Android는 Looper가 기본적으로 생성되어 있는 HandlerThred를 제공한다.</p>
<ul>
<li><strong>Message Queue에 저장되는 객체</strong>
<ul>
<li>문자와 필드로 구성된 Message 객체</li>
<li>Runnable 객체</li>
</ul>
</li>
</ul>
<p><strong>2. Handler</strong><br>
Looper로부터 받은 Message를 실행, 처리하거나 다른 쓰레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 쓰레드 간의 통신 장치이다. <strong>일반적으로 UI 갱신을 위해 사용된다.</strong> (뷰나 뷰 그룹에서 제공하는 메소드는 단일 스레드 모델(Thread-Unsafe)</p>
<h2 id="anr">ANR</h2>
<p><code>ANR</code>은 Android Not Responding의 약자로 오랜 시간이 걸리는 작업을 메인 쓰레드에서 담당하면 앱의 반응성이 낮아질 수 있고, 사용자의 불편함을 방지하고자 시스템이 <strong>ANR</strong> 상태로 전환시킬 수 있다. 따라서 시간이 걸리는 작업은 여분의 쓰레드를 사용해야 하고, 이 작업 결과를 반영하기 위해 메인 쓰레드와 통신하는 방법이 필요하다.</p>
<p><strong># ANR상태 예시</strong><br>
-&gt; input 이벤트에 5초 안에 반응하지 않을 경우(Activity)<br>
-&gt; BroadcastRecevier가 10초 이내로 실행하지 않을 경우(UI가 없는 브로드캐스트 리시버와 서비스도 실행 주체가 메인 쓰레드이기 때문에)</p>
<p><strong># ANR대처 방법</strong><br>
-&gt; 시간이 걸리는 긴 작업은 쓰레드로 처리<br>
-&gt; Progress bar로 진행 상황을 보여주어 사용자를 기다리게 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/17/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%913/" target="_blank" rel="noopener">안드로이드 면접 3</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
