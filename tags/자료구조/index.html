
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Tag: 자료구조 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/tags/자료구조/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/05/13/PriorityQueue/"
                            aria-label=": [자료구조] 우선순위 큐(Priority Queue)"
                        >
                            [자료구조] 우선순위 큐(Priority Queue)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-05-13T00:28:24+09:00">
	
		    May 13, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="우선순위-큐priority-queue">우선순위 큐(Priority Queue)</h3>
<p>일반적인 큐는 먼저 들어간 데이터가 먼저 나오는 구조이다. <strong>이런 큐의 특성과 달리 우선순위 큐(Priority Queue)는 들어간 순서에 상관없이 일정한 규칙에 따라 우선순위를 선정하고 우선순위가 가장 높은 데이터가 가장 먼저 나오게 된다.</strong> 대표적인 예로는 병원의 응급 환자를 생각할 수 있으며, 은행의 업무를 기다리는 상황과 달리 위급한 우선순위에 따라 먼저 처리된다.</p>
<h4 id="사용하기">사용하기</h4>
<ul>
<li>우선순위 큐도 Java에서 내부적으로 구현되어 있어 사용이 용이하다.</li>
<li>큐와 동일하게 add(), peek(), poll() 등의 메소드를 사용할 수 있다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(<span class="number">4</span>);</span><br><span class="line">        pq.add(<span class="number">19</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(pq.poll()); <span class="comment">// 1이 출력된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>add() 대신 offer() 메소드를 사용해도 동일한 결과를 얻는다.</li>
</ul>
<h4 id="우선순위-변경하기">우선순위 변경하기</h4>
<ul>
<li>우선순위를 정하는 기준은 Java의 정렬 기준과 동일하다.</li>
<li>Java는 기본적으로 낮은 숫자부터 큰 숫자까지 오름차순으로 정렬하게 되는데, 만약 다른 오름차순으로 정렬하고 싶다면 Comparator 클래스나 Comparable 인터페이스를 이용해야 한다.</li>
<li>Ex) 객체의 어떤 값에 따라 우선순위를 정해 정렬해야 할때, 오름차순이 아닌 내림차순 정렬을 할때 등등</li>
<li>Integer는 Collections.reverseOrder()를 사용해 내림차순 정렬을 할 수 있다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        pq.add(<span class="number">4</span>);</span><br><span class="line">        pq.add(<span class="number">19</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(pq.poll()); <span class="comment">// 19가 출력된다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="우선순위-큐-예제">우선순위 큐 예제</h4>
<ul>
<li>고양시에서 강남까지 가는 방법이 있다고 하자.</li>
<li>대중교통, 자가용, 도보, 자전거 총 4가지의 방법이 존재한다.
<ul>
<li>대중 교통 : 1시간 10분</li>
<li>자가용 : 45분</li>
<li>도보 : 6시간 40분</li>
<li>자전거 : 2시간 5분</li>
</ul>
</li>
<li>시간이 제일 적게 걸리는 순서로 정렬하면 -&gt; 자가용, 대중교통, 자전거, 도보 순이다.</li>
<li>우선순위 큐에 저장한 뒤, 데이터를 추출하면 위의 순서대로 추출된다.</li>
<li>하지만, 큐는 들어간 순으로 나온다.</li>
</ul>
<p>[Code]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> programmers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 2020/05/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Vehicle&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"대중교통"</span>, <span class="number">70</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"자가용"</span>, <span class="number">45</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"오토바이"</span>, <span class="number">45</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"도보"</span>, <span class="number">400</span>));</span><br><span class="line">        pq.add(<span class="keyword">new</span> Vehicle(<span class="string">"자전거"</span>, <span class="number">125</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            System.out.println(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Vehicle</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">        Vehicle(String name, <span class="keyword">int</span> time) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.time = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Vehicle&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", time="</span> + time +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Vehicle that)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.time == that.time) <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(that.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.time - that.time;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Vehicle&#123;name=<span class="string">'오토바이'</span>, time=<span class="number">45</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'자가용'</span>, time=<span class="number">45</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'대중교통'</span>, time=<span class="number">70</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'자전거'</span>, time=<span class="number">125</span>&#125;</span><br><span class="line">Vehicle&#123;name=<span class="string">'도보'</span>, time=<span class="number">400</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Vehicle 클래스를 만들었다. 그리고 자바에서 PriorityQueue를 사용하기 위해서는(객체인 경우) 우선순위 큐에 저장할 객체는 필수적으로 Comparable 인터페이스를 구현해야 한다.</li>
<li>compareTo 메소드를 오버라이드 하여 우선순위 조건을 설정하면 PriorityQueue가 우선순위가 높은 객체를 추출하게 된다.</li>
<li>시간이 작은 순서로 정렬해야 하기 때문에 오름차순 정렬을 한다.</li>
<li>다만, 시간이 같은 경우에는 이름의 사전순 정렬을 한다.(오름차순) name이 String이기 때문에 <code>this.name.compareTo(that.name)</code> 을 활용한다.</li>
<li>Int 형인 time 간의 연산에서 Integer.compareTo() 를 사용하지 않은 이유는 Integer와 int의 size가 메모리 차이 때문이다. int의 size가 훨씬 작아 연산시 적은 메모리를 사용한다는 점에서 서로의 값을 뺄셈하여 계산했다.</li>
<li>관련 내용은 해당 Repository에 있으니 확인하면 좋을 것 같다.</li>
</ul>
<h3 id="참고">참고</h3>
<ul>
<li><a href="https://siyoon210.tistory.com/117" target="_blank" rel="noopener">우선순위 큐 - Java에서 다루기</a></li>
<li><a href="https://pangsblog.tistory.com/23" target="_blank" rel="noopener">자바로 정리한 우선순위큐(PriorityQueue)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/05/13/PriorityQueue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/22/Java-Trie-Implement/"
                            aria-label=": [Java] 트라이(Trie) 자료구조 구현"
                        >
                            [Java] 트라이(Trie) 자료구조 구현
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-22T16:46:14+09:00">
	
		    Apr 22, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>구현 과정에서 람다를 사용하므로 Java 8을 베이스로 진행한다.</p>
<h3 id="자바에서-trie-구현하기">자바에서 Trie 구현하기</h3>
<h4 id="클래스-생성">클래스 생성</h4>
<p>자바로 Trie 자료구조를 구현하기 위해서는 자료구조인 Trie와 이를 구성할 TrieNode 클래스가 각각 필요하다.<br>
먼저, TrieNode 클래스부터 보도록 하자.</p>
<p><strong>TrieNode.java</strong></p>
<ul>
<li>TrieNode는 <code>자식 노드맵</code>과 <code>현재 노드가 마지막 글자인지 여부</code>에 대한 정보를 가지고 있다.</li>
<li>여기에서 마지막 글자 여부란 'DEV’라는 단어에서 [D], [E]는 마지막 글자가 아니지만 [V]는 마지막 글자로, 한 단어가 완성되는 시점임을 알 수 있도록 하는 boolean 값이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 2020/04/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 자식 노드맵.</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; childeNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 마지막 글자인지 여부.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLastChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이렇게 두 변수가 할당되었으면 이 변수에 접근할 수 있는 getter/setter를 구현한다. <strong>자식 노드는 Trie 차원에서 생성해서 넣을 것이기 때문에 getter만 생성</strong>해준다.</li>
<li>마지막 글자 여부는 추후 노드 삭제하는 과정에서 변경이 필요하기 때문에 getter/setter를 둘 다 생성해준다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 2020/04/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 자식 노드맵.</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; childeNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 마지막 글자인지 여부.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLastChar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Character, TrieNode&gt; <span class="title">getChildeNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> childeNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLastChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isLastChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastChar</span><span class="params">(<span class="keyword">boolean</span> isLastChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isLastChar = isLastChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Trie.java</strong></p>
<ul>
<li><strong>Trie</strong>는 <code>기본적으로 빈 문자열을 가지는 루트 노드만 가지고 있다.</code></li>
<li>이후에 나올 insert() 메소드를 통해 단어를 넣음으로써 그에 맞게 자식 노드가 생성된다.</li>
<li>우선, Trie가 생성되면 rootNode가 생성될 수 있도록 <code>생성자를 통해 rootNode를 초기화해준다.</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 2020/04/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 루트 노드.</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode rootNode;</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        rootNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="메소드-구현">메소드 구현</h4>
<ul>
<li>이제 본격적으로 Trie 자료구조에 단어 정보를 저장(insert)하고, 해당 단어가 존재하는지 확인(contains)하고, Trie에서 특정 단어를 삭제(delete)하는 세 가지 메소드를 만들어보자.</li>
</ul>
<p><strong>1. insert</strong></p>
<ul>
<li>입력받은 단어의 각 알파벳을 계층 구조의 자식 노드로 만들어 넣는다.</li>
<li>이떄, 이미 같은 알파벳이 존재하면 공통 접두어 부분까지는 생성하지 않는다.</li>
<li>즉, <code>해당 계층 문자의 자식노드가 존재하지 않을 때에만 자식 노드를 생성</code>해준다.(여기서 람다식 사용)</li>
<li>예를 들면, 이미 'DEV’가 들어있는 Trie에 'DEAR’를 넣을 때, 'DE-'는 중복이므로 ‘D-E-’ 노드 아래 'A-R’만 추가로 자식 노드를 생성해주는 것이다.</li>
<li>그리고 마지막 글자에서는 <code>여기까지를 끝으로 하는 단어가 존재한다는 표시를 위해 setLastCahr(true)</code> 해준다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 자식 노드 추가.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode thisNode = <span class="keyword">this</span>.rootNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// word 문자열의 각 단어를 확인한다.</span></span><br><span class="line">    <span class="comment">// thisNode 가 word 문자열의 각 단어를 key 로 하는 자식 노드가 존재하지 않을 때만 자식 노드를 생성해준다.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        thisNode = thisNode.getChildNodes().computeIfAbsent(word.charAt(i), c -&gt; <span class="keyword">new</span> TrieNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thisNode.setLastChar(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. contains</strong></p>
<ul>
<li>특정 단어가 Trie에 존재하는지를 확인하기 위해서는 다음 두 가지 조건을 만족시켜야 한다.
<ol>
<li>루트 노드부터 <code>순서대로 알파벳이 일치하는 자식 노드들이 존재할</code> 것!</li>
<li>해당 단어의 <code>마지막 글자에 해당하는 노드의 isLastChar가 true</code>일 것!<br>
(해당 글자를 마지막으로 하는 단어가 있다는 뜻)</li>
</ol>
</li>
<li>여기서 두 번째 조건에 유념해야 한다.</li>
<li>예를 들어, Trie에는 'POW’와 'PIE’라는 단어만 등록되어 있는데, 'PI’라는 단어를 검색한다고 가정해보자.</li>
<li>'PI’는 'PIE’와 'PI-'가 일치하기 때문에 1번 조건에는 부합(PI가 PIE에 포함되는 단어)하지만, insert 메소드에서 'PIE’의 '-E’에만 setIsLastChar(true) 했기 때문에 2번 조건에는 부합하지 않아 Trie에 없는 단어임을 확인할 수 있게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 특정 단어가 들어있는지 확인.</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    TrieNode thisNode = <span class="keyword">this</span>.rootNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> character = word.charAt(i);</span><br><span class="line">        <span class="comment">// TrieNode 가 가지고 있는 자식 노드 중에서 해당 문자를 가진 노드를 가져온다.</span></span><br><span class="line">        TrieNode node = thisNode.getChildNodes().get(character);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rootNode 의 자식 노드 중 해당 문자를 가진 노드가 없다면 null 이므로 false 를 반환한다.</span></span><br><span class="line">        <span class="comment">// 즉, word 라는 문자가 없음을 뜻한다.</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자가 존재하면 문자열의 모든 단어가 trie 에 존재하는지 확인하기 위해서</span></span><br><span class="line">        <span class="comment">// thisNode 를 자식 노드로 바꾸면서 반복한다.</span></span><br><span class="line">        thisNode = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thisNode.isLastChar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. delete</strong></p>
<ul>
<li>
<p>마지막으로 Trie에 넣었던 단어를 삭제하는 과정이다.</p>
</li>
<li>
<p>contains 메소드처럼 주어진 단어를 찾아 하위 노드로 단어 길이만큼 내려간다.</p>
</li>
<li>
<p>주의할 점은 노드들이 부모노드의 정보를 가지고 있지 않기 때문에, <code>하위 노드로 내려가며 삭제 대상 단어를 탐색</code>하고 <code>다시 올라오며 삭제하는 과정이 콜백(Callback) 형식으로 구현</code>되어야 한다는 점이다.</p>
</li>
<li>
<p>탐색 진행방향 : 부모 노드 -&gt; 자식 노드</p>
</li>
<li>
<p>삭제 진행방향 : 자식 노드 -&gt; 부모 노드</p>
</li>
</ul>
<img src="/img/trie_sample3.png">
<ul>
<li>삭제 진행은 마지막 글자에서 부모 노드 방향으로 되돌아 오는 과정에서 진행된다는 점에 유이하여 다음 삭제 조건을 살펴보자.
<ol>
<li>자식 노드를 가지고 있지 않아야 한다.<br>
위 그림에서 'PI’를 지워버리면 'PIE’까지 삭제되어 버리기 때문이다.</li>
<li>삭제를 시작하는 첫 노드는 isLastChar == true이어야 한다.<br>
false인 경우는 Trie에 없는 단어란 뜻이기 때문이다. 예를 들어, 위 그림에서 'PO’라는 글자를 지우라고 명령을 내려도 Trie가 가지고 있지 않은 단어라는 점이다.</li>
<li>삭제를 진행하던 중에는 isLastChar == false이어야 한다.<br>
삭제 과정 중에서 isLastChar가 true라는 것은 또다른 단어가 있다는 의미이므로 삭제 대상이 아니다. 'PIE’를 삭제 대상으로 했을 때, '-E’를 삭제 후 'PI’라는 단어의 'I’가 isLastChar==true이므로 또다른 단어가 있음을 알려준다.</li>
</ol>
</li>
</ul>
<p>3번이 의미하는 바는 이해가 잘 안갔지만, 이해가 되었다. 삭제 과정 중에 isLastChar가 true라는 것은 또 다른 단어가 있다는 의미이므로 삭제 대상이 아니다. 'PIE’를 삭제 대상으로 했을 때, '-E’를 삭제 후, 'PI’라는 단어의 'I’가 isLastChar == true이면 'PI’라는 단어가 있음을 뜻한다.</p>
<p>참고로, 삭제 대상 단어의 마지막 글자가 isLastChar false이거나 해당하는 마지막 글자가 없는 경우는 new Error를 던지도록 구현했습니다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://the-dev.tistory.com/3" target="_blank" rel="noopener">[자료구조] Trie(트라이)-2 : 자바로 구현하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/22/Java-Trie-Implement/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2020/04/22/Java-Trie/"
                            aria-label=": [Java] 트라이(Trie) 자료구조 개념"
                        >
                            [Java] 트라이(Trie) 자료구조 개념
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2020-04-22T16:27:46+09:00">
	
		    Apr 22, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h3 id="trie-자료구조란">Trie 자료구조란?</h3>
<ul>
<li>일반 트리 자료구조 중 하나로, Digital Tree, Radix Tree, Prefix Tree라고도 불린다.</li>
<li>텍스트 자동 완성 기능과 같이 문자열을 저장하고 탐색하는데 유용한 자료구조이다.</li>
</ul>
<h3 id="trie-자료구조의-형태는">Trie 자료구조의 형태는?</h3>
<ul>
<li>각 노드는 &lt;Key, Value&gt; 맵을 가지고 있다. <strong>Key</strong>는 하나의 알파벳이 되고, <strong>Value</strong>는 그 Key에 해당하는 자식 노드가 된다.</li>
<li>다음은 DEV, DEAR, PIE, POP, POW라는 단어가 들어있는 Trie 자료구조를 도식화한 것이다. 휴대폰 전화번호부에서 검색을 하거나 사전에서 단어를 찾는 것과 같다.</li>
<li>예를 들어, 아래 그림에서 'DEV’라는 문자열을 찾으려면 루트 노드에서부터 순차적으로 [D] -&gt; [E] -&gt; [V] 를 탐색한다.</li>
</ul>
<img src="/img/trie_sample.png">
<ul>
<li>그림에서 볼 수 있듯이 <code>루트 노드는 특정 문자를 의미하지 않고, 자식 노드만 가지고 있다.</code></li>
<li>유의할 점은 <strong>'부모 노드’나 '자신이 어떤 알파벳(Key)에 해당하는 노드(Value)'인지를 가지고 있는게 아니라는 점입니다.</strong></li>
</ul>
<ul>
<li>즉, 루트 노드는 [D], [P]라고 하는 알파벳을 Key로 하는 자식 노드들을 가지고 있고, [D]는 [E]를 Key로 하는 자식 노드, [P]는 [I]와 [O]를 Key로 하는 자식 노드들을 가지고 있는 것이다.</li>
<li>또 루트 노드를 제외한 <code>노드의 자손들은 해당 노드와 공통 접두어를 가진다는 특징이 있다.</code> 즉, ‘DE’ 노드의 자손인 'DEAR’와 'DEV’는 'DE-'를 공통 접두어로 가지며, 'P’의 자손인 'POW’와 'PIE’는 'P-'를 공통 접두어로 가진다.</li>
</ul>
<img src="/img/trie_sample2.png">
<h3 id="trie-자료구조의-특징">Trie 자료구조의 특징</h3>
<ul>
<li>정렬된 트리 구조이다.(데이터에 따라 이진트리일 때도 있다.)</li>
<li>Trie는 자식 노드를 Map&lt;Key, Value&gt; 형태로 가지고 있다.</li>
<li>루트 노드를 제외한 노드의 자손들은 해당 노드와 공통 접두어를 가진다.</li>
<li>루트 노드는 빈 문자와 연관있다.(특정 문자가 할당되어 있지 않다.)</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://the-dev.tistory.com/2" target="_blank" rel="noopener">[자료구조] Trie(트라이)-1 : 기초 개념</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2020/04/22/Java-Trie/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Diff-Of-HTTP-HTTPS/"
                            aria-label=": [네트워크] HTTP와 HTTPS"
                        >
                            [네트워크] HTTP와 HTTPS
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T22:35:54+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="http의-문제점">HTTP의 문제점</h2>
<p>HTTP는 다음과 같은 문제점을 갖는다.</p>
<ol>
<li>HTTP는 평문 통신이기 때문에 도청이 가능하다.</li>
<li>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</li>
<li>완전성을 증명할 수 없기 때문에 변조가 가능하다.</li>
</ol>
<p>위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다.</p>
<p><strong>TCP/IP는 도청 가능한 네트워크이다.</strong></p>
<p>TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로도 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.</p>
<p>1번 문제를 보완하는 방법은 다음과 같다.</p>
<ol>
<li>
<p>통신 자체를 암호화<br>
SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다.</p>
</li>
<li>
<p>콘텐츠를 암호화<br>
말 그대로 HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.</p>
</li>
</ol>
<p><strong>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</strong></p>
<p>HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 Request를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 엑세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.</p>
<ul>
<li>리퀘스트를 보낸 곳의 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.</li>
<li>리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.</li>
<li>통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.</li>
<li>어디에서 누가 리퀘스트 했는지 확인할 수 없다.</li>
<li>의미없는 리퀘스트도 수신한다. -&gt; DoS 공격을 방지할 수 없다.</li>
</ul>
<p>2번 문제를 보완하는 방법은 다음과 같다.</p>
<p><code>SSL</code>로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 <strong>증명서</strong>를 제공하고 있다. 증명서는 신뢰할 수 있는 써드 파티로부터 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.</p>
<p>이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.</p>
<blockquote>
<p>SSL의 작동 과정</p>
</blockquote>
<ol>
<li>클라이언트가 SSL로 암호화된 페이지를 요청한다.(일반적으로 <a href="https://xn--o39a" target="_blank" rel="noopener">https://가</a> 사용된다.)</li>
<li>서버는 Public Key와 인증서를 함께 전송한다.</li>
<li>인증서가 신용있다고 판단한 CA(Certificate Authority)로부터 서명된 것인지 판단한다.</li>
<li>클라이언트는 Public Key를 사용해서 랜덤 대칭 암호화키와 URL, http 데이터를 암호화하여 서버로 전송한다.</li>
<li>서버는 Private Key를 이용하여 랜덤 대칭 암호화키와 URL, http 데이터를 복호화한다.</li>
<li>서버는 요청받은 URL에 대한 응답을 랜덤 대칭 암호화키를 이용해서 암호화해서 클라이언트로 전송한다.</li>
<li>클라이언트는 대칭 키를 이용해서 http 데이터를 복호화하고 데이터를 이용한다.</li>
</ol>
<p>SSL의 인증과 암호화 과정을 통해 3번 문제 또한 해결할 수 있다.</p>
<p><strong>완전성을 증명할 수 없기 때문에 변조가 가능하다.</strong></p>
<p>여기서 완전성이란 <code>정보의 정확성</code>을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 으해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Main-in-the-Middle)이라고 부른다.</p>
<p>3번 문제를 보완하는 방법은 2번 문제를 보완하는 방법으로도 해결이 가능하다.</p>
<p>MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 <strong>HTTPS</strong>를 사용해야 한다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.</p>
<h2 id="https">HTTPS</h2>
<p>HTTPS는 HTTP 통신하는 소켓 부분은 SSL or TLS라는 프로토콜로 대체한 것이다. HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.<br>
HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 모두 사용한다.(두 개를 혼합한 하이브리드 암호화 시스템) 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식아.</p>
<p>[공통키, 공개키, 대칭키 암호화 방식이 뭘까…?]</p>
<p>모든 웹 페이지에서 HTTPS를 사용하지 않는다. 그 이유는 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 많이 필요로 하기 때문이다. 통신할 때마다 암호화를 하면 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 Request 수가 줄어들게 된다. 따라서 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다.<br>
그러나! 개인정보를 주고 받지 않아도 SSL을 이용해야 한다. 어느 사이트에 접속하는지, 어떤 행동을 하는지 공개될 수 있다. 모든 사용자의 행동 및 정보는 보호받아야 할 권리가 있다. 예를 들어, A 사이트에서 로그인 페이지로 넘어갈 때 해커가 가짜 로그인 페이지로 보낼 수 있는 확률도 존재한다.</p>
<h2 id="참고">참고</h2>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Diff-Of-HTTP-HTTPS/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Erro-Flow-Control/"
                            aria-label=": [네트워크] 흐름/혼잡/오류 제어 기법"
                        >
                            [네트워크] 흐름/혼잡/오류 제어 기법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T19:19:04+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>TCP의 가장 큰 특징은 <strong>신뢰성</strong>이다. 이러한 신뢰성을 구성해 주는 방법인 <strong>흐름 제어, 혼잡 제어, 오류 제어</strong>에 대해 알아보도록 하자.</p>
<h2 id="흐름-제어">흐름 제어</h2>
<p>송신(호스트) &lt;&gt; 수신(호스트)</p>
<p>흐름 제어는 수신측과 송신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.<br>
만약 송신측의 전송량이 수신측의 처리량보다 많은 경우, 전송된 패킷은 수신측의 큐를 넘어서 손실될 문제가 발생할 수 있기 때문에 <strong>송신측의 패킷 전송량을 제어하게 된다.</strong></p>
<h3 id="흐름-제어-방법">흐름 제어 방법</h3>
<ol>
<li>정지-대기(Stop and Wait)</li>
</ol>
<img src="/img/stop_and_wait.png" width="400" height="200">
<ul>
<li>매번 전송한 패킷에 대해 응답을 받아야만 그 다음 패킷을 전송할 수 있다.</li>
<li>구조가 간단한 대신, 하나를 주고 하나를 받기 때문에 <strong>비효율적이다.</strong></li>
</ul>
<ol start="2">
<li>슬라이딩 윈도우(Sliding Window)</li>
</ol>
<p>수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다.</p>
<p><strong>이처럼 슬라이딩 윈도우 기법을 통하여 송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜으로써 흐름제어를 수행한다.</strong></p>
<ul>
<li>윈도우는 전송, 수신 스테이션 양쪽에서 만들어진 <code>버퍼(Buffer)</code>의 크기이다.</li>
<li>윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수)</li>
<li>슬라이딩 윈도우 기법은 Stop and Wait 기법의 비효율성을 개선한 기법이다.</li>
<li>ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다.</li>
</ul>
<img src="/img/error_flow_control_2.png" width="400" height="200">
<p>위와 같은 구조에서 데이터 0과 1을 전송했다고 가정하면 슬라이딩 윈도우의 구조는 아래와 같이 변한다. 윈도우의 크기는 전송한 데이터 프레임만큼 왼쪽 경계가 줄어들게 된다.</p>
<img src="/img/error_flow_control_3.png" width="400" height="200">
<p>이때 수신측에서 ACK라는 프레임을 받게 된다면 전송측은 0과 1 데이터를 정상적으로 받았음을 알게 되고, 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다.</p>
<img src="/img/error_flow_control_4.png" width="400" height="200">
<blockquote>
<p>조금 더 자세한 설명</p>
</blockquote>
<p><strong># 전송측 윈도우</strong></p>
<img src="/img/transfer_window.png" width="400" height="200">
<p><strong># 수신측 윈도우</strong></p>
<img src="/img/receive_window.png" width="400" height="200">
<h2 id="혼잡-제어">혼잡 제어</h2>
<p>송신(호스트) &lt;&gt; 라우터(네트워크)</p>
<p>혼잡 제어는 송신측의 데이터 전달과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.</p>
<p>송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다. 만약, 한 라우터에게 데이터가 몰릴 경우 다시 말해 혼잡할 경우, 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.<br>
그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다. <strong>따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서는 보내는 데이터의 전송 속도를 강제로 줄이게 된다.</strong></p>
<h3 id="혼잡-제어-방법">혼잡 제어 방법</h3>
<ol>
<li>AIMD</li>
</ol>
<p>AIMD(Additive Increase / Multiplicative Decrease)라고 불리며, 합 증가 / 곱 감소라고 부른다.</p>
<p>처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간내에 보내는 패킷의 수)를 1씩 증가시켜 가면서 전송하는 방법이다. 만일 패킷 전송을 실패하거나 일정한 시간을 넘으면 패킷 전송 속도를 절반으로 줄이게 된다.</p>
<p>이 방식은 <strong>공평한 방식</strong>이다. 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 <code>평형 상태</code>로 수렴하게 되는 특징이 있다.</p>
<p><strong>문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하며 오랜 시간이 걸리게 되고 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.</strong></p>
<p>이러한 문제점들을 해결하기 위한 방법은 다음부터 소개될 것이다.</p>
<ol start="2">
<li>슬로우 스타트(Slow Start)</li>
</ol>
<p>AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있다.</p>
<p>Slow Start 방식은 AIMD 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window size가 2배가 된다.</p>
<p>따라서 전송 속도는 AIMD와는 다르게 지수 함수꼴로 증가하게 된다. 대신 <strong>혼잡 현상이 발생하면 Window Size를 1로 떨어뜨리게 된다.</strong></p>
<p>처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으므로 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.</p>
<ol>
<li>초기 혼잡 Window Size 1로 전송 = 전송 호스트는 하나의 패킷만 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 4로 하여 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도위의 크기를 8로 하여 전송</li>
</ol>
<img src="/img/error_flow_control_10.png" width="400" height="200">
<ul>
<li>미리 정해진 임계 값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.</li>
<li>Slow Start란 이름을 사용하지만, 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다.</li>
<li>전송되어지는 데이터의 크기가 임계 값에 도달하면 <strong>혼잡 회피</strong> 단계로 넘어간다.</li>
</ul>
<ol start="3">
<li>혼잡 회피(Congestion Avoidance)</li>
</ol>
<p>윈도우의 크기가 임계 값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게 된다. 이는 데이터를 전송함에 있어서 조심하는 단계이다.</p>
<p>전송한 데이터에 대한 ACK를 받으면 윈도우의 크기를 1씩 증가시킨다.<br>
전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.</p>
<ul>
<li>수신 호스트로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우</li>
</ul>
<ol>
<li>타임아웃의 발생</li>
<li>네트워크에 혼잡이 발생했다고 인식<br>
-&gt; 윈도우의 크기를 즉, 세그먼트의 수를 1로 줄임<br>
-&gt; 동시에 임계 값을 패킷 손실이 발생하였을 때의 윈도우 크기의 반으로 줄임</li>
</ol>
<ol start="4">
<li>빠른 회복(Fast Recovery)</li>
</ol>
<p>빠른 회복은 Congestion이 발생했을 때 Window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이는 AIMD의 AI 즉, Additive Increase 하는 방법이다.</p>
<p>Fast Recovery를 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.</p>
<ol start="5">
<li>빠른 재전송(Fast Retransmission)</li>
</ol>
<p>3개의 연속된 중복 ACK를 수신하는 경우에 패킷의 손실로 간주하여 타임아웃이 발생하기 전에 해당 패킷을 <strong>재전송</strong>한다. 그리고 이러한 현상이 일어난 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 반으로 줄인다.</p>
<ol start="6">
<li>TCP Reno</li>
</ol>
<p>N개의 중복 ACK 발생 시 ssthresh(slow start threshold)값을 Congestion Window(cwnd) 사이즈의 반으로 줄여 빠른 복구(Fast Recovery)를 수행하여 선형적 증가를 하게 되며, TCP Time Out에 이르면 Slow Start를 시작한다.</p>
<ol start="7">
<li>TCP Tahoe</li>
</ol>
<p>N개의 중복 ACK 발생 시 바로 Slow Start를 시작한다.</p>
<p>TCP Tahoe와 TCP Reno는 ssthresh(slow start threshold) 값까지 지수적 증가(Slow-Start)를 하게 되고 ssthresh를 넘어서면 선형적 증가(Additive Increase)를 하는 것까지는 동일하다. 차이가 생기는 기준은 N개의 중복 ACK가 발생할 경우이다.</p>
<h2 id="오류-제어">오류 제어</h2>
<p>오류 제어 기법은 오류 검출(Error detection)과 재전송(retransmission)을 포함한다.<br>
ARQ(Automatic Repeat Request) 기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다. ARQ 기법은 흐름 제어 기법과 관련되어 있는데 stop and wait은 stop and wait ARQ로, Sliding Window는 GBn(Go-Back-n) ARQ 또는 SR(Selective-Reject) ARQ 형태로 구혀한다.</p>
<h3 id="오류-제어-방법">오류 제어 방법</h3>
<blockquote>
<p>ARQ : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식</p>
</blockquote>
<ol>
<li>Stop and Wait ARQ</li>
</ol>
<p>전송측은 수신측에서 보내준 ACK를 받을 때까지 프레임의 복사본을 유지한다.<br>
식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 부여한다.</p>
<p>수신측이 데이터를 받지 못했을 경우, NAK를 송신측에게 보내고<br>
NAK를 받은 송신측은 데이터를 재전송한다.</p>
<p><strong>만약 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송한다.</strong></p>
<img src="/img/stop_and_wait_arq.png" width="400" height="200">
<ol start="2">
<li>Go-Back-n ARQ(GBn ARQ)</li>
</ol>
<p>전송된 프렘이이 손상되거나 분실될 경우, <strong>확인된 마지막 프레임 이후로 모두 재전송</strong>하는 기법이다.</p>
<p>슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별을 해야한다.</p>
<ul>
<li>ACK : 다음 프레임을 전송</li>
<li>NAK : 손상된 프레임 자체 번호를 반환</li>
</ul>
<p><strong>재전송 되는 경우는 다음과 같다.</strong></p>
<p><strong># 1. NAK 프레임을 받았을 경우</strong></p>
<p>만약 수신측으로 0부터 5까지의 데이터를 보내었다고 가정한다. 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 받게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다.</p>
<p>그러나 만약 수신측에서 데이터 오류 프레임2가 잘못 되었다는 것을 발견하고 NAK 2를 전송측에 보낸다. NAK 2를 받은 전송측은 데이터 프레임2가 잘못 되었다는 것을 알고 데이터를 재전송한다.</p>
<p>GBn ARQ의 특징은 바로 이 데이터를 재전송하는 부분이다. GBn ARQ는 NAK(n)을 받아 데이터를 재전송하게 되면, n 데이터만을 재전송하는 것이 아니라 n 데이터 이후의 데이터를 모두 재전송한다.</p>
<p><strong># 2. 전송 데이터 프레임의 분실</strong></p>
<p>GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 재전송과 수신측의 폐기이다. 수신측에서 데이터 1을 받았는데 갑자기 다음에 데이터 3을 받게 된다면 수신측에서는 데이터 2를 못받았으므로 데이터 3을 폐기하고 NAK 2를 전송측에 보낸다.</p>
<p>NAK 2를 받은 전송측은 위의 1의 경우에서와 같이 NAK 2 데이터부터 모두 재전송을 실시하며 수신측은 기존 받았던 데이터 중 NAK(n)으로 보내었던 대상 데이터 이후의 데이터를 모두 폐기하고 재전송 받는다.</p>
<p><strong># 3. 지정된 타임아웃 내의 ACK 프레임 분실(Lost ACK)</strong></p>
<p>전송 스테이션은 분실된 ACK를 다루기 위해 타이머를 가지고 있다. 전송측에서는 이 타이머의 타임 아웃동안 ACK 데이터를 받지 못했을 경우, 마지막 ACK부터 재전송한다.</p>
<img src="/img/error_flow_control_6.png" width="400" height="200">
<p>위의 그림은 송신측이 데이터 3을 보내고 수신측은 데이터 3을 받았지만 오류가 발생했을 경우이다. 이 경우에 송신측은 연속적으로 데이터를 보내지만 수신측은 데이터 3에서 오류가 발생했으므로 NAK 3을 송신측으로 보낸다.</p>
<p>수신측은 데이터 3 이후로 온 데이터 프레임을 모두 폐기하며 송신측은 데이터 3부터 재전송하게 된다.</p>
<img src="/img/error_flow_control_7.png" width="400" height="200">
<p>위의 그림은 송신측에서 데이터 2를 보내는 도중에 분실된 경우이다. 이 경우 수신측은 데이터 0, 1은 맞게 받았지만 2를 받지 않고 3을 받게 되어 받은 데이터를 폐기하고 NAK 2를 송신측에게 보낸다.</p>
<p>그럼 송신측은 NAK 2를 받고 데이터 2부터 송신측은 수신측으로 데이터를 재전송하게 된다.</p>
<ul>
<li>전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송한다.</li>
<li>수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다.</li>
<li>타임아웃(ACK 분실)일 경우, 마지막 ACK된 데이터부터 재전송한다.</li>
</ul>
<ol start="3">
<li>Selective-Reject(SR) ARQ</li>
</ol>
<p>GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다. SR ARQ는 손상된, 분실된 프레임만 재전송한다.</p>
<p>그렇기 때문에 별도의 데이터 재정렬을 수행해야 하며, <strong>별도의 버퍼를 필요로 한다.</strong></p>
<h2 id="gbn-arq-기법과-sr-arq-기법의-비교">GBn ARQ 기법과 SR ARQ 기법의 비교</h2>
<img src="/img/error_flow_control_8.png" width="400" height="200">
<img src="/img/error_flow_control_9.png" width="400" height="200">
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://90nam.tistory.com/23" target="_blank" rel="noopener">TCP Tahoe와 TCP Reno</a></li>
<li><a href="http://www.jidum.com/jidums/view.do?jidumId=424" target="_blank" rel="noopener">TCP/IP 혼잡제어</a></li>
<li><a href="http://jsonsang2.tistory.com/17" target="_blank" rel="noopener">흐름 제어와 혼잡 제어</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Erro-Flow-Control/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Packet-Switching-Method/"
                            aria-label=": [네트워크] 가상회선 패킷 교환 vs 데이터그램 패킷 교환"
                        >
                            [네트워크] 가상회선 패킷 교환 vs 데이터그램 패킷 교환
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T17:20:32+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다.</p>
<h2 id="데이터그램-패킷-교환-방식">데이터그램 패킷 교환 방식</h2>
<p>데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.<br>
이를 <code>데이터그램</code>이라 한다.<br>
패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(<strong>비연결 지향형</strong>)<br>
<strong>송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.</strong></p>
<img src="/img/datagram_packet.png" width="500" height="200">
<h2 id="가상회선-패킷-교환-방식">가상회선 패킷 교환 방식</h2>
<p>데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(<strong>연결 지향형</strong>) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.<br>
데이터 그램은 패킷마다 라우터가 경로를 선택하지만,<br>
가상회선 방식은 경로를 설정할 때 한 번만 수행한다.</p>
<img src="/img/virtual_circut_packet.png" width="500" height="200">
<h2 id="비교">비교</h2>
<p>정해진 시간 안이나 다량의 데이터를 연속으로 보낼 때는 <strong>가상 회선 방식</strong>이 적합하다.<br>
짧은 메시지의 일시적인 전송에는 <strong>데이터그램 방식</strong>이 적합하다.</p>
<p>네트워크 내의 한 노드가 다운되면 <strong>데이터그램 방식</strong>은 다른 경로를 새로 설정하지만,<br>
<strong>가상회선 방식</strong>은 그 노드를 지나는 모든 가상회선을 잃게 된다.</p>
<p>[부족한 내용 업데이트 해야 함.]</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://gotwo.tistory.com/107" target="_blank" rel="noopener">데이터그램 패킷 교환 vs 가상회선 패킷 교환</a></li>
<li><a href="http://blog.naver.com/PostView.nhn?blogId=eronica&amp;logNo=40007289876" target="_blank" rel="noopener">참고할 예정 : 패킷교환방식인 데이터그램방식과 가상회선방식을 비교</a></li>
<li><a href="http://security-nanglam.tistory.com/179" target="_blank" rel="noopener">참고할 예정 : [데이터그램(Datagram) &amp;  가상회선(Virtual Circuit)]</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Packet-Switching-Method/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-UDP-TCP-Concept/"
                            aria-label=": [네트워크] UDP와 TCP"
                        >
                            [네트워크] UDP와 TCP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T15:14:42+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>인터넷은 트랜스포트 계층에 연결형 프로토콜과 비연결형 프로토콜. 이렇게 두 개의 주된 프로토콜을 갖는다.</p>
<h2 id="udp"># UDP</h2>
<p>UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 <strong>비연결형</strong> 프로토콜이다. IP 데이터크램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.</p>
<p>UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.</p>
<p>UDP가 특별히 유용한 분야는 <code>클라이언트-서버 상황</code>이다. 종종 클라이언트는 서버로 짧은 요청을 보내고 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실되면, 클라이언트는 time-out되고 다시 시도할 수 있다. <strong>코드가 간단할 뿐만 아니라 TCP처럼 초기 설정에서 요구되는 프로토콜에서보다 적은 메시지가 요구된다.</strong></p>
<p><strong>UDP가 사용되는 분야</strong></p>
<ol>
<li>DNS<br>
어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.</li>
</ol>
<ol start="2">
<li>실시간 멀티미디어<br>
실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 패킷 형식으로 전송하는 <code>실시간 트랜스포트 프로토콜(RTP :: Real-time Transprot Protocol)</code>이 탄생했다.<br>
RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 <strong>멀티 플렉싱</strong>하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지들로 전송될 수 있다. RTP는 단지 UDP를 사용하기 때문에 전달, 지연, 손실 등에 대한 보장이 없다.<br>
[멀티플렉싱이 뭘까…?]</li>
</ol>
<p>이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 바로 전 패킷보다 <strong>하나 높은 번호가 주어진다.</strong> 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 분실되었는지 알 수 있게 한다. 만약 한 패킷이 없다면 이를 획득하기 위해 목적지에서의 최상의 동작은 보간(Interpolation)에 의해 손실한 값에 대한 근사치를 얻는 것이다.<br>
재전송은 재전송된 패킷이 유용하기에 너무 늦게 도착하므로 실용적인 옵션이 아니다. 그러므로 RTP는 확인 응답이 없고 재전송을 요청하는 메커니즘도 없다.</p>
<p>서로 다른 경로로 패킷을 처리함에도 순서를 부여하거나 재조립을 하거나 또는 흐름제어, 혼잡제어 등의 신뢰성 처리를 하지 않기 때문에 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터의 전송을 보장하지 못한다는 단점도 존재한다.</p>
<h2 id="tcp"># TCP</h2>
<p>대부분의 인터넷 응용분야들은 <strong>신뢰성과 순차적인 전달</strong>을 필요로 한다. UDP로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 <code>TCP</code>이다.</p>
<p>TCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 <strong>신뢰성 있는 바이트 스트림</strong>을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 서비스를 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다.</p>
<p>또한, TCP는 연결형 프로토콜로 3-way-handshake 과정을 통해서 연결을 설정하고 4-way-handshake 과정을 통해서 연결을 해제[가상 회선 방식]한다. 흐름 제어 및 혼잡 제어를 통해 높은 <strong>신뢰성</strong>을 보장한다. 그러나 이러한 기능 때문에 UDP보다 속도가 느리다. 그리고 전송 순서를 보장하며 수신 여부를 확인할 수 있다.<br>
<strong>TCP는 연속성보다 신뢰성이 있는 전송이 중요할 때 사용하는 프로토콜이다.</strong><br>
하나의 연결을 설정하려면 한쪽(서버)은 listen과 accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 listen과 accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 다른 한 쪽(client)은 connect를 실행하고 목적지 IP 주소와 포트 번호, 수신 가능한 최대 TCP 세그먼트 크기 그리고 기타 사용자 데이터를 명시한다.</p>
<p><strong>1. TCP 연결방식</strong></p>
<p>모든 TCP 연결은 <strong>전이중(full-duplex), 점대점(point to point) 방식</strong>이다.<br>
전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며<br>
점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다.<br>
TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다. 또한 메시지 스트림이 아니라 바이트 스트림의 형태를 갖는다. 메시지의 시작에서 끝까지 경계가 유지되지 않는다.</p>
<p><strong>2. TCP 특징</strong></p>
<ul>
<li>TCP 연결상의 모든 바이트가 고유의 32-비트 순서번호(sequence number)를 갖는다.</li>
<li>송수신 TCP 개체들은 세그먼트의 형태로서 데이터를 주고받는다. 한 세그먼트는 고정 2바이트 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다.</li>
<li>TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다.</li>
<li>세그먼트 크기에는 두 가지 제약요소가 있다.
<ul>
<li>모든 세그먼트들은 TCP 헤더를 포함하여 IP 수용량인 65,515 바이트를 넘을 수 없다는 것.</li>
<li>모든 네트워크는 정해진 **MTU(Maximum transfer Unit,최대 전송 단위)**를 갖는데 각 세그먼트는 이 MTU를 넘을 수 없다는 것.</li>
</ul>
</li>
<li>TCP는 IP와 함께 사용하는데 IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.</li>
<li>TCP는 신뢰성있는 데이터 전송을 지원하는 연결 지향형 프로토콜이다.</li>
<li>연결지향형인 TCP는 3-way-handshake 과정을 통해 연결 후 통신을 시작한다.</li>
<li>TCP에서 사용하는 포트 번호의 수는 0 ~ 65535(=2^16)이며, 총 65536개가 사용 가능하다.</li>
<li></li>
</ul>
<p>TCP 개체들에 의해 사용되는 기본 프로토콜은 동적으로 윈도우 크기를 조절할 수 있는 <strong>슬라이딩 윈도우(Sliding Window)프로토콜</strong>이다. 송신자는 한 세그먼트를 전송할 때, <strong>타이머를 구동</strong>시킨다. 그 세그먼트가 목적지에 도달하면 수신측 TCP 개체는 다음에 받으려고 하는 순서번호와 같은 응답 번호를 포함하는 세그먼트를 송신측으로 보낸다. 보낼 데이터가 있다면 그 데이터와 함께 보낸다.<br>
-Ex) 예를 들어, 송신측에 보낼 세그먼트가 3개 있고 번호는 1,2,3이라고 하자. 송신자는 1번 세그먼트를 수신측에 보낸다. 세그먼트가 목적지에 도달하면 수신측 TCP는 다음에 받으려고 하는 순서번호와 같은 확인 응답 번호 2를 포함하는 세그먼트를 송신측에 보낸다.</p>
<p>만일 확인 응답의 수신 전에 보낼 때 구동시킨 타이머가 종료되면 송신자는 그 세그먼트를 재전송한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 장치가 필요하며, 스트림 내의 각 바이트가 자기 고유의 <code>offset</code>을 가지고 있는데 이것을 장치로 한다.</p>
<p>TCP에서 <strong>흐름 제어</strong>는 가변크기의 <code>슬라이딩 윈도우</code>를 사용하여 처리된다. window size 필드는 확인 응답된 바이트에서 시작하여 얼마나 많은 바이트가 보내질 수 있는지를 나타낸다. 그러나 이 경우 좋지 않은 상황이 발생할 수 있다. 송신자는 응용프로그램에서 데이터가 올 때마다 전송할 필요가 없고 수신자도 마찬가지로 데이터를 받은 즉시 확인 응답을 해야 하는 것은 아니다.<br>
<strong>버퍼를 사용하면 되기 때문에 데이터를 모아서 보내거나 그것을 받고 애플리케이션에게 모아서 전달할 수 있는 것이다.</strong></p>
<p>인터렉티브 에디터<br>
네이글 알고리즘<br>
애플리케이션에서 수신된 데이터를 1바이트씩 가져가는 것<br>
3가지 추후 공부</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-UDP-TCP-Concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-TCP-3-4-WayHandShake/"
                            aria-label=": [네트워크] 3&amp;4 Way Handshake"
                        >
                            [네트워크] 3&amp;4 Way Handshake
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T13:45:32+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="3-way-handshake와-4-way-handshake">3-Way-Handshake와 4-Way-Handshake</h2>
<p>네트워크를 사용한 통신에서 TCP 통신을 하는 경우, 3-way-handshake라는 과정을 거친다.</p>
<p>TPC/IP 프로토콜을 이용해서 통신하는 두 종단간에 데이터 전송 전 정확한 데이터 전송을 보장하기 위해 사전에 연결하는 과정이다.</p>
<p><strong>연결 성립(Connection Extablishment)</strong></p>
<img src="/img/tcp_ip_3_way_handshake.png" width="600" height="300">
<ol>
<li>클라이언트는 서버에 접속을 요청하는 SYN(a) 패킷을 보낸다.</li>
<li>서버는 클라이언트의 요청인 SYN(a)을 받고 클라이언트에게 요청을 수락한다는 ACK(a+1)과 SYN(b)가 설정된 패킷을 클라이언트에게 발송한다.</li>
<li>클라이언트는 서버의 수락 응답인 ACK(a+1)과 SYN(b) 패킷을 받고 ACK(b+1)을 서버로 보내면 연결이 성립(establish)된다.</li>
</ol>
<p><strong>연결 종료(Connection Termination)</strong></p>
<p>TCP 통신에서 3-way-handshake를 통한 연결을 해제하는 과정이다.</p>
<img src="/img/tcp_ip_4_way_handshake.png" width="600" height="300">
<ol>
<li>클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.</li>
<li>서버는 클라이언트의 요청(FIN)을 받고 알겠다는 확인 메시지로 ACK를 보낸다.<br>
2-1) 그리고 나서는 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.(서버측 :: 자신의 통신이 끝날 때까지 기다리며 서버는 해당 포트에 연결되어 있는 Application에게 close() 을 요청한다.)</li>
<li>데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN 플래그를 전송한다.(close() 요청을 받은 Application은 종료 프로세스를 진행하고 FIN 패킷을 Client에게 전송!)</li>
<li>클라이언트는 FIN 메시지를 확인했다는 메시지(ACK)를 서버에게 보낸다.<br>
4-1) 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다.(TIME_WAIT)[TIME_WAIT에서 일정 시간이 지나면 close 된다.]</li>
<li>클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close 한다.</li>
</ol>
<p>연결 설정과 종료 단계에서 차이가 나는 이유는 클라이언트가 데이터 전송을 마쳤다고 하더라도 서버는 아직 보낼 데이터가 남아있을 수 있기 때문이다.<br>
따라서 일단, 클라이언트는 FIN에 대한 확인 응답인 ACK를 먼저 보내고, 데이터를 모두 전송한 후 서버 자신도 FIN을 보내기 때문이다.</p>
<p>클라이언트의 FIN 전송 후 ACK를 기다리는 FIN_WAIT1과 서버의 ACK를 받은 후 서버의 FIN을 기다리는 FIN_WAIT2는 일정 시간 후 TIME_OUT이 되면 스스로 연결을 종료한다.<br>
그러나 CLOSE_WAIT은 Application에서 close()를 적절하게 처리해주지 못하면 CLOSE_WAIT 상태로 계속 기다리게 된다. CLOSE_WAIT 상태인 연결이 많아지면 <strong>Hang</strong>이 걸려 더 이상 연결을 하지 못하는 경우가 생긴다.</p>
<p>[Hang이 뭘까…?]</p>
<blockquote>
<p>SYN Packet과 ACK Packet란?</p>
</blockquote>
<p>SYN :: synchronize sequence number<br>
ACK :: acknowledgement</p>
<p><code>TCP Header</code>에는 Control Bit(플래그 비트, 6bit)라는 부분이 존재한다. 각각의 비트들은 의미를 가지고 있으며, <strong>Urg-Ack-Psh-Rst-Syn-Fin</strong> 이다. 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷인지를 나타낸다.<br>
ex)<br>
SYN 패킷일 경우에는 000010이 되고<br>
ACK 패킷일 경우에는 010000이 된다.</p>
<blockquote>
<p>왜 패킷의 종류가 두개인가?</p>
</blockquote>
<p>일단 연결을 성립하려면 서로 통신이 가능한지를 먼저 파악하기 위해 패킷을 먼저 주고받아야 한다는 것까지는 이해가 쉽다. 그런데 두 종류의 패킷을 주고 받는다. 이는 <strong>요청</strong>과 <strong>응답</strong>에 대한 패킷을 주고 받아야 하기 때문에 두 종류인 것이다.</p>
<blockquote>
<p>2-way가 아니고 3-way인 이유는??</p>
</blockquote>
<p>비유를 들어보자.<br>
클라이언트가 자신의 목소리가 들리는지 물어본다.(SYN)<br>
서버는 클라이언트의 목소리가 들린다고 말한다.(SYN+1) 그리고 자신의 목소리가 들리는지 물어본다.(ACK)<br>
클라이언트는 서버의 목소리가 들린다고 말한다.(ACK+1)</p>
<p>이런 과정인 셈이다. TCP Connection은 양방향성 Connection이다. 클라이언트에서 서버에게 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, 서버에서도 클라이언트에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. <strong>그렇기 때문에 2-way-handshake로는 부족하므로 3-way-handshake를 사용한다.</strong></p>
<blockquote>
<p>sequence number가 난수인 이유는?</p>
</blockquote>
<p>처음 클라이언트에서 SYN 패킷을 보낼 때 <strong>Sequence Number에는 랜덤한 숫자가 담겨진다.</strong><br>
초기 sequence number를 ISN이라고 한다. ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇일까?<br>
Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용된다. 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용하는 가능성이 존재한다. 서버측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있다.<br>
<strong>이러한 문제가 발생할 가능성을 줄이기 위해 난수로 ISN을 설정하는 것이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/356" target="_blank" rel="noopener">TCP 3-way-handshake &amp; 4-way-handshake</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-TCP-3-4-WayHandShake/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/"
                            aria-label=": [네트워크] HTTP"
                        >
                            [네트워크] HTTP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T12:02:38+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="http란">HTTP란?</h2>
<p>HTTP(HyperText Transfer Protocol)의 약자로 하이퍼 텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, Web Server와 Web Clinet 간의 통신을 하기 위한 통신 규약이다.</p>
<p><strong>HTTP</strong>는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 월드 와이드 웹(WWW) 기반에서 전 세계적인 정보 공유를 이루는데 큰 역할을 하였다.</p>
<p>HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 요청(request)과 응답(response)을 전송한다.</p>
<h2 id="http-특징">HTTP 특징</h2>
<ul>
<li>HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석된다.</li>
<li>TCP/IP를 이용하는 응용 프로토콜이다.</li>
<li><strong>HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.</strong>[이러한 단점을 해결하기 위해 쿠키와 세션이 등장.]</li>
<li>HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청(request)와 응답(response) 방식으로 동작한다.</li>
</ul>
<p><strong>동작</strong></p>
<img src="/img/http.png" width="500" height="200">
<p>사용자(Client)가 브라우저를 통해서 어떠한 서비스를 url을 통해서 혹은 다른 방법으로 <strong>요청</strong>(request)을 하면 서버에서는 해당 요청 사항에 맞는 결과를 찾아서 사용자에게 <strong>응답</strong>(response)하는 형태로 동작한다.</p>
<ul>
<li>요청 : client -&gt; server</li>
<li>응답 : server -&gt; client</li>
</ul>
<p>HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다. Plain text로부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며 보통은 client가 어떤 정보를 어떻게 받고 싶은지 명시해주는 경우가 많다.<br>
(HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지)</p>
<h2 id="http의-get과-post-비교">HTTP의 GET과 POST 비교</h2>
<p>GET과 POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 <strong>요청</strong>할 때 사용하는 방식이다. PUT과 DELETE도 있지만 지금은 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도로 사용할 수 있도록 하자.</p>
<p><code>1. GET</code></p>
<p>GET 방식은 요청하는 <strong>데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송된다.</strong> “url?(데이터)” 처럼 request를 보내는 것이다.</p>
<p>이러한 방식은 url이라는 공간에 데이터가 담겨가기 때문에 전송할 수 있는 <strong>데이터의 크기가 제한적이다.</strong> 또한, 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되므로 GET 방식은 적절하지 않다.<br>
ex) password</p>
<p><code>2. POST</code></p>
<p>POST 방식은 <strong>HTTP Message의 Body 부분에 데이터가 담겨서 전송된다.</strong> 따라서 GET 방식에 비해서 더 큰 데이터를 보낼 수 있어 큰 데이터를 요청하는 경우에 사용할 수 있다. 보안적인 측면에서는 암호화를 하지 않은 이상 차이가 없다.</p>
<p>GET은 가져오는 의미를 가지고 있다. 서버에서 어떤 데이터를 가져와서 보여주는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. <strong>SELECT</strong> 적인 성향을 갖고 있다.<br>
반면에 POST는 서버의 값이나 상태를 <strong>변경</strong>하기 위해서 또는 <strong>추가</strong>하기 위해서 사용된다.</p>
<p>GET 방식의 요청은 브라우저에서 <code>Caching</code>할 수 있다. 따라서 POST 방식보다 빠르게 응답할 수 있다. POST 방식으로 요청해야 할 데이터의 크기 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청을 한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/DataStructure-Graph/"
                            aria-label=": [자료구조] Graph"
                        >
                            [자료구조] Graph
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T11:07:43+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><a href="#%EC%A0%95%EC%A0%90%EA%B3%BC-%EA%B0%84%EC%84%A0%EC%9D%98-%EC%A7%91%ED%95%A8,-Graph">정점과 간선의 집함, Graph</a><br>
<a href="#%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC">그래프 관련 용어 정리</a></p>
<h2 id="정점과-간선의-집함-graph">정점과 간선의 집함, Graph</h2>
<p>그래프란 정점과 간선의 집합을 말한다.<br>
ex) 트리는 그래프. [싸이클이 허용되지 않는 그래프이다.]</p>
<h2 id="그래프-관련-용어-정리">그래프 관련 용어 정리</h2>
<ul>
<li>V(vertex) : 정점을 의미한다.</li>
<li>E(edge) : 간선을 의미한다.</li>
</ul>
<ol>
<li>Directed Graph(Digraph)<br>
말 그대로 정점과 간선의 연결관계에 있어서 <code>방향성</code>이 포함되어 있는 그래프를 말한다.</li>
</ol>
<img src="/img/digraph.png" width="400" height="200">
<center>V = {1,2,3,4,5,6}</center>
<center>E = {(1,4),(2,1),(3,4),(5,6)}</center>
<center>(u,v) = vertex u에서 vertex v로 가는 edge</center>
<ol start="2">
<li>Undirected Graph<br>
정점과 간선의 연결관계에 있어서 <code>방향성</code>이 없는 그래프를 말한다.</li>
</ol>
<img src="/img/undirected_graph.png" width="400" height="200">
<ol start="3">
<li>Degree<br>
Undirected Graph에서 각 정점(Vertex)에 연결된 Edge의 개수를 <strong>Degree</strong>라고 한다.<br>
Directed Graph에서는 간선에 <code>방향성</code>이 존재하기 때문에 Degree가 두 개로 나뉘게 된다.<br>
각 정점으로부터 나가는 간선의 개수를 <strong>Outdegree</strong>라고 하고, 들어오는 간선의 개수를 <strong>Indegree</strong>라고 한다.</li>
</ol>
<ol start="4">
<li>가중치 그래프(Weight Graph)<br>
가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프는 모든 간선의 가중치가 동일한 그래프이다.</li>
</ol>
<ol start="5">
<li>부분 그래프(Sub Graph)<br>
부분 집합과 유사한 개념으로 부분 그래프라는 것이 존재한다.<br>
부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</li>
</ol>
<h2 id="그래프를-구현하는-두-방법">그래프를 구현하는 두 방법</h2>
<p>[무슨 말일까…?ㅠ^ㅠ]</p>
<ol>
<li>
<p>인접 행렬(adjacent matrix)<br>
정방 행렬을 사용하는 방법이다.<br>
해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)으로 파악할 수 있다.<br>
Edge 개수와는 무관하게 V^2의 Space Complexity(공간 복잡도)를 갖는다.<br>
=&gt; Dense graph를 표현할 때 적절한 방법이다.</p>
</li>
<li>
<p>인접 리스트(adjacent list)<br>
연결 리스트를 사용하는 방법이다.<br>
vertex의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다.<br>
Space Complexity는 O(E + V)이다.<br>
=&gt; Sparse graph를 표현하는데 적당한 방법이다.</p>
</li>
</ol>
<p>[어려운 용어가 많이 나온다… 더 공부하자!!]</p>
<h2 id="그래프-탐색">그래프 탐색</h2>
<p>그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<p><strong>1. 깊이 우선 탐색(Depth First Search: DFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결된 정점이 없으면 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다.<br>
어떤 자료구조를 사용해야 할까? 바로 <code>Stack</code>이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><strong>2. 너비 우선 탐색(Breadth First Search: BFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서 자료구조로 <code>Queue</code>를 사용한다. 연락을 취한 정점의 순서를 기록하기 위한 것이다.<br>
우선, 탐색을 시작하는 정점을 Queue에 넣는다.(enqueue)<br>
그리고 dequeue를 하면서 dequeue를 하는 정점과 간선으로 연결된 정점들을 enqueue한다.<br>
즉, vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><code>BFS로 구한 경로는 최단 경로이다.</code></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/342?category=688193" target="_blank" rel="noopener">Graph라는 자료구조에 대해서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/DataStructure-Graph/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/tags/자료구조/archives/2/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 2</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
