
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/14/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/17/Android-MVP-Step5/"
                            aria-label=": [안드로이드] MVP 따라하기 5"
                        >
                            [안드로이드] MVP 따라하기 5
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-17T09:32:11+09:00">
	
		    Jan 17, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 참고하는 블로그의 태환님께서 영상 올리신걸 참고하여 Presenter를 분리하는 방법을 배웠다.</p>
<p>이를 기반으로 코틀린 주요 코드를 작성했지만, 현재(2019.01.30) 자바를 이용해 프로젝트를 진행하고 있고, MVP를 적용해야 하기 때문에 한 번 더 공부를 해서 주요 코드를 작성하고자 한다.</p>
<h2 id="java의-주요-코드">Java의 주요 코드</h2>
<p><strong>MainContractor 정의</strong></p>
<p>MainContractor는 View와 Presenter에 대한 인터페이스를 정의한다. 이해하는데 용이하게 하기 위한 용도이다.</p>
<ul>
<li>View 인터페이스에는 Presenter로부터 가공된 데이터를 받고 UI를 갱신하는 로직이 필요하다.</li>
<li>Presenter 인터페이스에는 View로부터 이벤트를 받고 데이터를 가공하는 로직이 필요하다. 그리고 View로 데이터를 넘겨줘야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainContractor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addItems</span><span class="params">(ArrayList&lt;ImageItem&gt; list, Boolean isClear)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">notifyAdapter</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">attachView</span><span class="params">(View view)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSampleImageData</span><span class="params">(SampleImageData data)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadItems</span><span class="params">(Context context, Boolean isClear)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainPresenter 주요 코드</strong></p>
<ul>
<li>Presenter는 View를 들고 있는다. View에게 가공된 데이터를 넘기기 위해서 View를 들고 있는 것이다. 또한, 여기서는 데이터를 세팅하는 과정까지 포함하고 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MainContractor.View view;</span><br><span class="line"><span class="keyword">private</span> SampleImageData sampleImageData;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachView</span><span class="params">(MainContractor.View view)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.view = view;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Overrid</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detachView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    view = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSampleImageData</span><span class="params">(SampleImageData sampleImageData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sampleImageData = sampleImageData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainPresenter의 loadItems 코드</strong></p>
<ul>
<li>그리고 loadItems는 View에서 Presenter의 loadItems 함수를 호출한다. 그러면 Presenter에서는 이미지 데이터를 가져와서 view의 addItems와 notifyAdapter 함수를 호출함으로써 View에게 update된 데이터를 넘겨준다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadItems</span><span class="params">(Context context, Boolean isClear)</span> </span>&#123;</span><br><span class="line">      ArrayList&lt;ImageItem&gt; imageItemList = sampleImageData.getSampleList(context, <span class="number">10</span>);</span><br><span class="line">      view.addItems(imageItemList, isClear);</span><br><span class="line">      view.notifyAdapter();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainActivity 주요 코드</strong></p>
<ul>
<li>MainActivity에서는 Presenter를 들고 있다. 그리고 Presenter의 loadItems 함수를 호출한다. 그러면 Presenter에서는 데이터를 가공하고 View에게 전달하는 로직을 가지고 있다. 아래는 loadItems()를 호출하는 부분이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mMainPresenter = <span class="keyword">new</span> MainPresenter();</span><br><span class="line">mMainPresenter.attachView(MainActivity.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">mMainPresenter.setSampleImageData(SampleImageData.getInstance());</span><br><span class="line"></span><br><span class="line">mMainPresenter.loadItems(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>UI 갱신을 위한 주요 코드</strong></p>
<ul>
<li>UI 갱신을 위한 부분은 addItems()와 notifyAdapter() 부분이다. 이 함수는 결국 Presenter에 loadItems()를 호출하고 Presenter가 View에게 데이터를 전달하고 View에서 UI 갱신이 일어나는 과정이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItems</span><span class="params">(ArrayList&lt;ImageItem&gt; items, <span class="keyword">boolean</span> isClear)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">if</span> (isClear) &#123;</span><br><span class="line">			 imageAdapter.clear();</span><br><span class="line">	 &#125;</span><br><span class="line">	 imageAdapter.setImageItems(items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 imageAdapter.notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kotlin의-주요-코드">Kotlin의 주요 코드</h2>
<p><strong>MainContract 정의</strong><br>
Kotlin에서 사용 가능한 interface 정의를 다음과 같이 한다. var view, var ImageData를 정의한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MainContract</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">        <span class="comment">// View의 UI 갱신을 위한 메소드</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">updateItems</span><span class="params">(items : <span class="type">ArrayList</span>&lt;<span class="type">ImageItem</span>&gt;, isClear : <span class="type">Boolean</span>)</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">notifyAdapter</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> view : view</span><br><span class="line">        <span class="keyword">var</span> imageDat : SampleImageData</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Model에 접근하기 위한 메소드</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">loadItems</span><span class="params">(context : <span class="type">Context</span>, isClear : <span class="type">Boolean</span>)</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainPresenter 정의</strong><br>
그리고 <code>lateinit</code>을 통해서 변수를 선언한다.<br>
자바에서는 이때 setView/getView가 자동으로 생성된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">override</span> <span class="keyword">var</span> view: MainContract.View</span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">override</span> <span class="keyword">var</span> imageData: ImageData</span><br></pre></td></tr></table></figure>
<p>그리고 loadItems을 아래와 같이 생성한다. updateItems와 notifyAdapter을 각각 호출해주어서 UI를 갱신한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadItems</span><span class="params">(context: <span class="type">Context</span>, isClear: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    imageData.getSampleList(context, <span class="number">10</span>).let &#123;</span><br><span class="line">        view.updateItems(it, isClear)</span><br><span class="line">        view.notifyAdapter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MainActivity 정의</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">privaet <span class="keyword">lateinit</span> <span class="keyword">var</span> presenter : MainPresenter</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstancesState: <span class="type">Bundle</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    presenter = MainPresenter().apply&#123;</span><br><span class="line">        view = <span class="keyword">this</span><span class="symbol">@MainActivity</span></span><br><span class="line">        imageData = SampleImageData</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    presenter.loadItems(context, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 presenter로부터 View에 대한 콜백을 다음과 같이 처리한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItems</span><span class="params">(items: <span class="type">ArrayList</span>&lt;<span class="type">ImageItem</span>&gt;, isClear: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    imageAdapter?.apply &#123;</span><br><span class="line">        <span class="keyword">if</span> (isClear) &#123;</span><br><span class="line">            imageList?.clear()</span><br><span class="line">        &#125;</span><br><span class="line">        imageList = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">notifyAdapter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    imageAdapter?.notifyDataSetChanged()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="느낀점">느낀점</h2>
<p>MVP로 나아가기 위해서 조금씩 걸어가고 있다. 하지만 아직 어려운 건 사실이다. 익숙해지기 위해서는 더 많이 코드를 짜보고 생각을 해봐야 할 것 같다.</p>
<p>MVC가 보기에는 편하다. 몇 줄 적지 않았던 코드는 길게 늘어났고, 클래스도 많아졌다. 아직 MVP라고 하기엔 거리가 멀지만 단순히 생각해보면 Activity에서 Model을 분리했다?? 라는데 아니라고 보일지도 모른다. 그래도 최소한 View/Model 간의 결합도를 낮출 수 있고, View/Model에 대한 테스트도 가능하다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/12/23/Android-MVP-Three/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - Presenter 분리하기(동영상)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/17/Android-MVP-Step5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/16/Android-MVP-Step4/"
                            aria-label=": [안드로이드] MVP 따라하기 4"
                        >
                            [안드로이드] MVP 따라하기 4
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-16T22:36:24+09:00">
	
		    Jan 16, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 MVP 따라하기 4번째 시간이다. 저번 글에서 Android MVP 적용하는 방법 중 구글에서 추천하는 Presenter / View 인터페이스를 Contract 인터페이스에 선언해서 사용하는 방법을 다루었다.</p>
<p>이번에는 Presenter/PresenterImpl을 구현하는 방법을 살펴보려고 한다.</p>
<h2 id="presenter-interface-구현하기-전에">Presenter interface 구현하기 전에</h2>
<p>이전 글에서는 구글에서 추천하는 방법인 <strong>Contract</strong>을 통해서 interface을 구현하는 방법을 살펴보았고, 구글의 MVP 패턴 적용하는 방법을 살펴보았다.</p>
<p>여기서는 많이 사용되는 2번째 방법을 소개하려 한다.</p>
<ul>
<li>Presenter : interface로 구현하며, View를 포함</li>
<li>PresenterImpl : Presenter interface를 상속받아서 구현</li>
</ul>
<p>이번 글에서도 기존과 같은 방식으로 접근하지만 interface 생성하는 방법을 달리하였다.</p>
<img src="/img/My_Architecture.png" width="600" height="300">
<h2 id="present-interface-구현">Present interface 구현</h2>
<p>구글은 Contract을 통해서 <code>View/Presenter</code>의 interface 2개를 작성하였지만, 다음의 방법은 Presenter에 View interface만을 작성하였다. 그래서 구현하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SamplePresenter</span></span>&#123;</span><br><span class="line">    <span class="comment">// Presenter 구현</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadItem</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">        <span class="comment">// 해당 Presenter에서 사용할 View 구현</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">updateView</span><span class="params">(List&lt;Items&gt; items)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="presenterimpl-구현">PresenterImpl 구현</h2>
<p>다음과 같이 implements를 통해서 상속받고, 이를 아래와 같이 구현한다. 다만 이름은 implements의 구현체의 이름으로 <strong>Impl</strong>을 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamplePresenterImpl</span></span>(<span class="keyword">val</span> view : SamplePresenter.View) : SamplePresenter&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 상속받은 interface 구현</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">        view.updateView(lise)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view-구현">View 구현</h2>
<p>SamplePresenter인 <strong>SamplePresenterImpl</strong>을 초기화하여 사용한다. 사용법은 Contract을 통한 생성과 동일하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">SamplePresenter</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SamplePresenter presenter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		presenter = <span class="keyword">new</span> SamplePresenterImpl(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		presenter.loadItem();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">(List&lt;Items&gt; items)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// UI 갱신</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="presenter-interface가-없는-경우">Presenter interface가 없는 경우</h2>
<p>추가로 <strong>Presenter interface</strong>을 사용하지 않는 경우이다. Presenter에 대한 interface을 사용하지 않기 때문에 View에 대한 interface만을 정의한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SampleView</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">updateView</span><span class="params">(<span class="keyword">var</span> items : <span class="type">List</span>&lt;<span class="type">Items</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 다음과 같이 Presenter를 구현한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamplePresenter</span></span>(<span class="keyword">val</span> view : SampleView)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">val</span> list = ArrayList&lt;String&gt;()</span><br><span class="line">        view.updateView(list)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 다음과 같이 View의 사용이 가능하게 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> : <span class="type">AppCompatActivity</span>, <span class="type">SampleView&#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> presenter : SamplePresenter</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(<span class="keyword">var</span> savedInstanceState : <span class="type">Bundle</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        presenter = SamplePresenter(<span class="keyword">this</span>)</span><br><span class="line">        presenter.loadItem()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateView</span><span class="params">(<span class="keyword">var</span> items : <span class="type">List</span>&lt;<span class="type">Items</span>&gt;)</span></span>&#123;</span><br><span class="line">        <span class="comment">// UI 갱신</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/11/30/Android-MVP-Two/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - Presenter/View 생성하기 Other</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/16/Android-MVP-Step4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/16/Android-MVP-Step3/"
                            aria-label=": [안드로이드] MVP 따라하기 3"
                        >
                            [안드로이드] MVP 따라하기 3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-16T20:34:22+09:00">
	
		    Jan 16, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 Presenter와 View를 나누는 방법에 대해서 정리해보겠다.</p>
<h2 id="presenter의-정의는">Presenter의 정의는?</h2>
<ul>
<li>View : Presenter에서 전달받은 View의 이벤트이다.</li>
<li>Presenter : View에서 전달된 이벤트에 대한 처리를 한다.(View와 무관한 처리만 한다.)</li>
</ul>
<img src="/img/mvp_default.png" width="500" height="300">
<h2 id="presenter를-구분하는-방법들">Presenter를 구분하는 방법들</h2>
<ol>
<li>View에 대한 interface만 정의하는 방법</li>
</ol>
<ul>
<li>interface View : View에 대한 interface만 정의</li>
<li>Presenter : interface 정의 없이 함수를 생성하여 사용</li>
<li>View : interface View를 상속받아서 정의</li>
</ul>
<ol start="2">
<li>Google architecture를 따른다.</li>
</ol>
<ul>
<li>Contract : View와 Presenter에 대한 interface을 작성</li>
<li>Presenter : Contract.Presenter을 상속받아서 구현</li>
<li>View : Contract.View을 상속받아서 구현</li>
</ul>
<ol start="3">
<li>PresenterImpl을 구현</li>
</ol>
<ul>
<li>Presenter : Presenter와 View에 대한 interface을 구현</li>
<li>PresenterImpl : Presenter을 상속받아서 구현</li>
<li>View : Presenter.View을 상속받아서 구현</li>
</ul>
<p>위와 같이 구현하는 방법은 크게 3가지 정도로 나뉠 수 있다. 정답은 없고 편한 방법과 다른 사람과 공유했을 때의 장/단점을 따져서 작성하면 좋겠다.</p>
<p>interface 정의시의 장점은 처음 보는 사람이 파익이 쉽다이고, 단점은 여기나 interface 정의가 너무 많다는 것이 될 수 있습니다. 결국, View와 Presenter 간의 통신을 위한 리스너 역할의 interface view에 대한 정의는 처리가 되어야 한다.</p>
<h2 id="googl-architecture을-따르면">Googl Architecture을 따르면</h2>
<p>구글에서 정의하는 Presenter의 생성 방법은 다음과 같다.</p>
<img src="/img/Google_Architecture.png" width="600" height="300">
<ul>
<li>Presenter의 생성은 View가 아닌 실제 View가 만들어지는 시점의 Activity/Fragment/View 등에서 생성을 하고 해당 Presenter에 setView를 실행한다.</li>
<li>setView가 호출되는 시점에 자기 자신(this)을 setPresenter 함수를 통해서 실제 Presenter가 사용되어야 할 View에 전달한다.</li>
<li>View에서는 setPresenter을 통해서 전달받은 Presenter을 가지고 이후 loadItem, OnClickLstener 등의 처리를 한다.</li>
</ul>
<h2 id="여기서-의문점">여기서 의문점</h2>
<blockquote>
<p>Activity만 있는 경우는??</p>
</blockquote>
<ul>
<li>Activity만 있는 경우인데 별도의 View를 생성해야 하는가?</li>
<li>그냥 자기 자신이 받아도 되는가?</li>
</ul>
<p><strong>의문에 대한 대답</strong></p>
<ul>
<li>구글이 제안하는 방법대로라면 - 별도의 View가 있다고 생각하는게 좋겠죠? 코드의 통일성을 위해서 - 자기 자신이 받는 것은 없다고 보면 된다.</li>
</ul>
<p><strong>정리하자면</strong></p>
<ul>
<li>결국 자기 자신이 new Presenter을 처리할 수 있어야 한다.
<ul>
<li>그럼 setPresenter라는 메소드가 필요하지 않게 된다.</li>
</ul>
</li>
<li>Activitiy/Fragment/View 등에서 필요한 경우 Presenter을 생성하고, 자기 자신이 사용할 수 있어야 한다.</li>
</ul>
<h2 id="그럼-어떻게">그럼 어떻게?</h2>
<p>위와 같은 문제점에 대한 제안된 방법은 아래와 같다.</p>
<img src="/img/My_Architecture.png" width="600" height="300">
<ul>
<li>Activity/Fragment/View에서 필요한 Presenter을 직접 생성</li>
<li>setView를 전달한다.</li>
<li>loadItem을 직접 호출</li>
<li>View을 통해서 처리 결과에 다른 View을 갱신한다.</li>
</ul>
<h2 id="contract-구현하기">Contract 구현하기</h2>
<p>이번에는 구글의 <strong>Contract 정의</strong>를 따를 예정이므로 Contract를 구현한다. Contract를 사용하는 이유는 간단하다. <strong>View와 Presenter을 각각 정의하기 위함이며, 이해를 돕기 위한 이유도 있다.</strong></p>
<p>하나의 interface에 View/Presenter을 정의하고, 이를 각각의 View와 Presenter에서 정의하는 방식이다.</p>
<p>먼저 View와 Presenter을 각각 다음과 같이 구현할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleContract</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span></span>&#123;</span><br><span class="line">        <span class="comment">// View method</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span></span>&#123;</span><br><span class="line">        <span class="comment">// Presenter method</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="presenter-상속-정의">Presenter 상속 정의</h2>
<p>Presenter는 다음과 같은 방식으로 구현한다.</p>
<p>SampleContract.Presenter을 상속받아서 구현하며, SampleContract.View을 가지게 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamplePresenter</span> : <span class="type">SampleContract.Presenter&#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> view : SampleContract.View? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setView</span><span class="params">(view : <span class="type">SampleContract</span>.<span class="type">View</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="view-상속-정의">View 상속 정의</h2>
<p>SampleContract.View를 상속받으면 다음과 같이 정의해주면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">SampleContract</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> SampleContract.Presenter presenter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">		presenter = <span class="keyword">new</span> SamplePresenter();</span><br><span class="line">		presenter.setView(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		presenter.loadItem();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateView</span><span class="params">(List&lt;Items&gt; items)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// UI 갱신</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/11/28/Android-MVP-One/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - Presenter/View 생성하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/16/Android-MVP-Step3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/16/Android-MVP-Step2/"
                            aria-label=": [안드로이드] MVP 따라하기 2"
                        >
                            [안드로이드] MVP 따라하기 2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-16T19:43:15+09:00">
	
		    Jan 16, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 Android MVP 따라하기 두번째 Step으로 <strong>MVC</strong> 구조를 알아보려 한다. MVC 구조로 작성된 코드를 하나씩 <strong>MVP</strong> 구조로 변경하기 위함이다.</p>
<img src="/img/mvc.png" width="500" height="300">
<center>MVC 구조</center>
<p>MVC는 MVP 이전의 구조 중 하나이다. Model, View, Control의 약자로 주로 웹에서 사용되는 구조이다. 그래서 Android에 적용된 구조는 조금 다른 형태로 표현된다.</p>
<h2 id="mvc는">MVC는?</h2>
<p><code>Model, View, Control</code>의 약자이다. MVC는 주로 웹에서 사용하고, 가장 널리 사용되는 구조 중 하나이다. MVC 구조에서의 입력은 모두 <strong>Control</strong>에서 발생하게 되는 구조이다. 이벤트가 발생한 Control에 의해 모듈의 정의와 View의 용도가 결정된다.</p>
<ul>
<li>Model : 데이터를 가진다.</li>
<li>View : 사용자에게 보일 화면을 표현한다.</li>
<li>Control : 사용자로부터 입력을 받고, 이를 모델에 의해 View를 정의하게 된다.</li>
</ul>
<img src="/img/default_mvc.png" width="500" height="300">
<ol>
<li>Control : 사용자 이벤트 발생</li>
<li>Control : 사용자 이벤트가 발생하였는데 갱신이 필요한지 Model에 확인</li>
<li>Model : 데이터 갱신이 필요하다는 이벤트 발생</li>
<li>View : Model 또는 Control로부터 갱신 필요 여부 이벤트를 받는다.</li>
<li>View : Model에서 실제 필요한 데이터를 받아와 View를 갱신</li>
</ol>
<p>위와 같은 5단계 정도로 나열할 수 있을 것이다.</p>
<h2 id="하지만-android에서는">하지만 Android에서는?</h2>
<p>Android에서는 View와 Control이 <code>Activity/Fragment</code> 같은 View들이 모두 가지고 있다. 예를 들면 아래와 같은 코드가 될 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompactActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);</span><br><span class="line">    fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 데이터 갱신 요청</span></span><br><span class="line">            <span class="comment">// Model에 접근해서 최신 데이터를 요청</span></span><br><span class="line">              <span class="comment">// ex) ArrayList&lt;String&gt; getItems()</span></span><br><span class="line">            <span class="comment">// 전달받은 ArrayList를 통해 View를 갱신</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하나의 화면 안에서 Control인 setOnClickListener이 발생하고, 이를 View에서 모두 처리하는 형태이다. Web에서 적용된 MVC 패턴은 View와 Control이 모두 분리된 상태를 말한다. 하지만, 안드로이드는 위와 같다. 그래서 그림으로 정리해보면 아래와 같을 수 있다.</p>
<img src="/img/android_mvc.png" width="500" height="300">
<p>간단하게 정리해보면 아래와 같다.</p>
<ol>
<li>Activity에서 사용자 이벤트 발생</li>
<li>Model로부터 데이터 갱신이 필요한지 확인</li>
<li>Model로부터 전달받은 데이터를 통해 View 갱신 여부 판단</li>
<li>View에서 UI 갱신 처리</li>
</ol>
<h2 id="한-화면에서-모든-데이터를-처리함으로써-얻는-장점">한 화면에서 모든 데이터를 처리함으로써 얻는 장점</h2>
<p>Android에서 흔하게 사용되는 MVC는 Class 하나로 처리가 가능한 구조가 만들어지게 된다. 그렇기에 정리만 잘하면 한눈에 코드 파악이 가능할 수 있지만, 어느 정도 범주를 벗어나면 코드 파악이 어렵다. 함수 분리가 안되어 있다면 더욱 그렇다.</p>
<p>그렇기에 함수 분리 또는 Class 분리를 적절하게 해야 복잡도가 낮아질 수 있다. 예를 들면 아래와 같이…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> itemList.size() &gt;=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그 외에도 공통으로 분리될 수 있어 보이는 setVisibility()도 여러 번 Visible/Gone이 발생한다면 당연히 함수로 분리한다. 그렇기에 코드 분리만 잘해도 사실 MVC 패턴으로 코드 작성은 문제가 없다.(고 한다… 나는 계속 MVC로 프로젝트를 작성했다.)</p>
<h2 id="장점">장점</h2>
<ol>
<li>개발 기간이 짧을 수 있다.<br>
생각보다 개발 기간이 짧을 수 있다. 생각해야 할 부분도 많지 않고, 그냥 Android Activity에서 모든 걸 동작하게 처리만 해주면 되므로, 개발 기간이 짧을 수 있다.</li>
</ol>
<ol start="2">
<li>코드만 읽을 수 있다면 누구나 쉽게 파악 가능<br>
그리고 처음 보는 사람도 별도의 패턴을 구분하지 않고, 쉽게 파악이 가능하다.</li>
</ol>
<h2 id="단점">단점</h2>
<ol>
<li>코드의 양이 증가<br>
하나의 Class 안에서 모든 걸 할 수 있다. 그로 인해 하나의 Class에서 수백 ~ 수천 줄이 넘는 코드를 발견할 수 있다.</li>
</ol>
<ol start="2">
<li>스파게티 코드 가능성<br>
복사 / 붙여넣기가 많아지고, 코드 분리가 안되어 있다면 스파게티 코드처럼 빙빙 꼬여 있는 모습을 볼 수 있다. 그렇기에 복잡도는 증가한다. 결국 처음 설계부터 중요하고, 분리도 잘해야 한다.</li>
</ol>
<ol start="3">
<li>유지 보수의 어려움<br>
개발 기간이 짧다는 말은 그만큼 코드를 막 작성할 수 있다는 말이고, 코드의 정체성이 혼란이 생길 수 있다. 꾸준하게 이런 일이 발생하게 되면 쓰레기 코드의 양 증가를 동시에 가져오게 된다. 이러한 이유들로 유지 보수 역시 어려워지게 된다.</li>
</ol>
<ol start="4">
<li>View와 Model의 결합도가 높다.<br>
MVC는 View와 Model간의 결합도가 높다. 대부분의 코드를 View에서 Model을 직접 호출하여 사용하게 된다. 그렇기에 View와 Model 간의 결합도가 높아지게 되고, 테스트 코드 작성에도 어려움이 발생한다.</li>
</ol>
<ol start="5">
<li>테스트 코드 작성이 어렵다.<br>
MVC는 대부분 UI에서 모든 걸 할 수 있기 때문에 테스트 코드 작성이 어려워지게 된다. 작성을 한다고 하더라도 UI 위주의 테스트 코드 작성이 가능하다. 하지만 UI는 변화가 자주있는 곳 중에 하나이다. UI가 아닌 모델까지 변경이 된다면…</li>
</ol>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/10/23/Android-MVC-Architecture/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - MVC 구조 이해하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/16/Android-MVP-Step2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/16/Android-MVP-Step1/"
                            aria-label=": [안드로이드] MVP 따라하기 1"
                        >
                            [안드로이드] MVP 따라하기 1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-16T18:02:32+09:00">
	
		    Jan 16, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="서론">서론</h2>
<p>지금까지 안드로이드 개발을 하면서 아키텍처 패턴을 적용해서 개발을 해본 적이 없다. MVC, MVP, MVVM이 잘 알려져 있는데, 굳이 이 범주에 포함시켜 보자면 MVC로 개발을 진행했던 것 같다. 이번에 부스트캠프를 하는데, 어떤 교육을 받는 과정이 아니라 실무 프로젝트 중심으로 진행한다고 한다. 그래서 내가 배워보고 싶은 것들은 내가 노력하고 시간을 투자해서 공부하고 배워야 할 것 같다. 그 과정에서 어려운 것이 있다면 멘토님들한테 질문을 해보자.</p>
<p>안드로드에서 테스트 코드를 작성하기 위한 방법 중 하나로 <strong>MVP</strong>를 선택해서 사용한다고 한다. 또한 Model, View, Presenter 간의 상호 의존성을 떨어트리기 위한 용도도 있다고 한다.</p>
<h2 id="mvp란">MVP란?</h2>
<p>서론이 조금 길었다. 그렇다면 MVP란 무엇일까?<br>
MVP를 알기 위해서는 <strong>MVP</strong>의 각 단어의 역할과 목적이 중요하다.</p>
<ul>
<li>Model : Data와 관련된 처리를 담당
<ul>
<li>Data의 전반적인 부분을 model에서 담당하고, 네트워크, 로컬 데이터 등을 포함한다.</li>
</ul>
</li>
<li>View : 사용자의 실질적인 <strong>이벤트</strong>가 발생하고, 이를 처리 담당자인 <code>Presenter</code>로 전달한다.
<ul>
<li>완전한 View의 형태를 가지도록 설계한다. 계산을 하거나 데이터를 가져오는 등의 행위는 <code>Presenter</code>에서 처리하도록 한다.</li>
</ul>
</li>
<li>Presenter : View에서 전달받은 <strong>이벤트</strong>를 처리하고, 이를 다시 View에 전달한다.
<ul>
<li>View와는 무관한 Data등을 가지고, 이를 가공하고 View에 다시 전달하는 역할</li>
</ul>
</li>
</ul>
<img src="/img/mvp.png" width="500" height="300">
<center>MVP 구조</center>
<h2 id="mvp의-기본-패턴">MVP의 기본 패턴</h2>
<p>MVP를 처음 접해보고 이제 시작하는 나로서는 그냥 <strong>빙글 빙글</strong> 돌려놓은 듯한 느낌을 받았다. 이를 아래와 같은 그림처럼 표현할 수 있다.</p>
<img src="/img/mvp_default.png" width="500" height="300">
<p>이를 순서대로 나열하면 아래와 같다.</p>
<ol>
<li>View : View에서 터치 이벤트 발생</li>
<li>View -&gt; Presenter : Presenter로 이벤트 전달</li>
<li>Presenter : View에서 요청한 이벤트 처리</li>
<li>Presenter -&gt; View : 처리한 결과를 View로 전달</li>
<li>View : 처리된 결과를 바탕으로 UI를 갱신</li>
</ol>
<p>위와 같은 형태를 가지며 1~5번까지 처리가 완료되면 이후 같은 동작이 계속적으로 일어난다. 일반 코드라면 하나의 액티비티 파일 안에서 모두 처리가되니까 눈으로 보긴 편하다. 따라갈 필요도 없고, 함수만 따라다니면 보기도 쉽기 때문이다. 그래서 MVP를 <strong>빙글 빙글</strong> 돌려놓은 것 아닐까? 라는 답이 나올 수 밖에 없다.</p>
<h2 id="mvp에-모델을-더하면">MVP에 모델을 더하면?</h2>
<p>위에서 기본적으로 작성한 MVP에 모델을 더하면 아래와 같이 표현이 가능하다.</p>
<img src="/img/mvp_model.png" width="500" height="300">
<ol>
<li>View : View에서 <strong>터치 이벤트</strong> 발생</li>
<li>View -&gt; Presenter : Presenter에 이벤트 전달</li>
<li>Presenter : 이벤트의 형태에 따라 캐시 데이터를 가져오거나 <strong>Model</strong>에 요청</li>
<li>Presenter -&gt; Model : Presenter에서 데이터를 요청 받음</li>
<li>Model : 데이터를 로컬 또는 서버에서 가져온다.</li>
<li>Presenter : 전달 받은 데이터를 가공</li>
<li>Presenter -&gt; View : 가공한 데이터를 View에 전달</li>
<li>Vie : Presenter로부터 전달받은 데이터를 View에 갱신</li>
</ol>
<p><strong>상황에 따라서 Presenter는 Model을 사용할 수도 사용하지 않을 수도 있지만 기본 형태는 위와 같다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/10/12/Android-MVP-Intro/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - Intro</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/16/Android-MVP-Step1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/14/Android-View-Lifecycle-Test/"
                            aria-label=": [안드로이드] View 함수 Testing"
                        >
                            [안드로이드] View 함수 Testing
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-14T22:19:50+09:00">
	
		    Jan 14, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>예전에는 안드로이드에서 액티비티 파일을 만들고 xml 파일에 View, ViewGroup들을 정의하고, Activity의 생명주기 함수나 혹은 프래그먼트의 생명주기 함수가 호출되는 것이 가장 중요한 개념이 아닐까 생각했었다.</p>
<p>하지만, 이런 Activity, Fragment의 View, ViewGroup들이 결국 화면에 그려지기 위해서는 분명 화면에 그리는 함수들이 존재할 것이다. 나는 이 개념과 함수들을 부스트 캠프를 준비하면서 알게 되었다.</p>
<p>안드로이드에서 ViewGroup이나 View를 화면에 그릴 때, <strong>View Lifecycle</strong>의 개념이 중요하다. 이 개념을 아직 완벽하게 이해하진 못했지만, ViewGroup의 성능 측정을 위해서 실험을 하였다. View와 관련된 개념은 이전에 공부한 포스팅에 내용을 추가할 예정이다. 그리고 성능 측정을 위해서 <code>LinearLayout, RelativeLayout, ConstraintLayout</code>의 세가지 ViewGroup을 Custom하여 테스트해보았다.</p>
<p>3개의 ViewGroup의 View 함수들이 어떻게 호출되는지 확인하기 위해서 간단한 CustomView를 만들었다. 이 예제는 <strong>박상권</strong>님의 블로그를 참고했으며, 참고 링크는 아래에 기재해두었다.</p>
<h2 id="customview-만들기">CustomView 만들기</h2>
<p>CustomView가 사용되는 경우는 같은 형식의 버튼이 3개라면 하나의 레이아웃 소스 코드를 복사해서 3번 붙여넣기 하면 만들 수 있다. 만약 버튼이 100개라면 100번 정도 복사 / 붙여 넣기 작업을 반복하면 된다.</p>
<p>그런데, padding 값이나 margin값을 바꾸고 싶다면? 100개의 버튼에 대해서 똑같은 작업을 반복하는 지옥에 빠지게 된다.(상상만 해도 끔찍하다.) 이러한 경우 <strong>CustomView</strong>를 만들어서 이를 재사용하는 것이 좋다. 예제로 로그인 버튼 형태의 레이아웃을 유지하고 아이콘과 텍스트만 변경하도록 구성해보겠다.</p>
<img src="/img/android_customview_loginbutton.png" width="600" height="400">
<p>위와 같이 custom하게 만든 속성을 이용해서 배경색, 아이콘 이미지, 텍스트, 텍스트 색상 등을 지정할 수 있다. 복잡한 레이아웃 구성도 하나의 CustomView로 만들어 준뒤 해당 CustomView를 재사용하면 편리하고 유용하게 화면을 구성할 수 있다.</p>
<p><strong>1. layout xml파일 생성하기</strong></p>
<p>CustomView의 기본으로 사용될 layout xml 파일을 만든다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/bgLinear"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"55dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/kakao_color"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/symbolLinear"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/kakao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/textLinear"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"카카오톡 로그인"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">"@color/text_color"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textStyle</span>=<span class="string">"bold"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. attrs.xml 설정</strong></p>
<p>custom하게 만들어 줄 atrribute를 설정해준다. 해당 파일은 value -&gt; attrs.xml 파일을 만들고 이 안에 내용을 추가해준다. 추가해주는 속성은 CustomView를 사용할 xml에서 속성을 지정하기 위함이다. 즉, 내가 넣고자 하는 속성을 넣어서 마음대로 만들 수 있다는 뜻이다.</p>
<img src="/img/android_customview_attrs.png" width="600" height="400">
<p>이 attr 속성을 보았을 때 4가지를 나중에 속성값으로 받아서 적용할 수 있게 할 것이다. 이 attr은 나중에 app:text=&quot; … &quot; 로 쓰일 수 있으며 “가나다라” 같은 직접적인 String과 @string/exam 같은 reference를 넣어줄 수도 있다.</p>
<p><strong>3. CustomView 만들기</strong></p>
<ol>
<li>CustomView의 생성자를 모두 만들고 그 안에서 initView, getAttrs 함수를 호출한다. [주의할 사항은 꼭 커스텀 뷰의 생성자를 모두 생성해야 하는 것이다.]</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">this</span>(context) &#123;</span><br><span class="line">    initView()</span><br><span class="line">    getAttrs(attrs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, defStyle: <span class="built_in">Int</span>) : <span class="keyword">this</span>(context, attrs) &#123;</span><br><span class="line">    initView()</span><br><span class="line">    getAttrs(attrs, defStyle)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>initView()에서는 미리 만들어둔 xml 파일을 할당하고 각각의 view를 설정해준다. inflate를 통해서 xml 파일을 view 객체로 메모리에 올린다. 그리고 addView(view)를 해준다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inflaterService : String = Context.LAYOUT_INFLATER_SERVICE</span><br><span class="line">    <span class="keyword">var</span> inflater : LayoutInflater = context.getSystemService(inflaterService) <span class="keyword">as</span> LayoutInflater</span><br><span class="line">    <span class="keyword">var</span> view = inflater.inflate(R.layout.login_button_linear, <span class="keyword">this</span>, <span class="literal">false</span>)</span><br><span class="line">    addView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>getAttrs() 함수를 통해서 attrs.xml 파일에 선언해둔 attribute를 가지고 오는 작업을 수행한다. 그리고 setTypeArray() 함수로 넘겨준다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAttrs</span><span class="params">(attrs : <span class="type">AttributeSet</span>, defStyle: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton, defStyle,<span class="number">0</span>)</span><br><span class="line">    setTypeArray(typedArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAttrs</span><span class="params">(attrs: <span class="type">AttributeSet</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton)</span><br><span class="line">    setTypeArray(typedArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>setTypeArray() 함수를 통해서 attrs.xml 파일에 정의한 속성을 적용해서 layout이 가지고 있는 view에게 값을 설정해주는 작업을 수행한다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setTypeArray</span><span class="params">(typedArray: <span class="type">TypedArray</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> backgroundResourceId = typedArray.getResourceId(R.styleable.LoginButton_bg, R.color.naver_color)</span><br><span class="line">    bgLinear.setBackgroundResource(backgroundResourceId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> symbolResourceId = typedArray.getResourceId(R.styleable.LoginButton_symbol, R.drawable.naver)</span><br><span class="line">    symbolLinear.setImageResource(symbolResourceId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textColor = typedArray.getColor(R.styleable.LoginButton_textColor, <span class="number">0</span>)</span><br><span class="line">    textLinear.setTextColor(textColor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textString = typedArray.getString(R.styleable.LoginButton_text)</span><br><span class="line">    textLinear.text = textString</span><br><span class="line"></span><br><span class="line">    typedArray.recycle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="느낀점">느낀점</h2>
<p>뷰를 화면에 그릴 때는 View의 Lifecycle이 중요하다. 이는 우리가 구성한 뷰를 사용자의 화면에 보여주기 때문이다. 그리고 렌더링되는 속도는 뷰를 그리는 것과 연관이 되어있다. 그렇다면 View의 Lifecycle을 한 번 더 살펴보자.</p>
<img src="/img/android_view_method.png" width="400" height="300">
<p>실제로 RelativeLayout이나 LinearLayout보다는 ConstraintLayout이 뷰의 계층을 줄여주고 훨씬 효율적으로 뷰를 구성할 수 있다고 한다. 이로 인해서 얻을 수 있는 이점은 무엇이 있을까 생각해봐야 한다.</p>
<ul>
<li>뷰의 계층을 수평적으로 만들 수 있다.</li>
<li>이로 인해 findViewById를 호출하는 횟수도 감소시킬 수 있다.</li>
<li>View Lifecycle 함수들의 호출 횟수를 줄일 수 있다.</li>
</ul>
<ol>
<li><strong>Linear</strong><br>
<img src="/img/android_customview_linear.png" width="700" height="500"></li>
</ol>
<center>LiearLayout을 상속받은 CustomView</center>
<ol start="2">
<li><strong>Relative</strong><br>
<img src="/img/android_customview_relative.png" width="700" height="500"></li>
</ol>
<center>RelativeLayout을 상속받은 CustomView</center>
<ol start="3">
<li><strong>Constraint</strong><br>
<img src="/img/android_customview_constraint.png" width="700" height="500"></li>
</ol>
<center>ConstraintLayout을 상속받은 CustomView</center>
<p><strong>결론</strong><br>
RelativeLayout이 Linear나 ConstraintLayout보다 <code>onMeasure()</code> 함수가 2배 정도 많이 호출되는 것을 확인할 수 있었다. 아마도 RelativeLayout이 자신의 크기를 측정하고 자식의 크기를 측정하는 과정이 필요하기 때문에 2배 호출되는 것으로 생각하고 있다. RelativeLayout은 뷰를 구성할 때 상대적인 위치를 고려해서 배치하거나 상하좌우에 배치시킬 때 나는 주로 이용했었다.</p>
<p>하지만, 복잡한 레이아웃을 구성할 때 RelativeLayout을 사용한다면 View의 계층이 깊어지게 되고 이로 인해서 View의 크기를 측정하는 과정이 길어지면서 결국에는 렌더링 속도에 영향을 미치는 좋지 않을 결과를 초래할 것이다.</p>
<p>그래서 앞으로는 ConstraintLayout을 사용해보면서 익히고 주로 사용해볼 생각을 하고 있다.</p>
<p>사실, 제대로 테스트를 진행하기 위해서는 커스텀 뷰그룹 안에 커스텀 뷰를 넣어야 한다. 하지만 나는 커스텀 뷰 그룹 안에 TextView, ImageView를 그대로 넣었다.[<strong>이 부분은 나중에 다시 테스트 할 예정</strong>]</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://one-delay.tistory.com/94" target="_blank" rel="noopener">[Android] View에 대한 기본 지식 및 ViewGroup 성능 측정 삽질기</a></li>
<li><a href="http://gun0912.tistory.com/38" target="_blank" rel="noopener">[안드로이드/Android]CustomView를 만들어서 재사용하기</a></li>
<li><a href="https://developer.android.com/training/custom-views/create-view?hl=ko" target="_blank" rel="noopener">https://developer.android.com/training/custom-views/create-view?hl=ko</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/custom-components?hl=ko#custom" target="_blank" rel="noopener">https://developer.android.com/guide/topics/ui/custom-components?hl=ko#custom</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/14/Android-View-Lifecycle-Test/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/13/DesignPattern-Bridge/"
                            aria-label=": [디자인 패턴] 브릿지 패턴"
                        >
                            [디자인 패턴] 브릿지 패턴
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-13T23:40:31+09:00">
	
		    Jan 13, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Design-Pattern/">Design Pattern</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="브릿지-패턴">브릿지 패턴</h2>
<p>구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한다. 즉, 기능과 구현에 대해서 두 개를 별도의 클래스로 구현을 한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/13/DesignPattern-Bridge/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-4/"
                            aria-label=": [안드로이드] 안드로이드 면접 4"
                        >
                            [안드로이드] 안드로이드 면접 4
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T14:26:19+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C">안드로이드 백그라운드</a></li>
<li><a href="https://woovictory.github.io/2018/03/02/Android-ActivityLifeCycle/">액티비티 생명주기</a></li>
<li><a href="https://woovictory.github.io/2019/01/02/Android-What-Is-Fragment/">프래그먼트 생명주기</a></li>
<li><a href="#Content-Provider-VS-Content-Resolver">Content Provider VS Content Resolver</a></li>
</ol>
<h2 id="안드로이드-백그라운드">안드로이드 백그라운드</h2>
<p>안드로이드 UI는 기본적으로 싱글 스레드 모델로 작동하므로, 이 영향을 고려해서 개발하지 않으면 애플리케이션의 성능이 저하될 수 있다. 따라서 메인 스레드에서 긴 작업을 하는 것을 피하기 위해 여분의 스레드를 사용해야 한다. 다른 스레드에서 UI 스레드로 접근할 수 있도록 안드로이드에서 제공하는 스레드 간 통신 방법을 알아보자.</p>
<p><strong># 소개</strong><br>
안드로이드의 애플리케이션을 실행하면 시스템은 메인 액티비티를 메모리로 올려 프로세스를 만들며, 이 때 메인 스레드가 자동으로 생성된다. 메인 스레드는 안드로이드의 주요 컴포넌트를 실행하는 곳이자 UI를 그리거나 갱신하는 일을 담당할 수 있는 유일한 스레드이므로 이를 <code>UI 스레드</code>라고 부른다.</p>
<p>안드로이드 화면을 구성하는 뷰나 뷰 그룹을 하나의 스레드에서만 담당하는 원칙을 <strong>싱글 스레드 모델</strong>이라고 한다. 싱글 스레드 모델의 규칙은 다음과 같다.</p>
<ol>
<li>메인 스레드(UI 스레드)를 블럭하지 말 것.</li>
<li>안드로이드 UI 툴킷은 오직 UI 스레드에서만 접근할 수 있도록 할 것.</li>
</ol>
<p>이런 싱글 스레드 모델의 영향을 고려하지 않으면 애플리케이션의 성능이 저하될 수 있다. 긴 시간이 걸리는 작업을 메인 스레드에서 담당하면 애플리케이션의 반응성이 낮아질 수 있고, 급기야 사용자의 불편함을 방지하고자 시스템이 애플리케이션을 ANR 상태로 전환시킬 수도 있다.</p>
<p><strong>따라서 시간이 걸리는 작업을 하는 코드는 여분의 스레드를 사용하여 메인 스레드에서 분리해야 하고, 자연스럽게 메인 스레드와 다른 스레드가 통신하는 방법이 필요하게 된다.</strong></p>
<p>다른 스레드에서 메인 스레드로 접근하기 위해 <strong>Looper</strong>와 <strong>Handler</strong>를 사용할 수 있으며, 안드로이드는 Java의 Thread를 좀 더 쉽게 사용할 수 있도록 래핑한 <code>HandlerThread</code>. 더 나아가 Thread나 Message Loop 등의 작동 원리를 크게 고려하지 않고도 사용이 가능한 <code>AsyncTask</code> 등의 클래스를 제공한다. 그럼 먼저 Thread-Looper-Handler의 개념을 이해하고 다음 내용을 알아보자.</p>
<h2 id="looper와-handler의-사용-목적">Looper와 Handler의 사용 목적</h2>
<p>왜 안드로이드는 메인 스레드에서만 UI 작업이 가능하도록 제한할까? 메인 스레드가 아닌 스레드가 병렬적으로 실행되고 있을 때, 메인 스레드와 다른 스레드, 두 개 이상의 스레드가 동시에 같은 텍스트 뷰에 setText()를 시도하는 경우를 생각하면 간단하다.</p>
<img src="/img/android_thread_reason.png" width="400" height="300">
<p>위의 그림처럼 둘 중 어느 스레드의 setText()가 적용될지 예측할 수 없고, 사용자는 둘 중 하나의 값만을 볼 수 있어 다른 한 스레드의 결과는 버려진다. 이같이 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해서 Looper와 Handler를 사용하게 된다.</p>
<h2 id="looper와-handler의-작동-원리">Looper와 Handler의 작동 원리</h2>
<p><code>안드로이드 면접 3</code>에서도 살펴보았지만, 더 보도록 하겠다. 먼저 스레드와 Looper, Handler가 어떻게 작동하는지 보자. 메인 스레드는 내부적으로 <code>Looper</code>를 가지며 그 안에는 <strong>Message Queue</strong>가 포함된다. Message Queue는 스레드가 다른 스레드나 혹은 자기 자신으로부터 전달받은 Message를 기본적으로 FIFO(선입선출) 형식으로 보관하는 Queue이다.</p>
<p><strong>Looper</strong>는 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다. <strong>Handler</strong>는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다.</p>
<img src="/img/android_looper_handler.png" width="400" height="300">
<h2 id="handler">Handler</h2>
<p>Handler는 스레드의 Message Queue와 연계하여 Message나 Runnable 객체를 받거나 처리하여 스레드 간의 통신을 할 수 있도록 한다. Handler 객체는 하나의 스레드와 해당 스레드의 Message Queue에 종속된다. 새로 Handler 객체를 만든 경우 이를 만든 스레드와 해당 스레드의 Message Queue에 바인드 된다.</p>
<p>다른 스레드가 특정 스레드에게 메시지를 전달하려면 특정 스레드에 속한 Handler의 post나 sendMessage 등의 메소드를 호출하면 된다. 앞서 Message Queue는 전달받은 Message를 선입선출 형식으로 보관한다고 설명했지만, 전달 시점에 다른 메소드를 사용하여 Queue의 맨 위로 보내거나 원하는 만큼 Message나 Runnable 객체의 전송을 지연시킬 수도 있다. 자주 쓰이는 Handler의 메소드는 아래 글을 참고하자.</p>
<p><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">참고 글</a></p>
<p>외부, 혹은 자기 스레드로부터 받은 메시지를 어떤 식으로 처리할지는 <code>handleMessage()</code> 메소드를 구현하여 정리한다. <code>sendMessage()</code>나 <code>post()</code>로 특정 Handler에게 메시지를 전달할 수 있고, 재귀적인 호출도 가능하므로 딜레이를 이용한 타이머나 스케줄링 역할도 할 수 있어 편리하다.</p>
<h2 id="looper와-message-queue">Looper와 Message Queue</h2>
<p>Looper는 무한히 루프를 돌며 자신이 속한 스레드의 Message Queue에 들어온 Message나 Runnable 객체를 차례로 꺼내서 이를 처리할 Handler에 전달하는 역할을 한다. 메인 스레드는 Looper가 기본적으로 생성돼 있지만, 새로 생성한 스레드는 기본적으로 Looper를 가지고 있지 않고, 단지 run 메소드만 실행한 후 종료하기 때문에 메시지를 받을 수 없다.</p>
<p>따라서 기본 스레드에서 메시지를 전달받으려면 <code>prepare()</code> 메소드를 통해 <strong>Looper</strong>를 생성하고, loop() 메소드를 통해 Looper가 무한히 루프를 돌며 Message Queue에 쌓인 Message나 Runnable 객체를 꺼내 Handler에 전달하도록 한다. 이렇게 활성화된 Looper는 quit()이나 quitSafely() 메소드로 중단할 수 있다. quit() 메소드가 호출되면 Looper는 즉시 종료되고, quitSafely() 메소드가 호출되면 현재 Message Queue에 쌓인 메시지들을 처리한 후 종료된다.</p>
<img src="/img/android_looper_message_queue.png" width="400" height="300">
<h2 id="message와-runnable">Message와 Runnable</h2>
<p><strong>Message</strong><br>
Message란 스레드 간 통신할 내용을 담는 객체이자 Queue에 들어갈 일감의 단위로 Handler를 통해 보낼 수 있다. 일반적으로 Message가 필요할 때 새 Message 객체를 생성하면 성능 이슈가 생길 수 있으므로 안드로이드가 시스템에 만들어 둔 <strong>Message Pool</strong>의 객체를 재사용한다. obtain() 메소드는 빈 Message 객체를, obtain(Handler h, int what …)은 목적 Handler와 다른 인자들을 담은 Message 객체를 리턴한다.</p>
<p><strong>Runnable</strong><br>
새 스레드는 Thread() 생성자로 만들어서 내부적으로 run()을 구현하던지, Thread(Runnable runnable) 생성자로 만들어서 Runnable 인터페이스를 구현한 객체를 생성하여 전달하던지 둘 중 하나의 방법으로 스레드를 만들 수 있다. 후자에서 사용하는 것이 <strong>Runnable</strong>로 스레드의 run() 메소드를 분리한 것이다. 따라서 Runnable 인터페이스는 run() 추상 메소드를 가지고 있으므로 상속받은 클래스는 run() 코드를 반드시 구현해야 한다. 앞서 언급한대로 Message가 int나 Object 같이 <strong>스레드 간 통신할 내용</strong>을 담는다면 Runnable은 실행할 run()메소드와 그 내부에서 실행될 코드를 담는다는 차이점이 있다.</p>
<h2 id="handlerthread">HandlerThread</h2>
<p>Looper에서 언급했듯이 안드로이드의 스레드는 Java의 스레드를 사용하기 때문에 안드로이드에서 도입한 Looper를 기본으로 가지지 않는다는 불편함이 있다. 이같은 불편함을 개선하기 위해 생성할 때 Looper를 자동으로 보유한 클래스를 제공하는데, 이것이 바로 <code>HandlerThread</code>이다. HandlerThread는 일반적인 스레드를 확장한 클래스로 내부에 반복해서 루프를 도는 <strong>Looper</strong>를 가진다. 자동으로 Looper 내부의 Message Queue도 생성되므로 이를 통해 스레드로 Message나 Runnable을 전달받을 수 있다.</p>
<h2 id="asynctask">AsyncTask</h2>
<p><code>AsyncTask</code>는 스레드나 메시지 루프 등의 작동 원리를 잘 몰라도 하나의 클래스에서 UI 작업과 background 작업을 쉽게 할 수 있도록 안드로이드에서 제공하는 클래스이다. <strong>캡슐화</strong>가 잘되어 있기 때문에 사용시 코드 가독성이 증대되는 장점이 있으며, 태스크 스케줄을 관리할 수 있는 콜백 메소드를 제공하고 필요할 때 쉽게 UI 갱신도 가능하며 작업 취소도 쉽다. 따라서 리스트에 보여주기 위한 데이터 다운로드 등 UI와 관련된 독립된 작업을 실행할 경우 <code>AsyncTask</code>로 간단하게 구현할 수 있다.</p>
<img src="/img/android_AsyncTask.png" width="400" height="300">
<center>AsyncTask 구조</center>
<p>그러나 AsyncTask를 사용해서 스케줄링할 수 있는 작업 수의 제한이 있고, 몇 초 정도의 짧은 작업에서만 이상적으로 동작한다는 한계가 있다. 또한, 안드로이드의 버전 별로 병렬 처리 동작이 다르므로 허니콤 이후 버전에서 멀티 스레드로 병렬적인 동작을 원한다면 AsyncTask를 실행할 때 <code>AsyncTask.THREAD_POOL_EXECUTOR</code> 스케줄러를 지정해야 한다.</p>
<p>한편, 앞서 살펴본 Handler와 Looper를 사용한다면 동작 원리를 고려해야 하며 구현을 직접해야 하고 코드가 복잡해져서 가독성을 저해한다는 단점이 있지만 그만큼 개발 범위가 자유롭다. 또한 UI 스레드에서만 작업하지 않아도 되므로 보다 많은 자율성을 가지고 코드를 제어하기를 원한다면 Handler나 HandlerThread 사용을 고려해보는 것도 좋다.</p>
<p>무엇을 사용할지는 개발자가 어떤 기준을 가지고 개발하는지에 따라 다르다. 그럼에도 나는 AsyncTask를 사용할 것 같다. 왜냐하면 핸들러는 스레드 안에서 실행되어야 할 코드와 UI 접근을 위한 코드가 각각 다른 위치에서 구현을 한다. 그러므로 가독성이 떨어진다.</p>
<p>하지만, <code>AsyncTask</code>는 하나의 클래스 안에 스레드로 동작하는 부분과 화면을 갱신하는 부분을 함께 구현해놓을 수 있다. 이 때문에 스레드를 사용하는 하나의 작업단위가 하나의 클래스로 만들어질 수 있게 되므로 가독성이 훨씬 좋아지게 된다.</p>
<p>간단한 예제는 아래 블록를 참고하자^0^<br>
<a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">AsyncTask 예제</a></p>
<h2 id="content-provider-vs-content-resolver">Content Provider VS Content Resolver</h2>
<ul>
<li>
<p>Content Provider : 어플리케이션 내에서 사용할 수 있는 데이터를 <strong>공유</strong>하기 위한 컴포넌트<br>
ex) 연락처, 이미지 등(카카오톡)</p>
</li>
<li>
<p>Content Resolver : 앱이 Content Provider를 접근할 때에는 Content Resolver를 통해서 접근하게 됨. 기본적으로 <strong>CRUD</strong> 함수들 제공 -&gt; 다른 앱의 데이터베이스를 조작할 수 있음<br>
ex) contentResolver.query()</p>
</li>
</ul>
<h2 id="xml-기반-레이아웃이-중요한-이유">XML 기반 레이아웃이 중요한 이유</h2>
<p>동작을 제어하는 코드로부터 분리시킬 수 있고, UI의 구조를 시각화하기 더 쉽기 때문이다. 소스로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 재컴파일 해야 하는 번거로움이 있다.</p>
<h2 id="manifest">Manifest</h2>
<p>애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야 한다.</p>
<h2 id="vector-vs-bitmap">Vector Vs Bitmap</h2>
<ul>
<li>
<p>Vector : 리사이징이 되어도 전혀 깨지지 않는다. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심 ex)SVG</p>
</li>
<li>
<p>Bitmap : 픽셀로 구성되어 있다. 자유자재로 바꿀 수가 없고 움직일 수도 없다. ex)PNG, JPEG</p>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">안드로이드 백그라운드 잘 다루기 Thread, Looper, Handler</a></li>
<li><a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">[Android] AsyncTask</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-3/"
                            aria-label=": [안드로이드] 안드로이드 면접 3"
                        >
                            [안드로이드] 안드로이드 면접 3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T10:56:36+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%ED%99%94%EB%A9%B4%EC%9D%B4-%ED%9A%8C%EC%A0%84%ED%95%98%EB%A9%B4-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%8A%94?">화면이 회전하면 액티비티의 생명주기는?</a></li>
<li><a href="#%ED%8E%9C%EB%8E%85%EC%9D%B8%ED%85%90%ED%8A%B8%EB%9E%80?">펜딩인텐트란?</a></li>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-Task%EC%99%80-Process%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">안드로이드에서 Task와 Process의 차이점</a></li>
<li><a href="#A-%EC%95%B1%EC%97%90%EC%84%9C-B-%EC%95%B1%EC%9D%98-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EB%A5%BC-%EB%B6%80%EB%A5%BC-%EA%B2%BD%EC%9A%B0">A 앱에서 B 앱의 액티비티를 부를 경우</a></li>
<li><a href="#%ED%99%94%EB%A9%B4-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%86%8D%EB%8F%84%EB%A5%BC-%EA%B0%9C%EC%84%A0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">화면 렌더링 속도를 개선하는 방법</a></li>
<li><a href="#Thred%EA%B0%84-%ED%86%B5%EC%8B%A0-%EB%B0%A9%EB%B2%95">Thred간 통신 방법</a></li>
<li><a href="#ANR">ANR</a></li>
</ol>
<h2 id="화면이-회전하면-액티비티의-생명주기는">화면이 회전하면 액티비티의 생명주기는?</h2>
<p>안드로이드 애플리케이션을 사용하다 보면 화면이 가로 모드를 지원하는 애플리케이션들이 많다. 이런 경우 우리가 사용하는 액티비티의 생명주기는 어떻게 되는 것일까???</p>
<p>일단, 화면이 회전하면 뷰의 크기를 재측정하고 다시 달라진 크기대로 새롭게 그려야 된다. 먼저, <code>onPause</code>가 호출되고 <code>onStop</code>, <code>onDestroy</code>가 진행된 후 다시 <code>onCreate</code>, <code>onStart</code>, <code>onResume</code> 순서로 진행된다. 따라서 현재 액티비티를 destroy 시키고 새로 만들기 때문에 기존의 데이터는 사라지게 된다.</p>
<blockquote>
<p>그런데 우리가 사용하는 애플리케이션에서는 지워지지 않는데?</p>
</blockquote>
<p><code>onDestroy</code>가 호출되기 전에 액티비티는 <code>onSaveInstanceState</code>를 호출하게 되는데 이때 저장되어야 할 데이터를 <strong>Bundle</strong> 객체에 저장해두었다가 다시 <code>onCreate</code>가 호출되면 파라미터로 날아온 Bundle에서 이전 데이터를 받아 복구할 수 있다. 이 과정을 통해 화면이 회전되어도 데이터를 유지할 수 있는 것이다.</p>
<h2 id="펜딩인텐트란">펜딩인텐트란?</h2>
<p>펜딩 인텐트(Pending Intent)는 인텐트의 일종이다.</p>
<p>컴포넌트에서 다른 컴포넌트에게 작업을 요청하는 인텐트를 사전에 생성시키고 만든다는 점과 <strong>특정 시점</strong>에 자신이 아닌 다른 컴포넌트들이 펜딩 인텐트를 사용하여 다른 컴포넌트에게 작업을 요청시키는데 사용된다는 점이 일반적인 인텐트와의 차이점이다.</p>
<p>수행시킬 작업 및 인텐트와 그것을 수행하는 주체를 지정하기 위한 정보를 명시할 수 있는 기능의 클래스라고 보면 된다.</p>
<p>쉬운 예제는 아래와 같다.</p>
<blockquote>
<p><code>A한테 이 B인텐트를 C 시점에 실행하라고 해. 지금은 실행하지 말고.</code></p>
</blockquote>
<p>이 클래스의 인스턴스는 getActivity (Context, int, Intent, int), getActivities (Context, int, Intent [], int), getBroadcast (Context, int, Intent, int) 및  getService(Context, int, Intent, int) 가 반환 하는 객체를 다른 응용 프로그램으로 전달 할 수 있으므로 앱 개발자가 명시하는 작업을 수행 할 수 있다.</p>
<p><code>Pending Intent</code>를 다른 응용 프로그램에 제공하면 다른 응용 프로그램이 자신과 동일한 권한과 ID로 지정된 것처럼 작업을 수행할 수 있는 권한이 부여된다. 따라서 Pending Intent를 작성하는 방법에 주의해야 한다. 예를 들어, 제공하는 기본적인 인텐트는 컴포넌트 이름이 자신이 가진 컴포넌트들 중 하나를 명시적으로 지정해야 하며, 궁극적으로 그곳으로 보내지는 것을 보장해야 한다.</p>
<h3 id="사용되는-몇가지-사례">사용되는 몇가지 사례</h3>
<ul>
<li>사용자가 Notification을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(NotificationManager가 인텐트를 실행)</li>
<li>사용자가 AppWidget을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(홈 스크린이 인텐트를 실행)</li>
<li>미래의 특정 시점에 실행되는 인텐트를 선언함(안드로이드의 AlarmManager가 인텐트를 실행)</li>
</ul>
<p>안드로이드 앱을 구현할 때, 인터넷으로부터 파일을 다운로드 하는 로직은 대부분 서비스에서 이루어지도록 구성한다.  그런데 서비스는 액티비티와 달리 화면에 나타나지 않는다. 따라서 서비스는 다운로드의 진행중이라는 사실 및 진행 정도를 화면 상단에 위치한 <strong>노티피케이션의 상태바</strong>(Status bar)를 통해서 표현한다. 다운로드가 현재 진행 중이라는 상황을 표시하는 아이콘 등으로 말이다. 그리고 다운로드가 완료된 후에는 아이콘으로 다운로드 완료의 상태를 보여주게 된다.</p>
<p>사용자가 상태바의 아이콘을 확인하고 안드로이드 화면의 상태바를 누르면서 나타나는 바를 잡아 아래로 끌어당기면 나타나는 화면을 <strong>노티피케이션 리스트</strong> 또는 확장 메시지라 한다. 그리고 만약 서비스가 이 Notification List에 다운로드 완료를 표시를 추가해놓았고, 사용자가 이것을 클릭하면 노티피케이션은 사전에 서비스에서 작성한 <code>펜딩 인텐트</code>를 사용하여 다운로드된 파일을 읽을 수 있는 앱을 호출하고 다운로드 완료된 파일을 호출된 앱에서 재생 혹은 보여주게 된다.</p>
<p>펜딩 인텐트는 안드로이드 App의 각각의 컴포넌트들이 펜딩 인텐트를 생성할 수 있도록 다음과 같은 메소드를 제공한다. 아래의 메소드를 통해 펜딩 인텐트를 사용하고자 하는 컴포넌트 유형을 지정해야 한다는 뜻이다.</p>
<ul>
<li>getActivity(Context, int, Intent, int)</li>
<li>getBroadcast(Context, int, Intent, int)</li>
<li>getService(Context, int, Intent, int)</li>
</ul>
<p>여기서 Context는 <code>현재 App의 Context</code>이다.</p>
<p><strong># Example</strong><br>
노래를 재생하는 중이고 이것이 상태바에 Notification으로 보여질 때 사용자가 이 Noti를 클릭하면 Notification은 이전에 전달받은 Pending Intent를 실행한다. Pending Intent가 <code>getActivity()</code>에 의해 생성된 것이며 감싸고 있는 intent 또한 특정 화면을 실행시키는 intent라면 이것이 그대로 실행되어 노래 화면이 뜨게 된다.</p>
<p>이때 주의할 점은 Activity는 새로운 테스크를 생성하여 그곳에 쌓이게 된다. 마치 Intent의 flag가 <code>NEW_TASK</code>로 설정된 것처럼 실행되기 때문에 유의해야 한다. 하나의 Activity만 생성되도록 보장하기 위해선 AndroidManifest 파일에  lanunchMode = “singleTop” 으로 설정해주어야 한다.</p>
<h2 id="안드로이드에서-task와-process의-차이점">안드로이드에서 Task와 Process의 차이점</h2>
<p>애플리케이션 컴포넌트가 처음 시작될 때 실행 중인 다른 컴포넌트가 없으면 안드로이드 시스템은 프로세스를 새로 생성시킨다. 기본적으로 애플리케이션의 컴포넌트들은 같은 프로세스의 기본 스레드에서 실행된다. 이후의 컴포넌트들이 시작할 때는 이미 생성된 프로세스 내에서 시작되며 컴포넌트별로 별도의 프로세스에서 실행되도록 할 수도 있고 어느 프로세스에서든 추가적인 스레드를 생성하여 작업할 수 있다.</p>
<p>Manifest 파일에서 <code>android:process</code> 특성을 설정함으로써 다른 프로세스에 해당 컴포넌트를 실행시킬 수 있다. 안드로이드 시스템에서 메모리가 부족할 경우 우선순위가 낮은 프로세스부터 종료시킨다. 우선순위는 <code>Foregorund, Visible, Service, Background, Cached</code> 프로세스 순이다.</p>
<p>눈에 보이는 프로세스는 <strong>Foreground와 Service</strong> 프로세스이며 Visible은 다이얼로그가 뜨는 경우 뒤에 액티비티가 가려지지만 사용자에게 보이는 경우에 해당한다.</p>
<p><strong>Service</strong>는 사용자가 볼 수는 없지만 프로세스에 필요한 작업은 진행하기에 그 다음 우선순위를 가지며 <strong>Background</strong>는 뒤로 밀려난 프로세스이기에 종료될 수 있다. 마지막 <strong>Cached</strong> 프로세스는 컴포넌트가 없는 빈 프로세스이지만 다음에 실행할 때 로드 시간을 절약하기 위해 캐시된 상태이다.</p>
<p><strong>Task</strong>는 각 애플리케이션마다 사용하는 Activity들을 Stack 구조로 저장 및 관리하는 컬렉션이다. 따라서 사용자가 화면의 전환 흐름을 자연스럽게 경험하도록 보장한다. 또한 Task는 다른 애플리케이션이나 프로세스에 속하는 Activity를 같은 Task에 저장시킴으로써 사용자로 하여금 하나의 애플리케이션에서 작동하는 듯한 경험을 하도록 한다. 단말기에서 사용중인 애플리케이션 리스트를 보는 것이 Task 단위로 보여지는 것이다. 하지만 실질적으로 Activity는 다른 프로세스 상에서 돌아가는 컴포넌트이며 프로세스간 통신을 통해 정보를 주고 받는 것이다.</p>
<h2 id="a-앱에서-b-앱의-액티비티를-부를-경우">A 앱에서 B 앱의 액티비티를 부를 경우</h2>
<p>Task에는 해당 애플리케이션에 속한 컴포넌트뿐만 아니라 다른 애플리케이션 컴포넌트도 쌓일 수 있다. 다른 애플리케이션의 컴포넌트를 실행하는 방법으로 <code>PackageManager</code>의 getLaunchIntentForPackage()가 있고 Intent에 <code>setComponent()</code>를 사용하는 방법이 있는데 전자의 경우 항상 새로운 Task를 생성하여 그곳에서 컴포넌트를 실행시키며 후자의 경우 현재의 Task에서 컴포넌트를 실행시키게 된다.</p>
<p>이 부분은 추후 공부를 더 해볼 예정.</p>
<h2 id="화면-렌더링-속도를-개선하는-방법">화면 렌더링 속도를 개선하는 방법</h2>
<p>기본적으로 View의 움직임이 어색하거나 스크롤이 버벅거리거나 렌더링이 느린 경우는 <strong>뷰를 그리는 속도가 16ms 보다 오래걸리는 현상</strong>이다. 초당 60 프레임의 속도로 화면을 그려주어야 사람의 시각에 어색함이 없이 보이는데 그리는 시간이 이보다 오래 걸릴 경우 버벅이는 문제가 발생할 수 있다. 따라서 렌더링이 느리다면 2가지를 의심해 봐야 한다.</p>
<ol>
<li>View Hierarchy가 너무 많은지 의심해 볼 것.</li>
</ol>
<p>View는 그려지기 전에 Measure, Layout, Draw의 3단계를 계층적으로 실행한다. 만약 계층이 매우 길고 복잡하다면 당연히 View가 그려지는 시간 또한 오래 걸릴 것이기 때문이다. 계층을 줄이려 <code>ConstraintLayout</code>과 <code>FlexboxLayout</code>를 적극 사용한다면 줄일 수 있을 것이다.</p>
<ol start="2">
<li>onDraw()에서 오버드로우 현상이 일어나는지 확인할 것.</li>
</ol>
<p><code>onDraw()</code> 함수 안에서 객체 생성을 하였는지, 오래 걸리는 작업을 실행하지 않는지 확인하여 문제가 되는 로직을 수정하거나 제거할 것이다.</p>
<p><strong># ConstrainLayout?</strong><br>
ConstrainLayout은 뷰의 상하좌우를 주변 또는 부모 뷰와 연관을 지어 위치시킬 수 있다. bias를 통해 비율적으로 배치시킬 수도 있고, chain을 사용하여 마치 그룹화한 것처럼 사용도 가능하다. 또한 ratio를 사용하여 너비와 높이를 비율대로 설정할 수도 있는 등 매우 유연한 배치가 가능하다. <code>ConstrainLayout</code>의 가장 큰 장점은 <strong>View Hierarchy</strong>를 <strong>수평적으로 평평하게</strong> 만든다. 최대 8 계층으로 구성되어 있는 RelativeLayout 구조를 하나의 계층으로 줄일 수 있는 효과를 볼 수 있다.</p>
<p><strong># FlexBoxLayout?</strong><br>
태그와 같은 항목이 하나의 뷰 안에 일렬로 즐비할 경우 한 줄이 가득 차면 다음 줄로 View를 정렬시키는 기능이 필요할 때 사용할 수 있는 Layout이다. <code>FlexBoxLayout</code>은 부모 레이아웃의 너비에 따라 자식 뷰를 여러 행에 걸쳐 <strong>동적</strong>으로 맞추는 기능을 제공한다. 기존에는 LinearLayout을 통해 구현 가능하긴 하지만 ScrollView와 같이 사용하면서 View의 너비를 일일이 계산하여 다음 행으로 배치시키는 코드를 직접 구현하는 방식으로 커스텀을 해야했다. <code>FlexBoxLayout</code>을 사용하면 이러한 작업을 자동으로 처리해주기에 잘못된 구현으로 인해 오버헤드가 발생하는 문제를 방지할 수 있다.</p>
<h2 id="thred간-통신-방법">Thred간 통신 방법</h2>
<p>Android의 UI를 담당하는 쓰레드는 메인 쓰레드(UI 쓰레드)인데, 오랜 시간이 걸리는 작업을 메인 쓰레드에서 수행할 경우 앱의 성능이 저하된다. 따라서 여분의 쓰레드를 사용하여 작업을 수행해야 하고, 이 결과를 반영하기 위해 메인 쓰레드와의 통신이 필요하게 된다. 그래서 메인 쓰레드에 접근하는 방법은 <strong>Looper</strong>와 <strong>Handler</strong>를 이용하면 된다. <strong>그리고 UI 작업을 메인 쓰레드에서만 담당하는 이유는 두 개 이상의 쓰레드를 사용할 때의 동기화 이슈를 차단하기 위함이다.</strong></p>
<p><strong>Android는 Java의 쓰레드를 좀 더 쉽게 사용할 수 있도록 래핑한 HandlerThread, AsyncTask를 제공한다.</strong></p>
<p><strong>1. Looper</strong><br>
메인 쓰레드는 내부적으로 <strong>Looper</strong>를 가지며 그 안에는 Message Queue가 포함된다. <code>Message Queue</code>는 쓰레드가 다른 쓰레드나 혹은 자기 자신으로부터 전달받은 Message를 보관하는 Queue(FIFO)이다. Looper는 무한 루프를 돌며 자신이 속한 쓰레드의 Message Queue에서 Message 객체를 차례로 꺼내서 Handler가 처리하도록 전달한다.</p>
<p>메인 쓰레드는 기본적으로 Looper가 생성되어 있으나, 새로 생성한 쓰레드는 새로운 Looper를 생성해주어야 한다. Android는 Looper가 기본적으로 생성되어 있는 HandlerThred를 제공한다.</p>
<ul>
<li><strong>Message Queue에 저장되는 객체</strong>
<ul>
<li>문자와 필드로 구성된 Message 객체</li>
<li>Runnable 객체</li>
</ul>
</li>
</ul>
<p><strong>2. Handler</strong><br>
Looper로부터 받은 Message를 실행, 처리하거나 다른 쓰레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 쓰레드 간의 통신 장치이다. <strong>일반적으로 UI 갱신을 위해 사용된다.</strong> (뷰나 뷰 그룹에서 제공하는 메소드는 단일 스레드 모델(Thread-Unsafe)</p>
<h2 id="anr">ANR</h2>
<p><code>ANR</code>은 Android Not Responding의 약자로 오랜 시간이 걸리는 작업을 메인 쓰레드에서 담당하면 앱의 반응성이 낮아질 수 있고, 사용자의 불편함을 방지하고자 시스템이 <strong>ANR</strong> 상태로 전환시킬 수 있다. 따라서 시간이 걸리는 작업은 여분의 쓰레드를 사용해야 하고, 이 작업 결과를 반영하기 위해 메인 쓰레드와 통신하는 방법이 필요하다.</p>
<p><strong># ANR상태 예시</strong><br>
-&gt; input 이벤트에 5초 안에 반응하지 않을 경우(Activity)<br>
-&gt; BroadcastRecevier가 10초 이내로 실행하지 않을 경우(UI가 없는 브로드캐스트 리시버와 서비스도 실행 주체가 메인 쓰레드이기 때문에)</p>
<p><strong># ANR대처 방법</strong><br>
-&gt; 시간이 걸리는 긴 작업은 쓰레드로 처리<br>
-&gt; Progress bar로 진행 상황을 보여주어 사용자를 기다리게 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/17/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%913/" target="_blank" rel="noopener">안드로이드 면접 3</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/06/Android-What-is-DeepLink/"
                            aria-label=": [안드로이드] 딥링크"
                        >
                            [안드로이드] 딥링크
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-06T18:40:16+09:00">
	
		    Jan 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="applink-deeplink">Applink? Deeplink??</h2>
<ol>
<li>DeepLink</li>
</ol>
<p><strong>딥링크</strong>는 인텐트 필터의 일종으로 사용자들이 직접적으로 안드로이드 앱 내의 액티비티에 접근하는 것을 허용한다. 다른 앱에서 또는 웹브라우저에서의 링크를 클릭했을 때 해당 링크의 scheme을 보고 앱을 실행하게 되며, 해당 링크를 처리하는 2개 이상의 앱이 있다면 사용자에게 다이얼로그를 띄워 앱을 실행할 수 있도록 유도한다.</p>
<ol start="2">
<li>AppLink</li>
</ol>
<p><strong>앱링크</strong>는 인증된 웹 사이트 URL을 기반으로 하는 딥링크이다. 링크 클릭시 앱이 설치되어 있다면 즉시 열어서 보여주고 없다면 웹으로 이동한다. 다이얼로그는 나타나지 않는다.</p>
<img src="/img/android_deeplink_applink_diff.png" width="400" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=922" target="_blank" rel="noopener">딥링크와 앱링크의 차이점</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/06/Android-What-is-DeepLink/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/13/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/15/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 14 of 28</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
