
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2018 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2018/archives/6/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/18/BOJ2346/"
                            aria-label=": [2346] 풍선 터뜨리기 "
                        >
                            [2346] 풍선 터뜨리기 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-18T22:41:18+09:00">
	
		    Sep 18, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/2346" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2346</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<hr>
<p>예전에 한 번 풀어본 문제이지만, 인간의 기억력은 역시나… 오래 지속되지 않는다는 걸 알면서도 똑같은 실수를 반복했습니다…ㅜ 그래서 저는 다시 풀어보았습니다. 다행스럽게도 풀어본 경험이 있어서인지 문제를 보고 어떻게 접근해야 하는지 생각할 수 있었습니다.</p>
<ol>
<li>
<p><strong>Class 만들기</strong><br>
풍선의 순서와 풍선에 적혀있는 값을 가지고 있는 Class를 만들어서 사용하면 됩니다.</p>
</li>
<li>
<p><strong>List 사용</strong><br>
이 문제를 풀기 위해서 위에서 만든 Class를 타입으로 갖는 객체 배열을 사용할지 리스트를 사용할지 생각했습니다. 이 문제에서는 풍선을 터뜨릴 경우 삭제를 해줘야 하기 때문에 추가 및 삭제가 일어나도 빈 공간을 처리하지 않아도 되는 즉, 빈 공간이 자동으로 채워지는 <strong>List</strong>를 사용하였습니다.</p>
</li>
<li>
<p><strong>터뜨릴 순서?</strong><br>
풍선을 터뜨릴 순서를 결정하기 위해서는 풍선에 적혀있는 값을 가지고 결정해야 합니다. 풍선에 적혀있는 값이 양수이면 오른쪽으로 돌고, 음수이면 왼쪽으로 돌아서 풍선을 터뜨리면 됩니다. 문제에서 풍선은 원형처럼 1번의 왼쪽에는 N번 풍선이, N번의 오른쪽에는 1번 풍선이 있다고 하였으므로 참고해서 돌고 터뜨리면 됩니다.</p>
</li>
</ol>
<p><strong>주의할 점은 처음에 터뜨릴 풍선은 1번 풍선인데, 이 풍선을 터뜨리고 나면 1번 풍선이 사라지면서 2번째 풍선이 1번 풍선의 인덱스를 가지게 됩니다. 그러므로 첫번째 풍선을 이미 터뜨리고 나서 풍선에 적힌 값에 따라서 다음에 터뜨릴 풍선을 결정할 때, 풍선에 적혀있는 값이 양수라면 (그 값 - 1) 만큼만 계산하면 됩니다. 왜냐하면 리스트에서 풍선이 삭제됨에 따라서 이미 한칸을 이동했기 때문입니다. (쉽게 말하면 풍선이 하나 터지면서 다른 풍선의 인덱스들이 터진 풍선 이후 부터 즉, 오른쪽부터 0부터 재할당되기 때문입니다.)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ2346</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine()); <span class="comment">// 테스트 케이스</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Ballons&gt; ballons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st.nextToken());</span><br><span class="line">            ballons.add(<span class="keyword">new</span> Ballons(i+<span class="number">1</span>, value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = process(ballons, test_case);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">process</span><span class="params">(ArrayList&lt;Ballons&gt; ballon_list, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> kill=<span class="number">0</span>; <span class="comment">// 터뜨릴 풍선의 인덱스</span></span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>; <span class="comment">// 터뜨릴 풍선의 값</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="comment">// value 즉, 풍선에 적혀있는 값이 양수인지 음수인지에 따라</span></span><br><span class="line">            <span class="comment">// 오른쪽 혹은 왼쪽으로 이동하기 위해 검사</span></span><br><span class="line">            <span class="keyword">if</span>(value&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;value-<span class="number">1</span>;k++)&#123;</span><br><span class="line">                    ++kill;</span><br><span class="line">                    <span class="keyword">if</span>(kill&gt;=ballon_list.size())&#123;</span><br><span class="line">                        kill=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                value = Math.abs(value); <span class="comment">// 절대값 변환</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;value;j++)&#123;</span><br><span class="line">                    --kill;</span><br><span class="line">                    <span class="keyword">if</span> (kill&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        kill = ballon_list.size()-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*FIXME</span></span><br><span class="line"><span class="comment">            * 처음에는 0번째 즉, 첫 번째 풍선을 터뜨려야 하기 때문에</span></span><br><span class="line"><span class="comment">            * 이렇게 터뜨릴 풍선을 정하고</span></span><br><span class="line"><span class="comment">            * 그 풍선의 값(value)[즉, 적혀있는 값!]를 알아낸다.</span></span><br><span class="line"><span class="comment">            * 왜냐하면, 다음 풍선을 터뜨리기 위해 얼만큼 이동할지 알기 위해서</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            Ballons ballon = ballon_list.get(kill);</span><br><span class="line">            System.out.println(<span class="string">"삭제가 될 풍선 : "</span>+ballon.valueNumber+<span class="string">", "</span>+(ballon.orderNumber)+<span class="string">", "</span>+kill);</span><br><span class="line">            value = ballon.valueNumber;</span><br><span class="line"></span><br><span class="line">            sb.append(ballon.orderNumber+<span class="string">" "</span>);</span><br><span class="line">            ballon_list.remove(kill);</span><br><span class="line">            <span class="keyword">if</span>(kill == ballon_list.size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"몇번?"</span>);</span><br><span class="line">                kill = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballons</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> orderNumber; <span class="comment">// 풍선의 순서</span></span><br><span class="line">    <span class="keyword">int</span> valueNumber; <span class="comment">// 풍선 안에 적힌 값</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ballons</span><span class="params">(<span class="keyword">int</span> orderNumber, <span class="keyword">int</span> valueNumber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderNumber = orderNumber;</span><br><span class="line">        <span class="keyword">this</span>.valueNumber = valueNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/18/BOJ2346/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/05/java-basic-19/"
                            aria-label=": [Java] 19. java.time"
                        >
                            [Java] 19. java.time
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-05T20:36:36+09:00">
	
		    Sep 05, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="자바에서의-날짜-및-시간-처리">자바에서의 날짜 및 시간 처리</h1>
<hr>
<p>JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 처리를 수행했습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(<code>deprecated</code>)있습니다.</p>
<p>JDK 1.1부터 새롭게 제공된 Calendar 클래스는 날짜와 시간에 대한 정보를 손쉽게 얻을 수 있었습니다. 하지만 Calendar 클래스는 다음과 같은 <strong>문제점</strong>을 가지고 있습니다.</p>
<ol>
<li>Calendar 인스턴스는 불변 객체(immutable object)가 아니라서 값이 수정될 수 있습니다.</li>
<li>윤초(leap second)와 같은 특별한 상황을 고려하지 않습니다.</li>
<li>Calendar 클래스에서는 월(month)을 나타낼 때 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.</li>
</ol>
<p>따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러리를 함께 사용해 왔습니다.</p>
<p>버전에서는 이러한 Joda-Time 라이브러리를 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 하위 패키지를 포함하고 있습니다.</p>
<h2 id="javatime-패키지">java.time 패키지</h2>
<p>Java SE 8부터 제공되는 <code>java.time 패키지</code>에는 자바에서 날짜와 시간을 다루는 데 사용되는 필수 클래스들이 포함되어 있습니다. 또한, 다음과 같은 다양한 기능을 하는 하위 패키지를 포함하고 있습니다.</p>
<ol>
<li>java.time.chrono : ISO-8601에 정의된 표준 달력 이외의 달력 시스템을 사용할 때 필요한 클래스들</li>
<li>java.time.format : 날짜와 시간에 대한 데이터를 구문 분석하고 형식화하는데 사용되는 클래스들</li>
<li>java.time.temporal : 날짜와 시간에 대한 데이터를 연산하는 데 사용되는 보조 클래스들</li>
<li>java.time.zone : 타임 존(time-zone)과 관련된 클래스들</li>
</ol>
<p><strong>java.time 패키지는 기존에 사용되는 Calendar 클래스의 단점을 보완하였습니다. 따라서 해당 패키지에 속하는 모든 클래스의 인스턴스는 불변 객체(immutable object)로 생성됩니다. 따라서, 값을 수정할 수 없습니다.<br>
즉, java.time 패키지에 포함되는 클래스의 메소드들은 모두 새로운 객체를 생성하여 반환하고 있습니다.</strong></p>
<h2 id="javatime-패키지의-구성-클래스">java.time 패키지의 구성 클래스</h2>
<p>기존의 Calendar 클래스는 날짜와 시간을 한 번에 표현했지만, java.time 패키지에서는 별도로 구분하여 처리합니다. LocalData 클래스는 날짜를 표현할 때 사용하며, LocalTime 클래스는 시간을 표현할 때 사용합니다.<br>
또한, 기존의 Caledar 클래스처럼 날짜와 시간을 한 번에 표현하고 싶을 때는 LocalDateTime 클래스를 사용합니다.</p>
<p>ZonedDateTime 클래스는 특정 타임 존(time-zone)에 해당하는 날짜와 시간을 다루는 데 사용합니다. 또한, 기존의 Date 클래스와 비슷한 용도로 사용되는 Instant 클래스가 있습니다. Instant 클래스는 특정 시점의 날짜와 시간을 나노초(nanosecond) 단위로 표현하는 타임스탬프(time-stamp)를 다루는 데 사용됩니다.</p>
<p>Period 클래스(단어가 의미하듯이 '기간’이라는 뜻을 가지고 있음)는 두 날짜 사이의 차이를 표현하는 데 사용되며, Duration 클래스는 두 시각 사이의 차이를 표현하는 데 사용됩니다.</p>
<h1 id="localdate와-localtime">LocalDate와 LocalTime</h1>
<hr>
<p>LocalData 클래스는 날짜를 표현하는 데 사용되며, LocalTime 클래스는 시간을 표현하는 데 사용됩니다. java.time 패키지에 포함된 대부분의 클래스들은 이 두 클래스를 확장한 것이 많으므로, 우선 이 두 클래스를 먼저 이해하고 알고 있어야 합니다. :)</p>
<h2 id="날짜와-시간-객체의-생성">날짜와 시간 객체의 생성</h2>
<p>LocalData와 LocalTime 클래스는 객체를 생성하기 위해 now()와 of() 메소드라는 클래스 메소드를 제공합니다.</p>
<p>now() 메소드는 현재 날짜와 시간을 이용하여 새로운 객체를 생성하여 반환합니다. 하지만 of() 메소드는 전달된 인수를 가지고 특정 날짜와 시간을 표현하는 새로운 객체를 생성하여 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now(); <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(today+<span class="string">" 와 "</span>+present);</span><br><span class="line"></span><br><span class="line">        LocalDate birthday = LocalDate.of(<span class="number">1994</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        LocalTime birthTime = LocalTime.of(<span class="number">02</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">11</span>);</span><br><span class="line">        System.out.println(birthday+<span class="string">", "</span>+birthTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">05</span> 와 <span class="number">21</span>:<span class="number">22</span>:<span class="number">06.640</span></span><br><span class="line"><span class="number">1994</span>-<span class="number">06</span>-<span class="number">27</span>, <span class="number">02</span>:<span class="number">00</span>:<span class="number">00.000000011</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>of() 메소드는 위의 예제에서 사용된 메소드 시그니처 이외에도 다양한 형태로 오버로딩되어 제공됩니다.</p>
</blockquote>
<h2 id="날짜와-시간-객체에-접근하기">날짜와 시간 객체에 접근하기</h2>
<p>LocalDate와 LocalTime 클래스는 특정 필드의 값을 가져오기 위해서 다음과 같이 다양한 getter 메소드를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 날짜 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getYear()</td>
<td style="text-align:center">해당 날짜 객체의 연도(YEAR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">Month getMonth()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 Month 열거체를 이용하여 반환함.(즉, SEPTEMBER과 같은 형식으로 반환)</td>
</tr>
<tr>
<td style="text-align:center">int getMonthValue()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 반환함. (숫자로 1~12까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfMonth()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_MONTH) 필드의 값을 반환함. (숫자로 1~31까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfYear()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_YEAR) 필드의 값을 반환함. (숫자로 1~365까지를 반환함.[윤년이면 366])</td>
</tr>
<tr>
<td style="text-align:center">DayOfWeek getDayOfWeek()</td>
<td style="text-align:center">해당 날짜 객체의 요일(DAY_OF_WEEK) 필드의 값을 DayOfWeek 열거체를 이용하여 반환함.</td>
</tr>
</tbody>
</table>
<p>기존의 Calendar 클래스에서는 1월을 0으로 표현하여 월의 범위가 0~11이었으며, 요일은 일요일부터 1로 표현했습니다.<br>
하지만 java.time 패키지에서 1월을 1로 표현하여 월의 범위가 1~12가 되었으며, 요일은 월요일부터 1로 표현하도록 변경되었습니다.</p>
<blockquote>
<p>Calendar 클래스와 java.time 패키지의 클래스를 같이 사용할 때에는 특히 위와 같은 차이점에 주의해야 합니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"이번달은 "</span>+today.getMonthValue()+<span class="string">"월입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은"</span>+today.getDayOfWeek()+<span class="string">"입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은 1년 중 "</span>+today.get(ChronoField.DAY_OF_YEAR)+<span class="string">"일째 날입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">이번달은 <span class="number">9</span>월입니다.</span><br><span class="line">오늘은WEDNESDAY입니다.</span><br><span class="line">오늘은 <span class="number">1</span>년 중 <span class="number">248</span>일째 날입니다.</span><br></pre></td></tr></table></figure>
<p>LocalTime 클래스에서 제공하는 대표적인 getter 메소드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 시간 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getHour()</td>
<td style="text-align:center">해당 시간 객체의 시(HOUR_OF_DAY) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getMinute()</td>
<td style="text-align:center">해당 시간 객체의 분(MINUTE_OF_HOUR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getSecond()</td>
<td style="text-align:center">해당 시간 객체의 초(SECOND_OF_MINUTE) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getNano()</td>
<td style="text-align:center">해당 시간 객체의 나노초(NANO_OF_SECOND) 필드의 값을 반환함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.getHour() + <span class="string">"시 "</span> + present.getMinute() + <span class="string">"분입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">0</span>시 <span class="number">18</span>분입니다.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LocalDate와 LocalTime 클래스는 모두 현재 시간을 기준으로 하기 때문에 이 글을 보고 참고하시는 분들은 저와 다른 결과를 볼 수 있습니다. 다른 것이 당연한 것이니 당황해 하지 마시길…ㅎㅎ</p>
</blockquote>
<h2 id="temporalfield-인터페이스">TemporalField 인터페이스</h2>
<p>TemporalField 인터페이스는 월(month-of-year)과 시(hour-of-day)와 같이 날짜와 시간과 관련된 필드를 정의해 놓은 인터페이스입니다. 이 인터페이스를 구현하여 날짜와 시간을 나타낼 때 사용하는 열거체가 바로 ChronoField입니다.<br>
java.time 패키지를 구성하는 클래스의 메소드에서는 이 열거체를 이용하여 날짜와 시간을 처리하고 있스빈다.</p>
<p>ChronoField 열거체에 정의된 대표적인 열거체 상수는 다음 표와 같습니다.</p>
<img src="/img/chronoField.png" width="700" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.of(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        String ampm;</span><br><span class="line"></span><br><span class="line">        System.out.println(present.get(ChronoField.AMPM_OF_DAY));</span><br><span class="line">        <span class="comment">// 0 : 오전, 1 : 오후</span></span><br><span class="line">        <span class="keyword">if</span> (present.get(ChronoField.AMPM_OF_DAY) == <span class="number">0</span>) &#123;</span><br><span class="line">            ampm = <span class="string">"오전"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ampm = <span class="string">"오후"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"지금은 "</span> + ampm + <span class="string">" "</span> + present.get(ChronoField.HOUR_OF_AMPM) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">지금은 오후 <span class="number">1</span>시입니다.</span><br></pre></td></tr></table></figure>
<p>위의 결과에서 보듯이 'present.get(ChronoField.AMPM_OF_DAY)'는 오전은 0을 오후는 1을 반환하고 있습니다.</p>
<h2 id="날짜와-시간-객체의-필드값-변경">날짜와 시간 객체의 필드값 변경</h2>
<p>LocalDate와 LocalTime 클래스는 날짜와 시간 객체에 접근하여 특정 필드의 값을 변경하기 위해서 <code>with()</code> 메소드를 사용합니다. with() 메소드를 사용하면 값이 변경될 필드를 사용자가 직접 명시할 수 있습니다.<br>
또한, 특정 필드의 값을 변경하기 위해 미리 정의되어 제공되는 다양한 with() 메소드를 사용할 수도 있습니다.</p>
<p><strong>LocalDate 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localdate.png" width="700" height="300"></p>
<p><strong>LocalTime 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localtime.png" width="700" height="300"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalDate otherDay = today.withYear(<span class="number">1994</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+otherDay.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+present.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.withHour(<span class="number">16</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+otherTime.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">올해는 <span class="number">1994</span>년입니다.</span><br><span class="line"></span><br><span class="line">현재 시각은 <span class="number">0</span>시 입니다.</span><br><span class="line">현재 시각은 <span class="number">16</span>시 입니다.</span><br></pre></td></tr></table></figure>
<p>with() 메소드 이외에도 특정 필드의 값을 더하거나 뺄 수 있는 다양한 plus()와 minus() 메소드도 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.get(ChronoField.HOUR_OF_DAY) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + otherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime anotherTime = present.minus(<span class="number">6</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + anotherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">1</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">3</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">19</span>시입니다.</span><br></pre></td></tr></table></figure>
<h2 id="날짜와-시간-객체의-비교">날짜와 시간 객체의 비교</h2>
<p>LocalDate와 LocalTime 클래스에도 객체를 비교할 수 있는 compareTo() 메소드가 오버라이딩 되어 있습니다. 하지만 더욱 편리하게 날짜와 시간 객체를 서로 비교할 수 있도록 다음과 같은 메소드를 제공합니다.</p>
<ol>
<li>isEqual() 메소드 : equals() 메소드와는 달리 <strong>오직 날짜만을 비교함.</strong>(LocalDate 클래스에서만 제공)</li>
<li>isBefore() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 앞선 시간인지를 비교함.</li>
<li>isAfter() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 늦은 시간인지를 비교함.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        LocalDate otherDay = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line">        LocalDate otherDay2 = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(today.compareTo(otherDay));</span><br><span class="line">        <span class="comment">// today와 otherDay의 year 간의 차이를 반환</span></span><br><span class="line">        System.out.println(today.isBefore(otherDay));</span><br><span class="line">        System.out.println(today.isAfter(otherDay));</span><br><span class="line">        System.out.println(today.isEqual(otherDay));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(otherDay.isEqual(otherDay2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/05/java-basic-19/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/04/java-basic-18/"
                            aria-label=": [Java] 18. 스트림API"
                        >
                            [Java] 18. 스트림API
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-04T12:06:54+09:00">
	
		    Sep 04, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림api">스트림API</h1>
<hr>
<p>Java SE 8부터 추가된 스트림 API는 앞서 입력과 출력 수업에서 살펴본 스트림과는 전혀 다른 개념입니다. 자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용하는데, 이렇게 저장된 데이터에 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 새로운 코드를 작성해야 합니다.</p>
<p>하지만 이렇게 작성된 코드는 길이가 너무 길고 가독성도 떨어지며, 코드의 재사용이 거의 불가능합니다. 즉, 데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했습니다.</p>
<p><strong>이러한 문제점을 극복하기 위해서 Java SE 8부터 스트림(stream) API를 도입합니다. 스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다. 따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 됩니다.</strong></p>
<h2 id="스트림-api의-특징">스트림 API의 특징</h2>
<ol>
<li>스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복(internal iteration)을 통해 작업을 수행합니다.</li>
<li>스트림은 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있습니다.</li>
<li>스트림은 원본 데이터를 변경하지 않습니다.</li>
<li>스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화합니다.</li>
<li>스트림은 parallelStream() 메소드를 통한 손쉬운 병렬 처리를 지원합니다.</li>
</ol>
<h2 id="스트림-api의-동작-흐름">스트림 API의 동작 흐름</h2>
<p>스트림 APi는 다음과 같이 세 가지 단계에 걸쳐서 동작합니다.</p>
<ol>
<li>스트림의 생성</li>
<li>스트림의 중개 연산(스트림의 변환)</li>
<li>스트림의 최종 연산(스트림의 사용)</li>
</ol>
<img src="/img/stream2.png" width="800" height="300">
<h1 id="스트림의-생성">스트림의 생성</h1>
<hr>
<p>스트림 API는 다음과 같은 다양한 데이터 소스에서 생성해서 사용할 수 있습니다.</p>
<ol>
<li>컬렉션</li>
<li>배열</li>
<li>가변 매개변수</li>
<li>지정된 범위의 연속된 정수</li>
<li>특정 타입의 난수들</li>
<li>람다 표현식</li>
<li>파일</li>
<li>빈 스트림</li>
</ol>
<h2 id="컬렉션">컬렉션</h2>
<p>자바에서 제공하는 모든 컬렉션의 최고 상위 조상인 Collection 인터페이스에는 stream() 메소드가 정의되어 있습니다. 따라서 Collection 인터페이스를 구현한 모든 List와 Set 컬렉션 클래스에서도 stream() 메소드로 스트림을 생성할 수 있습니다. 또한, parallelStream() 메소드를 사용하면 병렬 처리가 가능한 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// stream.forEach(System.out::println); 한 번 더 호출하면 에러가 발생</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Stream 클래스의 forEach() 메소드는 해당 스트림의 요소를 하나씩 소모해가며 순차적으로 요소에 접근하는 메소드입니다. 따라서 같은 스트림으로는 forEach() 메소드를 한 번밖에 호출할 수 없습니다. 단, 원본 데이터의 요소를 소모하는 것은 아니므로, 같은 데이터에서 또 다른 스트림을 생성하여 forEach() 메소드를 호출하는 것은 가능합니다.</p>
<h2 id="배열">배열</h2>
<p>배열에 관한 스트림을 생성하기 위해 Arrays 클래스에는 다양한 형태의 stream() 메소드가 클래스 메소드로 정의되어 있습니다. 또한, 기본 타입인 int, long, double 형을 저장할 수 있는 배열에 관한 스트림이 별도로 정의되어 있습니다.<br>
이러한 스트림은 java.util.stream 패키지의 IntStream, LongStream, DoubleStream 인터페이스로 각각 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열에서 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(arr);</span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열의 특정 부분만을 이용한 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">둘 셋</span><br></pre></td></tr></table></figure>
<p>Arryas 클래스의 stream() 메소드는 전체 배열뿐만 아니라 배열의 특정 부분만을 이용하여 스트림을 생성할 수도 있습니다.</p>
<h2 id="가변-매개변수">가변 매개변수</h2>
<p>Stream 클래스의 <code>of()</code> 메소드를 사용하면 가변 매개변수를 전달받아 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Double&gt; stream = Stream.of(<span class="number">4.2</span>, <span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4.2</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">1.9</span></span><br></pre></td></tr></table></figure>
<h2 id="지정된-범위의-연속된-정수">지정된 범위의 연속된 정수</h2>
<p>지정된 범위의 연속된 정수를 스트림으로 생성하기 위해 IntStream이나 LongStream 인터페이스에는 range()와 rangeClosed() 메소드가 정의되어 있습니다.</p>
<ul>
<li>range() : 명시된 시작 정수를 포함하지만, 명시된 마지막 정수는 포함하지 않는 스트림을 생성합니다.</li>
<li>rangeClosed() : 명시된 시작 정수뿐만 아니라 명시된 마지막 정수까지도 포함하는 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="특정-타입의-난수들">특정 타입의 난수들</h2>
<p>특정 타입의 난수로 이루어진 스트림을 생성하기 위해 Random 클래스에는 ints(), longs(), doubles()와 같은 메소드가 정의되어 있습니다.</p>
<p>이 메소드들은 매개변수로 스트림의 크기를 long 타입으로 전달받을 수 있습니다. 이 메소드들은 만약 매개 변수를 전달받지 않으면 크기가 정해지지 않은 무한 스트림을 반환합니다. 이때에는 limit() 메소드를 사용하여 따로 스트림의 크기를 제한해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream = <span class="keyword">new</span> Random().ints().limit(<span class="number">10</span>);</span><br><span class="line">        intStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">-<span class="number">306452731</span></span><br><span class="line"><span class="number">1589863803</span></span><br><span class="line">-<span class="number">2033593764</span></span><br><span class="line">-<span class="number">686440616</span></span><br><span class="line">-<span class="number">938628166</span></span><br><span class="line"><span class="number">2106259183</span></span><br><span class="line"><span class="number">700874167</span></span><br><span class="line">-<span class="number">1006255911</span></span><br><span class="line">-<span class="number">181498589</span></span><br><span class="line"><span class="number">1937399570</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 처음에 ints() 메소드에 크기를 지정해주지 않아서 무한 스트림을 반환하지만, 뒤에 limit() 메소드를 이용하여 크기를 10으로 제한했습니다.</p>
<h2 id="람다-표현식">람다 표현식</h2>
<p>람다 표현식을 매개변수로 전달받아 해당 람다 표현식에 의해 반환되는 값을 요소로 하는 무한 스트림을 생성하기 위해 Stream 클래스에는 iterate()와 generate() 메소드가 정의되어 있습니다.</p>
<ul>
<li>iterate() : 시드(seed)로 명시된 값을 람다 표현식에 사용하여 반환된 값을 다시 시드로 사용하는 방식으로 무한 스트림을 생성합니다.</li>
<li>generate() : 매개변수가 없는 람다 표현식을 사용하여 반환된 값으로 무한 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = Stream.iterate(<span class="number">2</span>, n-&gt;n+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2,4,6,8,10, ...</span></span><br></pre></td></tr></table></figure>
<h2 id="파일">파일</h2>
<p>파일의 한 행(line)을 요소로 하는 스트림을 생성하기 위해 java.nio.file.Files 클래스에는 lines() 메소드가 정의되어 있습니다. 또한, java.io.BufferedReader 클래스의 lines() 메소드를 사용하면 파일뿐만 아니라 다른 입력으로부터도 데이터를 행(line) 단위로 읽어 올 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String&lt;String&gt; stream = File.lines(Path path);</span><br></pre></td></tr></table></figure>
<h2 id="빈-스트림">빈 스트림</h2>
<p>아무 요소도 가지지 않는 빈 스트림은 Stream 클래스의 empty() 메소드를 사용하여 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 스트림 생성</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Object&gt; stream = Stream.empty();</span><br><span class="line">        System.out.println(stream.count());</span><br><span class="line">        <span class="comment">// 스트림의 요소의 총 개수를 출력</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="스트림의-중개-연산">스트림의 중개 연산</h1>
<hr>
<p><strong>스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됩니다. 이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있습니다.</strong><br>
또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 지연(lazy) 연산을 통해 성능을 최적화할 수 있습니다.</p>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림 필터링 : filter(), distinct()</li>
<li>스트림 변환 : map(), flatMap()</li>
<li>스트림 제한 : limit(), skip()</li>
<li>스트림 정렬 : sorted()</li>
<li>스트림 연산 결과 확인 : peek()</li>
</ol>
<h2 id="스트림-필터링">스트림 필터링</h2>
<p><code>filter()</code> 메소드는 해당 스트림에서 주어진 조건(predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환합니다.<br>
또한, <code>distinct()</code> 메소드는 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환합니다. distinct() 메소드는 내부적으로 Object 클래스의 equals() 메소드를 사용하여 요소의 중복을 비교합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream1 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream intStream2 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 스트림에서 중복된 요소 제거</span></span><br><span class="line">        intStream1.distinct().forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 스트림에서 홀수만 골라냄</span></span><br><span class="line">        intStream2.filter(k-&gt;k%<span class="number">2</span> != <span class="number">0</span>).forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-변환">스트림 변환</h2>
<p><code>map()</code> 메소드는 해당 스트림의 요소들을 주어진 함수에 인수로 전달하여, 그 반환값들로 이루어진 새로운 스트림을 반환합니다. 만약 해당 스트림의 요소가 배열이라면, <code>flatMap()</code> 메소드를 사용하여 각 배열의 각 요소의 반환값을 하나로 합친 새로운 스트림을 얻을 수 있습니다.</p>
<p>다음 코드는 문자열로 이루어진 스트림을 map() 메소드를 이용하여 각 문자열의 길이로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"JAVASCRIPT"</span>);</span><br><span class="line">        stringStream.map(e-&gt;e.length()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>다음은 여러 문자열이 저장된 배열을 각 문자열에 포함된 단어로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"I study hard"</span>, <span class="string">"You study JAVA"</span>, <span class="string">"I am hungry"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream.flatMap(s-&gt;Stream.of(s.split(<span class="string">" "</span>))).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">I</span><br><span class="line">study</span><br><span class="line">hard</span><br><span class="line">You</span><br><span class="line">study</span><br><span class="line">JAVA</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">hungry</span><br></pre></td></tr></table></figure>
<h2 id="스트림-제한">스트림 제한</h2>
<p><code>limit()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소만으로 이루어진 새로운 스트림을 반환합니다.<br>
<code>skip()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소를 제외한 나머지 요소만으로 이루어진 새로운 스트림을 반환합니다.</p>
<blockquote>
<p>그리고 두 메소드의 들어가는 매개변수의 인덱스는 포함하지 않고 바로 직전 인덱스까지만 해당됩니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream3 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 4개의 요소를 제외 : 0,1,2,3 제외한 나머지 요소 출력</span></span><br><span class="line">        stream1.skip(<span class="number">4</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 5개의 요소 출력 : 0,1,2,3,4</span></span><br><span class="line">        stream2.limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stream3.skip(<span class="number">3</span>).limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-정렬">스트림 정렬</h2>
<p><code>sorted()</code> 메소드는 해당 스트림을 주어진 비교자(comparator)를 이용하여 정렬합니다. 이때 비교자를 전달하지 않으면 기본적으로 사전 편찬 순(natural order)으로 정렬하게 되고, 비교자를 전달하면 사전 편찬 순의 역순으로 정렬하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        stream1.sorted().forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        stream2.sorted(Comparator.reverseOrder()).forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">CSS HTML JAVA JAVASCRIPT </span><br><span class="line">JAVASCRIPT JAVA HTML CSS</span><br></pre></td></tr></table></figure>
<h2 id="스트림-연산-결과-확인">스트림 연산 결과 확인</h2>
<p><code>peek()</code> 메소드는 결과 스트림으로부터 요소를 소모하여 추가로 명시된 동작을 수행합니다. 이 메소드는 원본 스트림에서 요소를 소모하지 않으므로, 주로 연산과 연산 사이에 결과를 확인하고 싶을 때 사용합니다. 따라서 개발자가 디버깅 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        stream.peek(s -&gt; System.out.println(<span class="string">"원본 스트림 : "</span> + s))</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"skip(2) 실행 후 : "</span> + s))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"limit(5) 실행 후 : "</span> + s))</span><br><span class="line">                .sorted()</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"sorted() 실행 후 : "</span> + s))</span><br><span class="line">                .forEach(n -&gt; System.out.println(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 스트림 : <span class="number">7</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">1</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">3</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>위의 코드는 다음과 같은 결과를 보여줍니다. 현재 지금 저는 스트림 API에 대한 개념이 적은 상태입니다. 그리고 위의 peek()이라는 메소드의 동작 상태가 이해가 가지 않네요… 이렇게 정리해놓고 나중에 다시 공부할 때 조금 더 찾아보게 된다면 아마 이해가 가지 않을까요?ㅎㅎ</p>
</blockquote>
<p>위의 예제에서 첫 번째 요소인 7과 두 번째 요소인 5는 skip() 메소드에 의해 삭제되므로, 원본 스트림에서만 나타납니다. 하지만 세 번째 요소인 5는 skip() 메소드와 limit() 메소드가 실행된 후에도 존재하므로, 모두 나타납니다. 이렇게 peek() 메소드는 스트림의 각 요소가 해당 중개 연산 후에 어떻게 변화하는지를 보여줍니다.</p>
<h2 id="대표적인-중개-연산-메소드">대표적인 중개 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_method.png" width="800" height="300">
<h1 id="스트림의-최종-연산">스트림의 최종 연산</h1>
<hr>
<p><strong>스트림 API에서 중개 연산을 통해 변환된 스트림은 마지막으로 최종 연산을 통해 각 요소를 소모하여 결과를 표시합니다. 즉, 지연(lazy)되었던 모든 중개 연산들이 최종 연산 시에 모두 수행되는 것입니다. 이렇게 최종 연산 시에 모든 요소를 소모한 해당 스트림은 더는 사용할 수 없게 됩니다.</strong></p>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>요소의 출력 : forEach()</li>
<li>요소의 소모 : reduce()</li>
<li>요소의 검색 : findFirst(), findAny()</li>
<li>요소의 검사 : anyMatch(), allMatch(), noneMatch()</li>
<li>요소의 통계 : count(), min(), max()</li>
<li>요소의 연산 : sum(), average()</li>
<li>요소의 수집 : collect()</li>
</ol>
<h2 id="요소의-출력">요소의 출력</h2>
<p>위에서 중개 연산과 관련된 메소드를 사용하면서 자주 사용했던 <code>forEach()</code> 메소드는 스트림의 각 요소를 소모하여 명시된 동작을 수행합니다. 반환 타입이 void이므로 보통 스트림의 모든 요소를 출력하는 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"셋"</span>,<span class="string">"하나"</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">셋</span><br><span class="line">하나</span><br></pre></td></tr></table></figure>
<h2 id="요소의-소모">요소의 소모</h2>
<p>스트림의 최종 연산은 모든 스트림의 각 요소를 소모하여 연산을 수행하게 됩니다. 하지만  <code>reduce()</code> 메소드는 첫 번째와 두 번째 요소를 가지고 연산을 수행한 뒤, 그 결과와 세 번째 요소를 가지고 또 다시 연산을 수행합니다. 이런 식으로 해당 스트림의 모든 요소를 소모하여 연산을 수행하고, 그 결과를 반환하게 됩니다.<br>
또한, 인수로 초기값을 전달하면 초기값과 해당 스트림의 첫 번째 요소와 연산을 시작하며, 그 결과와 두 번째 요소를 가지고 계속해서 연산을 수행하게 됩니다.</p>
<p>다음 예제는 스트림의 각 문자열 요소를 “++” 기호로 연결하여 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; result1 = stream1.reduce((s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        result1.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        String result2 = stream2.reduce(<span class="string">"시작"</span>, (s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷++둘++셋++하나</span><br><span class="line">시작++넷++둘++셋++하나</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 인수로 초기값을 전달하는 reduce() 메소드의 반환 타입은 Optional<t>가 아닌 T 타입입니다. 그 이유는 비어 있는 스트림과 reduce 연산을 할 경우 전달받은 초기값을 그대로 반환해야 하기 때문입니다.</t></p>
<blockquote>
<p>Optional 클래스에 관한 내용은 아래에서 확인할 수 있습니다.</p>
</blockquote>
<h2 id="요소의-검색">요소의 검색</h2>
<p><code>findFirst()</code>와 <code>findAny()</code> 메소드는 해당 스트림에서 첫 번째 요소를 참조하는 Optional 객체를 반환합니다. 두 메소드 모두 비어있는 스트림에서 비어있는 Optional 객체를 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 정렬한 후, 첫 번째에 위치한 요소를 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        OptionalInt result1 = stream1.sorted().findFirst();</span><br><span class="line">        System.out.println(<span class="string">"findFirst() 메소드의 결과 : "</span>+result1.getAsInt());</span><br><span class="line"></span><br><span class="line">        OptionalInt result2 = stream2.sorted().findAny();</span><br><span class="line">        System.out.println(<span class="string">"findAny() 메소드의 결과 : "</span>+result2.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">findFirst() 메소드의 결과 : <span class="number">1</span></span><br><span class="line">findAny() 메소드의 결과 : <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-검사">요소의 검사</h2>
<p>해당 스트림의 요소 중에서 특정 조건을 만족하는 요소가 있는지, 아니면 모두 만족하거나 모두 만족하지 않는지를 다음 메소드를 사용하여 확인할 수 있습니다.</p>
<ol>
<li>anyMatch() : 해당 스트림의 일부 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>allMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>noneMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족하지 않은 경우에 true를 반환함.</li>
</ol>
<p>세 메소드 모두 인수로 <strong>Predicate</strong> 객체를 전달받으며, 요소의 검사 결과는 boolean값으로 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 검사하여 80보다 큰 값을 가지는 요소가 하나라도 존재하는지를 검사하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// stream1의 요소 중 어느 하나라도 80보다 크면 true 반환</span></span><br><span class="line">        System.out.println(stream1.anyMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">        <span class="comment">// stream2의 요소 중 모든 요소가 80보다 크면 treu 반환 </span></span><br><span class="line">        System.out.println(stream2.allMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-통계-연산">요소의 통계, 연산</h2>
<blockquote>
<p>통계</p>
</blockquote>
<ul>
<li>count() : 해당 스트림의 요소의 총 개수를 long 타입의 값으로 반환합니다.</li>
<li>max(), min() : 해당 스트림의 요소 중에서 가장 큰 값과 가장 작은 값을 가지는 요소를 참조하는 Optional 객체를 얻을 수 있습니다. <strong>원하는 Int값을 얻기 위해서는 getAsInt() 메소드를 사용하면 Int 값을 얻을 수 있습니다.</strong></li>
</ul>
<blockquote>
<p>연산</p>
</blockquote>
<p><strong>IntStream이나 DoubleStream과 같은 기본 타입 스트림에는 해당 스트림의 모든 요소에 대해 합과 평균을 구할 수 있는 sum()과 average() 메소드가 각각 정의되어 있습니다. 이때 average() 메소드는 각 기본 타입으로 래핑된 Optional 객체를 반환하므로, Int값을 얻기 위해서는 getAsInt() 메소드를 사용해서 얻을 수 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        DoubleStream stream3 = DoubleStream.of(<span class="number">30.3</span>, <span class="number">90.9</span>, <span class="number">70.7</span>, <span class="number">10.1</span>);</span><br><span class="line">        IntStream stream4 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"count() 메소드 호출 : "</span>+stream1.count());</span><br><span class="line">        System.out.println(<span class="string">"min() 메소드 호출 : "</span>+stream2.min().getAsInt());</span><br><span class="line">        <span class="comment">//System.out.println(stream2.max().getAsInt());</span></span><br><span class="line">        System.out.println(<span class="string">"average() 메소드 호출 : "</span>+stream3.average().getAsDouble());</span><br><span class="line">        System.out.println(<span class="string">"sum() 메소드 호출 : "</span>+stream4.sum());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">count() 메소드 호출 : <span class="number">4</span></span><br><span class="line">min() 메소드 호출 : <span class="number">10</span></span><br><span class="line">average() 메소드 호출 : <span class="number">50.5</span></span><br><span class="line">sum() 메소드 호출 : <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-수집">요소의 수집</h2>
<p><code>collect()</code> 메소드는 인수로 전달되는 Collectors 객체에 구현된 방법대로 스트림의 요소를 수집합니다. 또한, Collectors 클래스에는 미리 정의된 다양한 방법이 클래스 메소드로 정의되어 있습니다. 이 외에도 사용자가 직접 Collector 인터페이스를 구현하여 자신만의 수집 방법을 정의할 수도 있습니다.</p>
<p>스트림 요소의 수집 용도별 사용할 수 있는 Collectors 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림을 배열이나 컬렉션으로 변환 : toArray(), toCollection(), toList(), toSet(), toMap()</li>
<li>요소의 통계와 연산 메소드와 같은 동작을 수행 : counting(), maxBy(), minBy(), summingInt(), averagingInt() 등</li>
<li>요소의 소모와 같은 동작을 수행 : reducing(), joining()</li>
<li>요소의 그룹화와 분할 : groupingBy(), partitioningBy()</li>
</ol>
<p>다음 예제는 collect() 메소드를 이용하여 해당 스트림을 리스트로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"하나"</span>,<span class="string">"셋"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">하나</span><br><span class="line">셋</span><br></pre></td></tr></table></figure>
<p>다음 예제는 Collectors 클래스의 partitioningBy() 메소드를 이용하여 해당 스트림의 각 요소별 글자 수에 따라 홀수와 짝수로 나누어 저장하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"PHP"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, List&lt;String&gt;&gt; partition = stream.collect(Collectors.partitioningBy(s-&gt;(s.length() % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 홀수인 List</span></span><br><span class="line">        List&lt;String&gt; oddList = partition.get(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(oddList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 짝수인 Lists</span></span><br><span class="line">        List&lt;String&gt; evenList = partition.get(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(evenList);</span><br><span class="line"></span><br><span class="line">        System.out.println(partition);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">[CSS, PHP]</span><br><span class="line">[HTML, JAVA]</span><br><span class="line">&#123;<span class="keyword">false</span>=[CSS, PHP], <span class="keyword">true</span>=[HTML, JAVA]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="대표적인-최종-연산-메소드">대표적인 최종 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_final_method.png" width="800" height="300">
<h1 id="optional-클래스">Optional 클래스</h1>
<hr>
<p>Optional<t> 클래스는 Integer나 Double 클래스처럼 ‘T’ 타입의 객체를 포장해 주는 래퍼(Wrapper class)입니다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있습니다.</t></p>
<p><strong>이러한 Optional 객체를 사용하면 예상치 못한 NullPointerException 예외를 제공되는 메소드로 간단히 회피할 수 있습니다. 즉, 복잡한 조건문 없이도 널(null) 값으로 인해 발생하는 예외를 처리할 수 있게 됩니다.</strong></p>
<h2 id="optional-객체의-생성">Optional 객체의 생성</h2>
<p>of() 메소드나 ofNullable() 메소드를 사용하여 Optional 객체를 생성할 수 있습니다.</p>
<p>of() 메소드는 null이 아닌 명시된 값을 가지는 Optional 객체를 반환합니다. 만약 of() 메소드를 통해 생성된 Optional 객체에 null이 저장되면 <strong>NullPointerException</strong> 예외가 발생합니다.</p>
<p>따라서 만약 참조 변수의 값이 만에 하나 null이 될 가능성이 있다면, ofNullable() 메소드를 사용하여 Optional 객체를 생성하는 것이 좋습니다.<br>
ofNullable() 메소드는 명시된 값이 null이 아니면 명시된 값을 가지는 Optional 객체를 반환하며, 명시된 값이 null이면 비어있는 Optional 객체를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line">        Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">        System.out.println(opt2);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt.get());</span><br><span class="line">        <span class="comment">//System.out.println(opt2.get()); 에러발생</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">Optional[자바 공부 중]</span><br><span class="line">Optional.empty</span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<h2 id="optional-객체에-접근">Optional 객체에 접근</h2>
<p>get() 메소드를 사용하면 Optional 객체에 저장된 값에 접근할 수 있습니다. 만약 Optional 객체에 저장된 값이 null이면, <code>NoSuchElementException</code> 예외가 발생합니다. <strong>따라서 get() 메소드를 호출하기 전에 isPresent() 메소드를 사용하여 Optional 객체에 저장된 값이 null인지 아닌지를 먼저 확인한 후 호출하는 것이 좋습니다.</strong></p>
<p>다음 예제는 isPresent() 메소드를 이용하여 좀 더 안전하게 Optional 객체에 저장된 값에 접근하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt.isPresent())&#123;</span><br><span class="line">            System.out.println(opt.get());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"opt 객체는 null입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<p>또한, 아래와 같은 메소드를 사용하여 null 대신에 대체할 값을 지정할 수도 있습니다.</p>
<ol>
<li>orElse() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 값을 반환함.</li>
<li>orElseGet() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결과값을 반환함.</li>
<li>orElseThrow() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 예외를 발생시킴</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.empty(); <span class="comment">// Optional를 null로 초기화함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(opt.orElse(<span class="string">"빈 Optional 객체"</span>));</span><br><span class="line">        System.out.println(opt.orElseGet(String::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">빈 Optional 객체</span><br></pre></td></tr></table></figure>
<blockquote>
<p>empty() 메소드는 Optional 객체를 null로 초기화해줍니다.</p>
</blockquote>
<h2 id="기본-타입의-optional-클래스">기본 타입의 Optional 클래스</h2>
<p>자바에서는 IntStream 클래스와 같이 기본 타입 스트림을 위한 별도의 Optional 클래스를 제공하고 있습니다.</p>
<ol>
<li>OptionalInt 클래스</li>
<li>OptionalLong 클래스</li>
<li>OptionalDouble 클래스</li>
</ol>
<p>이러한 클래스는 반환 타입이 Optional<t> 타입이 아니라 해당 기본 타입이라는 사실만 제외하면 거의 모든 면에서 비슷합니다.</t></p>
<p>또한, Optional 객체에서 get() 메소드를 사용하여 저장된 값에 접근할 수 있는 것처럼 클래스별로 저장된 값에 접근할 수 있는 다음과 같은 메소드를 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스</th>
<th style="text-align:center">저장된 값에 접근하는 메소드</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Optional<t></t></td>
<td style="text-align:center">T get()</td>
</tr>
<tr>
<td style="text-align:center">OptionalInt</td>
<td style="text-align:center">int getAsInt()</td>
</tr>
<tr>
<td style="text-align:center">OptionalLong</td>
<td style="text-align:center">long getAsLong()</td>
</tr>
<tr>
<td style="text-align:center">OptionalDouble</td>
<td style="text-align:center">double getAsDouble()</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        OptionalInt result = stream.findFirst();</span><br><span class="line">        </span><br><span class="line">        System.out.println(result.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="optional-메소드">Optional 메소드</h2>
<img src="/img/optional_method.png" width="800" height="300">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/04/java-basic-18/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-17/"
                            aria-label=": [Java] 17. 람다표현식"
                        >
                            [Java] 17. 람다표현식
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T17:06:06+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="람다-표현식">람다 표현식</h1>
<hr>
<p><strong>람다 표현식(lambda expression)이란 간단히 말해서 메소드를 하나의 식으로 표현한 것을 말합니다.</strong> 기존의 메소드는 아래와 같이 작성합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>람다 표현식으로 위의 코드를 표현하면 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 메소드를 람다 표현식으로 표혀하면, 클래스를 작성하고 객체를 생성하지 않아도 메소드를 사용할 수 있습니다.</p>
<p>그런데 자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다. 따라서 자바에서 람다 표현식은 익명 클래스와 같다고 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 클래스</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 람다 표현식은 메소드의 매개변수로 전달될 수도 있으며, 메소드의 결과값으로 반환될 수도 있습니다. 따라서 람다 표현식을 사용하면, 기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높여줍니다. Java SE 8부터는 이러한 람다 표현식을 사용하여 자바에서도 함수형 프로그래밍을 할 수 있게 되었습니다.</p>
<h2 id="람다-표현식-작성">람다 표현식 작성</h2>
<p>화살표( -&gt; ) 기호를 사용하여 람다 표현식을 작성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(매개변수 목록) -&gt; &#123; 함수 몸체 &#125;</span><br></pre></td></tr></table></figure>
<p>자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다.</p>
<ol>
<li>매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다.</li>
<li>매개변수가 하나인 경우에는 괄호 () 를 생략할 수 있습니다.</li>
<li>함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호 {} 를 생략할 수 있습니다. (이 때, 세미콜론(;)은 붙이지 않음)</li>
<li>함수의 몸체가 하나의 return문으로만 이루어진 경우에는 중괄호 {} 를 생략할 수 없습니다.</li>
<li>return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결과값이 됩니다.(이때 세미콜론(;)은 붙이지 않음)</li>
</ol>
<p>다음은 전통적인 방식의 스레드 생성과 람다 표현식을 사용한 스레드의 생성을 비교하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"전통적인 방식의 일회용 스레드 생성"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"람다 표현식을 사용한 일회용 스레드 생성"</span>)</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">전통적인 방식의 일회용 스레드 생성</span><br><span class="line">람다 표현식을 사용한 일회용 스레드 생성</span><br></pre></td></tr></table></figure>
<blockquote>
<p>람다 표현식을 사용하면 불피요한 코드를 줄일 수 있으며, 코드의 가독성이 훨씬 좋아집니다.</p>
</blockquote>
<h2 id="함수형-인터페이스functional-interface">함수형 인터페이스(functional interface)</h2>
<p>람다 표현식을 사용할 때는 람다 표현식을 저장하기 위한 참조 변수의 타입을 결정해야만 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">참조변수의타입 참조변수의이름 = 람다 표현식</span><br></pre></td></tr></table></figure>
<p><strong>위의 문법처럼 람다 표현식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입을 함수형 인터페이스라고 부릅니다.</strong></p>
<p>함수형 인터페이스는 추상 클래스와는 달리 단 하나의 추상 메소드만을 가져야 합니다. 또한, 다음과 같은 어노테이션(annotation)을 사용하여 함수형 인터페이스임을 명시할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 어노테이션을 인터페이스의 선언 앞에 붙이면, 컴파일러는 해당 인터페이스를 함수형 인터페이스로 인식합니다. 자바 컴파일러는 이렇게 명시된 함수형 인터페이스에 두 개 이상의 메소드가 선언되면 오류를 발생시킵니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span> </span>&#123; <span class="comment">// 함수형 인터페이스의 선언</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Calc minNum = (x, y) -&gt; x &lt; y ? x : y; <span class="comment">// 추상 메소드의 구현</span></span><br><span class="line">        System.out.println(minNum.min(<span class="number">3</span>, <span class="number">4</span>));  <span class="comment">// 함수형 인터페이스의 사용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>자바는 java.util.function 패키지를 통해 여러 상황에서 사용할 수 있는 다양한 함수형 인터페이스를 미리 정의하여 재공합니다.</p>
<h1 id="메소드-참조">메소드 참조</h1>
<hr>
<p>메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있도록 해줍니다.</p>
<p>메소드 참조를 사용하면 불필요한 매개변수를 제거하고 다음과 같이 ‘::’ 기호를 사용하여 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">클래스이름::메소드이름</span><br><span class="line">또는</span><br><span class="line">참조변수이름::메소드이름</span><br></pre></td></tr></table></figure>
<p>다음 코드는 두 개의 값을 전달받아 제곱 연산을 수행하는 Math 클래스의 클래스 메소드인 pow() 메소드를 호출하는 람다 표현식입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base, exponent) -&gt; Math.pow(base, exponent);</span><br><span class="line"><span class="comment">// 위의 식은 단순히 Math 클래스의 pow() 메소드로 인수를</span></span><br><span class="line"><span class="comment">// 전달하는 역할만 하므로, 메소드 참조를 사용해 다음과 같이 표현 가능</span></span><br><span class="line">Math::pow;</span><br></pre></td></tr></table></figure>
<p>또한, 특정 인스턴스의 메소드를 참조할 때에도 참조 변수의 이름을 통해 메소드 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass;</span><br><span class="line">Function&lt;String, Boolean&gt; func = (a) -&gt; obj.equals(a); <span class="comment">// 람다 표현식</span></span><br><span class="line">Function&lt;String, Boolean&gt; func = obj::equals(a);       <span class="comment">// 메소드 참조</span></span><br></pre></td></tr></table></figure>
<p>다음 코드는 람다 표현식과 메소드 참조를 비교하는 코드입니다. 아래의 코드에서 차이를 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DoubleUnaryOperator oper;</span><br><span class="line"></span><br><span class="line">oper = (n) -&gt; Math.abs(n); <span class="comment">// 람다 표현식</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">oper = Math::abs; <span class="comment">// 메소드 참조</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>DoubleUnaryOperator 인터페이스는 한 개의 double 형 매개변수를 전달받아 한 개의 double 형 값을 반환하는 java.util.function 패키지에서 제공하는 함수형 인터페이스입니다.</p>
</blockquote>
<h2 id="생성자-참조">생성자 참조</h2>
<p>생성자를 호출하는 람다 표현식도 앞서 살펴본 메소드 참조를 이용할 수 있습니다. 즉, 단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 단순히 Object 클래스의 인스턴스를 생성하고 반환하기만 하므로, 생성자 참조를 사용하여 다음처럼 간단하게 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>이때, 해당 생성자가 존재하지 않으면 컴파일 시 오류가 발생합니다. 또한, 배열을 생성할 때에도 다음과 같이 생성자 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func1 = a -&gt; <span class="keyword">new</span> <span class="keyword">double</span>[a];</span><br><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func2 = <span class="keyword">double</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 생성자 참조</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-17/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-16/"
                            aria-label=": [Java] 16. 스레드"
                        >
                            [Java] 16. 스레드
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T12:48:43+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="프로세스process란">프로세스(process)란?</h1>
<hr>
<p><strong>프로세스란 단순히 실행 중인 프로그램이라고 할 수 있습니다. 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다. 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.</strong></p>
<h1 id="스레드thread란">스레드(thread)란?</h1>
<hr>
<p>스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.</p>
<h2 id="스레드의-생성과-실행">스레드의 생성과 실행</h2>
<p>자바에서 스레드를 생성하는 방법에는 다음과 같은 두 가지 방법이 있습니다.</p>
<ol>
<li>Runnable 인터페이스를 구현하는 방법</li>
<li>Thread 클래스를 상속받는 방법</li>
</ol>
<p>두 방법 모두 스레드를 통해 작업하고 싶은 내용을 run()이라는 메소드에 작성하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadWithClass thread1 = <span class="keyword">new</span> ThreadWithClass();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// Runnable을 구현한 클래스는 Thread가 없기 때문에 Thread 타입으로 객체를 만들고 구현한 클래스를</span></span><br><span class="line">        <span class="comment">// 생성자에 매개변수로 넣는다.</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread 클래스를 상속받아 Thread 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithClass</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread를 상속받아 구현 : "</span>+getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위의 결과를 보면, 생성된 스레드가 서로 번갈아가며 실행되고 있는 것을 확인할 수 있습니다. 스레드의 실행은 어떤 것이 먼저 실행되는 것인지 정해져 있지 않습니다. 그리고 Thread의 실행은 start()라는 메소드를 호출함으로써 실행시킬 수 있습니다.</p>
<p>Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없으므로, 일반적으로 Runnable 인터페이스를 구현하는 방법으로 스레드를 생성합니다.</p>
<blockquote>
<p>Runnable 인터페이스는 몸체가 없는 메소드인 run() 메소드 단 하나만을 가지는 간단한 인터페이스입니다.</p>
</blockquote>
<h2 id="스레드-우선순위">스레드 우선순위</h2>
<p>자바에서 각 스레드는 <code>우선순위(priority)</code>에 관한 자신만의 필드를 가지고 있습니다. 이러한 우선순위에 따라 특정 스레드가 더 많은 시간 동안 작업을 할 수 있도록 설정할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">필드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int MAX_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최대 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int MIN_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최소 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int NORM_PRIORITY</td>
<td style="text-align:center">스레드가 생성될 때 가지는 기본 우선순위를 명시함.</td>
</tr>
</tbody>
</table>
<p>getPriority()와 setPriority() 메소드를 통해 스레드의 우선순위를 반환하거나 변경할 수 있습니다. 스레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, <strong>숫자가 높을수록 우선순위 또한 높아집니다.</strong></p>
<p><strong>하지만 스레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐입니다. 우선순위가 10인 스레드가 우선순위가 1인 스레드보다 10배 더 빨리 수행되는 것이 아닙니다. 단지 우선순위가 10인 스레드는 우선순위가 1인 스레드보다 좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐입니다.</strong></p>
<p>그리고 스레드의 우선순위는 해당 스레드를 생성한 스레드의 우선순위를 상속받게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">      </span><br><span class="line">        thread2.setPriority(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 1 : thread-1의 우선순위를 10으로 변경함</span></span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 2 : thread-0 실행</span></span><br><span class="line">        thread2.start(); <span class="comment">// 3 : thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getPriority());</span><br><span class="line">        System.out.println(thread2.getPriority());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>main() 메소드를 실행하는 스레드의 우선순위는 언제나 5이므로, main() 메소드 내에서 생성된 스레드는 Thread-0의 우선순위는 5로 설정되는 것을 확인할 수 있습니다.</p>
<p>위의 코드에서 2번 라인에서 Thread-0이 먼저 실행되고, 3번 라인에서 Thread-1이 나중에 실행됩니다. 따라서 만약 1번 라인이 존재하지 않는다면, Thread-0이 먼저 실행되고, Thread-1이 나중에 실행될 것입니다. 하지만 1번 라인에서 Thread-1의 우선순위를 10으로 변경했기 때문에, Thread-1이 나중에 실행되었더라도 우선순위가 Thread-0보다 높아서 먼저 실행되는 것입니다.</p>
<h1 id="멀티-스레드multi-thread">멀티 스레드(multi thread)</h1>
<hr>
<p>스레드와 관련된 내용은 운영체제(OS)와 연관된 내용입니다. 그래서 여기에서는 간단하게 알아보고 추후에 운영체제 공부를 할 때 자세하게 포스팅하겠습니다. :)</p>
<p>일반적으로 하나의 프로세스는 하나의 스레드를 가지고 작업을 수행하게 됩니다. 하지만 멀티 스레드(multi trhead)란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다.<br>
또한, 멀티 프로세스(multi process)는 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미합니다.</p>
<p>멀티 스레드와 멀티 프로세스 모두 여러 흐름을 동시에 수행한다는 공통점을 가지고 있습니다. 멀티 프로세스는 각 프로세스가 독립적인 메모리를 가지고 별도로 실행되지만, <strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유한다는 점이 다릅니다.</strong></p>
<p><strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적습니다. 또한, 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아집니다.</strong></p>
<h2 id="문맥-교환context-switching">문맥 교환(context switching)</h2>
<p>컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어(core) 수와 같습니다. 만약 CPU의 코어 수보다 더 많은 스레드가 실행되면, 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행하게 됩니다.</p>
<p>이 때, 각 스레드가 서로 교체될 때 스레드 간의 <code>문맥 교환(context switching)</code>이라는 것이 발생합니다. <strong>문맥 교환이란 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업을 가리킵니다.</strong></p>
<p><strong>이러한 문맥 교환에 걸리는 시간이 커지면 커질수록, 멀티 스레딩의 효율은 저하됩니다. 오히여 많은 양의 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있습니다. 따라서 많은 수의 스레드를 실행하는 것이 언제나 좋은 성능을 보이는 것은 아니라는 점을 유의해야 합니다.</strong></p>
<h2 id="스레드-그룹thread-group">스레드 그룹(thread group)</h2>
<p><code>스레드 그룹(thread group)이란 서로 관련이 있는 스레드를 하나의 그룹으로 묶어 다루기 위한 장치입니다.</code> 자바에서는 스레드 그룹을 다루기 위해 ThreadGroup라는 클래스를 제공합니다.</p>
<p>이러한 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이렇게 포함된 스레드 그룹은 트리 형태로 연결됩니다. 이 때, 스레드는 자신이 포함된 스레드나 그 하위 그룹에는 접근할 수 있지만 다른 그룹에는 접근할 수 없습니다.<br>
<strong>이렇게 스레드 그룹은 스레드가 접근할 수 있는 범위를 제한하는 보안상으로도 중요한 역할을 하고 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.start(); <span class="comment">// thread-0 실행</span></span><br><span class="line">        System.out.println(thread0.getThreadGroup());</span><br><span class="line"></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"MyThread"</span>);</span><br><span class="line">        <span class="comment">// MyThread라는 스레드 그룹 생성</span></span><br><span class="line">        threadGroup.setMaxPriority(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 해당 스레드 그룹의 최대 우선순위를 7로 설정함</span></span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// 스레드를 생성할 때 포함될 스레드 그룹을 전달할 수 있다.</span></span><br><span class="line">        thread1.start(); <span class="comment">// thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getThreadGroup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">java.lang.ThreadGroup[name=MyThread,maxpri=<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 main() 메소드에서 생성된 스레드의 기본 스레드 그룹의 이름은 <strong>main</strong>이 되며, 최대 우선순위는 10으로 자동 설정됩니다.</p>
<h2 id="데몬-스레드deamon-thread">데몬 스레드(deamon thread)</h2>
<p><strong>데몬 스레드(deamo thread)란 다른 일반 스레드의 작업을 돕는 보조적인 역할을 하는 스레드를 가리킵니다. 따라서 데몬 스레드는 일반 스레드가 모두 종료되면 더는 할 일이 없으므로, 데몬 스레드 역시 자동으로 종료됩니다.</strong></p>
<p>데몬 스레드의 생성 방법과 실행 방법은 모두 일반 스레드와 같습니다. 단, 실행하기 전에 <code>setDaemon()</code> 메소드를 호출하여 데몬 스레드로 설정하기만 하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 데몬 스레드로 설정</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 데몬 스레드는 일정 시간마다 자동으로 수행되는 저장 및 화면 갱신 등에 이용되고 있습니다.</p>
<h2 id="가비지-컬렉터garbage-collector">가비지 컬렉터(garbage collector)</h2>
<blockquote>
<p>가비지 컬렉터는 자바에서 중요한 개념으로 알고 있습니다. 이 부분에 대한 심화된 내용은 별도의 포스트에서 소개할 예정이고, 이번에는 간단하게 알고 넘어가도록 하겠습니다.</p>
</blockquote>
<p><strong>데몬 스레드를 이용하는 가장 대표적인 예로 가비지 컬렉터(garbage collector)를 들 수 있습니다. 가비지 컬렉터(garbage collector)란 프로그래머가 동적으로 할당한 메모리 중 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제해 주는 데몬 스레드입니다.</strong></p>
<p>자바에서는 프로그래머가 메모리에 직접 접근하지 못하게 하는 대신에 가비지 컬렉터가 자동으로 메모리를 관리해 줍니다. 이러한 가비지 컬렉터를 이용하면 프로그래밍을 하기가 훨씬 쉬워지며, 메모리에 관련된 버그가 발생할 확률도 낮아집니다.</p>
<p>보통 가비지 컬렉터가 동작하는 동안에는 프로세서가 일시적으로 중지되므로, 필연적으로 성능의 저하가 발생합니다. 하지만 요즘에는 가비지 컬렉터의 성능이 많이 향상되어, 새롭게 만들어지는 대부분의 프로그래밍 언어에서 가비지 컬렉터를 제공하고 있습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-16/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-15/"
                            aria-label=": [Java] 15. 입력과 출력"
                        >
                            [Java] 15. 입력과 출력
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T10:51:33+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림">스트림</h1>
<hr>
<p><strong>자바에서는 파일이나 콘솔의 입출력을 직접 다루지 않고, 스트림(stream)이라는 흐름을 통해 다룹니다.</strong></p>
<p>스트림(stream)이란 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름을 의미합니다. 즉, 스트림은 운영체제에 의해 생성되는 가상의 연결고리를 의미하며, 중간 매개자 역할을 합니다.</p>
<img src="/img/stream.png" width="500" height="200">
<p>Java SE 8 버전부터 추가된 스트림 API는 앞서 설명한 스트림과는 전혀 다른 개념입니다. 스트림 API는 추후에 포스팅할 예정입니다. ^0^</p>
<h2 id="입출력-스트림">입출력 스트림</h2>
<p><strong>스트림은 한 방향으로만 통신할 수 있으므로, 입력과 출력을 동시에 처리할 수는 없습니다. 따라서 스트림은 사용 목적에 따라 입력 스트림과 출력 스트림으로 구분됩니다.</strong></p>
<p>자바에서는 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지를 통해 InputStream과 OutputStream 클래스를 별도로 제공하고 있습니다. 즉, 자바에서의 스트림 생성이란 이러한 스트림 클래스 타입의 인스턴스를 생성한다는 의미입니다.</p>
<p><strong>InputStream</strong> 클래스에는 read() 메소드가, <strong>OutputStream</strong> 클래스에는 write() 메소드가 각각 추상 메소드로 포함되어 있습니다. 사용자는 이 두 메소드를 상황에 맞게 적절히 구현해야만 입출력 스트림을 생성하여 사용할 수 있습니다.</p>
<img src="/img/stream_class.png" width="500" height="200">
<blockquote>
<p>read() 메소드는 해당 입력 스트림에서 더 이상 읽어들일 바이트가 없으면 -1을 반환해야 합니다. 그런데 반환 타입을 byte 타입으로 하면 0 ~ 255까지의 바이트 정보는 표현할 수 있지만 -1은 표현할 수 없게 됩니다. 따라서 InputStream의 read() 메소드는 반환 타입을 int형으로 선언하고 있습니다.</p>
</blockquote>
<h2 id="바이트-기반-스트림">바이트 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 자바에서는 아래와 같이 다양한 바이트 기반의 입출력 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:left">AudioInputStream</td>
<td style="text-align:center">AudioOutputStream</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<h2 id="보조-스트림">보조 스트림</h2>
<p>자바에서 제공하는 보조 스트림은 실제로 데이터를 주고 받을 수는 없지만, 다른 스트림의 기능을 향상시키거나 새로운 기능을 추가해 주는 스트림입니다. 자바에서는 아래와 같은 다양한 보조 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterInputStream</td>
<td style="text-align:center">FilterOutputStream</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center">입출력 스트림으로부터 자바의 기본 타입으로 데이터를 읽어올 수 있게함.</td>
</tr>
<tr>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center">데이터를 객체 단위로 읽거나, 읽어 들인 객체를 역직렬화시킴</td>
</tr>
<tr>
<td style="text-align:center">SequenceInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">두 개의 입력 스트림을 논리적으로 연결함.</td>
</tr>
<tr>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h2 id="문자-기반-스트림">문자 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 하지만 자바에서 가장 작은 타입인 char 형이 2바이트이므로, 1바이트씩 전송되는 바이트 기반 스트림으로는 원활한 처리가 힘든 경우가 있습니다.</p>
<p>따라서 자바에서는 바이트 기반 스트림뿐만 아니라 문자 기반의 스트림도 별도로 제공합니다. <strong>이러한 문자 기반 스트림은 기존의 바이트 기반 스트림에서 InputStream을 Reader로, OutputStream을 Writer로 변경하면 사용할 수 있습니다.</strong></p>
<p>다음은 다양한 문자 기반의 입출력 스트림을 보여주고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<p>지금까지 살펴본 바이트 기반의 스트림과 문자 기반의 스트림은 활용 방법이 거의 같습니다. 따라서 문자 기반의 보조 스트림도 다음과 같이 제공됩니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">FilterWriter</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintWriter</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h1 id="표준-입출력">표준 입출력</h1>
<hr>
<p>자바에서는 콘솔과 같은 입출력 장치를 위해 System이라는 표준 입출력 클래스를 정의하고 있습니다. java.lang 패키지에 포함되어 있는 System 클래스는 표준 입출력을 위해 다음과 같은 클래스 변수를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스 변수</th>
<th style="text-align:center">입출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://System.in" target="_blank" rel="noopener">System.in</a></td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">콘솔로부터 데이터를 입력받는다.</td>
</tr>
<tr>
<td style="text-align:center">System.out</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.</td>
</tr>
<tr>
<td style="text-align:center">System.err</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.(에러를 출력)</td>
</tr>
</tbody>
</table>
<p>표준 입출력 스트림은 자바가 자동으로 생성하므로, 개발자인 우리가 별도로 스트림을 생성하지 않아도 사용할 수 있습니다. &gt;__&lt;</p>
<h2 id="표준-입출력의-대상-변경">표준 입출력의 대상 변경</h2>
<p>앞서 살펴본 세 가지 입출력 스트림은 모두 콘솔과 같은 표준 입출력 장치를 대상으로 합니다. 하지만 이와 같은 스트림에 다음 System 메소드를 사용하면 스트림의 대상을 다른 입출력 장치로 변경할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static void setIn(InputStream in)</td>
<td style="text-align:center">입력 스트림의 대상을 전달된 입력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setOut(PrintStream out)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setErr(PrintStream err)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
</tbody>
</table>
<h2 id="randomaccessfile-클래스">RandomAccessFile 클래스</h2>
<p>앞서 살펴본 다양한 입출력 스트림을 이용하면 파일에 <strong>순차적으로</strong> 입출력 작업을 수행할 수 있습니다. 하지만 순차적인 접근이 아닌 임의의 지점에 접근하여 작업을 수행하고 싶다면, <strong>RandomAccessFile 클래스를 사용하면 됩니다.</strong> 이 클래스는 <code>파일</code>만을 대상으로 하며, 임의의 지점에서 입출력을 동시에 수행할 수 있습니다.</p>
<p>RandomAccessFile 클래스의 생성자에는 인수로 파일의 이름뿐만 아니라 파일 모드까지 함께 전달해야 합니다. 파일 모드란 파일의 사용 용도를 나타내는 문자열로, 자바에서 사용할 수 있는 대표적인 파일 모드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">파일 모드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">파일을 오로지 읽는 것만 가능한 모드로 개방함.</td>
</tr>
<tr>
<td style="text-align:center">“rw”</td>
<td style="text-align:center">파일을 읽고 쓰는 것이 모두 가능한 모드로 개방함. 만약 파일이 없으면 새로운 파일을 생성함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "rw" 모드로 "data.txt" 파일을 개방함.</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        System.out.println(file.getFilePointer()); </span><br><span class="line">        <span class="comment">// 0 : 파일 포인터의 현재 위치를 반환함.</span></span><br><span class="line">        file.writeInt(<span class="number">10</span>);<span class="comment">// 정수 10을 저장함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 4</span></span><br><span class="line">        file.seek(<span class="number">20</span>);                        </span><br><span class="line">        <span class="comment">// 파일 포인터의 위치를 20으로 이동시킴.</span></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getFilePointer() : 파일 포인터의 현재 위치를 확인할 수 있다.</li>
<li>seek() : 파일 포인터의 위치를 변경할 수 있다.</li>
</ul>
<h2 id="file-클래스">File 클래스</h2>
<p>앞서 살펴본 입출력 스트림을 사용하면 파일을 통한 입출력 작업을 수행할 수 있습니다. 하지만 파일의 제거나 디렉터리에 관한 작업 등은 입출력 스트림을 통해서는 수행할 수 없습니다.</p>
<p>자바는 이러한 입출력 작업 이외의 파일과 디렉터리에 관한 작업을 File 클래스를 통해 처리하도록 하고 있습니다. File 클래스에는 다음과 같은 다양한 메소드가 정의되어 있습니다.</p>
<img src="/img/file_class.png" width="800" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"D:\\data"</span>); <span class="comment">// 디렉토리 생성</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(dir, <span class="string">"data.txt"</span>); </span><br><span class="line">    <span class="comment">// 위에서 생성한 디렉토리에 파일 생성</span></span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">"파일이 존재하지 않습니다."</span>);</span><br><span class="line">        System.out(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.pirntln(file.getPath());</span><br><span class="line">    <span class="comment">// 파일의 경로 반환 : D:\data\data.txt</span></span><br><span class="line">    System.out.println(file.length());</span><br><span class="line">    <span class="comment">// 파일의 크기를 반환함</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">D:\data\data.txt</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-15/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/02/java-basic-14/"
                            aria-label=": [Java] 14. 예외 처리"
                        >
                            [Java] 14. 예외 처리
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-02T11:02:54+09:00">
	
		    Sep 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="오류error와-예외exception">오류(error)와 예외(exception)</h1>
<hr>
<p>자바 프로그램을 작성할 때 자바 문법에 맞지 않게 코드를 작성하고 컴파일하려고 하면 자바 컴파일러는 문법 오류(syntax error)를 발생시킵니다. 또한, 자바 문법에는 맞게 작성되었다 하더라도 프로그램이 실행되면서 예상하지 못한 오류가 발생할 수 있습니다.<br>
이렇게 컴퓨터 시스템이 동작하는 도중에 예상하지 못한 사태가 발생하여 실행 중인 프로그램이 영향을 받는 것을 오류(error)와 예외(exception) 두 가지로 구분할 수 있습니다.</p>
<blockquote>
<p>코드를 작성하는 과정에서 예기치 못한 수많은 에러들이 발생합니다. 예를 들면 다음과 같습니다.<br>
<strong>컴파일 전에 알게 되는 에러도 있고, 작성할 때는 아무 문제 없다가 실행시키고 나서야 발생하는 에러들이 있습니다. 이것들을 제어할 수 있어야 좀 더 안전한 프로그램을 설계할 수 있습니다.</strong></p>
</blockquote>
<p><code>에러(error)? 예외(exception)?</code></p>
<p>컴파일 에러 - 컴파일 시에 발생하는 에러<br>
런타임 에러 - 실행 시에 발생하는 에러<br>
논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 에러</p>
<p>그럼 위에서 말하는 컴파일, 런타임은 무엇이면 컴파일 에러는 무엇일까요?? 공부를 하다보니 들어본 적은 있지만, 정확하게 무엇이라고 설명하기에는 부족한 부분들이 있어서 아래에 정리해봤습니다.</p>
<ul>
<li>컴파일 에러 : 주로 문법상의 오류가 많습니다. (빨간 줄이 나타나는 에러와 같은 경우입니다. 대부분의 IDE들이 빨간줄 표시로 잡아줍니다.) 컴파일 에러가 발생하는 경우는 주로 오타, 중괄호의 짝이 맞지 않는 경우, 중복된 변수명 등의 원인이 있을 수 있습니다.</li>
<li><code>RunTime</code> : 어떤 프로그램이 실행되는 동안의 Time을 의미하며, runtime error는 어떤 프로그램이 실행되는 동안 발생하는 에러입니다.</li>
<li>런타임 에러 : 문법상으로는 에러가 없지만 실행시켰을 때 에러가 나는 경우, 대표적인 경우가 <strong>NullpointerException</strong></li>
<li><code>Compile Time</code> : 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정이라고 하며, compile error는 고급 언어(프로그래밍 언어)를 기계어로 변경하는 과정에서 발생하는 에러입니다.</li>
</ul>
<p>즉, 컴파일 에러가 발생하지 않더라도 런타임 에러가 발생할 수 있습니다.</p>
<p><img src="/img/compile_runtime.png" alt=""></p>
<h2 id="오류error">오류(error)</h2>
<p>**오류(error)**는 시스템 레벨에서 프로그램에 심각한 문제를 야기하여 실행 중인 프로그램을 종료시킵니다. 이러한 오류는 개발자가 미리 예측하여 처리할 수 없는 것이 대부분이므로, 오류에 대한 처리는 할 수 없습니다.<br>
(ex. 메모리 부족, 스택 오버플로우와 같이 발생하면 복구할 수 없는.)</p>
<h2 id="예외exception">예외(exception)</h2>
<p>**예외(exception)**는 오류와 마찬가지로 실행 중인 프로그램을 비정상적으로 종료시키지만, 발생할 수 있는 상황을 미리 예측하여 처리할 수 있습니다. 따라서 개발자는 예외 처리(Exception handling)를 통해 예외 상황을 처리할 수 있도록 코드의 흐름을 바꿀 필요가 있습니다.<br>
(발생하더라도 수습될 수 있는, 비교적 덜 심각한. 그렇기에 프로그램의 비정상적인 종료를 사전에 예방할 수 있음.)</p>
<h1 id="예외처리exception-handling">예외처리(exception handling)</h1>
<hr>
<p>자바에서 예외 처리는 이 <strong>Exception을 Handling하는 것</strong>을 말합니다. 프로그램을 제작하는 과정에서 발생할 예외에 대해 미리 코드를 작성하는 것입니다.</p>
<p>if-else문으로 처리를 해야만 했던, C에서는 예외 처리를 위한 if문과 일반 if문을 구분하기 힘들었습니다. 이 문제를 해결하기 위해 <strong>Java</strong>에서는 예외 처리에 특화된 문법을 제공합니다.</p>
<p>그것이 바로 <strong>try-catch문입니다.</strong> 사용하는 방법과 코드에 대한 설명은 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 예외를 발생시킬 위험을 갖고 있는 코드(로직)</span></span><br><span class="line"><span class="comment">// 이 로직은 예외 상황과 관련있는 문장들도 고려해야 합니다.</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line"><span class="comment">// 예외가 발생했을 때 실행되는 로직</span></span><br><span class="line"><span class="comment">// Exception클래스는 모든 예외의 상위 클래스</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(e2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 예외 발생 여부와 상관없이 무조건 실행될 코드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 보면 예외를 발생시킬 위험을 갖고 있는 코드인 경우 <strong>try{ }</strong> 블록 안에 넣어둡니다. 그리고 <strong>catch</strong>를 통해 오류 메시지를 출력합니다. try안에 있는 코드를 실행하다가 오류가 발생하면 catch 구문으로 <strong>Jump</strong>합니다.</p>
<blockquote>
<p>Jump : 오류가 발생한 구문 다음의 코드는 실행되지 않는다.</p>
</blockquote>
<p>그러면 catch 메소드가 실행되게 되는데, 이 때 Exception이라는 클래스를 e로 인스턴스화하여 catch에 매개변수로 전달합니다. 그리고 Exception 이라는 클래스에 있던 getMessage라는 메소드를 호출하거나 다른 구문을 실행합니다.</p>
<p>다음은 예외가 발생했을 때 실행되는 로직의 예입니다.<br>
Sysetm.out.println(e.getMessage()); -&gt; 가장 간단한 예외 상황을 출력<br>
Sysetm.out.println(e.toString()); -&gt; 예외 상황에 대한 좀 더 자세한 정보를 출력<br>
e.printStackTrace(); -&gt; 예외 상황이 발생한 소스코드의 위치까지 출력</p>
<p>그리고 위의 코드처럼 catch 구문을 여러 개 두어서 다중 catch도 가능합니다.</p>
<p>catch 블록과 finally 블록은 선택적인 옵션으로 반드시 사용할 필요는 없습니다. 따라서 사용할 수 있는 모든 적합한 try 구문은 다음과 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">try</span> / <span class="keyword">catch</span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">try</span> / <span class="keyword">finally</span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">try</span> / <span class="keyword">catch</span> / ... / <span class="keyword">finally</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>다른 제어문과 달리 예외 처리문은 중괄호를 생략할 수 없습니다.</p>
</blockquote>
<h2 id="예외처리-메커니즘">예외처리 메커니즘</h2>
<p>자바에서 예외 처리는 아래의 그림과 순서로 진행됩니다.</p>
<ol>
<li>try 블록에 도달한 프로그램의 제어는 try 블록 내의 코드를 실행합니다.<br>
이 때 만약 예외가 발생(throw)하지 않고, finally 블록이 존재하면 프로그램의 제어는 바로 finally 블록으로 이동합니다.</li>
<li>try 블로에서 예외가 발생하면 catch 구문으로 <strong>Jump</strong>하게 되고, catch 핸들러는 다음과 같은 순서로 적절한 catch 블록을 찾게 됩니다.
<ul>
<li>스택에서 try 블록과 가장 가까운 catch 블록부터 차례대로 검사합니다.</li>
<li>만약 적절한 catch 블록을 찾지 못하면, 바로 다음 바깥쪽 try 블록 다음에 위치한 catch 블록을 차례대로 검사합니다.</li>
<li>이러한 과정을 가장 바깥쪽의 try 블록까지 계속 검사하게 됩니다.</li>
<li>그래도 적절한 catch 블록을 찾지 못하면, 예외는 처리되지 못합니다.</li>
</ul>
</li>
<li>만약 적절한 catch 블록을 찾게 되면, throw 문의 피연산자는 예외 객체의 형식 매개변수로 전달됩니다.</li>
<li>모든 예외 처리가 끝나면 프로그램의 제어는 finally 블록으로 이동합니다.(finally 블록이 있다면)</li>
<li>finally 블록이 모두 처리되면, 프로그램의 제어는 예외 처리문 바로 다음으로 이동합니다.</li>
</ol>
<img src="/img/try_catch.png" width="500" height="200">
<p>만약 1번 try 블록에서 예외가 발생하지 않고, 바깥쪽 try 블록에서도 예외가 발생하지 않으면, 6번 finally 블록이 바로 실행될 것입니다.</p>
<p>하지만, 1번 try 블록에서 예외가 발생하면 2번과 3번 catch 블록에서 해당 예외를 처리할 수 있는지 검사하게 됩니다. 만약 적절한 catch 블록을 처리하지 못하면, 바깥쪽 4,5번 catch 블록도 차례대로 검사하게 됩니다.<br>
이 때 해당 예외를 처리할 수 있는 catch 블록을 찾게 되면, 해당 catch 블록을 실행한 후 6번의 finally 블록을 실행합니다. 하지만 모든 catch 블록이 해당 예외를 처리할 수 없으면, 예외는 처리되지 못한채 해당 프로그램을 강제 종료될 것입니다.</p>
<h1 id="exception-클래스">Exception 클래스</h1>
<hr>
<p>자바에서 모든 예외의 조상 클래스가 되는 Exception 클래스는 크게 다음과 같이 구분할 수 있습니다.</p>
<ol>
<li>RuntimeException 클래스</li>
<li>그 외의 Exception 클래스의 자식 클래스</li>
</ol>
<img src="/img/exception.png" width="500" height="200">
<p>RuntimeException 클래스를 상속받는 자식 클래스들은 주로 치명적인 예외 상황을 발생시키지 않는 예외들로 구성됩니다. 따라서 try / catch 문을 사용하기보다는 프로그램을 작성하면서 예외가 발생하지 않도록 주의를 기울이는 편이 좋습니다.</p>
<p>하지만 그 외의 Exception 클래스에 속하는 자식 클래스들은 치명적인 예외 상황을 발생시키므로, 반드시 try / catch문을 사용하여 예외를 처리해야만 합니다. 따라서 자바 컴파일러는 RuntimeException 클래스 이외의 Exception 클래스의 자식 클래스에 속하는 예외가 발생할 가능성이 있는 구문에는 반드시 예외를 처리하도록 강제하고 있습니다. 만약 이러한 예외가 발생할 가능성이 있는 구문을 처리하지 않았을 때는 컴파일 시 오류를 발생시킵니다.</p>
<p>다음 예제는 PrintStream 클래스의 write() 메소드를 사용하여 byte 타입 배열의 모든 요소를 출력하는 예제입니다. 하지만 write() 메소드에서 발생할 수 있는 IOException에 대한 예외를 처리하지 않았으므로, 컴파일 시 오류가 발생합니다.</p>
<p>따라서 try / catch문을 사용하여 IOException에 대한 예외 처리까지 해주어야만 컴파일 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] list = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.write(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="예외-처리의-계층-관계">예외 처리의 계층 관계</h2>
<p>자바에서는 예외가 발생하면, try 블록과 가장 가까운 catch 블록부터 순서대로 검사합니다. 따라서 여러 개의 catch 블록을 사용할 때는 Exception 클래스의 계층 관계에도 주의를 기울여야만 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.write(list);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 IOException이 발생하면, 자바는 첫 번째 catch 블록부터 순서대로 해당 예외를 처리할 수 있는지를 검사합니다. 그런데 IOException은 Exception 클래스의 자식 클래스이므로, 첫 번째 catch 블록에서도 IOException을 처리할 수 있습니다.<br>
따라서 IOException을 비롯한 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면, 언제나 첫 번째 catch 블록에서만 처리될 것입니다.<br>
즉, catch 블록의 순서를 위의 코드처럼 작성하면, 두 번째 catch 블록은 영원히 실행되지 않을 것입니다.</p>
<p>따라서, IOException만을 따로 처리하고자 한다면, 다음과 같이 catch 블록의 순서를 변경해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    System.out.write(list);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 변경하면 IOException이 발생하면, 첫 번째 catch 블록에서 해당 예외를 처리할 것입니다. 또한, IOException 이외의 Exception 클래스의 자식 클래스에 해당하는 예외가 발생하면 두 번째 catch 블록에서 처리될 것입니다. 이처럼 범위가 더 좁은 예외를 처리하는 catch 블록을 먼저 명시하고, 범위가 더 넓은 예외를 처리하는 catch 블록은 나중에 명시해야만 정상적으로 해당 예외를 처리할 수 있습니다.</p>
<h2 id="여러-예외-타입의-동시-처리">여러 예외 타입의 동시 처리</h2>
<p><strong>Java SE 7 부터는 ‘|’ 기호를 사용하여 하나의 catch 블록에서 여러 타입의 예외를 동시에 처리할 수 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.db.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 일반적으로 작성하던 catch 블록을 아래와 같이 동시에 처리할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.db.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | SQLException e) &#123;</span><br><span class="line"></span><br><span class="line">    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만, 둘 이상의 예외 타입을 동시에 처리하는 catch 블록에서 매개변수로 전달받은 예외 객체는 묵시적으로 final 제어자를 가지게 됩니다. 따라서 catch 블록 내에서 해당 매개변수에는 어떠한 값도 대입할 수 없습니다.(상수화가 되었기 때문)</p>
<h2 id="throwable-클래스">Throwable 클래스</h2>
<p>자바에서 Throwable 클래스는 모든 예외의 조상이 되는 Exception 클래스와 모든 오류의 조상이 되는 Error 클래스의 부모 클래스입니다. Throwable 타입과 이 클래스를 상속받은 서브 타입만이 자바 가상 머신(JVM)이나 throw 키워드에 의해 던져질 수 있습니다.</p>
<p>이 클래스에는 예외나 오류에 관한 다양한 정보를 확인할 수 있는 다음과 같은 메소드가 포함되어 있습니다.</p>
<ul>
<li>String getMessage() : 해당 throwable 객체에 대한 자세한 내용을 문자열로 반환함</li>
<li>vodi printStackTree() : 해당 throwable 객체와 표준 오류 스트림(standard error stream)에서 해당 객체의 스택 트레이스를 출력함</li>
<li>String toString() : 해당 throwable 객체에 대한 간략한 내용을 문자열로 반환함</li>
</ul>
<p>다음 예제는 일부로 숫자를 0으로 나눠서 ArithmeticException 오류를 발생시키는 예제입니다. 이렇게 발생한 오류에 대해서 Throwable 메소드를 사용하여 발생한 오류에 대한 정보를 출력합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="number">5</span>/<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">현재 발생한 예외의 정보 : / by zero</span><br></pre></td></tr></table></figure>
<h2 id="자주-사용되는-예외-클래스">자주 사용되는 예외 클래스</h2>
<p>자바에서 자주 사용되는 예외 클래스는 다음의 표와 같습니다.</p>
<img src="/img/exception_class.png" width="500" height="200">
<h1 id="예외-발생-및-회피">예외 발생 및 회피</h1>
<hr>
<p>자바에서는 throw 키워드를 사용하여 강제로 예외를 발생시킬 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception e = <span class="keyword">new</span> Exeption(<span class="string">"메시지"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h2 id="예외-회피하기">예외 회피하기</h2>
<p>예외 처리에 대한 부분에서 가장 헷갈리는 부분이 <strong>throw와 throws</strong>입니다.</p>
<ul>
<li><strong>throw</strong>
<ul>
<li>예외를 발생시키는 것이고, 예외를 던지는 것입니다.</li>
<li>메소드 내에서 상위 블록으로 예외를 던지는 것</li>
<li>억지로 에러를 발생시킬 때도 사용되지만 현재 메소드의 에러를 처리한 후에 상위 메소드에 에러 정보를 줌으로써 상위 메소드에서도 에러가 발생한 것을 감지할 수 있습니다.</li>
<li>실제로 exception을 throw할 때 사용하는 키워드</li>
<li><strong>throw는 강제로 예외를 발생시키는 것</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlingException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"호출된 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handlingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main() 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">호출된 메소드에서 예외가 처리됨!</span><br></pre></td></tr></table></figure>
<p>Main 함수에서 handlingException() 함수를 호출하고 그 함수 안에서는 <strong>throw</strong> 키워드를 사용하여 예외를 발생시키고 있습니다. 이 예외를 발생시키는 문장을 try / catch로 감싸고 있기 때문에 발생한 예외는 catch 블록으로 <strong>Jump</strong>하게 되고 함수 내에서 예외를 처리하게 됩니다.</p>
<ul>
<li><strong>throws</strong>
<ul>
<li>메소드나 생성자를 수행할 때 발생하는 Exception을 선언할 때 사용하는 키워드</li>
<li>예외를 던지는 것</li>
<li>현재 메소드에서 상위 메소드로 예외를 던집니다.</li>
<li>다시 말해, <strong>에외를 자신이 직접 처리하지 않고, 자신을 호출한 메소드에세 책임을 전가하는 것입니다.</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exception04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handlingException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handlingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main() 메소드에서 예외가 처리됨!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main() 메소드에서 예외가 처리됨!</span><br></pre></td></tr></table></figure>
<p>위의 코드는 <strong>throws</strong>를 사용하여 handlingException() 함수에서 발생한 예외를 전가시키는 예제입니다. 메소드를 정의할 때 <strong>throws</strong> 키워드를 추가하여 이 메소드를 호출하는 곳에서 예외 처리를 하도록 전가시킬 수 있습니다.</p>
<p><strong>handlingException() throws Exception</strong> 라는 문장을 해석해보자면, handlingException()라는 함수가 Exception 예외를 던진다는 뜻이므로 handlingException() 함수를 사용하는 곳(혹은 호출하는 곳)으로 예외를 던집니다.</p>
<p>여기서는 Main 함수에서 handlingException() 함수를 호출하였고 handlingException() 함수는 이 함수를 호출한 곳으로 예외를 던지기 때문에 Main 함수에서 예외를 처리해주어야 합니다. 하지만, 예외가 발생할 수 있기 때문에 앞에서 배운 에외 처리를 통해서 함수를 호출하는 문장을 try 블록으로 감싸줍니다. 그러면 여기서 예외가 발생하면 아래의 catch 블록으로 빠지게 되고, 결국에는 Main 함수에서 예외를 처리하게 됩니다.</p>
<h2 id="사용자-정의-예외-클래스">사용자 정의 예외 클래스</h2>
<p>자바에서는 Exception 클래스를 상속받아 자신만의 새로운 예외 클래스를 정의하여 사용할 수 있습니다.<br>
사용자 정의 예외 클래스에는 생성자뿐 아니라 필드 및 메소드도 원하는 만큼 추가할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    MyException(String errMsg)&#123;</span><br><span class="line">        <span class="keyword">super</span>(errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>요즘에는 위와 같이 Exception 클래스가 아닌 예외 처리를 강제하지 않는 RuntimeException 클래스를 상속받아 작성하는 경우가 많습니다.</p>
<h2 id="try-with-resources문">try-with-resources문</h2>
<p>Java SE 7 부터는 사용자 자원을 자동으로 해제해주는 try-with-resources 문을 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(파일을 열거나 자원을 할당하는 명령문)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 try 블록에 괄호 () 를 추가하여 파일을 열거나 자원을 할당하늠 명령문을 명시하면, 해당 try 블록이 끝나자마자 자동으로 파일을 닫거나 할당된 자원을 해제해줍니다.</p>
<p>다음은 파일에서 문자열을 한 줄 읽어오는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>)</span><br><span class="line">            br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 Java SE 7 이전에서는 finally 블록을 사용하여 사용한 파일을 닫아줘야 했습니다. 하지만 try-with-resources 문을 사용하면 다음과 같이 자동으로 파일의 닫기를 수행할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/02/java-basic-14/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/27/java-basic-13/"
                            aria-label=": [Java] 13. 제네릭"
                        >
                            [Java] 13. 제네릭
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-27T09:51:07+09:00">
	
		    Aug 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="제네릭generic">제네릭(Generic)</h1>
<hr>
<p>자바에서 제네릭(Generic)이란 데이터의 타입(data type)을 일반화(generalize)한다는 것을 의미합니다. <strong>제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다.</strong> 이렇게 컴파일 시에 미리 타입 검사(type check)를 수행하면 다음과 같은 장점을 가집니다.</p>
<ol>
<li>클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다.</li>
<li>반환값에 대한 타입 변환 및 검사에 들어가는 노력을 줄일 수 있습니다.</li>
</ol>
<p>JDK 1.5 이전에서는 여러 타입을 사용하는 대부분의 클래스나 메소드에서 인수나 반환값으로 Object 타입을 사용했습니다. 하지만 이 경우에는 반환된 Object 객체를 다시 원하는 타입으로 타입 변환해야 하며, 이 때 오류가 발생할 가능성도 존재합니다.<br>
하지만, JDK 1.5부터 도입된 제네릭을 사용하면 컴파일 시에 미리 타입이 정해지므로, 타입 검사나 타입 변환과 같은 번거로운 작업을 생략할 수 있게 됩니다.</p>
<h1 id="제네릭의-선언-및-생성">제네릭의 선언 및 생성</h1>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    T info;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;Integer&gt;();</span><br><span class="line">Person&lt;String&gt; person2 = <span class="keyword">new</span> Person&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>T</strong>를 타입 변수(type variable)이라고 하며, 임의의 참조형 타입을 의미합니다. 꼭 T뿐만 아니라 어떠한 문자를 사용해도 상관없으며, 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있습니다. 위의 코드처럼 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로도 사용할 수 있습니다.</p>
<p>T를 인스턴스화할 때, 꺽쇠 안에 있는 <strong>데이터 타입</strong>이 적용됩니다.</p>
<p>제네릭을 이용하여 클래스를 하나 정의하게 되면 클래스에서 정의한 변수에 대해 <strong>다양한 데이터 타입으로 인스턴스를 생성할 수 있습니다.</strong> 즉, 사용자 데이터 타입인 것입니다.</p>
<p>제네릭이 없는 상황의 코드에서는 코드의 중복이 발생할 수 있는데, 이 때 구현이 비슷한 두 클래스를 하나로 합칠 수가 있습니다. 변수의 데이터 타입을 지정하는 것은 그변수에 그 형식의 데이터 타입만 올 것이라는 것을 보장받을 수 있습니다. 그런데 Object로 처리를 하게 되면 어떠한 데이터도 들어올 수가 있습니다. 이것을 타입이 안전하지 않다라고 합니다.</p>
<blockquote>
<p>Javascript, Ruby on Rails 등에서는 타입 안전성에 대해서 free 합니다. 이런 언어를 typeless language라고 합니다.</p>
</blockquote>
<p>또한, <strong>제네릭으로는 참조형 데이터 타입만 올 수 있습니다.</strong> 기본 데이터 타입은 올 수 없습니다.(ex. int, char, double …) 하지만, <code>Wrapper class</code>를 사용해서 기본 데이터 타입을 객체처럼 만들어서 사용할 수 있습니다. 그런 클래스를 Wrapper class라고 합니다.</p>
<p>또한, Java SE 7부터 인스턴스 생성 시 타입을 추정할 수 있는 경우에는 다음과 같이 타입을 생략할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;Integer&gt; person1 = <span class="keyword">new</span> Person&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnimalList&lt;LandAnimal&gt; animalAnimalList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> LandAnimal());</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> cat());</span><br><span class="line">        animalAnimalList.add(<span class="keyword">new</span> dog());</span><br><span class="line">        <span class="comment">//animalAnimalList.add(new Sparrow()); 오류 발생</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;animalAnimalList.size();i++)&#123;</span><br><span class="line">           animalAnimalList.get(i).crying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        al.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.remove(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">육지 동물</span><br><span class="line">냐옹냐옹</span><br><span class="line">멍멍~~</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 cat과 dog 클래스는 LandAnimal 클래스를 상속받는 자식 클래스이므로, AnimalList<landanimal>에 추가할 수 있습니다. 하지만 Sparrow 클래스는 타입이 다르므로 추가할 수 없습니다.</landanimal></p>
<h1 id="제네릭의-제거-시기">제네릭의 제거 시기</h1>
<hr>
<p>자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환됩니다. 그리고서 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 됩니다. 이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서입니다.</p>
<h1 id="타입-변수의-제한">타입 변수의 제한</h1>
<hr>
<p>제네릭은 <strong>T</strong>와 같은 타입 변수(type variable)를 사용하여 타입을 제한합니다. 이 때, <code>extends</code> 키워드를 사용하면 타입 변수에 특정 타입만을 사용하도록 제한할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">예시</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WarmBlood</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">WarmBlood</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> &amp; <span class="title">WramBlood</span>&gt;</span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// implements 키워드를 사용해서는 안됨</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 클래스의 타입 변수에 제한을 걸어 놓으면 클래스 내부에서 사용된 모든 타입 변수에 제한이 걸립니다. 이 때에는 클래스가 아닌 인터페이스를 구현할 경우에도 implements 키워드가 아닌 extends 키워드를 사용해야만 합니다.</p>
<p>또한 클래스와 인터페이스를 동시에 상속받고 구현해야 한다면 마지막 코드처럼 <code>&amp;</code>기호를 사용하면 됩니다. 이 기호는 앰퍼센트라고 읽습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalList&lt;LandAnimal&gt; animalList1 = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 1</span></span><br><span class="line">        AnimalList&lt;cat&gt; animalList2 = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 2</span></span><br><span class="line">        AnimalList&lt;dog&gt; animalList = <span class="keyword">new</span> AnimalList&lt;&gt;(); <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// AnimalList&lt;Sparrow&gt; animalList3 = new AnimalList&lt;Sparrow&gt;(); 4</span></span><br><span class="line"></span><br><span class="line">        animalList1.add(<span class="keyword">new</span> LandAnimal());</span><br><span class="line">        animalList1.add(<span class="keyword">new</span> cat());</span><br><span class="line">        animalList1.add(<span class="keyword">new</span> dog());</span><br><span class="line">        <span class="comment">//animalAnimalList.add(new Sparrow());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;animalList1.size();i++)&#123;</span><br><span class="line">            animalList1.get(i).crying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span>&gt; </span>&#123;</span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        al.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.remove(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 타입 제한을 ’ AnimalList<t extends="" landanimal=""> ’ 걸게 되면 타입 변수에는 1번 처럼 LandAnimal 타입만 사용할 수 있도록 제한할 수 있습니다. 또한, 2,3번 처럼 LandAnimal을 상속한 자식 클래스까지도 사용할 수 있습니다. 하지만, 4번처럼 그 외의 클래스는 타입으로 사용할 수 없습니다.</t></p>
<p>만약 타입 변수를 제한하지 않는다면, 4번에서도 클래스를 정상적으로 사용할 수 있습니다.</p>
<h1 id="제네릭-메소드">제네릭 메소드</h1>
<hr>
<p>제네릭 메소드(generic method)란 메소드의 선언부에 타입 변수를 사용한 메소드를 의미합니다. 이 때 타입 변수의 선언은 메소드의 선언부에서 반환 타입 바로 앞에 위치합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>다음 코드에서 제네릭 클래스에서 정의된 타입 변수 T와 제네릭 메소드에서 사용된 타입 변수 T는 전혀 별개의 것임을 주의해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="와일드-카드의-사용">와일드 카드의 사용</h1>
<hr>
<p><code>와일드 카드(wild card)</code>란 이름에 제한을 두지 않음을 표현하는 데 사용되는 기호를 의미합니다. 자바의 제네릭에서는 물음표(?) 기호를 사용하여 이러한 와일드카드를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">문법</span><br><span class="line">&lt;?&gt; <span class="comment">// 타입 변수에 모든 타입을 사용할 수 있음</span></span><br><span class="line">&lt;? extends T&gt; <span class="comment">// T 타입과 T 타입을 상속받는 자식 클래스 타입만을 사용할 수 있음</span></span><br><span class="line">&lt;? <span class="keyword">super</span> T&gt; <span class="comment">// T 타입과 T 타입이 상속받은 조상 클래스 타입만을 사용할 수 있음</span></span><br></pre></td></tr></table></figure>
<p>다음은 클래스 메소드인 cryingAnimalList() 메소드의 매개변수의 타입을 와일드카드를 사용하여 제한하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">generics</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnimalList&lt;cat&gt; catList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        catList.add(<span class="keyword">new</span> cat());</span><br><span class="line">        AnimalList&lt;dog&gt; dogList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        dogList.add(<span class="keyword">new</span> dog());</span><br><span class="line">        AnimalList&lt;Sparrow&gt; sparrowList = <span class="keyword">new</span> AnimalList&lt;&gt;();</span><br><span class="line">        AnimalList.cryingAnimalList(catList);</span><br><span class="line">        AnimalList.cryingAnimalList(dogList);</span><br><span class="line">        <span class="comment">//AnimalList.cryingAnimalList(sparrowList); 오류</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ArrayList&lt;T&gt; al = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cryingAnimalList</span><span class="params">(AnimalList&lt;? extends LandAnimal&gt; al)</span> </span>&#123;</span><br><span class="line">        LandAnimal la = al.get(<span class="number">0</span>);</span><br><span class="line">        la.crying();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T animal)</span> </span>&#123; al.add(animal);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;<span class="keyword">return</span> al.get(index);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(T animal)</span> </span>&#123;<span class="keyword">return</span> al.remove(animal);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> al.size();&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"육지 동물"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"냐옹냐옹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">LandAnimal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"멍멍~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"짹"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">냐옹냐옹</span><br><span class="line">멍멍~~</span><br></pre></td></tr></table></figure>
<p>클래스 메소드인 cryingAniamlList() 메소드가 매개변수의 타입을 와일드카드를 사용하여 제한했습니다. 따라서 LandAnimal 타입과 그 타입을 상속받는 자식 클래스의 타입만 접근할 수 있기 때문에 4번은 오류가 발생하는 것입니다. 와일드카드를 사용한 타입 제한을 제거한다면 4번도 정상적으로 동작하게 됩니다.</p>
<h1 id="정리">정리</h1>
<hr>
<p>제네릭은 제한도 걸어놓을 수 있다고 합니다. 하지만, 지금은 이해가 가지 않네요… 조금 더 공부하다 보면 많은 내용을 알고 자료를 찾아가다 보면 이해가 되겠지요? ㅎㅎ</p>
<ul>
<li>상위 클래스를 만들어 준다. or 인터페이스를 만들어준다.</li>
<li>그리고 그 상위의 것에 extends 해준다. (상속과는 다르다)</li>
<li>just 부모가 누구냐만 밝혀주는 용도로 extends를 사용한다.</li>
<li>(인터페이스의 경우에도 extends를 사용한다. 따로 implements라는 표현을 사용하지 않는다.)</li>
<li>Tip &gt; super 부모를 제한하는 경우</li>
</ul>
<p>제네릭은 같은 기능을 하는 클래스를 여러 개 정의해야 한다는 불편함을 해소하면서 이것을 해소하기 위해 Object를 사용하게 되면 원하는 자료형에 대한 타입 변환을 해야 하고 또한, 안전성이 보장되지 않기 때문에 사용하는 것입니다.<br>
변수와 비슷한 개념인데도 값이 들어가는게 아니라 <strong>데이터 타입</strong>이 들어가는 것입니다.</p>
<blockquote>
<p>그렇다면 왜 제네릭을 알아야 하는가??</p>
</blockquote>
<p>앞으로 공부하게 될 컬렉션 프레임워크를 이애하기 위해 제네릭에 대한 이해가 필요합니다. <strong>Collection Framework</strong>에서 제네릭을 사용합니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/27/java-basic-13/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/22/android-tip/"
                            aria-label=": Android :: 깨알 팁"
                        >
                            Android :: 깨알 팁
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-22T17:31:58+09:00">
	
		    Aug 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>오늘은 안드로이드 스튜디오를 사용하면서 자신이 작성한 코드임을 명시할 수 있는 팁을 알려드리고자 합니다. :)</p>
<p><strong>Github</strong>에서 다른 사람이 작성한 코드를 참고해서 개발을 하는 경우가 많습니다. 저는 그렇게 하는데 다른 분들은 어떻게 하시는지…??ㅎㅎㅎ</p>
<p>아무튼!!! 다음과 같은 문장을 본 적이 있을 것입니다.</p>
<img src="/img/created.png" width="400" height="200">
<p>이 문장은 아무것도 아닌 것 같지만, 이렇게 명시함으로써 누가 코드를 작성했는지 알 수 있게 해줍니다. 다른 사람이랑 협업할 때 누가 작성한 코드인지 명확하게 볼 수 있어서 편리하다고 생각합니다. ㅎㅎㅎ</p>
<h1 id="설정-방법">설정 방법</h1>
<hr>
<ol>
<li>안드로이드 스튜디오 File</li>
<li>Settings</li>
<li>Editor</li>
<li>File and Code Templates를 선택합니다.</li>
<li>그리고 Includes 탭에 들어가면 아래와 같은 모습을 볼 수 있습니다.</li>
</ol>
<img src="/img/settings.png" width="400" height="200">
<ol start="6">
<li>그러면 + 버튼을 클릭해서 Lee와 같은 파일을 하나 생성합니다.</li>
<li>그리고 주석을 생성하고 그 안에 자신의 이름이나 자신이 원하는 문구를 작성합니다.</li>
<li>파일을 작성하고 Files 탭으로 넘어가서 아래 그림과 같이 위에서 만든 파일의 이름을 넣습니다.</li>
<li>그리고 Apply 버튼을 누르고 새 파일을 생성하면 문구가 자동으로 들어가는 것을 확인할 수 있습니다.</li>
</ol>
<img src="/img/settings2.png" width="400" height="200">
<ol start="10">
<li>이 방법 말고도 File Header를 수정하는 방법이 있습니다. 이것은 아래와 같은 방식으로 수정하면 됩니다. ^0^</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by $&#123;USER&#125; on $&#123;DATE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>별 내용은 아니지만, 혹시나 이런 것이 궁금하신 분들이 계실거 같아서 생각 난 김에 포스팅하고 갑니다~</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/22/android-tip/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/21/java-basic-12/"
                            aria-label=": [Java] 12. API 클래스-2"
                        >
                            [Java] 12. API 클래스-2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-21T11:44:33+09:00">
	
		    Aug 21, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="wrapper-클래스">Wrapper 클래스</h1>
<hr>
<p>프로그램에 따라 기본 타입의 데이터를 <strong>객체</strong>로 취급해야 하는 경우가 있습니다. 예를 들어, 메소드의 인수로 객체 타입만이 요구된다면, 기본 타입의 데이터를 그대로 사용할 수는 없습니다. 이 때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 합니다.</p>
<p>이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 <code>래퍼 클래스(Wrapper class)</code>라고 합니다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공됩니다.</p>
<img src="/img/wrapper.png" width="500" height="200">
<blockquote>
<p>래퍼 클래스 중에서 Integer 클래스와 Character 클래스만이 자신의 기본 타입과 이름이 다름을 주의해야 합니다.</p>
</blockquote>
<h2 id="박싱과-언박싱">박싱과 언박싱</h2>
<p>래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있습니다.</p>
<img src="/img/boxing.png" width="500" height="200">
<p>위의 그림과 같이 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정을 <code>박싱(Boxing)</code>이라고 합니다. 반면 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정은 <code>언박싱(UnBoxing)</code>이라고 합니다.</p>
<h2 id="오토-박싱과-오토-언박싱">오토 박싱과 오토 언박싱</h2>
<p>JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해 줍니다. 이렇게 자동화된 박싱과 언박싱을 <code>오토 박싱(AutoBoxing)</code>과 <code>오토 언방식(AutonUnBoxing)</code>이라고 부릅니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 박싱</span></span><br><span class="line">        <span class="keyword">int</span> number1 = num1; <span class="comment">// 언박싱</span></span><br><span class="line">        System.out.println(number1);</span><br><span class="line"></span><br><span class="line">        Character ch = <span class="string">'X'</span>; <span class="comment">// Character ch = new Character('X'); :오토박싱</span></span><br><span class="line">        <span class="keyword">char</span> c = ch; <span class="comment">// char c = ch.charValue();         :오토 언박싱</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure>
<p>위 예제에서 볼 수 있듯이 래퍼 클래스인 Integer 클래스와 Character 클래스에는 각각 언박싱을 위한 intValue() 메소드와 charValue() 메소드가 포함되어 있습니다.</p>
<p>또한, 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 Character 인스턴스를 생성할 수 있습니다.<br>
반대로 charValue() 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">7</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num2 = <span class="keyword">new</span> Integer(<span class="number">3</span>); <span class="comment">// 박싱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> int1 = num1.intValue();    <span class="comment">// 언박싱</span></span><br><span class="line">        <span class="keyword">int</span> int2 = num2.intValue();    <span class="comment">// 언박싱</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Integer result1 = num1 + num2; <span class="comment">// 1번 : 10</span></span><br><span class="line">        Integer result2 = int1 - int2; <span class="comment">// 2번 : 4</span></span><br><span class="line">        <span class="keyword">int</span> result3 = num1 * int2;     <span class="comment">// 3번 : 21</span></span><br><span class="line"></span><br><span class="line">        System.out.println(result1);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">        System.out.println(result3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>1번 : Integer 객체로 박싱된 객체들을 더하는 연산을 진행하고 있습니다. 하지만, 래퍼 클래스 타입의 객체들은 산술을 위해 정의된 클래스가 아니라고 했습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값을 참조할 수 있습니다. 따라서 산술 연산을 위해서 자바 컴파일러에 의해서 <strong>오토 언박싱</strong>되고, 산술 연산을 수행한 후의 결과 값인 10을 다시 <strong>오토 박싱</strong>하여 result1에 결과를 담게 됩니다.</p>
<p>2번 : 이미 언박싱 과정을 통해서 산술 연산이 가능해졌습니다. 따라서 두 값의 산술 연산을 진행한 후의 결과 값인 4를 <strong>오토 박싱</strong>하여 result2에 결과를 담게 됩니다.</p>
<p>3번 : 래퍼 클래스 타입의 객체와 기본형 타입인 int형 변수의 산술 연산입니다. 이를 위해서는 num1이 자동으로 오토 언박싱 되어서 산술 연산을 할 수 있도록 변환됩니다. 그리고 나서 산술 연산을 진행하고, 결과 값을 int형 변수인 result3에 담게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer num1 = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num2 = <span class="keyword">new</span> Integer(<span class="number">20</span>); <span class="comment">// 박싱</span></span><br><span class="line">        Integer num3 = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(num1&lt;num2); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(num1 == num3); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(num1.equals(num3)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n1 = num1;</span><br><span class="line">        <span class="keyword">int</span> n3 = num3;</span><br><span class="line">        System.out.println(n1 == n3); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>래퍼 클래스의 비교 연산도 오토 언박싱을 통해 가능하지만, 인스턴스에 저장된 값의 동등 여부 판단은 1번 라인처럼 비교 연산자인 <strong>동등 연산자</strong>( == )를 사용해서는 안되며, 2번 라인처럼 <strong>equals</strong>() 메소드를 사용해야만 합니다.</p>
<p>래퍼 클래스도 객체이므로 동등 연산자(==)를 사용하게 되면, 두 인스턴스의 값을 비교하는 것이 아니라 <strong>두 인스턴스의 주소값을 비교하게 됩니다.</strong> 따라서 서로 다른 두 인스턴스를 동등 연산자로 비교하게 되면, 언제나 false 값을 반환하게 됩니다.<br>
<strong>그러므로 인스턴스에 저장된 값의 동등 여부를 정확히 판단하려면 equals() 메소드를 사용해야만 합니다.</strong></p>
<p>num1과 num2에 들어있는 래퍼 클래스 타입의 객체 즉, 인스턴스는 서로 다른 주소값을 가지고 있지만 그 주소에 들어있는 값은 동일합니다. 이를 int형 변수인 n1과 n2에 각각 오토 언박싱을 하고 동등 연산자를 통해 비교해보면 true 값을 반환하는 것을 확인할 수 있습니다.<br>
이유는 인스턴스를 오토 언박싱을 통해서 기본 타입으로 변환했기 때문에 동등 연산자를 통해 비교해보면 같은 값임을 확인할 수 있습니다.</p>
<h1 id="enum-클래스">Enum 클래스</h1>
<hr>
<p>C언어와 C++에서는 열거체를 사용할 수 있지만, JDK 1.5 이전의 자바에서는 열거체를 사용할 수 없었습니다. 하지만,JDK 1.5부터는 C언어의 열거체보다 더욱 향상된 성능의 열거체를 정의한 Enum 클래스를 사용할 수 있습니다.</p>
<p>이와 같은 자바의 열거체는 다음과 같은 장점을 가집니다.</p>
<ol>
<li>열거체를 비교할 때 실제 값 뿐만 아니라 타입까지도 체크합니다.</li>
<li>열거체의 상숫값이 재정의되더라도 다시 컴파일할 필요가 없습니다.</li>
</ol>
<h2 id="열거체의-정의-및-사용">열거체의 정의 및 사용</h2>
<p>자바에서는 enum 키워드를 사용하여 열거체를 정의할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 열거체이름&#123; 상수<span class="number">1</span>이름, 상수<span class="number">2</span>이름 ...&#125;</span><br><span class="line"><span class="keyword">enum</span> Rainbow&#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용 방법</span></span><br><span class="line">열거체이름.상수이름</span><br><span class="line">Rainbow.RED</span><br></pre></td></tr></table></figure>
<h2 id="열거체의-상숫값-정의-및-추가">열거체의 상숫값 정의 및 추가</h2>
<p>위와 같이 정의된 열거체의 첫 번째 상숫값은 0부터 설정되며, 그 다음은 바로 앞의 상숫값보다 1만큼 증가되며 설정됩니다.</p>
<p>또한, 불규칙한 값을 상숫값으로 설정하고 싶으면 상수의 이름 옆에 괄호 (())을 추가하고, 그 안에 원하는 상숫값을 명시할 수 있습니다. 하지만, 이 때에는 불규칙한 특정 값을 저장할 수 있는 인스턴스 변ㅅ와 생성자를 다음과 같이 추가해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"상수값 : "</span>+Rainbow.RED.getValue()); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">"상수값 : "</span>+Rainbow2.RED.ordinal()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow &#123;</span><br><span class="line">        RED(<span class="number">3</span>), ORANGE(<span class="number">10</span>), YELLOW(<span class="number">11</span>), GREEN(<span class="number">23</span>), BLUE(<span class="number">4</span>), INDIGO(<span class="number">5</span>), VIOLET(<span class="number">17</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">        Rainbow(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Type&#123;</span><br><span class="line">        WALKING, RUNNING, HIKING</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">상수값 : <span class="number">3</span></span><br><span class="line">상수값 : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>1을 보면 불규칙한 상숫값을 설정하고 이 불규칙한 특정 값을 저장할 수 있는 인스턴스 변수와 생성자를 추가함으로써 상수값에 접근할 수 있습니다. 또한 2번에서는 상수값을 지정하지 않으면 첫 번째 상수값은 0부터 설정되어 순서대로 설정되므로 이 값에 접근하기 위해서는 <code>ordinal()</code> 메소드를 통해 접근할 수 있습니다.</p>
<h2 id="javalangenum-클래스">java.lang.Enum 클래스</h2>
<p>Enum 클래스는 모든 자바 열거체의 공통된 조상 클래스입니다. Enum 클래스에는 열거체를 조작하기 위한 다양한 메소드가 포함되어 있습니다.</p>
<h2 id="values-메소드">values() 메소드</h2>
<p><code>values()</code> 메소드는 해당 열거체의 모든 상수를 저장한 배열을 생성하여 반환합니다. 이 메소드는 자바의 모든 열거체에 컴파일러가 자동으로 추가해 주는 메소드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Rainbow2[] arr = Rainbow2.values();</span><br><span class="line">        <span class="keyword">for</span> (Rainbow2 rb : arr) &#123;</span><br><span class="line">            System.out.println(rb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow2 &#123;</span><br><span class="line">        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RED</span><br><span class="line">ORANGE</span><br><span class="line">YELLOW</span><br><span class="line">GREEN</span><br><span class="line">BLUE</span><br><span class="line">INDIGO</span><br></pre></td></tr></table></figure>
<h2 id="valueof-메소드">valueOf() 메소드</h2>
<p><code>valueOf()</code> 메소드는 전달된 문자열과 일치하는 해당 열거체의 상수를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Rainbow2.valueOf(<span class="string">"RED"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">enum</span> Rainbow2 &#123;</span><br><span class="line">        RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RED</span><br></pre></td></tr></table></figure>
<h2 id="ordinal-메소드">ordinal() 메소드</h2>
<p><code>ordinal()</code> 메소드는 해당 열거체 상수가 열거체 정의에서 <strong>정의된 순서</strong> (0부터 시작)를 반환합니다. 이 때, 반환되는 값은 열거체 정의에서 해당 열거체 상수가 정의된 순서이며, 상수값 자체가 아님을 명심해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Rainbow &#123; RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Rainbow.YELLOW.ordinal();</span><br><span class="line">        System.out.println(idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>다음 예제는 불규칙적인 상수값을 가지는 열거체에서 <code>ordinal()</code>메소드를 사용한 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Rainbow.YELLOW.ordinal());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Rainbow &#123;</span><br><span class="line">        RED(<span class="number">3</span>), ORANGE(<span class="number">10</span>), YELLOW(<span class="number">11</span>), GREEN(<span class="number">23</span>), BLUE(<span class="number">4</span>), INDIGO(<span class="number">5</span>), VIOLET(<span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        Rainbow(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="대표적인-enum-메소드">대표적인 Enum 메소드</h2>
<img src="/img/enum.png" width="700" height="200">
<h1 id="arrays-클래스">Arrays 클래스</h1>
<hr>
<p>Arrays 클래스를 다루기 전에 먼저 살펴보아야 할 것은 java.util 패키지입니다.<br>
java.util 패키지에는 프로그램을 개발하는 데 사용할 수 있는 유용한 유틸리티 클래스가 다수 포함되어 있습니다. 실제로 java.lang 패키지 다음으로 가장 많이 사용되는 패키지가 java.util 패키지입니다. 하지만, import문을 사용하지 않아도 바로 사용할 수 있는 java.lang 패키지와는 달리 java.util 패키지는 import문으로 패키지를 불러오고 나서야 클래스 이름만으로 사용할 수 있습니다.</p>
<h2 id="javautilarrays-클래스">java.util.Arrays 클래스</h2>
<p>Arrays 클래스에는 배열을 다루기 위한 다양한 메소드가 포함되어 있습니다. Arrays 클래스의 모든 메소드는 <strong>클래스 메소드</strong> (static method)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이 클래스는 반드시 import문으로 java.util 패키지를 불러오고 나서 사용해야 합니다.</p>
<h2 id="binarysearch-메소드">binarySearch() 메소드</h2>
<p><code>binarySearch()</code> 메소드는 전달받은 배열에서 <strong>특정 객체의 위치를 이진 검색 알고리즘을 사용하여 검색한 후, 해당 위치를 반환합니다.</strong><br>
이 메소드는 이진 검색 알고리즘을 사용하므로, 매개변수로 전달되는 배열이 sort() 메소드 등을 사용하여 <strong>미리 정렬되어 있어야만 제대로 동작합니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, <span class="number">437</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">437</span></span><br></pre></td></tr></table></figure>
<h2 id="copyof-메소드">copyOf() 메소드</h2>
<p><code>copyOf()</code> 메소드는 전달받은 배열의 특정 길이만큼을 새로운 배열로 복사하여 반환합니다.</p>
<p>copyOf() 메소드는 첫 번째 매개변수로 원본 배열을 전달받고, 두 번째 매개변수로 원본 배열에서 새로운 배열로 복사할 요소의 개수를 전달받습니다. 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다.</p>
<p>이 때, 새로운 배열의 길이가 원본 배열보다 길면, 나머지 요소는 배열 요소의 타입에 맞게 기본값으로 채워지게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOf(arr1, <span class="number">3</span>); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = Arrays.copyOf(arr1, <span class="number">10</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : arr3) &#123;</span><br><span class="line">            System.out.print(j + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>1번에서는 copyOf() 메소드를 사용하여 배열 arr1의 첫 번째 배열 요소부터 3개의 요소를 복사하여 배열 arr2에 대입하고 있습니다.<br>
2번에서는 배열 arr1에서 10개의 배열 요소를 복사하여 배열 arr3에 대입하려고 합니다. 하지만, 배열 arr1의 길이가 5밖에 되지 않으므로, 배열 arr3의 나머지 배열 요소에는 int형의 기본 값인 0이 채워지게 됩니다.</p>
<h2 id="copyofrange-메소드">copyOfRange() 메소드</h2>
<p><code>copyOfRange()</code> 메소드는 전달받은 배열의 특정 범위에 해당하는 요소만을 새로운 배열로 복사하여 반환합니다.</p>
<p>copyOfRange() 메소드는 첫 번째 매개변수로 복사의 대상이 될 원본 배열을 전달받습니다. 두 번째 매개변수로 원본 배열에서 복사할 시작 인덱스를 전달받고, 세 번째 매개변수로는 마지막으로 복사될 배열 요소의 다음 인덱스를 전달받습니다. <strong>즉, 세 번째 매개변수로 전달된 인덱스 바로 전까지의 배열 요소까지만 복사됩니다.</strong> 그리고 원본 배열과 같은 타입의 복사된 새로운 배열을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = Arrays.copyOfRange(arr1, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr2) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"아래는 원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : arr1) &#123;</span><br><span class="line">            System.out.print(j + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line">아래는 원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 배열이 복사되는 것을 확인할 수 있고, <strong>원본 배열이 변경되는 것이 아니라 원본 배열을 가지고 새로운 배열을 복사하는 것이기 때문에 원본 배열은 변경되지 않습니다.</strong></p>
<h2 id="fill-메소드">fill() 메소드</h2>
<p><code>fill()</code> 메소드는 전달받은 배열의 모든 요소를 특정 값으로 초기화해줍니다.</p>
<p>fill() 메소드는 첫 번째 매개변수로 초기화할 배열을 전달 받고, 두 번째 매개변수로 초기값을 전달받습니다. <strong>따라서 이 메소드는 전달받은 원본 배열의 값을 변경하게 됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"fill() 메소드 사용 후 원본 배열"</span>);</span><br><span class="line">        Arrays.fill(arr1, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">fill() 메소드 사용 후 원본 배열</span><br><span class="line"><span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="sort-메소드">sort() 메소드</h2>
<p><code>sort()</code> 메소드는 전달받은 배열의 모든 요소를 <strong>오름차순으로 정렬합니다.</strong></p>
<p>sort() 메소드는 매개변수로 정렬한 배열을 전달받으며, 따라서 이 메소드는 <strong>전달받은 원본 배열의 순서를 변경하게 됩니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">"원본 배열"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"sort() 메소드 사용 후 원본 배열"</span>);</span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i:arr1) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 배열</span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> </span><br><span class="line">sort() 메소드 사용 후 원본 배열</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="대표적인-arrays-메소드">대표적인 Arrays 메소드</h2>
<p>Arrays 클래스의 메소드는 매우 다양하며, 그 중에서 많이 사용되는 메소드는 다음과 같습니다.</p>
<img src="/img/arrays.png" width="700" height="200">
<h1 id="calendar-클래스">Calendar 클래스</h1>
<hr>
<h2 id="자바에서의-날짜-및-시간-처리">자바에서의 날짜 및 시간 처리</h2>
<p>JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 간단한 처리만을 수행할 수 있었습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(deprecated) 있습니다.</p>
<p>JDk 1.1부터는 새롭게 제공되는 <strong>Calendar</strong> 클래스를 이용하여 날짜와 시간에 관한 처리를 수행하게 됩니다. 하지만 이러한 Calendar 클래스는 다음과 같은 문제점을 안고 있습니다.</p>
<ol>
<li>Calendar 인스턴스는 불변 객체가 아니라서 값이 수정될 수 있습니다.</li>
<li>윤초(leap second)와 같은 특별한 상황을 고려하지 않았습니다.</li>
<li>Calendar 클래스에서는 월(month)을 나타낼 때, 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.</li>
</ol>
<p>따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 <code>Joda-Time</code>이라는 라이브러를 함께 사용해왔습니다.</p>
<p>Java SE 8 버전에서는 이러한 Joda-Time 라이브러리르 발전시킨 새로운 날짜와 시간 API인 <code>java.time</code> 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 패키지를 포함하고 있습니다.</p>
<p>더 자세한 내용을 추후에 공부하겠습니다. :D</p>
<h2 id="javautilcalendar-클래스">java.util.Calendar 클래스</h2>
<p>Calendar 클래스는 자바에서 날짜와 시간에 관한 데이터를 손쉽게 처리할 수 있도록 제공하는 추상 클래스입니다. 이 클래스가 추상 클래스로 선언된 이유는 나라마다 사용하는 달력 체계가 조금씩 다를 수 있기 때문입니다.</p>
<p>이러한 Calendar 클래스에는 날짜와 시간을 처리하기 위한 다양한 필드와 메소드가 포함되어 있습니다. Calendar 클래스의 모든 필드는 클래스 변수(static variable)이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다.</p>
<h2 id="javautilgregoriancalendar-클래스">java.util.GregorianCalendar 클래스</h2>
<p>현재 전 세계적으로 가장 많이 사용되는 달력은 1582년 교황 그레고리오 13세가 개혁한 그레고리오 달력입니다. Calendar 클래스는 추상 클래스이므로, 직접 인스턴스를 생성할 수 없습니다. GregorianCalendar 클래스는 이러한 Calendar 클래스를 상속받아 그레고리오 달력을 완전히 구현한 하위 클래스입니다.</p>
<h2 id="add-메소드">add() 메소드</h2>
<p><code>add()</code> 메소드는 전달된 Calendar 필드에서 일정 시간 만큼을 더하거나 빼줍니다. 즉, 특정 시간을 기준으로 일정 시간 전후의 날짜와 시간을 알 수 있습니다.</p>
<p>아래는 현재 시각에 1시간을 더하는 예제입니다.:)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time = Calendar.getInstance();</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line"></span><br><span class="line">        time.add(Calendar.HOUR, <span class="number">1</span>);</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">43</span> KST <span class="number">2018</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">13</span>:<span class="number">32</span>:<span class="number">43</span> KST <span class="number">2018</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Calendar 클래스에 메소드는 현재 시각을 기준으로 동작하기 때문에, 이 예제를 보고 따라하신다면 다른 결과값을 얻을 수 있습니다.</p>
</blockquote>
<h2 id="before와-after-메소드">before()와 after() 메소드</h2>
<p>두 시간상의 전후 관계만을 알고 싶을 경우에는 before()와 after() 메소드를 사용할 수 있습니다. <code>before()</code> 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 앞서는지를 판단하고, 결과를 true/false로 반환합니다. 반대로 <code>after()</code> 메소드는 현재 Calendar 인스턴스가 전달된 객체가 나타내는 시간보다 나중인지를 판단하고, 결과를 true/false로 판단합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time1 = Calendar.getInstance();</span><br><span class="line">        Calendar time2 = Calendar.getInstance();</span><br><span class="line">        Calendar time3 = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        time2.set(<span class="number">1994</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        time3.set(<span class="number">2020</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        System.out.println(time1.before(time2));</span><br><span class="line">        System.out.println(time1.before(time3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h2 id="get-메소드">get() 메소드</h2>
<p><code>get()</code> 메소드는 전달된 Calendar 필드에 저장된 값을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time = Calendar.getInstance();</span><br><span class="line">        System.out.println(time.getTime());</span><br><span class="line"></span><br><span class="line">        System.out.println(time.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">        System.out.println(time.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(time.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(time.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">        System.out.println(time.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(time.get(Calendar.SECOND));</span><br><span class="line">        System.out.println(time.get(Calendar.YEAR));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Wed Aug <span class="number">22</span> <span class="number">12</span>:<span class="number">47</span>:<span class="number">34</span> KST <span class="number">2018</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>
<h2 id="roll-set-메소드">roll(), set() 메소드</h2>
<p><code>roll()</code> 메소드는 전달된 Calendar 필드에 일정 시간 만큼을 더하거나 빼줍니다. 하지만, add() 메소드와는 달리 다른 Calendar 필드에는 영향을 주지 않습니다. 즉, 계산 결과가 해당 필드의 최댓값이나 최솟값을 넘어가도 다른 필드에 영향을 주지 않습니다.</p>
<p><code>set()</code> 메소드는 전달된 Calendar 필드를 특정 값으로 설정합니다. 아래의 코드에서 add(), roll() , set() 메소드를 사용하는 것을 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar time1 = Calendar.getInstance();</span><br><span class="line">        Calendar time2 = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 같은 시간으로 설정</span></span><br><span class="line">        time1.set(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">50</span>);</span><br><span class="line">        time2.set(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        time1.add(Calendar.SECOND, <span class="number">15</span>);</span><br><span class="line">        time2.roll(Calendar.SECOND, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">"add() 메소드 호출 후 : "</span>+time1.getTime());</span><br><span class="line">        System.out.println(<span class="string">"roll() 메소드 호출 후 : "</span>+time2.getTime());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">add() 메소드 호출 후 : Wed Jul <span class="number">27</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">05</span> KST <span class="number">1994</span></span><br><span class="line">roll() 메소드 호출 후 : Wed Jul <span class="number">27</span> <span class="number">12</span>:<span class="number">34</span>:<span class="number">05</span> KST <span class="number">1994</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 add() 메소드를 사용하여 Calendar.SECOND를 15초 증가시키면 결과적으로 Calendar.MINUTE 필드가 1 증가하게 됩니다.<br>
하지만, roll() 메소드를 사용하여 Calendar.SECOND 필드를 15초 증가시키면 Calendar.MINUTE 필드에는 아무런 영향을 주지 않는 것을 확인할 수 있습니다.<br>
즉, Calendar.SECOND 필드만이 15초 증가하여 출력됩니다.</p>
<h2 id="대표적인-calendar-메소드">대표적인 Calendar 메소드</h2>
<img src="/img/calendar.png" width="700" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/21/java-basic-12/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2018/archives/5/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2018/archives/7/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 6 of 13</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
