
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2018 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2018/archives/7/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/20/9012/"
                            aria-label=": BOJ :: 9012"
                        >
                            BOJ :: 9012
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-20T23:22:36+09:00">
	
		    Aug 20, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>알고리즘을 다시 풀려고 하는데, 기억이 하나도 나지 않아서 차근 차근 자바 문법부터 보고 있습니다…ㅎㅎ 하지만, 뭔가 알고리즘을 빨리 시작해서 공부해야 한다는 부담감이 조금씩 있죠… 하지만, 지금의 상황에서는 여러 가지를 하면서 진도를 많이 나가지 못하는 것보다는 범위를 좁혀서 빠르게 공부하는 게 나을 것 같다는 생각을 했습니다…!</p>
<p>그래서 이번 알고리즘 문제까지 풀고 당분간 우선 순위를 잡아 놓은 것들을 해결하고 나서야 다시 알고리즘을 꾸준하게 풀 수 있을 것 같습니다…ㅜㅜ 조급해 할 필요는 없고 시작하기 위한 기초를 잘 다지기 위한 과정이니까 조급해 하지 맙시다 ^^</p>
<p><code>문제</code></p>
<p>괄호 문자열이 주어졌을 때, 올바른 괄호 문자열인지 아닌지를 판단하는 문제입니다.<br>
괄호 문자열 : ( 와 )로만 이루어진 문자열<br>
올바른 괄호 문자열 : 괄호의 쌍이 올바른 문제</p>
<p><strong>문제</strong> : <a href="https://www.acmicpc.net/problem/9012" target="_blank" rel="noopener">https://www.acmicpc.net/problem/9012</a></p>
<p><code>풀이</code></p>
<ul>
<li>여는 괄호 : (</li>
<li>닫는 괄호 : )</li>
</ul>
<p>닫는 괄호의 입장에서 닫는 괄호와 짝이 맞는 여는 괄호는 어디에 있을까요?</p>
<ol>
<li>왼쪽에 있어야 합니다.</li>
<li>아직 짝이 맞지 않아야 합니다.</li>
<li>1과 2와 해당하는 문자 중에서 가장 오른쪽에 있는 괄호가 어떤 닫는 괄호가 있었을 때 그 닫는 괄호와 짝이 맞는 여는 괄호를 의미하게 됩니다.</li>
</ol>
<p>이 성질을 이용해서 Stack을 이욜해서 풀 수 있다.<br>
1 -&gt; 어떤 순서로 문자열을 검사할 것인지를 판단할 수 있습니다.<br>
2 -&gt; 2번에 해당하는 여는 괄호를 차례대로 스택에 넣습니다.<br>
그렇다면 스택에 있는 괄호는 아직 짝이 맞지 않는 괄호이기 때문에 가장 오른쪽에 있는 괄호는 Stack의 top을 의미하게 됩니다. 따라서 stack을 이용하면 시간 복잡도는 O(1)로 줄일 수 있게 됩니다.</p>
<ul>
<li>Stack을 이용해서 올바른 괄호 문자열인지 아닌지를 알 수 있습니다.</li>
<li>( 가 나오면 스택에 (를 넣고 )가 나오면 스택에서 하나를 빼서 (인지 확인합니다.</li>
<li>또는 하나를 뺄 수 있는지를 확인합니다.</li>
</ul>
<p>경우는 세 가지로 나눠 볼 수 있습니다.</p>
<ol>
<li>닫는 괄호가 나왔는데 스택이 비어있는 경우 -&gt; 올바른 문자열이라고 할 수 없습니다. 왜냐하면 닫는 괄호에 해당하는 여는 괄호가 없기 때문입니다.</li>
<li>모든 과정이 끝났고, 스택이 비어있는 경우 -&gt; 올바른 문자열이라고 할 수 있습니다.</li>
<li>모든 과정이 끝났는데, 스택이 비어있지 않은 경우 -&gt; 여는 괄호에 대한 닫는 괄호가 없기 때문입니다.</li>
</ol>
<p>하지만, 다시 생각해보면 스택에는 어차피 여는 괄호를 넣습니다. 따라서 스택에 무엇이 들어있는지 보다는 몇개가 들어있는지가 중요한 문제입니다. 즉, count 변수를 선언해서 체크함으로써 해결 가능합니다.</p>
<p><code>코드</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ9012</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> test_case = sc.nextInt();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_case; i++) &#123;</span><br><span class="line">            System.out.println(check(sc.nextLine()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">check</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                count -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123; <span class="comment">// 닫는 괄호에 대한 여는 괄호가 스택에 없음. 문자열에 닫는 괄호가 있어서 count가 음수</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"NO"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123; <span class="comment">// 스택이 비어있음. 올바른 문자열</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"YES"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 스택이 비어있지 않음. 올바르지 못한 문자열</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"NO"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/20/9012/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/20/java-basic-11/"
                            aria-label=": [Java] 11. API 클래스-1"
                        >
                            [Java] 11. API 클래스-1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-20T10:14:45+09:00">
	
		    Aug 20, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="object-클래스">Object 클래스</h1>
<hr>
<p>java.lang 패키지 중에서도 가장 많이 사용되는 클래스는 바로 <strong>Object</strong> 클래스입니다. Object 클래스는 모든 자바 클래스의 최고 조상 클래스가 됩니다. 따라서 자바의 모든 클래스는 <strong>Object</strong> 클래스의 모든 메소드를 바로 사용할 수 있습니다.</p>
<h2 id="tostring메소드">toString()메소드</h2>
<p>toString() 메소드는 해당 인스턴스에 대한 정보를 <code>문자열</code>로 반환합니다. 이 때 반환되는 문자열은 클래스 이름과 함께 구분자로 '@'가 사용되며, 그 뒤로 16진수 해시 코드가 추가됩니다.<br>
16진수 해시 코드 값은 인스턴스의 주소를 가리키는 값으로, 인스턴스마다 모두 다르게 반환됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">System.out.println(car1.toString());</span><br><span class="line">System.out.println(car2.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">com.company.Car@<span class="number">60e53</span>b93</span><br><span class="line">com.company.Car@<span class="number">5e2</span>de80c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>자바에서 toString() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다.</p>
</blockquote>
<h2 id="equals-메소드">equals() 메소드</h2>
<p>equals() 메소드는 해당 인스턴스를 매개변수로 전달받은 참조 변수와 비교하여, 그 결과를 반환합니다. 이 때, 참조 변수가 가리키는 값을 비교하므로, 서로 다른 두 객체는 언제나 false를 반환하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Car car1 = <span class="keyword">new</span> Car();</span><br><span class="line">Car car2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">System.out.println(car1.equals(car2));</span><br><span class="line">car1 = car2; <span class="comment">// 두 참조 변수가 같은 주소를 가리킴 </span></span><br><span class="line">System.out.println(car1.equals(car2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>자바에서 equals() 메소드는 기본적으로 각 API 클래스마다 자체적으로 오버라이딩을 통해 재정의되어 있습니다.</p>
</blockquote>
<h2 id="clone-메소드">clone() 메소드</h2>
<p>clone() 메소드는 해당 인스턴스를 복제하여, 새로운 인스턴스를 반환합니다. 하지만 Object 클래스의 clone() 메소드는 단지 필드의 값만을 복사하므로, 필드의 값이 배열이나 인스턴스이면 제대로 복제할 수 없습니다.<br>
따라서 이러한 경우에는 해당 클래스에서 clone() 메소드를 오버라이딩하여, 복제가 제대로 이루어지도록 재정의해야 합니다.</p>
<p>이러한 clone() 메소드는 데이터의 보호를 이유로 <strong>Cloneable</strong> 인터페이스를 구현한 클래스의 인스턴스만이 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car01 = <span class="keyword">new</span> Car(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">        car01.setModelName(<span class="string">"아반떼"</span>);</span><br><span class="line">        car01.setOwners(<span class="string">"홍길동"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Car01 : "</span> + car01.getModelName() + <span class="string">", "</span> + car01.getOwners() + <span class="string">"\n"</span>); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Car car02 = (Car) car01.clone(); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">        car02.setOwners(<span class="string">"이순신"</span>); <span class="comment">// 8</span></span><br><span class="line">        System.out.println(<span class="string">"Car01 : "</span> + car01.getModelName() + <span class="string">", "</span> + car01.getOwners()); <span class="comment">// 9</span></span><br><span class="line">        System.out.println(<span class="string">"Car02 : "</span> + car02.getModelName() + <span class="string">", "</span> + car02.getOwners()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String modelName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; owners = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModelName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelName;</span><br><span class="line">    &#125;                    <span class="comment">// modelName의 값을 반환함</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModelName</span><span class="params">(String modelName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">    &#125; <span class="comment">// modelName의 값을 설정함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">getOwners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.owners;</span><br><span class="line">    &#125;                      <span class="comment">// owners의 값을 반환함</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOwners</span><span class="params">(String ownerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.owners.add(ownerName);</span><br><span class="line">    &#125;   <span class="comment">// owners의 값을 추가함</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Car clonedCar = (Car) <span class="keyword">super</span>.clone(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// clonedCar.owners = (ArrayList)owners.clone(); 3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> clonedCar;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException ex) &#123; <span class="comment">// 4</span></span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Car01 : 아반떼, [홍길동]</span><br><span class="line"></span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 2번에서는 부모 클래스의 <strong>clone()</strong> 메소드를 호출하여 clone() 메소드를 오버라이딩하고 있습니다. 5번에서는 Car 클래스의 인스턴스인 <strong>car01</strong>을 생성하고, 7번에서는 오버라이딩한 clone() 메소드를 호출하여 복제를 수행하고 있습니다.</p>
<p>하지만, 2번처럼 clone() 메소드를 재정의하면, 필드의 값이 1번처럼 인스턴스일 때는 제대로 된 복제를 수행할 수 없습니다.<br>
8번에서는 복제된 인스턴스인 <strong>car02</strong>의 owners 필드에 새로운 값을 하나 추가합니다. 하지만 9번의 실행 결과를 보면, 7번에서의 결과와는 달리 원본 인스턴스인 <strong>car01</strong>의 owners 필드에도 새로운 값이 추가되었음을 확인할 수 있습니다.<br>
이처럼 단순히 부모 클래스의 clone() 메소드를 호출하여 clone() 메소드를 재정의하면, 배열이나 인스턴스인 필드는 복제되는 것이 아닌 해당 배열이나 인스턴스를 가리키는 주소값만이 복제되는 것입니다.</p>
<p>따라서 정확한 복제를 위해서는 3번처럼 배열이나 인스턴스인 필드에 대해서는 별도로 clone() 메소드를 구현하여 호출해야 합니다.<br>
3번의 주석을 해제하고 결과를 보면 다음과 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car01 : 아반떼, [홍길동]</span><br><span class="line"></span><br><span class="line">Car02 : 아반떼, [홍길동]</span><br><span class="line">Car02 : 아반떼, [홍길동, 이순신]</span><br></pre></td></tr></table></figure>
<h2 id="object-클래스의-메소드">Object 클래스의 메소드</h2>
<img src="/img/object.png" width="600" height="200">
<h1 id="string-클래스">String 클래스</h1>
<hr>
<p>자바에서는 문자열을 위한 <strong>String</strong>이라는 클래스를 별도로 제공합니다. String 클래스에는 문자열과 관련된 작업을 할 때 유용하게 사용할 수 있는 다양한 메소드가 포함되어 있습니다. 이러한 String 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<p>String 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 이러한 객체를 자바에서는 <code>불변 객체(immutable object)</code>라고 합니다. 즉, 자바에서 덧셈(+) 연산자를 이용하여 문자열 결합을 수행하면, 기존 문자열의 내용이 변경되는 것이 아니라 내용이 합쳐진 새로운 String 인스턴스가 생성되는 것입니다.</p>
<h2 id="charat-메소드">charAt() 메소드</h2>
<p><code>charAt()</code> 메소드는 해당 문자열의 특정 인덱스에 해당하는 문자를 반환합니다. 만약 해당 문자열의 길이보다 큰 인덱스나 음수를 전달하면, <strong>IndexOutOfBoundsException</strong> 오류가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">api</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            System.out.print(str.charAt(i)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"charAt() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">J a v a </span><br><span class="line">charAt() 메소드 호출 후 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="comparto-메소드">comparTo() 메소드</h2>
<p>compareTo() 메소드는 해당 문자열을 인수로 전달된 문자열과 사전 편찬 순으로 비교합니다. <strong>이 메소드는 문자열을 비교할 때 대소문자를 구분하여 비교합니다.</strong> 만약 두 문자열이 같다면 0을 반환하며, 해당 문자열인 인수로 전달된 문자열보다 작으면 음수를, 크면 양수를 반환합니다.</p>
<p>만약 문자열을 비교할 때 대소문자를 구분하지 않기를 원하면, <strong>compareToIgnoreCase()</strong> 메소드를 사용하면 됩니다.</p>
<p>쉽게 말해서 다음과 같은 문자열이 있다고 생각해봅시다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"abcf"</span>)); <span class="comment">// 1</span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"abbb"</span>)); <span class="comment">// 2 </span></span><br><span class="line">System.out.println(str.compareTo(<span class="string">"Abcd"</span>)); <span class="comment">// 3</span></span><br><span class="line">System.out.println(str.compareToIgnoreCase(<span class="string">"ABCD"</span>)); <span class="comment">// 4</span></span><br><span class="line">System.out.println(<span class="string">"compareTo() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">원본 문자열 : abcd</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">compareTo() 메소드 호출 후 문자열 : abcd</span><br></pre></td></tr></table></figure>
<p>1 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abcf&quot;보다 사전순으로 먼저 존재하고, 이를 작다고 표현하며 음수를 반환합니다.<br>
2 -&gt; 이 경우 문자열 &quot;abcd&quot;가 인수로 전달된 문자열 &quot;abbb&quot;보다 사전순으로 뒤에 존재하고, 이를 크다고 표현하며 양수를 반환합니다.<br>
3 -&gt; 사전 순으로 대문자가 먼저 존재하고, 소문자가 존재하는 것으로 파악됩니다.<br>
4 -&gt; compareToIgnoreCase() 메소드를 사용함으로써 대소문자를 구분하지 않고 비교합니다.</p>
<h2 id="concat-메소드">concat() 메소드</h2>
<p><code>concat()</code> 메소드는 해당 문자열의 뒤에 인수로 전달된 문자열을 추가한 새로운 문자열을 반환합니다. 만약 인수로 전달된 문자열의 길이가 0이면, 해당 문자열을 그대로 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line">System.out.println(str.concat(<span class="string">"수업"</span>));</span><br><span class="line">System.out.println(<span class="string">"concat() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">Java수업</span><br><span class="line">concat() 메소드 호출 후 원본 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="indexof-메소드">indexOf() 메소드</h2>
<p><code>indexOf()</code> 메소드는 해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환합니다. 만약 해당 문자열에 전달된 문자나 문자열이 포함되어 있지 않으면 -1을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Oracle Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'o'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">'a'</span>));</span><br><span class="line">System.out.println(str.indexOf(<span class="string">"Java"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"indexOf() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Oracle Java</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line">indexOf() 메소드 호출 후 원본 문자열 : Oracle Java</span><br></pre></td></tr></table></figure>
<p><strong>위의 예제처럼 indexOf() 메소드는 문자나 문자열을 찾을 때 대소문자를 구분합니다.</strong></p>
<h2 id="trim-메소드">trim() 메소드</h2>
<p><code>trim()</code> 메소드는 해당 문자열의 맨 앞과 맨 뒤에 포함된 모든 공백 문자를 제거해줍니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"  Java   "</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">System.out.println(str + <span class="string">'|'</span>);</span><br><span class="line">System.out.println(str.trim() + <span class="string">'|'</span>);</span><br><span class="line">System.out.println(<span class="string">"trim() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 :   Java   </span><br><span class="line">  Java   |</span><br><span class="line">Java|</span><br><span class="line">trim() 메소드 호출 후 원본 문자열 :   Java</span><br></pre></td></tr></table></figure>
<h2 id="tolowercase-touppercase-메소드">toLowerCase(), toUpperCase() 메소드</h2>
<ul>
<li>toLowerCase() : 해당 문자열의 모든 문자를 소문자로 변환시켜 줍니다.</li>
<li>toUpperCase() : 해당 문자열의 모든 문자를 대문자로 변환시켜 줍니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">원본 문자열 : Java</span><br><span class="line">java</span><br><span class="line">JAVA</span><br><span class="line">trim() 메소드 호출 후 원본 문자열 : Java</span><br></pre></td></tr></table></figure>
<h2 id="대표적인-string-메소드">대표적인 String 메소드</h2>
<img src="/img/string1.png" width="700" height="200">
<img src="/img/string2.png" width="700" height="200">
<h1 id="stringbuffer-클래스">StringBuffer 클래스</h1>
<hr>
<p>String 클래스의 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수는 없습니다. 하지만, <code>StringBuffer</code> 클래스의 인스턴스는 그 값을 변경할 수도 있고, 추가할 수도 있습니다.</p>
<p>이를 위해 <code>StringBuffer</code> 클래스는 내부적으로 버퍼(Buffer)라고 하는 독립적인 공간을 가집니다. 버퍼 크기의 기본값은 16개의 문자를 저장할 수 있는 크기이며, 생성자를 통해 그 크기를 별도로 설정할 수 있습니다. 하지만, 인스턴스 생성 시 사용자가 설정한 크기보다 언제나 16개의 문자를 더 저장할 수 있도록 여유 있는 크기로 생성됩니다.(즉, 두배씩 증가한다는 말입니다. 16-&gt;32-&gt;64 …)</p>
<p>덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성합니다. 따라서 문자열을 많이 결합하면 결합할수록 공간의 낭비뿐만 아니라 속도 또한 매우 느려지게 됩니다.</p>
<p>하지만, <strong>StringBuffer</strong> 인스턴스를 사용하면 문자열을 바로 추가할 수 있으므로, 공간의 낭비도 없으며 속도도 매우 빨라집니다. 이러한 StringBuffer 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<blockquote>
<p>짚고 넘어가기~</p>
</blockquote>
<p>String 클래스를 이용해서 객체를 생성하면, 그 인스턴스는 읽을 수만 있고 값을 변경할 수는 없습니다. 이를 코드를 통해서 확인해보겠습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"이승우"</span>);</span><br><span class="line">System.out.println(str1.hashCode());</span><br><span class="line">str1 = <span class="string">"정지현"</span>;</span><br><span class="line">System.out.println(str1.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span>번 : <span class="number">50664843</span></span><br><span class="line"><span class="number">2</span>번 : <span class="number">50879257</span></span><br></pre></td></tr></table></figure>
<p>위의 개념대로라면 str1의 값은 읽기만 가능하고, 변경할 수는 없습니다. 하지만, 위의 코드는 정상적으로 실행됩니다. 그렇다면 값을 읽을 수만 있고 변경할 수는 없다는 것은 무슨 뜻일까요??</p>
<p>처음에 str1은 문자열이 &quot;이승우&quot;이고, <strong>50664843</strong>라는 주소를 가지고 있는 인스턴스를 참조하고 있습니다. 이 공간에 있는 값은 읽을 수만 있고 변경할 수는 없습니다. <code>str1 = &quot;정지현&quot;;</code>을 통해서 값을 변경하려고 한다면, 새로운 공간을 할당하고 그 공간에 문자열을 집어넣습니다. 그 결과로 str1은 문자열이 &quot;정지현&quot;이고, <strong>50879257</strong>라는 주소를ㄹ 가지고 있는 인스턴스를 참조하게 됩니다. 따라서 원래의 공간에 있는 값은 변경되지 않고, str1이 참조하고 있는 공간이 바뀌는 것입니다.</p>
<p>정리하면, String 클래스의 값을 변경한다는 것은 str1 인스턴스가 새롭게 생성되고, 이렇게 생성된 인스턴스의 공간은 str1이 참조하게 되는 것입니다. 그리고 그 전의 인스턴스는 공간을 차지하면서, 누구도 참조하지 않게 되고 이로 인해서 공간의 낭비는 발생하게 되고, 속도도 느려지는 것입니다.</p>
<h2 id="불변클래스와-가변-클래스">불변클래스와 가변 클래스</h2>
<p>String 클래스와 같이 인스턴스가 한 번 생성되면 그 값을 변경할 수 없는 클래스를 <strong>불변 클래스(immutable class)</strong> 라고 합니다.<br>
반대로 StringBuffer 클래스와 같이 자유롭게 인스턴스의 값을 변경할 수 있는 클래스를 **가변 클래스(mutable class)**라고 합니다.<br>
String 클래스와 같은 불변 클래스는 StringBuffer 클래스의 append()나 insert() 메소드와 같이 값을 변경하는 set 메소드를 포함하지 않습니다.</p>
<p>이렇게 불편하기만 할 것 같은 불변 클래스를 사용하는 이유는 멀티 스레드 환경에서 객체가 변화되는 상황이라면 불변 인스턴스를 사용하는 것이 좀 더 신뢰할 수 있는 코드를 작성할 수 있기 때문입니다.<br>
즉, 하나의 객체에 접근하면서 각각의 객체가 서로 영향을 주어서는 안되는 경우에 불변 인스턴스를 사용하면 값이 변하지 않는다는 점이 보장됩니다.</p>
<h2 id="append-메소드">append() 메소드</h2>
<p><code>append()</code>메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가합니다. 이 메소드는 String 클래스의 concat() 메소드와 같은 결과를 반환하지만, <strong>내부적인 처리 속도가 훨씬 빠릅니다.</strong></p>
<p>이유는 String 클래스의 concat() 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 마지막에 추가하지만, 원본 문자열에 추가하는 것이 아니라 문자열을 추가한 새로운 인스턴스를 생성하는 것이고, <strong>append()</strong> 메소드는 원본 문자열에 인수로 전달된 문자열을 추가하는 것이기 때문에 처리 속도가 빠른 것입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">        System.out.println(str.append(<span class="string">"수업"</span>));</span><br><span class="line">        System.out.println(<span class="string">"append() 메소드 호출 한 후 문자열 : "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java</span><br><span class="line">Java수업</span><br><span class="line">append() 메소드 호출 한 후 문자열 : Java수업</span><br></pre></td></tr></table></figure>
<h2 id="capacity-메소드">capacity() 메소드</h2>
<p><code>capacity()</code> 메소드는 StringBuffer 인스턴스의 현재 버퍼 크기를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StringBuffer str1 = <span class="keyword">new</span> StringBuffer(<span class="string">"Java"</span>);</span><br><span class="line">        StringBuffer str2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(str1.capacity());</span><br><span class="line">        System.out.println(str2.capacity());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 길이가 4인 문자열로 StringBuffer 인스턴스를 생성하면, 기본적으로 생성되는 여유 버퍼 크기인 16에 문자의 길이인 4를 더한 총 20개의 문자를 저장할 수 있는 버퍼가 생성되는 것을 확인할 수 있습니다.</p>
<h2 id="delete-메소드">delete() 메소드</h2>
<p><code>delete()</code> 메소드는 전달된 인덱스에 해당하는 부분 문자열을 해당 문자열에서 제거합니다. 또한, deleteCharAt() 메소드를 사용하면 특정 위치의 문자 한 개만을 제거할 수도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java Oracle"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span> + str);</span><br><span class="line"></span><br><span class="line">        System.out.println(str.delete(<span class="number">4</span>, <span class="number">8</span>)); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(str.deleteCharAt(<span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(<span class="string">"deleteCharAt() 메소드 호출 후 원본 문자열 : "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java Oracle</span><br><span class="line">Javacle</span><br><span class="line">Jvacle</span><br><span class="line">deleteCharAt() 메소드 호출 후 원본 문자열 : Jvacle</span><br></pre></td></tr></table></figure>
<p>1번에서는 delete() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치의 문자부터 8보다 하나 적은 7인 위치의 문자까지를 삭제하고 있습니다. 이처럼 delete() 메소드는 첫 번째 매개변수로 전달된 인덱스부터 두 번째 매개변수로 전달된 인덱스 바로 앞의 문자까지를 삭제하는 메소드입니다.</p>
<h2 id="insert-메소드">insert() 메소드</h2>
<p><code>insert()</code> 메소드는 인수로 전달된 값을 문자열로 변환한 후, 해당 문자열의 지정된 인덱스 위치에 추가합니다. 이 때, 전달된 인덱스가 해당 문자열의 길이와 같으면, append() 메소드와 같은 결과를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">string2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">"Java 만세!!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"원본 문자열 : "</span>+str);</span><br><span class="line">        System.out.println(str.insert(<span class="number">5</span>, <span class="string">"Script "</span>));</span><br><span class="line">        System.out.println(<span class="string">"insert() 메소드 호출 후 문자열 : "</span>+str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 문자열 : Java 만세!!</span><br><span class="line">Java Script 만세!!</span><br><span class="line">insert() 메소드 호출 후 문자열 : Java Script 만세!!</span><br></pre></td></tr></table></figure>
<p>insert() 메소드를 사용하여 해당 문자열에서 인덱스가 4인 위치부터 두 번째 매개변수로 전달된 문자열을 추가하고 있습니다. 이처럼 내가 원하는 위치에 문자열을 추가할 때 사용할 수 있는 메소드입니다.</p>
<h2 id="대표적인-stringbuffer-메소드">대표적인 StringBuffer 메소드</h2>
<img src="/img/stringbuffer.png" width="800" height="200">
<h1 id="math-클래스">Math 클래스</h1>
<hr>
<p><code>Math</code> 클래스는 수학에서 자주 사용하는 상수들과 함수들을 미리 구현해 놓은 클래스입니다. Math 클래스의 모든 메소드는 <strong>클래스 메소드</strong> <strong>(static method)</strong> 이므로, 객체를 생성하지 않고도 바로 사용할 수 있습니다. 이러한 Math 클래스는 java.lang 패키지에 포함되어 제공됩니다.</p>
<h2 id="mathe와-mathpi">Math.E와 Math.PI</h2>
<p>다음은 Math 클래스에 정의되어 있는 클래스 필드입니다.</p>
<ol>
<li>Math.E : 오일러의 수라 불리며, 자연로그(natural logarithms)의 밑(base) 값으로 약 2.718을 의미합니다.</li>
<li>Math.PI : 원의 원주를 지름으로 나눈 비율(원주율) 값으로 약 3.14159를 의미합니다.</li>
</ol>
<h2 id="random-메소드">random() 메소드</h2>
<p><code>random()</code> 메소드는 0.0이상 1.0 미만의 범위에서 임의의 double 형 값을 하나 생성하여 반환합니다. 이 메소드는 내부적으로 java.util 패키지의 Random 클래스를 사용한 의사 난수 발생기(pseudorandom generator)를 사용하여 임의의 수를 생성합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        System.out.println(random.nextInt(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바에서는 Math 클래스의 random() 메소드 뿐만 아니라 java.util 패키지에 포함된 Random 클래스의 nextInt() 메소드를 사용해도 난수를 생성할 수 있습니다. nextInt() 메소드는 매개변수로 범위를 지정해 줄 수 있습니다.</p>
<p>만약 특정 범위에 속하는 난수를 생성하려면, 다음과 같이 난수 생성 범위를 조절할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)); <span class="comment">//1</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)+<span class="number">1</span>); <span class="comment">//2</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>) (Math.random()*<span class="number">6</span>)+<span class="number">3</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>만약 특정 범위에 속하는 난수를 생성하려면, 위와 같이 난수 생성 범위를 조절할 수 있습니다.<br>
기본적으로 0부터 곱해지는 수의 바로 앞 수까지가 난수 생성 범위로 지정됩니다.</p>
<p>1 -&gt; 0~5<br>
2 -&gt; 1~6<br>
3 -&gt; 3~8</p>
<h2 id="abs-메소드">abs() 메소드</h2>
<p><code>abs()</code> 메소드는 전달된 값이 음수이면 그 값의 절대값을 반환하며, 전달된 값이 양수이면 전달된 값을 그대로 출력합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.abs(<span class="number">10</span>));</span><br><span class="line">System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">System.out.println(Math.abs(-<span class="number">123123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 결과</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">123123</span></span><br></pre></td></tr></table></figure>
<h2 id="floor-ceil-round-메소드">floor(), ceil(), round() 메소드</h2>
<ul>
<li>floor() : <strong>인수로 전달받은 값과 같거나 작은 수 중에서 가장 큰 정수를 반환합니다.</strong></li>
<li>ceil() : <strong>반대로 인수로 전달받은 값과 같거나 큰 수 중에서 가장 작은 정수를 반환합니다.</strong></li>
<li>round() : <strong>전달받은 실수를 소수점 첫째 자리애서 반올림한 정수를 반환합니다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.ceil(<span class="number">10.9</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">10.0</span>));</span><br><span class="line">System.out.println(Math.ceil(<span class="number">9.9</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.println(Math.floor(<span class="number">9.9</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">10.9</span>));</span><br><span class="line">System.out.println(Math.floor(<span class="number">10.1</span>));</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">System.out.println(Math.round(<span class="number">10.34457</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">10.49</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">10.61</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">11.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="max-min-메소드">max(), min() 메소드</h2>
<p>max() 메소드는 전달된 두 값을 비교하여 그 중에서 큰 값을 반환하며, min() 메소드는 그 중에서 작은 값을 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.max(<span class="number">3.14</span>, <span class="number">3.141</span>));</span><br><span class="line">System.out.println(Math.max(<span class="number">3.14</span>, <span class="number">3.14159</span>)); </span><br><span class="line">System.out.println(Math.min(<span class="number">3.14</span>, <span class="number">3.14159</span>)); </span><br><span class="line">System.out.println(Math.max(-<span class="number">10</span>, -<span class="number">11</span>));      </span><br><span class="line">System.out.println(Math.min(-<span class="number">10</span>, -<span class="number">11</span>));      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3.141</span></span><br><span class="line"><span class="number">3.14159</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">-<span class="number">10</span></span><br><span class="line">-<span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="pow-sqrt-메소드">pow(), sqrt() 메소드</h2>
<p>pow() 메소드는 전달된 두 개의 double형을 가지고 제곱 연산을 수행합니다.<br>
예를 들어, pow(a,b)는 a의 b승, 즉 a^b를 반환하게 됩니다.</p>
<p>반대로 sqrt() 메소드는 전달된 double형 값의 제곱근을 반화합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println((<span class="keyword">int</span>)(Math.pow(<span class="number">5</span>,<span class="number">2</span>)));</span><br><span class="line">System.out.println((<span class="keyword">int</span>)(Math.sqrt(<span class="number">25</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="삼각함수와-관련된-메소드">삼각함수와 관련된 메소드</h2>
<p>자바에서는 삼각 함수와 관련된 다양한 연산을 간편하게 수행할 수 있도록 많은 삼각 함수를 제공하고 있습니다.</p>
<ul>
<li>sin() : 전달된 double형 값의 사인 값을 반환합니다.</li>
<li>cos() : 전달된 double형 값의 코사인 값을 반환합니다.</li>
<li>tan() : 전달된 double형 값의 탄젠트 값을 반환합니다.</li>
</ul>
<p>이 외에도 Math 클래스에서 제공하는 삼각 함수와 관련된 메소드는 다음과 같습니다.<br>
-asin(), acos(), atan(), atan2(), sinh(), cosh(), tanh()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Math.sin(Math.toRadians(<span class="number">30</span>)));</span><br><span class="line">System.out.println(Math.sin(Math.PI / <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(Math.tan(Math.toRadians(<span class="number">45</span>)));</span><br><span class="line">System.out.println(Math.tan(Math.PI / <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(Math.cos(Math.toRadians(<span class="number">60</span>)));</span><br><span class="line">System.out.println(Math.cos(Math.PI / <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0.49999999999999994</span></span><br><span class="line"><span class="number">0.49999999999999994</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br><span class="line"><span class="number">0.9999999999999999</span></span><br><span class="line"><span class="number">0.5000000000000001</span></span><br><span class="line"><span class="number">0.5000000000000001</span></span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 자바의 삼각 함수에 관한 메소드는 정확한 값을 나타내지 못합니다. 그 이유는 컴퓨터가 실수를 나타내는데 사용하는 부동 소수점 방식의 한계로 모든 언어에서 공통으로 발생하는 문제입니다.</p>
<h2 id="대표적인-math-메소드">대표적인 Math 메소드</h2>
<img src="/img/math1.png" width="700" height="200">
<img src="/img/math2.png" width="700" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/20/java-basic-11/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/19/java-basic-10/"
                            aria-label=": [Java] 10. 다형성"
                        >
                            [Java] 10. 다형성
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-19T16:02:01+09:00">
	
		    Aug 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="다형성"># 다형성</h1>
<ul>
<li>하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미한다.</li>
<li>부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 해 구현한다.</li>
<li><strong>여러 가지 형태를 가질 수 있는 능력</strong>을 의미한다. 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 구현한다.</li>
</ul>
<h2 id="참조-변수의-다형성"># 참조 변수의 다형성</h2>
<ul>
<li>부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 한다.</li>
<li>참조 변수가 사용할 수 있는 멤버의 개수 &lt;= 실제 인스턴스의 멤버의 개수</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showTV</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goSleep</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    String gender;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goSchool</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parent p = <span class="keyword">new</span> Parent(); <span class="comment">// 1</span></span><br><span class="line">        Parent pc = <span class="keyword">new</span> Child(); <span class="comment">// 2</span></span><br><span class="line">        Child c = <span class="keyword">new</span> Child(); <span class="comment">// 3</span></span><br><span class="line">        Child cp = <span class="keyword">new</span> Parent(): <span class="comment">// 4 </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>참조변수 a = new 인스턴스타입()</code></p>
<p>특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있다.<br>
참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문이다.</p>
<p>부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있다.<br>
참조 변수가 사용할 수 있는 멤버가 실제 인스턴스의 멤버 개수보다 적기 때문입니다.</p>
<p>하지만 반대의 경우, 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다.</p>
<blockquote>
<p>클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 된다.</p>
</blockquote>
<ol>
<li>기본적으로는 참조 변수와 인스턴스의 타입이 일치하는 걸 많이 사용한다.</li>
<li>참조 변수보다 인스턴스 타입의 멤버가 범위가 더 넓어야 한다.</li>
</ol>
<p><code>Parent p = new Child();</code><br>
참조 변수 : 부모, 인스턴스 타입 : 자식 -&gt; 가능, 부모의 멤버만 참조가 가능.<br>
<code>Child d = new Parent();</code><br>
참조 변수 : 자식, 인스턴스 타입 : 부모 -&gt; 불가능, 참조 변수의 멤버를 모두 충족하지 못한다.</p>
<h2 id="참조-변수의-타입-변환"># 참조 변수의 타입 변환</h2>
<p>참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있다.</p>
<ol>
<li>서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있다.</li>
<li>자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있다.</li>
<li>부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.</li>
</ol>
<p>참조 변수의 타입 변환도 기본 타입의 변환과 마찬가지로 <code>타입 캐스트 연산자 ()</code>를 사용한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(변환할 타입의 클래스 이름) 변환할 참조 변수</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Parent pa1 = <span class="keyword">null</span>;</span><br><span class="line">Child ch = <span class="keyword">new</span> Child();</span><br><span class="line">Parent pa2 = <span class="keyword">new</span> Parent();</span><br><span class="line">Brother bro = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">pa1 = ch; <span class="comment">// 1</span></span><br><span class="line">bro = (Brother)pa2; <span class="comment">// 2</span></span><br><span class="line">bro = (Brother)ch; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>1 : pa1 = (Parent)ch; 와 같으며 자식 클래스 -&gt; 부모 클래스 타입으로의 변환이므로 타입 변환을 생략할 수 있다.<br>
2 : 타입 변환을 생략할 수 없다. (부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다.)<br>
3 : 이 문장은 두 클래스 간의 직접적인 상속 관계가 아니므로 오류 발생.</p>
<blockquote>
<p>짚고 넘어가야 할 부분!</p>
</blockquote>
<ol>
<li>자식 -&gt; 부모(Up-casting) : 형 변환 생략 가능<br>
자식이 부모의 모든 걸 상속 받았으므로 자식이 더 범위가 넓다고 판단하여 손실이 없다고 판단하고 형 변환 생략이 가능하다.</li>
<li>부모 -&gt;자식(Down-casting) : 형 변환 생략 불가능</li>
</ol>
<p><code>TV2 t = new TV2();</code>와 <code>TV2 t = new CaptionTV();</code>의 차이점을 알아보자. 사실 <code>TV2 t = new CaptionTV();</code>는 다음을 줄인 것이다.<br>
<code>TV2 t = (TV2)new CaptionTV();</code> 업 캐스팅이므로 형 변환이 생략되어있던 것이다. 이걸 또 풀어 쓰면 다음과 같다.</p>
<ol>
<li><code>CaptionTV c = new CaptionTV();</code></li>
<li><code>TV2 t = (TV2)c</code><br>
역시 업 캐스팅이므로 TV2는 생략이 가능하다.</li>
</ol>
<p>그렇다면 차이점이 무엇일까???</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> power;</span><br><span class="line">    <span class="keyword">int</span> channel;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelUp</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelDown</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CaptionTV</span> <span class="keyword">extends</span> <span class="title">TV2</span> </span>&#123;</span><br><span class="line">    String text;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">caption</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV2 t = <span class="keyword">new</span> TV2();</span><br><span class="line">        TV2 t2 = <span class="keyword">new</span> CaptionTV();</span><br><span class="line">        System.out.println(((CaptionTV) t2).text); <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// t는 TV2 인스턴스여서 TV2의 멤버만 가지고 있으므로 CaptionTV 타입을 커버할 수가 없다.</span></span><br><span class="line">        <span class="comment">// 컴파일 시에는 올바른 형변환으로 보지만 런타임에서 체크 해보면 부모가 자식을 커버할 수 없는 원리와 같다.</span></span><br><span class="line">        <span class="comment">// CaptionTV c = (CaptionTV)t;</span></span><br><span class="line">        <span class="comment">// System.out.println(c.text);</span></span><br><span class="line">        <span class="comment">// t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅 해서 일단 CaptionTV 멤버를 들고는 있는데</span></span><br><span class="line">        <span class="comment">// 접근만 못할 뿐이라 CaptionTV 타입을 커버할 수 있다.</span></span><br><span class="line">        CaptionTV c2 = (CaptionTV)t2; <span class="comment">// 2</span></span><br><span class="line">        System.out.println(c2.text); <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t2는 CaptionTV 인스턴스를 강제로 TV2로 업캐스팅해서 일단 CaptionTV 멤버를 들고 있다. 그래서 접근하기 위해서는 1번과 같이 t2를 CaptionTV2로 다운 캐스팅 한 후에 접근해야 한다.</p>
<p>2번과 그 아래 코드는 1번에서 캐스팅 하고 text에 접근하는 과정을 풀어서 나타낸 것이다.</p>
<ol>
<li>
<p><code>TV2 t = new TV2();</code></p>
<ul>
<li>부모 참조 타입에 부모 인스턴스이면</li>
<li><code>Caption c = (CaptionTV)t</code> -&gt; 불가능</li>
<li>자식의 참조 타입으로 변환하지 못한다.</li>
<li>컴파일에서 에러가 발생하지는 않지만, 런타임에 에러가 발생한다.</li>
</ul>
</li>
<li>
<p><code>TV2 t = new CaptionTV();</code></p>
<ul>
<li>부모 참조 타입에서 자식 인스턴스이면</li>
<li><code>CaptionTV c = (CaptionTV)t</code> -&gt; 가능</li>
<li>자식의 참조 타입으로 변환 가능하다.</li>
</ul>
</li>
</ol>
<p><strong>instanceof 연산자</strong></p>
<ul>
<li>런타임에 참조 변수가 실제 참조하고 있는 인스턴스의 타입을 확인하기 위해 사용한다.</li>
<li><code>참조 변수 instanceof 클래스이름</code>
<ul>
<li>true : 참조 변수 = 실제 참조하고 있는 인스턴스 타입일 때 반환</li>
<li>false : 참조 변수 != 실제 참조하고 있는 인스턴스 타입이 아닐 때 반환</li>
<li>참조 변수가 null을 가리키고 있으면 false 반환.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brother</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Parent pa1 = <span class="keyword">new</span> Parent();</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Parent);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Child);</span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Brother);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Parent child = <span class="keyword">new</span> Child();</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Parent);</span><br><span class="line">        System.out.println(child <span class="keyword">instanceof</span> Child);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h1 id="다형성에-대해-더"># 다형성에 대해 더</h1>
<p>이후에 추가적으로 더 좋은 글을 참고하여 덧붙이게 되었다.</p>
<p><strong>다형성?</strong></p>
<ul>
<li><strong>여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함을 구현하는데 사용한다.</strong></li>
<li>구체적으로는 조상 클래스 타입의 참조 변수로 자손 클래스의 인스턴스를 참조할 수 있도록 하는 것이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        obj.x();</span><br><span class="line">        <span class="comment">// obj.y(); 이 녀석으로 인해 컴파일 에러</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class B를 obj로 인스턴스화하는데 데이터 타입은 A<br>
그 말은 실질적으로 class B를 담고 있지만 A인 것!!<br>
즉, class A에는 메소드 y()가 정의되어 있지 않다.<br>
그래서 obj.y()는 컴파일 에러가 발생한다.</p>
<ul>
<li>어떤 클래스를 인스턴스화 시킬 때, 변수를 담는 데이터 타입은 그 클래스가 될 수도 있고, 그 클래스의 부모 클래스가 될 수도 있다.</li>
<li>그럼 도대체 왜 이렇게 객체를 생성하는가 의문이 들기 시작한다. 다음 코드를 보자.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(obj.x());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">B.x</span><br></pre></td></tr></table></figure>
<p>A obj = new B();<br>
위의 코드는 class B를 인스턴스화 한 obj이지만 class A의 행세를 한다.<br>
그 뜻은 class A에 속해 있는 메소드만 호출할 수 있다는 것이다.<br>
즉, class B에만 속해 있는 메소드는 호출할 수 없다.<br>
class B에서 class A에 속해있던 메소드를 오버라이딩했다면 그 오버라이딩한 결과가 호출된다.</p>
<p>하지만 아직도 왜 이런 코드를 작성하는지 모르는 건 마찬가지이다…ㅜ<br>
아래의 코드를 하나 더 살펴보도록 하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A obj = <span class="keyword">new</span> B();</span><br><span class="line">        A obj2 = <span class="keyword">new</span> B2();</span><br><span class="line">        System.out.println(obj.x());</span><br><span class="line">        System.out.println(obj2.x());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">// class A를 상속 받고 있는 B</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"y"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="comment">// 오버라이딩 : 상속 관계에서 부모 클래스의 메소드를 하위 클래스 즉, 자식 클래스에서 재정의 하는 것</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B2.x"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">B.x</span><br><span class="line">B2.x</span><br></pre></td></tr></table></figure>
<p>obj, obj2 둘은 각각 B, B2 클래스를 통해 형성된 것이지만 부모 행세를 하고 있다. 따라서 자식 클래스에서 정의된 메소드를 호출할 수 없고 오버라이딩한 부분에 대해서만 호출한다.<br>
즉 각각의 자식 클래스에서 오버라이딩한 부분이 실행된다.</p>
<p>서로 다른 객체가 동일한 데이터 타입으로 존재하면서 각각의 클래스에 정의되어 있는 메소드를 호출할 때 각자가 정의한 대로 호출합니다.</p>
<ul>
<li>이쯤 되면 이러한 의문을 가질 수 있습니다.</li>
<li>같은 데이터 타입을 갖게 되면 장점이 있을까?</li>
<li>맞다. 데이터 타입이 같으면 메소드를 실행시키기가 편리해진다.</li>
</ul>
<img src="/img/kklkl.png" width="600" height="200">
<p>위의 코드처럼 호출하는 메소드를 만들어두면 하나의 데이터 타입을 대상으로 여러가지를 호출할 수 있다.</p>
<p><strong>다형성과 인터페이스</strong></p>
<p>어떤 클래스가 어떤 인터페이스를 구현하고 있다면 그 클래스로부터 인스턴스화 되는 인스턴스의 데이터 타입은 구현하고 있는 인터페이스로 인스턴스화 될 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphism</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        I obj = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I2</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        D objD = <span class="keyword">new</span> D();</span><br><span class="line">        I2 objI2 = <span class="keyword">new</span> D();</span><br><span class="line">        I3 objI3 = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">        System.out.println(objD.A());</span><br><span class="line">        <span class="comment">// class D가 정의한 모든 멤버를 호출할 수 있습니다.</span></span><br><span class="line">        System.out.println(objD.B());</span><br><span class="line">        <span class="comment">// class D가 정의한 모든 멤버를 호출할 수 있습니다.</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(objI2.A());</span><br><span class="line">        <span class="comment">// interface I2의 데이터 타입이므로 A() 메소드 호출 가능</span></span><br><span class="line">        <span class="comment">// System.out.println(objI2.B());</span></span><br><span class="line">        <span class="comment">// interafce I2의 데이터 타입이므로 B() 메소드가 존재하지 않아 호출 불가능</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(objI3.A());</span></span><br><span class="line">        <span class="comment">// interface I3의 데이터 타입이므로 A() 메소드가 존재하지 않아 호출 불가능</span></span><br><span class="line">        System.out.println(objI3.B());</span><br><span class="line">        <span class="comment">// interface I3의 데이터 타입이므로 호출 가능</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스가 갖고 있는 모든 메소드를 호출해야 한다면(모든 기능을 사용해야 한다면) 데이터 타입을 그 클래스로 지정해줘야 하지만, <strong>특정한 인터페이스에 해당하는 기능만을 사용한다고 하면 데이터 타입으로 그 기능이 속해 있는 인터페이스를 데이터 타입으로 지정하면 된다. 나머지 기능을 마치 존재하지 않는 것처럼 할 수 있다.</strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/19/java-basic-10/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/18/aws-hackathon/"
                            aria-label=": AWS :: amathon"
                        >
                            AWS :: amathon
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-18T22:52:19+09:00">
	
		    Aug 18, 2018
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>뒤늦은 후기이지만, 제가 참여한 해커톤에 대한 간단한 리뷰를 해보겠습니다. ^0^</p>
<p>제가 활동하고 있는 SOPT라는 동아리에서 AppJam이라는 2주 간의 해커톤은 해 본 경험이 있지만, 이렇게 짧은 1박 2일간의 해커톤은 처음이었습니다. 이번 글은 제가 첫 해커톤에 참가해서 느낀 경험을 말해보는 시간입니다. :D</p>
<h1 id="amathon">Amathon</h1>
<hr>
<p>해커톤에 대한 부푼 기대를 안고 참가했습니다. 하지만, 생각과 달리 분위기는 자유로웠고 즐거웠습니다. ㅎㅎ 바로 시작을 하지 않고, 간단한 소개 및 인사말과 후원을 해주신 분들 그리고 여러가지 설명을 해주셨습니다…ㅎㅎㅎ</p>
<p>먼저, <strong>Amathon</strong>이란??<br>
<img src="/img/amathon_concept.png" width="700" height="200"></p>
<h1 id="amathon-session">Amathon Session</h1>
<hr>
<img src="/img/amathon_pre_session.png" width="500" height="200">
<p>그리고 먼저 해커톤을 진행하기에 앞서 사전 교육 세션을 진행했습니다. 저는 이 중에서 <code>Serverless Crawling &amp; Data Analysis</code> 세션을 들었습니다. 이 세션은 AWS에서 제공하는 기능들을 이용해서 크롤링을 진행하고 많은 기능들을 체험해봄으로써 AWS에 친숙해지자는 목적을 담고 있습니다. 덕분에 크롤링이라는 것을 AWS에서 제공하는 기능들을 통해서 경험해보고 좋은 이야기를 들을 수 있었습니다.</p>
<h1 id="time-table">Time table</h1>
<hr>
<img src="/img/amathon_timetable_1.png" width="500" height="200">
<img src="/img/amathon_timetable_2.png" width="500" height="200">
<h1 id="requirements">Requirements</h1>
<hr>
<img src="/img/amathon1.png" width="500" height="200">
<img src="/img/amathon2.png" width="500" height="200">
<h1 id="review">Review</h1>
<hr>
<p>첫 해커톤에 대한 기대와 설렘 그리고 부담감이 있었지만, 자유롭고 즐거운 분위기 속에서 즐길 수 있었습니다. 제일 중요한 것은 좋은 팀원들을 만나서 정말 재미있는 해커톤을 진행하였으며, 실력이 좋으신 안드로이드 개발자 선배님을 만나서 <strong>그래들</strong>을 관리하는 법, Pair coding, 안드로이드 스튜디오는 항상 최신 버전으로 유지할 것 등등 유용한 것들을 많이 배울 수 있었습니다.</p>
<p>또한, 상을 주는 기준은 잘하는 것이 아닌 재미와 asug에서 정한 기준에 따른 수상이었습니다. 저희 팀은 운이 좋게도 <code>기능은 좋지만 디자인이 별로였다</code>상을 받아서 치킨을 선물로 받을 수 있었습니다.</p>
<p>그리고 참가비 만원을 내고 참가하였지만, 참가자에게 주는 기념품과 제가 받은 상까지 포함하면 소위 말해 <strong>개이득</strong>이었고, 정말 좋은 기회였습니다. 앞으로 해커톤이 생기면 자주 참여하도록 노력할 생각입니다. ^0^</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/18/aws-hackathon/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/17/java-basic-9/"
                            aria-label=": [Java] 9. 상속"
                        >
                            [Java] 9. 상속
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-17T10:38:44+09:00">
	
		    Aug 17, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="상속"># 상속</h1>
<ul>
<li>기존의 클래스에 기능을 추가하거나 메소드를 재정의하여 새로운 클래스를 정의하는 것을 의미한다.</li>
<li>캡슐화, 추상화와 더불어 객체지향 프로그래밍의 특징 중 하나이다.</li>
<li><strong>extends</strong> 키워드를 사용한다.</li>
<li>단일 상속만을 지원한다.</li>
</ul>
<p>상속을 통해 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아, 새로운 클래스를 생성할 수 있다. 즉, 기존의 객체를 그대로 유지하면서 어떤 기능을 추가하는 방법이다.</p>
<p>기존의 객체가 갖고 있는 메소드들을 그대로 사용할 수 있다. 이때 기존에 정의되어 있던 클래스를 부모 클래스(parent class) 또는 상위 클래스(super class), 기초 클래스(base class)라고도 한다. 그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스(child class) 또는 하위 클래스(sub class), 파생 클래스(derived class)라고도 한다.</p>
<h2 id="상속의-장점">상속의 장점</h2>
<ol>
<li>기존에 작성된 클래스를 <strong>재활용</strong>할 수 있다.</li>
<li>자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해 놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다.</li>
<li>클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다.</li>
</ol>
<p><strong>1. 자식 클래스(child class)</strong></p>
<ul>
<li>부모 클래스의 모든 특성을 물려받아 새롭게 작성된 클래스.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 자식 클래스 이름 <span class="keyword">extends</span> 부모 클래스 이름</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<img src="/img/child_class.png" width="500" height="200">
<center><b>부모 클래스와 자식 클래스 간의 포함 관계</b></center>
<p>부모 클래스는 자식 클래스에 포함된 것으로 볼 수 있다.<br>
따라서, 부모 클래스에 새로운 필드를 하나 추가하면 자식 클래스에도 자동으로 해당 필드가 추가된 것처럼 동작한다.</p>
<p>자식 클래스에는 부모 클래스의 필드와 메소드만이 상속된다.<br>
생성자와 초기화 블록은 상속되지 않는다. 또한, 부모 클래스의 접근 제어자가 private나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근할 수 없다.</p>
<p>private로 선언된 멤버는 자식 클래스에서 접근할 수 없다.<br>
(같은 패키지이건, 다른 패키지이건)<br>
default로 선언된 멤버는 자식 클래스에서 접근 할 수 있다. (같은 패키지에 한해서만) 다른 패키지의 자식 클래스에서는 접근을 할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num1 = <span class="number">10</span>; <span class="comment">// private 필드</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num2 = <span class="number">20</span>; <span class="comment">// public 필드</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num3 = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num1); <span class="comment">// 1 </span></span><br><span class="line">        System.out.println(num2); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(num3); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 부모 클래스의 private 멤버는 자식 클래스에서 접근할 수 없으므로 오류 발생.<br>
2 : 부모 클래스의 public 멤버는 자식 클래스에서 접근 가능.<br>
3 : 자식 클래스에서 자신만의 필드 혹은 메소드를 선언하여 사용할 수 있으므로 가능.</p>
<h1 id="object-클래스"># Object 클래스</h1>
<ul>
<li>Object 클래스는 모든 클래스의 부모 클래스이다.</li>
<li>모든 클래스는 자동으로 Object 클래스의 모든 필드와 메소드를 상속받게 된다.</li>
<li>toString(), clone()과 같은 메소드 등등.</li>
</ul>
<h1 id="super"># super</h1>
<ul>
<li>super : 부모 클래스로부터 상속받은 필드나 메소드를 자식 클래스에서 참조하는데 사용하는 참조 변수이다.</li>
</ul>
<p>인스턴스 변수의 이름과 지역 변수의 이름이 같을 경우 인스턴스 변수 앞에 this 키워드를 사용해서 구분했었다. 이와 마찬가지로 부모 클래스의 멤버와 자식 클래스의 멤버 이름이 같을 경우 <code>super</code> 키워드를 사용하여 구별할 수 있다.</p>
<p>this와 마찬가지로 super 참조 변수는 인스턴스 메소드에서만 사용할 수 있다. 클래스 메소드에서는 사용할 수 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.a);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child();</span><br><span class="line">        child.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">결과</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>위의 예제에서 int형 변수 a는 자식 클래스인 Child와 부모 클래스인 Parent에 선언되어 있습니다. 따라서 지역 변수와 this 참조 변수는 자식 클래스에서 대입된 값을 출력하며, super 참조 변수만이 부모 클래스에서 대입된 값을 출력하게 됩니다.</p>
<h1 id="super"># super()</h1>
<ul>
<li>this() 메소드가 같은 클래스의 다른 생성자를 호출할 때 사용된다면, <code>super()</code> 메소드는 부모 클래스의 생성자를 호출할 때 사용된다.</li>
</ul>
<p>자식 클래스의 인스턴스를 생성하면 이 인스턴스에는 자식 클래스의 고유 멤버뿐 아니라 부모 클래스의 모든 멤버가 포함되어 있다. 따라서 부모 클래스의 멤버를 초기화하기 위해서는 자식 클래스의 생성자에서 부모 클래스의 생성자까지 호출해야 한다.</p>
<p>이러한 부모 클래스의 생성자 호출은 모든 클래스의 부모 클래스인 <strong>Object</strong> 클래스의 생성자까지 거슬러 올라가며 수행된다.</p>
<p>자바 컴파일러는 부모 클래스의 생성자를 명시적으로 호출하지 않는 모든 자식 클래스의 생성자 첫 줄에 자동으로 <code>super()</code>를 추가하여 부모 클래스의 멤버를 초기화할 수 있도록 해준다.</p>
<p>하지만 자바 컴파일러는 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않아야, <strong>자동으로 기본 생성자를 추가해준다.</strong> 아래처럼 부모 클래스에 매개변수를 가지는 생성자를 하나라도 선언했다면, 부모 클래스에는 기본 생성자가 자동으로 추가되지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 부모 클래스의 매개변수가 있는 생성자</span></span><br><span class="line">    Parent(<span class="keyword">int</span> n)&#123; </span><br><span class="line">        <span class="keyword">this</span>.a = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 super()를 사용해 부모 클래스의 기본 생성자를 호출하면 오류가 발생한다. 이유는 부모 클래스에 기본 생성자가 없기 때문이다. 매개변수를 가진 생성자를 선언해야 할 경우는 기본 생성자까지 명시적으로 선언하는 것이 좋다.</p>
<p>혹은 아래의 2번처럼 <code>super(20);</code> super() 메소드를 호출할 때 부모 클래스의 매개변수가 있는 생성자를 호출하는 것도 하나의 방법이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">// 부모 클래스의 매개변수가 있는 생성자</span></span><br><span class="line">    Parent(<span class="keyword">int</span> n)&#123; </span><br><span class="line">        <span class="keyword">this</span>.a = n;</span><br><span class="line">    &#125;</span><br><span class="line">    Parent()&#123;</span><br><span class="line">        a  = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child()&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="number">20</span>); <span class="comment">// 2</span></span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아래는 super() 메소드가 어떻게 호출되는지를 보여주는 예제이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Parent() &#123; </span><br><span class="line">        a = <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    Parent(<span class="keyword">int</span> n) &#123; </span><br><span class="line">        a = n; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    Child() &#123;</span><br><span class="line">    <span class="comment">// 하위 클래스에서는 반드시 상위 클래스의 생성자가 호출되어야 합니다.</span></span><br><span class="line">    <span class="comment">// super(40); 1번</span></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child ch = <span class="keyword">new</span> Child();</span><br><span class="line">        ch.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자바 컴파일러는 주석 처리된 1번 라인에 자동으로 <code>super();</code>를 삽입할 것이다. 따라서 변수 a는 10으로 초기화된다.</p>
<p>1번 라인의 주석을 해제하고 실행하면 부모 클래스 Parent 클래스는 두 번째 생성자에 의해 초기화되고 변수 a는 40으로 초기화된다.</p>
<p>추가적으로 인스턴스 변수(여기서 int b)의 초기화는 인스턴스 변수가 선언된 클래스의 <strong>생성자</strong>를 통해서 진행하는 것이 가장 좋은 모델이 될 수 있다. 상위 클래스의 인스턴스 변수는 상위 클래스의 생성자 내에서 초기화가 진행되어야 하고, 하위 클래스에서는 상위 클래스의 인스턴스 변수를 초기화하는데 필요한 데이터를 <strong>키워드 super</strong>를 통해서 전달만 하는 것이 합리적이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/17/java-basic-9/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/13/java-basic-8/"
                            aria-label=": [Java] 8. 클래스 멤버"
                        >
                            [Java] 8. 클래스 멤버
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-13T16:01:59+09:00">
	
		    Aug 13, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바에서는 변수가 3 종류로 나누어지고 각각 다른 메모리에 올라간다. 메소드도 클래스 메소드와 인스턴스 메소드로 분류할 수 있다.</p>
<h1 id="필드의-구분"># 필드의 구분</h1>
<ul>
<li>클래스의 <code>필드(field)</code>란 클래스에 포함된 <strong>변수</strong>를 의미한다.</li>
<li>클래스 내에서 필드는 선언된 위치에 따라 다음과 같이 구분된다.</li>
</ul>
<ol>
<li>클래스 변수(static variable)</li>
<li>인스턴스 변수(instance variable)</li>
<li>지역 변수(local variable)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cv; <span class="comment">// 클래스 변수</span></span><br><span class="line">    String iv; <span class="comment">// 인스턴스 변수</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lv = <span class="number">10</span>; <span class="comment">// 지역 변수</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 변수와 인스턴스 변수는 초기화를 하지 않아도 변수의 타입에 맞게 자동으로 초기화 된다.</li>
<li>지역 변수는 사용하기 전에 초기화하지 않으면, 자바 컴파일러가 오류를 발생시킨다. 따라서 지역 변수는 반드시 초기화 해야 한다.</li>
</ul>
<p><strong>1. 클래스 변수</strong></p>
<ul>
<li>멤버 변수라고도 한다.</li>
<li>모든 인스턴스에게 적용될 수 있는 변수이며, <strong>메모리 공간에 하나만 존재하고 모든 인스턴스가 공유하는 변수</strong>이다.(공유 변수)</li>
<li>인스턴스를 생성하지 않고도 바로 사용할 수 있다.</li>
<li>클래스 영역에 위치하며 static으로 선언된다.</li>
<li>어디서나 접근할 수 있도록 하기 위해 public 제어자를 추가한다.</li>
<li>참조의 용도로만 사용되는 공유 변수는 <code>static final</code>로 선언한다.</li>
</ul>
<p>static 변수(즉, 클래스 변수, 멤버 변수, 공유 변수)는 인스턴스가 생성되기 전에 메모리 공간에 할당되어 초기화까지 완료된다.<br>
int 타입 변수는 0으로 초기화된다.<br>
String 타입 변수는 null로 초기화된다.<br>
<strong>JVM에 의해 클래스가 메모리에 올라가는 순간에 초기화된다.</strong></p>
<p>static 변수에는 무거운 즉, 용량이 큰 변수를 선언하면 메모리의 비효율을 발생시킨다. 프로그램이 실행되면서 static area(= 메소드 영역)에 변수가 생성되기 때문이다. 이 영역에 생성되는 변수는 프로그램이 종료될 때까지 할당된 메모리를 점유하고 있게 된다. 이로 인해 무거운 즉, 용량이 큰 변수를 선언하지 않도록 주의해야 한다.</p>
<p><strong>2. 인스턴스 변수</strong></p>
<ul>
<li>클래스 내부에 선언된다.</li>
<li>클래스 영역에 위치하며 static 키워드를 갖지 않는다.</li>
<li>인스턴스마다 다른 값을 갖는 변수.</li>
<li>인스턴스가 <strong>new</strong> 키워드를 통해 생성되어야 생성된다. 즉, 인스턴스가 생성되었을 때 인스턴스 변수에 접근할 수 있다.</li>
<li>자바 메모리 구조 중 Heap 영역에 생성된다. 삭제하지 않아도 GC에 의해 메모리가 회수된다.</li>
</ul>
<p><strong>3. 지역 변수</strong></p>
<ul>
<li>메소드 내에 선언되고 메소드 내에서만 사용 가능하다.</li>
<li>메소드가 종료되면 지역 변수는 소멸된다.</li>
<li>초기화하지 않으면 기본값이 설정되지 않기 때문에 명시적으로 초기화를 해줘야 한다.</li>
</ul>
<p><strong>예제</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>; <span class="comment">// 클래스 변수</span></span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">20</span>; <span class="comment">// 인스턴스 변수</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> localVar = <span class="number">30</span>;</span><br><span class="line">        System.out.println(<span class="string">"지역 변수 참조 : "</span>+localVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Field field1 = <span class="keyword">new</span> Field();</span><br><span class="line">        Field field2 = <span class="keyword">new</span> Field();</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 참조 : "</span>+Field.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field1의 클래스 변수 참조 : "</span>+field1.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 클래스 변수 참조 : "</span>+field2.classVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        field1.classVar = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"클래스 참조 변수의 값 변경 후"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 참조 : "</span>+Field.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field1의 클래스 변수 참조 : "</span>+field1.classVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 클래스 변수 참조 : "</span>+field2.classVar);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"field1의 인스턴스 변수 참조 : "</span>+field1.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">"field2의 인스턴스 변수 참조 : "</span>+field2.instanceVar);</span><br><span class="line"></span><br><span class="line">        field1.instanceVar = <span class="number">200</span>;</span><br><span class="line">        field2.instanceVar = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"인스턴스 참조 변수의 값 변경 후"</span>);</span><br><span class="line">        System.out.println(field1.instanceVar);</span><br><span class="line">        System.out.println(field2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">지역 변수 참조 : <span class="number">30</span></span><br><span class="line"></span><br><span class="line">클래스 변수 참조 : <span class="number">10</span></span><br><span class="line">field1의 클래스 변수 참조 : <span class="number">10</span></span><br><span class="line">field2의 클래스 변수 참조 : <span class="number">10</span></span><br><span class="line"></span><br><span class="line">클래스 참조 변수의 값 변경 후</span><br><span class="line">클래스 변수 참조 : <span class="number">100</span></span><br><span class="line">field1의 클래스 변수 참조 : <span class="number">100</span></span><br><span class="line">field2의 클래스 변수 참조 : <span class="number">100</span></span><br><span class="line"></span><br><span class="line">field1의 인스턴스 변수 참조 : <span class="number">20</span></span><br><span class="line">field2의 인스턴스 변수 참조 : <span class="number">20</span></span><br><span class="line"></span><br><span class="line">인스턴스 참조 변수의 값 변경 후</span><br><span class="line">field1의 인스턴스 변수 참조 : <span class="number">200</span></span><br><span class="line">field2의 인스턴스 변수 참조 : <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>클래스 변수는 해당 클래스의 모든 인스턴스 변수가 같은 값을 공유한다.</li>
<li>인스턴스 변수는 인스턴스마다 별도의 고유한 값을 갖는다.</li>
</ul>
<p>선언된 위치에 따라 구분되는 변수는 생성 및 소멸 시기, 저장되는 메모리 공간과 사용 방법까지도 서로 다르다.</p>
<img src="/img/static_local.png" width="650" height="200">
<h1 id="메소드의-구분"># 메소드의 구분</h1>
<ul>
<li>클래스 메소드(static method)</li>
<li>인스턴스 메소드(instance method)</li>
</ul>
<p><strong>1. 클래스 메소드(static 메소드)</strong></p>
<ul>
<li>static 키워드를 갖는 메소드를 의미한다.</li>
<li>인스턴스를 생성하지 않아도 static 메소드에 접근하여 호출할 수 있다.</li>
<li>효율적으로 메모리와 시간을 컨트롤할 수 있다.</li>
<li><strong>클래스 메소드는 인스턴스 변수를 사용하지 않고 전달된 매개변수만으로 동작하는 메소드이다.</strong></li>
<li>클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다. 이유는 인스턴스 변수는 인스턴스가 생성될 때 사용할 수 있도록 메모리에 할당되기 때문이다.</li>
</ul>
<p>클래스는 메소드보다 먼저 존재한다. 클래스는 컴파일 과정에서 이미 메모리에 올라가게 된다. 그리고 클래스를 기반으로 인스턴스를 생성하게 된다.</p>
<p>인스턴스 멤버는 인스턴스가 생성되면 사용할 수 있도록 메모리에 올라가게 된다. 클래스 메소드는 인스턴스 생성과 관계 없이 접근할 수 있다. 생성되지 않은 인스턴스는 메모리에 없다. 클래스 메소드가 메모리에 없는 인스턴스 변수에 접근하기 때문에 오류가 발생한다. 이러한 이유로 <strong>클래스 메소드 내부에서 인스턴스 멤버에 접근할 수 없다.</strong></p>
<p><strong>메소드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려해볼만 합니다. 메소드 호출 시간이 짧아지므로 성능이 향상됩니다.</strong></p>
<p><strong>예제</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span> </span>&#123; <span class="comment">// 인스턴스 메소드</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// 클래스 메소드</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Method.add(<span class="number">10</span>, <span class="number">100</span>));</span><br><span class="line">        Method method = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(method.add());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">110</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>
<h1 id="필드의-초기화"># 필드의 초기화</h1>
<ul>
<li>필드를 초기화하지 않으면 변수 타입에 맞는 초기값으로 자동 초기화된다.</li>
<li>하지만 지역 변수와 마찬가지로 적절한 값으로 초기화한 후에 사용하는 것이 좋다.</li>
</ul>
<p>필드 초기화 방법</p>
<ol>
<li>명시적 초기화
<ul>
<li>지역 변수를 초기화하는 방법과 마찬가지로 필드를 선언과 동시에 초기화하는 방법이다.</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>생성자를 이용한 초기화
<ul>
<li>객체의 생성과 동시에 필드를 초기화하는 방법이다. 따라서 이 방법은 인스턴스를 생성할 때까지는 필드를 초기화할 수 없다.</li>
</ul>
</li>
<li>초기화 블록을 이용한 초기화
<ul>
<li>클래스 필드의 초기화만을 담당하는 중괄호({})로 둘러싸인 블록을 의미한다. 초기화 블록은 생성자보다 먼저 호출되며, static 키워드의 유무에 따라 구분할 수 있다.
<ul>
<li>static 키워드 X : 인스턴스 초기화 블록</li>
<li>static 키워드 O : 클래스 초기화 블록</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>초기화 블록에는 다양한 명령문 및 제어문을 사용할 수 있으므로, 복잡한 초기화를 해야할 경우 유용하게 사용된다.</p>
<ul>
<li>인스턴스 초기화 블록</li>
</ul>
<p>단순히 중괄호만을 사용하여 정의 가능.<br>
생성자와 마찬가지로 인스턴스가 생성될 때 실행된다.<br>
하지만 인스턴스 초기화 블록이 생성자보다 먼저 실행된다.<br>
차이가 거의 없어 잘 사용되지 않는다.<br>
다만 여러 개의 생성자가 있으면 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함하여 코드의 중복을 막을 수 있다.(사용해본 적이 없다.)</p>
<ul>
<li>클래스 초기화 블록</li>
</ul>
<p><code>static</code> 키워드를 초기화 블록 앞에 정의한다.<br>
<strong>클래스가 처음으로 메모리에 로딩될 때 단 한 번만 실행된다.</strong><br>
생성자나 인스턴스 초기화 블록으로 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar;</span><br><span class="line">    <span class="keyword">int</span> instanceVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인스턴스 초기화 블록</span></span><br><span class="line">    &#123;</span><br><span class="line">        classVar = <span class="number">11</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클래스 초기화 블록 </span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        classVar = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">        instanceVar = <span class="number">20</span>; <span class="comment">// 2 : 오류 발생</span></span><br><span class="line">    &#125;</span><br><span class="line">    Method()&#123;</span><br><span class="line">        classVar = <span class="number">100</span>; <span class="comment">// 3 </span></span><br><span class="line">        <span class="keyword">this</span>.instanceVar = <span class="number">200</span>; <span class="comment">// 4 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Method m = <span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(Method.classVar);</span><br><span class="line">        System.out.println(m.classVar);</span><br><span class="line">        System.out.println(m.instanceVar);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">결과 </span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>1 : 클래스 초기화 블록을 이용한 클래스 변수의 초기화는 수행된다.<br>
2 : 클래스 초기화 블록을 이용한 인스턴스 변수의 초기화는 에러가 발생한다.<br>
3 : 생성자를 이용한 클래스 변수의 초기화는 수행된다.<br>
4 : 생성자를 이용한 인스턴스 변수의 초기화는 수행된다.</p>
<p>정리하면, 클래스 변수는 클래스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다. 그리고 인스턴스 변수는 인스턴스 초기화 블록을 통한 초기화, 생성자를 통한 초기화가 가능하다.</p>
<p>클래스 초기화 블록이 먼저 실행되고 그 다음으로는 인스턴스 초기화 블록이 실행된다. 가장 나중에는 생성자가 실행된다. 이 경우 위의 3가지 방법을 모두 이용해 초기화를 한다면 비효율적이다.</p>
<p>왜냐하면 어차피 제일 나중에 생성자를 위한 초기화가 반영되기 때문이다. 그래서 초기화할 때는 용도나 상황에 맞게 적절하게 사용하는 것이 중요하다.</p>
<p><strong>필드의 초기화 순서 예시</strong></p>
<ol>
<li>클래스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블록</li>
<li>인스턴스 변수 : 기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블록 -&gt; 생성자</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitBlack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> classVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> instanceVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 클래스를 참조할 때 실행된다. </span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        classVar = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        instanceVar = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InitBlack()&#123;</span><br><span class="line">        instanceVar = <span class="number">30</span>;</span><br><span class="line">        classVar = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 : "</span>+InitBlack.classVar);</span><br><span class="line">        InitBlack initBlack = <span class="keyword">new</span> InitBlack();</span><br><span class="line">        System.out.println(<span class="string">"인스턴스 변수 : "</span>+initBlack.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 - 생성자를 이용한 초기화한 후"</span>);</span><br><span class="line">        System.out.println(<span class="string">"클래스 변수 : "</span>+InitBlack.classVar);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line">클래스 변수 : <span class="number">20</span></span><br><span class="line">인스턴스 변수 : <span class="number">30</span></span><br><span class="line">클래스 변수 - 생성자를 이용한 초기화한 후</span><br><span class="line">클래스 변수 : <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>같은 필드를 여러 번 초기화하면 제일 마지막으로 초기화한 값만 남게된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/13/java-basic-8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/12/java-basic-7/"
                            aria-label=": [Java] 7. 제어자"
                        >
                            [Java] 7. 제어자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-12T17:14:53+09:00">
	
		    Aug 12, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><strong>제어자</strong>는 클래스와 멤버 선언 시 사용해 부가적인 의미를 부여하는 키워드.
<ul>
<li>접근 제어자 : 두 개 이상 사용 불가.</li>
<li>기타 제어자 : 여러 개 함께 사용 가능.</li>
</ul>
</li>
</ul>
<h1 id="접근-제어자"># 접근 제어자</h1>
<ul>
<li>정보 은닉을 위해 접근 제어자 기능을 제공한다.
<ul>
<li><strong>정보 은닉</strong> : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념.</li>
</ul>
</li>
<li>클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정해 정보 은닉을 구체화할 수 있다.</li>
</ul>
<p>자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다.</p>
<ol>
<li>private</li>
<li>public</li>
<li>default</li>
<li>protected</li>
</ol>
<p><strong>1. private</strong></p>
<p><strong>private 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없다.</li>
<li>자바 프로그램은 private 멤버에 직접 접근할 수 없으며,<br>
해당 객체의 <strong>public 메소드</strong>를 통해서만 접근할 수 있다.<br>
따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는데 사용된다.</li>
</ul>
<img src="/img/private.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">"이승우"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>private 멤버는 해당 멤버를 선언한 클래스에서만 접근할 수 있다.</li>
<li>다른 클래스에서 Person 클래스의 name에 접근하고자 할 때는 2와 같이 Person 클래스에 <strong>public</strong>으로 메소드를 선언하여 private로 선언된 name에 접근할 수 있다.</li>
<li>1과 같이 메소드를 private로 선언하게 된다면, 다른 클래스에서 Person 클래스의 name에 접근할 수 없다.</li>
</ul>
<p><strong>2. public</strong></p>
<p><strong>public 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.</li>
<li>자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다. public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행한다.</li>
</ul>
<img src="/img/public.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EveryWhere</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String var = <span class="string">"누구든지 허용"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. default(package-private)</strong></p>
<ul>
<li>클래스 및 클래스 멤버의 접근 제어 기본값으로 <strong>default 접근 제어자</strong>를 사용한다.</li>
<li>접근 제어자가 지정되지 않으면 default 접근 제어자를 자동으로 갖는다.</li>
</ul>
<p>default 접근 제어를 가지는 멤버는</p>
<ul>
<li>같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있습니다.</li>
<li>상속 관계에 있더라도 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<img src="/img/default.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지만 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamePackage</span></span>&#123;</span><br><span class="line">    String sameVar = <span class="string">"같은 패키지는 허용"</span>; <span class="comment">// default 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">같은 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    String var = <span class="string">"다른 패키지는 접근 불가"</span>; <span class="comment">// 1 : default 필드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SamePackage sp = <span class="keyword">new</span> SamePackage();</span><br><span class="line">        System.out.println(sp.sameVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1에서 var 변수는 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<p><strong>4. protected</strong></p>
<p>자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축한다. 여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다.</p>
<p><strong>protected 멤버는</strong></p>
<ul>
<li>부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됩니다.</li>
<li>상속 관계에 있을 경우 다른 패키지에서도 접근 가능.</li>
<li>상속 관계가 아닌 경우 다른 패키지에서 접근 불가능.</li>
</ul>
<p>클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다.</p>
<ol>
<li>이 멤버를 선언한 클래스의 멤버</li>
<li>이 멤버를 선언한 클래스가 속한 패키지의 멤버</li>
<li>이 멤버를 선언한 클래스를 상속받은 자식 클래스(child class)의 멤버</li>
</ol>
<img src="/img/protected.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지는 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String sameVar = <span class="string">"다른 패키지에 속하는 자식 클래스까지 허용"</span>;</span><br><span class="line">    <span class="comment">// protected 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">다른 패키지에 속하는 자식 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test.other;</span><br><span class="line"><span class="keyword">import</span> test.SameClass;</span><br><span class="line"><span class="comment">// test 패키지의 SameClass 클래스를 불러들여 포함시킴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SameClass sameClass = <span class="keyword">new</span> SameClass();</span><br><span class="line">        System.out.println(sameClass.sameVar);</span><br><span class="line">        <span class="comment">// 다른 패키지에 속하는 자식 클래스까지 허용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="접근-제어자의-접근-범위"># 접근 제어자의 접근 범위</h2>
<p>자바에서 접근 제어자의 접근 범위가 보다 많은 제어자부터 적은 제어자 순으로 나열하면 다음과 같다.<br>
자바에서는 클래스나 멤버를 선언할 때, 접근을 허용할 범위에 맞는 접근 제어자를 선택하는 것이 매우 중요하다.</p>
<p>public -&gt; protected -&gt; default -&gt; private</p>
<img src="/img/range.png" width="600" height="200">
<h1 id="기타-제어자"># 기타 제어자</h1>
<p>기타 제어자의 종류로는 다음과 같습니다.</p>
<ol>
<li>final 제어자</li>
<li>static 제어자</li>
<li>abstract 제어자</li>
</ol>
<p><strong>1.final</strong></p>
<ul>
<li><strong>final 제어자</strong>는 '변경할 수 없다’는 의미로 사용된다.</li>
<li>즉, 필드나 지역 변수에 사용하면 값을 변경할 수 없는 <code>상수(constant)</code>가 된다.</li>
<li>클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없다.</li>
<li>메소드에 사용하면 오버라이딩을 통한 재정의를 할 수 없다.</li>
<li>자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드, 필드, 지역 변수</li>
</ul>
</li>
</ul>
<p>?? 어디지??<br>
<code>메소드 오버라이딩</code>이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다.</p>
<p>자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속받을 수 있습니다. 이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 <strong>재정의</strong>하여 사용할 수도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> VAR; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> MAX_NUM = <span class="number">10.2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : Car 클래스는 <strong>상속을 통해 서브 클래스를 생성할 수 없다.</strong><br>
2 : VAR 필드는 <strong>상수화</strong>되어 값을 변경할 수 없다.<br>
3 : 이 메소드는 오버라이딩을 통해 재정의할 수 없다.<br>
4 : 이 지역 변수는 상수화되어 값을 변경할 수 없다.</p>
<p><strong>2.static</strong></p>
<ul>
<li>변수에 static 제어자를 사용하면 클래스 변수가 된다.</li>
<li>메소드에 static 제어자를 사용하면 클래스 메소드가 된다.</li>
<li>특징
<ol>
<li>프로그램 시작시 최초에 단 한 번만 생성되고 초기화 된다.</li>
<li>인스턴스를 생성하지 않고도 바로 사용할 수 있다.</li>
<li>해당 클래스의 모든 인스턴스가 공유한다.</li>
</ol>
</li>
<li>자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같습니다.
<ul>
<li>메소드, 필드, 초기화 블록</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">static</span>&#123; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 클래스 필드(static 변수) - Car 클래스의 인스턴스들이 공유한다.<br>
2 : static 초기화 블록으로 보통 클래스 필드의 초기화를 진행<br>
3 : 클래스 메소드(static 메소드)</p>
<p><strong>3.abstract</strong></p>
<ul>
<li>abstract 제어자는 '추상적인’이라는 의미로 사용된다.</li>
<li>선언부만 있고 구현부가 없는 메소드를 <strong>추상 메소드</strong>라 하며, 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>하나 이상의 추상 메소드를 포함하고 있는 추상 클래스도 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 추상 클래스<br>
2 : 추상 메소드</p>
<h2 id="제어자의-조합"># 제어자의 조합</h2>
<ul>
<li>접근 제어자와 기타 제어자를 한 대상에 사용할 수 있다.</li>
<li>모든 경우가 가능한 것은 아니며 대상에 따라 조금 다르다.</li>
</ul>
<img src="/img/combination_2.png" width="500" height="200">
<ol>
<li>
<p>클래스에서 final과 abstract는 함께 사용할 수 없다.<br>
<strong>final</strong> 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, <strong>abstract</strong> 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용할 수 있으므로, 상반된 이 두 제어자는 클래스에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 static과 abstract는 함께 사용할 수 없다.<br>
<strong>abstract</strong> 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, <strong>static</strong> 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private과 abstract는 함께 사용할 수 없다.<br>
: <strong>abstract</strong> 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, <strong>private</strong> 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private와 final은 함께 사용할 필요가 없다.<br>
메소드에 사용된 <strong>final</strong> 제어자와 <strong>private</strong> 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없게 된다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있습니다.</p>
</li>
</ol>
<blockquote>
<p>private 제어자를 사용한 메소드에는 자식 클래스가 접근할 수 없으므로 메소드 오버라이딩을 통한 재정의를 할 수 없다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/12/java-basic-7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/10/java-basic-6/"
                            aria-label=": [Java] 6. 메소드와 생성자"
                        >
                            [Java] 6. 메소드와 생성자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-10T15:31:15+09:00">
	
		    Aug 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="메소드"># 메소드</h1>
<ul>
<li>클래스의 멤버 중 기능을 표현하는 <strong>메소드</strong></li>
<li>특정 작업을 수행하기 위한 명령문의 집합</li>
<li>중복되는 코드의 작성을 피할 수 있다.</li>
<li>모듈화로 인해 가독성이 좋아진다.</li>
<li>유지보수 또한 쉽다.</li>
</ul>
<blockquote>
<p>메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다.</p>
</blockquote>
<p><strong>메소드의 정의 및 호출</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSpeed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accelerationTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accelerate</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">int</span> second)</span></span>&#123; <span class="comment">// 선언부</span></span><br><span class="line">        System.out.println(second + <span class="string">"초간 속도를 시속 "</span> + speed + <span class="string">"(으)로 가속함!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();<span class="comment">// 객체 생성</span></span><br><span class="line">    myCar.acceleratea(<span class="number">60</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 메소드 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>메소드 시그니처</strong>란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킨다.<br>
만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면 이 두 메소드의 시그니처는 같다고 할 수 있다.</li>
<li>메소드를 호출할 때 멤버 참조 연산자(.)를 사용하여 호출한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 객체참조변수이름.메소드이름(); <span class="comment">// 매개변수가 없는 메소드의 호출</span></span><br><span class="line"><span class="number">2</span>. 객체참조변수이름.메소드이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...); <span class="comment">// 매개변수가 있는 메소드의 호출</span></span><br></pre></td></tr></table></figure>
<h1 id="생성자"># 생성자</h1>
<p>클래스로부터 객체를 생성하면 해당 객체는 즉시 메모리에 생성된다.<br>
하지만 이 객체는 모든 인스턴스 변수가 초기화되지 않은 상태이다.<br>
클래스 변수와 인스턴스 변수를 별도로 초기화하지 않으면 타입에 맞는 값으로 자동 초기화된다.</p>
<p>사용자가 원하는 값으로 인스턴스 변수를 초기화하려면 일반적인 초기화 방식으로는 할 수 없다. private 변수도 있기 때문이다.<br>
따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 <strong>public</strong> 메소드가 필요하다.</p>
<p>초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 한다.</p>
<p>자바에서 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 <code>생성자(constructor)</code>라는 메소드를 제공한다. <strong>생성자의 이름은 해당 클래스의 이름과 같아야 한다.</strong></p>
<ol>
<li><strong>생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.</strong></li>
<li>생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.</li>
<li>객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, <strong>메소드 오버로딩</strong>이 가능하다.</li>
<li>생성자는 인스턴스 생성 시 딱 한번 호출되는 메소드이다.</li>
<li>return문도 정의되어 있지 않다.</li>
</ol>
<p><strong>생성자의 선언</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 클래스이름()&#123; ... &#125; <span class="comment">// 매개변수가 없는 생성자 선언</span></span><br><span class="line"><span class="number">2</span>. 클래스이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...)&#123; ... &#125; <span class="comment">// 매개변수가 있는 생성자 선언</span></span><br></pre></td></tr></table></figure>
<p><strong>생성자의 호출</strong></p>
<ul>
<li><strong>new</strong> 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 생성자</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 객체 생성 및 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="기본-생성자">기본 생성자</h2>
<p>모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다. 하지만, <strong>특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다.</strong> 자바 컴파일러가 <code>기본 생성자(default constructor)</code>를 기본적으로 제공해주기 때문이다.</p>
<ul>
<li>기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다.</li>
<li>자바 컴파일러가 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 기본 생성자를 추가한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">기본생성자 : 클래스이름()&#123;&#125; </span><br><span class="line">예시 : Car()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다. 다음 코드는 Car 클래스에 생성자를 정의하지 않고, 기본 생성자를 호출하는 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(); <span class="comment">// 기본 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 Car 클래스의 객체인 myCar는 기본 생성자를 호출하여 생성된다. Car 클래스에 기본 생성자가 존재하지 않는다. 기본 생성자가 없을 경우 자바 컴파일러가 컴파일 시 자동으로 생성해준다.</p>
<p>기본 생성자는 아무 동작도 하지 않는다. 따라서 인스턴스 변수를 클래스 필드에서 바로 초기화할 수 있다. <strong>인스턴스 변수의 초기화는 생성자를 사용하거나 클래스 필드에서 수행할 수 있다.</strong></p>
<p>만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않는다. 따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생한다. 이 경우에는 기본 생성자를 직접 추가해줘야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 2. 객체 생성 및 생성자의 호출</span></span><br><span class="line">        Car yourCar = <span class="keyword">new</span> Car(); <span class="comment">// 3. 기본 생성자의 호출 -&gt; 오류 발생</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 갖는 생성자를 정의하고 있다. 따라서 자바 컴파일러는 Car 클래스에 기본 생성자를 추가하지 않는다.</li>
<li>3번에서 기본 생성자를 호출하여 인스턴스를 생성하려고 한다. 자바 컴파일러가 오류를 발생시킨다. 오류를 발생을 없애기 위해서는 Car 클래스에 기본 생성자를 추가하면 된다.</li>
</ul>
<h1 id="this와-this"># this와 this()</h1>
<ul>
<li>this 참조 변수 : <strong>인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수이다.</strong> this 참조 변수는 해당 인스턴스의 주소를 가리키고 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 <strong>인스턴스 변수 앞에 this 키워드를 붙여 구분해야 한다.</strong></p>
<p>자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다. this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다. 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다.</p>
<ul>
<li>this() 메소드 : <strong>this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용한다.</strong> this() 메소드에 인수를 전달하면 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해줍니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"소나타"</span>;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Car()&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">33</span>,<span class="string">"그랜져"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">    System.out.println(myCar.getModel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 가지는 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근한다.</li>
<li>또한, 매개변수를 가지지 않은 기본 생성자는 내부에서 this() 메소드를 사용하여 매개 변수를 가진 생성자를 호출한다.</li>
<li>이처럼 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있다.</li>
</ul>
<blockquote>
<p>단, 한 생성자에서 다른 생성자를 호출할 때는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있습니다.</p>
</blockquote>
<h1 id="메소드-오버로딩"># 메소드 오버로딩</h1>
<ul>
<li>핵심은 <code>메소드 시그니처</code>
<ul>
<li>메소드 시그니처 : 메소드의 선언부에 명시되는 매개변수의 리스트를 말한다.</li>
<li>두 메소드의 매개변수의 개수와 타입, 그 순서까지 모두 같다면 두 메소드의 시그니처는 같다고 할 수 있다.</li>
</ul>
</li>
<li><strong>메소드 오버로딩</strong>은 같은 이름의 메소드를 매개변수의 개수와 타입을 다르게하여(중복) 정의하는 것이다.</li>
</ul>
<p><strong>즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이다.</strong></p>
<p>메소드 오버로딩을 통해 메소드에 사용되는 이름을 절약할 수 있다.<br>
또한, 메소드를 호출할 때 전달할 매개변수의 타입이나 개수에 대해 신경 쓰지 않아도 된다. <strong>메소드 오버로딩은 OOP의 특징 중 하나인 다형성의 한 예다.</strong></p>
<ul>
<li>메소드 오버로딩의 대표적인 예 : <code>println()</code>
<ul>
<li>전달받은 매개변수의 타입에 따라 다양한 원형 중 적절한 원형을 호출한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">메소드 원형</span><br><span class="line"><span class="number">1</span>. println()</span><br><span class="line"><span class="number">2</span>. println(<span class="keyword">boolean</span> x)</span><br><span class="line"><span class="number">3</span>. println(<span class="keyword">char</span> x)</span><br><span class="line"><span class="number">4</span>. println(<span class="keyword">char</span>[] x)</span><br><span class="line"><span class="number">5</span>. println(<span class="keyword">double</span> x)</span><br><span class="line"><span class="number">6</span>. println(<span class="keyword">float</span> x)</span><br><span class="line"><span class="number">7</span>. println(<span class="keyword">int</span> x)</span><br><span class="line"><span class="number">8</span>. println(<span class="keyword">long</span> x)</span><br><span class="line"><span class="number">9</span>. println(Object x)</span><br><span class="line"><span class="number">10</span>. println(String x)</span><br></pre></td></tr></table></figure>
<p><strong>메소드 오버로딩의 조건</strong></p>
<ol>
<li>메소드의 이름이 같아야 한다.</li>
<li>메소드의 시그니처 즉, 매개변수의 개수와 타입이 달라야 한다.</li>
</ol>
<ul>
<li><strong>메소드 오버로딩은 반환 타입과는 관계가 없다.</strong></li>
<li><strong>메소드의 시그니처는 같은데 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않는다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 전달받은 숫자 그대로 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1)</span></span>&#123; </span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 두 정수의 곱 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1*num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 정수와 실수의 합 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    test.display(<span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 2</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">3.14</span>); <span class="comment">// 3</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="string">'a'</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 사용자가 오버로딩된 함수를 호출하면 같은 메소드 시그니처를 갖는 메소드를 찾아서 호출한다.</li>
</ul>
<p>4번에서 문제가 발생한다. 자바에서 char형 데이터는 int형 뿐만 아니라 double형으로도 타입 변환될 수 있기 때문이다.</p>
<p>이 호출은 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출해야 할 지 불명확하다. 자바에서는 오버로딩한 메소드의 이러한 모호한 호출을 허용하지 않으며, 위와 같은 경우에는 <strong>더 작은 표현 범위를 가지는 int형으로 자동 타입 변환된다.</strong></p>
<p>4번 라인의 display() 메소드 호출은 영문 소문자 'a’의 아스키 코드값이 97이므로, int형으로 자동 타입 변환되어 두 수의 곱이 출력된다.</p>
<h1 id="재귀-호출"># 재귀 호출</h1>
<ul>
<li><code>재귀 호출(recursive call)</code>이란 메소드 내부에서 해당 메소드가 또 다시 호출되는 것을 의미한다.</li>
<li><strong>메소드 내에 재귀 호출을 중단하도록 조건이 변경된 명령문을 반드시 포함해야 한다.</strong></li>
</ul>
<p><strong>재귀 호출의 개념</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        result+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재귀 호출을 사용하지 않고 반복문으로 만든 메소드이다.</li>
<li>규칙</li>
</ul>
<ol>
<li>1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다.</li>
<li>1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다.</li>
<li>1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다.</li>
<li>1부터 1까지의 합은 그냥 1입니다.</li>
</ol>
<p>위의 알고리즘을 의사코드(psedo code)로 작성하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">시작</span><br><span class="line">    <span class="number">1</span>. n이 <span class="number">1</span>이 아니면, n과 <span class="number">1</span>부터 (n-<span class="number">1</span>)까지의 합을 더한 값을 반환함</span><br><span class="line">    <span class="number">2</span>. n이 <span class="number">1</span>이면, 그냥 <span class="number">1</span>을 반환함</span><br><span class="line">끝</span><br></pre></td></tr></table></figure>
<blockquote>
<p>의사 코드(psedo code)란 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드를 말한다.</p>
</blockquote>
<p>의사 코드로 작성하고 바로 코드로 옮겨서 재귀 호출을 구현한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursiveSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">// n이 1이면, 그냥 1을 반환</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n+recursiveSum(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 문이 존재하지 않으면, 이 프로그램은 실행 직후 <code>스택 오버플로우(stack overflow)</code>에 의해 종료될 것이다. 따라서 if문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.</p>
<blockquote>
<p>스택 오버플로우는 메모리 구조 중 스택 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/10/java-basic-6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/10/open-tutorials-8/"
                            aria-label=": 생활코딩 :: supervisor"
                        >
                            생활코딩 :: supervisor
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-10T10:51:48+09:00">
	
		    Aug 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="supervisor">supervisor</h1>
<p>우리가 자바스크립트 코드를 수정하면 node가 이것을 알아서 감지하지 못합니다. 그래서 우리는 코드를 수정하고 서버를 껐다 켜야 하는 번거로운 작업을 수행하고 변경된 내용이 반영되는 것을 확인할 수 있습니다.</p>
<p>이러한 작업은 이미 실행된 프로그램이 루프를 계속 돌고 있기 때문에 우리가 변경한 내용이 반영되지 않는 것입니다.</p>
<ul>
<li>watch : 변경된 사항을 보고 있다가 변경이 일어났을 때 자동으로 node를 내부적으로 껐다가 키는 것</li>
</ul>
<p>먼저, npm install supervisor -g 를 통해서 전역적으로 설치한 후</p>
<p><code>supervisor app.js</code>를 통해 코드를 수행하면 app.js가 실행이 되고 app.js의 코드를 수정하고 변경된 사항을 저장하면 아래와 같이 서버가 자동으로 꺼졌다가 켜지는 것을 확인할 수 있습니다.</p>
<img src="/img/app_js.png" width="400" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/10/open-tutorials-8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/09/java-basic-5/"
                            aria-label=": [Java] 5. 클래스"
                        >
                            [Java] 5. 클래스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-09T19:11:44+09:00">
	
		    Aug 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="객체지향-프로그래밍oop"># 객체지향 프로그래밍(OOP)</h1>
<p>객체 지향 프로그래밍(Object-Oriented Programming)에서는 모든 데이터를 <strong>객체</strong>로 취급하며, 객체가 바로 프로그래밍의 중심이 된다.</p>
<p><strong>프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.</strong><br>
상태 -&gt; Property로 정의.<br>
행위 -&gt; Method로 정의.</p>
<p><strong>장점</strong></p>
<ul>
<li>코드 재사용성이 높다.
<ul>
<li>만들어 놓은 클래스를 가져와 사용할 수 있고, 상속을 통해 확장하여 사용할 수 있다.</li>
</ul>
</li>
<li>유지보수가 쉽다.
<ul>
<li>수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메소드로 있기 때문에 해당 부분만 수정하면 된다.</li>
</ul>
</li>
<li>대형 프로젝트에 적합하다.
<ul>
<li>클래스 단위로 모듈화시켜 개발할 수 있으므로 업무 분담이 쉽다.</li>
</ul>
</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>실행 처리 속도가 상대적으로 느리다.</li>
<li>객체가 많으면 용량이 커질 수 있다.</li>
<li>설계시 많은 시간과 노력이 필요하다.</li>
</ul>
<h1 id="클래스와-인스턴스"># 클래스와 인스턴스</h1>
<p><strong>클래스</strong><br>
어떤 문제를 해결하이 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 <strong>변수와 메소드</strong>로 정의한 것이다.</p>
<p><strong>인스턴스</strong><br>
클래스에서 정의한 것을 토대로 <strong>실제 메모리상에 할당된 것</strong>으로 실제 프로그램에서 사용되는 데이터이다.</p>
<p>독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.<br>
하지만 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.</p>
<h1 id="메소드"># 메소드</h1>
<p>클래스는 멤버로 속성을 표현하는 필드와<br>
기능을 표현하는 <strong>메소드</strong>를 갖는다.<br>
메소드는 특정 작업을 수행하기 위한 명령문의 집합.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시</li>
<li>반환 타입 : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시</li>
<li>메소드 이름 : 메소드를 호출하기 위한 이름을 명시</li>
<li>매개변수 목록 : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시</li>
<li>구현부: 메소드의 고유 기능을 수행하는 명령문의 집합</li>
</ol>
<p>자바에서 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다.<br>
하지만, <code>메소드 오버로딩(overloading)</code>을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.</p>
<p><strong>메소드 오버로딩</strong></p>
<p>매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다.</p>
<p>메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다.<br>
또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 된다.</p>
<h1 id="클래스의-구성-요소"># 클래스의 구성 요소</h1>
<p>클래스의 멤버<br>
필드 : 속성을 표현<br>
메소드 : 기능을 표현<br>
생성자 : 객체의 필드를 초기화하는 메소드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 클래스 이름</span></span><br><span class="line">    <span class="keyword">private</span> String modelName; <span class="comment">// 필드</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear; <span class="comment">// 필드</span></span><br><span class="line"></span><br><span class="line">    Car(String modelName, <span class="keyword">int</span> modelYear)&#123; <span class="comment">// 생성자</span></span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123; <span class="comment">// 메소드</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear+<span class="string">"년식 "</span>+<span class="keyword">this</span>.modelName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>필드(field)</code>
<ul>
<li>클래스에 포함된 <strong>변수</strong>를 의미한다. 클래스 내에 선언된 위치에 따라서 다음과 같이 구분된다.</li>
</ul>
</li>
</ul>
<ol>
<li>클래스 변수(static variable)</li>
<li>인스턴스 변수(instance variable)</li>
<li>지역 변수(local variable)</li>
</ol>
<p><a href="https://woovictory.github.io/2018/08/06/java-basic-algorithm/">Java :: 기초에서 확인가능합니다.</a></p>
<ul>
<li>
<p><code>메소드(method)</code></p>
<ul>
<li>특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있으며, 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 된다.</li>
<li>유지보수가 용이하다.</li>
</ul>
</li>
<li>
<p><code>생성자(constructor)</code></p>
<ul>
<li>클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성된다. 하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태이다.</li>
<li>객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 <strong>초기화</strong>할 수 있는 <code>생성자(constructor)</code>라는 메소드를 제공한다. 자바에서 <strong>생성자의 이름은 클래스의 이름과 같아야 한다.</strong></li>
</ul>
</li>
</ul>
<h1 id="클래스의-선언"># 클래스의 선언</h1>
<img src="/img/class.png" width="600" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">클래스이름 객체참조변수이름; <span class="comment">// 1</span></span><br><span class="line">Car myCar; </span><br><span class="line"></span><br><span class="line">객체참조변수이름 = <span class="keyword">new</span> 클래스이름(); <span class="comment">// 2</span></span><br><span class="line">myCar = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">클래스이름 객체참조변수이름 = <span class="keyword">new</span> 클래스이름(); <span class="comment">// 3</span></span><br><span class="line">Car myCar = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>
<p>1번 : 객체 참조 변수 선언<br>
2번 : 객체를 생성한다.(메모리상에 할당된다.) 객체의 주소를 미리 선언한 참조 변수에 저장한다.<br>
3번 : 선언과 동시에 생성한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/09/java-basic-5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2018/archives/6/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2018/archives/8/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 7 of 13</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
