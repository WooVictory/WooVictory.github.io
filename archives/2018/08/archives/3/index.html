
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2018/8 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2018/08/archives/3/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/02/open-tutorials-3/"
                            aria-label=": 생활코딩 :: 동기와 비동기 프로그래밍"
                        >
                            생활코딩 :: 동기와 비동기 프로그래밍
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-02T20:09:51+09:00">
	
		    Aug 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="동기와-비동기-프로그래밍">동기와 비동기 프로그래밍</h1>
<hr>
<ul>
<li><code>동기(Synchronous)</code>
<ul>
<li>줄여서 <strong>sync</strong>라고도 부릅니다. 예를 들어서, 빨래와 설거지 청소의 3가지 일을 해야 한다면 빨래를 1시간 동안하고 끝낸 다음에 설거지를 1시간 동안하고 그 다음에 청소를 1시간 동안하고 끝냅니다. 총 3시간에 걸쳐서 일을 끝냅니다.</li>
<li>즉, 순차적으로 일을 스스로 끝내 나가는 방식입니다.</li>
</ul>
</li>
</ul>
<ul>
<li><code>비동기(Asynchronous)</code>
<ul>
<li>일단은 빨래하는 업체 A가 있고, 설거지 하는 업체 B, 청소하는 업체 C가 있다고 가정하면 빨래를 하기 위해서 A 업체에 전화를 하고 빨래가 끝나면 알려 달라고 한 다음에 전화를 끊고 B 업체에 전화해서 청소를 부탁하고 끝나면 알려 달라하고 전화를 끊고, C 업체에 전화해서 청소를 부탁하고 끝나면 알려 달라고 합니다.</li>
<li>전화를 하는데 각각 1분씩 걸렸다면 총 3분만에 일처리를 시작했다는 걸 끝낼 수 있습니다. 시간이 지난 후에 각각의 업체로부터 업무가 끝났다는 알림을 받을 수 있습니다.</li>
<li>어떤 업무가 먼저 끝날 지 알 수가 없다는 단점이 있습니다.</li>
</ul>
</li>
</ul>
<h1 id="예시">예시</h1>
<p>Node.js 사이트에서 document(문서)를 참고해서 <strong>file system</strong> 모듈을 참고합니다. <strong>file system</strong> 모듈은 Node.js를 이용해서 file을 제어하는 것과 관련된 기능을 합니다.</p>
<p>Node.js는 기본적으로 <strong>시간이 필요한 작업들</strong>(I/O가 필요한 작업)을 <code>비동기적</code>으로 처리합니다.</p>
<p>우리가 특별히 원할 경우에는 동기적으로 일을 처리할 수 있도록 Sync라는 키워드가 붙은 메소드들이 존재합니다.</p>
<h1 id="동기식-코드">동기식 코드</h1>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 실행 순서 1</span></span><br><span class="line"><span class="keyword">var</span> data = fs.readFileSync(<span class="string">'textdata.txt'</span>,&#123;<span class="attr">encoding</span>:<span class="string">'utf8'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(data); <span class="comment">// 실행 순서 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Hello Sync And Async</span><br></pre></td></tr></table></figure>
<p>만약 readFileSync를 통해서 파일을 읽는데 시간이 오래 걸린다면 동기적 처리 방식에서는 그 시간 동안 다른 작업을 수행할 수 없습니다.</p>
<h1 id="비동기식-코드">비동기식 코드</h1>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// 실행 순서 1</span></span><br><span class="line"><span class="keyword">var</span> data = fs.readFile(<span class="string">'textdata.txt'</span>,&#123;<span class="attr">encoding</span>:<span class="string">'utf8'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>); <span class="comment">// 실행 순서 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(data); <span class="comment">// 실행 순서 4</span></span><br><span class="line">	&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>); <span class="comment">// 실행 순서 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">Hello Sync And Async</span><br></pre></td></tr></table></figure>
<p>readFile을 통해서 파일을 읽는 동안 다른 작업을 먼저 수행합니다. 그리고 readFile이 파일을 다 읽고 에러가 없다고 판단하면 readFile 함수의 매개변수로 전달된 익명 함수(즉, Callback 함수)의 data라는 매개변수 값으로 textdata.txt 파일의 내용을 전달하고 이를 호출합니다. 그리고 이후 나머지 동작들을 수행하게 됩니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/02/open-tutorials-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/02/open-tutorials-2/"
                            aria-label=": 생활코딩 :: 콜백(Callback) 함수"
                        >
                            생활코딩 :: 콜백(Callback) 함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-02T19:05:18+09:00">
	
		    Aug 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="callback-함수">Callback 함수</h1>
<hr>
<p>Callback 함수를 배웠습니다.<br>
우선, <strong>Terminal</strong>에서 javascript로 작성된 파일을 node로 실행시킬 때는 <strong>node hello.js</strong>를 통해서 실행시키면 됩니다.<br>
하지만, 지금 배우는 환경에서는 <strong>node</strong>라고 입력하고 <strong>인터프리터</strong> 환경에서 실습을 진행할 예정입니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 여러번 사용될 함수라면 이름을 붙여줍니다.</span></span><br><span class="line">	<span class="keyword">return</span> v2-v1;</span><br><span class="line">&#125;</span><br><span class="line">a.sort(); <span class="comment">// [1,2,3]</span></span><br><span class="line">a.sort(b); <span class="comment">// [3,2,1]</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>)</span>&#123; </span><br><span class="line">	<span class="comment">// 이 경우 정렬할 때 한번만 사용할 목적이라면 익명 함수를 이용해 callback함수로 사용</span></span><br><span class="line">	<span class="keyword">return</span> v2-v1;</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>
<p>위의 코드를 보면 sort라는 함수의 인자로 다른 함수를 전달했고, 저렇게 전달된 함수를 <code>callback 함수</code>라고 부릅니다.</p>
<p>callback 함수를 우리는 정의했습니다. 하지만, 우리가 callback 함수를 호출하지 않았고, sort라는 함수가 필요할 때마다 내부적으로 b를 호출하고 있습니다. 다시 말해서, b라는 함수는 우리가 호출할 함수가 아니라 누군가에 의해서 나중에 호출 당할 함수입니다.</p>
<p>그리고 sort라는 함수가 가지는 기본적인 방법을 확장할 수 있는 가능성을 우리가 어떠한 logic을 주입함으로써 할 수 있었습니다. 이것이 Callback을 우리가 사용하는 이유입니다.</p>
<p><strong>Callback</strong> 함수를 사용하여 프로그램의 흐름을 끊지 않음으로서, <code>Non-Blocking</code> 코드를 사용하는 서버는 Blocking 코드를 사용하는 서버보다 더 많은 양의 요청을 빠르게 처리할 수 있습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/02/open-tutorials-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/02/open-tutorials-1/"
                            aria-label=": 생활코딩 :: 모듈과 NPM"
                        >
                            생활코딩 :: 모듈과 NPM
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-02T17:51:59+09:00">
	
		    Aug 02, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="인터넷의-동작-방법">인터넷의 동작 방법</h1>
<hr>
<p><strong>클라이언트</strong> : 웹 브라우저가 설치된 컴퓨터, 요청<br>
<strong>서버</strong> : Client가 요청한 정보를 응답<br>
<strong>도메인</strong> : 사람이 쉽게 이해할 수 있도록 만들어진 서버의 주소(이름)<br>
<strong>IP</strong> : 실제 웹 브라우저가 연결되는 주소<br>
<strong>Port</strong> : 웹 서버를 실행시킬 때 6만개의 포트 중에 80번 포트에 웹 서버를 실행시킵니다. 즉, 웹 서버를 실행시켜놓고 80번에 해당되는 문에다가 웹 서버를 연결시켜 놓고, 웹서버가 80번 포트를 바라보게 합니다. 즉, 80번 포트를 리스닝하게 하는 것입니다.</p>
<p>사용자가 이 서버에 접속할 때, 예를 들어서 <strong><a href="http://a.com:80" target="_blank" rel="noopener">http://a.com:80</a></strong> 이렇게 접속하면 웹 브라우저는 <strong><a href="http://a.com" target="_blank" rel="noopener">a.com</a></strong>에 해당되는 컴퓨터를 찾고 <strong><a href="http://a.com" target="_blank" rel="noopener">a.com</a></strong>에 해당되는 컴퓨터한테 <code>80번 포트</code>와 연결하고 싶다라고 얘기를 합니다. 그럼 그 컴퓨터가 80번 포트를 연결해주기 때문에 웹 브라우저를 통해서 들어온 접속은 80번 포트에서 리스닝하고 있는 즉, 듣고 있는 웹 서버를 호출하고 그 웹서버가 요청을 받아서 웹 서버가 응답할 수 있게 됩니다.<br>
이러한 과정이 인터넷의 동작 방법이라고 볼 수 있습니다.</p>
<blockquote>
<p>http로 접속하는 경우에는 <strong>80번 포트</strong>를 쓰자라는 약속이 되어 있기 때문에 끝에 붙이는 <code>:80</code>을 생략할 수 있습니다.</p>
</blockquote>
<h1 id="모듈과-npm">모듈과 NPM</h1>
<p><code>모듈</code>은 다른 말로는 <strong>부품</strong>이라고 할 수 있으며, 우리가 필요로 하는 모듈을 가져와서 쓸 수 있습니다. Node.js에서는 필요한 모듈을 가져와서 쓰기 위해서는 <strong>require</strong>라는 함수를 사용합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">// http라는 변수에 http라는 서버를 구동시키기 위해서 필요한 모듈을 담은 것이다.</span></span><br><span class="line"><span class="comment">// 이 http를 통해서 모듈을 제어할 수 있습니다.</span></span><br><span class="line"><span class="comment">// 값이 한 번 할당이 되면 그 이후에는 값을 바꿀 수 없음.</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o.platform());</span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">1338</span>;</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(port, hostname, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 코드가 웹브라우저를 통해서 요청한 내용을 받아서 우리에게 hello world라는 텍스트를</span></span><br><span class="line"><span class="comment">// 전송한 것입니다.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// createServer를 통해서 서버 한개를 만들고</span></span><br><span class="line"><span class="comment">// listen을 통해서 그 서버가 컴퓨터 한 대를 리스닝하게 만든다.</span></span><br><span class="line"><span class="comment">// 모듈은 부품과 같은 것이다. 그래서 가져다 쓸 수 있다.</span></span><br><span class="line"><span class="comment">// 우리가 필요한 모듈을 가져다 쓸 수 있고 그러한 모듈을 가져다 쓰기 위해서는</span></span><br><span class="line"><span class="comment">// require라는 함수를 호출해서 사용한다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>NPM</strong> : Node Package Manager</li>
<li>NPM -&gt; Node계의 앱스토어라고 부르기도 합니다.
<ul>
<li>어떠한 모듈을 우리의 프로젝트에 사용하기 쉽게 그리고 간편하게 설치하고 필요없으면 삭제할 수도 있고, 우리가 쓰고 있는 모듈이 기능 개선이 되었으면 업그레이드를 편리하게 해주고, 의존성 관리도 해줍니다.</li>
</ul>
</li>
<li>Node.js는 다양한 모듈을 제공합니다.
<ul>
<li>HTTP, OS -&gt; Node.js가 제공하는 모듈</li>
<li>Date, String, Array -&gt; JavaScript가 제공하는 모듈</li>
</ul>
</li>
<li>NPM은 다른 사람의 S/W를 가져와서 연결시켜주는 연결자의 역할을 하고 있습니다. 따라서 Node.js의 생태계의 중심에는 NPM이 있다고 할 수 있습니다.</li>
</ul>
<p>이번에는 타인의 모듈을 사용하는 방법을 배워볼 것이고 그 방법으로서 NPM을 사용해볼 것입니다.</p>
<ul>
<li>NPM 소프트웨어 패키지의 종류
<ul>
<li>
<p>독립적으로 동작하는 소프트웨어<br>
: npm install underscore -g<br>
g는 global의 약자이며, 전역적으로 실행할 수 있는 독립적인 소프트웨어의 설치</p>
</li>
<li>
<p>부품 모듈<br>
: 모듈을 설치하기 전에 지금 현재 진행하고 있는 프로젝트 폴더를 npm의 패키지로 초기화하는 작업을 거쳐야 합니다.<br>
-&gt; <strong>npm init()</strong> 사용하고 정보들을 등록합니다. 이 정보들을 명령어 수행 후 <code>package.json</code>이라는 파일에 저장되어 생성됩니다.<br>
<strong>npm install underscore</strong><br>
해당 폴더, 즉 패키지에서 부품으로 사용할 수 있는 모듈을 설치하는 것입니다.<br>
<strong>npm install underscore --save</strong><br>
<code>--save</code> 옵션을 주게 되면 underscore라는 모듈이 package.json 파일 안에 <strong>dependencies</strong> 항목으로 추가되기 때문에 이 프로젝트의 의존성을 명시적으로 표시해서 다른 디렉토리에서 이 프로젝트를 사용할 때 의존성을 갖고 있는 프로젝트를 쉽게 가져올 수 있습니다.<br>
어떠한 모듈을 항상 프로젝트에 포함시킬 때는 <code>--save</code> 옵션을 사용하는게 좋습니다.<br>
일시적으로 사용하는 모듈은 <code>--save</code> 옵션이 필요없습니다.</p>
</li>
</ul>
</li>
</ul>
<p>npm install underscore<br>
이렇게 옵션을 주면 해당 폴더, 즉 패키지에서 부품으로 사용할 수 있는 모듈을 설치하는 것입니다.</p>
<p>npm install underscore --save<br>
이렇게 --save 옵션을 주게 되면 underscore라는 모듈이 package.json 파일안에 dependencies 항목으로 추가되기 때문에 이 프로젝트의 의존성을 명시적으로 표시해서 다른 디렉토리에서 이 프로젝트를 사용할 때 의존성을 갖고 있는 프로젝트를 쉽게 가져올 수 있습니다.<br>
그리고 npm을 이용해서 모듈을 사용하기 전에는 지금 현재 프로젝트 폴더를 npm의 패키지로 초기화해야 합니다.<br>
npm init()</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/02/open-tutorials-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/01/nodejs-chap1/"
                            aria-label=": Nodejs :: Nodejs?"
                        >
                            Nodejs :: Nodejs?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-01T17:38:49+09:00">
	
		    Aug 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>SOPT라는 동아리를 통해서 Client 즉, Android에 대해서 공부하면서 프로젝트를 진행해보고 App 개발에 대한 실력을 얻었고 관련 지식도 얻을 수 있었습니다. 저는 Android에 대해 더 공부하기 위한 발판으로 서버 공부를 하기 위해서 JavaScript와 Node.js를 공부할 계획입니다. 공부하는 내용은 이곳에 포스팅할 예정입니다.</p>
<h1 id="javascript">JavaScript</h1>
<hr>
<ul>
<li>웹 브라우저에서 동작하는 스크립트 언어로 시작</li>
<li>다양한 분야에서 활용 가능, 풀스택개발까지 가능</li>
<li>가볍고 손쉽게 작성이 가능한 프로그래밍 언어</li>
<li>HTML 내에 코드를 삽입해서 사용 가능</li>
<li>거의 모든 브라우저에서 실행 가능</li>
<li><strong>이벤트 중심 프로그래밍</strong></li>
<li>Node.js의 등장으로 서버 사이드 개발 가능</li>
<li>클래스는 지원하지 않지만 <strong>객체 지향 프로그래밍</strong> 가능</li>
<li>대부분의 개념은 객체(기본 데이터타입, null, undefined)</li>
<li>함수조차 객체로 취급! -&gt; 일급 객체로 다뤄짐</li>
<li>실행 컨텍스트가 독특하다. -&gt; 스코프(객체의 유효범위)가 일반적이지 않다.</li>
<li>모든 객체는 <strong>프로토타입</strong>을 가짐</li>
<li><strong>일급객체</strong>와 <strong>클로저</strong>의 특성으로 <strong>함수 지향 프로그래밍</strong>까지 가능</li>
<li>Javascript의 표준이 ECMAScript이고 현재는 ECMAScript6(줄여서 ES6)가 표준</li>
</ul>
<h2 id="javascript-문법">Javascript 문법</h2>
<hr>
<p>Javascript는 변수 타입을 표시하지 않고, 값이 할당되는 과정에서 자동으로 자료형이 결정됩니다. =&gt; 그래서 같은 변수에 여러 자료형의 값을 대입할 수 있습니다.<br>
자료형은 var, let, const로 표시 -&gt; <strong>Scope</strong>의 차이</p>
<ul>
<li>String, Number, Boolean, undefined, null, Object의 자료형을 갖고 있습니다.</li>
<li>ES6에서 Symbol이 추가됨 : primitive type이기 때문에 new로 생성 X</li>
<li>기본 타입 : Number, String, Boolean, undefined, null + Symbol</li>
<li>참조 타입 : Array, Function(Object)
<ul>
<li>Object에는 배열, 함수, 정규표현식 등이 포함됩니다.</li>
</ul>
</li>
</ul>
<h2 id="자료형">자료형</h2>
<ol>
<li>Number<br>
다른 언어들처럼 여러 타입(short,int,long,byte) 등이 있지 않고, 정수값과 실수값을 구분하지 않습니다. <strong>모든 숫자를 실수로 표현합니다.</strong>(64bit의 floating point type으로 저장) 그리고 비트연산도 가능하자 속도가 느립니다.<br>
53bit의 정확도로 정수 표기 가능합니다. 즉, int형도 완벽히 표기 가능!</li>
</ol>
<ol start="2">
<li>String<br>
2byte의 값들이 연속적으로 나열되어 있습니다. 0기반의 인덱싱 사용(다른 언어와 동일)합니다.<br>
그리고 문자 하나를 표현하는 문자형은 제공하지 않습니다.(길이가 1인 문자열)<br>
또한, ‘(작은 따옴표)’,&quot;(큰 따옴표)&quot; 둘 다 가능하며, 여러 문자열을 '+'를 이용해 연결할 수 있습니다. (+가 <strong>addition</strong>과 <strong>concatenation</strong>으로 사용되기 때문에 주의하여 사용해야 합니다.)<br>
<code>문자열을 수정하는 모든 메소드는 새로운 문자열을 반환</code>합니다.</li>
</ol>
<ol start="3">
<li>Boolean<br>
true, false 중 하나의 값을 가지며, 비교의 결과로 생성됩니다.<br>
false : 0, “”, undefined, null, NAN(Not A Number)</li>
</ol>
<ol start="4">
<li>null, undefined<br>
<code>null</code>은 <strong>객체가 아님</strong>을 뜻하는 특수한 값입니다.<br>
<code>undefined</code>는 <strong>값이 없음</strong>을 나타내는 값으로 값 자체가 없거나 초기화 되어 있지 않거나 존재하지 않는 값에 접근할 때 사용합니다.<br>
시스템 레벨에서는 undefined, 일반적인 프로그램 레벨에서는 null을 사용</li>
</ol>
<ol start="5">
<li>Object<br>
속성(property) : 키(key) - 값(value)의 쌍으로 이루어지며, 속성끼리는 쉼표(,)로 구분합니다.<br>
키는 문자열만 가능하고 따옴표가 있어도 없어도 가능합니다.</li>
</ol>
<ol start="6">
<li>Array<br>
[]로 감싸며, 값들이 <strong>순서대로 나열</strong>되어 있습니다.<br>
배열의 원소에는 다른 데이터 타입들이 들어갈 수 있습니다.</li>
</ol>
<ul>
<li>기본 자료형
<ul>
<li>Number</li>
<li>String : &quot; &quot;,’ ’ 둘 다 가능</li>
<li>Boolean : true/false</li>
<li>Array : 0 이상의 임의의 종류의 값으로 이루어진 순서가 있는 리스트. 대괄호 [] 사용</li>
<li>Object : 순서가 없는 이름 - 값 의 쌍으로 이루어진 집합이며, 이름(키)은 문자열입니다. 중괄호 {} 사용</li>
<li>null</li>
</ul>
</li>
</ul>
<h2 id="함수function">함수(Function)</h2>
<ul>
<li>일급객체<br>
javascript는 함수형 프로그래밍 언어이며, 객체가 <code>일급 객체</code>(<strong>First Class Object</strong>)입니다. =&gt; 함수도 객체! =&gt; 함수가 일급 객체!<br>
익명 함수(Anonymous Function) : 함수의 이름이 없는 함수<br>
고차 함수(Higher-Order Function) : 함수를 인자로 받거나 반환할 수 있는 함수</li>
</ul>
<p><strong>일급 객체의 조건</strong></p>
<p>(1). 변수나 데이터 구조 안에 담을 수 있습니다.<br>
(2). 다른 함수의 파라미터로 전달할 수 있습니다.<br>
(3). 반환값(return value)로 사용할 수 있습니다.<br>
(4). 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다.<br>
(5). 동적으로 프로퍼티 할당이 가능합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수나 데이터 구조 안에 담을 수 있습니다.</span></span><br><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();</span><br><span class="line"><span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 다른 함수의 파라미터로 전달할 수 있습니다.</span></span><br><span class="line"><span class="keyword">var</span> func2_1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> func2_2 = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2_2(func2_1());</span><br><span class="line"><span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 반환값(return value)로 사용할 수 있습니다.</span></span><br><span class="line"><span class="keyword">var</span> func3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func3()(); </span><br><span class="line"><span class="comment">// (3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다.</span></span><br><span class="line"><span class="keyword">var</span> func4 = <span class="function"><span class="keyword">function</span> <span class="title">func44</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func4();</span><br><span class="line"><span class="comment">// (4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 동적으로 프로퍼티 할당이 가능합니다.</span></span><br><span class="line"><span class="keyword">var</span> func5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">func5.property = <span class="string">'55'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(func5.property);</span><br><span class="line"><span class="comment">// (5)</span></span><br></pre></td></tr></table></figure>
<h2 id="함수의-생성-방법">함수의 생성 방법</h2>
<hr>
<ul>
<li>함수 선언문을 사용한 생성
<ul>
<li>코드 블록 자체는 실행 가능한 코드는 아님</li>
<li>함수명이 반드시 정의되어야 함</li>
<li>일반적인 언어의 함수 정의와 같음</li>
<li>매개변수의 타입을 표시하지 않음</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'func1 : '</span>+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 표현식을 사용한 생성
<ul>
<li>함수 리터럴(표현식)로 특정 변수에 할당되거나 즉시 실행 가능한 코드 블록</li>
<li>일급 객체이므로 변수에 할당이 가능</li>
<li>함수의 이름은 선택 사항이고 함수 표현식에서 사용된 함수 이름은 외부에서 접근할 수 없음 -&gt; 그래서 보통 익명함수로 생성 후 변수명으로 사용합니다.</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'func2 : '</span>+n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func4 = <span class="function"><span class="keyword">function</span> <span class="title">func44</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'func4 : '</span>+n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>생성자 함수를 사용한 생성
<ul>
<li>함수가 <strong>일급 객체</strong>이기 때문에 객체 생성 방식과 비슷</li>
<li>new 키워드로 객체를 생성할 수 있는 함수</li>
<li>prototype을 사용하여 한 번만 메소드를 생성할 수 있음</li>
<li>자주 사용하지 않습니다.</li>
</ul>
</li>
</ul>
<h2 id="jsonjavascript-object-notation">Json(JavaScript Object Notation)</h2>
<hr>
<ul>
<li><code>속성 - 값</code>의 쌍으로 이루어진 데이터 Object를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷을 말합니다.</li>
<li>일반적으로 서버에서 클라이언트로 데이터를 보낼 때 사용하는 포맷입니다.</li>
<li>또한, 자바스크립트에서 파생되어 자바스크립트의 구문 형식을 따르지만 언어 독립형 데이터 포맷입니다.-&gt; 자바스크립트에서만 사용하는 것이 아님!</li>
<li>공식 인터넷 미디어 타입 : application/json</li>
<li>프로퍼티 사이의 구분은 쉼표(,)로 하고 마지막 프로퍼티 끝에는 붙이지 않습니다.</li>
<li>아래와 같이 둘 다 가능합니다.</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span> : <span class="string">"이승우"</span>,</span><br><span class="line">	<span class="attr">"age"</span> : <span class="number">25</span>,</span><br><span class="line">	<span class="attr">"married"</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	name : "이승우",</span><br><span class="line">	age : 25,</span><br><span class="line">	marrie" : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. Object() 생성자 함수 이용</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">server.name = <span class="string">"이승우"</span>;</span><br><span class="line">server.age = <span class="number">26</span>;</span><br><span class="line">server.married = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2. 객체 리터럴(표현식) 방식 이용</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = &#123;</span><br><span class="line">	name : <span class="string">"이승우"</span>,</span><br><span class="line">	age : <span class="number">25</span>,</span><br><span class="line">	married : <span class="literal">false</span>,</span><br><span class="line">	gender : <span class="string">"남자"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 프로퍼티 접근</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server[<span class="string">"name"</span>];</span><br><span class="line">server[<span class="string">"age"</span>];</span><br><span class="line">server.married;</span><br><span class="line">server.gender;</span><br></pre></td></tr></table></figure>
<p>이처럼 <strong>대괄호 표기법</strong>을 이용하면 프로퍼티 이름을 문자열 형식으로 적어줘야 접근할 수 있습니다. 만약 server[name]으로 접근시 <strong>undefined</strong></p>
<p>마침표 표기법을 이용해서 간단한게 <code>.</code>을 통해서 객체의 프로퍼티에 접근할 수 있습니다.</p>
<p><strong>4. 객체 프로퍼티 순회</strong></p>
<p><code>for in</code>문을 사용해서 객체의 프로퍼티에 접근할 수 있습니다. 객체에 포함된 모든 프로퍼티에 대해 루프를 수행합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> server)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(server[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. 객체 프로퍼티 삭제</strong></p>
<p><code>delete</code>연산자를 통해서 가능합니다. delete 연산자가 객체의 <strong>프로퍼티</strong>는 삭제할 수 있지만 객체 자체를 삭제할 수는 없습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>(server.name);</span><br></pre></td></tr></table></figure>
<h2 id="배열">배열</h2>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nameOfArray = [<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">"sopt"</span>,<span class="literal">true</span>, &#123;<span class="string">"part"</span> : <span class="string">"server"</span>, <span class="string">"name"</span> : <span class="string">"이승우"</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 배열의 원소에는 <strong>다른 데이터 타입</strong>들이 들어갈 수 있습니다. 또한, 함수도 <strong>객체</strong>이므로 들어갈 수 있습니다.</p>
<p><strong>1. 배열 요소 추가</strong><br>
동적으로 배열 원소를 추가할 수 있습니다. 특히나, 값을 순차적으로 넣을 필요 없이 <strong>아무데나 넣을 수 있습니다.</strong><br>
array.push(넣을값) -&gt; 가장 끝에 있는 인덱스 뒤에 넣습니다.<br>
array.splice(index,0,item) -&gt; 원하는 index에 item 값을 넣을 수 있습니다.</p>
<p><strong>2. 배열 요소 삭제</strong><br>
<code>delete</code>를 통해 배열 요소를 삭제할 수 있습니다. 삭제를 하고 나서는 해당 인덱스의 값이 <strong>undefined</strong>로 남아 있습니다. 즉, 비어있는 상태로 남아있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>(nameOfArray[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p><strong>3. 배열 요소 접근</strong><br>
array[음이 아닌 정수 or 변수]로 배열 요소에 접근이 가능합니다. 그리고 <strong>현재 배열 내 없는 인덱스로 접근하더라도</strong> <code>out of bound</code> <strong>가 나지 않습니다.</strong></p>
<p><strong>4. 배열 요소 순회</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"** 배열 요소 순회 예제 **"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameOfArray.length; i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(nameOfArray[i]);</span><br><span class="line">&#125; <span class="comment">// 배열 내 없는 원소까지 undefined로 모두 출력</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">in</span> nameOfArray)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(nameOfArray[j]);</span><br><span class="line">&#125; <span class="comment">// 배열 내 없는 원소는 출력하지 않음</span></span><br></pre></td></tr></table></figure>
<p><strong>5. 배열도 객체다!</strong><br>
<code>배열이름.프로퍼티이름 = 값</code>으로 프로퍼티를 추가하는 것이 가능합니다. 또한, length도 메소드가 아니라 <strong>객체의 프로퍼티</strong>입니다. 그래서 실제 배열의 길이와 관계없이 변경이 가능합니다. <strong>인덱스</strong>에만 관계가 있기 때문에 배열 객체의 프로퍼티는 length에 포함되지 않습니다.</p>
<h2 id="실행-컨텍스트">실행 컨텍스트</h2>
<hr>
<p>아직까지 무슨 이야기인지 잘 모르겠습니다…ㅜ_ㅜ</p>
<p>자바스크립트가 실행될 때 생성되는 하나의 실행 단위를 말합니다. C,C++,Java 등의 콜스택에 들어가는 하나의 실행정보와 비슷한 개념입니다. 실행 가능한 자바스크립트 코드 블록이 실행되는 환경입니다.</p>
<p>현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동합니다.</p>
<p>실행 컨텍스트 생성 과정</p>
<ol>
<li>활성 객체 생성</li>
<li>arguments 객체 생성</li>
<li>스코프 정보 생성</li>
<li>변수 생성 -&gt; 여기서 선언이 이루어짐</li>
<li>this 바인딩</li>
<li>코드 실행 -&gt; 여기서 할당이 이루어짐</li>
</ol>
<ul>
<li><strong>변수 타입별 스코프(영역)</strong>
<ul>
<li>var : 함수 단위 스코프, 재선언 가능, 재할당 가능</li>
<li>let, const : 블록 단위 스코프 (일반적인 C,C++,Java)</li>
<li>let : 재선언 불가능, 재할당 가능</li>
<li>const : 재선언 불가능, 재할당 불가능</li>
</ul>
</li>
</ul>
<blockquote>
<p>호이스팅이란?? - 사실, 이 친구도 어려워요…ㅜ</p>
</blockquote>
<p><strong>변수, 함수의 선언부가 스코프 가장 위로 끌어올려지는 것</strong>을 말합니다. 블록 내부에 정의된 변수는 블록에 포함된 함수 전체에 선언되는 것과 같으므로 <code>유효범위가 함수 전체로 확대</code>됩니다. 반복문, 조건문 내부에 사용된 변수를 같은 함수 내라면 바깥에서 접근이 가능합니다.<br>
또한 함수 표현식으로 정의되어 있으면 호이스팅이 발생하지 않습니다.</p>
<h2 id="연산자의-종류">연산자의 종류</h2>
<hr>
<p>보통의 연산자는 다른 언어와 유사합니다. 그래서 일반적이지 않은 <strong>javascript</strong>의 연산자에 대해서 공부해보았습니다.</p>
<ul>
<li>
<p><strong>관계 연산자</strong></p>
<ul>
<li>두 피연산자의 관계를 검사하여 관계가 성립하면 true, 아니면 false를 반환합니다.</li>
<li>항상 Boolean 값을 반환합니다.</li>
</ul>
</li>
<li>
<p><strong>동등 연산자 vs 일치 연산자</strong></p>
<ul>
<li>==, != (동등 연산자, Equality) : 타입이 다를 경우 형변환(묵시적 형변환)을 한 후에 값을 비교합니다. 즉, 타입이 달라도 동등할 수 있습니다.</li>
<li>===, !== (일치 연산자, Identity) : 형변환을 하지 않고 현재 상태로 값을 비교합니다. 즉, 타입이 다르면 일치하지 않습니다.</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><strong>+ 연산자</strong></p>
<ul>
<li>Number + Number =&gt; 더하기 연산 수행</li>
<li>String + String, Number + String, String + Number =&gt; 문자열 연결 연산을 수행</li>
<li>여러 숫자, 문자열을 결합 시 연산자가 실행된 순서에 따라 연산 결과가 바뀌게 됩니다.</li>
</ul>
</li>
<li>
<p><strong>/ 연산자</strong></p>
<ul>
<li>자료형만 확실히 이해하고 있다면 어렵지 않습니다. console.log(5/2)의 결과는 =&gt; <strong>2.5</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>typeof 연산자</strong>
<ul>
<li>피연산자의 타입을 String 형태로 반환하는 연산자</li>
</ul>
</li>
</ul>
<p><img src="/img/typeof.png" alt=""></p>
<h2 id="변수의-범위variable-scope">변수의 범위(Variable Scope)</h2>
<hr>
<p>변수가 존재하는 컨텍스트(함수가 실행되거나 변수를 참조할 때의 환경). 어디에서 변수가 접근할 수 있는지, 그 컨텍스트에서 변수에 접근할 수 있는지를 명시적으로 나타냅니다.</p>
<ul>
<li>지역 변수(함수 수준 범위) : 함수 내에 정의된 변수는 지역 범위를 가지며, 해당 함수와 내부 함수에서만 접근이 가능합니다. 지역 변수는 함수 내에서 전역 변수보다 높은 우선순위를 갖습니다.</li>
<li>전역 변수 : 함수의 외부에서 선언된 모든 변수는 전역 범위를 가집니다. 전역 컨텍스트(scope)는 window를 가리킵니다.</li>
</ul>
<p>지금까지 Javascript에서 변수를 선언하는 방법은 var를 이용하는 것 뿐이었다고 합니다. 물론 Javascript 특성상 var 없이 변수를 선언하는 것도 가능하지만 부작용이 심각하기 때문에 실무에서는 적용하지 않는 것이 보통입니다. 일이 아니더라도 var 선언 없이 변수를 사용하는 것은 정신건강에 좋지 않기 때문에 절대로 사용하지 말 것을 권장한다고 합니다.</p>
<p>본론으로 넘어가서, <strong>ES6</strong>로 넘어오면서 <code>let</code>과 <code>const</code>라는 새로운 선언 방법이 생겼습니다.</p>
<ul>
<li><code>var</code> : function-scoped. 변수 재선언 가능</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 에러가 발생하지 않습니다. 변수 foo는 값이 정의되지 않은 형인 <strong>undefined</strong>가 되어 있을 뿐입니다. 선언보다 호출이 먼저 있었음에도 불구하고 이 코드는 정상적으로 작동합니다. 이유는 <code>호이스팅</code>이라는 키워드를 검색해보면 알 수 있습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> foo = <span class="string">'bar1'</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(foo); <span class="comment">// bar1</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  	<span class="keyword">var</span> foo = <span class="string">'bar2'</span>;</span><br><span class="line">  	<span class="built_in">console</span>.log(foo); <span class="comment">// bar2</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">console</span>.log(foo); <span class="comment">// bar2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ab();</span><br></pre></td></tr></table></figure>
<p>위의 코드가 ab()라는 함수 안에 존재한다고 했을 때, if문 밖의 변수 foo와 if문 안의 변수 foo는 <strong>동일한 변수</strong>가 됩니다. 중복 선언을 했지만 앞서 말한바와 같이 별다른 에러를 발생시키지 않고, 값마저 'bar2’로 변경해버립니다.</p>
<p>하지만, <strong>let</strong>과 <strong>const</strong>는 <code>Block-scoped</code>라고 합니다. 유효 범위가 블록 즉, {}로 감싸지는 범위라는 뜻입니다.</p>
<ul>
<li><code>let</code> : block-scoped. 변수 재선언 불가능. 변수 재할당 가능</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="string">"kim"</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">"lee"</span>; <span class="comment">// 재선언 불가능. 에러 발생</span></span><br><span class="line">c = <span class="string">"lee"</span>; <span class="comment">// 재할당 가능. 에러 없이 정상적으로 작동</span></span><br></pre></td></tr></table></figure>
<p>위의 코드를 통해서 <strong>let</strong>이 잘 작동하는지 확인해보았습니다. 그리고 여러 예제를 통해서 let의 의미를 더 알아보았습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// bar1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'bar2'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo) <span class="comment">// bar2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// bar1</span></span><br></pre></td></tr></table></figure>
<p>위 코드에서는 var를 사용한 경우와는 달리 if문 밖의 foo와 if문 안의 foo는 서로 다른 변수입니다. 따라서 중복 선언으로 인한 에러도 발생하지 않으며, if문 안쪽에서 선언한 foo의 경우 if문이 닫히는 시점에서 유효 범위가 끝납니다.</p>
<p>여기서 의문이 조금 생깁니다. if문 안에서 foo를 먼저 호출한 다음 let으로 foo에 값을 할당하게 된다면??</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// bar1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo) <span class="comment">// bar1</span></span><br><span class="line">  foo = <span class="string">'bar2'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo) <span class="comment">// bar2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// bar2</span></span><br></pre></td></tr></table></figure>
<p>걱정했던 것과는 다르게 정상적으로 호출도 되고 값의 변경에도 아무 문제가 없습니다. 그럼 foo 호출 이후에 let으로 foo를 선언해보겠습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">'bar1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// bar1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">  <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">'bar2'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br></pre></td></tr></table></figure>
<p><strong>foo는 정의되지 않았다는 에러가 발생합니다.</strong> 앞에서 말한 <code>임시적 사각지대</code>(TDZ)의 정체가 이것입니다. 어떤 변수가 호출되었을 때 블록 안에 같은 이름의 변수가 없으면 상위 블록에서 선언된 같은 이름의 변수를 호출합니다. 하지만 블록 안에서 let이나 const로 변수 선언이 있었다면 그 이름의 변수는 변수가 선언되기 이전까지 그 블록 안에서는 정의되지 않은 변수로 간주되는 것입니다.</p>
<ul>
<li><code>const</code> : block-scope. 변수 재선언 불가능. 변수 재할당 불가능</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo;</span><br></pre></td></tr></table></figure>
<p>호출한 시점에서 변수가 선언되어 있지 않음을 알리는 에러가 발생합니다;. 일시적 사각지대(Temporal Dead Zone : TDZ)라는 개념인데, 특정 개념을 설명하지 않더라도 let과 const의 동작 방식이 직관적이고 자연스럽다고 생각합니다.</p>
<p>실제로 원시형(primitives type : String, Number, Boolean, null, undefined)에서 const는 <strong>상수</strong>로 동작합니다. 따라서 <code>const</code>로 선언되면 값을 재할당할 경우 에러가 발생합니다. 또한, 당연하게도 초기값을 설정하지 않으면 에러가 발생합니다.</p>
<p>따라서 단순형의 경우 값의 변경이 있는 경우에는 <strong>let</strong>으로, 상수로 사용하는 경우에는 <strong>const</strong>로 선언하는 것이 바람직합니다.</p>
<p>하지만, 참조형(Complex tyupe : Array, Object, Function)의 경우 결론부터 말하자면 <strong>const</strong>로 선언하는 것이 바람직합니다. 참조형은 const로 선언하더라도 멤버값을 조작하는 것이 가능합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo3 = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> bar3 = foo3;</span><br><span class="line"> </span><br><span class="line">foo3.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo3, bar3);</span><br><span class="line">bar3[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo3, bar3);</span><br></pre></td></tr></table></figure>
<p>위의 결과를 보면 const bar = foo;의 선언으로 bar는 foo를 참조합니다. 참조가 아니라 값을 <strong>복사</strong>(copy)하는 경우에는 <code>array</code>는  … 연산자를 사용하고, <code>object</code>는 assign() 함수를 사용합니다.</p>
<ul>
<li>호이스팅 : 변수의 정의가 그 범위에 따라 선언과 할당이 분리되는 것을 의미
<ul>
<li>함수 내에서 정의되었을 경우 : 선언이 함수의 최상위</li>
<li>함수 바깥에서 정의되었을 경우 : 전역 컨텍스트의 최상위로 변경</li>
<li>변수의 선언이 초기화나 할당시에 발생하는 것이 아니라, 최상위로 호이스트 됨</li>
<li>함수 선언문 방식만 호이스팅이 제대로 이루어짐</li>
</ul>
</li>
</ul>
<p>함수 선언은 변수 선언을 덮어씁니다. 하지만, 변수에 값이 할당될 경우 반대로 변수가 함수 선언을 덮어쓰게 됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'test'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> test); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<ul>
<li>변수는 <strong>camelCase</strong>로 작성합니다. [ ex. var mainTest; ]</li>
<li><strong>세미콜론</strong>은 항상 붙여줍니다.</li>
<li>변수 선언은 스코프 상단에 선언합니다.</li>
<li>동치 연산자(==,!=)보다는 일치 연산자(===,!==)를 사용합니다.</li>
<li>중괄호 ‘{’ 위치는 선언문과 같은 줄에</li>
</ul>
<ul>
<li>결론
<ul>
<li>ES6에서는 var는 지양하고 가급적 let과 const를 사용</li>
<li>원시형 변수는 let, 상수는 const로 선언</li>
<li>참조형은 const로 선언</li>
</ul>
</li>
</ul>
<h1 id="nodejs">Node.js?</h1>
<hr>
<p><code>Nodejs</code>는 <strong>Chrome V8 JavaScript</strong> 엔진으로 빌드된 JavaScript 런타임 환경으로 주로 서버 사이드 애플리케이션 개발에 사용되는 소프트웨어 플랫폼입니다.<br>
Javascript가 브라우저 밖에 존재하지 않았던 한계를 극복하여 브라우저 외부 환경에서 Javascript 애플리케이션 개발에 사용되며 이에 필요한 모듈, 파일 시스템, HTTP 등 Built-in API를 제공합니다. 또한, Node.js는 이벤트 기반, 논 블로킹 I/O 모델을 사용해 가볍고 효율적입니다.</p>
<blockquote>
<p>런타임(RunTime)이란??</p>
</blockquote>
<p>단순하게 말해서 프로그래밍 언어가 구동되는 환경이라고 이해하면 됩니다. Javascript라면 Web Browser에서 작동하는 Javascript 측면이 있고, Node.js라는 환경에서 구동되는 측면이 존재합니다. 여기에서의 <strong>Browser</strong>와 <strong>Node.js</strong>를 런타임이라고 볼 수 있습니다.</p>
<h1 id="특징">특징</h1>
<hr>
<p>기존의 웹에서 서버는 <code>스레드를 기반으로 하는 동기 방식(Multi-Thread)</code>으로 네트워크 입출력을 처리합니다. 여기서 <strong>동기 방식</strong>이란 작업 요청이 들어올 때마다 스레드를 여러 개 만들어 동시에 일을 처리하는 것을 말합니다. 좋은 해결법이지만, 일이 많아질수록 스레드를 더 많이 만들어야 하므로 <code>메모리 사용량이 많아</code>질 수 있습니다. 그러나 서버의 자원이 <strong>제한</strong>되어 있기 때문에 <strong>Thread</strong>를 무한히 생성할 수는 없습니다.</p>
<p><code>Multi-Thread</code> 방식은 이러한 문제를 서버의 성능을 높이거나 Load-Balancing 등으로 분산 처리하여 해결합니다. Multi-Thread 방식은 Thread 간의 공유 자원 접근 시에도 신중해야 합니다. 각 Thred는 독립적인 시점에서 동작하기 때문에 공유 자원에 대한 동기화도 반드시 필요합니다.</p>
<p>Node.js의 경우, 모든 API는 <code>이벤트 기반 비동기 방식으로 동작</code>하여 <strong>Non-blocking</strong> <strong>I/O</strong>가 가능(제어권을 넘김)하여 요청을 처리하면서 다음 요청을 받을 수 있습니다. 또한, <code>single thread를 사용</code>하여 Multi Thread의 문제로부터 자유롭습니다.</p>
<h1 id="nodejs-동작원리">Node.js 동작원리</h1>
<hr>
<p><img src="/img/nodejs.png" alt=""></p>
<p><code>Node.js</code>는 <strong>Event-Callback</strong> 방식을 이용하여 <code>비동기식 처리</code>를 진행합니다. 클라이언트가 Event를 요청하면 Message 형태로 Event Queue에 저장됩니다. Event Loop는 Node.js에서 Single thread에서 돌아가며 I/O Bound 작업들을 비동기적으로 처리하기 위하여 필요합니다. Event Loop가 Queue에 있는 Task를 Pop하여 kernel에 요청하게 되는데 처리하는 동안 제어권은 다음 요청으로 넘어가게 됩니다. (Non-Blocking:또 다른 요청을 처리할 수 있게 됩니다.) <strong>요청이 Blocking I/O 혹은 처리에 많은 시간을 요구하는 복잡한 성격의 요청(파일 시스템 I/O, 데이터베이스, 외부 서비스 처리 등)이라면 내부 쓰레드 풀에서 대기 중인 쓰레드에게 요청을 위임합니다. 요청이 Non-Blocking I/O 또는 복잡하지 않은 작업이라면 Event Loop Thread는 요청을 즉각 처리합니다.</strong></p>
<p>요청 처리가 완료되면 Callback을 호출하여 처리 완료를 클라이언트에게 전달합니다. 내부적으로 비동기식 방식(Non-Blocking)을 지원하지 않는 task는 Multi Thread Pool로 처리하는데 이는 내부 처리를 위한 목적이며 요청 처리 자체를 Thread로 하지 않습니다.</p>
<p><img src="/img/node.png" alt=""></p>
<p>그림을 통해 설명하자면, Client A가 요청을 하면 CPU 작업이 수행되고 I/O 요청을 보냅니다. <code>Non-Blocking</code> 처리 방식을 사용하기 때문에 I/O 작업을 수행하며 또 다른 요청을 처리할 수 있습니다. Client B의 요청이 오면 CPU 작업을 수행하고 I/O 요청을 보냅니다. I/O 작업 시 기다리지 않기 때문에 <strong>single thread</strong>가 다른 요청을 받아서 작업을 처리할 수 있는 구조입니다.</p>
<p><strong>Event Loop</strong>는 Single Thread로 이루어져 있습니다. 따라서, 하나의 request 처리 작업이 CPU를 많이 사용(CPU intensive한 처리)하게 된다면 전체 서버 처리에 영향을 줄 수 있는 단점이 있습니다. (다른 요청이 CPU 작업을 수행하기 힘들다.) 이에 따라, 처리해야할 작업이 CPU를 많이 소모한다거나 대용량 파일을 처리해야 한다면 Node.js가 적합하지 않을 수 있습니다.</p>
<h1 id="장단점">장단점</h1>
<hr>
<p><code>이벤트 기반 비동기 방식</code>으로 많은 클라이언트 요청에 대하여 이벤트 루프를 사용하기 때문에 <strong>많은 스레드를 사용하지 않습니다.</strong> 따라서, 멀티 스레드 방식보다 Thread 수가 적기 때문에 <strong>메모리 또는 자원 소모가 작습니다.</strong> 오버헤드 또한 적습니다.</p>
<p>추가적인 장점으로 <code>JavaScript</code>를 사용하여. <strong>웹 개발자가 쉽게 접근</strong>할 수 있습니다. 또한, Google이 만든 자바스크립트 엔진을 사용하고 있습니다. 계속해서 여러 큰 기업들이 경쟁하며 자바스크립트 엔진의 속도를 높이고 있어 Google이 무너지지 않는 이상 속도는 계속 빨라질 것입니다.</p>
<p>마지막 장점으로, C++로 개발된 V8 JavaScript 엔진을 사용하여 C++을 사용해 기능을 확장할 수 있습니다.<br>
JavaScript를 사용한 것이 단점이 될 수도 있습니다. C/C++로 개발된 서버 애플리케이션보다는 느리기 때문입니다. 그러나, 또 다른 스크립트 언어를 사용해서도 웹 개발이 많이 이루어지고 있어 큰 문제라고는 생각할 수 없습니다.</p>
<p><strong>Single Thread</strong>기반의 비동기 I/O처리, 이벤트 처리 방식으로 인해 성능이 매우 빠릅니다. 또한, 시스템 리소스의 부하가 적습니다.</p>
<p>또한, Single Thread를 사용하기 때문에 <code>CPU intensive한 영역에서는 약한 모습</code>을 보입니다. 그러나 상대적으로 CPU intensive한 작업이 없고, 많은 Connection을 동시에 처리해야 하는 경우에는 node.js의 성능이 압도적으로 높은 것을 알 수 있습니다.</p>
<p>단점으로는 일을 처리하는 한 명(즉,Single Thread)이 쓰러지는 순간 <strong>프로그램 전체에 문제</strong>가 발생하게 됩니다.<br>
또한, 하나의 작업 자체가 시간이 많이 걸리면, 전체 시스템의 성능이 급격하게 떨어집니다. 그리고 코드의 가독성이 떨어져 유지보수가 어렵습니다.<br>
마지막으로 에러가 날 경우 프로세스 자체가 죽어버립니다.</p>
<p>요약하자면, 개발 관점에서는 빠르고 쉬운 장점이 있지만, 반대로 운영관점에서는 테스트, 디버깅 등에 어려움이 있을 수 있습니다. 대규모 프로젝트나 게임 서버보다는 <strong>RESTful API 서버, 채팅 서버</strong> 등에 적절합니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/01/nodejs-chap1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/01/java-basic-1/"
                            aria-label=": [Java] 1. 타입"
                        >
                            [Java] 1. 타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-01T01:45:03+09:00">
	
		    Aug 01, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바의 기초적인 문법과 개념을 정리하는 공간</p>
<h1 id="java-program"># Java Program</h1>
<ul>
<li>한 개 이상의 <strong>클래스</strong>로 구성된다.</li>
<li>클래스는 한 개 이상의 필드나 메소드로 구성된다.</li>
<li>main() 메소드를 가지는 클래스가 반드시 하나 존재해야 한다.</li>
<li><strong>소스 파일의 이름은 해당 public 클래스의 이름과 같아야 한다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Victory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Victory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="변수variable"># 변수(variable)</h1>
<ul>
<li>데이터를 저장할 수 있는 <strong>메모리 공간</strong>을 의미.</li>
<li>저장된 값은 변경 가능하다.</li>
</ul>
<h2 id="변수의-이름-생성-규칙">변수의 이름 생성 규칙</h2>
<ul>
<li>변수의 이름은 해당 변수에 저장될 <strong>데이터의 의미</strong>를 잘 나타내도록 짓는 것이 좋다.</li>
</ul>
<ol>
<li>영문자(대소문자), 숫자, 언더스코어,달러($)로만 구성할 수 있다.</li>
<li>숫자로 시작할 수 없다.</li>
<li>변수의 이름 사이에는 공백을 포함할 수 없다.</li>
<li>자바에서 미리 정의된 키워드를 사용할 수는 없다.</li>
</ol>
<h2 id="변수의-종류">변수의 종류</h2>
<ul>
<li>기본형 변수(primitive type)
<ul>
<li>계산을 위해 <strong>실제 연산</strong>에 사용되는 변수.</li>
<li>논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)</li>
</ul>
</li>
<li>참조형 변수(reference type)
<ul>
<li>8개의 기본형을 제외한 나머지 타입이다.</li>
<li>객체의 주소를 저장한다.</li>
</ul>
</li>
</ul>
<ul>
<li>덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합합니다.</li>
<li><strong>참조변수의 출력이나 덧셈 연산자를 이용한 참조변수와 문자열의 결합에는 toString()이 자동적으로 호출되어 참조변수를 문자열로 대치한 후 처리합니다.</strong></li>
</ul>
<h2 id="변수의-선언과-초기화">변수의 선언과 초기화</h2>
<ul>
<li>변수 선언만 한다.
<ul>
<li>변수를 선언하여 메모리 공간을 할당 받는다.</li>
<li>초기화하지 않았으므로 쓰레기 값이 들어간다.</li>
<li>반드시 초기화 이후에 사용해야 한다. 그렇지 않으면 컴파일 오류 발생.</li>
</ul>
</li>
<li>변수 선언과 초기화를 동시에 한다.
<ul>
<li>선언과 동시에 초기화한다.</li>
<li>타입이 같으면 동시에 선언 및 초기화 가능.</li>
</ul>
</li>
</ul>
<h1 id="상수constant"># 상수(constant)</h1>
<ul>
<li>변수와 마찬가지로 데이터를 저장할 수 있는 메모리 공간.</li>
<li>변수와 다르게 저장된 데이터를 <strong>변경할 수 없다.</strong></li>
<li>선언과 동시에 초기화해야 한다.</li>
<li><code>final</code> 키워드를 사용하여 선언한다.</li>
<li>통상적으로 상수는 <strong>대문자</strong>를 사용해 선언한다. 길 경우 언더스코어 사용.</li>
</ul>
<p><strong>리터럴(literal)</strong></p>
<p>상수의 다른 이름이다.<br>
값 그 자체를 의미한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">30</span>; <span class="comment">// 30이 리터럴</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> AGES = <span class="number">100</span>; <span class="comment">// 100이 리터럴</span></span><br></pre></td></tr></table></figure>
<p><strong>리터럴 타입 접미사(literal type suffix)</strong></p>
<p>자바에서 3.14와 같은 실수형 리터럴을 그대로 사용하면, 해당 리터럴은 실수형 타입 중에서도 double로 인식할 것이다.<br>
하지만, 실수형 리터럴 맨 뒤에 F나 f를 추가하면, 자바는 해당 실수형 리터럴을 float형으로 인식할 것이다.</p>
<p>이처럼 리터럴 뒤에 추가되어 해당 리터럴의 타입을 명시해주는 접미사를 <strong>리터럴 타입 접미사</strong>(lister type suffix)라고 한다.</p>
<img src="/img/literal.png" width="800" height="300">
<center>자바에서 사용할 수 있는 리터럴 타입 접미사</center>
<h1 id="기본형-데이터-타입의-범위"># 기본형 데이터 타입의 범위</h1>
<img src="/img/primitive_type_range.png" width="800" height="300">
<ul>
<li>타입은 데이터가 메모리에 어떻게 저장되는지, 처리되는지 명시적으로 알려준다.</li>
</ul>
<p><strong>boolean</strong></p>
<ul>
<li>저장 가능한 범위 true / false</li>
<li>Java에서 데이터를 다루는 최소 범위가 1 Byte이기 때문에 낭비적이긴 하지만 1 Byte 사용.</li>
</ul>
<p><strong>char</strong></p>
<ul>
<li>Unicode를 사용. 동양 글자의 경우 2Byte가 필요하기 때문에 char의 경우 2Byte 사용.</li>
<li>유일하게 제공되는 Unsinged 형태(음수가 존재하지 않는다.)</li>
<li>맨 앞 1bit로 음수나 양수를 나타내지만 char형은 unsinged 형식이기 때문에 맨 앞 비트를 음수, 양수 형식으로 사용하지 않는다.</li>
<li>char 형은 유니코드 정수 형태로 저장한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a = &apos;A&apos;</span><br><span class="line">a 변수에는 &apos;A&apos;의 정수 값인 65가 들어간다.</span><br></pre></td></tr></table></figure>
<p>JVM의 피연산자 스택이 피연산자를 4 Byte 단위로 저장하기 때문에 int 형보다 작은 자료형의 값을 계산할 때 int 형으로 형 변환하고 연산이 수행된다.</p>
<p>정수형 데이터를 사용하게 되면 JVM에서 기본적으로 int 형 데이터 타입의 데이터로 인식을 한다.</p>
<ul>
<li>int형 데이터 타입의 범위를 넘는 long 타입의 정수를 사용하고자 하는 경우에는 정수 데이터 맨 뒤쪽에 접미사 ‘l<br>
’ 또는 'L’을 붙여줘야 한다.</li>
</ul>
<img src="/img/data_type.png" width="600" height="300">
<center><b>정수형 데이터 타입</b></center>
<p><strong>오버플로우와 언더플로우</strong></p>
<p>데이터를 저장할 때는 데이터의 크기를 고려해서 적절한 데이터 타입을 사용해야 한다. 그렇지 않으면 데이터 손실이 생긴다.</p>
<ul>
<li>오버 플로우 : 해당 타입이 표현할 수 있는 최대 범위를 벗어난 데이터를 저장할 경우 발생한다. 다른 값이 저장될 수 있다.</li>
<li>언더 플로우 : 해당 타입이 표현할 수 있는 최소 범위보다 작은 수를 저장할 때 발생한다.</li>
</ul>
<h1 id="실수"># 실수</h1>
<p>실수란 <strong>소수부</strong>와 <strong>지수부</strong>가 있는 수를 가리키며, 정수보다 훨씬 더 넓은 표현 범위를 가진다. double 형이 기본 데이터 타입이다.</p>
<ol>
<li><strong>float</strong></li>
<li><strong>double</strong></li>
</ol>
<img src="/img/float_double1.png" width="600" height="300">
<img src="/img/float_double2.png" width="600" height="300">
<p>컴퓨터에서 실수를 표현하는 방식은 오차가 발생할 수 밖에 없는 태생적 한계를 지닌다. 이러한 실수형 데이터의 오차는 자바뿐만 아니라 모든 프로그래밍 언어에서 발생하는 공통된 문제입니다.</p>
<h1 id="실수의-표현"># 실수의 표현</h1>
<p>컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡합니다. 왜냐하면, 컴퓨터에서는 실수를 정수와 마찬가지로 2진수로만 표현해야 하기 때문이다.<br>
두 가지의 방법이 사용되고 있다.</p>
<h2 id="고정-소수점-방식fixed-point">고정 소수점 방식(fixed point)</h2>
<p>실수는 보통 <strong>정수부</strong>와 <strong>소수부</strong>로 나눌 수 있다. 따라서 실수를 표현하는 가장 간단한 방식은 소수부의 자릿수를 미리 고정하여 고정된 자릿수의 소수를 표현하는 것이다.</p>
<img src="/img/fixed_point.png" width="600" height="300">
<p>위 그림은 32비트 실수를 고정 소수점 방식으로 표현한 것이다. 하지만, 이 방식은 정수부와 소수부의 자릿수가 크지 않으므로 표현할 수 있는 범위가 매우 적다는 단점이 있다.</p>
<h2 id="부동-소수점-방식floating-point">부동 소수점 방식(floating point)</h2>
<p>실수는 보통 정수부와 소수부로 나누지만, <strong>가수부</strong>와 <strong>지수부</strong>로 나누어 표현할 수도 있다. 부동 소수점 방식은 이렇게 하나의 실수를 가수부와 지수부로 나누어 표현하는 방식이다.</p>
<p>앞서 살펴본 고정 소수점 방식은 제한된 자릿수로 인해 표현할 수 있는 범위가 매우 작다. 하지만, 부동 소수점 방식은 다음의 수식을 이용하여 매우 큰 실수까지도 표현할 수 있게 되었다.</p>
<img src="/img/operation.png" width="600" height="300">
<p>현재 대부분의 시스템에서는 부동 소수점 방식으로 실수를 표현하고 있다.</p>
<h2 id="ieee-부동-소수점-방식">IEEE 부동 소수점 방식</h2>
<p>현재 사용되고 있는 부동 소수점 방식은 대부분 <strong>IEEE 754</strong> 표준을 따르고 있다.</p>
<p>32비트(4바이트)의 float형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다.</p>
<img src="/img/floating.png" width="600" height="300">
<p>64비트의 double형 실수를 IEEE 부동 소수점 방식으로 표현하면 다음과 같다.</p>
<img src="/img/floating2.png" width="600" height="300">
<p>지수 필드의 비트 수가 늘어나면 표현 가능한 수의 범위가 확장되고, 가수 필드의 비트 수가 늘어나면 정밀도가 증가한다.</p>
<h2 id="부동-소수점-방식의-오차">부동 소수점 방식의 오차</h2>
<p>부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있다. 하지만, <code>부동 소수점 방식</code>에 의한 실수의 표현은 <strong>항상 오차가 존재</strong>한다는 단점을 가지고 있다.</p>
<p>부동 소수점 방식에서의 오차는 앞에서 본 공식에 의해 발생한다. 이 공식을 사용하면 표현할 수 있는 범위는 늘어나지만, 10진수를 정확하게 표현할 수는 없게 된다. 따라서 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임을 항상 명심해야 한다.</p>
<h2 id="타입-변환">타입 변환</h2>
<ul>
<li>하나의 타입을 다른 타입으로 바꾸는 것이다.</li>
<li>boolean형을 제외한 나머지 기본 타입 간의 타입 변환을 자유롭게 수행할 수 있다.</li>
</ul>
<p>다른 타입끼리의 연산은 우선 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 메모리에 할당받은 바이트의 크기가 상대적으로 작은 타입 -&gt; 큰 타입으로의 변환은 생략할 수 있다.</p>
<p>하지만, 메모리에 할당받은 바이트의 크기가 큰 타입 -&gt; 작은 타입으로의 타입 변환은 데이터의 손실이 발생한다. 따라서 상대적으로 바이트의 크기가 작은 타입으로 타입 변환을 할 경우 자바 컴파일러는 오류를 발생시킨다.</p>
<h3 id="묵시적-타입-변환자동-타입-변환">묵시적 타입 변환(자동 타입 변환)</h3>
<p>대입 연산이나 산술 연산에서 컴파일러가 자동으로 수행해주는 타입 변환을 가리킨다. <strong>자바에서는 데이터의 손실이 발생하지 않거나, 데이터의 손실이 최소화되는 방향으로 묵시적 타입 변환을 진행합니다.</strong><br>
또한, 자바에서는 데이터의 손실이 발생하는 대입 연산은 허용하지 않습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> num1 = <span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">3.14</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">double</span> num3 = <span class="number">7.0f</span> + <span class="number">3.14</span>; <span class="comment">//3</span></span><br><span class="line">System.out.println(num1);</span><br><span class="line">System.out.println(num3);</span><br></pre></td></tr></table></figure>
<p>1번<br>
double형 변수에 int형 데이터를 대입한다.<br>
int형 데이터 -&gt; double형 데이터 : 자동 형 변환된다.</p>
<p>2번<br>
int형 변수가 표현할 수 있는 범위보다 더 큰 double형 데이터를 대입하므로 데이터의 손실이 발생한다.<br>
이 대입 연산의 경우 컴파일러가 오류를 발생시킨다.</p>
<p>3번<br>
데이터의 손실이 최소화되도록 float형 데이터 -&gt; double형 데이터로 자동 형 변환시킨다.</p>
<p><strong>자바 컴파일러가 자동으로 수행하는 타입 변환은 데이터의 손실이 최소화되는 방향으로 이루어진다.</strong> 따라서 자바에서는 타입의 표현 범위에 따라 다음과 같은 방향으로 자동 타입 변환이 이루어집니다.</p>
<img src="/img/java_type_conversion.jpg" width="600" height="300">
<h3 id="명시적-타입-변환강제-타입-변환">명시적 타입 변환(강제 타입 변환)</h3>
<p>사용자가 타입 캐스트 연산자 (())를 사용하여 강제적으로 수행하는 타입 변환을 말한다.</p>
<p>다음과 같은 방법으로 명시적 타입 변환을 수행할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(변환할 타입) 변환할 데이터</span><br></pre></td></tr></table></figure>
<p>변환시키고자 하는 데이터의 앞에 괄호 (())를 넣고, 그 괄호 안에 변환할 타입을 적으면 된다.이 괄호를 <code>타입 캐스트(type cast)</code> 연산자라고 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>, num2 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result1 = num1 / num2;</span><br><span class="line"><span class="keyword">double</span> resutl2 = (<span class="keyword">double</span>) num1 / num2; <span class="comment">// 강제 타입 변환</span></span><br><span class="line"></span><br><span class="line">System.out.println(result1);</span><br><span class="line">System.out.println(resutl2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.25</span></span><br></pre></td></tr></table></figure>
<p>result1은 나눗셈의 결과로는 0이 반환된다. 자바에서 산술 연산을 수행하고 얻는 결과값의 타입은 언제나 피연산자의 타입과 일치해야 합니다. 즉, int형 데이터끼리 산술 연산에 대한 결과값은 언제나 int형 데이터의 결과가 나오게 된다.</p>
<p>따라서 <code>1/4</code>의 결과로는 0.25가 반환되지만, int형으로 자동 타입 변환되어 0이 반환되게 된다. 그리고서 double형 변수에 그 결과가 대입될 때, double형으로 자동 타입 변환되어 0.0이라는 결과가 출력된다. 데이터가 손실되었다.</p>
<p>정확한 결과를 얻고자 한다면 result2처럼 피연산자 중 하나의 타입을 double형으로 강제 타입 변환을 해야 한다. 이렇게 피연산자 중 하나의 타입이 double형이 되면, 나눗셈 연산을 위해 나머지 하나의 피연산자도 double형으로 자동 타입 변환된다. 따라서 그 결과 또한 double형인 0.25가 될 것이며, 이 결과가 double형 변수에 제대로 대입될 것이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/01/java-basic-1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2018/08/archives/2/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 3 of 3</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
