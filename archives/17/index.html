
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/17/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/"
                            aria-label=": [네트워크] HTTP"
                        >
                            [네트워크] HTTP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T12:02:38+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="http란">HTTP란?</h2>
<p>HTTP(HyperText Transfer Protocol)의 약자로 하이퍼 텍스트 문서를 교환하기 위하여 사용된 통신 규약이다. 즉, Web Server와 Web Clinet 간의 통신을 하기 위한 통신 규약이다.</p>
<p><strong>HTTP</strong>는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 월드 와이드 웹(WWW) 기반에서 전 세계적인 정보 공유를 이루는데 큰 역할을 하였다.</p>
<p>HTTP는 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 요청(request)과 응답(response)을 전송한다.</p>
<h2 id="http-특징">HTTP 특징</h2>
<ul>
<li>HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석된다.</li>
<li>TCP/IP를 이용하는 응용 프로토콜이다.</li>
<li><strong>HTTP는 연결 상태를 유지하지 않는 비연결성 프로토콜이다.</strong>[이러한 단점을 해결하기 위해 쿠키와 세션이 등장.]</li>
<li>HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 요청(request)와 응답(response) 방식으로 동작한다.</li>
</ul>
<p><strong>동작</strong></p>
<img src="/img/http.png" width="500" height="200">
<p>사용자(Client)가 브라우저를 통해서 어떠한 서비스를 url을 통해서 혹은 다른 방법으로 <strong>요청</strong>(request)을 하면 서버에서는 해당 요청 사항에 맞는 결과를 찾아서 사용자에게 <strong>응답</strong>(response)하는 형태로 동작한다.</p>
<ul>
<li>요청 : client -&gt; server</li>
<li>응답 : server -&gt; client</li>
</ul>
<p>HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다. Plain text로부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며 보통은 client가 어떤 정보를 어떻게 받고 싶은지 명시해주는 경우가 많다.<br>
(HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지)</p>
<h2 id="http의-get과-post-비교">HTTP의 GET과 POST 비교</h2>
<p>GET과 POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 <strong>요청</strong>할 때 사용하는 방식이다. PUT과 DELETE도 있지만 지금은 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도로 사용할 수 있도록 하자.</p>
<p><code>1. GET</code></p>
<p>GET 방식은 요청하는 <strong>데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송된다.</strong> “url?(데이터)” 처럼 request를 보내는 것이다.</p>
<p>이러한 방식은 url이라는 공간에 데이터가 담겨가기 때문에 전송할 수 있는 <strong>데이터의 크기가 제한적이다.</strong> 또한, 보안이 필요한 데이터에 대해서는 데이터가 그대로 노출되므로 GET 방식은 적절하지 않다.<br>
ex) password</p>
<p><code>2. POST</code></p>
<p>POST 방식은 <strong>HTTP Message의 Body 부분에 데이터가 담겨서 전송된다.</strong> 따라서 GET 방식에 비해서 더 큰 데이터를 보낼 수 있어 큰 데이터를 요청하는 경우에 사용할 수 있다. 보안적인 측면에서는 암호화를 하지 않은 이상 차이가 없다.</p>
<p>GET은 가져오는 의미를 가지고 있다. 서버에서 어떤 데이터를 가져와서 보여주는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. <strong>SELECT</strong> 적인 성향을 갖고 있다.<br>
반면에 POST는 서버의 값이나 상태를 <strong>변경</strong>하기 위해서 또는 <strong>추가</strong>하기 위해서 사용된다.</p>
<p>GET 방식의 요청은 브라우저에서 <code>Caching</code>할 수 있다. 따라서 POST 방식보다 빠르게 응답할 수 있다. POST 방식으로 요청해야 할 데이터의 크기 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청을 한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-HTTP-Method-Diff-Of-GET-POST/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/DataStructure-Graph/"
                            aria-label=": [자료구조] Graph"
                        >
                            [자료구조] Graph
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T11:07:43+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><a href="#%EC%A0%95%EC%A0%90%EA%B3%BC-%EA%B0%84%EC%84%A0%EC%9D%98-%EC%A7%91%ED%95%A8,-Graph">정점과 간선의 집함, Graph</a><br>
<a href="#%EA%B7%B8%EB%9E%98%ED%94%84-%EA%B4%80%EB%A0%A8-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC">그래프 관련 용어 정리</a></p>
<h2 id="정점과-간선의-집함-graph">정점과 간선의 집함, Graph</h2>
<p>그래프란 정점과 간선의 집합을 말한다.<br>
ex) 트리는 그래프. [싸이클이 허용되지 않는 그래프이다.]</p>
<h2 id="그래프-관련-용어-정리">그래프 관련 용어 정리</h2>
<ul>
<li>V(vertex) : 정점을 의미한다.</li>
<li>E(edge) : 간선을 의미한다.</li>
</ul>
<ol>
<li>Directed Graph(Digraph)<br>
말 그대로 정점과 간선의 연결관계에 있어서 <code>방향성</code>이 포함되어 있는 그래프를 말한다.</li>
</ol>
<img src="/img/digraph.png" width="400" height="200">
<center>V = {1,2,3,4,5,6}</center>
<center>E = {(1,4),(2,1),(3,4),(5,6)}</center>
<center>(u,v) = vertex u에서 vertex v로 가는 edge</center>
<ol start="2">
<li>Undirected Graph<br>
정점과 간선의 연결관계에 있어서 <code>방향성</code>이 없는 그래프를 말한다.</li>
</ol>
<img src="/img/undirected_graph.png" width="400" height="200">
<ol start="3">
<li>Degree<br>
Undirected Graph에서 각 정점(Vertex)에 연결된 Edge의 개수를 <strong>Degree</strong>라고 한다.<br>
Directed Graph에서는 간선에 <code>방향성</code>이 존재하기 때문에 Degree가 두 개로 나뉘게 된다.<br>
각 정점으로부터 나가는 간선의 개수를 <strong>Outdegree</strong>라고 하고, 들어오는 간선의 개수를 <strong>Indegree</strong>라고 한다.</li>
</ol>
<ol start="4">
<li>가중치 그래프(Weight Graph)<br>
가중치 그래프란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 비가중치 그래프는 모든 간선의 가중치가 동일한 그래프이다.</li>
</ol>
<ol start="5">
<li>부분 그래프(Sub Graph)<br>
부분 집합과 유사한 개념으로 부분 그래프라는 것이 존재한다.<br>
부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</li>
</ol>
<h2 id="그래프를-구현하는-두-방법">그래프를 구현하는 두 방법</h2>
<p>[무슨 말일까…?ㅠ^ㅠ]</p>
<ol>
<li>
<p>인접 행렬(adjacent matrix)<br>
정방 행렬을 사용하는 방법이다.<br>
해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)으로 파악할 수 있다.<br>
Edge 개수와는 무관하게 V^2의 Space Complexity(공간 복잡도)를 갖는다.<br>
=&gt; Dense graph를 표현할 때 적절한 방법이다.</p>
</li>
<li>
<p>인접 리스트(adjacent list)<br>
연결 리스트를 사용하는 방법이다.<br>
vertex의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다.<br>
Space Complexity는 O(E + V)이다.<br>
=&gt; Sparse graph를 표현하는데 적당한 방법이다.</p>
</li>
</ol>
<p>[어려운 용어가 많이 나온다… 더 공부하자!!]</p>
<h2 id="그래프-탐색">그래프 탐색</h2>
<p>그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<p><strong>1. 깊이 우선 탐색(Depth First Search: DFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 한 정점으로만 나아간다라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결된 정점이 없으면 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다.<br>
어떤 자료구조를 사용해야 할까? 바로 <code>Stack</code>이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><strong>2. 너비 우선 탐색(Breadth First Search: BFS)</strong><br>
그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 모든 정점으로 나아간다. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서 자료구조로 <code>Queue</code>를 사용한다. 연락을 취한 정점의 순서를 기록하기 위한 것이다.<br>
우선, 탐색을 시작하는 정점을 Queue에 넣는다.(enqueue)<br>
그리고 dequeue를 하면서 dequeue를 하는 정점과 간선으로 연결된 정점들을 enqueue한다.<br>
즉, vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다.<br>
Time Complexity : O(V + E) =&gt; vertex개수+edge개수</p>
<p><code>BFS로 구한 경로는 최단 경로이다.</code></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/342?category=688193" target="_blank" rel="noopener">Graph라는 자료구조에 대해서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/DataStructure-Graph/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-HashTable/"
                            aria-label=": [자료구조] Hash"
                        >
                            [자료구조] Hash
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T23:17:04+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="hasttable">HastTable</h2>
<p><code>Hash(또는 HashMap)</code>은 내부적으로 배열을 사용하여 데이터를 저장하기 때문에 인덱스를 이용한 빠른 검색 속도를 갖는다. 특정한 값을 searching하는데 데이터 고유의 <strong>인덱스</strong>로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다.<br>
[항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.]</p>
<p>그리고 데이터의 삽입과 삭제 시 기존 데이터를 밀어내거나 다시 채우는 작업이 필요없도록 <strong>특별한 알고리즘</strong>을 이용하여 데이터와 연관된 고유한 숫자를 만들어 낸 뒤 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에 삽입 시 다른 데이터의 사이에 끼어들거나 삭제 시 다른 데이터로 채울 필요가 없으므로 추가적인 데이터의 이동이 없다.</p>
<p><strong>'특별한 알고리즘’이라는 것을 통해서 고유한 인덱스 값을 설정하는 것이 중요한 포인트이다.</strong><br>
앞서 언급한 특별한 알고리즘을 해시 메소드 또는 해시 함수라고 하고 이 메소드에 의해 반환되는 데이터의 <strong>고유한 숫자 값</strong>을 <strong>hashCode</strong>라고 한다.<br>
Java에서는 Object 클래스의 _hashCode()_라는 메소드를 이용하여 모든 객체의 hashcode 값을 쉽게 구할 수 있다.</p>
<p>hash 메소드를 구현하는 가장 간단한 방법은 <strong>나머지 연산자를 이용</strong>하는 것이다. <em>저장할 데이터의 값을 저장할 hash table의 크기로 나누고 나머지 연산 결과를 데이터의 인덱스로 사용하는 것이다.</em> 하지만 이렇게 하면 문제점이 발생한다.</p>
<p>만약 3의 배수로 이루어진 데이터 9개를 저장한다고 가정해보자.<br>
저장하려는 데이터 : 3,6,9,12,15,18,21,24,27<br>
hashcode 값 계산<br>
3 % 9 == 3<br>
6 % 9 == 6<br>
9 % 9 == 0<br>
12 % 9 == 3<br>
15 % 9 == 6<br>
18 % 9 == 0<br>
21 % 9 == 3<br>
24 % 9 == 6<br>
27 % 9 == 3</p>
<p>계산 결과 hashcode 값이 0,3,6으로 집중되고 있다. <em>이렇게 되면 같은 index로 접근하게 되는 value가 많아져 데이터를 저장할 수 없게 되는 충돌 현상이 발생한다.</em> 이를 <strong>Collision</strong>이라고 한다.</p>
<p>이런 충돌을 최소화 하기 위한 가장 간단한 방법은 나머지 연산의 값이 중복되지 않도록 테이블의 크기를 <code>소수(Prime number)</code>로 만드는 것이다. 위와 동일한 입장일 경우, 저장하려는 데이터의 크기가 9이므로 9보다 큰 소수인 11로 나머지 연산을 해보자.</p>
<p>hashcode 값 계산<br>
3 % 11 == 3<br>
6 % 11 == 6<br>
9 % 11 == 9<br>
12 % 11 == 1<br>
15 % 11 == 4<br>
18 % 11 == 7<br>
21 % 11 == 10<br>
24 % 11 == 2<br>
27 % 11 == 5</p>
<p>중복되는 값이 깨끗하게 사라진 것을 확인할 수 있다. 하지만 이 방법으로 모든 것이 해결된 것일까?? 위의 과정에서 데이터의 성질이 달라져 다른 값이 들어올 수 있게 된 경우는 어떨까?</p>
<p>예를 들어 26이라는 데이터를 추가적으로 저장해야 한다면 데이터의 크기는 10이 되고 10보다 큰 소수는 11로 나머지 연산자 방법을 수행해준다.</p>
<p>26 % 11 == 4</p>
<p>결과를 확인해보니 다시 중복이 발생하였다. 바로 <code>Collision</code>이 발생한 것이다. <em>Hash Table의 크기를 소수로 만드는 것은 충돌을 줄일 수는 있지만 원천적으로 해결해주지는 못한다.</em></p>
<p>충돌이 많아질수록 Searching에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다.<br>
<em>어설픈 해쉬 함수는 해시를 해시답게 사용하지 못하도록 한다. 좋은 해쉬 함수를 선택하는 것은 해쉬 테이블의 성능 향상에 필수적인 것이다.</em></p>
<p>두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.(Collision)<br>
따라서 해싱된 인덱스에 이미 다른 값이 들어가 있다면 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수적이며 그 방법들에 대해 알아보고자 한다.</p>
<p>기본적인 두 가지 방법을 알아보자. 해시 충돌을 해결하기 위한 다양한 자료가 있지만, 다음 두 가지 방법을 응용한 방법들이다.</p>
<h2 id="open-address-방식개방-주소법">Open Address 방식(개방 주소법)</h2>
<p>해시 충돌이 발생하면 즉 삽입하려는 해시 버킷이 이미 사용 중인 경우, <code>다른</code> 해시 버킷에 해당 자료를 삽입하는 방식이다.</p>
<ul>
<li>버킷(bucket)이란 바구니와 같은 개념으로 데이터를 저장하기 위한 공간이라고 생각하면 된다.</li>
</ul>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 Collision(충돌)이 발생하면 데이터를 저장할 장소. 즉 다른 해시 버킷을 찾아 헤맨다. 이 과정에서도 여러 방법들이 존재하는데 다음 3가지에 대해 간단하게 알아보자.</p>
<ol>
<li>
<p>Linear Probing<br>
순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다. Worst case의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다.</p>
</li>
<li>
<p>Quadratic probing<br>
2차 함수를 이용해 탐색할 위치를 찾는다.</p>
</li>
<li>
<p>Double hashing probing</p>
</li>
</ol>
<p>하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두가지 방법에 비해 많은 연산량을 요구한다.</p>
<h2 id="seperate-chaining-방식분리-연결법">Seperate Chaining 방식(분리 연결법)</h2>
<p>참고로 Java 7에서는 Seperate Chaining 방식을 사용하여 HashMap을 구현하고 있다.</p>
<blockquote>
<p>Why?</p>
</blockquote>
<p>HashMap의 특성상 remove() 메소드가 빈번하게 일어날 수 있는데 데이터를 삭제할 때 OpenAddress 방식은 처리가 효율적이기 어렵다. 또한 저장된 Key-value 쌍의 개수가 일정 개수 이상 많아지면 보통 Seperate Chaining 방식에 비해 Open Address 방식이 느리다.</p>
<p><strong>연결 리스트를 사용하는 방식(LinkedList)</strong></p>
<p>각각의 버킷들을 연결리스트(Linked List)로 만들어 Collision이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 오버헤드가 부담이 된다.</p>
<p>일반적으로 Open Address 방법은 Seperate Chaining 방식보다 느리다. Open Address의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면에 Seperate Chaining 방식의 경우 해시 충돌이 잘 발생하지 않도록 <strong>보조 해시 함수</strong>를 통해 조정할 수 있다면 Worst Case에 가까워지는 것을 줄일 수 있다.</p>
<p><a href="https://d2.naver.com/helloworld/831311" target="_blank" rel="noopener">보조 해시 함수에 대한 글</a></p>
<p><strong>Tree를 사용하는 방식(Red-Black-Tree)</strong></p>
<p>기본적인 알고리즘은 Seperate Chaining 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 여기서 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 <strong>하나의 버킷에 할당된 Key-Value 쌍의 개수</strong>이다.</p>
<p>트리는 기본적으로 메모리 사용량이 많고 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 연결 리스트의 성능 상의 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 연결 리스트를 사용한다.</p>
<blockquote>
<p>데이터가 적다는 것은 얼마나 적다는 것을 의미할까??</p>
</blockquote>
<p>앞에서 언급한 것처럼 기준은 하나의 버킷에 할당되는 Key-Value 쌍의 개수이다. 이 Key-Value 쌍의 개수가 6개, 8개를 기준으로 결정한다.</p>
<p>오잉…? 왜 기준이 2개인가?? 이는 아래에서 설명하겠다.</p>
<p>결론부터 말하자면 연결 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 <strong>소요되는 비용을 줄이기 위함</strong>이다.<br>
한 가지 상황을 가정해보자.<br>
해시 버킷에 6개의 Key-Value 쌍이 들어있다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료 구조를 연결 리스트에서 트리로 변경해야 한다. 그러다가 바로 하나의 값이 삭제된다면 다시 트리에서 연결 리스트로 자료구조를 변경해야 한다.</p>
<p>각각 자료구조로 넘어가는 기준이 1이라면 Switching 할 때 생기는 비용이 너무 많이 필요하게 되는 것이다. <strong>그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다.</strong><br>
따라서 데이터의 개수가 6개 -&gt; 7개로 증가했을 때는 연결 리스트의 자료구조를 취하고 있을 것이고<br>
8개 -&gt; 7개로 감소했을 때는 트리의 자료 구조를 취하고 있을 것이다.</p>
<ul>
<li>참고로 Java 8을 구현하는데 사용하는 트리는 RBT이다.</li>
</ul>
<p><strong>해시 버킷 동적 확장(Resize)</strong></p>
<p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능상 손실이 발생할 수도 있다. 그래서 HashMap은 Key-Value 쌍 데이터 개수가 <strong>일정 개수 이상</strong>이 되면 해시 버킷의 개수를 두배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.</p>
<blockquote>
<p>일정 개수 이상??</p>
</blockquote>
<p>해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor로 HashMap의 생성자에서 지정할 수도 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://asfirstalways.tistory.com/332?category=688193" target="_blank" rel="noopener">hashcode와 HashMap에 대해서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-HashTable/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-RBT/"
                            aria-label=": [자료구조] Red-Black Tree"
                        >
                            [자료구조] Red-Black Tree
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T22:01:28+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식의 자료구조이다.</p>
<p>먼저 레드 블랙 트리를 알아보기 전에 BST가 무엇인지 한번 더 알고 넘어가자.</p>
<p>BST(Binary Search Tree)는 이진 탐색 트리이다.<br>
효율적인 탐색을 위해 어떻게 찾을까만 고민해서는 안된다. 그보다는 효율적인 탐색을 위한 <strong>저장 방법이 무엇일까</strong>를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>
<h2 id="red-black-tree">Red Black Tree</h2>
<p>결론부터 말하자면 <code>Red-Black-Tree</code>에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, depth를 최소화하여 시간 복잡도를 줄이는 것이 핵심 아이디어이다. 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 tree가 Complete Binary Tree인 경우이다.</p>
<p></p><h5 id="1-red-black-tree의-정의">1. Red-Black-Tree의 정의</h5><p></p>
<p>Red-Black-Tree를 앞으로 RBT라고 부르도록 하겠다.<br>
RBT는 다음의 성질을 만족하는 BST이다.</p>
<ul>
<li>각 노드는 <code>Red</code> 혹은 <code>Black</code>라는 색깔을 갖는다.</li>
<li>Root node의 색깔을 Black이다.</li>
<li>각 leaf node(단말 노드)는 black이다.</li>
<li>어떤 노드의 색깔이 red라면 두 개의 children의 색깔은 모두 black이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black node들을 포함하고 있다. 이를 해당 노드의 <code>Black-Height</code>라고 한다. [노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수]</li>
</ul>
<p>[무슨 말일까…? 어렵다!]</p>
<p><strong>2. RBT의 특징</strong></p>
<ul>
<li>Binary Search Tree이므로 BST의 특징을 모두 갖는다.</li>
<li>Root node부터 leaf node까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 <strong>balanced</strong> 상태라고 한다.</li>
<li>노드의 child가 없을 경우, child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL은 leaf node로 간주한다.</li>
</ul>
<p>RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어진 자료구조이다. 그렇다면 이를 어떻게 해결할 것인가??</p>
<h3 id="삽입">삽입</h3>
<p>우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 <code>Red</code>로 지정한다. Red로 지정하는 이유는 Black-Height의 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고 Black-Height가 위배되었다면 rotation을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node 들의 Black-Height가 같아지게 되고 최소 경로와 최대 경로의 크기 비율이 2미만으로 유지된다.</p>
<h3 id="삭제">삭제</h3>
<p>삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-Height가 1 감소한 경로에 black node가 1개 추가되도록 rotation을 하고 노드의 색깔을 조정한다. &lt;지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-RBT/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Heap/"
                            aria-label=": [자료구조] Heap"
                        >
                            [자료구조] Heap
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T21:45:11+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#Heap">Heap</a></li>
</ul>
<h2 id="heap">Heap</h2>
<p>Heap 자료구조는 일종의 Tree의 형식을 하고 있으며, Tree 중에서도 <strong>배열</strong>에 기반한 Complete Binary Tree(완전 이진 트리)이다.</p>
<p>배열에 트리의 값을 넣어줄 때, 0번째는 건너뛰고 1부터 루트노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다.</p>
<p>힙에는 최소 힙(min heap)과 최대 힙(max heap) 두 종류가 있다.</p>
<p><code>Max Heap</code>이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 Complete Binary Tree(완전 이진 트리)를 말한다.[Min Heap은 그 반대.]</p>
<p>Max Heap에서는 Root node에 있는 값이 제일 크므로 최대값을 찾는데 소요되는 연산의 시간 복잡도는 O(1)이다. 그리고 Complete Binary Tree이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다.<br>
(즉, 배열의 장점 중 하나인 Random Access가 가능하다)<br>
Min Heap에서는 최소값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다.</p>
<p>Heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 Heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 <code>Heapify</code> 과정을 거쳐 Heap 구조를 유지한다. 이런 경우 결국에는 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있다.</p>
<p>[Heap 구조를 유지시키는 더 자세한 내용을 추가 예정.]</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Heap/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Tree/"
                            aria-label=": [자료구조] Tree 개념"
                        >
                            [자료구조] Tree 개념
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T16:59:05+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="tree">Tree</h2>
<p>트리는 스택이나 큐와 같은 선형 구조가 아닌 <strong>비선형 자료구조</strong>이다.<br>
트리는 계층적 관계를 표현하는 자료구조이며, 표현에 집중한다.<br>
무엇인가를 저장하고 꺼내야 한다는 사고를 벗어나 트리라는 자료구조를 보자.</p>
<p><strong>트리를 구성하고 있는 구성요소들</strong></p>
<ul>
<li>Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미</li>
<li>Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미</li>
<li>Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미</li>
<li>Terminal Node(=leaf Noed, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미</li>
<li>Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.</li>
</ul>
<p>트리의 속성 중 가장 중요한 것은 <strong>루트 노드를 제외한 모든 노드는 단 하나의 부모 노드만을 가진다</strong>는 것이다. 이 속성 때문에 트리는 다음의 성질을 만족한다.</p>
<ul>
<li>임의의 노드에서 다른 노드로 가는 경로(path)는 유일하다.</li>
<li>회로(cycle)가 존재하지 않는다.</li>
<li>모든 노드는 서로 연결되어 있다.</li>
<li>엣지를 하나 자르면 트리가 두 개로 분리된다.</li>
<li>엣지의 수(E) = 노드의 수(V) - 1</li>
</ul>
<h3 id="binary-tree이진-트리">Binary Tree(이진 트리)</h3>
<p>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나누어진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다.</p>
<p><strong>즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다.</strong> 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf Node에 다 달았을 때 정의가 만족되기 때문이다.</p>
<p>트리에서는 각 <strong>층 별</strong>로 숫자를 매겨서 이를 트리의 Level이라고 한다. 루트 노드부터 시작하고 루트 노드의 Level은 1이다. 그리고 트리의 최고 Level을 가리켜 해당 트리의 <code>height(높이)</code>라고 한다.</p>
<ol>
<li>완전 이진 트리(Complete Binary Tree)</li>
</ol>
<p>위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 <strong>완전 이진 트리</strong>라고 한다.</p>
<img src="/img/complete_binary_tree.png" width="400" height="200">
<ol start="2">
<li>포화 이진 트리(Full Binary Tree)</li>
</ol>
<p>모든 레벨에서 노드들이 꽉 채워진 이진트리를 말한다.(= 잎새 노드를 제외한 모든 노드가 자식 노드를 2개 가진다.)</p>
<img src="/img/full_binary_tree.png" width="400" height="200">
<p>포화 이진 트리의 노드 수가 n개라면 잎새노드의 수는 n/2를 올림한 숫자가 된다. 그리고 노드의 개수는 2^(k+1) - 1이 된다.</p>
<ol start="3">
<li>편향 이진 트리(skewed binary tree)</li>
</ol>
<p>모든 노드가 부모의 왼쪽 자식이기 때문에 왼편으로 편향되어 있거나 반대로 모든 노드가 부모의 오른쪽 자식으로 되어 오른쪽으로 편향되어 있는 이진트리를 말한다.</p>
<img src="/img/skewed_binary_tree.png" width="400" height="200">
<p>이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면 탐색, 삽입, 삭제, 메모리 성능 등 모든 면에서 배열에 비해 좋은 것이 없다.</p>
<h2 id="bstbinary-search-tree">BST(Binary Search Tree)</h2>
<p>효율적인 탐색을 위한 저장 방법이 무엇일까를 고민해야 한다.<br>
이진 탐색 트리는 이진 트리의 일종이다.<br>
단, 이진 탐색 트리에는 <strong>데이터를 저장하는 규칙이 있다.</strong><br>
그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브트리를 구성하는 어떤 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브트리를 구성하는 어떤 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.</li>
</ul>
<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다.<br>
사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두배씩 증가하기 때문이다.<br>
이러한 이진 탐색 트리는 <strong>편항 트리</strong>가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생할 수 있기 때문이다.<br>
이럴 경우 성능에 영향을 미치게 되며, 탐색의 <code>Worst cost</code>가 발생하고 시간 복잡도는 O(n)이 된다.</p>
<p>배열보다 많은 메모리를 사용하여 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생했다.<br>
이를 해결하기 위해 <code>Rebalancing</code> 기법이 등장했다.</p>
<p>균형을 잡기 위한 트리 구조의 재조정을 Rebalancing이라고 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 그 중에서 하나는 추후에 살펴볼 Red-black-Tree 이다.</p>
<h2 id="이진-트리의-순회-방법">이진 트리의 순회 방법</h2>
<p>이진 트리의 순회 방법을 간단하게 정리하면 아래와 같다. 루트의 위치를 기준으로 이름을 기억하면 된다.</p>
<ol>
<li>전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리</li>
<li>중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리</li>
<li>후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Tree/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-Diff-of-Array-LinkedList/"
                            aria-label=": [자료구조] Array vs LinkedList"
                        >
                            [자료구조] Array vs LinkedList
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T15:44:23+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>2019.03.20 일자 기준으로 공부했던 내용을 수정하려고 한다. 이유는 이렇게 정리해놨지만 머리에 기억으로 남지 않기 때문이다.</p>
<p>먼저, Array VS LinkedList를 비교해보겠다.</p>
<h2 id="array배열">Array(배열)</h2>
<ul>
<li>논리적 저장순서와 물리적 저장 순서가 일치한다.</li>
<li><code>인덱스</code>로 해당 원소에 접근이 가능하다.</li>
<li>인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.</li>
<li>즉, Random Access가 가능하다.</li>
<li>배열의 원소를 삭제할 경우 삭제한 원소보다 큰 인덱스를 가진 원소들을 옮겨줘야(Shift) 하기 때문에 시간 복잡도 O(n)이 걸린다.</li>
<li>삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1씩 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.</li>
<li>제한적인 크기를 갖는다.</li>
</ul>
<p>즉, 삭제 또는 삽입 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생해 O(n)의 시간복잡도를 갖는다.</p>
<h2 id="linkedlist">LinkedList</h2>
<ul>
<li>자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.</li>
<li>삽입과 삭제의 경우 LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다고 하는게 맞다. (아래에서 설명하겠다.)</li>
<li>원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회하여야 하므로 O(n)의 시간 복잡도를 갖는다.</li>
<li>트리의 근간이 되는 자료구조이다.</li>
</ul>
<p>LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다. 추가적으로 데이터를 삽입 / 삭제하기 위한 시간 복잡도까지 계산하면 결국 O(n)의 시간 복잡도를 갖는 셈이다.</p>
<p>하지만 위에서 경우에 따라서 다르다고 하지 않았는가?<br>
<strong>삽입의 경우</strong><br>
일단, <strong>LinkedList</strong>는 어느 곳에 삽입하던지 O(n)의 시간복잡도를 갖는다. (만약, 중간 삽입이 없다면 즉 맨 앞과 맨 뒤에만 삽입한다면 -&gt; 시간 복잡도 : O(1))</p>
<p><strong>삭제의 경우</strong><br>
삭제의 경우도 삽입과 마찬가지이다. 어느 곳에 삽입하던지 O(n)의 시간 복잡도를 갖는다. (만약, 중간 삭제가 없고 맨 앞과 뒤에서만 삭제한다면 -&gt; 시간 복잡도 : O(1))</p>
<h2 id="array-vs-linkedlist">Array VS LinkedList</h2>
<p><strong># 데이터 접근 속도</strong></p>
<p><strong>Array</strong>는 인덱스를 사용해 빠르게 원소에 접근할 수 있다. 따라서 Random Access를 지원한다. <code>시간 복잡도 O(1)</code>로 빠르게 찾을 수 있다.</p>
<p><strong>LinkedList</strong>는 순차 접근 방식을 사용한다. 특정 원소에 접근하기 위해서는 처음부터 원소에 도달할 때까지 순차적으로 검색하면서 찾는다. <code>시간 복잡도 O(N)</code></p>
<p><strong># 데이터의 삽입 속도</strong></p>
<p>경우에 따라 다르다.<br>
만약 배열에 공간이 많이 남아있고 맨 끝에 삽입한다면 삽입 속도 역시 O(1)에 가능하다. 하지만 이런 경우는 발생하기 힘든 케이스이다.</p>
<p><strong>Array</strong>(배열)의 경우 데이터를 중간이나 맨 앞에 삽입할 경우 그 이후의 데이터를 한 칸씩 미뤄야 하는 추가 과정과 시간이 소요된다. 데이터가 많을 경우 비효율적이다. 그렇기 때문에 <strong>LinkedList</strong>가 필요하게 되었다.</p>
<p><strong>LinkedList</strong>는 어느 곳에 삽입하던지 O(N)의 시간 복잡도를 갖는다.(만약, 중간 삽입이 없다면 O(1)의 시간복잡도를 갖는다.) 이유는 삽입할 위치를 찾고(O(N)) 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다. 그럼에도 Array보다 빠른 성능을 보인다.</p>
<p>또한 <strong>Array</strong>의 경우 데이터 삽입 시 모든 공간이 다 차버렸다면 새로운 메모리 공간을 할당받지만 <strong>LinkedList</strong>는 그럴 필요가 없다. 추가할 때마다 동적으로 할당하는 것으로 알고 있다.</p>
<p><strong># 데이터의 삭제 속도</strong></p>
<p>이 부분도 경우에 따라 다르다.<br>
<strong>Array</strong>는 데이터 삭제의 경우 그 위치의 데이터를 삭제 후, 전체적으로 Shift 해줘야 한다. (O(N))</p>
<p><strong>LinkedList</strong>의 경우 삭제할 원소를 찾기 위해서 O(N)의 시간 복잡도를 갖고 삭제를 한다. 결구 O(N)의 시간 복잡도를 갖는다. 하지만 Array 보다 빠르게 삭제 연산을 수행한다.</p>
<p><strong># 메모리 할당</strong></p>
<ul>
<li>
<p><code>Array</code>에서 메모리는 Array가 선언되자 마자 Compile time에 할당되어 진다. 이것을 정적 메모리 할당이라고 한다.</p>
</li>
<li>
<p><strong>Stack</strong> 영역에 메모리 할당이 이루어진다.</p>
</li>
<li>
<p><code>LinkedList</code>에서 메모리는 새로운 node가 추가될 때 runtime에 할당되어 진다. 이것은 동적 메모리 할당이라고 한다.</p>
</li>
<li>
<p><strong>Heap</strong> 영역에 메모리 할당이 이루어진다.</p>
</li>
</ul>
<p><strong># size</strong></p>
<p>Array의 size는 반드시 선언 시점에 지정되어있어야 한다.</p>
<p>LinkedList의 size는 다양할 수 있다. node들이 추가될 때 runtime 시점에서 LinkedList의 size가 커질 수 있기 때문이다.</p>
<h2 id="결론">결론</h2>
<ul>
<li>삽입과 삭제가 빈번하다면 <strong>LinkedList</strong>를 사용하는 것이 더 좋다.</li>
<li>데이터의 접근하는 게 중요하다면 <strong>Array</strong>를 사용하는 것이 좋다.</li>
</ul>
<p>전반적인 내용을 보면 Array보다 LinkedList(포괄적인 범위에서 List라고 하겠다.)의 사용이 훨씬 좋아보인다. 하지만 일반적인 알고리즘 문제를 풀 때는 List보다 Array가 훨씬 빠르고 좋다. 왜냐하면 대부분의 알고리즘 문제는 메모리 공간의 범위를 파악할 수 있도록 N의 크기가 주어지기 때문이다.</p>
<p>그래서 배열의 크기를 MAX로 초반에 잡을 수 있다면 훨씬 더 편리하고 List와는 다른 속도를 보인다. 왜냐하면 위에서 본 것처럼 List의 입력마다 메모리의 할당이 일어나고 삭제에서는 메모리 해제가 일어난다. 이런 작업은 시간복잡도에 포함되지는 않지만 <strong>시스템 콜</strong>(System Call)을 사용하는 구문은 <code>시간 소요</code>가 꽤 걸린다.</p>
<p>사용하려는 목적에 따라서 Array와 List를 구분해서 사용하면 된다.</p>
<p>자자, 위에서는 Array와 LinkedList의 차이점을 살펴보았다. 이번에는 ArrayList와 LinkedList의 차이를 살펴보겠다. 사실 위에서 본 것과 차이는 거의 없다고 생각한다. 이유는 ArrayList가 단지 내부적으로 Array(배열)를 사용하고 List 인터페이스를 구현했기 때문에 거의 똑같다고 생각한다. 그래도 한 번 살펴보자.</p>
<h3 id="arraylist-vs-linkedlist">ArrayList vs LinkedList</h3>
<p><strong>1. ArrayList</strong></p>
<ul>
<li>내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해서 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.</li>
<li>대량의 자료를 추가/삭제 하는 경우 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하가 발생</li>
<li>중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 존재해야 한다.</li>
<li>반면 <strong>인덱스</strong>를 가지고 있어서 한 번에 참조가 가능해 데이터 검색에 유리하다.</li>
</ul>
<p><strong>ArrayList</strong>는 삽입과 삭제를 할 일이 없거나 배열의 끝에서만 하게 될 경우 유용하게 쓰일 수 있다. 원소에 대해 빠르게 접근할 수 있을 뿐만 아니라, 원소들이 메모리에 연속으로 배치해 있어 CPU 캐시 효율도 더욱 높다.</p>
<p><strong>2.LinkedList</strong></p>
<ul>
<li>데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.</li>
<li>ArrayList와 달리 데이터의 추가, 삭제시 불필요한 데이터의 복사가 없어 데이터의 추가, 삭제시에 유리하다.</li>
<li>반면, 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 성능상 불리하다.</li>
</ul>
<p><strong>3. 데이터의 검색,삽입,삭제시 성능 비교</strong></p>
<blockquote>
<p>검색</p>
</blockquote>
<ul>
<li>ArrayList : 인덱스 기반이기 때문에 O(1)의 시간복잡도를 갖는다.</li>
<li>LinkedList : 검색 시 모든 요소를 순차적으로 탐색해야 하기 때문에 O(N)의 시간 복잡도를 갖는다.</li>
</ul>
<blockquote>
<p>삽입,삭제</p>
</blockquote>
<ul>
<li>ArrayList : 삽입,삭제 이후 다른 데이터를 복사해야 하기 때문에 O(N)의 시간복잡도를 갖는다.</li>
<li>LinkedList : 이전 노드와 다음 노드를 참조하는 상태만 변경하면 되기 때문에 삽입, 삭제 시에 O(1)의 시간 복잡도를 갖는다. 하지만 이 부분도 경우에 따라 다르다.</li>
</ul>
<img src="/img/arraylist_linkedlist_diff.png" width="600" height="200">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@audrl1010/linked-list-%EC%99%80-array-%EC%B0%A8%EC%9D%B4%EC%A0%90-4ba873c2e5f5" target="_blank" rel="noopener">Linked List 와 Array</a></li>
<li><a href="https://makefortune2.tistory.com/191" target="_blank" rel="noopener">배열(Array)과 연결리스트(Linked List) 차이</a></li>
<li><a href="https://www.holaxprogramming.com/2014/02/12/java-list-interface/" target="_blank" rel="noopener">Java의 LinkedList와 ArrayList에 대한 비교</a></li>
<li><a href="https://manducku.tistory.com/33" target="_blank" rel="noopener">자료구조 List - ArrayList와 LinkedList 비교</a></li>
<li><a href="https://coding-factory.tistory.com/228?category=794828" target="_blank" rel="noopener">[Algorism] ArrayList와 LinkedList란 무엇인가?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-Diff-of-Array-LinkedList/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/27/DataStructure-What-Is/"
                            aria-label=": [자료구조] 자료구조 개요"
                        >
                            [자료구조] 자료구조 개요
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-27T15:01:29+09:00">
	
		    Dec 27, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="자료구조란">자료구조란?</h2>
<p>자료구조하면 무엇이 떠오르는가?</p>
<p>흔한 자료구조의 형태로 큐(Queue)나 스택(Stack) 혹은 연결 리스트, 트리 등을 떠올리거나 선택정렬, 삽입정렬 등의 정렬 알고리즘이 먼저 떠오른다.</p>
<p>사전적 의미를 살펴보면 다음과 같다. &quot;<code>자료(data)</code>의 집합을 의미하고 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 <code>효율적</code>으로 수행할 수 있도록 자료를 구분하여 표현한 것&quot;이라고 한다.</p>
<p>자료를 더 효율적으로 저장하고 관리하기 위해 사용하며 잘 선택된 자료구조는 <strong>실행 시간을 단축</strong>시켜주거나 <strong>메모리 용량의 절약</strong>을 이끌어 낼 수 있다.</p>
<p>자료 구조의 선택 기준은 아래와 같다.</p>
<ul>
<li>자료의 처리 시간</li>
<li>자료의 크기</li>
<li>자료의 활용 빈도</li>
<li>자료의 갱신 정도</li>
<li>프로그램의 용이성</li>
</ul>
<h2 id="자료구조의-특징">자료구조의 특징</h2>
<ol>
<li><strong>효율성</strong></li>
</ol>
<p>자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다.<br>
따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다.<br>
Ex)<br>
검색에 대한 알고리즘을 구현할 때, 데이터의 양이 만다면 순차 검색을 사용하는 것보다 이분 탐색(이분 검색)을 활용하는 것이 더 효율적일 것이다.<br>
왜냐하면 학생 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다.<br>
이에 반해, <strong>이분 탐색</strong>은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다.</p>
<ol start="2">
<li><strong>추상화</strong></li>
</ol>
<p>추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 시간을 더 쏟을 수 있다.<br>
알고리즘 자체에는 중점을 두지 않는다.</p>
<p>마찬가지로 자료구조 내부의 구현은 중요하지 않다.<br>
어떻게 구현했는지보다 어떻게 사용해야 하는지를 알고 있어야 한다.</p>
<p>Ex)<br>
Stack의 경우 나중에 들어간 것이 먼저 나오는 <code>LIFO(Last In First Out)</code>의 형태를 가지고 있다.</p>
<ul>
<li>push() 함수를 이용해 데이터를 삽입</li>
<li>pop() 함수를 이용해 데이터를 추출<br>
그 함수 내부 구현이 어떻게 되었는지는 크게 중요하지 않다. 사람마다 다른 코드를 작성할 것이고 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다.</li>
</ul>
<ol start="3">
<li><strong>재사용성</strong></li>
</ol>
<p>자료구조를 설계할 때 특정 프로그램에서만 동작하도록 설계 하지 않는다. 다양한 프로그램에서 동작할 수 있도록 <strong>범용성</strong> 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다.</p>
<h2 id="자료구조의-분류">자료구조의 분류</h2>
<p>자료구조는 크게 <strong>선형 자료구조</strong>와 <strong>비선형 자료구조</strong>로 나뉜다.</p>
<ol>
<li>선형 자료구조 : 데이터가 일렬로 나열되어 있는 즉, 선형인 것을 뜻한다.</li>
</ol>
<ul>
<li>배열</li>
<li>연결 리스트</li>
<li>스택</li>
<li>큐</li>
</ul>
<ol start="2">
<li>비선형 자료구조 : 선형이 아닌 특정한 형태를 띄고 있는 것을 뜻한다.</li>
</ol>
<ul>
<li>트리</li>
<li>그래프</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/27/DataStructure-What-Is/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/26/OS-MultiThread-Concept/"
                            aria-label=": [운영체제] 멀티 쓰레드"
                        >
                            [운영체제] 멀티 쓰레드
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-26T17:33:53+09:00">
	
		    Dec 26, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Operation-System/">Operation System</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%93%9C%EB%9E%80?">멀티쓰레드란?</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">멀티 프로세스와 멀티 쓰레드의 차이점</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%94%A9%EC%9D%98-%EC%9E%A5%EC%A0%90">멀티 쓰레딩의 장점</a></li>
<li><a href="#%EB%A9%80%ED%8B%B0-%EC%93%B0%EB%A0%88%EB%94%A9%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90">멀티 쓰레딩의 문제점</a></li>
</ol>
<h2 id="멀티-쓰레드란">멀티 쓰레드란?</h2>
<ul>
<li>하나의 프로세스를 다수의 실행 단위(즉, 쓰레드)로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 <code>멀티 쓰레딩</code>이라고 한다.</li>
<li>하나의 프로그램이 동시에 여러 개의 일을 수행할 수 있도록 해주는 것이다.</li>
</ul>
<h2 id="멀티-쓰레드를-사용하는-이유는">멀티 쓰레드를 사용하는 이유는?</h2>
<p>앞서 설명한 것처럼 프로세스를 이용하여 동시에 처리하던 일을 <strong>쓰레드</strong>로 구현할 경우 메모리 공간과 자원 소모를 줄일 수 있게 된다.</p>
<p>쓰레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 <strong>전역 변수의 공간</strong> 또는 동적으로 할당된 공간인 <strong>Heap 영역</strong>을 이용하여 데이터를 주고 받을 수 있는 통신을 할 수 있다.</p>
<p>그렇기 때문에 프로세스 간 통신 방법에 비해 쓰레드 간의 통신 방법이 훨씬 간단하다. <strong>심지어 쓰레드의 문맥교환은 프로세스의 문맥교환과는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다.</strong></p>
<p>따라서 앞에서 언급한 것처럼 시스템의 처리량이 향상되고 자원 소모가 줄어들어 자연스럽게 프로그램의 응답 시간이 단축된다.[즉, 프로그램이 빨라진다.]</p>
<p>이러한 장점 때문에 여러 프로세스로 할 수 있는 작업들을 하나의 프로세스에 <code>여러 쓰레드</code>로 나누어 수행하는 것이다.</p>
<h1 id="멀티-프로세스와-멀티-쓰레드의-차이점">멀티 프로세스와 멀티 쓰레드의 차이점</h1>
<ul>
<li>멀티 프로세스 : [데이터, 힙, 스택] 영역 모두를 비공유한다.</li>
<li>멀티 쓰레드 : [데이터, 힙, 스택] 영역 중 스택 영역만 비공유하고 데이터와 힙 영역은 공유한다.</li>
</ul>
<h1 id="멀티-쓰레딩의-장점">멀티 쓰레딩의 장점</h1>
<p>프로세스 생성은 앞에서 언급한 것과 같이 많은 시간과 자원을 소비한다. 이러한 단점을 최소화 시킨 일종의 <strong>경량화된 프로세스인 쓰레드</strong>를 만들게 된 것이다.</p>
<ul>
<li>멀티 쓰레드에서 쓰레드 간 스택 영역만 비공유하고 데이터 영역과 힙 영역은 공유한다.</li>
<li>쓰레드의 생성 및 컨텍스트 스위칭은 프로세스의 생성 및 컨텍스트 스위칭보다 빠르다.</li>
<li>멀티 쓰레드 컨텍스트 스위칭 시 데이터 영역과 힙 영역을 올리고 내릴 필요가 없다.</li>
<li>데이터 영역과 힙 영역을 통해 데이터 교환이 가능하다.</li>
<li>쓰레드 사이에서의 데이터 교환에는 특별한 기법이 필요하지 않다.</li>
</ul>
<img src="/img/what_is_multi_thread_1.png" width="400" height="200">
<h1 id="멀티-쓰레딩의-문제점">멀티 쓰레딩의 문제점</h1>
<p><strong>멀티 프로세스</strong> 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 대해 접근하는 일이 없었지만 <strong>멀티 쓰레딩</strong>을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다.</p>
<p>서로 다른 쓰레드가 <strong>데이터 영역과 힙 영역</strong>을 공유하기 때문에 어떤 쓰레드가 다른 쓰레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.</p>
<p>그렇기 때문에 멀티 쓰레딩 환경에서는 <code>동기화 작업</code>이 필요하다.</p>
<blockquote>
<p>동기화란?</p>
</blockquote>
<p>시스템의 한정적인 자원에 여러 쓰레드가 동시에 접근해서 사용하려고 하면 문제가 발생할 수 있다. 이런 문제를 방지하기 위해 <strong>쓰레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법</strong>이다.</p>
<p>동기화를 통해 <strong>작업 처리 순서</strong>를 컨트롤하고 <strong>공유 자원</strong>에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 <code>병목 현상</code>이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락(lock)으로 인한 병목 현상을 줄여야 한다.</p>
<p>공유 자원이 아닌 부분은 동기화 처리를 할 필요가 없다. 즉, 동기화 처리가 필요한 부분에만 <code>synchronized</code> 키워드를 통해 동기화 하는 것이다.</p>
<p>불필요한 부분까지 동기화를 할 경우 현재 쓰레드는 락(lock)을 획득한 쓰레드가 종료하기 전까지 대기해야 한다. 그렇게 되면 전체 성능에 악영향을 미치게 된다.</p>
<p>즉, 동기화를 하고자 할 때는 메소드 전체를 동기화 할 것인가 아니면 특정 부분만 동기화할 것인가를 고민해야 한다.</p>
<h1 id="임계영역">임계영역</h1>
<p>둘 이상의 쓰레드(또는 프로세스)가 공유 자원에 동시에 접근하면 문제가 발생할 수 있다. 이런 문제를 일으킬 수 있는 코드 블록을 임계 영역이라고 한다. 다시 말해 임계 영역은 배타적 접근 권한(한 순간에 하나의 쓰레드만 접근)이 요구되는 공유 리소스(전역변수, static 변수 등)에 접근하는 코드 블럭을 의미한다.</p>
<h1 id="동기화-방법">동기화 방법</h1>
<p>여러 쓰레드들은 자원을 공유하고, 프로세스간 메시지를 전송하면서 간혹 문제가 발생할 수 있다. 즉, <code>공유된 자원에 여러 프로세스, 쓰레드가 접근하면서 문제</code>가 발생한다.</p>
<p>그래서 동기화를 통해 작업의 처리 순서와 공유 자원에 대한 접근을 컨트롤 하는 것이다.</p>
<p>Mutex/Semaphore/Monitor<br>
3가지가 존재하고 모두 운영체제의 동기화 기법이다.<br>
프로세스의 동기화 기법<br>
쓰레드의 동기화 기법</p>
<h2 id="뮤텍스">뮤텍스</h2>
<p>뮤텍스는 <code>Mutual Exclusion</code>의 약자로 공유 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것이다.</p>
<p>뮤텍스의 쓰레드 동기화 방법은 임계 영역에 들어가기 위해 이 뮤텍스 객체를 가지고 있어야 들어갈 수 있다. 즉, 임계 영역을 가진 쓰레드들의 Running time이 서로 겹치지 않게 각각 단독으로 실행되게 하는 기술이다.</p>
<p>일종의 <strong>자물쇠</strong> 역할을 한다. 임계 영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올 때까지 다른 쓰레드가 못 들어오게 내부에서 자물쇠로 잠근다.</p>
<p><strong>fitting romm을 예로 들어 설명하겠다.</strong></p>
<p>fitting room은 ‘사용중’ 표시를 하는 대신에 사용자들에게 <strong>열쇠</strong>를 지급한다. 열쇠를 지급받은 사용자는 fitting room에 들어가서 옷을 갈아입는다. 열쇠가 없는 사람들은 기다린다. 옷을 다 갈아입은 사람은 열쇠를 카운터에 반납한다. fitting room을 사용할 사람은 카운터로 가서 열쇠를 받아서 사용하면 된다.</p>
<p>이것이 바로 대략적인 뮤텍스에 대한 설명이다.<br>
fitting room = 임계 영역<br>
열쇠 = mutex<br>
사용자 =  쓰레드</p>
<p>아래 그림을 보며 정리하자.</p>
<img src="/img/os_sync_mutex1.png" width="500" height="200">
<p>임계 영역(그림의 Protected Resource)에 진입하길 원하는 3개의 고양이(쓰레드)가 있다. 임계 영역에 접근하기 위해서는 <code>뮤텍스</code>라는 열쇠가 필요하다. 뮤텍스를 얻어야 임계 영역에 진입할 수 있다.</p>
<img src="/img/os_sync_mutex2.png" width="500" height="200">
<p>한 쓰레드(고양이)가 뮤텍스(열쇠)를 획득했다. 이제 이 쓰레드(고양이)는 임계 영역에 진입할 수 있게 된다.</p>
<img src="/img/os_sync_mutex3.png" width="500" height="200">
<p>진입한 쓰레드는 임계 영역을 처리한다. 이 때 다른 쓰레드들은 아무일도 못하고 쉬게 된다. 뮤텍스가 반환될 때까지 쉬면서 기다릴 수 밖에 없다.(Block 상태를 의미한다.)</p>
<img src="/img/os_sync_mutex4.png" width="600" height="200">
<p>임계 영역에 있는 쓰레드가 빠져나와 뮤텍스를 반납한다. 쉬던 쓰레드들이 이제 뮤텍스를 가질 수 있으며 이 쓰레드들 중 하나가 뮤텍스를 가지게 될 것이다. 그리고 지금까지의 과정을 반복한다.</p>
<h2 id="세마포어">세마포어</h2>
<p>세마포어 역시 뮤텍스와 비슷한 역할을 하지만 세마포어는 동시 접근 동기화가 아닌 <strong>접근 순서 동기화</strong>에 더 관련있다.</p>
<p>내가 운영하는 별다방이 있다고 하자. 좌석은 테이블이 5개 있다. 각 테이블에는 한명의 손님만 사용할 수 있다고 가정</p>
<p>손님이 와서 빈 테이블을 보면 찾아서 앉고 시간을 보내고 집에 간다. 이 카페는 5개의 테이블만큼 손님을 받을 수가 있다. 5개의 테이블이 가득 차면 다음 손님은 기다려야 한다.</p>
<p>옷가게 fitting room에서는 한 명만 이용할 수 있었지만, 카페에서는 5 테이블을 이용할 수 있다. 이 점이 뮤텍스와 세마포어의 차이점이다.</p>
<p>카페가 임계 영역(critical section)이 되고, 손님은 쓰레드가 된다. 5개의 테이블이 바로 <strong>세마 포어</strong>이다. 뮤텍스가 5개가 되는 상황으로 이해할 수 있다. fitting room으로 바꾸면 최대 5명이 동시에 이용할 수 있는 큰 fitting room이 된다.</p>
<p>여기서는 개인의 권리가 없는 이상한 fitting room이 된다. 아무튼 이런 fitting room을 이용하려면 5개의 열쇠가 필요하다. 5개의 열쇠 즉, 5개의 뮤텍스가 바로 세마포어가 된다. 그래서 세마포어는 뮤텍스와 다르게 <code>count</code>와 관련된 사항이 중요하다.</p>
<p>세마포어는 다음의 세 가지 원자적인 연산만을 지원한다.</p>
<ul>
<li>initialize, decrement, increment</li>
<li>initialize : 세마포어 초기화(음이 아닌 정수값으로 초기화)</li>
<li>decrement : 프로세스를 블록시킬 수 있다.</li>
<li>increment : 블록되었던 프로세스를 깨울 수 있다. 이 세마포어를 <strong>카운팅 세마포어</strong> 또는 <strong>범용 세마포어</strong>라고 한다. 세마포어의 값에 따라 운영체제는 프로세스가 즉시 자원을 사용할지, 자원이 다른 프로세스에 의해 사용 중인걸 알게 될 경우에는 일정 시간을 기다려야 한다.<br>
프로세스가 자원을 사용하는 동안에는 세마포어 값을 변경함으로써 다른 프로세스들이 기다리게 해야 한다.</li>
<li>프로세스간 메시지를 전송하거나 고유 메모리를 통해 특정 데이터를 공유하게 될 경우 공유 자원에 여러 프로세스가 접근하면서 문제가 발생하기 때문에 하나의 프로세스만 공유 자원에 접근 가능하도록 설정할 때 세마포어를 사용한다.</li>
</ul>
<ul>
<li>이진 세마포어 : 0 또는 1의 값을 가지는 세마포어</li>
</ul>
<img src="/img/os_sync_semaphore1.png" width="600" height="200">
<p>위 그림은 뮤텍스를 설명하는 그림이다. 세마포어는 다수의 뮤텍스로 이해할 수 있다고 했으므로 다음 그림처럼 표현할 수 있다.</p>
<img src="/img/os_sync_semaphore2.png" width="600" height="200">
<p>임계 영역으로 들어갈 수 있는 <strong>열쇠인 세마포어가 3개이다.</strong> 어떤 쓰레드가 세마포어를 얻으면 남은 세마포어의 수는 2개이다. 또 어떤 쓰레드가 세마포어를 얻어서 진입했다. 남은 세마포어의 수는 1개이다. 또 어떤 쓰레드가 세마포어를 얻어서 진입했다. 그러면 남은 세마포어의 수는 0개이다. 또 어떤 쓰레드가 임계영역에 진입하려 할 때, 더이상 남은 세마포어가 없기 때문에 임계영역 내에 어떤 쓰레드가 빠져나오면서 세마포어를 반납할 때까지 기다려야 한다.</p>
<h2 id="모니터">모니터</h2>
<p>Mutex(Lock)와 Condition Variables(Queue라고도 함)을 가지고 있는 Synchronization 메카니즘이다. 예를 들어 자바에서 모든 객체는 Object 클래스를 상속 받는다. 이 Object 클래스에는 wait(), nofityAll(), nofity() 메소드를 가지고 있는데 이게 바로 <strong>Condition Variables</strong> 역할이라고 보면 된다.</p>
<p>고로 모든 자바 객체는 Monitor를 가지고 있다. 자바에서는 Mutual Exclusion 해결을 위한 구현체로 <code>Synchronization</code> 키워드가 있다. 예들 들어, Synchronization가 메소드에 선언되어 있고, 쓰레드 A가 이미 Lock을 획득해서 Critical Section(메소드, 임계영역)을 수행중이라고 가정하자. 쓰레드 B가 동일한 메소드를 수행하기 위해 해당 Object의 Lock을 획득해야 할 것이다. 이 Lock이 반환될 때까지 대기를 해야하는데 그 때 사용되는게 바로 <strong>Monitor</strong>이다.</p>
<p>쓰레드 A가 Lock을 반환하면 쓰레드 B는 기다렸다가 Lock을 획득하게 된다. 그리고 Critical Section인 메소드를 수행할 수 있게 된다. 물론 Synchronized 키워드를 사용했을 때 자동적으로 수행되는 내부 동작이고, 별도로 명시적인 Monitor를 구현할 수도 있다. 그 외 Monitor의 다른 정의로는 공유자원에 안전하게 접근하기 위해 Mutual Exclusion가 랩핑된 Thread-Safe한 클래스, 객체, 모듈들을 의미하기도 한다.</p>
<p>하지만, 위의 모니터에 대한 설명은 무슨 말인지 이해가 가지 않는다. ㅜㅜ 이해가지 않으니 차이점이라도 알고 넘어가자.</p>
<p>우선 뮤텍스 / 모니터 / 세마포어는 개념적으로 차이가 있다.</p>
<p>전자(뮤텍스, 모니터)는 <strong>상호 배제</strong>를 함으로써 임계구역에 <strong>하나의 쓰레드만</strong> 들어갈 수 있다.</p>
<blockquote>
<p>상호 배제란?</p>
</blockquote>
<p>여기서 등장하는 상호 배제는 무엇일까??<br>
<strong>상호 배제</strong>는 한 프로세스가 공유 자원을 접근하는 임계 영역 코드를 수행하고 있으면 다른 프로세스ㅡㄹ은 공유 자원을 접근하는 임계 영역의 코드를 수행할 수 없다는 조건이다.</p>
<ul>
<li>임계 영역을 보호하기 위한 개념</li>
<li>둘 이상의 프로세스(혹은 쓰레드)가 공유자원에 대해 동시에 읽거나 쓰는 것을 방지하기 위한 기법</li>
<li>상호 배제 기법에는 뮤텍스, 세마포어, 모니터, 메시지 전달 등의 기법이 있다.</li>
</ul>
<p>후자(세마포어)는 <strong>하나의 쓰레드</strong>만 들어가거나 혹은 <strong>여러 개의 쓰레드</strong>가 들어가게 할 수도 있다.</p>
<p><code>Q. 뮤텍스와 모니터의 차이는?</code></p>
<ul>
<li>가장 큰 차이는 <strong>뮤텍스</strong>는 <strong>다른 프로세스</strong>(애플리케이션) 간에 동기화를 위해 사용한다. 반면에 <strong>모니터</strong>는 하나의 프로세스(애플리케이션)내에 <strong>다른 쓰레드들 간</strong>에 동기화를 위해 사용한다.</li>
<li>또한, 뮤텍스는 보통 운영체제 커널에 의해서 제공되는 반면에 모니터는 프레임워크나 라이브러리 그 자체에서 제공된다.</li>
<li>따라서 뮤텍스는 무겁고(heavy-weight) 느리며(slower) 모니터는 가볍고(light-weight) 빠르다(faster).</li>
</ul>
<p><code>Q. 세마포어와 모니터의 차이는?</code></p>
<ul>
<li>Java에서는 모니터를 모든 객체에게 기본적으로 제공하고 있는 반면 C에서는 모니터를 사용할 수 없다.</li>
<li>세마포어는 <strong>카운터라는 변수 값</strong>으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시 매번 값을 따로 지정해줘야 하는 등 조금 번거롭다.</li>
<li>반면, 모니터는 이러한 일들이 <strong>캡슐화</strong>(encapsulation)되어 있어서 개발자는 카운터값을 1 또는 0으로 주어야 하는 고민을 할 필요없이 synchronized, wait(), nofity() 등의 키워드를 이용해 조금 더 편하게 동기화를 할 수 있다.</li>
</ul>
<p><code>Q. 뮤텍스와 세마포어의 차이는?</code></p>
<p>세마포어는 뮤텍스가 될 수 있지만<br>
뮤텍스는 세마포어가 될 수 없다.</p>
<p>(뮤텍스) 세마포어 -&gt; 가능<br>
(세마포어) 뮤텍스 -&gt; 불가능</p>
<p>세마포어는 소유할 수 없는 반면<br>
뮤텍스는 소유할 수 있고 소유자가 이에 책임을 진다.</p>
<p>뮤텍스는 <strong>1개만</strong> 동기화가 되지만<br>
세마포어는 <strong>하나 이상</strong>을 동기화할 수 있다.</p>
<p><strong>Example</strong></p>
<p>변기가 하나뿐인 화장실에서는<br>
앞의 사람이 볼일을 마치고 나와야 다음 사람이 들어갈 수 있다.<br>
이렇게 한번에 오직 하나만 처리할 수 있는 대상에 사용하는 것이 <code>뮤텍스</code>이다.</p>
<p>변기가 세개인 화장실에서는 동시에 세 사람이 볼일을 볼 수 있고<br>
이 세 사람 중 아무나 한명이 나오면 다음 사람이 들어가서 볼일을 볼 수 있다.<br>
이렇게 동시에 제한된 수의 여러 처리가 가능하면 <code>세마포어</code>를 사용한다.</p>
<p>만약 변기 세개짜리 화장실의 각 변기에 대해 <strong>뮤텍스</strong>를 사용한다면<br>
대기 중인 사람은 각 변기 앞에 줄을 서는 것이고<br>
이렇게 되면 옆 칸이 비어도 들어가지 못하게 된다.</p>
<p>만약 변기 세개를 묶어서 뮤텍스를 사용한다면<br>
변기 수에 관계없이 무조건 <strong>한명만</strong> 사용할 수 있게 된다.</p>
<p>변기 - 동기화 대상(즉,공유 자원)<br>
사람 - 동기화 대상에 접근하는 쓰레드</p>
<p>뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 쓰레드에 의해서 사용중일 경우 다른 쓰레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만 관리하는 동기화 대상이 <code>몇 개</code>인가에 따라 차이가 생기게 된다.</p>
<h1 id="참고">참고</h1>
<ul>
<li><a href="https://mooneegee.blogspot.com/2015/01/oscritical-section-2-mutex.html" target="_blank" rel="noopener">임계영역 동기화 - 뮤텍스</a></li>
<li><a href="https://m.blog.naver.com/PostView.nhn?blogId=rja1104&amp;logNo=220551216367&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" target="_blank" rel="noopener">멀티 쓰레드란?</a></li>
<li><a href="https://goodgid.github.io/What-is-Thread/" target="_blank" rel="noopener">쓰레드란</a></li>
<li><a href="http://sycho-lego.tistory.com/11" target="_blank" rel="noopener">세마포어와 뮤텍스</a></li>
<li><a href="https://mooneegee.blogspot.com/2015/01/osthread-critical-section.html" target="_blank" rel="noopener">쓰레드와 임계영역</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/26/OS-MultiThread-Concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/26/OS-Thread/"
                            aria-label=": [운영체제] 쓰레드"
                        >
                            [운영체제] 쓰레드
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-26T14:05:44+09:00">
	
		    Dec 26, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Operation-System/">Operation System</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EC%93%B0%EB%A0%88%EB%93%9C">메모리 관점에서 본 쓰레드</a></li>
<li><a href="#IPC">IPC</a></li>
<li><a href="#%EC%93%B0%EB%A0%88%EB%93%9C%EB%9E%80?">쓰레드란?</a></li>
<li><a href="#%EC%93%B0%EB%A0%88%EB%93%9C%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%98%EC%97%AC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%88%98%ED%96%89%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EC%9E%A5%EC%A0%90">쓰레드를 생성하여 프로세스를 수행했을 때의 장점</a></li>
<li><a href="#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4">프로세스와 쓰레드의 차이</a></li>
</ul>
<h1 id="메모리-관점에서-본-쓰레드">메모리 관점에서 본 쓰레드</h1>
<p>이를 보기 전에 먼저 <code>메모리 관점에서 본 프로세스</code>편을 보고 오기를 추천한다.</p>
<p>각각의 프로세스는 메모리 공간에서 독립적으로 존재한다.</p>
<img src="/img/process_memory_organization.png" width="400" height="200">
<p>위의 그림은 프로세스를 구성하는 메모리 공간의 모습이다. 각각의 프로세스는 자신만의 이런 메모리 구조를 가진다. 프로세스 A, B, C가 존재한다면 각각의 프로세스는 모두 위와 같은 구조의 메모리 공간을 가진다.</p>
<p>독립적인 만큼 다른 프로세스의 메모리 공간에 접근할 수도 없다. A가 B의 메모리 공간에 접근하게 된다면 재앙이 발생할 수도 있다.<br>
예를 들면, Chrome이 windows 메모리 공간에 접근한다면 안전성이 보장되지 않는 문제가 발생할 것이다.</p>
<p>운영체제의 메모리 공간에 접근하여 뭔가를 변경한다면 심각한 문제가 발생할 수 있다.(물론 운영체제의 메모리 공간에 접근하는 것은 원천적으로 불가능하다.) 그러므로 <strong>프로세스의 안전성을 보장하기 위해서는 프로세스는 각각 독립된 메모리 공간을 가져야 한다.</strong></p>
<p>그렇다면 프로세스 A에서 연산한 결과를 프로세스 B가 받아서 사용하고 싶다면 어떻게 해야할까??</p>
<h2 id="ipc">IPC</h2>
<p>(inter process communication)</p>
<img src="/img/IPC.png" width="400" height="200">
<p>A의 메모리 공간에 B가 직접 접근하지 못하기 때문에 프로세스간의 통신을 하는 특별한 방법이 존재하는데 메일슬롯, 파이프 등이 바로 프로세스 간의 통신 즉, IPC의 예라고 할 수 있다.</p>
<p>IPC에 대한 설명은 <a href="%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4">프로세스</a>부분을 참고하면 된다.</p>
<p>여기서 중요한 점은 프로세스는 독립적인 메모리 공간을 지니기 때문에 IPC를 통하지 않고서는 통신할 수 없다는 사실이다. 그리고 프로세스가 여럿이 병렬적으로 실행되기 위해서는 필연적으로 <code>Context Switching</code>이 발생할 수밖에 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">독립적인 메모리 공간으로 컨텍스트 스위칭이 발생한다.</span><br><span class="line">프로세스 간 통신하기 위해서는 IPC가 필요하다.</span><br></pre></td></tr></table></figure>
<p>위의 두 가지 프로세스가 지니는 문제점을 한 번에 해결할 수 있는 녀석이 <strong>쓰레드</strong>이다.</p>
<p><strong>메모리 공간에서의 쓰레드</strong></p>
<img src="/img/diff_process_thread.png" width="400" height="200">
<p>위 그림은 프로세스와 쓰레드의 메모리 구조의 차이점을 보여주는 그림이다. 왼쪽의 프로세스는 앞에서 설명했고, 오른쪽의 쓰레드의 메모리 구조를 확인해보자.</p>
<p>쓰레드는 프로세스 안에 존재하는 실행 흐름이다. 메모리 구조 역시 그러하다. 특이한 점은 쓰레드는 프로세스의 <strong>heap, stack, code</strong> 영역 등을 공유한다는 사실이다. 각각의 프로세스가 독립적인 stack, heap, data, code 영역을 가진 반면에 한 프로세스에 속한 쓰레드는 stack 영역을 제외한 메모리 영역은 프로세스의 메모리 영역을 공유해서 사용한다.</p>
<p>쓰레드가 code 영역을 공유하기 때문에 한 프로세스 내부의 다른 쓰레드들은 프로세스가 가지고 있는 함수를 자연스럽게 호출할 수 있다.</p>
<p>뿐만 아니라 쓰레드는 data, heap 영역을 공유하기 때문에 IPC 없이도 쓰레드 간의 통신이 가능하다. 동일한 프로세스 내부에 존재하는 쓰레드 A, B가 통신하기 위해 heap 영역에 메모리 공간을 할당하고 두 쓰레드가 자유롭게 접근한다고 생각하면 된다.</p>
<p>쓰레드는 프로세스처럼 스케줄리으이 대상이다. 이 과정에서 <strong>컨텍스트 스위칭</strong>이 발생한다. 하지만 쓰레드는 공유하고 있는 메모리 영역 덕분에 컨텍스트 스위칭이 발생하는 오버헤드가 프로세스에 비해 작다.</p>
<h1 id="쓰레드란">쓰레드란?</h1>
<hr>
<p>동일한 일을 하는 부분이 많은 프로세스를 여러 개 생성하는 것은 메모리 낭비이다. 그래서 프로세스는 하나만 생성하고 <code>Program Counter</code>만 여러 개 생성한다. 즉, CPU 수행 단위를 여러 개를 두는 것이며 이를 쓰레드라고 한다.</p>
<p>각각 다른 Instruction을 수행하려면 Program Counter 값이 존재해야 하고, 메모리에 어떤 레지스터 값들을 세팅해야 할텐데, 쓰레드마다 Program Counter 값과 레지스터 값들이 들어가는 것이다. 이렇게 쓰레드를 생성하여 쓰레드마다 다른 부분의 코드를 실행할 수 있게 하면 된다.</p>
<ul>
<li>
<p>쓰레드란 프로그램(프로세스) 실행의 단위이며 하나의 프로세스는 <strong>1개 이상의 쓰레드</strong>로 구성이 가능하다.</p>
</li>
<li>
<p>하나의 프로세스를 구성하는 쓰레드들은 프로세스에 할당된 메모리, 자원 등을 공유한다.</p>
</li>
<li>
<p>프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며 실행 상태가 변할 때마다 <code>쓰레드 문맥 교환(context switching)</code>을 수행한다.</p>
</li>
<li>
<p>각 쓰레드별로 자신만의 <strong>스택</strong>과 <strong>레지스터</strong>를 가진다.</p>
</li>
<li>
<p>특징</p>
<ul>
<li>스레드는 프로세스 내에서 Stack만 따로 할당받고, 프로세스의 Code, Data, Heap 영역은 공유한다.</li>
<li>스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유하며 실행된다.</li>
<li>같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.</li>
<li>각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.</li>
<li>한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.</li>
</ul>
</li>
</ul>
<img src="/img/thread_os.png" width="400" height="200">
<h2 id="쓰레드를-생성하여-프로세스를-수행했을-때의-장점">쓰레드를 생성하여 프로세스를 수행했을 때의 장점</h2>
<ol>
<li>응답시간이 줄어든다.(Responsiveness)</li>
</ol>
<p>하나의 프로세스 안에 여러 쓰레드를 두게 되면 <strong>즉, 다중 쓰레드로 구성된 프로세스 내에서는 하나의 서버 쓰레드가 blocked(or waiting)상태인 동안에도 동일한 프로세스 내의 다른 쓰레드가 실행되어 보다 빠른 처리가 가능하다.</strong> 웹 브라우저에서 네트워크를 통해 웹 페이지를 읽어올 때 읽어오는 작업이 오래 걸리기 때문에, 웹 브라우저 상태가 blocked 상태가 된다. 하나의 쓰레드가 데이터를 읽어오는 동안에 다른 쓰레드가 읽어온 데이터를 화면에 뿌려주는 역할을 하면 되는 것이다.</p>
<ol start="2">
<li>시스템의 자원소모가 줄어든다.(Resource Sharing로 인해)</li>
</ol>
<p>하나의 프로세스 안에 여러 개의 쓰레드를 두면 메모리 낭비를 줄일 수 있다. 비슷한 작업에 대해서는 리소스를 공유한 결과이다.</p>
<ol start="3">
<li>Economy</li>
</ol>
<p>생성하고 switch 하는 면에서 프로세스보다 오버헤드가 적고 빠르다. 이를 경제적이라고 표현한다.[아직 정확한 원리를 잘 모른다.]</p>
<ol start="4">
<li>Utilization of MP(MultiProcessor) Architectures</li>
</ol>
<p>쓰레드를 생성하게 되면 병렬성을 높일 수 있다. 이는 CPU가 여러 개인 컴퓨터에서만 얻을 수 있는 장점이지만 쓰레드를 통해 이 장점을 취할 수 있다.</p>
<h1 id="프로세스와-쓰레드의-차이">프로세스와 쓰레드의 차이</h1>
<p>프로세스는 운영체제로부터 자원을 할당받는 <strong>작업의 단위</strong>이고<br>
쓰레드는 프로세스가 할당받은 자원을 이용하는 <strong>실행의 단위</strong>이다.</p>
<ul>
<li>
<p>프로세스는 실행중인 프로그램으로 디스크로부터 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다.</p>
</li>
<li>
<p>하지만 프로세스의 생성은 많은 시간과 자원을 소모한다.</p>
</li>
<li>
<p>쓰레드는 프로세스의 실행단위라고 위에서 설명했다.</p>
</li>
<li>
<p>한 프로세스 내에서 동작하는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원 등을 공유할 수 있다.</p>
</li>
<li>
<p>이 경우 각각의 쓰레드는 <strong>독립적인 작업</strong>을 수행해야 하기 때문에 각자의 <strong>스택</strong>과 <strong>PC 레지스터 값</strong>을 갖고 있다.</p>
</li>
</ul>
<blockquote>
<p>쓰레드마다 스택을 독립적으로 할당하는 이유</p>
</blockquote>
<p>스택은 함수 호출시 전달되는 인자, 복귀 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간으로 스택 메모리 공간이 독립적이라는 것은 <strong>독립적인 함수 호출</strong>이 가능하다는 것이고 이는 <strong>독립적인 실행 흐름</strong>이 가능하게 한다.</p>
<p>따라서 <code>독립적인 실행 흐름을 위한 최소 조건</code>으로 독립된 스택을 할당한다.</p>
<blockquote>
<p>쓰레드마다 PC Register를 독립적으로 할당하는 이유</p>
</blockquote>
<p>PC 값은 쓰레드가 명령어의 어디까지 수행했는지를 나타내게 된다. 쓰레드는 CPU를 할당받았다가 <strong>스케쥴러</strong>에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있다. 따라서 PC 레지스터를 독립적으로 할당하는 것이다.</p>
<h1 id="쓰레드의-장점">쓰레드의 장점</h1>
<ul>
<li>쓰레드는 프로세스보다 생성 및 종료시간, 쓰레드간 전환시간이 짧다.</li>
<li>쓰레드는 프로세스의 메모리 자원 ㄷ으을 공유하므로 커널의 도움 없이<br>
<strong>상호 간에 통신</strong>이 가능하다.</li>
<li>프로세스 간의 통신 방법에 비해 쓰레드의 간의 통신 방법이 훨씬 간단하다.[별도의 자원을 이용하는 것이 아니라 전역 변수의 공간을 이용하여 데이터를 주고 받을 수 있다.]</li>
</ul>
<h1 id="쓰레드의-단점">쓰레드의 단점</h1>
<ol>
<li>동기화 문제</li>
</ol>
<p>앞에서 언급한 쓰레드의 장점 중에서 쓰레드 간의 통신시 데이터를 주고 받는 방법은 메모리 공간을 공유하여 데이터 세그먼트, 즉 전역변수를 이용한다고 했다. <strong>그런데 공유하는 전역 변수를 여러 쓰레드가 함께 사용하려면 충돌하는 문제가 발생한다.</strong></p>
<p>따라서 쓰레드 간에 통신할 경우에는 충돌 문제가 발생하지 않도록 <code>동기화</code>를 통하여 문제를 해결해야 한다.</p>
<ol start="2">
<li>멀티 쓰레드를 이용할 때 주의 깊게 설계해야 한다.</li>
<li>프로그램 디버깅이 어렵다.(왜지?)</li>
<li>단일 프로세서 시스템에서는 효과를 기대하기 어렵다.</li>
</ol>
<h1 id="쓰레드의-종류">쓰레드의 종류</h1>
<ol>
<li>kernel Thread(커널 쓰레드)</li>
</ol>
<p>프레소스 내 스레드가 여러 개라는 것을 OS가 알고 있는 쓰레드이다. <strong>그래서 커널이 쓰레드 스케쥴링을 맡아서 하게 된다.</strong></p>
<ol start="2">
<li>User Thread(유저 쓰레드)</li>
</ol>
<p>라이브러리 차원에서 지원되는 쓰레드이다. <strong>프로세스 안에 쓰레드가 여러 개 있다는 것을 OS가 모르기 때문에 커널 입장에서는 하나의 일반적인 프로세스로 인식된다.</strong></p>
<h1 id="참고">참고</h1>
<ul>
<li><a href="http://arer.tistory.com/80" target="_blank" rel="noopener">[운영체제 이론] 스레드</a></li>
<li><a href="https://goodgid.github.io/What-is-Thread/" target="_blank" rel="noopener">쓰레드란 무엇인가?</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html" target="_blank" rel="noopener">프로세스와 쓰레드의 차이</a></li>
<li><a href="http://ralf79.tistory.com/34" target="_blank" rel="noopener">프로세스와 쓰레드 차이</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/26/OS-Thread/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/16/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/18/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 17 of 28</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
