
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/6/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/09/15/RxJava-Chap08/"
                            aria-label=": [RxJava] Chap08. 테스팅과 Flowable"
                        >
                            [RxJava] Chap08. 테스팅과 Flowable
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-15T20:51:07+09:00">
	
		    Sep 15, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="testobserver-클래스">TestObserver 클래스</h2>
<ul>
<li>RxJava에서 제공하는 TestObserver 클래스다.</li>
<li>JUnit 기반의 테스트 코드와 다른 점은 test()와 assertResult() 함수다.</li>
<li>코드는 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JUnitBasic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetShapeObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2-R"</span>, <span class="string">"3-T"</span>&#125;;</span><br><span class="line">        <span class="comment">// source : 실제 결과.</span></span><br><span class="line">        Observable&lt;String&gt; source = Observable.fromArray(data)</span><br><span class="line">                .map(Shape::getShape);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// expected : 예상 결과.</span></span><br><span class="line">        String[] expected = &#123;Shape.BALL, Shape.RECTANGLE, Shape.TRIANGLE&#125;;</span><br><span class="line">        source.test().assertResult(expected);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>assertResult()</strong> : 예상된 결과와 실제 결과를 비교하는 메소드. JUnit의 assertEquals() 메소드와 같다.</li>
<li><strong>assertFailure()</strong> : Observable에서 기대했던 에러가 발생하는지 확인하는 코드다. 만약, 기대했던 에러가 발생하지 않으면 테스트 코드 실행은 실패한다.
<ul>
<li>총 3개의 값을 넣어 앞 두 번째 값까지는 정상적으로 발행하고 마지막 값에서 기대했던 예외가 발생하는지 확인한다.</li>
<li>세번째 데이터는 %를 붙여서 Integer.parseInt()에서 변환이 안되기 때문에 NumberFormatException이 발생하고 onError 이벤트로 종료된다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertFailureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"%300"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(data)</span><br><span class="line">                .map(Integer::parseInt);</span><br><span class="line"></span><br><span class="line">        source.test().assertFailure(NumberFormatException.class, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>assertFailureAndMessage()</strong> : 기대했던 에러 발생시 에러 메시지까지 확인할 수 있다.
<ul>
<li>에러 메시지를 확인하기 위한 message 인자가 추가되었다.</li>
<li>에러가 발생했을 때 메시지를 확인하기 위해 아래와 같은 구문을 추가한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertFailureAndMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] data = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"%300"</span>&#125;;</span><br><span class="line">    Observable&lt;Integer&gt; source = Observable.fromArray(data)</span><br><span class="line">            .map(Integer::parseInt);</span><br><span class="line"></span><br><span class="line">    source.test().assertFailureAndMessage(NumberFormatException.class,</span><br><span class="line">            <span class="string">"For input string : \"%300\""</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>awaitDone()</strong> : interval() 함수처럼 비동기로 동작하는 Observable 코드를 테스트할 수 있다.</li>
<li><strong>assertComplete()</strong> : Observable을 정상적으로 완료했는지(onComplete 이벤트) 확인한다.</li>
<li></li>
</ul>
<h2 id="비동기-코드-테스트">비동기 코드 테스트</h2>
<ul>
<li>RxJava는 다양한 상황에서 비동기 코드를 직관적으로 작성할 수 있다. 하지만, 비동기 코드를 테스트하는 것은 어려우므로 RxJava는 비동기로 동작하는 코드를 테스트할 방법을 제공한다.</li>
<li>Observable.interval() 메소드는 main 스레드가 아닌 계산 스케줄러에서 실행되기 때문에 비동기 코드를 테스트할 필요가 있다. <code>awaitDone()</code> 함수를 사용하면 된다.</li>
<li>awaitDone() 함수는 test() 함수가 실행되는 스레드에서 onComplete() 함수를 호출할 때까지 기다려준다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAsync</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(<span class="number">5</span>)</span><br><span class="line">                .map(Long::intValue);</span><br><span class="line"></span><br><span class="line">        source.doOnNext(Log::d)</span><br><span class="line">                .test()</span><br><span class="line">                .awaitDone(<span class="number">1L</span>, TimeUnit.SECONDS)</span><br><span class="line">                .assertResult(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HTTP 서버와 통신하는 코드를 테스트하는 것은 소스 코드만 봐도 충분히 이해할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHttp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String url = <span class="string">"http://api.github.com/users/yudong80"</span>;</span><br><span class="line">    Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">            .subscribeOn(Schedulers.io())</span><br><span class="line">            .map(OkHttpHelper::get)</span><br><span class="line">            .doOnNext(Log::d) <span class="comment">// json 을 로그로 찍는다.</span></span><br><span class="line">            .map(json -&gt; GsonHelper.parseValue(json, <span class="string">"name"</span>))</span><br><span class="line">            .observeOn(Schedulers.newThread());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// json 중에서 name 만 뽑은 것을 로그로 찍는다.</span></span><br><span class="line">    String expected = <span class="string">"Dong Hwan Yu"</span>;</span><br><span class="line">    source.doOnNext(Log::i)</span><br><span class="line">            .test()</span><br><span class="line">            .awaitDone(<span class="number">3</span>, TimeUnit.SECONDS)</span><br><span class="line">            .assertResult(expected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP 호출은 IO 스케줄러에서 실행되었고 JSON 파싱 결과는 뉴 스레드 스케줄러에서 출력한다. UI 프로그래밍을 할 때는 뉴 스레드 스케줄러 대신 UI 스레드로 변경하면 된다.</li>
</ul>
<h2 id="flowable-클래스">Flowable 클래스</h2>
<ul>
<li>배압 이슈를 위해 별도로 분리한 클래스다.</li>
<li>Flowable 클래스를 도입한 이유는 Observable 클래스의 성능을 향상시키기 위해서다.</li>
<li>기존의 Observable 클래스(배압 관련 함수들을 포함했었다.)는 배압에 관한 처리가 불필요한 경우에는 초기 로딩 때문에 약간의 오버헤드가 있었지만, RxJava 2.X의 Observable 클래스에는 배압으로 인한 성능 오버헤드가 사라졌다.</li>
<li>Flowable -&gt; Observable로 변환하는 것뿐만 아니라 반대도 어렵지 않다.</li>
</ul>
<h3 id="observabler과-flowable의-선택-기준">Observabler과 Flowable의 선택 기준</h3>
<p><strong>1. Observable을 사용해야 할 때</strong></p>
<ul>
<li>최대 1000개 미만의 데이터 흐름.</li>
<li>예를 들어, 응용 프로그램에서 OOM이 발생할 확률이 거의 없는 경우다</li>
<li>마우스 이벤트나 터치 이벤트를 다루는 GUI 프로그래밍. 이 경우에는 배압의 이슈가 거의 발생하지 않는다. Observable로는 초당 1000회 이하의 이벤트를 다루는데 이때 sample()이나 debounce() 같은 흐름 제어 함수를 활용하면 된다.</li>
<li>데이터 흐름이 본질적으로 동기 방식이지만, 프로젝트에서 사용하는 플랫폼이 자바 Stream API나 그에 준하는 기능을 제공하지 않을 때, Observable은 보통 Flowable과 비교했을 때 성능 오버헤드가 낮다.</li>
</ul>
<p><strong>2. Flowable을 사용해야 할 때</strong></p>
<ul>
<li>특정 방식으로 생성된 1000개 이상의 데이터를 처리하는 경우. 이때 메소드 체인에서 데이터 소스에 데이터 개수 제한을 요청해야 한다.</li>
<li>디스크에서 파일을 읽어 들일 경우, 본질적으로 블로킹 I/O 방식을 활용하고 내가 원하는 만큼 가져오는 방식(pull-based)으로 처리해야 하기 때문이다. 예를 들면, 특정 단위로 잘라 몇 행씩 가져오도록 제어할 수 있다.</li>
<li>JDBC를 활용해 데이터베이스의 쿼리 결과를 가져오는 경우, 블로킹 방식을 이용하므로 ResultSet.next()를 호출하는 방식으로 쿼리의 결과를 읽어오도록 제어할 수 있다.</li>
<li>네트워크 I/O를 실행하는 경우, 네트워크나 프로토콜을 통해 서버에서 가져오길 원하는 만큼의 데이터양을 요청할 수 있을 때이다.</li>
<li>다수의 블로킹 방식을 사용하거나 가져오는 방식(pull-based)의 데이터 소스가 미래에는 논 블로킹 방식의 리액티브 API나 드라이버를 제공할 수도 있는 경우다.</li>
</ul>
<p>디스크에서 파일 읽기, JDBC를 활용한 데이터베이스 쿼리하기, 네트워크 I/O 등은 차가운 Observable(구독자가 구독하면 데이터의 처음부터 모두 발행하는 Observable)에 해당한다. 이는 결과 데이터를 처리할 수 있는만큼 조금씩 가져오는 것이 아니라 한 번에 모두 가져온다. 따라서 이 경우에는 반드시 Flowable을 활용해야 하는 것은 아니다.</p>
<p>업스트림에서 발생하는 데이터의 속도와 다운스트림에서 처리하는 속도의 차이가 작다면 Observable을 활용해도 된다. 즉, 데이터 발행과 처리 속도가 차이나더라도 먼저 <strong>sample(), throttle(), debounce()</strong> 같은 흐름 제어 함수를 활용해 해결하는 것이 좋다. 이러한 함수로도 해결하기 어려울 때는 Flowable 클래스로 전환하면 된다.</p>
<h3 id="flowable을-활용한-배압-이슈-대응">Flowable을 활용한 배압 이슈 대응</h3>
<ul>
<li>onBackpressureBuffer() : 배압 이슈가 발생했을 때 별도의 버퍼에 저장한다. Flowable 클래스는 기본적으로 128개의 버퍼가 있다.</li>
<li>onBackpressureDrop() : 배압 이슈가 발생했을 때 해당 데이터를 무시한다.</li>
<li>onBackpressureLatest() : 처리할 수 없어서 쌓이는 데이터를 무시하면서 최신의 데이터만 유지한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowableSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        PublishSubject&lt;Integer&gt; subject = PublishSubject.create();</span><br><span class="line">        subject.observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>); <span class="comment">// 100ms 후에 데이터 처리.</span></span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, err -&gt; Log.e(err.toString()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 뜨거운 Observable 로 50,000,000개의 데이터를 연속으로 발행함.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;</span><br><span class="line">            subject.onNext(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        subject.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PublishSubject 객체를 생성한 후, 처리 결과는 계산 스케줄러로 전달한다. subscribe() 함수를 호출한 후 Subject 객체가 발행한 데이터는 100ms 후에 로그를 찍는다.</p>
<p>한편 PublishSubject 객체는 뜨거운 Observable이다. 데이터를 발행하는 속도와 데이터를 처리하는 속도의 차이가 발생했을 때 어떠한 보호 장치도 없다. 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-1 | 604 | value = 0</span><br><span class="line">RxComputationThreadPool-1 | 742 | value = 1</span><br><span class="line">RxComputationThreadPool-1 | 3172 | value = 2</span><br><span class="line">RxComputationThreadPool-1 | 5158 | value = 3</span><br><span class="line">RxComputationThreadPool-1 | 7426 | value = 4</span><br><span class="line">RxComputationThreadPool-1 | 7528 | value = 5</span><br><span class="line">RxComputationThreadPool-1 | 8017 | value = 6</span><br><span class="line">RxComputationThreadPool-1 | 8570 | value = 7</span><br><span class="line">RxComputationThreadPool-1 | 9180 | value = 8</span><br><span class="line">RxComputationThreadPool-1 | 15089 | value = 9</span><br><span class="line">RxComputationThreadPool-1 | 15675 | value = 10</span><br></pre></td></tr></table></figure>
<p>처리 결과를 보면 100ms 간격보다 상당히 느리게 데이터를 처리한다. 그리고 데이터는 반복문을 통해서 PublishSubject 객체에서 매우 빠르게 발행되는데 데이터는 겨우 10개만 처리되었다. 만약, 발행하는 데이터의 개수가 훨씬 많아지면 JVM은 곧 OOM 예외를 발생하고 실행을 중단할 것이다. <strong>이런 배압 이슈가 발생했을 때 Flowable 클래스를 활용한다.</strong></p>
<p>위와 같은 배압 이슈에 대응하기 위해서 첫 번째 방법은 사용해보자.</p>
<ul>
<li>버퍼 만들기</li>
<li>onBackpressureBuffer() 함수에는 다음과 같은 오버로딩이 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기본값(128)의 버퍼 개수가 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// delayError 여부를 지정할 수 있다. </span></span></span><br><span class="line"><span class="function"><span class="comment">// true : 예외가 발생했을 때 버퍼에 쌓인 데이터를 모두 처리할 때가지 예외를 던지지 않는다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// false : 예외가 발생했을 때 바로 다운스트림에 예외를 던진다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 기본값은 false다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">boolean</span> delayError)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// capacity 인자로 버퍼의 개수를 지정한다.</span></span></span><br><span class="line"><span class="function"><span class="comment">// onOverflow 인자에 버퍼가 넘쳤을 때 실행할 동작을 지정한다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">int</span> capacity, Action onOverflow)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 버퍼가 가득찼을 때 추가로 실행하는 전략을 지정할 수 있다.</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Flowable&lt;T&gt; <span class="title">onBackpressureBuffer</span><span class="params">(<span class="keyword">long</span> capacity, Action onOverflow, BackpressureOverflowStrategy overflowStrategy)</span></span></span><br></pre></td></tr></table></figure>
<p>지정할 수 있는 전략은 아래와 같다.</p>
<ul>
<li><code>ERROR</code> : MissingBackpressureException 예외를 던지고 데이터 흐름을 중단한다.</li>
<li><code>DROP_LATEST</code> : 버퍼에 쌓여있는 최근 값을 제거한다.</li>
<li><code>DROP_OLDEST</code> : 버퍼에 쌓여있는 가장 오래된 값을 제거한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureBufferSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureBuffer(<span class="number">128</span>, () -&gt; &#123;</span><br><span class="line">                &#125;, BackpressureOverflowStrategy.DROP_OLDEST)</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flowable.range() 함수를 활용해 동일한 개수의 데이터를 발행한다. 그리고 128개의 버퍼를 생성한 후 버퍼가 넘치면 버퍼의 가장 오래된 데이터를 버리도록 지정한다. 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-1 | 356 | value = 1</span><br><span class="line">RxComputationThreadPool-1 | 459 | value = 2</span><br><span class="line">RxComputationThreadPool-1 | 561 | value = 3</span><br><span class="line">RxComputationThreadPool-1 | 662 | value = 4</span><br><span class="line">RxComputationThreadPool-1 | 766 | value = 5</span><br><span class="line">RxComputationThreadPool-1 | 869 | value = 6</span><br><span class="line">RxComputationThreadPool-1 | 972 | value = 7</span><br><span class="line">RxComputationThreadPool-1 | 1072 | value = 8</span><br><span class="line">RxComputationThreadPool-1 | 1176 | value = 9</span><br><span class="line">RxComputationThreadPool-1 | 1276 | value = 10</span><br><span class="line">RxComputationThreadPool-1 | 1380 | value = 11</span><br><span class="line">RxComputationThreadPool-1 | 1485 | value = 12</span><br><span class="line">RxComputationThreadPool-1 | 1586 | value = 13</span><br><span class="line">RxComputationThreadPool-1 | 1688 | value = 14</span><br><span class="line">RxComputationThreadPool-1 | 1793 | value = 15</span><br><span class="line">RxComputationThreadPool-1 | 1895 | value = 16</span><br></pre></td></tr></table></figure>
<p>이처럼 버퍼를 활용해 데이터를 훨씬 빠르게 다운스트림으로 발행하는 것을 알 수 있다. 거의 10배의 속도이다. 발행하는 속도도 이전보다 빨라졌고 더 많은 데이터를 발행한다. 데이터의 발행 속도가 워낙 빠르기 때문에 128개의 버퍼로는 모두 대응하기 어렵다.</p>
<p>배압 이슈에 대응하는 두 번째 방법은 <code>onBackpressureDrop()</code> 함수를 활용하는 것이다. onBackpressureBuffer() 함수가 버퍼를 만들어 쌓아 두었다가 처리하는 방식이라면, onBackpressureDrop() 함수는 버퍼가 가득 찼을 때, 이후 데이터를 그냥 무시한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureDropSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureDrop()</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">... 생략</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13004</span> | value = <span class="number">124</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13105</span> | value = <span class="number">125</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13207</span> | value = <span class="number">126</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13309</span> | value = <span class="number">127</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13411</span> | value = <span class="number">128</span></span><br></pre></td></tr></table></figure>
<p>버퍼에 128개의 데이터가 가득 찼을 때, 데이터를 계산 스케줄러에서 출력하기도 전에 예제가 끝난다. 따라서 계산 스케줄러에서 데이터를 다운스트림으로 발행할 수 있도록 충분한 시간(여기서는 20초)을 기다려줘야 한다. UI 프로그래밍(안드로이드)에서는 이와 같은 기다림이 필요하지 않다.</p>
<p>기본 버퍼 개수만큼만 버퍼에 저장하고 나머지는 모두 무시했기 때문에 128개의 데이터만 출력하고 종료한다.</p>
<p>마지막 방법은 <code>onBackpressureLatest()</code> 함수를 활용하는 것이다. 위의 두 함수의 기능을 섞을 것으로 데이터가 많이 쌓이면 무시하면서 최신의 데이터 즉, 마지막 데이터를 유지하는 것이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onBackPressureLatest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        Flowable.range(<span class="number">1</span>, <span class="number">50000000</span>)</span><br><span class="line">                .onBackpressureLatest()</span><br><span class="line">                .observeOn(Schedulers.computation())</span><br><span class="line">                .subscribe(data -&gt; &#123;</span><br><span class="line">                    CommonUtils.sleep(<span class="number">100</span>);</span><br><span class="line">                    Log.it(data);</span><br><span class="line">                &#125;, error -&gt; Log.e(error.getMessage()));</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13416</span> | value = <span class="number">127</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13518</span> | value = <span class="number">128</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">13622</span> | value = <span class="number">50000000</span></span><br></pre></td></tr></table></figure>
<p>함수만 교체해주었고, 결과는 위와 같다. 버퍼가 꽉찼을 때, 데이터를 무시하면서 마지막 데이터를 다운 스트림으로 발행하는 것을 확인할 수 있다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/09/15/RxJava-Chap08/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/09/14/RxJava-Chap07-3/"
                            aria-label=": [RxJava] Chap07. 디버깅 - 흐름 제어"
                        >
                            [RxJava] Chap07. 디버깅 - 흐름 제어
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-09-14T23:23:20+09:00">
	
		    Sep 14, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="흐름-제어">흐름 제어</h1>
<ul>
<li>흐름 제어는 Observable이 데이터를 발행하는 속도와 옵저버가 데이터를 받아서 처리하는 속도 사이의 차이가 발생할 때 사용하는 함수이다.</li>
<li>RxJava는 Observable이 데이터의 흐름을 push하는 방식으로 동작하기 때문에 위의 문제에 대해서 대처할 수 있어야 한다.</li>
</ul>
<h2 id="sample">sample()</h2>
<ul>
<li>특정한 시간 동안 가장 최근에 발행한 데이터만 걸러준다. <strong>즉, 최근에 발행된 데이터만 넘겨주고 나머지는 무시한다.</strong></li>
<li>해당 시간에는 아무리 많은 데이터가 들어와도 해당 구간의 마지막 데이터만 발행하고 나머지는 무시한다.</li>
</ul>
<img src="/img/sample.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">sample</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit, <span class="keyword">boolean</span> emitLast)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>emitLast</code> 인자는 sample() 함수의 데이터 발행이 완료되지 않고 마지막에 데이터가 남아 있을 때, 해당 데이터를 발행할 것인지 결정한다. true로 설정하면 마지막 데이터를 발행한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sampleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"7"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 시간 측정용.</span></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 4개의 데이터는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">4</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 데이터는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2개의 Observable 을 결합하고 300ms 로 샘플링.</span></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, lateSource)</span><br><span class="line">                .sample(<span class="number">300L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">552</span> | value = <span class="number">7</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">849</span> | value = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>먼저, 100ms 간격으로 data 배열에 있는 데이터 4개를 발행한다. 그리고 마지막 데이터인 6을 300ms 후에 발행한다.</li>
<li>또한 내가 원하는 특정 시간 후에 발행하기 위해 concat() 함수를 호출해 2개의 데이터 흐름(Observable)을 결합했다. 이렇게 전체 데이터 흐름을 세부 데이터 흐름으로 나누면 코드의 가독성이 좋아진다.</li>
<li>sample() 함수는 300ms 간격으로 수행한다. 매 300ms 마다 가장 최근에 들어온 값만 최종적으로 발행한다.</li>
<li>처음에 데이터를 발행하기 위해 약간의 지연 시간이 있어서(100ms+a) 다이어그램을 보면 시작할 때 약간의 간격이 있음을 볼 수 있다. 다음 데이터 발행이 3XXms이기 때문에 300ms일 때는 가장 최근 데이터가 이전에 발행했던 7이 되는 것이다.(처음 기준!)</li>
<li>마지막 인자를 true로 설정하면 마지막 데이터를 발행한다. 기본값이 false이다.</li>
</ul>
<h2 id="buffer">buffer()</h2>
<ul>
<li>일정 시간 동안 데이터를 모아두었다가 한꺼번에 발행해준다.</li>
<li>따라서 넘치는 데이터 흐름을 제어할 필요가 있을 때 활용한다. 컴퓨터의 버퍼 같은 기능을 한다.</li>
</ul>
<img src="/img/buffer.png" width="500" height="200">
<ul>
<li>처음에 빨,노,초 원을 발행하면 그것을 모아서 List 객체에 전달해준다. 그 다음 다시 하늘,파,보 원이 모이면 그것을 모아서 한 번에 발행해준다. 매우 단순한 로직이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>기본적으로 스케줄러 없이 현재 스레드에서 동작하며 입력되는 값을 count에 저장된 수만큼 모아서 List<t>에 한꺼번에 발행한다.</t></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;List&lt;T&gt;&gt; buffer(<span class="keyword">int</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bufferSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lataSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Observable&lt;List&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lataSource)</span><br><span class="line">                .buffer(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>buffer(3)는 데이터를 3개씩 모았다가 List<string>에 채운 후 값을 한꺼번에 발행해준다. 그래서 위의 결과를 보면 확인 가능하다.</string></li>
<li>buffer() 함수에는 모으거나(count) 무시할(skip) 데이터 개수를 입력할 수 있다.</li>
<li>skip 변수는 count보다 값이 커야 한다. count가 2이고 skip이 3이면 2개 데이터를 모으고 3번째 데이터 1개는 스킵한다.</li>
<li>코드는 위와 같으면 <code>buffer(2,3)</code>으로 호출하면 아래와 같은 결과를 얻을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">562</span> | value = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1067</span> | value = [<span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Observable에서 onNext 이벤트가 발생하면 내부 데이터는 3개가 아니라 2개 값을 모아 바로 List<string>에 채운 후 구독자에게 데이터를 발행한다.</string></li>
</ul>
<h2 id="throttlefirst-throttlelast">throttleFirst(), throttleLast()</h2>
<ul>
<li>throttle는 <strong>조절판</strong>이라는 뜻이다. 그것에 맞게 throttleFirst() 함수는 주어진 조건에서 가장 먼저 입력된 값을 발행한다. throttleLast() 함수는 주어진 조건에서 가장 마지막에 입력된 값을 발행한다.</li>
<li>throttleFirst()와 throttleLast()는 정반대의 의미가 아니다. throttleFirst() 함수는 어떤 데이터가 입력된 후 일정 시간 동안 다른 데이터가 발행되지 못하도록 방지하지만, throttleLast() 함수는 sample() 함수처럼 고정된 시간 간격안에서 마지막 데이터만 발행한다.</li>
<li><strong>throttleFirst()</strong> : sample() 함수와 비슷하지만 다르다. sample() 함수가 주어진 시간 동안 입력된 마지막 값을 발행한다면 <code>throttleFirst()</code> 함수는 <strong>어떤 데이터를 발행하면 지정된 시간 동안 다른 데이터를 발행하지 않도록 막는다.</strong></li>
<li><strong>throttleLast()</strong> : sample() 함수와 기본 개념은 동일하다. 주어진 시간 동안 입력된 값 중 마지막 값을 발행한다.</li>
</ul>
<img src="/img/throttleFirst.png" width="500" height="200">
<ul>
<li>함수 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 실행한다. 즉, 비동기로 동작하도록 설계된 함수다.</li>
<li>windowDuration는 시간 간격을 지정하며 unit은 시간의 단위다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">throttleFirst</span><span class="params">(<span class="keyword">long</span> windowDuration, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">throttleFirstSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 1개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.just(data[<span class="number">0</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 다음 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middlerSource = Observable.just(data[<span class="number">1</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 4개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">2</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a)</span><br><span class="line">                .doOnNext(Log::dt); <span class="comment">// 디버깅 정보 출력.</span></span><br><span class="line"></span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(earlySource, middlerSource, lateSource)</span><br><span class="line">                .throttleFirst(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::it);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">371</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">673</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">779</span> | debug = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">876</span> | debug = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | debug = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">975</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">4</span> | <span class="number">1077</span> | debug = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>처음 100ms가 지난 후에 1을 발행한 후, 300ms 동안 기다린 다음 2를 발행한다. 그리고 100ms 간격으로 나머지 값들을 발행한다. 마지막으로 throttleFirst() 함수를 호출해 200ms 간격으로 타임 윈도에 맨 먼저 입력된 값을 발행한다.</li>
<li>위에서는 1,2,4,6이 다운 스트림으로 발행된다.</li>
</ul>
<h2 id="window">window()</h2>
<ul>
<li>groupBy() 함수와 개념적으로 비슷하다.</li>
<li>throttleFirst()나 sample() 함수처럼 내가 처리할 수 있는 일부의 값들만 받아들일 수 있다. 흐름 제어 기능에 groupBy() 함수와 비슷한 별도의 Observable 분리 기능을 모두 갖추었다고 생각하면 된다.</li>
</ul>
<img src="/img/window.png" width="500" height="200">
<ul>
<li>count를 인자로 받는다. 예를 들어, 3을 인자로 받으면 앞으로 데이터 3개가 발행될 때마다 새로운 Observable을 생성하겠다는 뜻이다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>현재 스레드를 그대로 활용한다. 왜 그런지 window() 함수의 다른 변형을 비교하면 알 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(<span class="keyword">long</span> count)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;Observable&lt;T&gt;&gt; window(</span><br><span class="line">    <span class="keyword">long</span> timespan, <span class="keyword">long</span> timeskip, TimeUnit unit</span><br><span class="line">)&#123; </span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count만을 인자로 갖는 window() 함수는 입력된 값을 그대로 발행하기 때문에 비동기 작업이라고 보기 어렵다.</li>
<li>위의 함수 원형에는 timespan이라는 시간 동안 입력된 값 중에서 일부를 무시하는 기능을 포함한다.</li>
<li>어떤 필터링 작업을 해줘야 하기 때문에 계산 스케줄러를 활용하게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">windowSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 앞의 3개는 100ms 간격으로 발행.</span></span><br><span class="line">        Observable&lt;String&gt; earlySource = Observable.fromArray(data)</span><br><span class="line">                .take(<span class="number">3</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 가운데 1개는 300ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; middleSource = Observable.just(data[<span class="number">3</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">300L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 마지막 2개는 100ms 후에 발행.</span></span><br><span class="line">        Observable&lt;String&gt; lateSource = Observable.just(data[<span class="number">4</span>], data[<span class="number">5</span>])</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS),</span><br><span class="line">                        (a, b) -&gt; a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 데이터 3개씩 모아서 새로운 Observable 생성.</span></span><br><span class="line">        Observable&lt;Observable&lt;String&gt;&gt; source = Observable.concat(earlySource, middleSource, lateSource)</span><br><span class="line">                .window(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        source.subscribe(observable -&gt; &#123;</span><br><span class="line">            Log.dt(<span class="string">"New Observable Started!!"</span>);</span><br><span class="line">            observable.subscribe(Log::it);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">        CommonUtils.exampleComplete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">365</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">366</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">461</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | <span class="number">560</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | debug = New Observable Started!!</span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | <span class="number">861</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">963</span> | value = <span class="number">5</span></span><br><span class="line">RxComputationThreadPool-<span class="number">3</span> | <span class="number">1062</span> | value = <span class="number">6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>window() 함수의 인자로 3을 넣었다. 처음에 Observable을 생성하고 3개의 데이터를 전달받으면 새로운 Observable을 다시 생성하여 값을 발행한다.</li>
<li>1 값을 발행할 때와 4 값을 발행할 때 각각 새로운 Observable이 생성되었다.</li>
</ul>
<h2 id="debounce">debounce()</h2>
<ul>
<li>빠르게 연속 이벤트를 처리하는 흐름 제어 함수다.</li>
<li>안드로이드와 같은 UI 기반의 프로그래밍에서는 유용하게 활용할 수 있다.</li>
<li>예를 들어, 버튼을 빠르게 누르는 상황에서 마지막에 누른 이벤트만 처리해야할 때 간단하게 적용할 수 있다. RxJava를 이용하지 않는다면 마지막에 버튼을 누른 시간을 멤버 변수에 저장하고 일정 시간 동안 if문으로 예외 처리해야 하기 때문에 매우 번거롭고 실수할 가능성도 크다.</li>
</ul>
<img src="/img/debounce.png" width="500" height="200">
<ul>
<li>첫 번째 원은 지정한 시간 간격 안에 들어왔고 다른 이벤트는 없어서 그대로 발행되었다. 두 번째 원의 경우 시간 간격 안에 세 번째 원이 다시 들어왔으므로 두 번째가 아닌 세 번째 원을 발행한다. 마지막도 마찬가지다.</li>
<li>함수의 원형은 다음과 같다.
<ul>
<li>계산 스케줄러에서 동작한다.</li>
<li><strong>어떤 이벤트가 입력되고 timeout에서 지정한 시간 동안 추가 이벤트가 발생하지 않으면 마지막 이벤트를 최종적으로 발행한다.</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">debounce</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">debounceSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] data = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>&#125;;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.concat(</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">0</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">1</span>]),</span><br><span class="line">                Observable.timer(<span class="number">100L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">2</span>]),</span><br><span class="line">                Observable.timer(<span class="number">300L</span>, TimeUnit.MILLISECONDS).map(i -&gt; data[<span class="number">3</span>])</span><br><span class="line">        ).debounce(<span class="number">200L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">        CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool-<span class="number">2</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>데이터를 발행하는 부분이 특이하다. 각각의 시간 간격이 서로 다르기 때문에 concat() 함수를 활용해 각가 데이터를 발행했다.</li>
<li>timer() 함수는 이벤트를 한 번만 발생시키고 완료하기 때문에 concat()과 timer() 함수의 조합은 유용하다.</li>
<li>debounce()를 활용해 어떤 이벤트가 입력되고 지정된 timeout인 200ms 안에 더 이상의 이벤트가 없으면 마지막에 입력된 값을 발행한다.</li>
<li>여기서 이해가 잘 안되었던 부분이 있었다. 결과를 예상해봤을 때, 1,2,5라고 생각했지만 아니었다. <strong>왜냐면 정의 자체가 어떤 이벤트가 입력되고 나서 timout 내에 더 이상의 이벤트가 없으면 마지막 이벤트를 발행하는 것이다.</strong> 그러니까 어떤 이벤트가 입력되고 나서 timout 내에 이벤트가 있는지 찾는 것이다. 그래서 결과는 1,3,5가 맞다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/09/14/RxJava-Chap07-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/21/Android-network-check/"
                            aria-label=": [Android] Network State Check"
                        >
                            [Android] Network State Check
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-21T17:55:46+09:00">
	
		    Aug 21, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 개발을 하다보면 마주하는 상황이 있다. 바로 인터넷 연결 상태를 확인하는 것이다. 서버와 네트워크 통신을 진행하는 도중 네트워크 연결이 끊기면 예외 처리를 해줘야 한다. 그래야 사용자들이 앱을 사용함에 있어서 사용자 경험을 나쁘지 않게 할 수 있다.</p>
<p>그래서 구글에 검색해봤다. 역시나 개발자 문서에 나와있다.</p>
<ul>
<li><a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring?hl=ko" target="_blank" rel="noopener">Android Developer</a></li>
<li>한가지로 예로 동영상을 다운받는다고 가정해보자. 영상을 다운받는 도중에 네트워크 연결이 너무 느리거나 끊겼다면 이에 대한 알림이나 메시지를 사용자에게 보여줘야 한다. 그래서 네트워크 연결을 다시 확인하도록 권장해야 한다.</li>
<li><code>ConnectivityManager</code>를 사용하면 인터넷에 실제로 연결되어 있는지, 연결되어 있다면 어떤 유형의 연결이 설정되어 있는지를 확인할 수 있다.
<ul>
<li>여기서 어떤 유형이라 함은 WiFi인지 데이터 연결인지를 의미한다.</li>
</ul>
</li>
</ul>
<p><strong>아래 코드를 확인하자. 간단하다.</strong></p>
<p>먼저, 다음의 권한을 매니페스트 파일에 등록한다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNetworkConnected</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Boolean</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) <span class="keyword">as</span> ConnectivityManager</span><br><span class="line">    <span class="keyword">val</span> activeNetwork : NetworkInfo? = cm.activeNetworkInfo</span><br><span class="line">    <span class="keyword">val</span> isConnected = activeNetwork != <span class="literal">null</span> &amp;&amp; activeNetwork.isConnected</span><br><span class="line">    <span class="keyword">return</span> isConnected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>끝이다. 그래서 네트워크 연결이 되었는지 혹은 끊겼는지 확인이 필요한 곳에서 사용하면 된다. util로 빼서 함수로 작성해도 되고 확장 함수 개념을 사용해서 작성해도 된다.</p>
<p>주의할 점은 API Level 29부터는 deprecated되었기 때문에 다른 방법을 이용해야 한다. 필자는 API Level 28로 하였다. 29부터도 적용되는 방법은 구글에 검색해보면 나와있다.</p>
<p>추가로 네트워크의 유형이 와이파이인지 데이터인지 확인하는 방법도 있으니 사용할 때, 참고하면 된다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://developer.android.com/training/monitoring-device-state/connectivity-monitoring?hl=ko" target="_blank" rel="noopener">Android Developer</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/21/Android-network-check/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/10/2019-the-first-half-year-review/"
                            aria-label=": [회고] 2019 상반기 Review"
                        >
                            [회고] 2019 상반기 Review
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-10T21:50:07+09:00">
	
		    Aug 10, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>2019년도 상반기 회고를 하려고 생각을 했었지만, 2달이나 지났다. 그래서 이 포스팅을 작성할까 말까 고민을 했었으나 고민을 깔끔하게 날려준 결정적인 사건이 있어서 글을 쓰게되었다. 무슨 사건인지는 아래에서 확인할 수 있다.</p>
<p>이번 회고는 <a href="https://woovictory.github.io/2019/03/02/2018-Review/">2018 회고</a>와 겹치는 부분이 있어서 겹치는 내용은 간략하게 작성할 것이다.</p>
<ul>
<li><a href="#%EB%B6%80%EC%8A%A4%ED%8A%B8-%EC%BA%A0%ED%94%84">부스트 캠프</a></li>
<li><a href="#%EB%A9%B4%EC%A0%91">면접</a></li>
<li><a href="#DDD-%EB%8F%99%EC%95%84%EB%A6%AC">DDD 동아리</a></li>
<li><a href="#%EC%97%AC%ED%96%89">여행</a></li>
<li><a href="#%EC%B7%A8%EC%97%85-%EC%A4%80%EB%B9%84">취업 준비</a></li>
<li><a href="#%EC%B7%A8%EC%97%85">취업</a></li>
</ul>
<h2 id="부스트-캠프">부스트 캠프</h2>
<p>올해 초에 부스트 캠프 3기 안드로이드 과정에 참여했다. 운이 좋아 면접부터 최종합격까지 할 수 있었다. 그래서 약 한 달 간은 강남에서 출퇴근을 하며 부스트 캠프 과정을 진행했다. 개발자와 협업을 하며 좋은 경험을 쌓았고 멘토링을 받으며 현실적인 조언도 받을 수 있었다.</p>
<p>제일 중요한 건 기술적인 시야가 넓어졌다는 점이다. 패턴도 모르고 데이터 바인딩도 몰랐지만, 부스트 캠프를 통해서 알게 되었고 관심을 가지고 공부를 시작할 수 있었다.</p>
<h2 id="면접">면접</h2>
<p>위의 부스트 캠프 관련 내용은 지난번 <strong>회고 관련 포스팅</strong>과 비슷하기 때문에 대략적으로 적었다. 여기서부터는 새로운 내용일 것이다. 좋은 기회가 주어져서 부스트 캠프와 연계되어 면접을 보게 되었다.</p>
<blockquote>
<p><strong>직접적인 회사의 부서를 언급하지는 않겠다.</strong></p>
</blockquote>
<p>부스트 캠프에서의 활동을 좋게 봐주셔서 면접을 제안받았다. 그래서 면접을 준비하면서 '어떻게 준비해야 할까?'라는 생각을 했다. 필자는 프로젝트 관련 질문과 인성 질문을 준비했다. 지금와서 떠올려보니 왜 ‘인성’ 관련 준비를 했는지 의문이다.</p>
<p>아무튼, 이렇게 준비를 하고 면접을 보러 갔다. 상세한 질문 내용은 적지 않겠지만 상황을 설명하겠다. 2:1 면접이었고 분위기는 굉장히 편안했다. 면접관분들도 면접자를 많이 배려해주었다. 그래서 걱정이 사라지고 긴장도 풀렸다. 하지만, 나의 준비와는 다르게 면접이 흘러갔다.</p>
<p>전산학 기초와 관련된 질문이 대부분이었고, 프로젝트에 관련된 질문은 비중이 굉장히 적었다. 그래서 답변이 부족했고, 그에 따라 자신감도 적어지며 대답에 대한 확신이 없었다. 소위 말해서 말렸다. 면접을 보고 나서 떨어질 확률이 높았다. 그래서 기대를 하지 않았지만, 결과를 받으니 실망이 컸다.</p>
<p>나의 준비가 부족했지만, 그때는 핑계를 대고 싶었나보다. 핑계를 대면서 '준비한 부분이 나오지 않았다.'라는 식의 핑계였다. 지금와서 생각해보니 어리석은 핑계였고 그냥 부족했던 거였다. 그렇게 조금 아픈 경험을 하고 빠르게 잊었다.</p>
<p>그래도 느낀 점은 있었다. 전산학 기초가 부족했고 질문에 대한 답변을 하는 능력이 부족하다는 걸 많이 깨달았다. 부족한 부분에 대한 보강이 필요하다는 걸 절실히 느낄 수 있는 기회였다.</p>
<h2 id="ddd-동아리">DDD 동아리</h2>
<p>이전에 활동했던 동아리를 졸업?하고 다른 동아리를 할지말지 고민했다. 그러던 와중에 친구에게 <code>DDD</code>라는 동아리를 소개받고 괜찮아 보여서 지원을 했고 합격하여 활동을 시작했다.</p>
<p>먼저, 좋다고 생각했던 점은 다음과 같다.</p>
<ul>
<li>직장인이 많이 활동한다.</li>
<li>하나의 주제를 잡고 스터디를 한다.</li>
<li>활동 처음부터 팀을 정해 프로젝트를 시작해서 기간이 길다.</li>
</ul>
<p>이러한 이유 때문에 DDD 동아리가 괜찮다고 생각했다. 3월부터 시작을 했고 <strong>RxJava</strong> 책을 정해 스터디를 진행했다. 2주에 한 번씩 모여 챕터별로 맡아서 공부하고 발표를 했다. 동시에 프로젝트는 팀별로 진행을 했다. 필자는 프로젝트를 하면서 이전에는 해보지 않았던 것이나 새로운 기술을 적용하고 싶었다.</p>
<p>새로운 기술 혹은 새로운 것을 적용하는 것은 설레면서 재미있다. 하지만, 그 과정은 쉽지만은 않다. 이 프로젝트에서 필자가 하고 싶은 것은 다음과 같았다.</p>
<ul>
<li>새로운 아키텍처를 공부해서 적용하는 것 -&gt; MVVM</li>
<li>동시에 새로운 기술들을 적용해보는 것</li>
<li>유지보수가 원활하게 디자인 요소를 컴포넌트화 하는 것</li>
<li>RxJava를 적용하는 것</li>
</ul>
<p>새로운 아키텍처를 적용해봤다. 전에 MVP를 사용했지만, 이번에 새로운 패턴을 적용해보고 싶었다. 이유는 View와 Presenter가 1:1 관계를 갖는다는 점과 인터페이스의 작성이 많아진다는 게 조금은 불편했다. 그래서 MVVM을 적용하기 위해 여러 블로그와 코드를 참고하여 프로젝트에 적용을 했다.</p>
<p>처음에 이게 맞는 것인가 싶어서 다른 사람의 코드를 비교했는데, 결국 MVVM 패턴도 각자의 코딩 스타일에 따라서 조금씩은 다르다는 것을 알았다. 큰 범주는 같지만 그 안에서 어떻게 코딩하는지는 각자 다 다르다는 것을 알았다. 이를 통해서 내 코드에 대한 의심은 없어졌고 다른 사람들은 어떻게 작성했는지 보면서 깨달음도 얻고 이 과정에서 공부도 할 수 있어서 좋은 기회였다.</p>
<p>계속해서 어떻게 하면 의존성을 낮추고 유지보수하기 좋은 코드를 작성할 수 있는지 생각할 수 있는 계기가 되었고, 다른 사람의 코드를 해석하는 과정에서 공부가 되었다. :)</p>
<p>새로운 기술을 적용해보고 싶었다. 적용하기 힘들지만, 구현하고 나면 성취감과 뿌듯함이 몰려온다. 필자는 Motion Layout과 BottomNavigationView에 애니메이션을 적용했다. 먼저, 모션 레이아웃은 카카오뱅크처럼 스크롤할 때 이미지가 작아지면서 우측 상단으로 이동시키고 싶었다. 자연스러운 Transition이 필요했고 깔끔하게 코드 없이 xml로만 작성할 수 있다는 장점이 있어서 모션 레이아웃을 적용했다. 두 번째는 BottomNavigationView에 애니메이션을 적용하는 것이다. 이는 내용이 길어질 것 같아서 짧게 말하면, 하단탭을 눌렀을 때 애니메이션을 보여주는 것이다. <code>ShapeShifter</code>라는 사이트를 통해서 svg 파일로 애니메이션을 만들어서 안드로이드에 앱에 적용하면 된다.</p>
<p>이 기술들을 적용하면서 삽질도 많이 했고, 포기하려고도 해봤지만 꼭 구현하고 싶은 마음이 강했기 때문에 완성할 수 있었다. 이 과정에서 많은 공부를 할 수 있었고 새로운 기술을 적용하는 것에 대한 두려움도 없앨 수 있었다. 새로운 기술을 적용하는 것은 언제나 즐겁다. ^0^</p>
<p>디자인 요소를 컴포넌트화 하는 것은 예전부터 하고 싶었던 작업이었다. 이전에 프로젝트는 기간이 짧아서 여유롭게 회의를 해서 이런 디자인 요소를 일치시키는 작업을 한 경험이 없었다. 하지만, 이번 프로젝트는 초반에 여유가 있어서 디자이너들과 함께 디자인 요소에 관해 회의를 할 수 있었다.</p>
<p>먼저, 마진을 8의 배수로 지정해서 공통적으로 사용할 수 있게 그리드 형식으로 UI를 구성해주었다. 그래서 마진 값이 8의 배수로만 떨어졌고 일반적인 규칙이 있어서 레이아웃을 작성할 때, 편했다. 예를 들면, 타이틀은 좌우에서 24dp만큼 떨어지는 규칙이 있어서 편하게 적용할 수 있었다.</p>
<p>두번째는 style과 color이다. text나 button에 대한 스타일도 컴포넌트화 시켜서 어느 곳에서든 필요한 곳이 있으면 가져다 쓸 수 있도록 지정했다. 그래서 한 속성이 이전과는 다르면 그 속성만 수정하여 재사용이 원활했다.</p>
<p>덕분에 레이아웃을 작성할 때, 재사용이 용이했으며 유지보수도 원활하게 할 수 있어서 뜻깊은 프로젝트가 되었다. 나중에는 가이드를 정해서 가이드에 맞게 디자인 요소를 컴포넌트화 해야겠다.</p>
<p>안드로이드 직군이 RxJava를 함께 공부해서 프로젝트에 부분적으로 적용하는 것은 그리 어렵지 않았다. 연산자도 그 역할을 알고 사용했기 때문에 재미있었다. 하지만, 활용하는 것은 조금 쉽지 않았다. 아무래도 공부가 더 필요한 것 같다.</p>
<p>DDD 동아리는 혼자서 공부하고 새로운 걸 많이 도전해볼 수 있는 좋은 기회가 되었던 것 같다.</p>
<h2 id="여행">여행</h2>
<p>취업 준비도 하면서 동아리 프로젝트를 진행하니 생각보다 바빴다. 그래서 쉬지 못하고 계속 공부와 프로젝트를 병행했다. 더운 여름을 맞이하기 전에 시원한 곳으로 떠나고 싶었다. 그래서 <strong>블라디보스토크</strong>로 떠나기로 했다.</p>
<p>생각보다 추웠다. 그래도 굉장히 재미있게 잘 다녀왔다. 가보고 싶은 곳도 거의 다 방문했고 마지막 날에는 아쿠아리움에 가서 돌고래쇼도 볼 수 있어서 너무 좋았다. 첫 해외 여행이었지만, 돈을 모아서 다른 곳도 여행하고 싶은 마음이 잔뜩 생겼다.</p>
<p>재미있고 행복한 힐링 여행이었다.</p>
<h2 id="취업-준비">취업 준비</h2>
<p>동아리 활동이 끝났다. 이제 본격적인 취업 준비에 들어가기로 했다. 함께 동아리에서 진행했던 프로젝트를 완전 마무리 짓고 스토어에 올릴 계획을 세웠다. 이유는 처음에 프로젝트를 시작할 때 목표 중 하나가 스토어에 올리는 것이었기 때문이다. 하지만, 아직 서버와 관련해서 통신하는 과정에 매끄럽지 못한 부분이 있어서 이 부분을 수정해야 한다. 수정해야 한다는 생각만을 가지고 각자 다들 바쁘게 지내면서 시간이 흘러갔다.</p>
<p>필자는 취업 준비를 하면서 알고리즘 공부를 꾸준하게 했고, 전산학 관련 공부도 했다. 동시에 프로젝트에서 사용한 기술과 적용한 패턴, 그리고 시행착오도 정리를 했다. 그러다 이전 동아리의 행사에서 리쿠르팅 관련 발표를 하시는 것을 봤고 채용 공고를 접하게 되었다.</p>
<p>스타트업에 지원해보고 싶었다. 왜냐하면 빠르게 성장할 수 있을 것 같았다. 치열하겠지만, 시간이 지나 돌아봤을 때 확실히 달라진 모습일 것 같았다. 사실, 내가 하기 나름이겠지만 열심히 한다면 큰 성장을 경험할 수 있을 것 같았다.</p>
<p>그래서 더는 고민하지 않고 지원했다. 서류로 지원서와 포트폴리오를 제출했다. 몇일 뒤에 연락이 왔고 서류 합격과 함께 간단한 코딩 테스트를 본다고 했다. 그래서 구현 문제 위주로 풀었다. 2문제가 나왔고 어려운 난이도는 아니었지만, 애매한 부분이 있었다. 문제를 풀고 제출을 했다. 이후에 복기를 하면서 다시 풀어봤는데, 접근 방법이 조금 틀렸다는 것을 알게 되었다.</p>
<p>그래도 떨어지는 것보다는 붙는다는 것을 생각하여 1차 면접 준비를 조금씩 했다. 문제를 다시 풀어보고 기술적인 부분들을 준비했다. 준비한게 기특해서였는지 좋은 기회를 주셨다.(아마 신이 주신게 분명하다.) 1차 면접을 보러 오라는 제안 메일을 받았다.</p>
<p>면접 준비를 하면서 계속 이야기하는 연습을 했다. 면접관과 이야기하는 것이기 때문에 모르더라도 이야기할 수 있도록 노력했다. 그리고 대망의 면접!! 기술적인 부분과 필자가 진행한 프로젝트에 관한 내용이 주였다. 아는 내용은 최대한 설명하려고 노력했고, 모르는 부분은 생각해 본 다음 떠오르면 대답했고 그렇지 않은 경우 모르겠다고 당당하게 말했다.</p>
<p>면접 시간은 꽤 길었다. 기억은 잘 나지 않는다. 면접이 끝나고 집에 가려 했는데, 퇴근 시간과 겹쳐서 근처 카페로 가서 면접 봤던 내용을 정리했다. 기억이 잘 안나는데 최대한 생각해보고 정리를 했다. 정리를 하는 이유는 필자가 어떤 질문에 대답을 못했는지를 파악하기 위함이고 혹시나 떨어진다면 다음에 다른 곳 면접 볼 때, 도움이 되지 않을까 하기 때문이다.</p>
<p>집에 와서 씻고 꿀잠을 잤다. 거의 9시간 정도 숙면을 취했다. 긴장을 많이 해서 그런듯 싶다. 하루는 그냥 휴식을 취했다. 힘이 안났다. 그리고 몇일 지나서 2차 면접 제안 메일을 받았다. 좋은 기회를 또 받을 수 있어서 행복했다. 2차 면접은 임원 면접이라고 채용 공고에서 본 적이 있었다. 그래서 기술적인 질문이 아닌 인성 질문에 대해서 준비를 했고, 자기 소개와 지원 동기 등등을 준비했다.</p>
<p>2차 면접을 봤다. 1차 면접보다는 시간이 짧았지만 제대로 된 답변을 하지 못한 것이 많았다. 많이 당황했고, 쉽지 않았던 면접이었다고 생각한다. 그래서 끝나고 집에 돌아오는 길에 '아, 느낌이 좋지 않다.'라고 생각을 하며 힘 없이 돌아왔다. 1차 면접때와 비슷하게 긴장을 많이해서 힘이 없었다. 그래서 이날도 아마 9시간 꿀잠을 잤다. ㅎㅎ 그리고 결과가 나오기까지 휴식을 취하면서 알고리즘만 조금씩 풀었다.</p>
<p>그리고 몇일이 지나서 합격했다는 메일을 받았다. 드디어 합격하게 되었다. 입사일까지 몇일이 남아서 가족들과 시간을 보내고 친구들도 만나고 못한 업무 같은 것들을 처리하면서 쉬려고 한다.</p>
<h2 id="취업">취업</h2>
<p>학생의 신분은 끝이 났지만, 이제 직장인 즉 개발자의 신분으로는 새로운 시작이다. 그러니 끝났다는 것에 안주하지 말고 잘 쉬다가 다시 버닝을 해야 한다. 잘 쉬다가 출근하면서 열심히 하자~</p>
<p><strong>그동안 수고했다. 앞으로 더 수고하자~</strong></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/10/2019-the-first-half-year-review/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/08/Kotlin-Double-Ref/"
                            aria-label=": [Kotlin] 더블콜론(::) 참조"
                        >
                            [Kotlin] 더블콜론(::) 참조
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-08T16:03:39+09:00">
	
		    Aug 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에서 사용하는 더블콜론 참조에 대해서 알아보려고 한다.</p>
<h2 id="리플렉션reflection이란">리플렉션(Reflection)이란</h2>
<p>코틀린에서 더블콜론(::)은 리플렉션을 위해 사용한다. 리플렉션이란 코드를 작성하는 시점에는 런타임상 컴파일된 바이트 코드에서 내가 작성한 코드가 어디에 위치하는지 알 수 없기 때문에 바이트 코드를 이용해 내가 참조하려는 값을 찾기위해 사용한다.</p>
<h2 id="자바와-코틀린에서의-리플렉션">자바와 코틀린에서의 리플렉션</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass.class -&gt; 클래스 그 자체를 리플렉션</span><br><span class="line">someInstance.getClass() -&gt; 인스턴스에서 클래스를 리플렉션</span><br></pre></td></tr></table></figure>
<ul>
<li>자바에서는 클래스를 참조할 때 위와 같이 사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SomeClass::class</span><br><span class="line">someInstance::class</span><br></pre></td></tr></table></figure>
<ul>
<li>코틀린에서는 더블콜론을 리플렉션을 위해 사용하며 위와 같은 형태로 사용한다.</li>
</ul>
<p>하지만 우리가 액티비티를 넘길 때는 <code>SomeClass::class.java</code>와 같이 끝에 <strong>.java</strong>가 붙는 것을 볼 수 있다. 그 이유는 자바에서 쓰는 클래스와 코틀린에서 쓰는 클래스가 다르기 때문이다.</p>
<p>자바에서의 <code>SomeClass.class</code>는 Class를 리턴한다. 반면, 코틀린에서는 <code>SomeClass::class</code>를 하면 <strong>KClass</strong>를 리턴한다. 그렇기 때문에 KClass를 Class로 바꾸어 주어야하는데 이때 .Java를 이용하여 자바 클래스 값을 받는다.</p>
<img src="/img/kclass.png" width="700" height="300">
<p>KClass 안의 java의 getter는 위 그림과 같이 확장함수 형태로 되어있으며 KClass에서 자바의 클래스 타입을 반환한다.</p>
<h2 id="코틀린에서의-함수참조">코틀린에서의 함수참조</h2>
<p>코틀린에서 SomeClass::class와 같이 클래스를 참조할 수도 있지만 SomeClass:Method와 같이 클래스 내의 메소드도 참조할 수 있고 ::Function 형식의 함수도 참조할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    numbers.filter(::isOdd)</span><br><span class="line">            .forEach &#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isOdd</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 단축형</span></span><br><span class="line"><span class="comment">//fun isOdd(x: Int) = x % 2 !=0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>isOdd() 함수를 filter를 사용한 코드이다. filter를 사용하면서 함수참조를 이용해 <code>::isOdd</code> 형태로 함수를 호출하였다.</li>
<li>필터의 원형은 IntArray에서 Int 값을 받아 Boolean을 반환하는 inline 함수이다. 마찬가지로 Int를 받아 Boolean을 반환하기 때문에 함수를 참조하여 동일한 형식의 isOdd를 사용할 수 있다.</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%EB%8D%94%EB%B8%94%EC%BD%9C%EB%A1%A0-%EC%B0%B8%EC%A1%B0-73ff25484586" target="_blank" rel="noopener">코틀린의 더블콜론(::) 참조</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/08/Kotlin-Double-Ref/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/08/Kotlin-isXXX-funcion-diff/"
                            aria-label=": [Kotlin] ixXXX() 함수들"
                        >
                            [Kotlin] ixXXX() 함수들
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-08T14:11:00+09:00">
	
		    Aug 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에서 제공되는 <strong>isEmpty, isNotEmpty, isBlank, isNotBlank, isNullOrBlank, isNullOrEmpty</strong> 함수의 차이점을 알아보려고 한다.</p>
<p>비교를 위해 사용할 문자열은 다음과 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> emptyString = <span class="string">""</span></span><br><span class="line"><span class="keyword">val</span> blankString = <span class="string">" "</span></span><br><span class="line"><span class="keyword">val</span> blankNewLineString = <span class="string">" \n"</span></span><br><span class="line"><span class="keyword">val</span> withBlankString = <span class="string">" victory"</span></span><br><span class="line"><span class="keyword">val</span> nullString: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> standardString = <span class="string">"standard"</span></span><br></pre></td></tr></table></figure>
<h2 id="isempty">isEmpty</h2>
<ul>
<li>CharSequence가 아무 값도 포함하고 있지 않을 때, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isEmpty())</span><br><span class="line">    println(blankString.isEmpty())</span><br><span class="line">    println(blankNewLineString.isEmpty())</span><br><span class="line">    println(withBlankString.isEmpty())</span><br><span class="line">    println(nullString?.isEmpty())</span><br><span class="line">    println(standardString.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotempty">isNotEmpty</h2>
<ul>
<li>CharSequence가 어떠한 값을 포함하고 있을 때(공백 포함), true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotEmpty())</span><br><span class="line">    println(blankString.isNotEmpty())</span><br><span class="line">    println(blankNewLineString.isNotEmpty())</span><br><span class="line">    println(withBlankString.isNotEmpty())</span><br><span class="line">    println(nullString?.isNotEmpty())</span><br><span class="line">    println(standardString.isNotEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isblank">isBlank</h2>
<ul>
<li>CharSequence가 공백만을 가지고 있을 경우나 empty일 경우, true를 반환한다.</li>
<li>결과는 다음과 같다.</li>
<li>공백+개행문자 -&gt; 공백으로 판단한다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isBlank())</span><br><span class="line">    println(blankString.isBlank())</span><br><span class="line">    println(blankNewLineString.isBlank())</span><br><span class="line">    println(withBlankString.isBlank())</span><br><span class="line">    println(nullString?.isBlank())</span><br><span class="line">    println(standardString.isBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnotblank">isNotBlank</h2>
<ul>
<li>CharSequence가 empty 상황이 아니고, 값에 공백만 있지 않을 때 true를 반환한다.</li>
<li>즉, 아무 값도 없거나 공백만 있을 때는 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNotBlank())</span><br><span class="line">    println(blankString.isNotBlank())</span><br><span class="line">    println(blankNewLineString.isNotBlank())</span><br><span class="line">    println(withBlankString.isNotBlank())</span><br><span class="line">    println(nullString?.isNotBlank())</span><br><span class="line">    println(standardString.isNotBlank())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorempty">isNullOrEmpty</h2>
<ul>
<li>CharSequence가 비어있거나 null일 경우, true를 반환한다.</li>
<li>공백은 비어있는게 아니다. 그래서 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    println(emptyString.isNullOrEmpty())</span><br><span class="line">    println(blankString.isNullOrEmpty())</span><br><span class="line">    println(blankNewLineString.isNullOrEmpty())</span><br><span class="line">    println(withBlankString.isNullOrEmpty())</span><br><span class="line">    println(nullString.isNullOrEmpty())</span><br><span class="line">    println(standardString.isNullOrEmpty())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="isnullorblank">isNullOrBlank</h2>
<ul>
<li>CharSequence가 null이거나 blank인 상황일 때, true를 반환한다.</li>
<li>공백+개행 -&gt; 비어있음(blank 상태)</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="summary">Summary</h2>
<p>어려운 내용은 아니지만, 헷갈리는 함수들이다. 그래서 사용할 때 자주 헷갈려서 정리를 했다. 주의해야 할 점은 다음과 같다.</p>
<ul>
<li>empty : 정말 아무 값도 가지지 않는 것을 말한다.
<ul>
<li>blank보다 empty가 작은 개념.</li>
</ul>
</li>
<li>blank : 공백만 있거나 정말 아무 값도 가지지 않는 것을 의미한다.
<ul>
<li>공백+개행문자도 공백으로 판단</li>
<li>blank가 더 큰 개념.</li>
</ul>
</li>
</ul>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://thecommelier.tistory.com/16?category=718833#recentEntries" target="_blank" rel="noopener">[Android/Kotlin] isNotEmpty(), isNotBlank(), isNullOrEmpty(), isNullOrBlank() 차이점</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/08/Kotlin-isXXX-funcion-diff/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/04/Kotlin-inline/"
                            aria-label=": [Kotlin] inline, infix"
                        >
                            [Kotlin] inline, infix
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-04T14:59:31+09:00">
	
		    Aug 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>커니의 코틀린이라는 책을 참고하여 코틀린을 공부했다. inline이라는 개념이 나왔지만 간단하게만 설명이 되어있었고, 필자도 간단하게만 정리하고 넘어갔다. 그런데 다시 보니 무슨 개념인지 모르겠어서 정리하려고 한다.</p>
<h2 id="overview">OverView</h2>
<p>문서는 다음과 같이 설명되어있다.</p>
<blockquote>
<p>고차 함수를 사용하면 런타임 패널티가 있기 때문에 함수 구현 자체를 코드 내부에 넣음으로써 오버헤드를 없앨 수 있다.</p>
</blockquote>
<p>무슨 내용인지 잘 와닿지 않는다. 다음의 글을 보고 다시 생각해보자.</p>
<p><strong>일급 함수</strong></p>
<ul>
<li><strong>일급 함수</strong>는 스스로 객체로써 취급되는 함수로 다른 함수를 파라미터로 전달받고 반환할 수 있는 함수를 뜻한다.</li>
<li>코드를 통해서 확인해보자.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&#123;a,b -&gt; a&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>위 함수는 두 개의 정수를 받아 하나의 정수값만을 출력하는 함수이다.</li>
<li>위와 같은 선언을 하게 된다면 Java에서 아래와 같은 코드로 변화을 하여 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(@NotNull Fuction2 body)</span></span>&#123;</span><br><span class="line">    Intrinsics.checkParameterIsNotNull(body, <span class="string">"body"</span>);</span><br><span class="line">    Object result = body.invoke(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 자동으로 컨버팅이 될 수 있기 때문에 아래와 같은 유동적인 방법도 사용이 가능하다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">printResult</span><span class="params">(body: (<span class="type">Int</span>, <span class="built_in">Int</span>)</span></span> -&gt; <span class="built_in">Int</span>)&#123;</span><br><span class="line">    println(body(<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">subtract</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a - b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    printResult(::sum)</span><br><span class="line">    printResult(::subtract)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드처럼 sum이나 subtract를 유동적으로 붙일 수 있다.</li>
</ul>
<h2 id="inline">inline</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        print(<span class="string">"문자열 출력!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드를 자바로 표현하면 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Function body)</span></span>&#123;</span><br><span class="line">    body.invoke();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(System.out.println(<span class="string">"문자열 출력!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드와 같이 자바로 표현된다. 그리고 이 자바코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething(<span class="keyword">new</span> Function()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>문제는 위의 sum이나 subtract처럼 조합하는 함수가 많아질수록 계속 N개만큼의 function 오브젝트가 생성된다. 이럴때 사용하게 되는 것이 <code>inline</code> 키워드이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">(body: ()</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    body()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    doSomething&#123;</span><br><span class="line">        println(<span class="string">"문자열 출력"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드는 아래와 같이 변환된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"문자열 출력!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>그리고 실제로 컴파일 시 doSomething()의 body()를 호출하는 부분에 저렇게 선언된 함수가 그대로 들어가게 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// body() 부분에 그대로 들어온다.</span></span><br><span class="line">System.out.println(<span class="string">"문자열 출력!"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같이 Fuction 인스턴스를 만들지 않고 callFunction 내부에 삽입되어 바로 선언되어지게 된다. 때문에 람다함수와 1급 함수가 호출된 곳에서 해당 함수를 가지게 된다.</li>
<li>하지만 inline 함수는 주의할 점이 있는데, <code>private</code> 키워드를 사용하여 함수를 정의할 수 없다. 대신 다른 접근 한정자인 <code>internal</code>을 사용해야 한다.</li>
</ul>
<h2 id="noinline">noinline</h2>
<ul>
<li>모든 람다함수에 inline을 쓰고싶지 않을 수 있다. 이 경우 아래와 같이 해당 람다 함수에 noinline 키워드를 추가해준다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">callLambda</span><span class="params">(aLambda: ()</span></span> -&gt; <span class="built_in">Unit</span>, <span class="keyword">noinline</span> dontInlineLambda: () -&gt; <span class="built_in">Unit</span>,</span><br><span class="line">    aLambda2: () -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">    <span class="comment">// 실행.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>모든 함수를 <strong>inline</strong>을 사용하여 내부로 컨버팅 되어지길 원치않을 수 있다. 이 경우 위처럼 <strong>inline</strong>을 먼저 선언한 뒤 람다함수 중 사용하지 않을 함수에 <code>noinline</code> 키워드를 붙여준다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/harrythegreat/kotlin-inline-noinline-%ED%95%9C%EB%B2%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1d54ff34151c" target="_blank" rel="noopener">[kotlin] inline, noinline 한번에 이해하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/04/Kotlin-inline/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/03/AsyncTask/"
                            aria-label=": [Android] AsyncTask"
                        >
                            [Android] AsyncTask
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-03T21:01:12+09:00">
	
		    Aug 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="overview">OverView</h2>
<p>안드로이드에서는 기본적으로 메인 스레드를 갖는다. 이를 <strong>UI 스레드</strong>라고 부르기도 하는데, UI 관련 작업을 해당 스레드에서만 작업하도록 제한하기 때문에 이렇게 부른다.</p>
<p>UI 스레드에서는 UI 관련 작업만 한다고 했는데, 그렇다면 파일을 다운로드 받거나 네트워크를 통해 데이터를 받아오는 입출력 작업 등의 시간이 오래 걸리는 작업을 하면 앱의 반응성이 낮아지고 안드로이드 시스템은 사용자의 사용성을 위해 <code>ANR(Application Not Responding)</code>을 발생시키게 된다.</p>
<p>이 문제를 해결하기 위해 안드로이드에서는 Handler, AsyncTask 등의 방법을 제공한다. 이번 포스팅에서 알아볼 친구는 <strong>AsyncTask</strong>이다. 그 중에서도 문제점과 유의사항이다. 사실 인터넷에 많은 사용법과 개념이 있으니 여기서는 다루지 않겠다.</p>
<h2 id="asynctask">AsyncTask</h2>
<p><strong>Google</strong>은 <code>AsyncTask</code>를 사용할 때, '수 초 내의 동작에만 사용’하는 것을 권장하고 있다. 그 이상의 작업을 하고 싶을 때는 별도의 스레드를 생성해 직접 구현하는 것을 권장한다. 그 <strong>이유는 AsyncTask가 액티비티에 종속되지 않기 때문이다.</strong></p>
<p><code>1. AysncTask 사용 규칙</code></p>
<ul>
<li>AsyncTask는 일회용 클래스이다. 두 번 이상 사용하면 안된다. 두 번째 execute() 호출시 오류가 발생한다.</li>
<li>AsyncTask 객체는 메인스레드에서 생성되어야 하고 실행되어야 한다.</li>
<li>AsyncTask의 콜백 메소드인 onPreExecute(), doInBackground(), onProgress() 등을 수동으로 호출하면 오류가 발생한다.</li>
</ul>
<p><code>2. AsyncTask가 액티비티에 종속되지 않아 생길 수 있는 문제</code></p>
<p>AsyncTask는 액티비티에 포함되지 않는다. 그래서 doInBackground()가 수행되고 있는 동안에 액티비티가 종료되면 수행되던 AsyncTask는 다음과 같은 2가지 문제가 발생할 수 있다.</p>
<ul>
<li><strong>액티비티 종료 시의 문제점</strong>
<ul>
<li>AsyncTask를 execute() 하고 doInBackground()가 수행되고 있는 동안에 액티비티가 먼저 종료되면 AsyncTask와 액티비티는 독립적인 존재이므로 AsyncTask가 종료되지 않는다. 액티비티가 종료되더라도 doInBackground()의 수행이 끝날 때까지 AsyncTask는 실행 중 상태를 유지하게 된다.</li>
<li>doInBackground() 수행 완료 후에 AsyncTask의 생명주기 상 onCancelled()나 onPostExecute() 메소드가 호출된다. 이때 존재하지 않은 액티비티의 UI에 접근을 한다면 메모리 누수(Memory Leak)이 발생하고 <code>IllegalArgumentException</code> 에러가 발생할 수 있다.</li>
</ul>
</li>
</ul>
<p>그래서 다음처럼 액티비티가 종료될 때, AsyncTask의 cancel() 메소드를 호출해 오류를 방지해야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    task.cancel(<span class="literal">true</span>)        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>디바이스의 화면 회전시의 문제점</strong>
<ul>
<li>액티비티 종료시의 문제점 사례와 같은 상황이다. 액티비티는 디바이스의 화면을 회전시키면 액티비티가 종료되고 새로운 액티비티가 생성된다. 그렇게 되면 액티비티의 모든 변수가 초기화되고 회전 전에 실행했던 AsyncTask는 계속 백그라운드에서 수행이 되고 doInBackground()가 종료되고 난 뒤에 UI 객체에 접근을 하면 메모리 누수와 스레드 <code>IllegalArgumentException</code> 에러가 발생할 수 있다.</li>
</ul>
</li>
</ul>
<p><code>3. AsyncTask를 취소하는 방법</code></p>
<p>AsyncTask는 수행 중에 cancel()을 호출하여 취소할 수 있다. cancel()이 한 번이라도 호출되면 isCancelled() 메소드는 true를 반환한다. 하지만 주의해야 할 것은 cancel()을 호출했다고 doInBackground()의 실행이 취소되는 것은 아니라는 점이다.</p>
<p>액티비티 종료나 화면이 회전되는 상황이 발생했을 때 cancel()을 호출하더라도 남아있는 작업은 계속 돌게 되어 원치 않은 상황이 될 수 있다. 그래서 작업 취소 요청에 바로 반응하기 위해서 doInBackground() 메소드에서 주기적으로 isCancelled()의 반환값을 확인하여 적절한 조치를 취해야 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://blog.naver.com/PostView.nhn?blogId=ironlove77&amp;logNo=221003037545" target="_blank" rel="noopener">안드로이드 | 스레드 | AsyncTask의 문제점과 유의사항</a></li>
<li><a href="https://webnautes.tistory.com/1082" target="_blank" rel="noopener">안드로이드 개념 및 예제 - AsyncTask</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/03/AsyncTask/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/31/RxJava-Chap01-Introduce/"
                            aria-label=": [RxJava] Chap01 리액티브 소개"
                        >
                            [RxJava] Chap01 리액티브 소개
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-31T13:38:38+09:00">
	
		    Jul 31, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>해당 포스팅 글이 로컬에서만 보이는 문제로 인하여 재업로드한 글입니다.</p>
</blockquote>
<p>RxJava와 관련된 내용은 <a href="http://www.yes24.com/Product/goods/45506284" target="_blank" rel="noopener">RxJava 프로그래밍</a> 책을 구매하여 공부하면서 참고하였습니다. 앞으로 작성하는 RxJava 글은 위의 책으로 공부하면서 정리한 내용입니다. 문제가 된다면 해당 게시글을 삭제하도록 하겠습니다. 아래 글은 제가 책을 보고 공부한 내용과 참고한 내용으로 작성되었으므로 정확하지 않을 수 있으니 깃헙에 있는 이메일로 연락주시면 감사하겠습니다.</p>
<ul>
<li><a href="#%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">리액티브 프로그래밍</a></li>
</ul>
<h2 id="리액티브-프로그래밍">리액티브 프로그래밍</h2>
<p>리액티브 프로그래밍(Reative Programming)은 반응형 프로그래밍이라고도 한다. <strong>데이터 의 흐름과 전달에 관한 프로그래밍 패러다임</strong>이다. 기존의 명령형 프로그래밍은 주로 컴퓨터 하드웨어를 대상으로 프로그래머가 작성한 코드가 정해진 절차에 따라 순서대로 실행된다. <strong>리액티브 프로그래밍</strong>은 데이터 흐름을 먼저 정의하고 데이터가 변경되었을 때 연관되는 수식이나 함수가 업데이트되는 방식이다.</p>
<p>가장 쉽게 이해할 수 있는 예는 MS의 엑셀(즉, 스프레드 시트)이다. 엑셀에서 값을 변경했을 때 자동으로 반영되는 것이 이러한 예를 설명한다.</p>
<ul>
<li>기존의 명령형 프로그래밍 &lt;–&gt; 반응형 프로그래밍(즉, 리액티브 프로그래밍)</li>
<li><code>명령형 프로그래밍</code> 방식은 변경이 발생했다는 통지를 받아서 연말 매출액을 새로 계산하는 당겨오는(<strong>pull</strong>) 방식이지만, <code>리액티브 프로그래밍</code>은 데이터 소스가 변경된 데이터를 밀어주는(<strong>push</strong> 방식이다. 일종의 옵저버 패턴이라고 생각하면 된다.</li>
<li>명령형 프로그래밍의 반대말은 선언형 프로그래밍이라고도 한다.
<ul>
<li>ex) SQL.</li>
<li>반응형 프로그래밍은 선언형 프로그래밍을 지향한다.</li>
</ul>
</li>
</ul>
<h2 id="자바언어와-리액티브-프로그래밍">자바언어와 리액티브 프로그래밍</h2>
<ul>
<li>기존의 pull 방식의 프로그래밍 개념 -&gt; push 방식의 프로그래밍 개념으로 바뀜.</li>
<li><code>함수형 프로그래밍</code>의 지원을 받는다.</li>
</ul>
<p><strong>리액티브 프로그래밍</strong>에서는 데이터의 변화가 발생했을 때 변경이 발생한 곳(데이터 소스)에서 새로운 데이터를 보내(push 방식) 준다. 기존 자바 프로그래밍이 pull 방식이라면 리액티브 프로그래밍은 push 방식이다.</p>
<p>한편 우리가 아는 콜백이나 옵저버 패턴을 넘어서 RxJava 기반의 리액티브 프로그래밍이 되려면 <strong>함수형 프로그래밍</strong>이 필요하다. 콜백이나 옵저버 패턴은 옵저버가 1개이거나 단일 스레드 환경에서는 문제가 없지만, 멀티 스레드 환경에서는 사용시 많은 주의가 필요하다.<br>
대표적인 예가 <strong>데드락</strong>과 <strong>동기화</strong>문제이다.</p>
<p>추가적으로 <strong>함수형 프로그래밍은 부수 효과(side effect)가 없다.</strong> 부수 효과란 콜백이나 옵저버 패턴이 스레드에 안전하지 않은 이유가 같은 자원에 여러 스레드가 경쟁 조건(race condition)에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오는 것을 말한다. 한 두개의 스레드가 있을 때는 잘 동작하다가 수십, 수백개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이게 되고 디버깅도 어려워진다.</p>
<p>함수형 프로그래밍은 부수 효과가 없는 순수 함수(pure function)를 지향한다. 따라서 멀티 스레드 환경에서도 안전하다. 자바를 사용해 리액티브 프로그래밍을 하기 위해서는 <strong>함수형 프로그래밍의 도움이 필요하다.</strong></p>
<blockquote>
<p>그럼 여기서 말하는 함수형 프로그래밍은 무엇을 말하는 걸까?</p>
</blockquote>
<p>간략하게 말하면 함수형 프로그래밍 언어는 함수를 단지 호출하는 대상이 아닌 변수로도 할 수 있고 인자로도 넘길 수 있고 마음대로 지지고 볶고? 할 수 있다. (아직 개념이 정확히 잡히지 않아서. . ㅜㅜ) 어려운 말로는 일급 시민이라고 표현한다고 한다.</p>
<p>반응형 프로그래밍은 이런 함수형 언어의 도구들을 자유자재로 활용해야 한다. 예를 들어 Java 8에 도입된 람다 표현식은 반드시 알아야 한다.</p>
<h2 id="리액티브-프로그래밍-개념-다시-잡아보자">리액티브 프로그래밍 개념 다시 잡아보자.</h2>
<p>RxJava를 비롯해서 리액티브 프로그래밍을 공부하다 보면 새로 등장하는 개념으로 인해 많은 혼란을 겪는다고 한다. 일단, 프로그래밍 스타일이 너무 다르다. 자바는 객체 지향 언어인데 리액티브 프로그래밍은 뭔가 좀 다른 것 같다. 그리고 내가 문제를 바라보는 개념도 이전과는 달라야 하는 것 같다. 이 부분은 아직 감이 안잡히지만 천천히 잡아보도록 하겠다.</p>
<p>아무튼 어렵고 새로운 개념은 초반에 잘 잡아놓으면 나중에 공부할 때 도움이 많이 되기 때문에 여기서 잘 잡아서 앞으로 나아가자. 다음은 위키 백과에 나와 있는 설명 중 일부분이다.</p>
<blockquote>
<p>위키 백과의 일부</p>
</blockquote>
<ul>
<li>상호 작용 프로그램은 <strong>프로그램이 주도하는 속도</strong>로 사용자 혹은 다른 프로그램과 상호작용 한다.</li>
<li>사용자의 관점으로 볼 때 시분할 시스템은 상호작용 프로그램이다.</li>
<li><strong>리액티브 프로그래밍</strong>은 주변의 환경과 끊임없이 상호작용을 하는데 <code>프로그램이 주도하는 것이 아니라 환경이 변하면 이벤트를 받아 동작한다.</code></li>
<li>상호작용 프로그램은 자신의 속도에 맞춰 일하고 대부분 통신을 담당하는 반면 리액티브 프로그램은 외부 요구에 반응에 맞춰 일하고 대부분 정확한 인터럽트 처리를 담당한다.</li>
</ul>
<p>자바에서는 이런 RxJava와 같은 리액티브 프로그래밍을 하기 위해서 기반이 마련되야 한다. 즉, 데이터 소스를 정의할 수 있고 그것의 변경 사항을 받아서 내 프로그램에 알려줄 존재(<strong>push</strong>)가 필요하다. 이를 <strong>RxJava 라이브러리</strong>를 통해서 구현할 수 있다.</p>
<h2 id="rxjava를-만든-이유가-뭘까">RxJava를 만든 이유가 뭘까??</h2>
<p>RxJava는 지금 우리가 아주 아주 잘 사용하는 [넷플릭스](<a href="https://www.netflix.com/kr/" target="_blank" rel="noopener">https://www.netflix.com/kr/</a>)의 기술 블로그에서 처음 소개되었다. 성능 개선을 위해서 넷플릭스는 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅(??)하여 RxJava를 만들었다. 넷플릭스가 RxJava를 만든 핵심적인 이유는 아래와 같다.</p>
<ol>
<li>동시성을 적극적으로 끌어안기에 자바는 번거롭다.</li>
</ol>
<p>자바가 동시성(? 정확히 뭐지…?)을 처리하기에 번거롭기 때문에 넷플릭스는 클라이언트의 요청을 <strong>서비스 계층</strong>에서 동시성을 적극적으로 끌어안음으로 이를 해결했다. 클라이언트의 요청을 처리할 때 <strong>다수의</strong> 비동기 실행 흐름(스레드 등등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다고 한다.</p>
<ol start="2">
<li>자바의 Future를 조합하기 어렵다?!</li>
</ol>
<p>약 6년 전 (시간이 벌써 2019년이라니ㅜ.ㅜ) 내가 대학교 1학년일 때이다. 이 당시에 자바 8에서 제공하는 <strong>CompletableFuture</strong> 같은 클래스가 제공되지 않았다고 한다. 그래서 비동기 흐름을 조합할 수 있는 방법이 거의 없었고, RxJava에서는 이를 해결하려고 비동기 흐름을 조합<code>(Compose)</code>할 수 있는 방법을 제공한다.<br>
RxJava에서 조합하는 실행 단위를 <strong>리액티브 연산자</strong>(Operator)라고 한다.</p>
<ol start="3">
<li>콜백 지옥 탈출!</li>
</ol>
<p>콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황은 코드의 가독성을 떨어트린다. 또한, 문제 발생 시 디버깅을 어렵게 만든다. <strong>콜백</strong>은 비동기 방식으로 동작하는 가장 대표적인 패턴이다. 이런 지옥을 탈출하고자 RxJava에서는 콜백을 사용하지 않는 방향으로 설계하려고 했다.</p>
<h2 id="정리">정리</h2>
<p>위에서 쭉 반응형 프로그래밍(즉, 리액티브 프로그래밍)은 비동기 데이터의 흐름과 전달에 초점을 맞춘 패러다임이다. 그리고 함수형 프로그래밍 언어의 지원을 받고 이를 활용한다고 했다.</p>
<p>정리하자면 반응형 프로그래밍은 <code>함수형 프로그래밍 언어의 도구들을 가지고 데이터의 흐름을 Composable(구성 가능하게?!)하게 구현</code>하는 것이라고 할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li>
<p><a href="https://brunch.co.kr/@yudong/33" target="_blank" rel="noopener">RxJava 반응형 프로그래밍이란 무엇인가?</a></p>
</li>
<li>
<p>아래는 참고하면 좋을 자료들!</p>
<ul>
<li><a href="https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263" target="_blank" rel="noopener">함수형 프로그래밍이란 무엇인가?</a></li>
<li><a href="https://www.slideshare.net/ChiwonSong/20171104-frp-81598173" target="_blank" rel="noopener">함수형 프로그래밍</a></li>
<li><a href="https://poqw.github.io/RxJava2_1/" target="_blank" rel="noopener">RxJava에 관하여</a></li>
<li><a href="https://medium.com/@LIP/rxjava-29cfb3ceb4ca" target="_blank" rel="noopener">RxJava 기초</a></li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/31/RxJava-Chap01-Introduce/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/15/AndroidStudio-Live-Template/"
                            aria-label=": [Android] Live Template?!"
                        >
                            [Android] Live Template?!
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-15T11:24:17+09:00">
	
		    Jul 15, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>매일 아침 10시에 <code>Daily DevBlog</code>를 통해서 개발 관련 블로그 포스팅들이 메일로 온다. 이를 통해서 매일 아침 따끈따근한 소식을 볼 수 있고, 내가 관심 있어하는 주제가 있다면 얻을 수 있어서 굉장히 좋아하고 잘 사용하고 있다.</p>
<p>어쨋든, 오늘 글의 주제는 이게 아니다. 글을 보던 중 괜찮은 내용이 있어서 참고해서 작성하려고 한다. Android Studio의 <code>Live Template</code> 기능이다.</p>
<h2 id="live-template">Live Template</h2>
<p>지극히 주관적인 생각이지만, 개발자들은 귀찮은 걸 싫어하는 것 같다. 코딩을 하더라도 조금만 귀찮은 작업이라면 싫어한다. 그래서 IDE에서 제공하는 기능을 잘 사용한다면 귀찮음을 덜어줄 수 있다. 그 중에서 나는 <code>JetBrains</code>이 만든 IDE가 좋다고 생각한다. 물론, IDE에서 제공하는 기능을 잘 사용한다면 말이다.</p>
<p><strong>Live Template</strong>은 축약형 값을 입력하면 자주 쓰는 코드 구성을 불러오는 기능이다. 쉽게 말해 상용구이다. 안드로이드 스튜디오에서 기본적으로 제공하는 라이브 템플릿 중에서도 유용한 것들이 꽤 있고, 사용자가 직접 커스텀해 사용할 수도 있다.</p>
<p>하나의 예로, 우리가 자주 사용하는 반복문 중 for문을 사용한다고 가정해보자. for문의 fo만 입력해도 밑에 자동 완성으로 제공되는 모습을 볼 수 있을 것이다.</p>
<img src="/img/android_studio_exam.png" width="500" height="200">
<p>설정을 변경할 수도 있고, 사용자가 원하는 상용구를 추가할 수도 있다. <strong>환경 설정(Preferences) -&gt; Editor -&gt; Live Template</strong> 에 들어가면 템플릿을 확인할 수 있다.</p>
<h2 id="커스텀해보자">커스텀해보자.</h2>
<p>그렇다면 간단한 커스텀 템플릿을 만들어보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<p>액티비티 이동을 위해서 이렇게 두 줄을 입력하기가 귀찮을 수 있다. 물론, 함수로 빼서 사용할 수도 있지만 그 경우는 제외하고 지금 상황만 보자. 그래서 <strong>축약형</strong>을 적었을 때, 위에 정의한 두 줄이 자동 생성되도록 하고 싶다. 현재 액티비티는 자동으로 완성되고, 이동할 두 번째 클래스명만 입력하도록 할 것이다.</p>
<p><code>cis</code>를 입력했을 때 아래의 두 줄이 뜨게 할 것이다. <strong>Preferences -&gt; Editor -&gt; Live Template</strong> 창에서 우측 상단의 <code>+</code> 버튼을 눌러 새로운 Template Group을 만든다. 만든 Group을 누른 상태에서 <code>+</code> 버튼을 한 번 더 누른 뒤, <strong>Live Template</strong>을 눌러 Template Text를 입력해준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = android.content.Intent(<span class="keyword">this</span>@$first$, $second$::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<img src="/img/android_studio_exam_2.png" width="800" height="200">
<p><code>android.content.Intent</code>를 입력함으로써 자동으로 import되도록 했다.</p>
<p>먼저, 이 템플릿을 어디에서 호출하여 사용할 것인지 지정해야 한다. 하단에 보면 주의사항 <strong>No applicable contexts</strong> 옆의 Define을 눌러 kotlin 전체에 체크해준다.</p>
<p>다음으로 $first$와 $second$는 자유롭게 정할 수 있는 변수명이다. 이 변수에 대한 설정은 Template Text 코드 우측 하단에 <strong>Edit variables</strong>에서 설정할 수 있다. 누르면 Expression을 불러 사용할 수 있다.</p>
<ul>
<li>first 변수 : 미리 정의되어 있는 함수 목록에서 클래스 이름을 불러오는 <code>className()</code> 메소드를 사용한다. 오른쪽에 있는 <strong>Skip if defined</strong>에 체크하면 템플릿을 불러온 후, 커서가 바로 second 변수 쪽으로 이동하도록 설정할 수 있다.</li>
<li>second 변수 : 직접 다음 액티비티 이름을 적어줄 것이기 때문에 아무 작업을 하지 않는다.</li>
</ul>
<img src="/img/android_studio_exam3.png" width="600" height="200">
<p>이제 Ok 버튼을 눌러서 마무리하면 코드에서 사용할 수 있다. 필자는 <code>cis</code>라는 축약형을 사용했다.</p>
<img src="/img/android_studio_exm4.png" width="600" height="200">
<p>위 그림을 보면 <code>cis</code> 축약형을 입력했을 때, 원하는 코드가 뜨는 것을 확인할 수 있다.</p>
<h2 id="결론">결론</h2>
<p>Live Template을 사용하면 간단한 코드를 작성하는 것을 템플릿화시켜서 아주 유용하게 사용할 수 있을 것 같다. 아주 유용한 기능이다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://blog.yena.io/studynote/2019/07/14/Android-Live-Templates.html" target="_blank" rel="noopener">[Android] Live Template 라이브 템플릿</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/15/AndroidStudio-Live-Template/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/5/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/7/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 6 of 26</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
