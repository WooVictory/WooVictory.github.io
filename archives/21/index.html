
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/21/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/10/03/BOJ1076/"
                            aria-label=": [1076] 저항"
                        >
                            [1076] 저항
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-10-03T16:18:29+09:00">
	
		    Oct 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/1076" target="_blank" rel="noopener">https://www.acmicpc.net/problem/1076</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<hr>
<ol>
<li>첫 번째 접근 방법</li>
</ol>
<p>처음에는 Map이라는 자료구조를 사용해야 한다는 느낌을 받았지만, 조금 복잡하게 생각을 했었습니다. 아마도 문제의 패턴을 몰랐기 때문일 것입니다. 그래서 저는 값과 곱을 가지는 Class를 만들어서 이 클래스 타입의 ArrayList를 만들려고 시도했습니다. 하지만, 이렇게 되면 인덱스로 원소에 접근을 해야하는 문제와 시간 복잡도가 커질 수 있는 문제가 발생하여 비효율적임을 알게 되었습니다.</p>
<ol start="2">
<li>두 번째 접근 방법</li>
</ol>
<p>이번에는 다른 방식을 생각했습니다. 값과 곱의 규칙을 찾아내어 Class를 따로 만들 필요가 없음을 알았습니다. <code>10^값 = 곱</code> 이라는 규칙을 찾아 냈습니다. 쉽게 설명하면 값이 0일 때, 곱은 1 값이 1일 때, 곱은 10, 값이 2일 때, 곱은 100 … 이런 규칙성을 찾을 수 있었고, Map이라는 자료 구조에 String을 키로 하고, Integer를 값으로 하는 Map을 생성했고, 데이터를 넣어놓았습니다.</p>
<p>그리고 문제에서 입력은 3개 뿐이므로, 반복문을 통해 입력을 받기보다는 바로 받아서 처리하는 것이 효율적이라고 판단했습니다. 코드는 아래에 있습니다.</p>
<ul>
<li>배운 점<br>
** Map이라는 자료구조는 내가 생각하는 것보다 다양한 곳에서 쓰이는 것 같습니다. 이러한 자료구조를 사용해서 문제를 풀 수 있도록 많이 생각해보고 문제도 많이 풀어봐야 할 것 같습니다. :)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ1076</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 저항 문제는 Map 자료구조를 사용해서 풀 수 있다.</span></span><br><span class="line">        <span class="comment">// 문제에서 입력은 세 개이므로 for문을 돌려서 받지 않고 그냥 한번에 받는 것이 더 간단.</span></span><br><span class="line"></span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">"black"</span>, <span class="number">0</span>);</span><br><span class="line">        map.put(<span class="string">"brown"</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">"red"</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"orange"</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">"yellow"</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"green"</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"blue"</span>, <span class="number">6</span>);</span><br><span class="line">        map.put(<span class="string">"violet"</span>, <span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">"grey"</span>, <span class="number">8</span>);</span><br><span class="line">        map.put(<span class="string">"white"</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        String one = bf.readLine(), two = bf.readLine(), three = bf.readLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> firstResult = map.get(one) * <span class="number">10</span> + map.get(two);</span><br><span class="line">        <span class="keyword">long</span> secondResult = (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, map.get(three));</span><br><span class="line">        System.out.println(firstResult * secondResult);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/10/03/BOJ1076/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/23/BOJ10816/"
                            aria-label=": [10816] "
                        >
                            [10816] 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-23T21:11:55+09:00">
	
		    Sep 23, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/10816" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10816</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<hr>
<ol>
<li>멍청한 풀이</li>
</ol>
<p>오늘 풀어본 문제는 어제 풀었던 문제의 두번째 시리즈라고 할 수 있습니다. 즉, 숫자카드2 입니다. 어제 숫자카드 문제를 풀면서 이해를 했다고 생각하고 바로 두번째 시리즈에 도전했습니다. 하지만 역시나 시즌2는 쉽지는 않다는 것을 깨달았습니다. 단순하게 Set을 쓰려고했지만, 문제를 읽어보니 Set이 아닌 다른 자료구조를 써야한다는 생각을 했고, 저는 늘 써오던 List를 이용해서 문제를 풀려고 했습니다.</p>
<p>하지만 List를 사용하게 되면 시간초과의 난관을 극복할 수 없었습니다. 애초에 List로 풀어야지라고 마음을 먹으면서 시간초과 날 것 같다는 염려를 했습니다…ㅜㅜ 아직 시간 초과를 해결하기 위한 다른 자료구조를 생각하는 능력이 많이 부족합니다…ㅜㅜ</p>
<p>그래서 일단은 부딪혀보자는 마음으로 List를 사용하여 문제를 풀었습니다. 아래의 코드는 List를 이용한 문제 풀이 방법입니다. 완성된 코드는 아니며 제가 생각해보면서 짠 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ10816</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(bf.readLine());</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            list.add(Integer.parseInt(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(bf.readLine());</span><br><span class="line">        StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st2.nextToken());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;N;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.get(k).equals(value))&#123;</span><br><span class="line">                    count+=<span class="number">1</span>;</span><br><span class="line">                    counts[M] = count;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    counts[M] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(counts[M]+<span class="string">" "</span>);</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/*  if(list.contains(value))&#123;</span></span><br><span class="line"><span class="comment">                System.out.println("들어오긴 하니;??"+", "+(j));</span></span><br><span class="line"><span class="comment">                count+=1;</span></span><br><span class="line"><span class="comment">                counts[M] = count;</span></span><br><span class="line"><span class="comment">                System.out.println(counts[M]);</span></span><br><span class="line"><span class="comment">            &#125;else &#123;</span></span><br><span class="line"><span class="comment">                counts[M] = 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            sb.append(counts[M]+" ");</span></span><br><span class="line"><span class="comment">            count = 0;*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>전체적인 틀을 잡았고 어떻게 푸는지 알았지만 List만을 사용해서는 중복된 값이 들어있는 것을 Check하고 갯수를 확인하는 과정이 어려웠습니다. 그래서 생각을 하다가 구글링을 해보았습니다.</p>
<ol start="2">
<li>생각하고 나서 깨달은 풀이</li>
</ol>
<p>Map이라는 자료구조를 사용했습니다. Map은 키와 값을 쌍으로 저장하는 자료구조입니다. 특징은 저장 요소의 순서를 유지하지 않고, Key는 중복을 허용하지 않지만, 값은 중복을 허용합니다.</p>
<p>Map을 이용해서 Key, Value 쌍으로 데이터를 저장하는 방식을 사용했습니다. 처음에 상근이가 가지고 있는 카드를 입력받는데, 이 값들을 모두 Map에 저장합니다. <strong>여기서 상근이가 가지고 있는 카드를 Key값으로 정했습니다.</strong></p>
<p>Map은 초기화되지 않은 상태이기 때문에 처음에 들어오는 카드 입력들은 모두 카드를 Key값으로 가지면서 Value는 모두 1을 저장했습니다. 그러다가 앞에서 저장되었던 Key의 카드 입력이 들어오게 되면 기존에 있던 key에 해당하는 value를 1을 더한 값으로 교체해줍니다. *<strong>이러한 과정을 거쳐 상근이가 가지고 있는 카드를 입력받으면 Map이라는 자료구조에 상근이가 가지고 있는 카드의 갯수가 저장됩니다.</strong></p>
<p>그리고 추후에 입력받는 카드들을 상근이가 가지고 있는지 비교하는 것이므로 입력받은 카드를 Map의 <code>containsKey()</code> 메소드를 이용해서 카드를 가지고 있는지 비교해서 가지고 있다면 입력받은 카드의 값을 Key로 해서 Map에서 뽑아내어 출력합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ10816</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(bf.readLine());</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// get()은 key에 해당하는 value를 반환</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">                map.replace(key, map.get(key) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(key, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(bf.readLine());</span><br><span class="line">        st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st.nextToken());</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(value)) &#123;</span><br><span class="line">                sb.append(map.get(value) + <span class="string">" "</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="number">0</span> + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 입력</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">10</span> <span class="number">10</span> <span class="number">10</span> -<span class="number">10</span> -<span class="number">10</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> -<span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> -<span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>배운점</p>
</blockquote>
<p>알고리즘을 풀 때 시간초과를 생각하는 방법을 배웠습니다. 이전에는 무작정 풀고 나서 '왜 안되는거지???'라는 생각을 하고 구글링을 해서 다른 방법을 찾아보았다면 이제는 '시간 초과가 나서 안되네…'라는 생각을 하고 시간 초과가 나지 않는 자료구조를 생각해보고 로직을 생각하는 힘을 키우게 된 것 같습니다.</p>
<p>또한, 알고리즘을 풀 때 어떠한 자료구조를 사용해야 할 지 결정하는 능력은 문제를 많이 풀어봐야 한다는 것을 알게 되었습니다. 문제를 보고 도전할 수 있는 자료구조는 List, Set 정도입니다. Map은 무엇인지 알긴 하지만, 알고리즘을 풀 때 어떻게 어떤 상황에서 사용하는지에 대해 잘 모르고 있었기 때문에 부족함을 많이 느꼈습니다. 앞으로 Map을 자주 사용해보고 많이 풀어보도록 노력하는게 좋을 것 같습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/23/BOJ10816/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/22/BOJ10815/"
                            aria-label=": [10815] 숫자 카드 "
                        >
                            [10815] 숫자 카드 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-22T22:14:02+09:00">
	
		    Sep 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/10815" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10815</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<ol>
<li>첫번째 접근방법</li>
</ol>
<p>처음에는 배열을 이용해서 접근하려고 했습니다. 상근이가 몇개의 숫자 카드를 가지고 있는지 그리고 어떤 숫자 카드를 가지고 있는지 입력 받고, 그 후에는 카드의 갯수와 카드를 입력 받아서 후에 입력받은 카드를 상근이가 가지고 있는지 없는지 여부를 확인하였습니다.</p>
<p>상근이가 숫자 카드를 가지고 있다면 1, 가지고 있지 않다면 0을 출력하게 됩니다. 그래서 저는 N, M 크기의 배열 2개를 만들고 각 배열에 저장해서 서로 비교할 수 있도록 구현했습니다.</p>
<p><strong>문제에서 주어진 테스트 케이스를 만족시키는 답을 얻을 수 있었습니다. 허나 시간 초과를 피하지 못했습니다. 문제를 풀면서도 이 문제는 시간 초과가 날 것 같다는 느낌이 들었지만, 일단 무작정 풀어보았습니다. 결과는, 역시나… 그래서 다른 방법으로 풀어보았습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> language;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ10815</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(bf.readLine()); <span class="comment">// 상근이가 가지고 있는 카드의 갯수</span></span><br><span class="line">        <span class="comment">//Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            list.add(Integer.parseInt(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set&lt;Integer&gt; check_set = new HashSet&lt;&gt;();</span></span><br><span class="line">        ArrayList&lt;Integer&gt; checkList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(bf.readLine());</span><br><span class="line">        StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            checkList.add(Integer.parseInt(st2.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(checkList.get(i).equals(list.get(j)))&#123;</span><br><span class="line">                    checkList.set(i,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!checkList.get(i).equals(<span class="number">1</span>))&#123;</span><br><span class="line">                checkList.set(i,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = checkList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">시간 초과....ㅜㅜ</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>두 번째 방법</li>
</ol>
<p>그 다음으로는 Set 자료 구조를 이용하는 것입니다. Set 자료구조는 기본적으로 중복된 값의 저장을 허용하지 않고, 값이 정렬된 것처럼 저장됩니다. 여기서는 Set의 특성을 이용하지는 않지만, 배열보다는 더욱 편리하게 다룰 수 있을 것 같아서 이 자료구조를 사용하기로 결정했습니다.<br>
[List를 사용해도 비슷한 결과를 얻을 수 있다고 생각합니다.]</p>
<p>그리고 문제를 다시 살펴보면서 2개의 Set을 만들어서 값을 가지고 있을 필요가 없다고 생각했습니다. 어차피 우리가 가지고 있어야 할 값들은 <code>상근이가 가지고 있는 숫자 카드</code>이기 때문에 상근이가 가지고 있는 숫자 카드만 Set 자료구조에 저장해서 가지고 있도록 했습니다.</p>
<p>M개의 숫자 카드를 가지고 있는지 확인하기 위해서 숫자 카드를 입력받는데 이 부분은 Set을 통해 값을 저장하지 않아도 됨을 깨달았습니다. 이유는 여기서 입력받는 값을 사용하지 않고 단순하게 상근이가 가지고 있는 카드인지 아닌지를 비교하기 위해서 사용하는 <strong>일회성</strong> 값이라고 판단되어 입력 받은 즉시 Set에 포함되어 있는지 <code>contains()</code> 메소드를 사용해서 확인해주었습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ10815</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(bf.readLine()); <span class="comment">// 상근이가 가지고 있는 카드의 갯수</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 상근이가 가지고 있는 카드를 담을 Set 자료구조</span></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            set.add(Integer.parseInt(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(bf.readLine());</span><br><span class="line">        StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*FIXME</span></span><br><span class="line"><span class="comment">        * 여기서는 어차피 기존에 상근이가 가지고 있는 카드와</span></span><br><span class="line"><span class="comment">        * 입력받은 카드를 비교해서 상근이가 가지고 있는지 가지고 있지 않은지</span></span><br><span class="line"><span class="comment">        * 판단하므로 굳이 Set을 통해서 값을 저장하지 않아도 됨.</span></span><br><span class="line"><span class="comment">        * 입력 받은 그대로 비교하면 된다.</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(Integer.parseInt(st2.nextToken())))&#123;</span><br><span class="line">                System.out.print(<span class="number">1</span>+<span class="string">" "</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="number">0</span>+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 입력</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">10</span> -<span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> -<span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> -<span class="number">10</span></span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>세 번째 방법</li>
</ol>
<p>이 방법은 두 번째 방법과 똑같은 형태로 구현하지만, 실행 시간을 줄이기 위한 방법입니다. 두 번째 방법으로 문제를 풀면 실행시간은 1.9초 정도 나오게 됩니다. 이 문제의 시간 제한이 2초인 것에 비하면 그 안에 들어서 문제는 없습니다. 하지만 다른 사람들이 푼 코드를 통해서 시간을 줄일 수 있는 방법을 찾았습니다.</p>
<p>그 방법은 System.out.print()를 빈번하게 호출하는 것보다는 StringBuilder 객체를 만들어서 append() 함수를 통해 값을 추가하고 마지막으로 한 번만 최종 결과를 출력해 주는 것입니다. 이 방법은 실행 시간이 0.9초 나오는 것을 확인할 수 있었고, 두 번째 방법과 1초 정도의 실핼 시간 차이가 남을 확인할 수 있었습니다.</p>
<p>실행 시간을 단축할 수 있는 방법을 찾았습니다. :)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> language;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ10815</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> N = Integer.parseInt(bf.readLine()); <span class="comment">// 상근이가 가지고 있는 카드의 갯수</span></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 상근이가 가지고 있는 카드를 담을 Set 자료구조</span></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            set.add(Integer.parseInt(st.nextToken()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> M = Integer.parseInt(bf.readLine());</span><br><span class="line">        StringTokenizer st2 = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*FIXME</span></span><br><span class="line"><span class="comment">        * 여기서는 어차피 기존에 상근이가 가지고 있는 카드와</span></span><br><span class="line"><span class="comment">        * 입력받은 카드를 비교해서 상근이가 가지고 있는지 가지고 있지 않은지</span></span><br><span class="line"><span class="comment">        * 판단하므로 굳이 Set을 통해서 값을 저장하지 않아도 됨.</span></span><br><span class="line"><span class="comment">        * 입력 받은 그대로 비교하면 된다.</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(Integer.parseInt(st2.nextToken())))&#123;</span><br><span class="line">                sb.append(<span class="number">1</span>+<span class="string">" "</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="number">0</span>+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 입력</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">10</span> -<span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> -<span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> -<span class="number">10</span></span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>단 3줄의 차이로 실행시간이 1초 줄어든 것을 확인할 수 있습니다. 앞으로 알고리즘 문제를 풀었더라도 실행 시간을 줄이는 방법을 찾아보고 공부해보는 것도 좋은 경험이 되고 실력도 쌓일 것 같습니다.</strong><br>
<img src="/img/runtime_diff.png" width="800" height="300"></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/22/BOJ10815/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/22/BOJ10867/"
                            aria-label=": [10867] 중복빼고 정렬하기 "
                        >
                            [10867] 중복빼고 정렬하기 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-22T18:27:21+09:00">
	
		    Sep 22, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/10867" target="_blank" rel="noopener">https://www.acmicpc.net/problem/10867</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<hr>
<p>이 문제는 입력받은 숫자를 오름차순으로 정렬하는 문제입니다. 하지만 중복된 숫자가 있다면 제거하고 정렬해야 합니다. 이 문제는 배열을 이용해서 풀어도 되지만, 배열을 이용해서 푼다면 중복된 값을 체크해야 하기 때문에, 그보다는 중복된 값을 허용하지 않는 자료구조를 사용하는 것이 간편하다고 생각합니다.</p>
<p>그래서 저는 Set 자료구조를 사용했고, HashSet을 이용해서 문제를 해결하였습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine());</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st.nextToken());</span><br><span class="line">            set.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.print(iterator.next()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/22/BOJ10867/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/18/BOJ2346/"
                            aria-label=": [2346] 풍선 터뜨리기 "
                        >
                            [2346] 풍선 터뜨리기 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-18T22:41:18+09:00">
	
		    Sep 18, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/2346" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2346</a></p>
<h1 id="풀이-방법">풀이 방법</h1>
<hr>
<p>예전에 한 번 풀어본 문제이지만, 인간의 기억력은 역시나… 오래 지속되지 않는다는 걸 알면서도 똑같은 실수를 반복했습니다…ㅜ 그래서 저는 다시 풀어보았습니다. 다행스럽게도 풀어본 경험이 있어서인지 문제를 보고 어떻게 접근해야 하는지 생각할 수 있었습니다.</p>
<ol>
<li>
<p><strong>Class 만들기</strong><br>
풍선의 순서와 풍선에 적혀있는 값을 가지고 있는 Class를 만들어서 사용하면 됩니다.</p>
</li>
<li>
<p><strong>List 사용</strong><br>
이 문제를 풀기 위해서 위에서 만든 Class를 타입으로 갖는 객체 배열을 사용할지 리스트를 사용할지 생각했습니다. 이 문제에서는 풍선을 터뜨릴 경우 삭제를 해줘야 하기 때문에 추가 및 삭제가 일어나도 빈 공간을 처리하지 않아도 되는 즉, 빈 공간이 자동으로 채워지는 <strong>List</strong>를 사용하였습니다.</p>
</li>
<li>
<p><strong>터뜨릴 순서?</strong><br>
풍선을 터뜨릴 순서를 결정하기 위해서는 풍선에 적혀있는 값을 가지고 결정해야 합니다. 풍선에 적혀있는 값이 양수이면 오른쪽으로 돌고, 음수이면 왼쪽으로 돌아서 풍선을 터뜨리면 됩니다. 문제에서 풍선은 원형처럼 1번의 왼쪽에는 N번 풍선이, N번의 오른쪽에는 1번 풍선이 있다고 하였으므로 참고해서 돌고 터뜨리면 됩니다.</p>
</li>
</ol>
<p><strong>주의할 점은 처음에 터뜨릴 풍선은 1번 풍선인데, 이 풍선을 터뜨리고 나면 1번 풍선이 사라지면서 2번째 풍선이 1번 풍선의 인덱스를 가지게 됩니다. 그러므로 첫번째 풍선을 이미 터뜨리고 나서 풍선에 적힌 값에 따라서 다음에 터뜨릴 풍선을 결정할 때, 풍선에 적혀있는 값이 양수라면 (그 값 - 1) 만큼만 계산하면 됩니다. 왜냐하면 리스트에서 풍선이 삭제됨에 따라서 이미 한칸을 이동했기 때문입니다. (쉽게 말하면 풍선이 하나 터지면서 다른 풍선의 인덱스들이 터진 풍선 이후 부터 즉, 오른쪽부터 0부터 재할당되기 때문입니다.)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ2346</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">int</span> test_case = Integer.parseInt(bf.readLine()); <span class="comment">// 테스트 케이스</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Ballons&gt; ballons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;test_case;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = Integer.parseInt(st.nextToken());</span><br><span class="line">            ballons.add(<span class="keyword">new</span> Ballons(i+<span class="number">1</span>, value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str = process(ballons, test_case);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">process</span><span class="params">(ArrayList&lt;Ballons&gt; ballon_list, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> kill=<span class="number">0</span>; <span class="comment">// 터뜨릴 풍선의 인덱스</span></span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>; <span class="comment">// 터뜨릴 풍선의 값</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="comment">// value 즉, 풍선에 적혀있는 값이 양수인지 음수인지에 따라</span></span><br><span class="line">            <span class="comment">// 오른쪽 혹은 왼쪽으로 이동하기 위해 검사</span></span><br><span class="line">            <span class="keyword">if</span>(value&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;value-<span class="number">1</span>;k++)&#123;</span><br><span class="line">                    ++kill;</span><br><span class="line">                    <span class="keyword">if</span>(kill&gt;=ballon_list.size())&#123;</span><br><span class="line">                        kill=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                value = Math.abs(value); <span class="comment">// 절대값 변환</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;value;j++)&#123;</span><br><span class="line">                    --kill;</span><br><span class="line">                    <span class="keyword">if</span> (kill&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        kill = ballon_list.size()-<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*FIXME</span></span><br><span class="line"><span class="comment">            * 처음에는 0번째 즉, 첫 번째 풍선을 터뜨려야 하기 때문에</span></span><br><span class="line"><span class="comment">            * 이렇게 터뜨릴 풍선을 정하고</span></span><br><span class="line"><span class="comment">            * 그 풍선의 값(value)[즉, 적혀있는 값!]를 알아낸다.</span></span><br><span class="line"><span class="comment">            * 왜냐하면, 다음 풍선을 터뜨리기 위해 얼만큼 이동할지 알기 위해서</span></span><br><span class="line"><span class="comment">            * */</span></span><br><span class="line">            Ballons ballon = ballon_list.get(kill);</span><br><span class="line">            System.out.println(<span class="string">"삭제가 될 풍선 : "</span>+ballon.valueNumber+<span class="string">", "</span>+(ballon.orderNumber)+<span class="string">", "</span>+kill);</span><br><span class="line">            value = ballon.valueNumber;</span><br><span class="line"></span><br><span class="line">            sb.append(ballon.orderNumber+<span class="string">" "</span>);</span><br><span class="line">            ballon_list.remove(kill);</span><br><span class="line">            <span class="keyword">if</span>(kill == ballon_list.size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"몇번?"</span>);</span><br><span class="line">                kill = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballons</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> orderNumber; <span class="comment">// 풍선의 순서</span></span><br><span class="line">    <span class="keyword">int</span> valueNumber; <span class="comment">// 풍선 안에 적힌 값</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ballons</span><span class="params">(<span class="keyword">int</span> orderNumber, <span class="keyword">int</span> valueNumber)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderNumber = orderNumber;</span><br><span class="line">        <span class="keyword">this</span>.valueNumber = valueNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/18/BOJ2346/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/05/java-basic-19/"
                            aria-label=": [Java] 19. java.time"
                        >
                            [Java] 19. java.time
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-05T20:36:36+09:00">
	
		    Sep 05, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="자바에서의-날짜-및-시간-처리">자바에서의 날짜 및 시간 처리</h1>
<hr>
<p>JDK 1.0에서는 Date 클래스를 사용하여 날짜에 관한 처리를 수행했습니다. 하지만 Date 클래스는 현재 대부분의 메소드가 사용을 권장하지 않고(<code>deprecated</code>)있습니다.</p>
<p>JDK 1.1부터 새롭게 제공된 Calendar 클래스는 날짜와 시간에 대한 정보를 손쉽게 얻을 수 있었습니다. 하지만 Calendar 클래스는 다음과 같은 <strong>문제점</strong>을 가지고 있습니다.</p>
<ol>
<li>Calendar 인스턴스는 불변 객체(immutable object)가 아니라서 값이 수정될 수 있습니다.</li>
<li>윤초(leap second)와 같은 특별한 상황을 고려하지 않습니다.</li>
<li>Calendar 클래스에서는 월(month)을 나타낼 때 1월부터 12월을 0부터 11까지로 표현해야 하는 불편함이 있습니다.</li>
</ol>
<p>따라서 많은 개발자들은 Calendar 클래스뿐만 아니라 더 나은 성능의 Joda-Time이라는 라이브러리를 함께 사용해 왔습니다.</p>
<p>버전에서는 이러한 Joda-Time 라이브러리를 발전시킨 새로운 날짜와 시간 API인 java.time 패키지를 제공합니다. java.time 패키지는 위와 같은 문제점을 모두 해결했으며, 다양한 기능을 지원하는 다수의 하위 패키지를 포함하고 있습니다.</p>
<h2 id="javatime-패키지">java.time 패키지</h2>
<p>Java SE 8부터 제공되는 <code>java.time 패키지</code>에는 자바에서 날짜와 시간을 다루는 데 사용되는 필수 클래스들이 포함되어 있습니다. 또한, 다음과 같은 다양한 기능을 하는 하위 패키지를 포함하고 있습니다.</p>
<ol>
<li>java.time.chrono : ISO-8601에 정의된 표준 달력 이외의 달력 시스템을 사용할 때 필요한 클래스들</li>
<li>java.time.format : 날짜와 시간에 대한 데이터를 구문 분석하고 형식화하는데 사용되는 클래스들</li>
<li>java.time.temporal : 날짜와 시간에 대한 데이터를 연산하는 데 사용되는 보조 클래스들</li>
<li>java.time.zone : 타임 존(time-zone)과 관련된 클래스들</li>
</ol>
<p><strong>java.time 패키지는 기존에 사용되는 Calendar 클래스의 단점을 보완하였습니다. 따라서 해당 패키지에 속하는 모든 클래스의 인스턴스는 불변 객체(immutable object)로 생성됩니다. 따라서, 값을 수정할 수 없습니다.<br>
즉, java.time 패키지에 포함되는 클래스의 메소드들은 모두 새로운 객체를 생성하여 반환하고 있습니다.</strong></p>
<h2 id="javatime-패키지의-구성-클래스">java.time 패키지의 구성 클래스</h2>
<p>기존의 Calendar 클래스는 날짜와 시간을 한 번에 표현했지만, java.time 패키지에서는 별도로 구분하여 처리합니다. LocalData 클래스는 날짜를 표현할 때 사용하며, LocalTime 클래스는 시간을 표현할 때 사용합니다.<br>
또한, 기존의 Caledar 클래스처럼 날짜와 시간을 한 번에 표현하고 싶을 때는 LocalDateTime 클래스를 사용합니다.</p>
<p>ZonedDateTime 클래스는 특정 타임 존(time-zone)에 해당하는 날짜와 시간을 다루는 데 사용합니다. 또한, 기존의 Date 클래스와 비슷한 용도로 사용되는 Instant 클래스가 있습니다. Instant 클래스는 특정 시점의 날짜와 시간을 나노초(nanosecond) 단위로 표현하는 타임스탬프(time-stamp)를 다루는 데 사용됩니다.</p>
<p>Period 클래스(단어가 의미하듯이 '기간’이라는 뜻을 가지고 있음)는 두 날짜 사이의 차이를 표현하는 데 사용되며, Duration 클래스는 두 시각 사이의 차이를 표현하는 데 사용됩니다.</p>
<h1 id="localdate와-localtime">LocalDate와 LocalTime</h1>
<hr>
<p>LocalData 클래스는 날짜를 표현하는 데 사용되며, LocalTime 클래스는 시간을 표현하는 데 사용됩니다. java.time 패키지에 포함된 대부분의 클래스들은 이 두 클래스를 확장한 것이 많으므로, 우선 이 두 클래스를 먼저 이해하고 알고 있어야 합니다. :)</p>
<h2 id="날짜와-시간-객체의-생성">날짜와 시간 객체의 생성</h2>
<p>LocalData와 LocalTime 클래스는 객체를 생성하기 위해 now()와 of() 메소드라는 클래스 메소드를 제공합니다.</p>
<p>now() 메소드는 현재 날짜와 시간을 이용하여 새로운 객체를 생성하여 반환합니다. 하지만 of() 메소드는 전달된 인수를 가지고 특정 날짜와 시간을 표현하는 새로운 객체를 생성하여 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now(); <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(today+<span class="string">" 와 "</span>+present);</span><br><span class="line"></span><br><span class="line">        LocalDate birthday = LocalDate.of(<span class="number">1994</span>,<span class="number">06</span>,<span class="number">27</span>);</span><br><span class="line">        LocalTime birthTime = LocalTime.of(<span class="number">02</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">11</span>);</span><br><span class="line">        System.out.println(birthday+<span class="string">", "</span>+birthTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">05</span> 와 <span class="number">21</span>:<span class="number">22</span>:<span class="number">06.640</span></span><br><span class="line"><span class="number">1994</span>-<span class="number">06</span>-<span class="number">27</span>, <span class="number">02</span>:<span class="number">00</span>:<span class="number">00.000000011</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>of() 메소드는 위의 예제에서 사용된 메소드 시그니처 이외에도 다양한 형태로 오버로딩되어 제공됩니다.</p>
</blockquote>
<h2 id="날짜와-시간-객체에-접근하기">날짜와 시간 객체에 접근하기</h2>
<p>LocalDate와 LocalTime 클래스는 특정 필드의 값을 가져오기 위해서 다음과 같이 다양한 getter 메소드를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 날짜 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getYear()</td>
<td style="text-align:center">해당 날짜 객체의 연도(YEAR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">Month getMonth()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 Month 열거체를 이용하여 반환함.(즉, SEPTEMBER과 같은 형식으로 반환)</td>
</tr>
<tr>
<td style="text-align:center">int getMonthValue()</td>
<td style="text-align:center">해당 날짜 객체의 월(MONTH_OF_YEAR) 필드의 값을 반환함. (숫자로 1~12까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfMonth()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_MONTH) 필드의 값을 반환함. (숫자로 1~31까지를 반환함.)</td>
</tr>
<tr>
<td style="text-align:center">int getDayOfYear()</td>
<td style="text-align:center">해당 날짜 객체의 일(DAY_OF_YEAR) 필드의 값을 반환함. (숫자로 1~365까지를 반환함.[윤년이면 366])</td>
</tr>
<tr>
<td style="text-align:center">DayOfWeek getDayOfWeek()</td>
<td style="text-align:center">해당 날짜 객체의 요일(DAY_OF_WEEK) 필드의 값을 DayOfWeek 열거체를 이용하여 반환함.</td>
</tr>
</tbody>
</table>
<p>기존의 Calendar 클래스에서는 1월을 0으로 표현하여 월의 범위가 0~11이었으며, 요일은 일요일부터 1로 표현했습니다.<br>
하지만 java.time 패키지에서 1월을 1로 표현하여 월의 범위가 1~12가 되었으며, 요일은 월요일부터 1로 표현하도록 변경되었습니다.</p>
<blockquote>
<p>Calendar 클래스와 java.time 패키지의 클래스를 같이 사용할 때에는 특히 위와 같은 차이점에 주의해야 합니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 현재 날짜 기준으로 생성</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"이번달은 "</span>+today.getMonthValue()+<span class="string">"월입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은"</span>+today.getDayOfWeek()+<span class="string">"입니다."</span>);</span><br><span class="line">        System.out.println(<span class="string">"오늘은 1년 중 "</span>+today.get(ChronoField.DAY_OF_YEAR)+<span class="string">"일째 날입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">이번달은 <span class="number">9</span>월입니다.</span><br><span class="line">오늘은WEDNESDAY입니다.</span><br><span class="line">오늘은 <span class="number">1</span>년 중 <span class="number">248</span>일째 날입니다.</span><br></pre></td></tr></table></figure>
<p>LocalTime 클래스에서 제공하는 대표적인 getter 메소드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int get(TemporalField field) long getLong(TemporalField field)</td>
<td style="text-align:center">해당 시간 객체의 명시된 필드의 값을 int형이나 long형으로 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getHour()</td>
<td style="text-align:center">해당 시간 객체의 시(HOUR_OF_DAY) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getMinute()</td>
<td style="text-align:center">해당 시간 객체의 분(MINUTE_OF_HOUR) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getSecond()</td>
<td style="text-align:center">해당 시간 객체의 초(SECOND_OF_MINUTE) 필드의 값을 반환함.</td>
</tr>
<tr>
<td style="text-align:center">int getNano()</td>
<td style="text-align:center">해당 시간 객체의 나노초(NANO_OF_SECOND) 필드의 값을 반환함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.getHour() + <span class="string">"시 "</span> + present.getMinute() + <span class="string">"분입니다."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">0</span>시 <span class="number">18</span>분입니다.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LocalDate와 LocalTime 클래스는 모두 현재 시간을 기준으로 하기 때문에 이 글을 보고 참고하시는 분들은 저와 다른 결과를 볼 수 있습니다. 다른 것이 당연한 것이니 당황해 하지 마시길…ㅎㅎ</p>
</blockquote>
<h2 id="temporalfield-인터페이스">TemporalField 인터페이스</h2>
<p>TemporalField 인터페이스는 월(month-of-year)과 시(hour-of-day)와 같이 날짜와 시간과 관련된 필드를 정의해 놓은 인터페이스입니다. 이 인터페이스를 구현하여 날짜와 시간을 나타낼 때 사용하는 열거체가 바로 ChronoField입니다.<br>
java.time 패키지를 구성하는 클래스의 메소드에서는 이 열거체를 이용하여 날짜와 시간을 처리하고 있스빈다.</p>
<p>ChronoField 열거체에 정의된 대표적인 열거체 상수는 다음 표와 같습니다.</p>
<img src="/img/chronoField.png" width="700" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.of(<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        String ampm;</span><br><span class="line"></span><br><span class="line">        System.out.println(present.get(ChronoField.AMPM_OF_DAY));</span><br><span class="line">        <span class="comment">// 0 : 오전, 1 : 오후</span></span><br><span class="line">        <span class="keyword">if</span> (present.get(ChronoField.AMPM_OF_DAY) == <span class="number">0</span>) &#123;</span><br><span class="line">            ampm = <span class="string">"오전"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ampm = <span class="string">"오후"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"지금은 "</span> + ampm + <span class="string">" "</span> + present.get(ChronoField.HOUR_OF_AMPM) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">지금은 오후 <span class="number">1</span>시입니다.</span><br></pre></td></tr></table></figure>
<p>위의 결과에서 보듯이 'present.get(ChronoField.AMPM_OF_DAY)'는 오전은 0을 오후는 1을 반환하고 있습니다.</p>
<h2 id="날짜와-시간-객체의-필드값-변경">날짜와 시간 객체의 필드값 변경</h2>
<p>LocalDate와 LocalTime 클래스는 날짜와 시간 객체에 접근하여 특정 필드의 값을 변경하기 위해서 <code>with()</code> 메소드를 사용합니다. with() 메소드를 사용하면 값이 변경될 필드를 사용자가 직접 명시할 수 있습니다.<br>
또한, 특정 필드의 값을 변경하기 위해 미리 정의되어 제공되는 다양한 with() 메소드를 사용할 수도 있습니다.</p>
<p><strong>LocalDate 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localdate.png" width="700" height="300"></p>
<p><strong>LocalTime 클래스에서 제공하는 with() 메소드는 다음과 같습니다.</strong><br>
<img src="/img/localtime.png" width="700" height="300"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+today.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalDate otherDay = today.withYear(<span class="number">1994</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"올해는 "</span>+otherDay.getYear()+<span class="string">"년입니다."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+present.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.withHour(<span class="number">16</span>); <span class="comment">// 새로운 객체를 반환</span></span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span>+otherTime.getHour()+<span class="string">"시 입니다."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">올해는 <span class="number">2018</span>년입니다.</span><br><span class="line">올해는 <span class="number">1994</span>년입니다.</span><br><span class="line"></span><br><span class="line">현재 시각은 <span class="number">0</span>시 입니다.</span><br><span class="line">현재 시각은 <span class="number">16</span>시 입니다.</span><br></pre></td></tr></table></figure>
<p>with() 메소드 이외에도 특정 필드의 값을 더하거나 뺄 수 있는 다양한 plus()와 minus() 메소드도 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoField;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalTime present = LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">"현재 시각은 "</span> + present.get(ChronoField.HOUR_OF_DAY) + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime otherTime = present.plus(<span class="number">2</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + otherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">        LocalTime anotherTime = present.minus(<span class="number">6</span>, ChronoUnit.HOURS);</span><br><span class="line">        System.out.println(<span class="string">"바뀐 시간은 "</span> + anotherTime.getHour() + <span class="string">"시입니다."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">현재 시각은 <span class="number">1</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">3</span>시입니다.</span><br><span class="line">바뀐 시간은 <span class="number">19</span>시입니다.</span><br></pre></td></tr></table></figure>
<h2 id="날짜와-시간-객체의-비교">날짜와 시간 객체의 비교</h2>
<p>LocalDate와 LocalTime 클래스에도 객체를 비교할 수 있는 compareTo() 메소드가 오버라이딩 되어 있습니다. 하지만 더욱 편리하게 날짜와 시간 객체를 서로 비교할 수 있도록 다음과 같은 메소드를 제공합니다.</p>
<ol>
<li>isEqual() 메소드 : equals() 메소드와는 달리 <strong>오직 날짜만을 비교함.</strong>(LocalDate 클래스에서만 제공)</li>
<li>isBefore() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 앞선 시간인지를 비교함.</li>
<li>isAfter() 메소드 : 두 개의 날짜와 시간 객체를 비교하여 현재 객체가 명시된 객체보다 늦은 시간인지를 비교함.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        LocalDate otherDay = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line">        LocalDate otherDay2 = LocalDate.of(<span class="number">1994</span>, <span class="number">06</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(today.compareTo(otherDay));</span><br><span class="line">        <span class="comment">// today와 otherDay의 year 간의 차이를 반환</span></span><br><span class="line">        System.out.println(today.isBefore(otherDay));</span><br><span class="line">        System.out.println(today.isAfter(otherDay));</span><br><span class="line">        System.out.println(today.isEqual(otherDay));</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(otherDay.isEqual(otherDay2));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/05/java-basic-19/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/04/java-basic-18/"
                            aria-label=": [Java] 18. 스트림API"
                        >
                            [Java] 18. 스트림API
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-04T12:06:54+09:00">
	
		    Sep 04, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림api">스트림API</h1>
<hr>
<p>Java SE 8부터 추가된 스트림 API는 앞서 입력과 출력 수업에서 살펴본 스트림과는 전혀 다른 개념입니다. 자바에서는 많은 양의 데이터를 저장하기 위해서 배열이나 컬렉션을 사용하는데, 이렇게 저장된 데이터에 접근하기 위해서는 반복문이나 반복자(iterator)를 사용하여 매번 새로운 코드를 작성해야 합니다.</p>
<p>하지만 이렇게 작성된 코드는 길이가 너무 길고 가독성도 떨어지며, 코드의 재사용이 거의 불가능합니다. 즉, 데이터베이스의 쿼리와 같이 정형화된 처리 패턴을 가지지 못했기에 데이터마다 다른 방법으로 접근해야만 했습니다.</p>
<p><strong>이러한 문제점을 극복하기 위해서 Java SE 8부터 스트림(stream) API를 도입합니다. 스트림 API는 데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다. 따라서 스트림 API를 이용하면 배열이나 컬렉션뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있게 됩니다.</strong></p>
<h2 id="스트림-api의-특징">스트림 API의 특징</h2>
<ol>
<li>스트림은 외부 반복을 통해 작업하는 컬렉션과는 달리 내부 반복(internal iteration)을 통해 작업을 수행합니다.</li>
<li>스트림은 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있습니다.</li>
<li>스트림은 원본 데이터를 변경하지 않습니다.</li>
<li>스트림의 연산은 필터-맵(filter-map) 기반의 API를 사용하여 지연(lazy) 연산을 통해 성능을 최적화합니다.</li>
<li>스트림은 parallelStream() 메소드를 통한 손쉬운 병렬 처리를 지원합니다.</li>
</ol>
<h2 id="스트림-api의-동작-흐름">스트림 API의 동작 흐름</h2>
<p>스트림 APi는 다음과 같이 세 가지 단계에 걸쳐서 동작합니다.</p>
<ol>
<li>스트림의 생성</li>
<li>스트림의 중개 연산(스트림의 변환)</li>
<li>스트림의 최종 연산(스트림의 사용)</li>
</ol>
<img src="/img/stream2.png" width="800" height="300">
<h1 id="스트림의-생성">스트림의 생성</h1>
<hr>
<p>스트림 API는 다음과 같은 다양한 데이터 소스에서 생성해서 사용할 수 있습니다.</p>
<ol>
<li>컬렉션</li>
<li>배열</li>
<li>가변 매개변수</li>
<li>지정된 범위의 연속된 정수</li>
<li>특정 타입의 난수들</li>
<li>람다 표현식</li>
<li>파일</li>
<li>빈 스트림</li>
</ol>
<h2 id="컬렉션">컬렉션</h2>
<p>자바에서 제공하는 모든 컬렉션의 최고 상위 조상인 Collection 인터페이스에는 stream() 메소드가 정의되어 있습니다. 따라서 Collection 인터페이스를 구현한 모든 List와 Set 컬렉션 클래스에서도 stream() 메소드로 스트림을 생성할 수 있습니다. 또한, parallelStream() 메소드를 사용하면 병렬 처리가 가능한 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// stream.forEach(System.out::println); 한 번 더 호출하면 에러가 발생</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Stream 클래스의 forEach() 메소드는 해당 스트림의 요소를 하나씩 소모해가며 순차적으로 요소에 접근하는 메소드입니다. 따라서 같은 스트림으로는 forEach() 메소드를 한 번밖에 호출할 수 없습니다. 단, 원본 데이터의 요소를 소모하는 것은 아니므로, 같은 데이터에서 또 다른 스트림을 생성하여 forEach() 메소드를 호출하는 것은 가능합니다.</p>
<h2 id="배열">배열</h2>
<p>배열에 관한 스트림을 생성하기 위해 Arrays 클래스에는 다양한 형태의 stream() 메소드가 클래스 메소드로 정의되어 있습니다. 또한, 기본 타입인 int, long, double 형을 저장할 수 있는 배열에 관한 스트림이 별도로 정의되어 있습니다.<br>
이러한 스트림은 java.util.stream 패키지의 IntStream, LongStream, DoubleStream 인터페이스로 각각 제공됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열에서 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Arrays.stream(arr);</span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열의 특정 부분만을 이용한 스트림 생성</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷 둘 셋 하나 </span><br><span class="line">둘 셋</span><br></pre></td></tr></table></figure>
<p>Arryas 클래스의 stream() 메소드는 전체 배열뿐만 아니라 배열의 특정 부분만을 이용하여 스트림을 생성할 수도 있습니다.</p>
<h2 id="가변-매개변수">가변 매개변수</h2>
<p>Stream 클래스의 <code>of()</code> 메소드를 사용하면 가변 매개변수를 전달받아 스트림을 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Double&gt; stream = Stream.of(<span class="number">4.2</span>, <span class="number">2.5</span>, <span class="number">3.1</span>, <span class="number">1.9</span>);</span><br><span class="line"></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4.2</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">1.9</span></span><br></pre></td></tr></table></figure>
<h2 id="지정된-범위의-연속된-정수">지정된 범위의 연속된 정수</h2>
<p>지정된 범위의 연속된 정수를 스트림으로 생성하기 위해 IntStream이나 LongStream 인터페이스에는 range()와 rangeClosed() 메소드가 정의되어 있습니다.</p>
<ul>
<li>range() : 명시된 시작 정수를 포함하지만, 명시된 마지막 정수는 포함하지 않는 스트림을 생성합니다.</li>
<li>rangeClosed() : 명시된 시작 정수뿐만 아니라 명시된 마지막 정수까지도 포함하는 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        stream1.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        stream2.forEach(e -&gt; System.out.print(e + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="특정-타입의-난수들">특정 타입의 난수들</h2>
<p>특정 타입의 난수로 이루어진 스트림을 생성하기 위해 Random 클래스에는 ints(), longs(), doubles()와 같은 메소드가 정의되어 있습니다.</p>
<p>이 메소드들은 매개변수로 스트림의 크기를 long 타입으로 전달받을 수 있습니다. 이 메소드들은 만약 매개 변수를 전달받지 않으면 크기가 정해지지 않은 무한 스트림을 반환합니다. 이때에는 limit() 메소드를 사용하여 따로 스트림의 크기를 제한해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream = <span class="keyword">new</span> Random().ints().limit(<span class="number">10</span>);</span><br><span class="line">        intStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">-<span class="number">306452731</span></span><br><span class="line"><span class="number">1589863803</span></span><br><span class="line">-<span class="number">2033593764</span></span><br><span class="line">-<span class="number">686440616</span></span><br><span class="line">-<span class="number">938628166</span></span><br><span class="line"><span class="number">2106259183</span></span><br><span class="line"><span class="number">700874167</span></span><br><span class="line">-<span class="number">1006255911</span></span><br><span class="line">-<span class="number">181498589</span></span><br><span class="line"><span class="number">1937399570</span></span><br></pre></td></tr></table></figure>
<p>위의 코드에서 처음에 ints() 메소드에 크기를 지정해주지 않아서 무한 스트림을 반환하지만, 뒤에 limit() 메소드를 이용하여 크기를 10으로 제한했습니다.</p>
<h2 id="람다-표현식">람다 표현식</h2>
<p>람다 표현식을 매개변수로 전달받아 해당 람다 표현식에 의해 반환되는 값을 요소로 하는 무한 스트림을 생성하기 위해 Stream 클래스에는 iterate()와 generate() 메소드가 정의되어 있습니다.</p>
<ul>
<li>iterate() : 시드(seed)로 명시된 값을 람다 표현식에 사용하여 반환된 값을 다시 시드로 사용하는 방식으로 무한 스트림을 생성합니다.</li>
<li>generate() : 매개변수가 없는 람다 표현식을 사용하여 반환된 값으로 무한 스트림을 생성합니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream stream = Stream.iterate(<span class="number">2</span>, n-&gt;n+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 2,4,6,8,10, ...</span></span><br></pre></td></tr></table></figure>
<h2 id="파일">파일</h2>
<p>파일의 한 행(line)을 요소로 하는 스트림을 생성하기 위해 java.nio.file.Files 클래스에는 lines() 메소드가 정의되어 있습니다. 또한, java.io.BufferedReader 클래스의 lines() 메소드를 사용하면 파일뿐만 아니라 다른 입력으로부터도 데이터를 행(line) 단위로 읽어 올 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String&lt;String&gt; stream = File.lines(Path path);</span><br></pre></td></tr></table></figure>
<h2 id="빈-스트림">빈 스트림</h2>
<p>아무 요소도 가지지 않는 빈 스트림은 Stream 클래스의 empty() 메소드를 사용하여 생성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 스트림 생성</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;Object&gt; stream = Stream.empty();</span><br><span class="line">        System.out.println(stream.count());</span><br><span class="line">        <span class="comment">// 스트림의 요소의 총 개수를 출력</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="스트림의-중개-연산">스트림의 중개 연산</h1>
<hr>
<p><strong>스트림 API에 의해 생성된 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됩니다. 이러한 중개 연산은 스트림을 전달받아 스트림을 반환하므로, 중개 연산은 연속으로 연결해서 사용할 수 있습니다.</strong><br>
또한, 스트림의 중개 연산은 필터-맵(filter-map) 기반의 API를 사용함으로 지연(lazy) 연산을 통해 성능을 최적화할 수 있습니다.</p>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림 필터링 : filter(), distinct()</li>
<li>스트림 변환 : map(), flatMap()</li>
<li>스트림 제한 : limit(), skip()</li>
<li>스트림 정렬 : sorted()</li>
<li>스트림 연산 결과 확인 : peek()</li>
</ol>
<h2 id="스트림-필터링">스트림 필터링</h2>
<p><code>filter()</code> 메소드는 해당 스트림에서 주어진 조건(predicate)에 맞는 요소만으로 구성된 새로운 스트림을 반환합니다.<br>
또한, <code>distinct()</code> 메소드는 해당 스트림에서 중복된 요소가 제거된 새로운 스트림을 반환합니다. distinct() 메소드는 내부적으로 Object 클래스의 equals() 메소드를 사용하여 요소의 중복을 비교합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream intStream1 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream intStream2 = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 스트림에서 중복된 요소 제거</span></span><br><span class="line">        intStream1.distinct().forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 스트림에서 홀수만 골라냄</span></span><br><span class="line">        intStream2.filter(k-&gt;k%<span class="number">2</span> != <span class="number">0</span>).forEach(e-&gt;System.out.print(e+<span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> </span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-변환">스트림 변환</h2>
<p><code>map()</code> 메소드는 해당 스트림의 요소들을 주어진 함수에 인수로 전달하여, 그 반환값들로 이루어진 새로운 스트림을 반환합니다. 만약 해당 스트림의 요소가 배열이라면, <code>flatMap()</code> 메소드를 사용하여 각 배열의 각 요소의 반환값을 하나로 합친 새로운 스트림을 얻을 수 있습니다.</p>
<p>다음 코드는 문자열로 이루어진 스트림을 map() 메소드를 이용하여 각 문자열의 길이로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"JAVASCRIPT"</span>);</span><br><span class="line">        stringStream.map(e-&gt;e.length()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>다음은 여러 문자열이 저장된 배열을 각 문자열에 포함된 단어로 이루어진 스트림으로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">"I study hard"</span>, <span class="string">"You study JAVA"</span>, <span class="string">"I am hungry"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream = Arrays.stream(arr);</span><br><span class="line">        stream.flatMap(s-&gt;Stream.of(s.split(<span class="string">" "</span>))).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">I</span><br><span class="line">study</span><br><span class="line">hard</span><br><span class="line">You</span><br><span class="line">study</span><br><span class="line">JAVA</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">hungry</span><br></pre></td></tr></table></figure>
<h2 id="스트림-제한">스트림 제한</h2>
<p><code>limit()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소만으로 이루어진 새로운 스트림을 반환합니다.<br>
<code>skip()</code> 메소드는 해당 스트림의 첫 번째 요소부터 전달된 개수만큼의 요소를 제외한 나머지 요소만으로 이루어진 새로운 스트림을 반환합니다.</p>
<blockquote>
<p>그리고 두 메소드의 들어가는 매개변수의 인덱스는 포함하지 않고 바로 직전 인덱스까지만 해당됩니다.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream3 = IntStream.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 4개의 요소를 제외 : 0,1,2,3 제외한 나머지 요소 출력</span></span><br><span class="line">        stream1.skip(<span class="number">4</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 첫 번째 요소부터 5개의 요소 출력 : 0,1,2,3,4</span></span><br><span class="line">        stream2.limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stream3.skip(<span class="number">3</span>).limit(<span class="number">5</span>).forEach(n -&gt; System.out.print(n + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h2 id="스트림-정렬">스트림 정렬</h2>
<p><code>sorted()</code> 메소드는 해당 스트림을 주어진 비교자(comparator)를 이용하여 정렬합니다. 이때 비교자를 전달하지 않으면 기본적으로 사전 편찬 순(natural order)으로 정렬하게 되고, 비교자를 전달하면 사전 편찬 순의 역순으로 정렬하게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"JAVA"</span>, <span class="string">"HTML"</span>, <span class="string">"JAVASCRIPT"</span>, <span class="string">"CSS"</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        stream1.sorted().forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        stream2.sorted(Comparator.reverseOrder()).forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">CSS HTML JAVA JAVASCRIPT </span><br><span class="line">JAVASCRIPT JAVA HTML CSS</span><br></pre></td></tr></table></figure>
<h2 id="스트림-연산-결과-확인">스트림 연산 결과 확인</h2>
<p><code>peek()</code> 메소드는 결과 스트림으로부터 요소를 소모하여 추가로 명시된 동작을 수행합니다. 이 메소드는 원본 스트림에서 요소를 소모하지 않으므로, 주로 연산과 연산 사이에 결과를 확인하고 싶을 때 사용합니다. 따라서 개발자가 디버깅 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        stream.peek(s -&gt; System.out.println(<span class="string">"원본 스트림 : "</span> + s))</span><br><span class="line">                .skip(<span class="number">2</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"skip(2) 실행 후 : "</span> + s))</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"limit(5) 실행 후 : "</span> + s))</span><br><span class="line">                .sorted()</span><br><span class="line">                .peek(s -&gt; System.out.println(<span class="string">"sorted() 실행 후 : "</span> + s))</span><br><span class="line">                .forEach(n -&gt; System.out.println(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">원본 스트림 : <span class="number">7</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">5</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">5</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">1</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">1</span></span><br><span class="line">원본 스트림 : <span class="number">2</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">2</span></span><br><span class="line">원본 스트림 : <span class="number">3</span></span><br><span class="line">skip(<span class="number">2</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">limit(<span class="number">5</span>) 실행 후 : <span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">sorted() 실행 후 : <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">sorted() 실행 후 : <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>위의 코드는 다음과 같은 결과를 보여줍니다. 현재 지금 저는 스트림 API에 대한 개념이 적은 상태입니다. 그리고 위의 peek()이라는 메소드의 동작 상태가 이해가 가지 않네요… 이렇게 정리해놓고 나중에 다시 공부할 때 조금 더 찾아보게 된다면 아마 이해가 가지 않을까요?ㅎㅎ</p>
</blockquote>
<p>위의 예제에서 첫 번째 요소인 7과 두 번째 요소인 5는 skip() 메소드에 의해 삭제되므로, 원본 스트림에서만 나타납니다. 하지만 세 번째 요소인 5는 skip() 메소드와 limit() 메소드가 실행된 후에도 존재하므로, 모두 나타납니다. 이렇게 peek() 메소드는 스트림의 각 요소가 해당 중개 연산 후에 어떻게 변화하는지를 보여줍니다.</p>
<h2 id="대표적인-중개-연산-메소드">대표적인 중개 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 중개 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_method.png" width="800" height="300">
<h1 id="스트림의-최종-연산">스트림의 최종 연산</h1>
<hr>
<p><strong>스트림 API에서 중개 연산을 통해 변환된 스트림은 마지막으로 최종 연산을 통해 각 요소를 소모하여 결과를 표시합니다. 즉, 지연(lazy)되었던 모든 중개 연산들이 최종 연산 시에 모두 수행되는 것입니다. 이렇게 최종 연산 시에 모든 요소를 소모한 해당 스트림은 더는 사용할 수 없게 됩니다.</strong></p>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산과 그에 따른 메소드는 다음과 같습니다.</p>
<ol>
<li>요소의 출력 : forEach()</li>
<li>요소의 소모 : reduce()</li>
<li>요소의 검색 : findFirst(), findAny()</li>
<li>요소의 검사 : anyMatch(), allMatch(), noneMatch()</li>
<li>요소의 통계 : count(), min(), max()</li>
<li>요소의 연산 : sum(), average()</li>
<li>요소의 수집 : collect()</li>
</ol>
<h2 id="요소의-출력">요소의 출력</h2>
<p>위에서 중개 연산과 관련된 메소드를 사용하면서 자주 사용했던 <code>forEach()</code> 메소드는 스트림의 각 요소를 소모하여 명시된 동작을 수행합니다. 반환 타입이 void이므로 보통 스트림의 모든 요소를 출력하는 용도로 많이 사용합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"셋"</span>,<span class="string">"하나"</span>);</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">셋</span><br><span class="line">하나</span><br></pre></td></tr></table></figure>
<h2 id="요소의-소모">요소의 소모</h2>
<p>스트림의 최종 연산은 모든 스트림의 각 요소를 소모하여 연산을 수행하게 됩니다. 하지만  <code>reduce()</code> 메소드는 첫 번째와 두 번째 요소를 가지고 연산을 수행한 뒤, 그 결과와 세 번째 요소를 가지고 또 다시 연산을 수행합니다. 이런 식으로 해당 스트림의 모든 요소를 소모하여 연산을 수행하고, 그 결과를 반환하게 됩니다.<br>
또한, 인수로 초기값을 전달하면 초기값과 해당 스트림의 첫 번째 요소와 연산을 시작하며, 그 결과와 두 번째 요소를 가지고 계속해서 연산을 수행하게 됩니다.</p>
<p>다음 예제는 스트림의 각 문자열 요소를 “++” 기호로 연결하여 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"넷"</span>, <span class="string">"둘"</span>, <span class="string">"셋"</span>, <span class="string">"하나"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; result1 = stream1.reduce((s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        result1.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">        String result2 = stream2.reduce(<span class="string">"시작"</span>, (s1, s2) -&gt; s1 + <span class="string">"++"</span> + s2);</span><br><span class="line">        System.out.println(result2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷++둘++셋++하나</span><br><span class="line">시작++넷++둘++셋++하나</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 인수로 초기값을 전달하는 reduce() 메소드의 반환 타입은 Optional<t>가 아닌 T 타입입니다. 그 이유는 비어 있는 스트림과 reduce 연산을 할 경우 전달받은 초기값을 그대로 반환해야 하기 때문입니다.</t></p>
<blockquote>
<p>Optional 클래스에 관한 내용은 아래에서 확인할 수 있습니다.</p>
</blockquote>
<h2 id="요소의-검색">요소의 검색</h2>
<p><code>findFirst()</code>와 <code>findAny()</code> 메소드는 해당 스트림에서 첫 번째 요소를 참조하는 Optional 객체를 반환합니다. 두 메소드 모두 비어있는 스트림에서 비어있는 Optional 객체를 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 정렬한 후, 첫 번째에 위치한 요소를 출력하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        OptionalInt result1 = stream1.sorted().findFirst();</span><br><span class="line">        System.out.println(<span class="string">"findFirst() 메소드의 결과 : "</span>+result1.getAsInt());</span><br><span class="line"></span><br><span class="line">        OptionalInt result2 = stream2.sorted().findAny();</span><br><span class="line">        System.out.println(<span class="string">"findAny() 메소드의 결과 : "</span>+result2.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">findFirst() 메소드의 결과 : <span class="number">1</span></span><br><span class="line">findAny() 메소드의 결과 : <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-검사">요소의 검사</h2>
<p>해당 스트림의 요소 중에서 특정 조건을 만족하는 요소가 있는지, 아니면 모두 만족하거나 모두 만족하지 않는지를 다음 메소드를 사용하여 확인할 수 있습니다.</p>
<ol>
<li>anyMatch() : 해당 스트림의 일부 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>allMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족할 경우에 true를 반환함.</li>
<li>noneMatch() : 해당 스트림의 모든 요소가 특정 조건을 만족하지 않은 경우에 true를 반환함.</li>
</ol>
<p>세 메소드 모두 인수로 <strong>Predicate</strong> 객체를 전달받으며, 요소의 검사 결과는 boolean값으로 반환합니다.</p>
<p>다음 예제는 스트림의 모든 요소를 검사하여 80보다 큰 값을 가지는 요소가 하나라도 존재하는지를 검사하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// stream1의 요소 중 어느 하나라도 80보다 크면 true 반환</span></span><br><span class="line">        System.out.println(stream1.anyMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">        <span class="comment">// stream2의 요소 중 모든 요소가 80보다 크면 treu 반환 </span></span><br><span class="line">        System.out.println(stream2.allMatch(n -&gt; n &gt; <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-통계-연산">요소의 통계, 연산</h2>
<blockquote>
<p>통계</p>
</blockquote>
<ul>
<li>count() : 해당 스트림의 요소의 총 개수를 long 타입의 값으로 반환합니다.</li>
<li>max(), min() : 해당 스트림의 요소 중에서 가장 큰 값과 가장 작은 값을 가지는 요소를 참조하는 Optional 객체를 얻을 수 있습니다. <strong>원하는 Int값을 얻기 위해서는 getAsInt() 메소드를 사용하면 Int 값을 얻을 수 있습니다.</strong></li>
</ul>
<blockquote>
<p>연산</p>
</blockquote>
<p><strong>IntStream이나 DoubleStream과 같은 기본 타입 스트림에는 해당 스트림의 모든 요소에 대해 합과 평균을 구할 수 있는 sum()과 average() 메소드가 각각 정의되어 있습니다. 이때 average() 메소드는 각 기본 타입으로 래핑된 Optional 객체를 반환하므로, Int값을 얻기 위해서는 getAsInt() 메소드를 사용해서 얻을 수 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.DoubleStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream1 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        IntStream stream2 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line">        DoubleStream stream3 = DoubleStream.of(<span class="number">30.3</span>, <span class="number">90.9</span>, <span class="number">70.7</span>, <span class="number">10.1</span>);</span><br><span class="line">        IntStream stream4 = IntStream.of(<span class="number">30</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"count() 메소드 호출 : "</span>+stream1.count());</span><br><span class="line">        System.out.println(<span class="string">"min() 메소드 호출 : "</span>+stream2.min().getAsInt());</span><br><span class="line">        <span class="comment">//System.out.println(stream2.max().getAsInt());</span></span><br><span class="line">        System.out.println(<span class="string">"average() 메소드 호출 : "</span>+stream3.average().getAsDouble());</span><br><span class="line">        System.out.println(<span class="string">"sum() 메소드 호출 : "</span>+stream4.sum());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">count() 메소드 호출 : <span class="number">4</span></span><br><span class="line">min() 메소드 호출 : <span class="number">10</span></span><br><span class="line">average() 메소드 호출 : <span class="number">50.5</span></span><br><span class="line">sum() 메소드 호출 : <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="요소의-수집">요소의 수집</h2>
<p><code>collect()</code> 메소드는 인수로 전달되는 Collectors 객체에 구현된 방법대로 스트림의 요소를 수집합니다. 또한, Collectors 클래스에는 미리 정의된 다양한 방법이 클래스 메소드로 정의되어 있습니다. 이 외에도 사용자가 직접 Collector 인터페이스를 구현하여 자신만의 수집 방법을 정의할 수도 있습니다.</p>
<p>스트림 요소의 수집 용도별 사용할 수 있는 Collectors 메소드는 다음과 같습니다.</p>
<ol>
<li>스트림을 배열이나 컬렉션으로 변환 : toArray(), toCollection(), toList(), toSet(), toMap()</li>
<li>요소의 통계와 연산 메소드와 같은 동작을 수행 : counting(), maxBy(), minBy(), summingInt(), averagingInt() 등</li>
<li>요소의 소모와 같은 동작을 수행 : reducing(), joining()</li>
<li>요소의 그룹화와 분할 : groupingBy(), partitioningBy()</li>
</ol>
<p>다음 예제는 collect() 메소드를 이용하여 해당 스트림을 리스트로 변환하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"넷"</span>,<span class="string">"둘"</span>,<span class="string">"하나"</span>,<span class="string">"셋"</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">        Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">넷</span><br><span class="line">둘</span><br><span class="line">하나</span><br><span class="line">셋</span><br></pre></td></tr></table></figure>
<p>다음 예제는 Collectors 클래스의 partitioningBy() 메소드를 이용하여 해당 스트림의 각 요소별 글자 수에 따라 홀수와 짝수로 나누어 저장하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"JAVA"</span>, <span class="string">"PHP"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;Boolean, List&lt;String&gt;&gt; partition = stream.collect(Collectors.partitioningBy(s-&gt;(s.length() % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 홀수인 List</span></span><br><span class="line">        List&lt;String&gt; oddList = partition.get(<span class="keyword">false</span>);</span><br><span class="line">        System.out.println(oddList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 문자열의 길이가 짝수인 Lists</span></span><br><span class="line">        List&lt;String&gt; evenList = partition.get(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(evenList);</span><br><span class="line"></span><br><span class="line">        System.out.println(partition);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">[CSS, PHP]</span><br><span class="line">[HTML, JAVA]</span><br><span class="line">&#123;<span class="keyword">false</span>=[CSS, PHP], <span class="keyword">true</span>=[HTML, JAVA]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="대표적인-최종-연산-메소드">대표적인 최종 연산 메소드</h2>
<p>스트림 API에서 사용할 수 있는 대표적인 최종 연산을 위한 메소드는 다음과 같습니다.</p>
<img src="/img/stream_final_method.png" width="800" height="300">
<h1 id="optional-클래스">Optional 클래스</h1>
<hr>
<p>Optional<t> 클래스는 Integer나 Double 클래스처럼 ‘T’ 타입의 객체를 포장해 주는 래퍼(Wrapper class)입니다. 따라서 Optional 인스턴스는 모든 타입의 참조 변수를 저장할 수 있습니다.</t></p>
<p><strong>이러한 Optional 객체를 사용하면 예상치 못한 NullPointerException 예외를 제공되는 메소드로 간단히 회피할 수 있습니다. 즉, 복잡한 조건문 없이도 널(null) 값으로 인해 발생하는 예외를 처리할 수 있게 됩니다.</strong></p>
<h2 id="optional-객체의-생성">Optional 객체의 생성</h2>
<p>of() 메소드나 ofNullable() 메소드를 사용하여 Optional 객체를 생성할 수 있습니다.</p>
<p>of() 메소드는 null이 아닌 명시된 값을 가지는 Optional 객체를 반환합니다. 만약 of() 메소드를 통해 생성된 Optional 객체에 null이 저장되면 <strong>NullPointerException</strong> 예외가 발생합니다.</p>
<p>따라서 만약 참조 변수의 값이 만에 하나 null이 될 가능성이 있다면, ofNullable() 메소드를 사용하여 Optional 객체를 생성하는 것이 좋습니다.<br>
ofNullable() 메소드는 명시된 값이 null이 아니면 명시된 값을 가지는 Optional 객체를 반환하며, 명시된 값이 null이면 비어있는 Optional 객체를 반환합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line">        Optional&lt;String&gt; opt2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt);</span><br><span class="line">        System.out.println(opt2);</span><br><span class="line"></span><br><span class="line">        System.out.println(opt.get());</span><br><span class="line">        <span class="comment">//System.out.println(opt2.get()); 에러발생</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">Optional[자바 공부 중]</span><br><span class="line">Optional.empty</span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<h2 id="optional-객체에-접근">Optional 객체에 접근</h2>
<p>get() 메소드를 사용하면 Optional 객체에 저장된 값에 접근할 수 있습니다. 만약 Optional 객체에 저장된 값이 null이면, <code>NoSuchElementException</code> 예외가 발생합니다. <strong>따라서 get() 메소드를 호출하기 전에 isPresent() 메소드를 사용하여 Optional 객체에 저장된 값이 null인지 아닌지를 먼저 확인한 후 호출하는 것이 좋습니다.</strong></p>
<p>다음 예제는 isPresent() 메소드를 이용하여 좀 더 안전하게 Optional 객체에 저장된 값에 접근하는 예제입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.ofNullable(<span class="string">"자바 공부 중"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt.isPresent())&#123;</span><br><span class="line">            System.out.println(opt.get());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"opt 객체는 null입니다."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">자바 공부 중</span><br></pre></td></tr></table></figure>
<p>또한, 아래와 같은 메소드를 사용하여 null 대신에 대체할 값을 지정할 수도 있습니다.</p>
<ol>
<li>orElse() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 값을 반환함.</li>
<li>orElseGet() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 람다 표현식의 결과값을 반환함.</li>
<li>orElseThrow() 메소드 : 지정된 값이 존재하면 그 값을 반환하고, 값이 존재하지 않으면 인수로 전달된 예외를 발생시킴</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Optional&lt;String&gt; opt = Optional.empty(); <span class="comment">// Optional를 null로 초기화함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(opt.orElse(<span class="string">"빈 Optional 객체"</span>));</span><br><span class="line">        System.out.println(opt.orElseGet(String::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">빈 Optional 객체</span><br></pre></td></tr></table></figure>
<blockquote>
<p>empty() 메소드는 Optional 객체를 null로 초기화해줍니다.</p>
</blockquote>
<h2 id="기본-타입의-optional-클래스">기본 타입의 Optional 클래스</h2>
<p>자바에서는 IntStream 클래스와 같이 기본 타입 스트림을 위한 별도의 Optional 클래스를 제공하고 있습니다.</p>
<ol>
<li>OptionalInt 클래스</li>
<li>OptionalLong 클래스</li>
<li>OptionalDouble 클래스</li>
</ol>
<p>이러한 클래스는 반환 타입이 Optional<t> 타입이 아니라 해당 기본 타입이라는 사실만 제외하면 거의 모든 면에서 비슷합니다.</t></p>
<p>또한, Optional 객체에서 get() 메소드를 사용하여 저장된 값에 접근할 수 있는 것처럼 클래스별로 저장된 값에 접근할 수 있는 다음과 같은 메소드를 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스</th>
<th style="text-align:center">저장된 값에 접근하는 메소드</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Optional<t></t></td>
<td style="text-align:center">T get()</td>
</tr>
<tr>
<td style="text-align:center">OptionalInt</td>
<td style="text-align:center">int getAsInt()</td>
</tr>
<tr>
<td style="text-align:center">OptionalLong</td>
<td style="text-align:center">long getAsLong()</td>
</tr>
<tr>
<td style="text-align:center">OptionalDouble</td>
<td style="text-align:center">double getAsDouble()</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.util.OptionalInt;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">streamExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IntStream stream = IntStream.of(<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        OptionalInt result = stream.findFirst();</span><br><span class="line">        </span><br><span class="line">        System.out.println(result.getAsInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="optional-메소드">Optional 메소드</h2>
<img src="/img/optional_method.png" width="800" height="300">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/04/java-basic-18/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-17/"
                            aria-label=": [Java] 17. 람다표현식"
                        >
                            [Java] 17. 람다표현식
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T17:06:06+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="람다-표현식">람다 표현식</h1>
<hr>
<p><strong>람다 표현식(lambda expression)이란 간단히 말해서 메소드를 하나의 식으로 표현한 것을 말합니다.</strong> 기존의 메소드는 아래와 같이 작성합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>람다 표현식으로 위의 코드를 표현하면 아래와 같습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br></pre></td></tr></table></figure>
<p>위의 예제처럼 메소드를 람다 표현식으로 표혀하면, 클래스를 작성하고 객체를 생성하지 않아도 메소드를 사용할 수 있습니다.</p>
<p>그런데 자바에서는 클래스의 선언과 동시에 객체를 생성하므로, 단 하나의 객체만을 생성할 수 있는 클래스를 익명 클래스라고 합니다. 따라서 자바에서 람다 표현식은 익명 클래스와 같다고 할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line">(x,y) -&gt; x &lt; y ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 익명 클래스</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 람다 표현식은 메소드의 매개변수로 전달될 수도 있으며, 메소드의 결과값으로 반환될 수도 있습니다. 따라서 람다 표현식을 사용하면, 기존의 불필요한 코드를 줄여주고, 작성된 코드의 가독성을 높여줍니다. Java SE 8부터는 이러한 람다 표현식을 사용하여 자바에서도 함수형 프로그래밍을 할 수 있게 되었습니다.</p>
<h2 id="람다-표현식-작성">람다 표현식 작성</h2>
<p>화살표( -&gt; ) 기호를 사용하여 람다 표현식을 작성할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(매개변수 목록) -&gt; &#123; 함수 몸체 &#125;</span><br></pre></td></tr></table></figure>
<p>자바에서 람다 표현식을 작성할 때 유의해야 할 사항은 다음과 같습니다.</p>
<ol>
<li>매개변수의 타입을 추론할 수 있는 경우에는 타입을 생략할 수 있습니다.</li>
<li>매개변수가 하나인 경우에는 괄호 () 를 생략할 수 있습니다.</li>
<li>함수의 몸체가 하나의 명령문만으로 이루어진 경우에는 중괄호 {} 를 생략할 수 있습니다. (이 때, 세미콜론(;)은 붙이지 않음)</li>
<li>함수의 몸체가 하나의 return문으로만 이루어진 경우에는 중괄호 {} 를 생략할 수 없습니다.</li>
<li>return 문 대신 표현식을 사용할 수 있으며, 이때 반환값은 표현식의 결과값이 됩니다.(이때 세미콜론(;)은 붙이지 않음)</li>
</ol>
<p>다음은 전통적인 방식의 스레드 생성과 람다 표현식을 사용한 스레드의 생성을 비교하는 코드입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"전통적인 방식의 일회용 스레드 생성"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"람다 표현식을 사용한 일회용 스레드 생성"</span>)</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">전통적인 방식의 일회용 스레드 생성</span><br><span class="line">람다 표현식을 사용한 일회용 스레드 생성</span><br></pre></td></tr></table></figure>
<blockquote>
<p>람다 표현식을 사용하면 불피요한 코드를 줄일 수 있으며, 코드의 가독성이 훨씬 좋아집니다.</p>
</blockquote>
<h2 id="함수형-인터페이스functional-interface">함수형 인터페이스(functional interface)</h2>
<p>람다 표현식을 사용할 때는 람다 표현식을 저장하기 위한 참조 변수의 타입을 결정해야만 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">참조변수의타입 참조변수의이름 = 람다 표현식</span><br></pre></td></tr></table></figure>
<p><strong>위의 문법처럼 람다 표현식을 하나의 변수에 대입할 때 사용하는 참조 변수의 타입을 함수형 인터페이스라고 부릅니다.</strong></p>
<p>함수형 인터페이스는 추상 클래스와는 달리 단 하나의 추상 메소드만을 가져야 합니다. 또한, 다음과 같은 어노테이션(annotation)을 사용하여 함수형 인터페이스임을 명시할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 어노테이션을 인터페이스의 선언 앞에 붙이면, 컴파일러는 해당 인터페이스를 함수형 인터페이스로 인식합니다. 자바 컴파일러는 이렇게 명시된 함수형 인터페이스에 두 개 이상의 메소드가 선언되면 오류를 발생시킵니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span> </span>&#123; <span class="comment">// 함수형 인터페이스의 선언</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda02</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Calc minNum = (x, y) -&gt; x &lt; y ? x : y; <span class="comment">// 추상 메소드의 구현</span></span><br><span class="line">        System.out.println(minNum.min(<span class="number">3</span>, <span class="number">4</span>));  <span class="comment">// 함수형 인터페이스의 사용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>자바는 java.util.function 패키지를 통해 여러 상황에서 사용할 수 있는 다양한 함수형 인터페이스를 미리 정의하여 재공합니다.</p>
<h1 id="메소드-참조">메소드 참조</h1>
<hr>
<p>메소드 참조(method reference)는 람다 표현식이 단 하나의 메소드만을 호출하는 경우에 해당 람다 표현식에서 불필요한 매개변수를 제거하고 사용할 수 있도록 해줍니다.</p>
<p>메소드 참조를 사용하면 불필요한 매개변수를 제거하고 다음과 같이 ‘::’ 기호를 사용하여 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문법</span></span><br><span class="line">클래스이름::메소드이름</span><br><span class="line">또는</span><br><span class="line">참조변수이름::메소드이름</span><br></pre></td></tr></table></figure>
<p>다음 코드는 두 개의 값을 전달받아 제곱 연산을 수행하는 Math 클래스의 클래스 메소드인 pow() 메소드를 호출하는 람다 표현식입니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(base, exponent) -&gt; Math.pow(base, exponent);</span><br><span class="line"><span class="comment">// 위의 식은 단순히 Math 클래스의 pow() 메소드로 인수를</span></span><br><span class="line"><span class="comment">// 전달하는 역할만 하므로, 메소드 참조를 사용해 다음과 같이 표현 가능</span></span><br><span class="line">Math::pow;</span><br></pre></td></tr></table></figure>
<p>또한, 특정 인스턴스의 메소드를 참조할 때에도 참조 변수의 이름을 통해 메소드 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass;</span><br><span class="line">Function&lt;String, Boolean&gt; func = (a) -&gt; obj.equals(a); <span class="comment">// 람다 표현식</span></span><br><span class="line">Function&lt;String, Boolean&gt; func = obj::equals(a);       <span class="comment">// 메소드 참조</span></span><br></pre></td></tr></table></figure>
<p>다음 코드는 람다 표현식과 메소드 참조를 비교하는 코드입니다. 아래의 코드에서 차이를 확인할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DoubleUnaryOperator oper;</span><br><span class="line"></span><br><span class="line">oper = (n) -&gt; Math.abs(n); <span class="comment">// 람다 표현식</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">oper = Math::abs; <span class="comment">// 메소드 참조</span></span><br><span class="line">System.out.println(oper.applyAsDouble(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>DoubleUnaryOperator 인터페이스는 한 개의 double 형 매개변수를 전달받아 한 개의 double 형 값을 반환하는 java.util.function 패키지에서 제공하는 함수형 인터페이스입니다.</p>
</blockquote>
<h2 id="생성자-참조">생성자 참조</h2>
<p>생성자를 호출하는 람다 표현식도 앞서 살펴본 메소드 참조를 이용할 수 있습니다. 즉, 단순히 객체를 생성하고 반환하는 람다 표현식은 생성자 참조로 변환할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a) -&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Object(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드는 단순히 Object 클래스의 인스턴스를 생성하고 반환하기만 하므로, 생성자 참조를 사용하여 다음처럼 간단하게 표현할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>
<p>이때, 해당 생성자가 존재하지 않으면 컴파일 시 오류가 발생합니다. 또한, 배열을 생성할 때에도 다음과 같이 생성자 참조를 사용할 수 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func1 = a -&gt; <span class="keyword">new</span> <span class="keyword">double</span>[a];</span><br><span class="line"><span class="comment">// 람다 표현식</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer, <span class="keyword">double</span>[]&gt; func2 = <span class="keyword">double</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 생성자 참조</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-17/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-16/"
                            aria-label=": [Java] 16. 스레드"
                        >
                            [Java] 16. 스레드
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T12:48:43+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="프로세스process란">프로세스(process)란?</h1>
<hr>
<p><strong>프로세스란 단순히 실행 중인 프로그램이라고 할 수 있습니다. 즉, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말합니다. 이러한 프로세스는 프로그램에 사용되는 데이터와 메모리 등의 자원 그리고 스레드로 구성됩니다.</strong></p>
<h1 id="스레드thread란">스레드(thread)란?</h1>
<hr>
<p>스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행합니다. 또한, 두 개 이상의 스레드를 가지는 프로세스를 멀티스레드 프로세스(multi-threaded process)라고 합니다.</p>
<h2 id="스레드의-생성과-실행">스레드의 생성과 실행</h2>
<p>자바에서 스레드를 생성하는 방법에는 다음과 같은 두 가지 방법이 있습니다.</p>
<ol>
<li>Runnable 인터페이스를 구현하는 방법</li>
<li>Thread 클래스를 상속받는 방법</li>
</ol>
<p>두 방법 모두 스레드를 통해 작업하고 싶은 내용을 run()이라는 메소드에 작성하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ThreadWithClass thread1 = <span class="keyword">new</span> ThreadWithClass();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// Runnable을 구현한 클래스는 Thread가 없기 때문에 Thread 타입으로 객체를 만들고 구현한 클래스를</span></span><br><span class="line">        <span class="comment">// 생성자에 매개변수로 넣는다.</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thread 클래스를 상속받아 Thread 구현</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithClass</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread를 상속받아 구현 : "</span>+getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Thread를 상속받아 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>위의 결과를 보면, 생성된 스레드가 서로 번갈아가며 실행되고 있는 것을 확인할 수 있습니다. 스레드의 실행은 어떤 것이 먼저 실행되는 것인지 정해져 있지 않습니다. 그리고 Thread의 실행은 start()라는 메소드를 호출함으로써 실행시킬 수 있습니다.</p>
<p>Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없으므로, 일반적으로 Runnable 인터페이스를 구현하는 방법으로 스레드를 생성합니다.</p>
<blockquote>
<p>Runnable 인터페이스는 몸체가 없는 메소드인 run() 메소드 단 하나만을 가지는 간단한 인터페이스입니다.</p>
</blockquote>
<h2 id="스레드-우선순위">스레드 우선순위</h2>
<p>자바에서 각 스레드는 <code>우선순위(priority)</code>에 관한 자신만의 필드를 가지고 있습니다. 이러한 우선순위에 따라 특정 스레드가 더 많은 시간 동안 작업을 할 수 있도록 설정할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">필드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static int MAX_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최대 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int MIN_PRIORITY</td>
<td style="text-align:center">스레드가 가질 수 있는 최소 우선순위를 명시함.</td>
</tr>
<tr>
<td style="text-align:center">static int NORM_PRIORITY</td>
<td style="text-align:center">스레드가 생성될 때 가지는 기본 우선순위를 명시함.</td>
</tr>
</tbody>
</table>
<p>getPriority()와 setPriority() 메소드를 통해 스레드의 우선순위를 반환하거나 변경할 수 있습니다. 스레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, <strong>숫자가 높을수록 우선순위 또한 높아집니다.</strong></p>
<p><strong>하지만 스레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐입니다. 우선순위가 10인 스레드가 우선순위가 1인 스레드보다 10배 더 빨리 수행되는 것이 아닙니다. 단지 우선순위가 10인 스레드는 우선순위가 1인 스레드보다 좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐입니다.</strong></p>
<p>그리고 스레드의 우선순위는 해당 스레드를 생성한 스레드의 우선순위를 상속받게 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">      </span><br><span class="line">        thread2.setPriority(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 1 : thread-1의 우선순위를 10으로 변경함</span></span><br><span class="line"></span><br><span class="line">        thread1.start(); <span class="comment">// 2 : thread-0 실행</span></span><br><span class="line">        thread2.start(); <span class="comment">// 3 : thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getPriority());</span><br><span class="line">        System.out.println(thread2.getPriority());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Runnable 인터페이스를 구현 : "</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 현재 실행 중인 스레드의 이름을 반환</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">1</span></span><br><span class="line">Runnable 인터페이스를 구현 : Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>main() 메소드를 실행하는 스레드의 우선순위는 언제나 5이므로, main() 메소드 내에서 생성된 스레드는 Thread-0의 우선순위는 5로 설정되는 것을 확인할 수 있습니다.</p>
<p>위의 코드에서 2번 라인에서 Thread-0이 먼저 실행되고, 3번 라인에서 Thread-1이 나중에 실행됩니다. 따라서 만약 1번 라인이 존재하지 않는다면, Thread-0이 먼저 실행되고, Thread-1이 나중에 실행될 것입니다. 하지만 1번 라인에서 Thread-1의 우선순위를 10으로 변경했기 때문에, Thread-1이 나중에 실행되었더라도 우선순위가 Thread-0보다 높아서 먼저 실행되는 것입니다.</p>
<h1 id="멀티-스레드multi-thread">멀티 스레드(multi thread)</h1>
<hr>
<p>스레드와 관련된 내용은 운영체제(OS)와 연관된 내용입니다. 그래서 여기에서는 간단하게 알아보고 추후에 운영체제 공부를 할 때 자세하게 포스팅하겠습니다. :)</p>
<p>일반적으로 하나의 프로세스는 하나의 스레드를 가지고 작업을 수행하게 됩니다. 하지만 멀티 스레드(multi trhead)란 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것을 의미합니다.<br>
또한, 멀티 프로세스(multi process)는 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것을 의미합니다.</p>
<p>멀티 스레드와 멀티 프로세스 모두 여러 흐름을 동시에 수행한다는 공통점을 가지고 있습니다. 멀티 프로세스는 각 프로세스가 독립적인 메모리를 가지고 별도로 실행되지만, <strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유한다는 점이 다릅니다.</strong></p>
<p><strong>멀티 스레드는 각 스레드가 자신이 속한 프로세스의 메모리를 공유하므로, 시스템 자원의 낭비가 적습니다. 또한, 하나의 스레드가 작업을 할 때 다른 스레드가 별도의 작업을 할 수 있어 사용자와의 응답성도 좋아집니다.</strong></p>
<h2 id="문맥-교환context-switching">문맥 교환(context switching)</h2>
<p>컴퓨터에서 동시에 처리할 수 있는 최대 작업 수는 CPU의 코어(core) 수와 같습니다. 만약 CPU의 코어 수보다 더 많은 스레드가 실행되면, 각 코어가 정해진 시간 동안 여러 작업을 번갈아가며 수행하게 됩니다.</p>
<p>이 때, 각 스레드가 서로 교체될 때 스레드 간의 <code>문맥 교환(context switching)</code>이라는 것이 발생합니다. <strong>문맥 교환이란 현재까지의 작업 상태나 다음 작업에 필요한 각종 데이터를 저장하고 읽어오는 작업을 가리킵니다.</strong></p>
<p><strong>이러한 문맥 교환에 걸리는 시간이 커지면 커질수록, 멀티 스레딩의 효율은 저하됩니다. 오히여 많은 양의 단순한 계산은 싱글 스레드로 동작하는 것이 더 효율적일 수 있습니다. 따라서 많은 수의 스레드를 실행하는 것이 언제나 좋은 성능을 보이는 것은 아니라는 점을 유의해야 합니다.</strong></p>
<h2 id="스레드-그룹thread-group">스레드 그룹(thread group)</h2>
<p><code>스레드 그룹(thread group)이란 서로 관련이 있는 스레드를 하나의 그룹으로 묶어 다루기 위한 장치입니다.</code> 자바에서는 스레드 그룹을 다루기 위해 ThreadGroup라는 클래스를 제공합니다.</p>
<p>이러한 스레드 그룹은 다른 스레드 그룹을 포함할 수도 있으며, 이렇게 포함된 스레드 그룹은 트리 형태로 연결됩니다. 이 때, 스레드는 자신이 포함된 스레드나 그 하위 그룹에는 접근할 수 있지만 다른 그룹에는 접근할 수 없습니다.<br>
<strong>이렇게 스레드 그룹은 스레드가 접근할 수 있는 범위를 제한하는 보안상으로도 중요한 역할을 하고 있습니다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.start(); <span class="comment">// thread-0 실행</span></span><br><span class="line">        System.out.println(thread0.getThreadGroup());</span><br><span class="line"></span><br><span class="line">        ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"MyThread"</span>);</span><br><span class="line">        <span class="comment">// MyThread라는 스레드 그룹 생성</span></span><br><span class="line">        threadGroup.setMaxPriority(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 해당 스레드 그룹의 최대 우선순위를 7로 설정함</span></span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(threadGroup, <span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        <span class="comment">// 스레드를 생성할 때 포함될 스레드 그룹을 전달할 수 있다.</span></span><br><span class="line">        thread1.start(); <span class="comment">// thread-1 실행</span></span><br><span class="line">        System.out.println(thread1.getThreadGroup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line">java.lang.ThreadGroup[name=main,maxpri=<span class="number">10</span>]</span><br><span class="line">java.lang.ThreadGroup[name=MyThread,maxpri=<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 main() 메소드에서 생성된 스레드의 기본 스레드 그룹의 이름은 <strong>main</strong>이 되며, 최대 우선순위는 10으로 자동 설정됩니다.</p>
<h2 id="데몬-스레드deamon-thread">데몬 스레드(deamon thread)</h2>
<p><strong>데몬 스레드(deamo thread)란 다른 일반 스레드의 작업을 돕는 보조적인 역할을 하는 스레드를 가리킵니다. 따라서 데몬 스레드는 일반 스레드가 모두 종료되면 더는 할 일이 없으므로, 데몬 스레드 역시 자동으로 종료됩니다.</strong></p>
<p>데몬 스레드의 생성 방법과 실행 방법은 모두 일반 스레드와 같습니다. 단, 실행하기 전에 <code>setDaemon()</code> 메소드를 호출하여 데몬 스레드로 설정하기만 하면 됩니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadGroupExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadWithRunnable());</span><br><span class="line">        thread0.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 데몬 스레드로 설정</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runnable 인터페이스를 구현해서 Thread를 생성하기 위함</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadWithRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이러한 데몬 스레드는 일정 시간마다 자동으로 수행되는 저장 및 화면 갱신 등에 이용되고 있습니다.</p>
<h2 id="가비지-컬렉터garbage-collector">가비지 컬렉터(garbage collector)</h2>
<blockquote>
<p>가비지 컬렉터는 자바에서 중요한 개념으로 알고 있습니다. 이 부분에 대한 심화된 내용은 별도의 포스트에서 소개할 예정이고, 이번에는 간단하게 알고 넘어가도록 하겠습니다.</p>
</blockquote>
<p><strong>데몬 스레드를 이용하는 가장 대표적인 예로 가비지 컬렉터(garbage collector)를 들 수 있습니다. 가비지 컬렉터(garbage collector)란 프로그래머가 동적으로 할당한 메모리 중 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제해 주는 데몬 스레드입니다.</strong></p>
<p>자바에서는 프로그래머가 메모리에 직접 접근하지 못하게 하는 대신에 가비지 컬렉터가 자동으로 메모리를 관리해 줍니다. 이러한 가비지 컬렉터를 이용하면 프로그래밍을 하기가 훨씬 쉬워지며, 메모리에 관련된 버그가 발생할 확률도 낮아집니다.</p>
<p>보통 가비지 컬렉터가 동작하는 동안에는 프로세서가 일시적으로 중지되므로, 필연적으로 성능의 저하가 발생합니다. 하지만 요즘에는 가비지 컬렉터의 성능이 많이 향상되어, 새롭게 만들어지는 대부분의 프로그래밍 언어에서 가비지 컬렉터를 제공하고 있습니다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-16/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/09/03/java-basic-15/"
                            aria-label=": [Java] 15. 입력과 출력"
                        >
                            [Java] 15. 입력과 출력
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-09-03T10:51:33+09:00">
	
		    Sep 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스트림">스트림</h1>
<hr>
<p><strong>자바에서는 파일이나 콘솔의 입출력을 직접 다루지 않고, 스트림(stream)이라는 흐름을 통해 다룹니다.</strong></p>
<p>스트림(stream)이란 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름을 의미합니다. 즉, 스트림은 운영체제에 의해 생성되는 가상의 연결고리를 의미하며, 중간 매개자 역할을 합니다.</p>
<img src="/img/stream.png" width="500" height="200">
<p>Java SE 8 버전부터 추가된 스트림 API는 앞서 설명한 스트림과는 전혀 다른 개념입니다. 스트림 API는 추후에 포스팅할 예정입니다. ^0^</p>
<h2 id="입출력-스트림">입출력 스트림</h2>
<p><strong>스트림은 한 방향으로만 통신할 수 있으므로, 입력과 출력을 동시에 처리할 수는 없습니다. 따라서 스트림은 사용 목적에 따라 입력 스트림과 출력 스트림으로 구분됩니다.</strong></p>
<p>자바에서는 <a href="http://java.io" target="_blank" rel="noopener">java.io</a> 패키지를 통해 InputStream과 OutputStream 클래스를 별도로 제공하고 있습니다. 즉, 자바에서의 스트림 생성이란 이러한 스트림 클래스 타입의 인스턴스를 생성한다는 의미입니다.</p>
<p><strong>InputStream</strong> 클래스에는 read() 메소드가, <strong>OutputStream</strong> 클래스에는 write() 메소드가 각각 추상 메소드로 포함되어 있습니다. 사용자는 이 두 메소드를 상황에 맞게 적절히 구현해야만 입출력 스트림을 생성하여 사용할 수 있습니다.</p>
<img src="/img/stream_class.png" width="500" height="200">
<blockquote>
<p>read() 메소드는 해당 입력 스트림에서 더 이상 읽어들일 바이트가 없으면 -1을 반환해야 합니다. 그런데 반환 타입을 byte 타입으로 하면 0 ~ 255까지의 바이트 정보는 표현할 수 있지만 -1은 표현할 수 없게 됩니다. 따라서 InputStream의 read() 메소드는 반환 타입을 int형으로 선언하고 있습니다.</p>
</blockquote>
<h2 id="바이트-기반-스트림">바이트 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 자바에서는 아래와 같이 다양한 바이트 기반의 입출력 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FileInputStream</td>
<td style="text-align:center">FileOutputStream</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:left">ByteArrayInputStream</td>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:left">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:left">AudioInputStream</td>
<td style="text-align:center">AudioOutputStream</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<h2 id="보조-스트림">보조 스트림</h2>
<p>자바에서 제공하는 보조 스트림은 실제로 데이터를 주고 받을 수는 없지만, 다른 스트림의 기능을 향상시키거나 새로운 기능을 추가해 주는 스트림입니다. 자바에서는 아래와 같은 다양한 보조 스트림을 제공하고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterInputStream</td>
<td style="text-align:center">FilterOutputStream</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center">입출력 스트림으로부터 자바의 기본 타입으로 데이터를 읽어올 수 있게함.</td>
</tr>
<tr>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center">데이터를 객체 단위로 읽거나, 읽어 들인 객체를 역직렬화시킴</td>
</tr>
<tr>
<td style="text-align:center">SequenceInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">두 개의 입력 스트림을 논리적으로 연결함.</td>
</tr>
<tr>
<td style="text-align:center">PushbackInputStream</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h2 id="문자-기반-스트림">문자 기반 스트림</h2>
<p>자바에서 스트림은 기본적으로 바이트 단위로 데이터를 전송합니다. 하지만 자바에서 가장 작은 타입인 char 형이 2바이트이므로, 1바이트씩 전송되는 바이트 기반 스트림으로는 원활한 처리가 힘든 경우가 있습니다.</p>
<p>따라서 자바에서는 바이트 기반 스트림뿐만 아니라 문자 기반의 스트림도 별도로 제공합니다. <strong>이러한 문자 기반 스트림은 기존의 바이트 기반 스트림에서 InputStream을 Reader로, OutputStream을 Writer로 변경하면 사용할 수 있습니다.</strong></p>
<p>다음은 다양한 문자 기반의 입출력 스트림을 보여주고 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">입출력 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
<td style="text-align:center">파일</td>
</tr>
<tr>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
<td style="text-align:center">메모리</td>
</tr>
<tr>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
<td style="text-align:center">프로세스</td>
</tr>
<tr>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
<td style="text-align:center">오디오 장치</td>
</tr>
</tbody>
</table>
<p>지금까지 살펴본 바이트 기반의 스트림과 문자 기반의 스트림은 활용 방법이 거의 같습니다. 따라서 문자 기반의 보조 스트림도 다음과 같이 제공됩니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">입력 스트림</th>
<th style="text-align:center">출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">FilterWriter</td>
<td style="text-align:center">필터를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
<td style="text-align:center">버퍼를 이용한 입출력</td>
</tr>
<tr>
<td style="text-align:center">PushbackReader</td>
<td style="text-align:center">X</td>
<td style="text-align:center">다른 입력 스트림에 버퍼를 이용하여 push back이나 unread와 같은 기능을 추가함.</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">PrintWriter</td>
<td style="text-align:center">다른 출력 스트림에 버퍼를 이용하여 다양한 데이터를 출력하기 위한 기능을 추가함.</td>
</tr>
</tbody>
</table>
<h1 id="표준-입출력">표준 입출력</h1>
<hr>
<p>자바에서는 콘솔과 같은 입출력 장치를 위해 System이라는 표준 입출력 클래스를 정의하고 있습니다. java.lang 패키지에 포함되어 있는 System 클래스는 표준 입출력을 위해 다음과 같은 클래스 변수를 제공합니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">클래스 변수</th>
<th style="text-align:center">입출력 스트림</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://System.in" target="_blank" rel="noopener">System.in</a></td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">콘솔로부터 데이터를 입력받는다.</td>
</tr>
<tr>
<td style="text-align:center">System.out</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.</td>
</tr>
<tr>
<td style="text-align:center">System.err</td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center">콘솔로 데이터를 출력한다.(에러를 출력)</td>
</tr>
</tbody>
</table>
<p>표준 입출력 스트림은 자바가 자동으로 생성하므로, 개발자인 우리가 별도로 스트림을 생성하지 않아도 사용할 수 있습니다. &gt;__&lt;</p>
<h2 id="표준-입출력의-대상-변경">표준 입출력의 대상 변경</h2>
<p>앞서 살펴본 세 가지 입출력 스트림은 모두 콘솔과 같은 표준 입출력 장치를 대상으로 합니다. 하지만 이와 같은 스트림에 다음 System 메소드를 사용하면 스트림의 대상을 다른 입출력 장치로 변경할 수 있습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">메소드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static void setIn(InputStream in)</td>
<td style="text-align:center">입력 스트림의 대상을 전달된 입력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setOut(PrintStream out)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
<tr>
<td style="text-align:center">static void setErr(PrintStream err)</td>
<td style="text-align:center">출력 스트림의 대상을 전달된 출력 스트림으로 변경함.</td>
</tr>
</tbody>
</table>
<h2 id="randomaccessfile-클래스">RandomAccessFile 클래스</h2>
<p>앞서 살펴본 다양한 입출력 스트림을 이용하면 파일에 <strong>순차적으로</strong> 입출력 작업을 수행할 수 있습니다. 하지만 순차적인 접근이 아닌 임의의 지점에 접근하여 작업을 수행하고 싶다면, <strong>RandomAccessFile 클래스를 사용하면 됩니다.</strong> 이 클래스는 <code>파일</code>만을 대상으로 하며, 임의의 지점에서 입출력을 동시에 수행할 수 있습니다.</p>
<p>RandomAccessFile 클래스의 생성자에는 인수로 파일의 이름뿐만 아니라 파일 모드까지 함께 전달해야 합니다. 파일 모드란 파일의 사용 용도를 나타내는 문자열로, 자바에서 사용할 수 있는 대표적인 파일 모드는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th style="text-align:center">파일 모드</th>
<th style="text-align:center">설명</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">파일을 오로지 읽는 것만 가능한 모드로 개방함.</td>
</tr>
<tr>
<td style="text-align:center">“rw”</td>
<td style="text-align:center">파일을 읽고 쓰는 것이 모두 가능한 모드로 개방함. 만약 파일이 없으면 새로운 파일을 생성함.</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// "rw" 모드로 "data.txt" 파일을 개방함.</span></span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">        System.out.println(file.getFilePointer()); </span><br><span class="line">        <span class="comment">// 0 : 파일 포인터의 현재 위치를 반환함.</span></span><br><span class="line">        file.writeInt(<span class="number">10</span>);<span class="comment">// 정수 10을 저장함.</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 4</span></span><br><span class="line">        file.seek(<span class="number">20</span>);                        </span><br><span class="line">        <span class="comment">// 파일 포인터의 위치를 20으로 이동시킴.</span></span><br><span class="line">        System.out.println(file.getFilePointer()); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//결과</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getFilePointer() : 파일 포인터의 현재 위치를 확인할 수 있다.</li>
<li>seek() : 파일 포인터의 위치를 변경할 수 있다.</li>
</ul>
<h2 id="file-클래스">File 클래스</h2>
<p>앞서 살펴본 입출력 스트림을 사용하면 파일을 통한 입출력 작업을 수행할 수 있습니다. 하지만 파일의 제거나 디렉터리에 관한 작업 등은 입출력 스트림을 통해서는 수행할 수 없습니다.</p>
<p>자바는 이러한 입출력 작업 이외의 파일과 디렉터리에 관한 작업을 File 클래스를 통해 처리하도록 하고 있습니다. File 클래스에는 다음과 같은 다양한 메소드가 정의되어 있습니다.</p>
<img src="/img/file_class.png" width="800" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">"D:\\data"</span>); <span class="comment">// 디렉토리 생성</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(dir, <span class="string">"data.txt"</span>); </span><br><span class="line">    <span class="comment">// 위에서 생성한 디렉토리에 파일 생성</span></span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">"파일이 존재하지 않습니다."</span>);</span><br><span class="line">        System.out(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.pirntln(file.getPath());</span><br><span class="line">    <span class="comment">// 파일의 경로 반환 : D:\data\data.txt</span></span><br><span class="line">    System.out.println(file.length());</span><br><span class="line">    <span class="comment">// 파일의 크기를 반환함</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">D:\data\data.txt</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/09/03/java-basic-15/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/20/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/22/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 21 of 28</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
