
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2019 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2019/archives/2/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/08/DI/"
                            aria-label=": [Android] DI에 대해서"
                        >
                            [Android] DI에 대해서
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-08T15:09:36+09:00">
	
		    Jul 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="di">DI</h2>
<p><code>Dagger</code>는 DI 프레임워크이다 DI는 Dependency Injection(의존성 주입)의 준말이다. 의존성 주입이란 외부에서 의존 객체를 생성하여 넘겨주는 것을 의미한다. 예를 들어 A class가 B class를 의존할 때 B Object를 A가 직접 생성하지 않고 외부에서 생서아여 넘겨주면 의존성을 주입했다고 할 수 있다.</p>
<img src="/img/di_sample.jpeg" width="500" height="200">
<p>왼쪽은 A에서 B,C를 생성하는 일반적인 의존 형태이고, 오른쪽은 외부에서 의존 객체를 생성하고 주입하는 형태이다.</p>
<p>DI를 위해서는 객체를 생성하고 넘겨주는 외부의 뭔가가 필요하다. 이것이 DI 프레임워크가 하는 일이다. 외부에서 넘겨주는 무언가를 스프링에서는 컨테이너, <code>Dagger</code>에서는 <strong>Component</strong>와 <strong>Module</strong>이라고 부른다. DI는 이렇게 의존성이 있는 객체의 제어를 외부 Framework로 올리면서 IoC 개념을 구현한다. IoC는 Inversion of Control(제어의 역전)의 준말이다.</p>
<img src="/img/di_sample2.jpeg" width="500" height="200">
<p>외부 컨테이너가 객체를 생성하고 주입한다. 제어가 거꾸로 가는 개념을 IoC라고 하고, DI는 IoC를 구현하는 방법 중 하나이다.</p>
<p><strong>DI는 왜 필요할까?</strong></p>
<ol>
<li>의존성 파라미터를 생성자에 작성하지 않아도 되므로 보일러 플레이트 코드를 줄일 수 있다. 이를 통해서 유연한 프로그래밍이 가능하다.</li>
<li>Interface에 구현체를 쉽게 교체하면서 상황에 따라 적절한 행동을 정의할 수 있다. 이것은 특히 Mock 객체와 실제 객체를 바꿔가며 테스트할 때 유용하다. 즉, 테스트 가능한 코드를 작성할 수 있다. 이로 인해 재사용성이 높아지고 유지보수가 용이해진다.</li>
</ol>
<p>DI를 구현하는 방법은 다음과 같다.</p>
<ol>
<li>직접 Provider를 구성해 코드로 작성하는 방법</li>
<li>라이브러리로 넘겨서 처리하도록 하는 방법
<ul>
<li>Dagger2</li>
<li>koin</li>
</ul>
</li>
</ol>
<h2 id="dagger-이해하기">Dagger 이해하기</h2>
<p><strong>1. Inject</strong></p>
<p>의존성 주입을 요청한다. <code>Inject</code> 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다.</p>
<p><strong>2. Component</strong></p>
<p>연결된 Module을 이용하여 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다.</p>
<p><strong>3. Subcomponent</strong></p>
<p>Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위 계층 Component이다. Sub의 Sub도 가능하다. Subcomponent는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고, 없으면 부모로 올라가면서 검색한다.</p>
<p><strong>4. Module</strong></p>
<p>Component에 연결되어 의존성 객체를 생성한다. 생성 후 Scope에 따라 관리도 한다.</p>
<p><strong>5. Scope</strong></p>
<p>생성된 객체의 Lifecycle 범위이다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서 Scope을 보고 객체를 관리한다.</p>
<p>위의 5가지 개념을 따라 Dagger가 의존성을 주입하는 플로우는 다음과 같다.</p>
<img src="/img/di_flow.png" width="700" height="200">
<img src="/img/di_flow2.png" width="700" height="200">
<ul>
<li>Inject로 의존성을 요청하면 Subcomponent에서부터 Module을 검색하고, Scope에 따라 객체를 가져와 주입한다.</li>
</ul>
<p>koin과 관련된 글은 다음의 포스팅을 참고하면 된다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@maryangmin/di-%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%82%AC%EC%9A%A9%EB%B2%95%EA%B9%8C%EC%A7%80-dagger2-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-3332bb93b4b9" target="_blank" rel="noopener">DI 기본개념부터 사용법까지, Dagger2 시작하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/08/DI/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/05/RxJava-Chap07/"
                            aria-label=": [RxJava] Chap07. 디버깅"
                        >
                            [RxJava] Chap07. 디버깅
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-05T23:23:57+09:00">
	
		    Jul 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="디버깅">디버깅</h2>
<p>코딩하는 도중에 로그를 넣는 이유는 잘못되었을 때를 대처하기 위함이다. 하지만 RxJava 코드는 로그를 넣을 수 있는 공간이 없다. Observable로 시작하는 업스트림(upstream)과 그것을 받아서 처리하는 다운스트림(downstream)이 동일한 문장으로 이루어져 있기 때문이다. 즉, 전체 동작을 선언적으로 만들 수 있으므로 전체 맥락에 대한 가독성은 높아지지만 예외 코드를 어떻게 넣어야 하는지에 대한 어려움이 있다.</p>
<p>원래 함수형 프로그래밍은 함수의 부수 효과를 없도록 하는 것이 원칙이지만 doOnXXX() 계열 함수는 오히려 부수 효과를 일으켜서 내가 작성하는 코드가 문제없는지 알아볼 수 있게 도와준다.</p>
<p>이번 Chapter에서 알아보자.</p>
<h2 id="doonxxx-함수">doOnXXX() 함수</h2>
<p>doOnNext(), doOnComplete(), doOnError() 3가지 함수는 Observable의 알림 이벤트에 해당한다. Observable에서 어떤 데이터를 발행할 때는 onNext, 중간에 에러가 발생하면 onError, 모든 데이터를 발행하면 onComplete 이벤트가 발생한다. <strong>어떻게 보면 이 알림 이벤트를 위의 함수가 가로채서 디버깅을 할 수 있도록 도와주는 것이다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnXXX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.e(<span class="string">"onError"</span>, error))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | onNext() | debug = <span class="number">3</span></span><br><span class="line">main | value = <span class="number">3</span></span><br><span class="line">main | onNext() | debug = <span class="number">5</span></span><br><span class="line">main | value = <span class="number">5</span></span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>결과는 위와 같이 나온다. doOnNext(), doOnComplete(), doOnError() 함수를 사용해 로그를 출력해봤다. 모두 main 스레드에서 실행되었고, 실제로 Observable이 구독자에게 발행한 데이터는 value로 표시하였다.</p>
<p>하지만, doOnError() 함수의 동작을 보지 못했다. 다른 예제를 통해서 확인해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnXXX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">                .map(divider -&gt; <span class="number">1000</span> / divider)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.e(<span class="string">"onError()"</span>, error.getMessage()))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">100</span></span><br><span class="line">main | value = <span class="number">100</span></span><br><span class="line">main | onNext() | debug = <span class="number">200</span></span><br><span class="line">main | value = <span class="number">200</span></span><br><span class="line">main | onError() | error = / by zero</span><br><span class="line">io.reactivex.exceptions.OnErrorNotImplementedException: <span class="function">The exception was not handled due to missing onError handler in the <span class="title">subscribe</span><span class="params">()</span> method call. Further reading</span></span><br></pre></td></tr></table></figure>
<p>어떤 수를 0으로 나누려고 하기 때문에 0 데이터가 발행될 때 에러가 발생하는 것을 볼 수 있다.</p>
<h2 id="dooneach-함수">doOnEach() 함수</h2>
<p>onNext, onComplete, onError 이벤트를 각각 처리하는 것이 아니라 한 번에 처리할 수 있기 때문에 편리하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"ONE"</span>, <span class="string">"TWO"</span>, <span class="string">"THREE"</span>)</span><br><span class="line">                .doOnEach(noti -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnNext()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onNext()"</span>, noti.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnComplete()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onComplete()"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnError()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onError()"</span>, noti.getError().getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = ONE</span><br><span class="line">main | value = ONE</span><br><span class="line">main | onNext() | debug = TWO</span><br><span class="line">main | value = TWO</span><br><span class="line">main | onNext() | debug = THREE</span><br><span class="line">main | value = THREE</span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>Notification<t> 객체는 발생한 이벤트의 종류를 알 수 있는 boolean 타입의 isOnNext(), isOnComplete(), isOnError() 함수를 제공한다. onNext()의 경우는 getValue() 함수를 호출하면 발행된 값을 얻을 수 있다. onError() 함수의 경우 getError() 함수를 호출하면 Throwable 객체를 얻을 수 있다.</t></p>
<p><code>doOnEach()</code> 함수는 오직 onNext, onComplete, onNext 이벤트만 처리한다. 그리고 람다식을 잘 활용하여 간결하 코드를 유지하도록 한다.</p>
<h2 id="doonsubscribe-doondispose-기타-함수">doOnSubscribe(), doOnDispose(), 기타 함수</h2>
<p>Observable의 알림 이벤트 중에는 onSubscribe와 onDispose 이벤트도 있다. 각각 Observable을 구독했을 때와 구독 해지했을 때의 이벤트를 처리할 수 있다.</p>
<ul>
<li>doOnSubscribe() : Observable을 구독했을 때 어떤 작업을 할 수 있다. 람다 표현식의 인자로는 구독의 결과로 나오는 Disposable 객체가 제공된다.</li>
<li>doOnDispose() : Observable의 구독을 해지했을 때 호출되며 인자는 Action 객체이다. 여러 스레드에서 Observable을 참조할 수 있기 때문에 Action 객체는 <code>Thread-Safe</code>하게 동작해야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnSubscribe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"2"</span>, <span class="string">"6"</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS), (a, b) -&gt; a)</span><br><span class="line">                .doOnSubscribe(data -&gt; Log.d(<span class="string">"onSubscribe()"</span>))</span><br><span class="line">                .doOnDispose(() -&gt; Log.d(<span class="string">"onDispose"</span>));</span><br><span class="line"></span><br><span class="line">        Disposable d = source.subscribe(Log::i);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">200</span>);</span><br><span class="line">        d.dispose();</span><br><span class="line">        CommonUtils.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | debug = onSubscribe()</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | value = <span class="number">3</span></span><br><span class="line">main | debug = onDispose</span><br></pre></td></tr></table></figure>
<p>한편 doOnSubscribe()와 doOnDispose() 함수를 각각 호출하지 않고 한번에 호출하는 함수인 <code>doOnLifeCycle()</code> 함수가 존재한다. 위의 코드에서 doOnSubscribe()와 doOnDispose() 함수를 빼고 <code>doOnLifeCycle()</code> 함수를 사용하면 된다. 결과는 같다.</p>
<p>또한, <code>doOnTerminate()</code> 함수는 Observable이 끝나는 조건이 onComplete 혹은 onError 이벤트가 발생했을 때 실행하는 함수이다. 정확하게는 onComplete() 혹은 onError() 이벤트 발생 직전에 호출된다.</p>
<p>다음 코드를 통해서 결과를 확인해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnTerminate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"7"</span>)</span><br><span class="line">                .doOnTerminate(() -&gt; Log.d(<span class="string">"onTerminate()"</span>))</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.d(<span class="string">"onError()"</span>, error.getMessage()))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | onNext() | debug = <span class="number">3</span></span><br><span class="line">main | value = <span class="number">3</span></span><br><span class="line">main | onNext() | debug = <span class="number">5</span></span><br><span class="line">main | value = <span class="number">5</span></span><br><span class="line">main | onNext() | debug = <span class="number">7</span></span><br><span class="line">main | value = <span class="number">7</span></span><br><span class="line">main | debug = onTerminate()</span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>onComplete 이벤트가 발생하기 직전에 <code>doOnTerminate()</code> 함수가 호출되는 것을 확인할 수 있다.</p>
<h1 id="예외-처리">예외 처리</h1>
<p>자바에서는 예외를 처리할 때 try-catch문을 사용했지만, RxJava에서는 사용할 수 없다.<br>
사용한다면 다음과 같은 에러를 만나게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OnErrorNotImplementedException</span><br></pre></td></tr></table></figure>
<p>RxJava 내부에서 onError를 함수의 인자로 넘긴다. 따라서 try-catch문을 활용할 수가 없다. 추가로 함수 체인이나 Observable 내부에서 예외가 발생해도 onError 이벤트가 발생하고 try-catch 문으로는 해결할 수 없다.</p>
<h2 id="onerrorretrun-함수">onErrorRetrun() 함수</h2>
<ul>
<li>에러도 어떠한 데이터로 보는 것이 적절하다.</li>
<li>예외가 발생했을 때 에러를 의미하는 다른 데이터로 대체한다.</li>
<li>onError 이벤트는 데이터 흐름이 바로 중단되므로 subscribe() 함수를 호출할 때, onError 이벤트를 처리하는 것은 OOM 같은 중대한 에러가 발생했을 때만 활용한다.</li>
<li>에러가 발생했을 때 내가 원하는 데이터로 대체할 수 있다.</li>
</ul>
<img src="/img/onErrorReturn.png" width="500" height="200">
<p>위의 그림에서 앞의 3개의 데이터가 정상적으로 발행되고 마지막 데이터에서 에러가 발생하는 경우, onErrorReturn() 함수는 인자로 넘겼던 기본ㄱ밧을 대신 발행하고 <strong>onComplete 이벤트가 발생한다. onError() 이벤트는 발생하지 않는다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] grades = &#123;<span class="string">"70"</span>, <span class="string">"60"</span>, <span class="string">"$100"</span>, <span class="string">"93"</span>, <span class="string">"83"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(grades)</span><br><span class="line">                .map(data -&gt; Integer.parseInt(data))</span><br><span class="line">                .onErrorReturn(e -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NumberFormatException) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data found!!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Grade is "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>에러를 <code>onErrorReturn()</code> 함수에서 처리하며 NumberFormatException 발생 시 -1을 리턴한다. subscribe() 함수는 성적 데이터를 처리하므로 0보다 커야 하낟. onErrorReturn() 함수에서 예외 발생 시 음수 값을 리턴했으므로 data가 0보다 작으면 에러 발생 여부를 판단하고 에러 로그를 출력한다.</li>
</ul>
<p><strong>onError 이벤트에서 예외를 처리하는 것과 다른 점</strong></p>
<ol>
<li>예외 발생이 예상되는 부분을 선언적으로 처리할 수 있다.</li>
<li>Observable을 생성하는 측과 구독하는 측이 서로 다를 수 있다는 점이다.
<ul>
<li>구독자는 Observable에서 발생할 수 있는 예외를 구독한 이후에 파악하는 것이 어렵다.</li>
<li>다시 말하면 Observable에서 에러 가능성을 명시하지 않았는데 구독자가 필요한 예외 처리를 빠짐없이 하는 것은 어렵다는 뜻이다. 이럴때 Observable을 생성하는 측에서 발생하는 예외 처리를 미리 해두면 구독자는 선언된 예외 상황을 보고 그에 맞는 처리를 할 수 있다.</li>
</ul>
</li>
</ol>
<ul>
<li>onErrorReturnItem() : onErrorReturn() 함수와 동일하지만 Throwable 객체를 인자로 전달하지 않기 때문에 코드는 좀 더 간결해진다. 즉, 가독성이 좋아진다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] grades = &#123;<span class="string">"70"</span>, <span class="string">"60"</span>, <span class="string">"$100"</span>, <span class="string">"93"</span>, <span class="string">"83"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(grades)</span><br><span class="line">                .map(data -&gt; Integer.parseInt(data))</span><br><span class="line">                .onErrorRetrunItem(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data found!!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Grade is "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onerrorresumenext-함수">onErrorResumeNext() 함수</h2>
<ul>
<li>onErrorReturn(), onErrorReturnItem()은 에러가 발생한 시점에 특정 값으로 대체.</li>
<li>에러가 발생했을 때, 내가 원하는 Observable로 대체하는 방법이다.</li>
<li>Observable로 대체한다는 것은 에러 발생 시 데이터를 교체하는 것뿐만 아니라 관리자에게 이메일을 보낸다던가 자원을 해제하는 등의 추가 작업을 해야할 때 유용하다.</li>
</ul>
<img src="/img/onErrorResumeNext.png" width="500" height="200">
<p>에러가 발생했을 때, 특정 값을 원하는 Observable로 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorResumeNext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] salesData = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"A300"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; onParseError = Observable.defer(() -&gt; &#123;</span><br><span class="line">            Log.d(<span class="string">"send email to administrator"</span>);</span><br><span class="line">            <span class="keyword">return</span> Observable.just(-<span class="number">1</span>);</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(salesData)</span><br><span class="line">                .map(Integer::parseInt)</span><br><span class="line">                .onErrorResumeNext(onParseError);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data Found!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Sales data: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = Sales data: <span class="number">100</span></span><br><span class="line">main | value = Sales data: <span class="number">200</span></span><br><span class="line">RxCachedThreadScheduler-<span class="number">1</span> | debug = send email to administrator</span><br><span class="line">RxCachedThreadScheduler-<span class="number">1</span> | error = Wrong Data Found!</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 에러가 발생했을 때 관리자에게 이메일을 보내고 '-1’이라는 데이터를 발행하는 Observable로 대체한다.</li>
<li>onParseError 변수는 subscribeOn() 함수를 호출하여 IO 스케줄러에서 실행한다. 이처럼 내가 원하는 코드를 실행하는 스케줄러를 선언적으로 지정할 수 있어 활용범위가 넓다.</li>
</ul>
<h2 id="retry-함수">retry() 함수</h2>
<ul>
<li>예외 처리의 다른 방법은 재시도이다.</li>
<li>예를 들어 서버와 통신할 때 인터넷이 일시적으로 안되거나 서버에 일시적인 장애가 발생하면 클라이언트에서는 일정 시간 후에 다시 통신을 요청하는 것이 필요하다. 이때 1개의 API가 아닌 다수의 API를 연속해서 호출해야 하는 경우 재시도하는 시나리오가 복잡해질 수도 있다.</li>
<li>이런 것을 단순하게 처리할 수 있는 <code>retry()</code> 함수를 제공한다. onError 이벤트 발생 시 해당 처리를 재시도한다.</li>
</ul>
<img src="/img/retry.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .retry(<span class="number">5</span>)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            Log.it(<span class="string">"result: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>retry() 함수의 실행횟수는 5회로 지정한다. 마지막으로 에러 발생시 ERROR_CODE를 반환한다. 재시도 동작을 확인하기 위해서는 인터넷 환경을 끊은 상태에서 테스트를 진행해야 한다. 결과는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main | 645 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">main | 646 | error = api.github.com</span><br><span class="line">main | 646 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | value = result: -500</span><br></pre></td></tr></table></figure>
<ul>
<li>5회의 재시도 후 최종 요청이 실패 처리되었다. <code>getT()</code> 함수를 통해서 api 접속을 시도하지만 예외가 발생해서 에러 로그를 찍는 부분으로 빠진다. 요청을 5번 시도하면서 계속 에러 로그를 찍고 그 후에 <code>onErrorReturn()</code> 함수에서 에러 코드를 반환하고 종료한다.</li>
<li>위에서 실행 시간이 문제가 있다. 재시도를 할 때 지연 시간이 없이 바로 재시도하기 때문에 도움이 되지 않는다. 지연 시간을 설정해서 재시도를 해보자.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryDelaySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> RETRY_MAX = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> RETRY_DELAY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .retry((retryCount, e) -&gt; &#123;</span><br><span class="line">                    Log.e(<span class="string">"retryCount: "</span> + retryCount);</span><br><span class="line">                    CommonUtils.sleep(RETRY_DELAY);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> retryCount &lt; RETRY_MAX ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            Log.it(<span class="string">"result: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재시도 횟수는 5회이고 지연 시간 간격은 1000ms이다. 재시도할 때 CommonUtils.sleep() 함수를 호출해 1000ms 동안 대기한다.</li>
<li>api 호출을 하고 인터넷 연결이 되어 있지 않다면 재시도를 하게 된다. 5번까지 재시도를 하고 1000ms 간격으로 시도를 하면서 재시도 횟수를 로그를 통해 기록한다. 재시도 횟수가 5회 이하일 때는 true를 이후에는 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main | 716 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">main | error = retryCount: 1</span><br><span class="line">main | 1721 | error = api.github.com</span><br><span class="line">main | error = retryCount: 2</span><br><span class="line">main | 2726 | error = api.github.com</span><br><span class="line">main | error = retryCount: 3</span><br><span class="line">main | 3726 | error = api.github.com</span><br><span class="line">main | error = retryCount: 4</span><br><span class="line">main | 4728 | error = api.github.com</span><br><span class="line">main | error = retryCount: 5</span><br><span class="line">main | 5732 | value = result: -500</span><br></pre></td></tr></table></figure>
<h2 id="retryuntil">retryUntil()</h2>
<ul>
<li>retry() 함수는 재시도를 지속할 조건이 없을 때 재시도를 중단한다.</li>
<li>재시도를 중단할 조건이 발생할 때까지 재시도 한다.</li>
<li>함수 원형은 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">retryUntil</span><span class="params">(<span class="keyword">final</span> BooleanSupplier stop)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>BooleanSupplier 객체는 인자는 없고 Boolean 값을 리턴하는 함수형 인터페이스다.</li>
<li>즉, retryUntil() 함수의 인자로 Boolean 값을 리턴하는 구문이 들어가야 한다. 이게 재시도를 중단할 조건을 의미한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryUntil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .retryUntil(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CommonUtils.isNetworkAvailable()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 중지.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 계속 진행.</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IO 스케줄러에서 실행되기 때문에 sleep 함수가 필요함.</span></span><br><span class="line">        CommonUtils.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>보통 재시도 로직은 별도의 스레드에서 동작하기 때문에 <strong>IO 스케줄러</strong>를 활용한다.</li>
<li>retryUntil() 함수의 인자인 람다 표현식에는 먼저 <code>CommonUtils.isNetworkAvailable()</code>를 호출해 네트워크가 사용 가능한 상태인지 확인한다. 만약, true를 반환하면 재시도를 중단하도록 true를 반환한다. 네트워크를 사용할 수 없는 상태라면 1000ms를 쉬고 재시도(재구독)한다. 이때 람다 표현식은 false를 반환한다.</li>
<li>결국 retryUntil 함수의 인자인 람다 표현식이 true를 반환해야 재시도를 중단하게 된다. false를 반환하면 재시도를 계속하게 된다.</li>
<li>결과는 다음과 같다. Process가 종료된 것은 인터넷에 연결되어 재시도가 끝났다는 것으로 해석할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RxCachedThreadScheduler-1 | 680 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-2 | 1685 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-2 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-1 | 2691 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-2 | 3695 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-2 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-1 | 4698 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="retrywhen">retryWhen()</h2>
<ul>
<li>재시도와 관련된 함수 중 가장 복잡하다.</li>
<li>주로 재시도 조건을 동적으로 설정해야 하는 복잡한 로직을 구현할 때 사용한다.</li>
</ul>
<img src="/img/retryWhen.jpeg" width="500" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/05/RxJava-Chap07/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/"
                            aria-label=": [Android] RecyclerView ClickListener"
                        >
                            [Android] RecyclerView ClickListener
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-05T12:34:18+09:00">
	
		    Jul 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>이번에는 Android에서 RecyclerView를 사용할 때, 각 아이템의 ClickListener를 다는 방법에 대해서 설명하려고 한다. 여러가지 방법이 있겠지만, 이번에는 Kotlin의 특징 중 하나인 <strong>함수를 매개변수로 넘길 수 있다는 특징</strong>을 사용하려고 한다.</p>
<p>필자가 진행 중인 프로젝트의 일부 코드를 기반으로 설명할 예정이다.</p>
<h2 id="구현">구현</h2>
<ol>
<li>먼저, MainFragment에서 RecyclerView를 사용할 것이다. 그리고 RecyclerView의 각 아이템을 눌렀을 때 어떤 동작을 할 것인지를 미리 정의해둔다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startToDetailActivity</span><span class="params">(id: <span class="type">Int</span>, message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(context, MissionDetailActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        intent.putExtra(<span class="string">"id"</span>, id)</span><br><span class="line">        intent.putExtra(<span class="string">"completeMessage"</span>, message)</span><br><span class="line">        intent.putExtra(<span class="string">"main"</span>,<span class="string">"main"</span>)</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Int 타입인 id와 String 타입인 message를 매개변수로 받는 함수이다. 이 함수는 id, message를 가지고 MissionDetailActivity로 이동하는 함수이다.</p>
<ol start="2">
<li>이제는 이 함수를 RecyclerView에서 사용될 Adapter에 매개변수로 넘기는 과정이 필요하다. 이 과정은 두 단계로 나눠보도록 하겠다.</li>
</ol>
<ul>
<li>Adapter에서 함수를 인자로 받을 수 있도록 수정.</li>
<li>MainFragment에서 Adapter 객체를 만들 때 위에서 만든 함수를 전달한다.</li>
</ul>
<p>Adapter에서 함수를 인자로 받을 수 있도록 수정해보도록 하겠다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainMissionAdapter</span></span>(<span class="keyword">private</span> <span class="keyword">var</span> onMainMissionItemClick: (<span class="built_in">Int</span>, String) -&gt; <span class="built_in">Unit</span>) :</span><br><span class="line">    RecyclerView.Adapter&lt;MainMissionViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> itemsMock = ArrayList&lt;MissionFeedResponse&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: MainMissionViewHolder &#123;</span><br><span class="line">        <span class="keyword">val</span> binding = ItemListMainMissionBinding.inflate(</span><br><span class="line">            LayoutInflater.from(parent.context)</span><br><span class="line">            , parent, <span class="literal">false</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> MainMissionViewHolder(binding, onMainMissionItemClick)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MainMissionAdapter의 기본 생성자를 호출하면서 <code>(Int, String) -&gt; Unit</code>을 확인할 수 있다. 이는 Int, String을 인자로 받고 반환값이 없는 함수를 의미한다. 따라서 Int, String을 인자로 받고 반환값이 없는 함수를 매개변수를 받겠다는 의미이다.</p>
<p>그리고 <strong>onCreateViewHodler</strong>에서 <strong>MainMissionViewHolder</strong>에 매개변수로 받은 <code>onMainMissionItemClick</code> 함수를 넘기고 있다. ViewHolder는 위의 남은 단계가 끝나고 살펴볼 예정이다.</p>
<p>그러면 MainFragment에서 함수를 전달해보도록 하자. 함수를 전달할 때는 람다식을 사용할 수 있다. 이유는 익명 함수이기 때문에 람다식을 이용해서 가독성을 높이고 쉽게 처리할 수 있기 때문이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mainMissionAdapter = MainMissionAdapter &#123; id, message -&gt;</span><br><span class="line">            startToDetailActivity(id, message)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>초기화 하는 코드이다. MainMissionAdapter의 인자로 id, message를 받는 익명함수가 전달되어야 하기 때문에 람다식을 통해서 id, message를 넘겨 받는다. 이는 위에서 구현해놓은 <code>startToDetailActivity()</code> 함수의 매개변수로 넘겨줘야 한다.</p>
<p>이것은 실제로 값을 받는 코드가 아니다. 이렇게 값을 받을 것이다라고 선언만 해놓은 것이지 아직 코드가 실행되지 않는다.<br>
어떻게 보면 <strong>startToDetailActivity</strong> 함수를 Adapter에 넘기는 것이다. 이 함수는 위치는 MainFragment에 존재하는 것이고 이 함수의 호출을 대신하기 위해서 함수를 넘기는 것이다.</p>
<p>따라서 함수를 넘긴다는 것의 의미는 실제로 이 함수를 넘기는 것이 아니라 원하는 값을 얻어 이 함수에 담아서 호출하기 위함이다. 그래서 Adapter에서 ViewHolder로 넘기면 ViewHolder에서 <strong>onMainMissionItemClick</strong> 이라는 익명 함수를 받는다. 코드를 먼저 보도록 하자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainMissionViewHolder</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: ItemListMainMissionBinding</span><br><span class="line">    , <span class="keyword">private</span> <span class="keyword">val</span> onMainMissionItemClick: (<span class="built_in">Int</span>, String) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(item: <span class="type">MissionFeedResponse</span>)</span></span> &#123;</span><br><span class="line">        binding.item = item</span><br><span class="line">        binding.executePendingBindings()</span><br><span class="line"></span><br><span class="line">        binding.itemMainImage.setOnClickListener &#123;</span><br><span class="line">            onMainMissionItemClick.invoke(item.mission.id, item.mission.category.completeMessage)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewHolder에서 필자가 원하는 아이템에 <strong>setOnClickListener</strong>를 통해서 클릭 리스너를 달아준다. 그리고 그 안에서 <code>onMainMissionItemClick.invoke()</code>를 호출함으로써 넘겨받은 함수를 대신 호출할 수 있도록 해준다. <strong>invoke()</strong> 함수가 함수를 대신 호출하는 의미를 가진듯 하다.</p>
<p>그래서 여기서 호출하게 되면 MainFragment에서 정의했던 startToDetailActivity() 함수가 호출되고 원하는 동작을 할 수 있게 된다.</p>
<p>내가 원하는 값을 인자로 받는 부분은 ViewHolder에서 이루어지게 되고 실제 함수는 MainFragment에 존재한다. 그리고 호출도 이 함수를 호출하게 되는 것이다.</p>
<p>설명을 두서없이 하였다. 다음에 Kotlin의 사용자 정의 get(), set()을 통해 변경된 코드로 다시 한번 설명하도록 하겠다. 그 때는 더 깔끔하게 글을 쓰도록 할 예정이다. 마지막으로 이 글을 쓴 목적은 코틀린스럽게 코드를 작성하고자 하는 사람들이 영어로 된 자료말고 이 자료를 통해서 더 쉽게 해당 지식을 얻어갔으면 하는 바램에서 작성하게 되었다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/04/Android-EditTextFunction/"
                            aria-label=": [Android] EditText 유용한 기능"
                        >
                            [Android] EditText 유용한 기능
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-04T15:56:02+09:00">
	
		    Jul 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드에서 EditText는 거의 필수적인 존재라고 봐도 무방할 것 같다. 자주 사용하지만, 매번 필요한 기능을 검색해보기 때문에 유용한 기능들을 정리하려고 포스팅하게 되었다.</p>
<h2 id="기능">기능</h2>
<ul>
<li><code>maxLength</code> : EditText에 작성할 수 있는 최대 길이를 지정한다.</li>
<li><code>singleLine</code> : 이 기능은 true/false로 설정할 수 있으며, false로 설정하게 되면 EditText의 오른쪽 면에 닿으면 줄바꿈이 된다.</li>
<li><code>scrollHorizontally</code> : 이 기능도 마찬가지로 true/false로 설정할 수 있으며, false로 설정하게 되면 EditText의 길이가 오른쪽으로 길어져도 좌우 스크롤이 안된다. 필자는 <strong>singleLine</strong>과 <strong>scrollHorizontally</strong> 속성을 함께 사용하였다.</li>
<li><code>inputType</code> : 키보드의 형태를 지정할 수 있다. 숫자만으로 구성된 키보드를 띄울 수도 있고, e-mail 입력을 할 수 있도록 그에 맞는 키보드를 띄울 수 있다. 공식 문서를 참고하면 잘 정리되어있다.</li>
<li><code>imeOptions</code> : 키보드의 완료 버튼을 지정할 수 있다. 아무 값도 지정하지 않았다면 줄바꿈이 되어 있을 것이다. 필자는 완료를 위해서 <strong>actionDone</strong>으로 지정했다.</li>
<li><code>style</code> : EditText의 커서 색상이나 백그라운드 등을 바꾸고 싶다면 style을 작성해서 EditText에 지정해주면 된다.</li>
</ul>
<p>추가적으로 생각이 나는 부분은 이 포스팅에 계속해서 올릴 예정이다.</p>
<p><strong>[2020.02.19 내용 추가]</strong></p>
<p>이번에 추가하는 부분은 함수라기 보다는 개발하면서 알게 된 방법 중 하나이다.<br>
정말 간단하고, 읽는데 1분도 안걸린다.</p>
<p>어떤 글에 대해 <code>수정</code> 버튼을 누르기 전에는 글을 수정할 수 없다. 하지만, 어떤 액션을 했을 경우, 글을 수정할 수 있도록 하기 위해서 EditText의 <strong>enabled</strong> 속성을 이용했다. 또한, drawable에 파일을 생성해 selector 같이 만들었다.</p>
<ol>
<li>drawable에 파일을 만든다</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@android:color/holo_orange_dark"</span> <span class="attr">android:state_enabled</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:color</span>=<span class="string">"@android:color/black"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>EditText의 textColor에 drawable 파일을 연결한다.</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/et_title"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">"@string/label_title"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingStart</span>=<span class="string">"@dimen/space_16"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingEnd</span>=<span class="string">"@dimen/space_8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.memo.title&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"@drawable/selector_et"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/toolbar"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>[2020.03.30 추가]</strong></p>
<h2 id="자동-개행하기">자동 개행하기</h2>
<p>필자는 EditText를 사용해 글을 입력 받는데, 오른쪽 면에 닿았을 때 자동 개행이 되기를 원했다. 그래서 <code>android:scrollHorizontally=&quot;false&quot;</code>를 설정하고 <code>android:inputType=&quot;text&quot;</code>로 설정했었다.</p>
<p>하지만, 자동 개행은 적용되지 않았다. 구글링을 해 본 결과 왜 되지 않는가에 대해서는 나오지 않았다. 필자가 생각하기로는 text로 설정함으로써 scrollHorizontally 속성이 제대로 적용되지 않는 것으로 판단이 되었다.</p>
<p>여기까지가 근거 없는 이유였다. 역시나 구글링을 더 해보니 이유를 생각할 수 있었다. EditText의 inputType 속성에 대해서 검색하고 찾아봤다. 그 중 필자가 사용했던 <code>android:inputType=&quot;text&quot;</code>는 다음과 같은 의미를 갖고 있다.</p>
<ul>
<li><code>android:inputType=&quot;text&quot;</code> : none과 같으나 줄바꿈이 불가능하다.</li>
<li><code>android:inputType=&quot;none&quot;</code> : 다른 특징이 없는 기본 EditText. 입력 폼 안에 줄 바꿈이 가능하다.</li>
</ul>
<p>그렇다. <strong>text</strong> 설정으로 인해서 줄바꿈이 되지 않는다. 때문에 scrollHorizontally 설정을 바꾼다하더라도 자동 개행이 되지 않았던 것이다. 이제 속성의 정확한 의미를 알았기 때문에 inputType 값을 설정하지 않아도 되고 설정해도 된다. 필자는 다음과 같이 설정했다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/et_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">"@dimen/space_16"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">"@dimen/space_8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">"@dimen/space_16"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@drawable/bg_et_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"top|start"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">"@string/hint_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">"textMultiLine"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxHeight</span>=<span class="string">"250dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"@dimen/space_16"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scrollHorizontally</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"@&#123;vm.memo.content&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"@drawable/selector_et"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/EditTextStyle"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/et_title"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>[inputType 속성]</strong></p>
<ul>
<li><code>textMultiLine</code> : 입력 폼에 줄 바꿈이 가능하다. 따로 설정하지 않으면 단일 줄의 텍스트로 제한된다.</li>
<li><code>scrollHorizontally</code> : 자동으로 줄이 바뀌고 enter 엔터키를 누르면 다음줄로 이동한다.</li>
</ul>
<p>또한 <a href="https://youeye.tistory.com/119" target="_blank" rel="noopener">쎄씨’s</a>님의 블로그에 inputType에 대해서 정리되어 있으니 가서 확인해보는 것도 좋다. 공식 문서가 사실 더 좋다!</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://m.blog.naver.com/PostView.nhn?blogId=websearch&amp;logNo=220400070845&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank" rel="noopener">[안드로이드] EditText 의 disable 텍스트 색상 설정하는 방법</a></li>
<li><a href="https://m.blog.naver.com/PostView.nhn?blogId=invister&amp;logNo=40150491344&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank" rel="noopener">android 안드로이드 edittext 자동 줄바꿈</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/04/Android-EditTextFunction/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/26/Android-Dialog-Context/"
                            aria-label=": [Android] Dialog Error?!"
                        >
                            [Android] Dialog Error?!
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-26T23:27:06+09:00">
	
		    Jun 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Android 개발을 함에 있어서 <strong>AlertDialog</strong>를 사용하는 경우를 많이 접해봤을 것이다. 예를 들면, 야놀자 앱을 켰을 때 뜨는 광고가 Dialog의 한 예라고 볼 수 있다. 필자도 이러한 Dialog를 만들어야 하는데, 기본으로 제공하는 것이 아니라 Custom 해야 했다.</p>
<p>그래서 xml로 원하는 뷰를 작성하고 CustomDialog라는 클래스를 만들어 xml을 inflate했다.<br>
그리고 Click이 필요하다면 ClickListener도 설정하면 된다.</p>
<p><strong>CustomDialog.class</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomDialog</span></span>(context: Context) : Dialog(context), View.OnClickListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layout = R.layout.custom_dialog</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(layout)</span><br><span class="line">        init()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        dialogOkayButton.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (v.id) &#123;</span><br><span class="line">            R.id.dialogOkayButton -&gt; &#123;</span><br><span class="line">                dismiss()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 MyPageFragmet 클래스에서 CustomDialog를 사용하려고 한다.<br>
간단하게 호출하면 된다. 코드를 한번 봐보자.</p>
<p><strong>MyPageFragment.class</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fragmentMyPageDataBinding.myPageMissionSuggest.setOnClickListener &#123;</span><br><span class="line">            toast(requireContext().toString())</span><br><span class="line">            <span class="keyword">val</span> dialog = CustomDialog(activity?.applicationContext)</span><br><span class="line">            dialog.setCanceledOnTouchOutside(<span class="literal">false</span>)</span><br><span class="line">            dialog.show()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>필자는 DataBinding을 사용하기 때문에 위와 같은 코드를 구성했다. 버튼 클릭 시 Dialog를 띄우는 코드이다. Dialog 클래스는 Context를 필요로 하기 때문에 applicationContext를 넘겼다.<br>
‘그럼 이제 Dialog가 뜨겠지?’ 라고 기대해본다.</p>
<blockquote>
<p>Unable to add window – token null is not for an application</p>
</blockquote>
<p>흠, 이게 무슨 상황인가. 왜 실행이 되지 않는 것일까? 역시 해결책은 구글링이다. 찾아보니 Dialog를 생성할 때 넘겨야 하는 Context는 <code>Activity의 Context</code>를 넘겨야 한다. 나는 지금까지 <code>applicationContext</code>를 넘겼기 때문에 저런 에러를 겪은 것이다.</p>
<p>이유는 Dialog가 Activity에 종속적이기 때문이다. 그래서 applicationContext가 아니라 Activity의 Context를 넘겨야 한다. 아마도 Dialog는 Activity가 떠야 그 위에서 그릴 수 있기 때문일 것이다. Application의 생명주기를 따르지 않고 Activity의 생명주기를 따라서 Dialog가 함께 존재하기 때문이다.</p>
<p>그럼 fragment에서 Activity의 context는 어떻게 얻을 수 있을까?</p>
<p>이에 대한 답변은 자바와 코틀린이 조금 다르다.</p>
<ul>
<li>Java : <code>getActivity()</code> 혹은 <code>getContext()</code>를 통해서 얻을 수 있다.</li>
<li>Kotlin : <code>requireContext()</code> 함수를 통해서 얻을 수 있다.</li>
</ul>
<p>그래서 위의 MyPageFragment.class의 코드를 수정하면 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fragmentMyPageDataBinding.myPageMissionSuggest.setOnClickListener &#123;</span><br><span class="line">            toast(requireContext().toString())</span><br><span class="line">            <span class="keyword">val</span> dialog = CustomDialog(requireContext())</span><br><span class="line">            dialog.setCanceledOnTouchOutside(<span class="literal">false</span>)</span><br><span class="line">            dialog.show()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>그러면 말끔하게 에러가 해결된 모습을 만나게 될 것이다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/2634991/android-1-6-android-view-windowmanagerbadtokenexception-unable-to-add-window" target="_blank" rel="noopener">StackOverflow</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/26/Android-Dialog-Context/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/25/Android-RecyclerView-BottomSpace/"
                            aria-label=": [Android] RecyclerView Bottom padding"
                        >
                            [Android] RecyclerView Bottom padding
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-25T20:30:17+09:00">
	
		    Jun 25, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Android에서 RecyclerView의 사용은 거의 필수라고 할 수 있다. 왜냐하면 리스트를 보여주는 화면은 대부분의 앱에 존재할 것이기 때문이다. 이번 글은 간단하다. 리싸이클러뷰를 사용하는 사람이라면 글을 읽는데 어려움이 없을 것이다. 사실, 몰라도 볼 수 있다. 그만큼 간단한 글이다.</p>
<h2 id="recyclerview">RecyclerView</h2>
<p>리싸이클러뷰는 리스트 화면을 구성하는데 효율적이다. 이유는 View를 재활용하기 때문이다. 화면을 작성하고 보면 리스트의 제일 하단 공간이 아래와 바짝 붙어있는 경우를 본 적이 있을 것이다. 이를 해결하기 위한 방법은 내가 할 수 있는 것 중에서는 두 가지가 있다.</p>
<ul>
<li>ItemDecoration 클래스를 만들어서 마지막 아이템일 경우 공간을 추가하는 방법</li>
<li>RecyclerView 자체에 padding을 주는 방법</li>
</ul>
<p>첫 번째 방법은 <code>addDecoration</code> 키워드를 가지고 검색해보면 답을 구할 수 있다. 이 방법은 추후에 설명하도록 하겠다. 이것보다 훨씬 간단한 두 번째 방법을 설명하겠다. 두 번째 방법 그대로 padding을 RecyclerView에 추가하면 어떻게 될까??</p>
<p>내가 원하는 것처럼 바닥과 공간이 떨어진다. 하지만, 스크롤이 되는 위치도 그만큼 떨어지게 된다. 즉 RecyclerView를 자식으로 가지는 부모 뷰에 꽉 차지 않는 것이다. 이를 해결하기 위해서는 다음의 한 줄을 추가하면 간단하게 해결된다</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:clipToPadding="false"</span><br></pre></td></tr></table></figure>
<p>공식 문서의 내용을 보면 다음과 같다.</p>
<blockquote>
<p>Defines whether the ViewGroup will clip its children and resize (but not clip) any EdgeEffect to its padding, if padding is not zero. This property is set to true by default.</p>
</blockquote>
<p><strong>해석해보면 패딩이 0이 아닌 경우에는 ViewGroup이 자신의 자식 뷰의 영역을 자르고 EdgeEffect의 크기를 조정(clip)할지 여부를 규정한다. 이 속성은 기본적으로 true로 설정되어 있다.</strong></p>
<p>기본적으로 패딩값이 설정되어 있다면 ViewGroup은 자신의 자식 뷰의 영역을 자르고 EdgeEffect(사용자가 2D 공간에서 콘텐츠 경계를 넘어 스크롤할 때 스크롤 가능한 위젯의 가장자리에서 사용하는 그래픽 효과를 말한다.)의 크기를 조정한다. 이 속성을 false로 설정한다는 것은 EdgeEffect의 크기를 조정하지 않는다. 따라서 스크롤 가능한 위젯의 가장자리에서 사용하는 그래픽 효과는 부모 뷰에 맞도록 설정이 된다는 걸 뜻한다.</p>
<p>그래서 스크롤할 때 부모 뷰에서 떨어지지 않고 내가 원하는 동작을 할 수 있다. 이것은 나의 해석과 생각이 담겨 있다. 그래서 사실이 아닐 수도 있다. 질문이나 틀린 점이 있다면 알려주면 피드백 반영해서 수정하도록 하겠습니다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipToPadding" target="_blank" rel="noopener">Android Developer clipToPadding</a></li>
<li><a href="https://developer.android.com/reference/android/widget/EdgeEffect" target="_blank" rel="noopener">Android Developer EdgeEffect</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/25/Android-RecyclerView-BottomSpace/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/24/Android-Progressbar-tip/"
                            aria-label=": [Android] 로딩시 어떻게 할 것인가?"
                        >
                            [Android] 로딩시 어떻게 할 것인가?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-24T23:37:18+09:00">
	
		    Jun 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 개발에서 서버로부터 데이터를 불러올 때, 네트워크 상황이 좋지 않다면 금방 불러올 수 없을 것이다. 시간이 어느 정도 걸린다. 또한, 불러오는 데이터 중 사진, 영상이 많거나 데이터의 양이 많다면 시간이 오래 걸린다.</p>
<p>이처럼 시간이 오래 걸리는 작업을 아무런 동작 없이 그냥 냅두면 사용자는 빈 화면을 보다가 갑자기 나타난 화면에 좋지 않은 경험을 할 것이다. 그래서 이를 해결하기 위한 방법은 내가 생각했을 때는 두가지가 있다.</p>
<ul>
<li>Progress Bar를 이용한 로딩</li>
<li><a href="https://github.com/elye/loaderviewlibrary" target="_blank" rel="noopener">loaderViewLibrary</a>를 사용하는 방법</li>
</ul>
<p>아마도 이 글은 두 Part로 나뉘어서 쓸 것 같다. 이번에는 <code>Progress Bar</code>를 이용한 로딩 방법을 다뤄보고 다음에는 <code>loaderViewLibrary</code>를 이용한 방법을 다룰 예정이다.</p>
<h2 id="progressbar">Progressbar</h2>
<p>사용방법은 정말 간단하다. 그냥 xml에 정의해서 사용하면 된다. 아래 xml 코드를 보자.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">"@+id/loading"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_marginBottom</span>=<span class="string">"8dp"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">           <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>이렇게 정의하면 빨간색의 ProgressBar를 볼 수 있다. 원형이 기본 형태인 것 같다. 색상도 빨간색이 기본으로 설정되어 있다. 하지만, 이 빨간색은 여러분이 개발하고 있는 앱의 색상과 맞지 않을 것이다. 그래서 변경하려는 사람이 많다. 필자도 변경하려고 구글링을 좀 해봤다.</p>
<p>여러 방법이 있지만, 가장 단순한 방법은 다음 코드 한 줄을 추가하는 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:indeterminateTint=&quot;@color/fe_fu_main&quot;</span><br></pre></td></tr></table></figure>
<p>이 속성이 무엇인지는 <a href="https://developer.android.com/reference/android/widget/ProgressBar.html#attr_android:indeterminateTint" target="_blank" rel="noopener">Android Developer</a> 문서에 설명되어 있다. 사진을 아래와 같이 첨부했다.</p>
<img src="/img/android_progress_color_change.png" width="700" height="200">
<p>해석해보면 ProgressBar에 적용할 색상이라고 한다. indeterminate가 뭔지 몰랐는데 <strong>불확정의</strong>라는 뜻을 가진다. ProgressBar가 불확정에서 확정으로 되는 동안 로딩하기 위해 쓰이는 것이라 이런 이름을 붙이지 않았을까 추측해본다. (물론 나의 생각!!)</p>
<p>저 속성을 통해서 원하는 색상을 지정하면 사용자가 원하는 색상을 사용할 수 있다. 직접 drawable 파일을 만들어서 커스텀하는 방법도 있는데, 이는 디자인 자체에서 조금 다르면 커스텀해서 사용해도 좋을 것 같다. 다음의 스택 오버플로우 질문을 보면 답변에 두 방식 모두 나와있다. -&gt; <a href="https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769" target="_blank" rel="noopener">https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769</a></p>
<h2 id="사용해보기">사용해보기</h2>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://developer.android.com/reference/android/widget/ProgressBar.html#attr_android:indeterminateTint" target="_blank" rel="noopener">Android Developer</a></li>
<li><a href="https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769" target="_blank" rel="noopener">https://stackoverflow.com/questions/5337613/how-to-change-color-in-circular-progress-bar/17785769</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/24/Android-Progressbar-tip/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/24/Android-NestedScrollview-issue/"
                            aria-label=": [Android] NestedScrollView Issue"
                        >
                            [Android] NestedScrollView Issue
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-24T17:04:21+09:00">
	
		    Jun 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 개발을 하다보면 ScrollView 안에 RecyclerView를 넣어야 하는 경우가 생긴다. 이럴 때, <code>NestedScrollView</code>를 사용하면 된다. 이름처럼 중첩된 스크롤뷰라는 뜻이다. 필자는 NestedScrollView를 아주 유용하게 사용한다. 사용하는 상황은 다음과 같다.</p>
<ul>
<li>RecyclerView이 있는데 다른 형태의 뷰가 보여질 때</li>
<li>타이틀이 있고 아래에 리스트 목록이 보일 때</li>
</ul>
<p>두 가지 경우는 거의 비슷하다. 첫 번째 경우는 사실 ViewType을 다르게 하여 RecyclerView를 구성할 수도 있다. 하지만, 이 부분이 조금 번거롭다면 NestedScrollView를 사용하는 것도 하나의 방법이다.</p>
<h2 id="issue">issue</h2>
<p>이제 필자가 겪은 문제를 말하려고 한다. 서론이 길었다. 위에서 두 번째 경우를 구현해야 하는 상황이 있었다. <strong>NestedScrollView는 ScrollView와 마찬가지로 내부에 ViewGroup을 하나만 가질 수 있다.</strong> 그래서 LinearLayout을 두고 그 안에 타이틀을 보여주는 TextView와 리스트를 나타내는 RecyclerView를 두었다.</p>
<p>그런데 경우에 따라서 이 NestedScrollView가 자기 멋대로 밑으로 스크롤이 내려갈 때가 있다. 처음에는 이유를 몰랐다. 그래서 구글링을 해보면서 찾아봤다. 이유는 뷰가 그려지면서 안에 넣어둔 또 다른 ScrollView(즉, 여기서는 RecyclerView)에 포커스가 잡히면서 타이틀이 보이지 않는 것이었다.</p>
<p>그래서 이 포커스를 어떻게 없앨까 찾아보았다. 포커스만 없앤다면 뷰가 그려지면서 RecyclerView에 포커스되는 상황이 없어지고 스크롤이 제멋대로 내려가지 않을테니 말이다. 바로 다음의 한줄만 추가하면 된다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:descendantFocusability="blocksDescendants"</span><br></pre></td></tr></table></figure>
<p><strong>무슨 속성일까?</strong></p>
<ul>
<li><code>descendantFocusability</code> : <strong>ViewGroup 내에서 포커스를 맞출 때 ViewGroup과 그의 하위 뷰의 관계를 설정한다.</strong> 여기서 하위 뷰란 자식 뷰를 의미한다.</li>
<li><code>blocksDescendants</code> : 해당 뷰 그룹의 하위 뷰가 포커스를 받지 못하게 하는 옵션이다.</li>
</ul>
<p><strong>어디에 정의할까?</strong></p>
<p>ScrollView의 자식 뷰에 설정하면 된다. 스크롤뷰는 자식 뷰를 하나만 가지기 때문에 LinearLayout에 설정하면 된다.</p>
<p><strong>xml 코드</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"@id/achieveAppBar"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:descendantFocusability</span>=<span class="string">"blocksDescendants"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginStart</span>=<span class="string">"@dimen/margin_24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginTop</span>=<span class="string">"@dimen/margin_16dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:text</span>=<span class="string">"@string/text_my_page_achieve_list_title"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">style</span>=<span class="string">"@style/SubTitleHeaderStyle"</span></span></span><br><span class="line"><span class="tag">                /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/achieveListRv"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:overScrollMode</span>=<span class="string">"never"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginTop</span>=<span class="string">"@dimen/margin_24dp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="결론">결론</h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:descendantFocusability="blocksDescendants"</span><br></pre></td></tr></table></figure>
<p>정리하면, 위의 설정은 NestedScrollView 안의 자식 뷰(하위 뷰)가 포커스를 가져가는 현상을 막아준다. 즉, NestedScrollView 안에 있는 RecyclerView가 포커스를 가져가지 않는다. 따라서 NestedScrollView는 원하던 대로 포커스를 받고 스크롤이 내려가는 현상도 방지할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://bonoogi.postype.com/post/657336" target="_blank" rel="noopener">NestedScrollView가 보여질 때 제멋대로 스크롤 되는 문제</a></li>
<li><a href="https://stackoverflow.com/questions/34329707/nestedscrollview-scrolls-to-top-on-recyclerview-resized" target="_blank" rel="noopener">NestedScrollView scrolls to top on Recyclerview resized</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/24/Android-NestedScrollview-issue/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/20/DesignPattern-Observer/"
                            aria-label=": [Design Pattern] 옵저버 패턴"
                        >
                            [Design Pattern] 옵저버 패턴
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-20T13:32:51+09:00">
	
		    Jun 20, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Design-Pattern/">Design Pattern</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>옵저버 패턴이란</h2>
                    
                        <a
                            href="/2019/06/20/DesignPattern-Observer/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Design Pattern] 옵저버 패턴"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/19/RxJava-Chap05-Scheduler/"
                            aria-label=": [RxJava] Chap05. 스케줄러"
                        >
                            [RxJava] Chap05. 스케줄러
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-19T22:22:26+09:00">
	
		    Jun 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>지금까지 공부했던 예제의 공통점은 대부분의 동작이 현재 즉, main 스레드에서 동작한다는 것이었다. 하지만, 실무에서는 요구사항에 맞게 <strong>비동기</strong>로 동작할 수 있도록 이를 바꿔야 한다. 이때 스케줄러를 이용한다.</p>
<p>스케줄러는 스레드를 지정할 수 있게 해준다. 단순히 새로운 스레드를 생성하거나 기존의 Executors를 활용하는 것을 넘어 새로운 방식으로 볼 수 있다. 그동안 어렵게 다뤄야 했단 비동기 프로그래밍이 간결한 코드로 구성될 수 있다.</p>
<img src="/img/rx_flip.png" width="700" height="200">
<p>위의 그림에서 시간 표시줄에 주목해야 한다. 마블 다이어그램을 코드로 표현하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlipSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] objs = &#123;<span class="string">"1-T"</span>, <span class="string">"2-S"</span>, <span class="string">"3-P"</span>&#125;;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.fromArray(objs)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"Original data = "</span> + data))</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .map(Shape::flip);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">        CommonUtils.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">3</span>-P</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">2</span> | value = (flipped)<span class="number">3</span>-P</span><br></pre></td></tr></table></figure>
<ul>
<li><code>doOnNext()</code> : Observable 에서 onNext 이벤트가 발생하면 실행되며, 여기에서는 원래의 데이터 값을 확인한다.</li>
<li><code>subscribeOn()</code> : 구독자가 Observable 에 subscribe() 함수를 호출하여 구독할 때 실행되는 스레드를 지정한다. -&gt; 해당 작업을 어느 쓰레드에서 실행할 것인가?!</li>
<li><code>observeOn()</code> : Observable 에서 생성한 데이터 흐름이 여기저기 함수를 거치며 처리될 때, 동작이 어느 쓰레드에서 일어나는지 지정할 수 있다. -&gt; 받은 결과를 어느 쓰레드에서 수행할지?!</li>
</ul>
<p>결과를 보면 최초의 데이터 흐름이 발생하는 스레드와 flip() 함수를 거쳐서 구독자에게 전달되는 스레드가 다르다. 보통 우리는 새로운 스레드를 생성하거나 Runnable 혹은 Callable 객체를 생성하는데 우리는 전달한 적이 없다. 단지 <code>subscribeOn()</code>과 <code>observeOn()</code> 함수에 어떤 스케줄러를 지정했을 뿐이다.</p>
<p>이처럼 스케줄러를 활용하는 비동기 프로그래밍의 핵심은 바로 <strong>데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 전달하는 스레드를 분리할 수 있다는 것이다.</strong></p>
<p>위의 코드에서 observeOn() 함수 호출 부분을 제거해보면 어떤 결과가 나올까? 결과는 아래에서 확인할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">1</span>-T</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">2</span>-S</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | debug = Original data = <span class="number">3</span>-P</span><br><span class="line">RxNewThreadScheduler-<span class="number">1</span> | value = (flipped)<span class="number">3</span>-P</span><br></pre></td></tr></table></figure>
<p>observeOn() 함수를 지정하지 않으면 subscribeOn() 함수로 지정한 스레드에서 모든 로직을 실행한다.</p>
<p>지금까지 배운 내용을 간단하게 정리하면 아래와 같다.</p>
<ol>
<li>스케줄러는 RxJava 코드를 어느 스레드에서 실행할지 지정할 수 있다.</li>
<li>subscribeOn() 함수와 observeOn() 함수를 모두 지정하면 Observable에서 데이터 흐름이 발생하는 스레드와 처리된 결과를 구독자에게 발행하는 스레드를 분리할 수 있다.</li>
<li>subscribeOn() 함수만 호출하면 Observable의 모든 흐름이 동일한 스레드에서 실행된다.(observeOn() 함수를 생략했을 경우!)</li>
<li>스케줄러를 별도로 지정하지 않으면 현재(main) 스레드에서 동작을 실행한다.</li>
</ol>
<h2 id="스케줄러의-종류">스케줄러의 종류</h2>
<ul>
<li>특정 스케줄러를 사용하다가 다른 스케줄러로 변경하기 쉽다는 특징을 가지고 있다.</li>
<li>마치 map() 함수를 한 번 더 호출하는 것처럼 새롭게 스케줄러를 추가하거나 기존의 스케줄러를 다른 것으로 교체할 수 있다.</li>
</ul>
<p><strong>1. 뉴 스레드 스케줄러</strong></p>
<p>이름처럼 새로운 스레드를 생성한다. 새로운 스레드를 만들어 동작을 실행하고 싶을 때 <code>Schedulers.newThread()</code>를 인자로 넣어주면 된다. 그럼 뉴 스레드 스케줄러는 요청을 받을 때마다 새로운 스레드를 생성한다.</p>
<p>뉴 스레드 스케줄러는 새로운 스레드를 생성하여 내가 원하는 동작을 처리하는 방법이다. 하지만 적극적으로 추천하는 방법은 아니다. RxJava에는 뉴 스레드 스케줄러보다 활용도가 높은 계산 스케줄러와 IO 스케줄러와 같은 다른 스케줄러를 제공하기 때문이다.</p>
<p><strong>2. 계산 스케줄러</strong></p>
<p>4장에서 봤던 interval() 함수는 기본적으로 계산 스케줄러에서 동작한다. 물론 내가 원하는 스케줄러에서 동작하도록 변경할 수도 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> period, TimeUnit unit, Scheduler scheduler)</span></span></span><br></pre></td></tr></table></figure>
<p>CUSTOM은 원하는 스케줄러를 지정할 수 있다는 의미이다. 리액티브 함수 대부분은 마지막 인자로 스케줄러를 지정할 수 있다. flatMap()이나 scan() 함수 등은 대표적인 연산자이지만 스케줄러를 인자로 받지 않는 경우도 있다.</p>
<p>계산 스케줄러는 CPU에 대응하는 계산용 스케줄러이다. <strong>계산 작업</strong>(입출력(I/O) 작업을 하지 않는)을 할 때는 대기 시간 없이 빠르게 결과를 도출하는 것이 중요하다. 내부적으로 스레드 풀을 생성하며 스레드 개수는 기본적으로 프로세서 개수와 동일하다.</p>
<p><strong>3. IO 스케줄러</strong></p>
<p>IO 스케줄러는 네트워크상의 요청을 처리하거나 각종 입,출력 작업을 실행하기 위한 스케줄러이다. 계산 스케줄러와 다른 점은 기본적으로 생성되는 스레드 개수가 다르다는 것이다.</p>
<p><strong>즉, 계산 스케줄러는 CPU 개수만큼 스레드를 생성하지만, IO 스케줄러는 필요할 때마다 스레드를 계속 생성한다</strong>. 입,출력 작업은 비동기로 실행되지만 결과를 얻기까지 대기 시간이 길다.</p>
<p>두 스케줄러의 비교</p>
<ul>
<li>계산 스케줄러 : 일반적인 계산 작업</li>
<li>IO 스케줄러 : 네트워크상의 요청, 파일 입출력, DB 쿼리 등</li>
</ul>
<p><strong>4. 트램펄린 스케줄러</strong></p>
<p>트램펄린 스케줄러는 <strong>새로운 스레드를 생성하지 않고 현재 스레드에 무한한 크기의 대기 행렬을 생성하는 스케줄러이다.</strong> RxJava 1.x에서는 repeat() 함수와 retry() 함수의 기본 스케줄러였으나 RxJava 2.x에서는 이러한 제약이 사라졌다.</p>
<p>새로운 스레드를 생성하지 않는다는 것과 대기 행렬을 자동으로 만들어준다는 것이 뉴 스레드 스케줄러, 계산 스케줄러, IO 스케줄러와 다른 점이다.</p>
<p><strong>5. 싱글 스레드 스케줄러</strong></p>
<p>싱글 스레드 스케줄러는 RxJava 내부에서 단일 스레드를 별도로 생성하여 구독 작업을 처리한다. 단, 생성된 스레드는 여러 번 구독 요청이 와도 공통으로 사용한다.</p>
<p>리액티브 프로그래밍이 비동기 프로그래밍을 지향하기 때문에 싱글 스레드 스케줄러를 활용할 확률은 낮다.</p>
<p>트팸펄린 스케줄러 예제와 비교해보면 실행 스레드가다르다는 사실을 알 수 있다.</p>
<ul>
<li>트램펄린 스케줄러 : 메인 스레드</li>
<li>싱글 스레드 스케줄러 : RxSingleScheduler-1</li>
</ul>
<p>뒤에 <code>-1</code>과 같이 번호가 붙있지만 <strong>결국 단일 스레드만 사용한다</strong>는 사실도 확인할 수 있다.</p>
<h2 id="스케줄러를-활용하여-콜백-지옥-벗어나기">스케줄러를 활용하여 콜백 지옥 벗어나기</h2>
<p>안드로이드 개발을 한다면 가장 쉽게 접근할 수 있고 유용하게 사용할 수 있는 부분이다. 서버와 통신하는 네트워크 프로그래밍을 할 때 마주치는 <code>콜백 지옥(Callback Hell)</code>을 해결하는 것에 집중해보자.</p>
<p>RxJava의 스케줄러를 활용하면 비동기 프로그래밍 방식이 달라진다. 계산 스케줄러나 IO 스케줄러의 예제에서도 살펴봤듯이 스레드를 생성하거나 Callable, Runnable 객체를 실행하는 코드가 사라진다. <strong>리액티브 프로그래밍은 서버와 연동하는 비동기 프로그래밍을 작성할 때 큰 힘을 발휘한다.</strong></p>
<h2 id="observeon-함수의-활용">observeOn() 함수의 활용</h2>
<p>RxJava 스케줄러의 핵심은 결국 제공되는 스케줄러의 종류를 선택한 후 subscribeOn()과 observeOn() 함수를 호출하는 것이다.</p>
<ul>
<li><code>subscribeOn()</code> : Observable에서 구독자가 subscribe() 함수를 호출했을 때 데이터 흐름을 발행하는 스레드를 지정한다.(즉, 작업 스레드를 지정한다.)</li>
<li><code>observeOn()</code> : 처리된 결과를 구독자에게 전달하는 스레드를 지정한다.(UI 갱신을 위한 스레드를 지정한다.)</li>
</ul>
<p>또한, subscribeOn() 함수는 처음 지정한 스레드를 고정시키므로 다시 subscribeOn() 함수를 호출해도 무시한다. 하지만, observeOn() 함수는 다르다.</p>
<img src="/img/schedulers.png" width="700" height="200">
<ul>
<li>subscribeOn(A)를 호출했을 때는 데이터를 발행하는 첫 줄이 스레드 A에서 실행된다. 이후에는 observeOn() 함수가 호출될 때까지 스레드 A에서 실행된다.</li>
<li>observeOn(B)를 호출하면 그 다음인 두 번째 줄부터는 스레드 B에서 실행된다.</li>
<li>map(o–&gt;D) 함수는 스레드 변겨와는 상관없으므로 세 번째 줄은 계속 스레드 B에서 실행된다.</li>
<li>이제 observeOn© 함수를 호출하면 그 다음 데이터 흐름은 스레드 C에서 실행된다.</li>
</ul>
<p>요약하면 다음과 같다.</p>
<ol>
<li>subscribeOn() 함수는 한번 호출했을 때 결정한 스레드를 고정하며 이후에는 다시 호출해도 스레드가 바뀌지 않는다.</li>
<li>observeOn() 함수는 여러 번 호출할 수 있으며 그 다음부터 동작하는 스레드를 바꿀 수 있다.</li>
</ol>
<p>전통적인 스레드 프로그래밍에서는 일일이 스레드를 만들어야 하고 스레드가 늘어날 때마다 동기화하는 것이 매우 부담스럽기 때문에 이러한 로직을 구현하는 것이 매우 힘들다. 하지만 observeOn() 함수는 스레드 변경이 쉬우므로 활용할 수 있는 범위가 매우 넓다.</p>
<p>책이 있다면 책에 나와있는 openWeatherMap 예제를 실행해보는 것을 추천한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/19/RxJava-Chap05-Scheduler/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/archives/3/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 2 of 11</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
