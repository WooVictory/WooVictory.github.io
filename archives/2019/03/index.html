
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2019/3 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2019/03/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/26/Java-Diff-Array-ArrayList/"
                            aria-label=": [Java] Array VS ArrayList"
                        >
                            [Java] Array VS ArrayList
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-26T12:54:58+09:00">
	
		    Mar 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>정렬과 관련된 알고리즘 문제를 풀고 있었다.<br>
문제는 <a href="https://www.acmicpc.net/problem/11650" target="_blank" rel="noopener">좌표 정렬하기</a>이다.<br>
비교적 간단한 문제이지만 Array와 ArrayList 모두 사용해서 풀 수 있는 문제이다.</p>
<p>하지만, <strong>실행 시간이 다르다.</strong> 왜 다른지 찾아보기로 했다.</p>
                    
                        <a
                            href="/2019/03/26/Java-Diff-Array-ArrayList/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] Array VS ArrayList"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/24/Algo-Get-the-Prime/"
                            aria-label=": [소수 구하기] 에라토스테네스의 체"
                        >
                            [소수 구하기] 에라토스테네스의 체
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-24T14:09:02+09:00">
	
		    Mar 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>소수를 구하는 방법은 여러가지가 있다. 하지만 시간이 덜 거리고 빠르게 찾을 수 있는 방법이 있다면 사람들은 그 방법을 사용하지 않을까? 맞다. 사람들은 짧은 시간이 걸리는 것을 선호한다. 세상의 공짜란 없듯이 짧은 시간이 걸리는 방법은 구현 방법이 기존보다는 조금 어렵다. 그렇다면 어떤 방법인지 알아보자.</p>
<blockquote>
<p>소수란?</p>
</blockquote>
<p>1과 자기 자신으로만 나누어 떨어지는 수를 <strong>소수</strong>라고 한다. 즉, 자기 자신보다 작은 수들로 나누어봐서 하나라도 나누어 떨어지는 수가 존재하면 소수가 아니라는 뜻이다.</p>
<h2 id="에라토스테네스의-체">에라토스테네스의 체</h2>
<p><strong>소수</strong>의 개념을 간단하게 알아봤으니 <code>에라토스테네스의 체</code> 방법을 알아보자.</p>
<ul>
<li>120까지의 모든 소수를 구한다고 가정해보자.</li>
<li>2부터 120까지 수를 배열에 모두 넣는다.</li>
<li><strong>소수가 아닌 수들을 모두 체크해버린다.</strong></li>
</ul>
<p>2를 제외한 모든 2의 배수를 체크한다.<br>
3을 제외한 모든 3의 배수를 체크한다.<br>
4를 제외한 모든 4의 배수를 체크한다.</p>
<p>이와 같은 방식으로 소수가 아닌 수들을 체크한다. 그러면 배열에서 체크되지 않은 수들은 <strong>소수만 남게 된다.</strong> 생각보다 그렇게 어렵지 않고 간단하게 이해하고 구현할 수 있다.</p>
<h2 id="첫-번째-방법"># 첫 번째 방법</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_LINE = <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="comment">// 자신과 같지 않고 0으로 나누어 떨어지면 소수가 아니다. </span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] !=i &amp;&amp; arr[j] % i == <span class="number">0</span>)&#123;</span><br><span class="line">                    arr[j] = <span class="number">0</span>; <span class="comment">// 소수가 아닌 경우 0을 넣는다. </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                bw.write(i + NEW_LINE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 방식으로 구하면 <strong>에라토스테네스의 체</strong> 방식을 이용하지 않는 방식보다 시간이 오래 걸린다. 그러면 우리가 이 방식을 사용하는 의미가 없지 않는가?? 이제 <strong>에라토스테네스의 체</strong>를 이용해 최상의 소수 구하기 프로그램을 만들어보자.</p>
<h2 id="두-번째-방법"># 두 번째 방법</h2>
<p>체크할 때 모든 수를 다 돌면서 체크할 필요 없이 <strong>체크할 배수만큼만 반복문을 돌게 하는 것</strong>이다. 그리고 이미 <strong>0으로 체크되어버린 수의 배수는 확인하지 않는다.</strong> 왜냐하면 어떤 수가 소수가 아니라면 그 수의 배수도 소수가 아니기 때문이다.</p>
<p>ex)<br>
2를 제외한 2의 배수를 체크한다.<br>
2,4,6,8,10,12,14 …</p>
<p>4를 제외한 4의 배수를 체크한다.<br>
4,6,8,12,16,…<br>
<code>이미 2의 배수를 체크할 때 체크가 되어 있기 때문에 건너뛸 수 있다.</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_LINE = <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 에라토스테네스의 체에서 0과 1은 제외하고 시작하기 때문에 체크한다.</span></span><br><span class="line">        check[<span class="number">0</span>] = check[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 체크되어 있으면 건너뛴다.</span></span><br><span class="line">            <span class="comment">// 체크가 되어 있다는 뜻은 소수가 아니라는 뜻이다.</span></span><br><span class="line">            <span class="keyword">if</span> (check[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 해당 수의 배수만큼 반복문을 돌면서 체크한다. </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="comment">// 소수가 아닌 것들을 true로 체크한다.</span></span><br><span class="line">                check[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check[i]) &#123;</span><br><span class="line">                bw.write(i + NEW_LINE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 경우 결과는 매우 짧은 시간이 나오는 것을 확인할 수 있었다. 앞으로 소수를 구할 때는 <code>에라토스테네스의 체</code> 방식을 이용하자.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://marobiana.tistory.com/91" target="_blank" rel="noopener">소수 구하기 최적의 알고리즘 (2) - 에라토스테네스의 체</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/24/Algo-Get-the-Prime/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/23/Algo-Shell-Sort/"
                            aria-label=": [알고리즘] 정렬 알고리즘 Part2"
                        >
                            [알고리즘] 정렬 알고리즘 Part2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-23T01:05:14+09:00">
	
		    Mar 23, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>저번에 살펴봤던 기본적인 정렬 알고리즘에 이어 이번에는 조금 어려운 정렬 알고리즘을 살펴보자. 물론 이번 것도 어려운 것은 아니지만 상대적으로 비교해봤을 때 저번 정렬 알고리즘들보다 어렵다!</p>
<h2 id="쉘-정렬"># 쉘 정렬</h2>
<ul>
<li><strong>삽입 정렬을 보완</strong>한 알고리즘이다.</li>
<li>삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠르다는 것에 착안한 것이다.
<ul>
<li>삽입 정렬의 최대 문제점 : 요소들이 삽입될 때, 이웃한 위치로만 이동한다.</li>
<li>다시 말해서 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야 제자리로 갈 수 있다.</li>
<li>삽입 정렬과 다르게 <strong>쉘 정렬</strong>은 전체의 리스트를 한 번에 정렬하지 않는다. 그래서 <strong>요소들이 멀리 떨어진 위치로 이동할 수 있다.</strong></li>
</ul>
</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ol>
<li>먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류한다.</li>
<li>연속적이지 않은 여러 개의 부분 리스트를 생성한다.<br>
(실제로 여러 개의 부분 리스트가 생기고 이것들을 병합하는 것이 아니라, 단순히 gap 값으로 간격을 주어 부분 리스트가 만들어진 것처럼 구현한다. )</li>
<li>각 부분 리스트를 삽입 정렬을 이용하여 정렬한다.</li>
<li>모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복한다.</li>
<li>위의 1~4번까지의 과정을 리스트의 개수가 1이 될 때까지 반복한다.</li>
</ol>
<p>기본 로직은 이렇지만 사실 잘 와닿지 않는다. 한 번 더 살펴보자.</p>
<ul>
<li>정렬해야 할 리스트의 각 <strong>k번째</strong> 요소를 추출해서 부분 리스트를 만든다. 이때, k를 <code>간격(gap)</code>이라고 한다.
<ul>
<li>간격(gap) 즉 k의 초기값 : (정렬할 값의 개수) / 2</li>
<li>생성된 부분 리스트의 개수는 gap과 같다.</li>
</ul>
</li>
<li>각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
<ul>
<li>간격은 홀수로 하는 것이 좋다. (간격을 정하는 방법은 여러가지다.)</li>
<li>간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.</li>
</ul>
</li>
<li>간격 k(gap)가 1이 될 때까지 반복한다.</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 <strong>더 큰 거리를 이동한다.</strong> 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.</li>
<li>부분 리스트는 어느 정도 정렬된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 쉘 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 <strong>정렬된 상태이므로 삽입 정렬보다 더욱 빠르게 수행된다.</strong></li>
<li>알고리즘이 간단해서 쉽게 구현이 가능하다.</li>
</ul>
<p><strong>시간 복잡도</strong></p>
<ul>
<li>평균 : O(N^1.5)</li>
<li>최악의 경우 : O(N^2)</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>연속적이지 않은 부분 리스트에서 자료의 교환을 진행하여 <strong>더 큰 거리를 이동</strong>한다. 기존의 삽입 정렬에서는 한 칸씩 이동하며 비교를 하여 key 값의 자리를 찾았기 때문에 먼 거리를 이동할 경우 그만큼 반복 비교 연산이 많이 일어나는 단점이 있었다. 더 큰 거리를 이동함으로써 <strong>교환되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높아진다.</strong></li>
<li>최종 자리를 더 빨리 찾아감으로써 <strong>연산의 횟수를 줄이는데 기여할 수 있다.</strong></li>
<li>삽입 정렬은 어느 정도 정렬이 된 배열에서 더 빠르게 동작한다는 것을 앞의 포스팅에서 살펴봤다. 이 점을 토대로 한 번에 정렬을 끝내는 것이 아니라 <strong>부분 리스트를 구성해 조금씩 정렬된 상태를 만들어가는 것</strong>이므로 삽입 정렬에 비해 <strong>속도가 점점 더 빠르게</strong> 수행된다.</li>
</ul>
<h2 id="합병-정렬"># 합병 정렬</h2>
<ul>
<li><code>존 폰 노이만</code> 선생님이 제안한 방법.</li>
<li>일반적인 방법으로 구현했을 때 이 정렬은 <strong>안정</strong> (stable) 정렬에 속하며, <strong>분할 정복 알고리즘</strong>의 하나이다.</li>
<li>분할 정복(divide and conquer) 방법
<ul>
<li>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.</li>
<li>분할 정복 방법은 대개 <strong>순환 호출</strong>을 이용하여 구현한다.</li>
</ul>
</li>
<li>오름 차순을 기준으로 정렬한다.</li>
</ul>
<p><strong>기본 로직은 다음과 같다.</strong></p>
<ol>
<li>리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.(리스트의 길이가 1이 될때까지 반으로 잘게 나눈다.) 그렇지 않은 경우에는</li>
<li>정렬되지 않은 리스트를 절반으로 나눠 비슷한 크기의 두 부분 리스트로 나눈다.</li>
<li>각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li>
<li>두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.</li>
</ol>
<p><strong>구체적으로 다시 설명해보면 다음과 같다.</strong></p>
<ul>
<li>최종 목표는 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 것이다.</li>
<li>합병 정렬은 다음의 단계들로 이루어진다.
<ul>
<li><strong>분할</strong>(Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.</li>
<li><strong>정복</strong>(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 <code>순환 호출</code>(재귀 호출)을 이용하여 다시 분할 정복 방법을 적용한다.</li>
<li><strong>결합</strong>(Combine) : 정렬된 부분 배열을 하나의 배열에 합병한다.</li>
</ul>
</li>
<li>합병 정렬의 과정
<ul>
<li>추가적인 리스트가 필요하다.</li>
<li>각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다.(재귀 호출)</li>
<li>합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 <strong>합병</strong>(Merge)하는 단계이다.</li>
</ul>
</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>안정적인 정렬 방법이다. <strong>stable</strong>하다.</li>
<li>데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. -&gt; O(n logn)으로 동일.</li>
<li>만약 레코드를 <strong>연결 리스트</strong>(LinkedList)로 구성하면 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
<ul>
<li>제자리 정렬(in-place sorting)을 구현할 수 있다.</li>
</ul>
</li>
<li>따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>만약 레코드를 <strong>배열</strong>로 구성하면, 임시 배열이 필요하다.
<ul>
<li>메모리 낭비를 초래할 수 있다.</li>
<li>제자리 정렬(in-place sorting)이 아니다.</li>
</ul>
</li>
<li>레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.</li>
</ul>
<p><strong>시간 복잡도</strong><br>
크기가 N인 배열을 반으로 쪼개면서 분할한다.<br>
한 번 분할하면 N/2, N/2 -&gt; 2개가 생기고,<br>
그 다음 분할하면 N/4, N/4, N/4, N/4 -&gt;4개</p>
<p>이처럼 분할 과정은 매번 반씩 감소하므로 밑이 2인 log N만큼 반복해야 크기가 1인 배열로 분할 할 수 있다.</p>
<p>각 분할별로 합병을 진행하므로 합병 정렬의 시간 복잡도는 O(NlogN)이다.</p>
<ul>
<li>평균 : NlogN</li>
<li>최악 : NlogN</li>
<li>최상 : NlogN</li>
</ul>
<p>다음의 글을 참고하자. -&gt; <a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html" target="_blank" rel="noopener">병합 정렬의 시간복잡도</a></p>
<h1 id="퀵-정렬"># 퀵 정렬</h1>
<ul>
<li>오름차순을 기준으로 정렬한다.</li>
<li>'찰스 앤터니 리처드 호어’가 개발한 정렬 알고리즘이다.</li>
<li><strong>불안정 정렬</strong>에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 <strong>비교 정렬</strong>에 속한다.</li>
<li>분할 정복 알고리즘의 하나로, 평균적으로 <code>매우 빠른 수행 속도</code>를 갖는다.
<ul>
<li>Merge Sort와 달리 퀵 정렬은 리스트를 <strong>비균등</strong>하게 나눈다.</li>
</ul>
</li>
<li><strong>분할 정복 방법</strong>(Divide and Conquer)
<ul>
<li>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.</li>
<li>분할 정복 방법은 순환 호출(재귀 호출)을 이용하여 구현한다.</li>
</ul>
</li>
</ul>
<p><strong>기본 로직은 다음과 같다.</strong></p>
<ol>
<li>리스트 안에서 하나의 원소를 선택한다. 이 원소를 <strong>피봇</strong>이라고 한다.</li>
<li>피봇을 기준으로 왼쪽에는 피봇보다 작은 원소들을 옮기고 오른쪽에는 피봇보다 큰 원소들을 옮긴다.</li>
<li>피봇을 제외한 왼쪽 부분 집합과 오른쪽 부분 집합을 다시 정렬한다.
<ul>
<li>분할된 부분 집합에 대해 <strong>순환 호출</strong>을 이용하여 정렬을 반복한다.</li>
<li>부분 집합에 대해서도 다시 피봇을 정하고 피봇 기준으로 2개의 부분 집합으로 나누는 과정을 반복한다.</li>
</ul>
</li>
<li>부분 집합이 더 이상 분할이 불가능할 때까지 반복한다.
<ul>
<li>리스트의 크기가 0이나 1이 될 때까지 반복한다.</li>
</ul>
</li>
</ol>
<p><strong>퀵 정렬에서 알아야 할 개념</strong></p>
<ul>
<li>분할(Divide) : 정렬할 자료들을 피봇을 중심으로 좌, 우 2개의 부분집합으로 나누는 것을 말한다.</li>
<li>정복(Conquer) : 부분집합의 원소들 중에서 피봇보다 작은 원소들은 왼쪽, 큰 원소들을 오른쪽 부분집합으로 정렬하는 과정이다.</li>
<li>부분 집합의 크기가 더 이상 나눌 수 없을 때까지(부분 집합의 원소가 1개 이하) 분할, 정복 과정이 반복된다.</li>
<li><strong>피봇</strong> : 기준 값(일반적으로 전체 원소 중 가운데에 위치한 원소)</li>
<li>L : 왼쪽에서 오른쪽으로 움직이며 피봇보다 큰 원소를 찾아 L로 지정.</li>
<li>R : 오른쪽에서 왼쪽으로 움직이며 피봇보다 작은 원소를 찾아 R로 지정.</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>속도가 빠르다.
<ul>
<li>시간 복잡도가 O(NlogN)을 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.</li>
</ul>
</li>
<li>추가 메모리 공간을 필요로 하지 않는다.
<ul>
<li>퀵 정렬은 O(NlogN) 만큼의 메모리를 필요로 한다.</li>
</ul>
</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
<ul>
<li>퀵 정렬의 불균형 분할을 방지하기 위해 피봇을 선택할 때 리스트를 더욱 균등하게 분할할 수 있는 데이터를 선택한다.</li>
<li>Ex) 리스트 내의 몇 개의 데이터 중에서 크기순으로 <strong>중간 값</strong>을 피봇으로 선택한다.</li>
</ul>
</li>
</ul>
<p><strong>시간 복잡도</strong></p>
<ul>
<li>평균, 최선 : O(NlogN)</li>
<li>최악 : O(N^2)</li>
</ul>
<p>일반적으로는 O(NlogN)의 성능을 나타내지만,<br>
피봇이 항상 최솟값이나 최댓값으로 잡힙다면 최악의 성능인 O(N^2) 나온다.<br>
이미 정렬된 리스트에 대해서 첫 번째 원소 혹은 마지막 원소를 피봇으로 선택할 경우 최악의 성능을 맛 볼 수 있다.</p>
<p><strong>그래서 중간 값을 피봇으로 선택하는 것이 시간 복잡도가 최악의 경우인 O(N^2)을 피할 수 있는 방법이기도 하다.</strong></p>
<h2 id="느낀-점">느낀 점</h2>
<p>정렬 알고리즘은 크게 보면 두 가지 분류로 나눌 수 있을 것 같다.</p>
<ul>
<li>단순(구현이 간단)하지만 비효율적인 방법
<ul>
<li>삽입 정렬, 선택 정렬, 버블 정렬</li>
</ul>
</li>
<li>복잡하지만 효율적인 방법
<ul>
<li>퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬</li>
</ul>
</li>
</ul>
<p>이 중에서 퀵 정렬이 가장 어려웠다. 개념을 이해하고 코드를 보는데 이해가 되지 않았다. 여러 사람들이 정리한 블로그를 참고해서 코드를 보니까 조금씩 구현이 달라서 방향을 잡지 못했다.</p>
<p>그래서 2개의 블로그를 참고해서 코드를 돌려보면서 실제로 디버깅을 해보니까 이해가 확실히 갔다. 생각보다 정렬 알고리즘이 재미있었다. 기억력이 오래 갔으면 좋겠지만 아닐 수도 있으니 빠른 시일 내에 복습을 해야겠다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html" target="_blank" rel="noopener">[알고리즘] 셸 정렬(shell sort)이란</a></li>
<li><a href="https://mattlee.tistory.com/76" target="_blank" rel="noopener">&lt;셸 정렬(shell sort)&gt; 기본 개념 및 알고리즘</a></li>
<li><a href="https://prosto.tistory.com/177" target="_blank" rel="noopener">퀵 정렬(Quick Sort) - C언어/자료구조</a></li>
<li><a href="https://creatordev.tistory.com/70" target="_blank" rel="noopener">자바로 구현하는 퀵정렬 (Quick Sort) 알고리즘</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html" target="_blank" rel="noopener">[알고리즘] 퀵 정렬(quick sort)이란</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/23/Algo-Shell-Sort/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/20/Algo-Select-Sort/"
                            aria-label=": [정렬] 정렬 알고리즘 Part1"
                        >
                            [정렬] 정렬 알고리즘 Part1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-20T17:04:04+09:00">
	
		    Mar 20, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>정렬 알고리즘은 개발자 면접을 보기 위해서 꼭 필요한 내용이다.<br>
하나씩 정리해보고 숙지해보자.<br>
정렬 알고리즘은 다음과 같이 간단하게 나눠볼 수 있다.</p>
<ul>
<li><strong>단순하지만 비효율적인 방법</strong>
<ul>
<li>선택 정렬, 삽입 정렬, 버블 정렬</li>
</ul>
</li>
<li><strong>복잡하지만 조금 더 효율적인 방법</strong>
<ul>
<li>퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬</li>
</ul>
</li>
</ul>
<p><strong>Q. 정렬은 왜 사용할까?</strong><br>
탐색을 빠르게 하기 위해서 정렬을 한다.<br>
하지만 정렬 방법은 많고 이 중에서 제일 빠른 걸 사용해야 한다.<br>
같은 시간 복잡도를 갖더라도 요소에 따라 달라질 수 있으니 알아보자.</p>
<h2 id="선택-정렬"># 선택 정렬</h2>
<p>기본이 되는 정렬 중 하나이다. 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라서 최소 선택 정렬(오름차순으로 정렬)과 최대 선택 정렬(내림차순으로 정렬)이 있다.</p>
<p><strong>기본로직은 아래와 같다.</strong></p>
<ol>
<li>정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후 배열의 값 중 가장 작은 값을 찾는다.</li>
<li>가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.</li>
<li>다음 인덱스에서 위의 과정을 반복한다.</li>
</ol>
<p>쉽게 설명하면 기준이 되는 수와 나머지 수를 비교해서 가장 작은 수를 앞으로 계속 보내는 정렬이다. 간단하지만 매우 비효율적이다.</p>
<p>최악의 경우, 최선의 경우, 평균적인 경우 모두 <code>시간 복잡도 : O(N^2)</code>을 갖는다.</p>
<p><strong>장점</strong></p>
<ul>
<li>데이터의 양이 적을 때 좋은 성능을 나타냄</li>
<li>적은 값을 선택하기 위해서는 비교는 여러번 수행되지만 교환횟수가 적다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>100개 이상의 자료에 대해서는 속도가 급격히 떨어져 적절히 사용되기 힘들다.</li>
</ul>
<h2 id="버블-정렬"># 버블 정렬</h2>
<ul>
<li>서로 인접한 두 원소를 검사하여 정렬하는 알고리즘을 갖는다.
<ul>
<li>인접한 2개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.</li>
</ul>
</li>
<li>선택 정렬과 기본 개념이 유사함.</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ol>
<li>버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를 … n-1번째 자료와 n번째 자료를 비교하여 교환하면서 자료를 정렬한다.</li>
<li>1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동한다.</li>
<li>이렇기 때문에 2회전에서는 맨 끝에 있는 자료가 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.</li>
</ol>
<p>쉽게 설명하면 현재 원소와 다음 원소를 비교해서 큰 원소를 뒤로 보내는 정렬이다.</p>
<p>최악의 경우, 최선의 경우, 평균적인 경우 모두 <code>시간 복잡도 : O(N^2)</code>을 갖는다.<br>
이미 정렬된 데이터에 대해서 검사하는데는 O(N)으로 간단하게 할 수 있다.</p>
<p><strong>장점</strong></p>
<ul>
<li>구현이 쉽다.</li>
<li>이미 정렬된 데이터를 정렬할 때 가장 빠르다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>다른 정렬에 비해 정렬 속도가 느리다.</li>
<li>역순배열을 정렬할 때 가장 느리다.</li>
<li>정말 비효율적이라 거의 쓰이지 않는다.</li>
</ul>
<h2 id="삽입-정렬"># 삽입 정렬</h2>
<p>삽입 정렬의 기본 개념은 손안의 카드를 정렬하는 방법과 유사하다.</p>
<ul>
<li>새로운 카드를 기존의 정렬된 카드 사이에 올바른 자리를 찾아 삽입한다.</li>
<li>새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.</li>
<li>자료 배열의 모든 요소를 <strong>앞에서부터 차례대로 이미 정렬된 배열 부분과 비교</strong>하여 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘.</li>
<li>매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ul>
<li>오름차순을 기준으로 정렬한다.</li>
</ul>
<ol>
<li>기준이 되는 인덱스는 두 번째 자료부터 시작한다. 이 기준이 되는 인덱스를 <strong>Key</strong>라고 하겠다. Key가 들어갈 자리를 찾는게 핵심이다.</li>
<li>Key는 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료들을 뒤로 옮기고 지정한 자리에 Key 자료를 삽입하여 정렬한다.</li>
<li>즉, 두 번째 자료는 첫 번째 자료와 비교하고 세 번째 자료는 두 번째와 첫 번째 자료 …  이런 방식으로 비교해서 기준이 되는 자료가 들어갈 위치를 찾는다.</li>
<li>최종적으로 Key가 들어갈 위치를 찾았다면 자료들을 한칸씩 뒤로 이동시키고 그 자리에 삽입한다.</li>
</ol>
<p>쉽게 말하면 기준이 되는 인덱스의 앞쪽(왼쪽)을 검사하여 기준이 되는 인덱스가 들어갈 자리를 찾아서 삽입하는 정렬이다.</p>
<p>최악의 경우 : O(N^2) - 자료가 역순으로 정렬되어 있을 경우/작은 값이 뒤에 몰려있을 경우<br>
최선의 경우 : O(N) - 이동없이 1번의 비교만 이루어질 경우<br>
평균적인 경우 : O(N^2)</p>
<p><strong>장점</strong></p>
<ul>
<li>stable한 정렬 방법</li>
<li>적은 수를 정렬할 경우 알고리즘 자체가 간단해서 다른 복잡한 정렬 방법보다 유리할 수 있다.</li>
<li>대부분의 수가 이미 정렬되어 있는 경우에 매우 효율적이다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>비교적 많은 수들의 이동을 포함한다.</li>
<li>비교할 수가 많고 크기가 클 경우에 적합하지 않다.</li>
</ul>
<h2 id="결론">결론</h2>
<p>위에서 살펴본 정렬 알고리즘들은 비교적 구현이 간단하다. 그리고 이해하기도 어렵지 않다. 하지만 속도가 느리다는 단점이 존재한다. 다음에는 이보다 속도가 좋은 정렬 알고리즘을 살펴보도록 하겠다.</p>
<p><strong>stable과 unstable</strong></p>
<ul>
<li>stable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌지 않는 경우</li>
<li>unstable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌는 경우</li>
</ul>
<p>다음의 예를 한 번 생각해보자.<br>
ex) 5, 4, 8, 8, 5, 3, 1, 10, 6<br>
숫자가 있고 순서를 부여해보자.<br>
ex 5(1), 4(2), 8(3), 8(4), 5(5), 3(6), 1(7), 10(8), 6(9)</p>
<p>()안의 숫자는 해당 노드(수)가 들어온 순서를 뜻한다. 만약 정렬할 시에 key 값을 기준으로 정렬을 하되, 같은 key 값을 가진 노드는 들어온 순서에 따라 다시 정렬되어야 한다면 어떻게 할 것인가? 다음 결과와 같이 최종적으로 정렬된 정보가 바로 stable한 것이다. 정렬된 결과는 다음과 같다.</p>
<p>ex) 1(7), 3(6), 4(2), 5(1), 5(5), 6(9), 8(3), 8(4), 10(8)</p>
<ul>
<li><strong>선택 정렬</strong> : unstable</li>
</ul>
<p>ex) 5(1), 4(2), 5(3), 2(4), 3(5)<br>
위에서 5(1)과 2(4)를 교환한다.<br>
ex) 2(4), 4(2), 5(3), 5(1), 3(5)<br>
위의 결과가 나온다. 처음의 순서를 유지하지 않게 된다. 이러한 이유로 선택 정렬은 stable한 결과를 보장할 수 없기 때문에 <strong>unstable</strong>하다고 한다.</p>
<ul>
<li><strong>버블 정렬</strong> : stable</li>
<li><strong>삽입 정렬</strong> : stable</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://dpdpwl.tistory.com/17" target="_blank" rel="noopener">[Algorithm]선택정렬 예제(selection sort)</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html" target="_blank" rel="noopener">정렬 기본</a></li>
<li><a href="http://blog.naver.com/zephyehu/150013176075" target="_blank" rel="noopener">stable과 unstable에 대하여</a></li>
<li><a href="https://marobiana.tistory.com/85" target="_blank" rel="noopener">[JAVA] Insertion Sort (삽입정렬)</a></li>
<li><a href="https://geekhub.tistory.com/62" target="_blank" rel="noopener">기술면접 list - 알고리즘</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/20/Algo-Select-Sort/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/02/2018-Review/"
                            aria-label=": [2018 회고]"
                        >
                            [2018 회고]
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-02T00:23:37+09:00">
	
		    Mar 02, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>2019년이 되고 3달이나 지났다. 회고라는 걸 해본 적이 없지만 지인의 회고를 보고 영감을 받아서 작성하겠다고 마음을 먹었다. 2018년은 나에게 힘들고 아프면서 많은 걸 경험하게 해줬다.<br>
이 회고는 내가 2018년 동안 <strong>어떤 걸 했고, 어떤 걸 느꼈는지 내가 내린 선택과 결과</strong>를 잊지 않기 위해 작성할 예정이다.<br>
그리고 2019년에는 <strong>어떤 마음 가짐과 목표를 세우고 달려나갈지 생각</strong>하기 위함이다.</p>
<p><code>2019.03.05</code> 기준으로 다시 작성한다. 왜냐하면 캠프 끝난 기념으로 제주도 여행을 갔다 왔기 때문이다…ㅎㅎ 즐겁게 놀고 잘 쉬다가 왔으니 새로운 마음가짐으로 회고를 할 예정이다.</p>
<ul>
<li><a href="#%EB%AF%B8%EC%9C%A0%EB%B0%95%EC%8A%A4">미유박스</a></li>
<li><a href="#%EC%84%9C%EC%9A%B8%EC%8B%9C-%EA%B3%B5%EB%AA%A8%EC%A0%84">서울시 공모전</a></li>
<li><a href="#SK-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B4%80%EA%B4%91-%EA%B3%B5%EB%AA%A8%EC%A0%84">SK 스마트 관광 공모전</a></li>
<li><a href="#%ED%9A%8C%EC%82%AC-%EC%83%9D%ED%99%9C">회사 생활</a></li>
<li><a href="#%EB%B6%80%EC%8A%A4%ED%8A%B8-%EC%BA%A0%ED%94%84">부스트 캠프</a></li>
</ul>
<h2 id="미유박스"># 미유박스</h2>
<p><a href="http://sopt.org/wp/" target="_blank" rel="noopener"><strong>SOPT</strong></a> 22기 앱잼을 했던 프로젝트 미유박스이다. 솝트 22기에 다시 안드로이드 파트원으로 지원하면서 세웠던 목표는 <strong>수상</strong>과 <strong>성장</strong> 두 가지로 요약할 수 있다. 왜냐하면 전기수에 <code>Lang</code>이라는 프로젝트에서 부족한 실력으로 인해서 결과물을 내지 못했던 경험이 있기 때문에 더 잘하고 싶다는 욕심이 생겼다.</p>
<p>미유박스는 사전 팀빌딩 없이 네트워킹을 통해 들어가게 되었다. 수상을 하고 싶다는 목표를 가지고 참여했지만, 안드로이드 개발자는 나를 포함해 2명 뿐이었다. 자신감이 하락하는 소리가 들린다. 그래도 포기는 너무 이른 생각이었다.</p>
<p>2주 동안 정말 치열하고 재미있게 프로젝트를 진행했다. 밤 새는 걸 못하던 나는 앱잼 기간동안 잠도 많이 줄여야 했고 합숙하는 동안은 거의 매일 같이 밤 새고 아침에 잠 들었다. 그래도 팀원들과 즐거운 분위기 속에서 개발을 했기 때문에 힘들다는 생각은 적게 할 수 있었다.</p>
<p>노력의 결과로 우리 팀은 <strong>대상</strong>이라는 명예를 얻을 수 있었다. 이 상은 나에게 있어서 의미가 컸다. 내가 노력한 결과로 상을 받은 경험을 처음이었기 때문이다. 좋은 분위기를 이끌어준 팀원들과 함께 노력한 결과가 수상으로 이어져서 기분이 정말 좋았다.</p>
<p>기능은 많지 않았지만 앱을 안정적으로 만들고 <strong>결제 기능</strong>을 테스트용으로 구현할 수 있어서 좋은 경험을 했다.</p>
<blockquote>
<p>이를 통해서 내가 느꼈던 점은 다음과 같다.</p>
</blockquote>
<ul>
<li>안드로이드 개발자로서 &quot;<strong>자신감</strong>&quot;을 얻을 수 있었고, 전보다 성장했음을 느낄 수 있었다.</li>
<li>안드로이드 개발에 대한 &quot;<strong>흥미</strong>&quot;를 일깨워 줄 수 있는 경험이 되었다.</li>
<li>미유박스는 앞으로의 내 행보에 발판을 마련해준 중요한 경험이 되었다. 앞으로도 미유박스 팀은 꾸준하게 오래 보는 사이가 되었으면 좋겠다. ^_^</li>
</ul>
<img src="/img/MeowBox.png" width="700" height="300">
<h2 id="서울시-공모전"># 서울시 공모전</h2>
<p>미유박스에서 같이 개발했던 형의 소개로 일정에 없던 공모전에 참여하게 되었다. 공모전을 준비해 본 경험이 없어서 하고 싶은 마음은 계속 있었다. 그러던 와중에 좋은 기회가 생겼다. 아는 형을 제외하고는 다 처음 보는 사이였다. 프로젝트의 기획 단계는 마무리가 되었고 디자인과 개발만 시작하면 되는 시점이었다.</p>
<p>그래서 뭔가 날로 먹는 느낌이 강해서 찜찜했지만 개발을 시작하면서 그 생각은 사라졌다. 너무 여유를 부렸던 탓인지 개발 속도는 진전이 없었다. 나는 공모전을 해보고 싶었고 상을 받고 싶은 욕심이 있었기 때문에 빨리 개발을 진행할 수 있도록 분위기를 유도했다. 그래도 어느정도 진전이 있었다.</p>
<p>같이 하기로 했던 한 분이 좋은 기회로 인턴에서 정직원으로 전환이 되었다고 했다. 그래서 그 분을 대체할 분을 데리고 오셨고 기분 좋게 개발을 하는가 싶었다. <strong>인생은 고난의 연속이라고 했던 누군가의 말이 생각났다.</strong> 대타로 들어오신 분이 사정이 있어서 빠지게 되었다. 그래서 기능 한개가 비어버리게 되었고, 이 부분까지 내가 맡아서 개발을 진행했다.</p>
<p>덕분에 <code>내가 처음에 맡았던 기능 + 대타 분이 떠나서 구현해야 하는 기능</code>을 신경 써야 했다. 또 하필, 이 기간은 내가 3~4달 동안 <strong>위워크</strong>에 있는 회사에서 잠깐 일했던 기간이기도 했다.(이 얘기는 밑에서 등장한다.) 그래서 회사에 갔다가 퇴근하고 공모전을 하면서 하루에 4~5시간 밖에 못 잤던 걸로 기억한다.</p>
<p>너무 힘들었지만 공모전을 한다고 결정한 나에게 포기하는 모습을 보여주고 싶지 않았다. 그래서 시간을 할애해서 정말 열심히 했다. 내가 선택한 일에 대해서 후회하고 싶지 않았던 마음과 공모전을 하고 싶었던 나의 버킷 리스트를 잘 실천하고 싶은 두 개의 마음이 나를 열심히 하게 한 원동력이 된 것 같다.</p>
<p>좋은 결과를 얻지는 못했지만, 재미있는 사람들과 공모전을 하면서 즐거웠다. 짧고 치열한 기간에 개발을 하자고 팀원들한테 얘기하면서 쪼았지만 잘 따라서 마무리를 해준 것을 고맙게 생각하고 있다.</p>
<blockquote>
<p>서울시 공모전을 하면서 느낀 점</p>
</blockquote>
<ul>
<li>내가 내린 결정에 대해서 후회하지 않고, 책임감을 가지고 일을 진행해야 한다는 걸 배웠다.</li>
<li>개발적인 부분을 다른 사람한테 설명하기 위해서는 내가 많은 지식을 알고 있어야 한다는 걸 알았다.</li>
<li>Git을 조금 더 능숙하게 다룰 줄 알았다면 더 편하게 협업을 하지 않았을까를 깨닫게 되었다.</li>
</ul>
<h2 id="kb-app-challenge"># KB App Challenge</h2>
<p>아마 지금 와서 2018년도에 했던 일들을 다시 하라고 한다면 나는 못할 것 같다. 내가 활동하던 SOPT에서 주최한 <strong>KB App Challenge</strong>였다. KB의 클라우드 관련 신기술인 <a href="https://www.clayon.io/" target="_blank" rel="noopener"><strong>클래용</strong></a>을 활용하여 유스 고객을 타겟으로 하여 금융 관련 지식들을 라이브 방송을 통해 알려주고 포인트를 쌓을 수 있는 애플리케이션의 프로토 타입을 개발했다.</p>
<p>프로젝트 기간이 <strong>2주</strong>였기 때문에 기획을 빨리 픽스하고 개발에 도입했다. 안드로이드 개발은 80% 정도 혼자 진행했다. 회사를 다니면서 퇴근하면 바로 종각역 근처에 위치한 <strong>패스트 파이브</strong>로 향했다. 2주 동안 짧고 치열하게 프로젝트를 완성시키고 최종 발표를 했다.</p>
<p>최종 발표는 KB 본사 건물에서 진행했고, KB 회장님을 비롯하여 임직원분들이 오셔서 우리가 진행한 프로젝트를 보고 평가해주셨다. 훌륭한 팀원들 덕분에 2등을 할 수 있었다. 아마도 <strong>최우수상</strong>이었던 걸로 기억한다. <code>100만원</code> 상금을 받고 5명이서 20만원씩 나눴다. 뜻깊은 경험도 하고 평생 만날 기회가 없을 KB 회장님도 직접 뵙고 사진도 찍고 상금까지 얻을 수 시간이었다.</p>
<blockquote>
<p>KB 프로젝트를 하며 느낀 점</p>
</blockquote>
<ul>
<li>앱 개발자로서 UI를 더 생각해보고 신경쓸 수 있었다. 그래서 UI를 만들 때 전보다 개선된 걸 느낄 수 있었다.</li>
<li>기존에 사용했던 기술이 아닌 색다른 기술을 사용해 볼 수 있어서 좋았다. 결국은 <strong>Youtube Player API</strong>를 사용했지만, 영상 재생을 구현하는 방법에 대해서 고민해 볼 수 있는 좋은 시간이었다.</li>
</ul>
<img src="/img/kb_app_challenge.png" width="700" height="300">
<center>[ KB App Challenge 사진 ]</center>
<p>나는 눈에 띄는 파란색 니트를 입고 가운데서 사진을 찍었다. 재밌었다. :)</p>
<h2 id="sk-스마트-관광-공모전"># SK 스마트 관광 공모전</h2>
<p>공모전을 하고 싶었던 나의 소망이 좀 이상했다. 한 번에 3개씩 하겠다는게 아니었는데 어쩌다 보니 1개는 먼저 진행했고 2개가 기간이 겹치는 문제가 발생했다. ㅠ_ㅠ 앞의 KB가 끝나자마자 바로 <code>SK 스마트 관광 공모전</code>을 시작했다.</p>
<p><strong>미유박스</strong>(자주 등장한다.ㅎㅎ)를 함께 진행했던 팀원들과 다른 사람 몇명을 추가해서 공모전을 진행했다. 팀원이 14명이었다. 지금 생각해도 너무 많았던 것 같다. 그래서 우리 팀의 목표는 무조건 1등이었다. 왜냐하면 1등은 상금이 <code>1천만원</code>이었기 때문이다. 14명이서 나누면 약 70만원 가량의 상금을 얻을 수 있었다. 생각만 해도 행복하다.ㅎ0ㅎ</p>
<p>앞에서 진행했던 KB 프로젝트와 회사 생활로 인해서 <a href="https://github.com/WooVictory/DMZing-Andorid" target="_blank" rel="noopener"><strong>DMZing</strong></a>(우리 프로젝트 애플리케이션 이름이다.)의 초기 기획 단계에 많이 참여하지 못한 점이 아쉽고 미안하다. 아무튼 나는 마감 기간이 2주 정도 남았을 때 개발에 들어갔다. 안드로이드 개발을 할 때 운이 없는 건지 팀 프로젝트를 할 때 계속 두 명이서 진행했다. 힘들었다. . . ㅠㅠ</p>
<p>2주 동안 치열하게 잠을 줄여가면서 개발에 몰두했고 마무리를 잘해서 <code>Google Play Store</code>에도 올리는 경험을 했다. 이번 프로젝트에서 내가 하고 싶었던 건 <strong>중복을 없애고 재사용</strong>을 하는 것과 <strong>효율적으로 코드를 작성</strong>해보는 것이었다. 하지만, 기간이 짧기도 했고 시간이 많지 않아서 2개의 목표는 달성하지 못했다.</p>
<p>운이 좋게도 본선에 진출해서 최종 발표를 할 수 있는 기회를 얻었다. 기획과 디자인을 담당했던 친구들이 가서 발표를 하고 마무리를 잘 해줬다. 그리고 12월 00일에 최종 결과 발표가 있었다. 우리는 시간이 되는 사람들끼리 모여서 최종 결과를 받기 위해서 종각 근처의 <strong>콘랩</strong>으로 향했다. 대상을 받을거라고 김칫국을 마시던 우리는 <strong>장려상</strong>을 받고 아쉬워 했다. 그래도 함께 열심히 노력한 과정을 알기 때문에 빨리 잊어버렸다.</p>
<p><code>100만원</code>이라는 상금을 받고 14명이 나눠 가졌다. 대략 7만원 정도씩 가질 수 있었다. 나는 받았던 상금을 모으고 일했던 돈을 보태서 <strong>아이폰XS</strong>로 핸드폰을 바꿨다. 좋은 기회가 있어서 생각보다 저렴하게 구매했고 지금 만족하면서 잘 쓰고 있다. <a href="https://goodgid.github.io/" target="_blank" rel="noopener"><strong>갓기용</strong></a>님에게 항상 감사하고 있다.ㅎㅎ</p>
<blockquote>
<p>SK 스마트 관광 프로젝트를 하면서 느낀점</p>
</blockquote>
<ul>
<li>바쁘게 사는 건 좋지만 너무 빡빡한 일정은 좋지 않다는 것을 느꼈다. 여유가 없었기 때문에 회고를 할 수 있는 시간이 없었다. 그리고 <strong>KB 프로젝트</strong>와 <strong>SK 관광 프로젝트</strong>가 겹쳤기 때문에 한 가지에 집중하기 힘들어서 능률이 떨어지는 느낌을 받았다.</li>
<li>여유를 어느 정도 가지고 프로젝트나 일을 할 때는 한가지에 집중하는게 중요하다는 걸 깨달았다.</li>
<li>Store에 실제로 올리면서 <strong>개인 정보 취급 방침</strong>이 필요하다는 걸 알게 되었고, APK 파일을 추출하는 법에 대해서도 알 수 있었다. 개발자로서 꼭 필요한 경험을 할 수 있었다.</li>
</ul>
<h2 id="회사-생활"># 회사 생활</h2>
<p>4학년 1학기를 깔끔하게 마무리하고 2학기는 6학점만 남겨놓았다. 그래서 OCU라는 인터넷 강의를 2개 잡고 2학기에는 학교를 다니지 않았다. 이 기간 동안 무엇을 할까 고민을 많이 했다. 취업 준비를 해야 하는 시기가 맞지만, 나는 아직 취업 준비를 하고 싶지 않았다. 휴식을 취하고 싶었고, 돈을 벌고 싶은 마음이 있었다. 그래서 알바를 할까 생각을 했지만, 시간 낭비를 하지 않고 관련된 업무를 하면서 돈을 벌 수 있는 기회를 찾았다.</p>
<p>그러던 와중에 아는 지인이 다니는 회사를 추천받았다. 간단하게 말해서 인공지능에게 필요한 학습 데이터를 가공하는 업무였다. 타이틀은 거창하고 인턴이었지만 나는 단순 업무를 하는 아르바이트라고 생각했다. 9월에 입사를 했고 회사를 다니는 동안 시간을 틈틈히 쪼개서 위에서 언급했던 <strong>KB 프로젝트</strong>와 <strong>SK 스마트 관광 프로젝트</strong> 2개를 진행했다.</p>
<p>계약 기간이 12월 30일까지였기 때문에 나는 12월 30일에 퇴사를 했다. 3개월에서 4개월 정도의 짧은 기간이었지만 좋은 사람들을 만나고 회사를 다니면서 혼자 시간을 쪼개서 여러 가지를 할 수 있었다. 그리고 돈도 벌 수 있었다. 회사를 다니면서 많은 업무를 하지는 않았다. 처음부터 단순 업무라고 들었기 때문이다.</p>
<p>시간을 낭비했다고 생각하기도 하지만 내가 선택한 결정에 대해서 후회는 없다. 돈을 벌 수 있었고 더 바쁘게 생활하기도 했어서 오히려 나한테 자극을 줄 수 있는 시간이었다. 퇴사를 하면서 다음 회사는 &quot;<strong>내가 진짜 원하는 업무를 할 수 있는 회사에 들어가자</strong>&quot;라는 목표를 세웠다.</p>
<blockquote>
<p>회사를 다니면서 내가 느낀 점</p>
</blockquote>
<ul>
<li>첫 번째는 스타트업이라도 너무 작은 스타트업보다는 어느 정도 규모가 있는 스타트업이 좋을 것 같다는 점을 느꼈다. 규모가 너무 작으면 체계도 잘 잡혀있지 않은 것 같다.</li>
<li>두 번째는 식비나 교통비를 지원해주는 회사가 좋은 회사라는 것이다. 월급을 받지만 식비와 교통비로 지출이 생기기 때문에 돈 모으기가 힘들었다. 마지막에는 도시락을 싸서 다녔지만 아무래도 <code>식비+교통비</code>를 지원해준다면 꿈의 회사가 아닐까하는 생각이 들었다.</li>
<li>마지막으로 내가 진짜 원하는 업무를 하는 회사에 들어가서 재미있게 개발을 하자는 마음을 가지게 되었다.</li>
</ul>
<h2 id="부스트-캠프-후기-in-2019"># 부스트 캠프 후기 in 2019</h2>
<p>2018년은 프로젝트를 연달아서 쉬는 기간 없이 3개를 진행했다. <strong>발전이 없고</strong> 프로젝트만 계속 한 느낌?!을 받았다. 회고를 작성하지도 않았고 리뷰를 하지도 않았다. 심지어 프로젝트에 대한 정리도 하지 않았다. 아마 그래서 발전이 없었고 계속 같은 자리에 머물러 있는 것 같다는 느낌을 받았다. 이 상태로 있다가는 <strong>성장하는 개발자</strong>가 되지 못할 것 같았다.</p>
<p>그래서 나는 지금보다 한 단계 성장하고 다른 경험을 해보고 싶어서 <strong>부스트 캠프</strong>에 지원하게 되었다. 부스트 캠프는 네이버 계열사 중 하나인 <a href="https://connect.or.kr/" target="_blank" rel="noopener"><strong>커넥트 재단</strong></a>에서 진행하는 캠프이다. 내가 부스트 캠프에 지원하게 된 이유는 다음과 같은 것들을 얻고 싶어서다.</p>
<ol>
<li>현업에서 일하는 튜터님의 멘토링을 받고 좋은 조언들을 얻을 수 있다는 점</li>
<li>코드 리뷰를 통해서 코딩할 때 안좋은 습관을 없애고 실력을 쌓을 수 있다는 점</li>
<li>같은 분야를 공부하는 다른 개발자들을 만나보고 싶다는 점</li>
<li>자극을 받고 싶다는 점</li>
</ol>
<p>위의 4가지 이유로 인해서 부스트 캠프에 지원하게 되었다. 나는 지원서를 제출하고 1차 합격 메일을 받았다. 다음 절차는 <code>온라인 테스트</code>였다. 주말에 진행되었으며 안드로이드 관련 문제와 간단한 알고리즘 문제가 나왔다. 공부했던 부분에서 문제가 나와서 수월하게 풀 수 있었으며 알고리즘도 다행히 내가 풀 수 있는 수준이라고 생각을 해서 테스트를 잘 마무리 할 수 있었다.</p>
<p>테스트를 보고 나서 합격 여부를 모른채로 일단 면접 준비를 했다. 취업한 선배들의 말을 들어보니 합격 통지를 받고 면접까지의 기간이 길지 않아서 바로 준비하는게 좋다고 했다. 그래서 나는 테스트를 보고 다음날부터 면접에 대한 준비를 했다. <strong>온라인 테스트</strong>를 합격하고 면접 날짜가 나왔다. 사전에 면접 준비를 어느 정도 했기 때문에 떨리지 않았지만, 어떤 질문이 들어올지 예측할 수 없었다. 일단은 온라인 테스트 문제와 지원서를 기반으로 준비했다.</p>
<p>같이 지원하고 면접까지 붙은 학교 선배 및 후배와 함께 면접 준비를 했다. 혼자 준비한 것보다 확실히 도움이 많이 되었다. <strong>모의 면접</strong>을 통해서 긴장감을 풀 수 있었고 말할 때 태도나 말투를 고칠 수 있었다. 또한, 예상치 못한 질문을 듣고 부족한 부분을 더 공부할 수 있었다. 준비한 결과 부스트 캠프에 <code>최종 합격</code>을 할 수 있었다.</p>
<p>캠프를 하면서 내가 지원할 때 <strong>부스트 캠프</strong>를 통해서 얻고 싶었던 것들을 하나씩 얻고 배울 수 있었다.<br>
일단, 첫번째로 현업에서 일하시는 튜터님의 멘토링을 받을 수 있었다. 우리는 초반에 프로젝트 아키텍처 설계를 <strong>MVP</strong> 패턴으로 잡았다. 그리고 Model, View, Presenter의 의존성을 분리해서 개발을 시작했다. 그리고 튜터링을 받았는데 설계부터 잘못되었다는 평가를 받았다. 기존에는 뷰를 먼저 그리고 필요한 데이터를 그 때 그 때 작성했다. 이렇게 하면 변경 사항이 자주 발생하고 수정할 때도 굉장히 귀찮은 작업을 거치게 된다.</p>
<ol>
<li>튜터링을 받은 내용은 <code>요구사항 명세서</code>를 만들고 먼저 화면에 그릴 데이터를 고려하고 설계하는 것이다. 로직을 하나도 신경쓰지 않고 사용자게에 보여질 화면에 필요한 데이터를 설계한다.</li>
<li>MVP 패턴을 사용하므로 비즈니스 로직을 처리할 Repository 인터페이스를 설계한다.</li>
<li>2번에서 생성한 Repository 인터페이스를 구현한다.</li>
<li>Presenter 구현 및 View 인터페이스 설계</li>
<li>View 인터페이스 구현</li>
</ol>
<p>위와 같은 순서로 작업을 진행하는 것이 좋다는 피드백을 받았다. 기존에 개발해왔던 것과는 반대의 <strong>프로세스</strong>였다. Data를 먼저 고려하고 최종적으로 View는 가장 마지막에 구현하는 것이었다. 처음에는 이 프로세스가 적응이 되지 않고 왜 이렇게 하는지 이해가 잘 가지 않았다. 하지만, 계속 하다보니 적응이 되었고 <strong>요구사항 명세서</strong>를 잘 작성해 놓으니 추후에 유지보수나 수정할 때 손이 많이 가지 않았다. 덕분에 능률이 조금 더 오를 수 있었다.</p>
<p>또한, 관심사의 분리(SOC)를 하는데에도 도움이 많이 되었다. MVP 패턴을 사용하다보니 Model, View, Presenter 각각이 하는 역할이 명확해서 분리하는 것이 필요했다. 말은 쉽지만 실제로 개발을 하다보니 서로 의존성이 생기는 문제가 발생했다. 이 문제는 위의 <strong>요구사항 명세서</strong> 작성을 통해서 역할을 명확하게 분리할 수 있었고 의존성을 낮출 수 있게 되었다.</p>
<p>두번째는 <strong>코드리뷰</strong>였다. 지금까지 살면서 남의 코드를 봐온 적은 있지만 코드 리뷰를 해본 적이 없었고, 내 코드를 누군가가 리뷰해 준 적도 없었다. 내 첫 코드 리뷰는 엉망이라고 할 수 있다. 접근제어자는 막 갖다 붙였고, 전역 변수, 지역 변수도 구분할 줄 몰랐다. 그래서 조언을 받고 반성을 하면서 코드를 짤 때 <strong>생각을 많이 하고</strong> 짜는 습관을 가지게 되었다. 내가 짠 코드에 대해서 왜 이렇게 짰는지 생각해 볼 수 있는 습관을 가지게 된 것이 좋았다.</p>
<p>세번째는 같은 분야의 다른 개발자들을 만날 수 있었다는 점이다. 물론 <strong>SOPT</strong>를 통해서 많이 만났지만, 새로운 사람들을 만난다는 건 좋은 경험이었다. 처음 보는 사람들과 팀을 이루었다. 처음에는 굉장히 어색했지만, 시간이 지나면서 친해졌고 일상 이야기 뿐 아니라 개발적인 부분도 함께 공유하고 이야기 할 수 있어서 좋았다. 캠프에도 적응할 수 있어서 긴장이 많이 풀렸다. 또한, 내가 모르는 부분들도 많이 알게 되었고 전보다 시야가 넓어졌다.</p>
<p>마지막으로 다른 사람들을 통해서 많은 <strong>자극</strong>을 받을 수 있었다. 아마도 SOPT에서만 계속 있었다면 발전이 없고 그 자리에 머물러 있었을 것이라고 생각한다. 부스트 캠프에는 전국에서 안드로이드 개발에 관심이 있는 사람들이 모인 자리인 만큼 잘하는 사람들이 굉장히 많았다. 그 속에서 나는 남과 비교하면서 내 자신을 깎아내리기도 했었다. 하지만 시간이 조금 지나면서 <strong>부정적인 생각</strong>을 없애버렸고 <strong>그 사람들로부터 자극</strong>을 받기 시작했다. 이 자극은 나한테 큰 도움이 됐다. 앞으로 어떤 걸 공부해야 할지 방향을 잡을 수 있었고, 내게 부족한 점들을 확인할 수 있는 시간이었다.</p>
<p><code>부스트 캠프</code>를 하면서 좋았던 점은 좋은 팀원들, 튜터님과 함께 프로젝트를 진행하고 잘 마무리할 수 있었던 점이다. 한달이라는 기간 동안 싸우지 않고 프로젝트 동안 의견 충돌도 많지 않았다. 또한, 좋은 튜터님들을 알아 갈 수 있었던 것도 굉장히 좋았다. 안드로이드 개발자라면 모를 수 없는 <a href="https://gun0912.tistory.com/" target="_blank" rel="noopener"><strong>박상권</strong></a>을 실제로 보고 좋은 이야기도 많이 들으면서 값진 경험을 할 수 있었다. 그리고 조금 아쉬운 점은 캠프 동안 매일 기록하지 못했다는 것이다. 초반에는 기록할 시간이 있었지만 개발을 시작하고 나서는 시간적인 여유가 부족해서 기록을 하지 못했다.</p>
<p>그래도 <strong>부스트 캠프</strong>는 나에게 있어서 한 단계 성장할 수 있게 만들어준 발판이었다. 2019년의 시작은 힘들었지만, 추진력을 주었기에 감사한 마음이다.</p>
<ul>
<li>2019년도에는 <strong>끝까지 포기하지 않고 최선을 다하는</strong> 마음가짐을 가지고 꼭 취업을 하는게 목표다.</li>
<li>그리고 체력 관리도 필수적인 것 같다. 꾸준한 운동도 꼭 할 계획이다.</li>
</ul>
<img src="/img/boostcamp_android.png" width="700" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.emoneynews.co.kr/news/articleView.html?idxno=68681" target="_blank" rel="noopener">KB금융, 대학생과 함께하는 ‘KB App Challenge’ 개최</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/02/2018-Review/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
