
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2019/1 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2019/01/archives/3/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/16/Android-MVP-Step1/"
                            aria-label=": [안드로이드] MVP 따라하기 1"
                        >
                            [안드로이드] MVP 따라하기 1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-16T18:02:32+09:00">
	
		    Jan 16, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="서론">서론</h2>
<p>지금까지 안드로이드 개발을 하면서 아키텍처 패턴을 적용해서 개발을 해본 적이 없다. MVC, MVP, MVVM이 잘 알려져 있는데, 굳이 이 범주에 포함시켜 보자면 MVC로 개발을 진행했던 것 같다. 이번에 부스트캠프를 하는데, 어떤 교육을 받는 과정이 아니라 실무 프로젝트 중심으로 진행한다고 한다. 그래서 내가 배워보고 싶은 것들은 내가 노력하고 시간을 투자해서 공부하고 배워야 할 것 같다. 그 과정에서 어려운 것이 있다면 멘토님들한테 질문을 해보자.</p>
<p>안드로드에서 테스트 코드를 작성하기 위한 방법 중 하나로 <strong>MVP</strong>를 선택해서 사용한다고 한다. 또한 Model, View, Presenter 간의 상호 의존성을 떨어트리기 위한 용도도 있다고 한다.</p>
<h2 id="mvp란">MVP란?</h2>
<p>서론이 조금 길었다. 그렇다면 MVP란 무엇일까?<br>
MVP를 알기 위해서는 <strong>MVP</strong>의 각 단어의 역할과 목적이 중요하다.</p>
<ul>
<li>Model : Data와 관련된 처리를 담당
<ul>
<li>Data의 전반적인 부분을 model에서 담당하고, 네트워크, 로컬 데이터 등을 포함한다.</li>
</ul>
</li>
<li>View : 사용자의 실질적인 <strong>이벤트</strong>가 발생하고, 이를 처리 담당자인 <code>Presenter</code>로 전달한다.
<ul>
<li>완전한 View의 형태를 가지도록 설계한다. 계산을 하거나 데이터를 가져오는 등의 행위는 <code>Presenter</code>에서 처리하도록 한다.</li>
</ul>
</li>
<li>Presenter : View에서 전달받은 <strong>이벤트</strong>를 처리하고, 이를 다시 View에 전달한다.
<ul>
<li>View와는 무관한 Data등을 가지고, 이를 가공하고 View에 다시 전달하는 역할</li>
</ul>
</li>
</ul>
<img src="/img/mvp.png" width="500" height="300">
<center>MVP 구조</center>
<h2 id="mvp의-기본-패턴">MVP의 기본 패턴</h2>
<p>MVP를 처음 접해보고 이제 시작하는 나로서는 그냥 <strong>빙글 빙글</strong> 돌려놓은 듯한 느낌을 받았다. 이를 아래와 같은 그림처럼 표현할 수 있다.</p>
<img src="/img/mvp_default.png" width="500" height="300">
<p>이를 순서대로 나열하면 아래와 같다.</p>
<ol>
<li>View : View에서 터치 이벤트 발생</li>
<li>View -&gt; Presenter : Presenter로 이벤트 전달</li>
<li>Presenter : View에서 요청한 이벤트 처리</li>
<li>Presenter -&gt; View : 처리한 결과를 View로 전달</li>
<li>View : 처리된 결과를 바탕으로 UI를 갱신</li>
</ol>
<p>위와 같은 형태를 가지며 1~5번까지 처리가 완료되면 이후 같은 동작이 계속적으로 일어난다. 일반 코드라면 하나의 액티비티 파일 안에서 모두 처리가되니까 눈으로 보긴 편하다. 따라갈 필요도 없고, 함수만 따라다니면 보기도 쉽기 때문이다. 그래서 MVP를 <strong>빙글 빙글</strong> 돌려놓은 것 아닐까? 라는 답이 나올 수 밖에 없다.</p>
<h2 id="mvp에-모델을-더하면">MVP에 모델을 더하면?</h2>
<p>위에서 기본적으로 작성한 MVP에 모델을 더하면 아래와 같이 표현이 가능하다.</p>
<img src="/img/mvp_model.png" width="500" height="300">
<ol>
<li>View : View에서 <strong>터치 이벤트</strong> 발생</li>
<li>View -&gt; Presenter : Presenter에 이벤트 전달</li>
<li>Presenter : 이벤트의 형태에 따라 캐시 데이터를 가져오거나 <strong>Model</strong>에 요청</li>
<li>Presenter -&gt; Model : Presenter에서 데이터를 요청 받음</li>
<li>Model : 데이터를 로컬 또는 서버에서 가져온다.</li>
<li>Presenter : 전달 받은 데이터를 가공</li>
<li>Presenter -&gt; View : 가공한 데이터를 View에 전달</li>
<li>Vie : Presenter로부터 전달받은 데이터를 View에 갱신</li>
</ol>
<p><strong>상황에 따라서 Presenter는 Model을 사용할 수도 사용하지 않을 수도 있지만 기본 형태는 위와 같다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thdev.tech/androiddev/2016/10/12/Android-MVP-Intro/" target="_blank" rel="noopener">Android MVP 무작정 따라하기 - Intro</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/16/Android-MVP-Step1/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/14/Android-View-Lifecycle-Test/"
                            aria-label=": [안드로이드] View 함수 Testing"
                        >
                            [안드로이드] View 함수 Testing
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-14T22:19:50+09:00">
	
		    Jan 14, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>예전에는 안드로이드에서 액티비티 파일을 만들고 xml 파일에 View, ViewGroup들을 정의하고, Activity의 생명주기 함수나 혹은 프래그먼트의 생명주기 함수가 호출되는 것이 가장 중요한 개념이 아닐까 생각했었다.</p>
<p>하지만, 이런 Activity, Fragment의 View, ViewGroup들이 결국 화면에 그려지기 위해서는 분명 화면에 그리는 함수들이 존재할 것이다. 나는 이 개념과 함수들을 부스트 캠프를 준비하면서 알게 되었다.</p>
<p>안드로이드에서 ViewGroup이나 View를 화면에 그릴 때, <strong>View Lifecycle</strong>의 개념이 중요하다. 이 개념을 아직 완벽하게 이해하진 못했지만, ViewGroup의 성능 측정을 위해서 실험을 하였다. View와 관련된 개념은 이전에 공부한 포스팅에 내용을 추가할 예정이다. 그리고 성능 측정을 위해서 <code>LinearLayout, RelativeLayout, ConstraintLayout</code>의 세가지 ViewGroup을 Custom하여 테스트해보았다.</p>
<p>3개의 ViewGroup의 View 함수들이 어떻게 호출되는지 확인하기 위해서 간단한 CustomView를 만들었다. 이 예제는 <strong>박상권</strong>님의 블로그를 참고했으며, 참고 링크는 아래에 기재해두었다.</p>
<h2 id="customview-만들기">CustomView 만들기</h2>
<p>CustomView가 사용되는 경우는 같은 형식의 버튼이 3개라면 하나의 레이아웃 소스 코드를 복사해서 3번 붙여넣기 하면 만들 수 있다. 만약 버튼이 100개라면 100번 정도 복사 / 붙여 넣기 작업을 반복하면 된다.</p>
<p>그런데, padding 값이나 margin값을 바꾸고 싶다면? 100개의 버튼에 대해서 똑같은 작업을 반복하는 지옥에 빠지게 된다.(상상만 해도 끔찍하다.) 이러한 경우 <strong>CustomView</strong>를 만들어서 이를 재사용하는 것이 좋다. 예제로 로그인 버튼 형태의 레이아웃을 유지하고 아이콘과 텍스트만 변경하도록 구성해보겠다.</p>
<img src="/img/android_customview_loginbutton.png" width="600" height="400">
<p>위와 같이 custom하게 만든 속성을 이용해서 배경색, 아이콘 이미지, 텍스트, 텍스트 색상 등을 지정할 수 있다. 복잡한 레이아웃 구성도 하나의 CustomView로 만들어 준뒤 해당 CustomView를 재사용하면 편리하고 유용하게 화면을 구성할 수 있다.</p>
<p><strong>1. layout xml파일 생성하기</strong></p>
<p>CustomView의 기본으로 사용될 layout xml 파일을 만든다.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/bgLinear"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"55dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@color/kakao_color"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/symbolLinear"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"32dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_vertical"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@drawable/kakao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/textLinear"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"카카오톡 로그인"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">"@color/text_color"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textStyle</span>=<span class="string">"bold"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. attrs.xml 설정</strong></p>
<p>custom하게 만들어 줄 atrribute를 설정해준다. 해당 파일은 value -&gt; attrs.xml 파일을 만들고 이 안에 내용을 추가해준다. 추가해주는 속성은 CustomView를 사용할 xml에서 속성을 지정하기 위함이다. 즉, 내가 넣고자 하는 속성을 넣어서 마음대로 만들 수 있다는 뜻이다.</p>
<img src="/img/android_customview_attrs.png" width="600" height="400">
<p>이 attr 속성을 보았을 때 4가지를 나중에 속성값으로 받아서 적용할 수 있게 할 것이다. 이 attr은 나중에 app:text=&quot; … &quot; 로 쓰일 수 있으며 “가나다라” 같은 직접적인 String과 @string/exam 같은 reference를 넣어줄 수도 있다.</p>
<p><strong>3. CustomView 만들기</strong></p>
<ol>
<li>CustomView의 생성자를 모두 만들고 그 안에서 initView, getAttrs 함수를 호출한다. [주의할 사항은 꼭 커스텀 뷰의 생성자를 모두 생성해야 하는 것이다.]</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(context: Context, attrs: AttributeSet) : <span class="keyword">this</span>(context) &#123;</span><br><span class="line">    initView()</span><br><span class="line">    getAttrs(attrs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(context: Context, attrs: AttributeSet, defStyle: <span class="built_in">Int</span>) : <span class="keyword">this</span>(context, attrs) &#123;</span><br><span class="line">    initView()</span><br><span class="line">    getAttrs(attrs, defStyle)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>initView()에서는 미리 만들어둔 xml 파일을 할당하고 각각의 view를 설정해준다. inflate를 통해서 xml 파일을 view 객체로 메모리에 올린다. 그리고 addView(view)를 해준다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inflaterService : String = Context.LAYOUT_INFLATER_SERVICE</span><br><span class="line">    <span class="keyword">var</span> inflater : LayoutInflater = context.getSystemService(inflaterService) <span class="keyword">as</span> LayoutInflater</span><br><span class="line">    <span class="keyword">var</span> view = inflater.inflate(R.layout.login_button_linear, <span class="keyword">this</span>, <span class="literal">false</span>)</span><br><span class="line">    addView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>getAttrs() 함수를 통해서 attrs.xml 파일에 선언해둔 attribute를 가지고 오는 작업을 수행한다. 그리고 setTypeArray() 함수로 넘겨준다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAttrs</span><span class="params">(attrs : <span class="type">AttributeSet</span>, defStyle: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton, defStyle,<span class="number">0</span>)</span><br><span class="line">    setTypeArray(typedArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAttrs</span><span class="params">(attrs: <span class="type">AttributeSet</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> typedArray : TypedArray = context.obtainStyledAttributes(attrs,R.styleable.LoginButton)</span><br><span class="line">    setTypeArray(typedArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>setTypeArray() 함수를 통해서 attrs.xml 파일에 정의한 속성을 적용해서 layout이 가지고 있는 view에게 값을 설정해주는 작업을 수행한다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setTypeArray</span><span class="params">(typedArray: <span class="type">TypedArray</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> backgroundResourceId = typedArray.getResourceId(R.styleable.LoginButton_bg, R.color.naver_color)</span><br><span class="line">    bgLinear.setBackgroundResource(backgroundResourceId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> symbolResourceId = typedArray.getResourceId(R.styleable.LoginButton_symbol, R.drawable.naver)</span><br><span class="line">    symbolLinear.setImageResource(symbolResourceId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textColor = typedArray.getColor(R.styleable.LoginButton_textColor, <span class="number">0</span>)</span><br><span class="line">    textLinear.setTextColor(textColor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> textString = typedArray.getString(R.styleable.LoginButton_text)</span><br><span class="line">    textLinear.text = textString</span><br><span class="line"></span><br><span class="line">    typedArray.recycle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="느낀점">느낀점</h2>
<p>뷰를 화면에 그릴 때는 View의 Lifecycle이 중요하다. 이는 우리가 구성한 뷰를 사용자의 화면에 보여주기 때문이다. 그리고 렌더링되는 속도는 뷰를 그리는 것과 연관이 되어있다. 그렇다면 View의 Lifecycle을 한 번 더 살펴보자.</p>
<img src="/img/android_view_method.png" width="400" height="300">
<p>실제로 RelativeLayout이나 LinearLayout보다는 ConstraintLayout이 뷰의 계층을 줄여주고 훨씬 효율적으로 뷰를 구성할 수 있다고 한다. 이로 인해서 얻을 수 있는 이점은 무엇이 있을까 생각해봐야 한다.</p>
<ul>
<li>뷰의 계층을 수평적으로 만들 수 있다.</li>
<li>이로 인해 findViewById를 호출하는 횟수도 감소시킬 수 있다.</li>
<li>View Lifecycle 함수들의 호출 횟수를 줄일 수 있다.</li>
</ul>
<ol>
<li><strong>Linear</strong><br>
<img src="/img/android_customview_linear.png" width="700" height="500"></li>
</ol>
<center>LiearLayout을 상속받은 CustomView</center>
<ol start="2">
<li><strong>Relative</strong><br>
<img src="/img/android_customview_relative.png" width="700" height="500"></li>
</ol>
<center>RelativeLayout을 상속받은 CustomView</center>
<ol start="3">
<li><strong>Constraint</strong><br>
<img src="/img/android_customview_constraint.png" width="700" height="500"></li>
</ol>
<center>ConstraintLayout을 상속받은 CustomView</center>
<p><strong>결론</strong><br>
RelativeLayout이 Linear나 ConstraintLayout보다 <code>onMeasure()</code> 함수가 2배 정도 많이 호출되는 것을 확인할 수 있었다. 아마도 RelativeLayout이 자신의 크기를 측정하고 자식의 크기를 측정하는 과정이 필요하기 때문에 2배 호출되는 것으로 생각하고 있다. RelativeLayout은 뷰를 구성할 때 상대적인 위치를 고려해서 배치하거나 상하좌우에 배치시킬 때 나는 주로 이용했었다.</p>
<p>하지만, 복잡한 레이아웃을 구성할 때 RelativeLayout을 사용한다면 View의 계층이 깊어지게 되고 이로 인해서 View의 크기를 측정하는 과정이 길어지면서 결국에는 렌더링 속도에 영향을 미치는 좋지 않을 결과를 초래할 것이다.</p>
<p>그래서 앞으로는 ConstraintLayout을 사용해보면서 익히고 주로 사용해볼 생각을 하고 있다.</p>
<p>사실, 제대로 테스트를 진행하기 위해서는 커스텀 뷰그룹 안에 커스텀 뷰를 넣어야 한다. 하지만 나는 커스텀 뷰 그룹 안에 TextView, ImageView를 그대로 넣었다.[<strong>이 부분은 나중에 다시 테스트 할 예정</strong>]</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://one-delay.tistory.com/94" target="_blank" rel="noopener">[Android] View에 대한 기본 지식 및 ViewGroup 성능 측정 삽질기</a></li>
<li><a href="http://gun0912.tistory.com/38" target="_blank" rel="noopener">[안드로이드/Android]CustomView를 만들어서 재사용하기</a></li>
<li><a href="https://developer.android.com/training/custom-views/create-view?hl=ko" target="_blank" rel="noopener">https://developer.android.com/training/custom-views/create-view?hl=ko</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/custom-components?hl=ko#custom" target="_blank" rel="noopener">https://developer.android.com/guide/topics/ui/custom-components?hl=ko#custom</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/14/Android-View-Lifecycle-Test/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-4/"
                            aria-label=": [안드로이드] 안드로이드 면접 4"
                        >
                            [안드로이드] 안드로이드 면접 4
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T14:26:19+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EB%B0%B1%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C">안드로이드 백그라운드</a></li>
<li><a href="https://woovictory.github.io/2018/03/02/Android-ActivityLifeCycle/">액티비티 생명주기</a></li>
<li><a href="https://woovictory.github.io/2019/01/02/Android-What-Is-Fragment/">프래그먼트 생명주기</a></li>
<li><a href="#Content-Provider-VS-Content-Resolver">Content Provider VS Content Resolver</a></li>
</ol>
<h2 id="안드로이드-백그라운드">안드로이드 백그라운드</h2>
<p>안드로이드 UI는 기본적으로 싱글 스레드 모델로 작동하므로, 이 영향을 고려해서 개발하지 않으면 애플리케이션의 성능이 저하될 수 있다. 따라서 메인 스레드에서 긴 작업을 하는 것을 피하기 위해 여분의 스레드를 사용해야 한다. 다른 스레드에서 UI 스레드로 접근할 수 있도록 안드로이드에서 제공하는 스레드 간 통신 방법을 알아보자.</p>
<p><strong># 소개</strong><br>
안드로이드의 애플리케이션을 실행하면 시스템은 메인 액티비티를 메모리로 올려 프로세스를 만들며, 이 때 메인 스레드가 자동으로 생성된다. 메인 스레드는 안드로이드의 주요 컴포넌트를 실행하는 곳이자 UI를 그리거나 갱신하는 일을 담당할 수 있는 유일한 스레드이므로 이를 <code>UI 스레드</code>라고 부른다.</p>
<p>안드로이드 화면을 구성하는 뷰나 뷰 그룹을 하나의 스레드에서만 담당하는 원칙을 <strong>싱글 스레드 모델</strong>이라고 한다. 싱글 스레드 모델의 규칙은 다음과 같다.</p>
<ol>
<li>메인 스레드(UI 스레드)를 블럭하지 말 것.</li>
<li>안드로이드 UI 툴킷은 오직 UI 스레드에서만 접근할 수 있도록 할 것.</li>
</ol>
<p>이런 싱글 스레드 모델의 영향을 고려하지 않으면 애플리케이션의 성능이 저하될 수 있다. 긴 시간이 걸리는 작업을 메인 스레드에서 담당하면 애플리케이션의 반응성이 낮아질 수 있고, 급기야 사용자의 불편함을 방지하고자 시스템이 애플리케이션을 ANR 상태로 전환시킬 수도 있다.</p>
<p><strong>따라서 시간이 걸리는 작업을 하는 코드는 여분의 스레드를 사용하여 메인 스레드에서 분리해야 하고, 자연스럽게 메인 스레드와 다른 스레드가 통신하는 방법이 필요하게 된다.</strong></p>
<p>다른 스레드에서 메인 스레드로 접근하기 위해 <strong>Looper</strong>와 <strong>Handler</strong>를 사용할 수 있으며, 안드로이드는 Java의 Thread를 좀 더 쉽게 사용할 수 있도록 래핑한 <code>HandlerThread</code>. 더 나아가 Thread나 Message Loop 등의 작동 원리를 크게 고려하지 않고도 사용이 가능한 <code>AsyncTask</code> 등의 클래스를 제공한다. 그럼 먼저 Thread-Looper-Handler의 개념을 이해하고 다음 내용을 알아보자.</p>
<h2 id="looper와-handler의-사용-목적">Looper와 Handler의 사용 목적</h2>
<p>왜 안드로이드는 메인 스레드에서만 UI 작업이 가능하도록 제한할까? 메인 스레드가 아닌 스레드가 병렬적으로 실행되고 있을 때, 메인 스레드와 다른 스레드, 두 개 이상의 스레드가 동시에 같은 텍스트 뷰에 setText()를 시도하는 경우를 생각하면 간단하다.</p>
<img src="/img/android_thread_reason.png" width="400" height="300">
<p>위의 그림처럼 둘 중 어느 스레드의 setText()가 적용될지 예측할 수 없고, 사용자는 둘 중 하나의 값만을 볼 수 있어 다른 한 스레드의 결과는 버려진다. 이같이 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해서 Looper와 Handler를 사용하게 된다.</p>
<h2 id="looper와-handler의-작동-원리">Looper와 Handler의 작동 원리</h2>
<p><code>안드로이드 면접 3</code>에서도 살펴보았지만, 더 보도록 하겠다. 먼저 스레드와 Looper, Handler가 어떻게 작동하는지 보자. 메인 스레드는 내부적으로 <code>Looper</code>를 가지며 그 안에는 <strong>Message Queue</strong>가 포함된다. Message Queue는 스레드가 다른 스레드나 혹은 자기 자신으로부터 전달받은 Message를 기본적으로 FIFO(선입선출) 형식으로 보관하는 Queue이다.</p>
<p><strong>Looper</strong>는 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다. <strong>Handler</strong>는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 스레드 간의 통신 장치이다.</p>
<img src="/img/android_looper_handler.png" width="400" height="300">
<h2 id="handler">Handler</h2>
<p>Handler는 스레드의 Message Queue와 연계하여 Message나 Runnable 객체를 받거나 처리하여 스레드 간의 통신을 할 수 있도록 한다. Handler 객체는 하나의 스레드와 해당 스레드의 Message Queue에 종속된다. 새로 Handler 객체를 만든 경우 이를 만든 스레드와 해당 스레드의 Message Queue에 바인드 된다.</p>
<p>다른 스레드가 특정 스레드에게 메시지를 전달하려면 특정 스레드에 속한 Handler의 post나 sendMessage 등의 메소드를 호출하면 된다. 앞서 Message Queue는 전달받은 Message를 선입선출 형식으로 보관한다고 설명했지만, 전달 시점에 다른 메소드를 사용하여 Queue의 맨 위로 보내거나 원하는 만큼 Message나 Runnable 객체의 전송을 지연시킬 수도 있다. 자주 쓰이는 Handler의 메소드는 아래 글을 참고하자.</p>
<p><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">참고 글</a></p>
<p>외부, 혹은 자기 스레드로부터 받은 메시지를 어떤 식으로 처리할지는 <code>handleMessage()</code> 메소드를 구현하여 정리한다. <code>sendMessage()</code>나 <code>post()</code>로 특정 Handler에게 메시지를 전달할 수 있고, 재귀적인 호출도 가능하므로 딜레이를 이용한 타이머나 스케줄링 역할도 할 수 있어 편리하다.</p>
<h2 id="looper와-message-queue">Looper와 Message Queue</h2>
<p>Looper는 무한히 루프를 돌며 자신이 속한 스레드의 Message Queue에 들어온 Message나 Runnable 객체를 차례로 꺼내서 이를 처리할 Handler에 전달하는 역할을 한다. 메인 스레드는 Looper가 기본적으로 생성돼 있지만, 새로 생성한 스레드는 기본적으로 Looper를 가지고 있지 않고, 단지 run 메소드만 실행한 후 종료하기 때문에 메시지를 받을 수 없다.</p>
<p>따라서 기본 스레드에서 메시지를 전달받으려면 <code>prepare()</code> 메소드를 통해 <strong>Looper</strong>를 생성하고, loop() 메소드를 통해 Looper가 무한히 루프를 돌며 Message Queue에 쌓인 Message나 Runnable 객체를 꺼내 Handler에 전달하도록 한다. 이렇게 활성화된 Looper는 quit()이나 quitSafely() 메소드로 중단할 수 있다. quit() 메소드가 호출되면 Looper는 즉시 종료되고, quitSafely() 메소드가 호출되면 현재 Message Queue에 쌓인 메시지들을 처리한 후 종료된다.</p>
<img src="/img/android_looper_message_queue.png" width="400" height="300">
<h2 id="message와-runnable">Message와 Runnable</h2>
<p><strong>Message</strong><br>
Message란 스레드 간 통신할 내용을 담는 객체이자 Queue에 들어갈 일감의 단위로 Handler를 통해 보낼 수 있다. 일반적으로 Message가 필요할 때 새 Message 객체를 생성하면 성능 이슈가 생길 수 있으므로 안드로이드가 시스템에 만들어 둔 <strong>Message Pool</strong>의 객체를 재사용한다. obtain() 메소드는 빈 Message 객체를, obtain(Handler h, int what …)은 목적 Handler와 다른 인자들을 담은 Message 객체를 리턴한다.</p>
<p><strong>Runnable</strong><br>
새 스레드는 Thread() 생성자로 만들어서 내부적으로 run()을 구현하던지, Thread(Runnable runnable) 생성자로 만들어서 Runnable 인터페이스를 구현한 객체를 생성하여 전달하던지 둘 중 하나의 방법으로 스레드를 만들 수 있다. 후자에서 사용하는 것이 <strong>Runnable</strong>로 스레드의 run() 메소드를 분리한 것이다. 따라서 Runnable 인터페이스는 run() 추상 메소드를 가지고 있으므로 상속받은 클래스는 run() 코드를 반드시 구현해야 한다. 앞서 언급한대로 Message가 int나 Object 같이 <strong>스레드 간 통신할 내용</strong>을 담는다면 Runnable은 실행할 run()메소드와 그 내부에서 실행될 코드를 담는다는 차이점이 있다.</p>
<h2 id="handlerthread">HandlerThread</h2>
<p>Looper에서 언급했듯이 안드로이드의 스레드는 Java의 스레드를 사용하기 때문에 안드로이드에서 도입한 Looper를 기본으로 가지지 않는다는 불편함이 있다. 이같은 불편함을 개선하기 위해 생성할 때 Looper를 자동으로 보유한 클래스를 제공하는데, 이것이 바로 <code>HandlerThread</code>이다. HandlerThread는 일반적인 스레드를 확장한 클래스로 내부에 반복해서 루프를 도는 <strong>Looper</strong>를 가진다. 자동으로 Looper 내부의 Message Queue도 생성되므로 이를 통해 스레드로 Message나 Runnable을 전달받을 수 있다.</p>
<h2 id="asynctask">AsyncTask</h2>
<p><code>AsyncTask</code>는 스레드나 메시지 루프 등의 작동 원리를 잘 몰라도 하나의 클래스에서 UI 작업과 background 작업을 쉽게 할 수 있도록 안드로이드에서 제공하는 클래스이다. <strong>캡슐화</strong>가 잘되어 있기 때문에 사용시 코드 가독성이 증대되는 장점이 있으며, 태스크 스케줄을 관리할 수 있는 콜백 메소드를 제공하고 필요할 때 쉽게 UI 갱신도 가능하며 작업 취소도 쉽다. 따라서 리스트에 보여주기 위한 데이터 다운로드 등 UI와 관련된 독립된 작업을 실행할 경우 <code>AsyncTask</code>로 간단하게 구현할 수 있다.</p>
<img src="/img/android_AsyncTask.png" width="400" height="300">
<center>AsyncTask 구조</center>
<p>그러나 AsyncTask를 사용해서 스케줄링할 수 있는 작업 수의 제한이 있고, 몇 초 정도의 짧은 작업에서만 이상적으로 동작한다는 한계가 있다. 또한, 안드로이드의 버전 별로 병렬 처리 동작이 다르므로 허니콤 이후 버전에서 멀티 스레드로 병렬적인 동작을 원한다면 AsyncTask를 실행할 때 <code>AsyncTask.THREAD_POOL_EXECUTOR</code> 스케줄러를 지정해야 한다.</p>
<p>한편, 앞서 살펴본 Handler와 Looper를 사용한다면 동작 원리를 고려해야 하며 구현을 직접해야 하고 코드가 복잡해져서 가독성을 저해한다는 단점이 있지만 그만큼 개발 범위가 자유롭다. 또한 UI 스레드에서만 작업하지 않아도 되므로 보다 많은 자율성을 가지고 코드를 제어하기를 원한다면 Handler나 HandlerThread 사용을 고려해보는 것도 좋다.</p>
<p>무엇을 사용할지는 개발자가 어떤 기준을 가지고 개발하는지에 따라 다르다. 그럼에도 나는 AsyncTask를 사용할 것 같다. 왜냐하면 핸들러는 스레드 안에서 실행되어야 할 코드와 UI 접근을 위한 코드가 각각 다른 위치에서 구현을 한다. 그러므로 가독성이 떨어진다.</p>
<p>하지만, <code>AsyncTask</code>는 하나의 클래스 안에 스레드로 동작하는 부분과 화면을 갱신하는 부분을 함께 구현해놓을 수 있다. 이 때문에 스레드를 사용하는 하나의 작업단위가 하나의 클래스로 만들어질 수 있게 되므로 가독성이 훨씬 좋아지게 된다.</p>
<p>간단한 예제는 아래 블록를 참고하자^0^<br>
<a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">AsyncTask 예제</a></p>
<h2 id="content-provider-vs-content-resolver">Content Provider VS Content Resolver</h2>
<ul>
<li>
<p>Content Provider : 어플리케이션 내에서 사용할 수 있는 데이터를 <strong>공유</strong>하기 위한 컴포넌트<br>
ex) 연락처, 이미지 등(카카오톡)</p>
</li>
<li>
<p>Content Resolver : 앱이 Content Provider를 접근할 때에는 Content Resolver를 통해서 접근하게 됨. 기본적으로 <strong>CRUD</strong> 함수들 제공 -&gt; 다른 앱의 데이터베이스를 조작할 수 있음<br>
ex) contentResolver.query()</p>
</li>
</ul>
<h2 id="xml-기반-레이아웃이-중요한-이유">XML 기반 레이아웃이 중요한 이유</h2>
<p>동작을 제어하는 코드로부터 분리시킬 수 있고, UI의 구조를 시각화하기 더 쉽기 때문이다. 소스로 레이아웃을 작성했다면, 레이아웃을 변경할 때마다 재컴파일 해야 하는 번거로움이 있다.</p>
<h2 id="manifest">Manifest</h2>
<p>애플리케이션에 대한 필수적인 정보를 안드로이드 플랫폼에 알려준다. 모든 안드로이드 앱은 반드시 AndroidManifest.xml 파일을 자신의 루트 디렉토리에 가지고 있어야 한다.</p>
<h2 id="vector-vs-bitmap">Vector Vs Bitmap</h2>
<ul>
<li>
<p>Vector : 리사이징이 되어도 전혀 깨지지 않는다. 모든 해상도에서 자유자재로 활용할 수 있기 때문에 특정 해상도에 제한되어 있지 않다는 것이 핵심 ex)SVG</p>
</li>
<li>
<p>Bitmap : 픽셀로 구성되어 있다. 자유자재로 바꿀 수가 없고 움직일 수도 없다. ex)PNG, JPEG</p>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://academy.realm.io/kr/posts/android-thread-looper-handler/?w=1" target="_blank" rel="noopener">안드로이드 백그라운드 잘 다루기 Thread, Looper, Handler</a></li>
<li><a href="https://one-delay.tistory.com/29?category=766130" target="_blank" rel="noopener">[Android] AsyncTask</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/07/Android-For-Interview-3/"
                            aria-label=": [안드로이드] 안드로이드 면접 3"
                        >
                            [안드로이드] 안드로이드 면접 3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-07T10:56:36+09:00">
	
		    Jan 07, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="#%ED%99%94%EB%A9%B4%EC%9D%B4-%ED%9A%8C%EC%A0%84%ED%95%98%EB%A9%B4-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0%EB%8A%94?">화면이 회전하면 액티비티의 생명주기는?</a></li>
<li><a href="#%ED%8E%9C%EB%8E%85%EC%9D%B8%ED%85%90%ED%8A%B8%EB%9E%80?">펜딩인텐트란?</a></li>
<li><a href="#%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-Task%EC%99%80-Process%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90">안드로이드에서 Task와 Process의 차이점</a></li>
<li><a href="#A-%EC%95%B1%EC%97%90%EC%84%9C-B-%EC%95%B1%EC%9D%98-%EC%95%A1%ED%8B%B0%EB%B9%84%ED%8B%B0%EB%A5%BC-%EB%B6%80%EB%A5%BC-%EA%B2%BD%EC%9A%B0">A 앱에서 B 앱의 액티비티를 부를 경우</a></li>
<li><a href="#%ED%99%94%EB%A9%B4-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%86%8D%EB%8F%84%EB%A5%BC-%EA%B0%9C%EC%84%A0%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95">화면 렌더링 속도를 개선하는 방법</a></li>
<li><a href="#Thred%EA%B0%84-%ED%86%B5%EC%8B%A0-%EB%B0%A9%EB%B2%95">Thred간 통신 방법</a></li>
<li><a href="#ANR">ANR</a></li>
</ol>
<h2 id="화면이-회전하면-액티비티의-생명주기는">화면이 회전하면 액티비티의 생명주기는?</h2>
<p>안드로이드 애플리케이션을 사용하다 보면 화면이 가로 모드를 지원하는 애플리케이션들이 많다. 이런 경우 우리가 사용하는 액티비티의 생명주기는 어떻게 되는 것일까???</p>
<p>일단, 화면이 회전하면 뷰의 크기를 재측정하고 다시 달라진 크기대로 새롭게 그려야 된다. 먼저, <code>onPause</code>가 호출되고 <code>onStop</code>, <code>onDestroy</code>가 진행된 후 다시 <code>onCreate</code>, <code>onStart</code>, <code>onResume</code> 순서로 진행된다. 따라서 현재 액티비티를 destroy 시키고 새로 만들기 때문에 기존의 데이터는 사라지게 된다.</p>
<blockquote>
<p>그런데 우리가 사용하는 애플리케이션에서는 지워지지 않는데?</p>
</blockquote>
<p><code>onDestroy</code>가 호출되기 전에 액티비티는 <code>onSaveInstanceState</code>를 호출하게 되는데 이때 저장되어야 할 데이터를 <strong>Bundle</strong> 객체에 저장해두었다가 다시 <code>onCreate</code>가 호출되면 파라미터로 날아온 Bundle에서 이전 데이터를 받아 복구할 수 있다. 이 과정을 통해 화면이 회전되어도 데이터를 유지할 수 있는 것이다.</p>
<h2 id="펜딩인텐트란">펜딩인텐트란?</h2>
<p>펜딩 인텐트(Pending Intent)는 인텐트의 일종이다.</p>
<p>컴포넌트에서 다른 컴포넌트에게 작업을 요청하는 인텐트를 사전에 생성시키고 만든다는 점과 <strong>특정 시점</strong>에 자신이 아닌 다른 컴포넌트들이 펜딩 인텐트를 사용하여 다른 컴포넌트에게 작업을 요청시키는데 사용된다는 점이 일반적인 인텐트와의 차이점이다.</p>
<p>수행시킬 작업 및 인텐트와 그것을 수행하는 주체를 지정하기 위한 정보를 명시할 수 있는 기능의 클래스라고 보면 된다.</p>
<p>쉬운 예제는 아래와 같다.</p>
<blockquote>
<p><code>A한테 이 B인텐트를 C 시점에 실행하라고 해. 지금은 실행하지 말고.</code></p>
</blockquote>
<p>이 클래스의 인스턴스는 getActivity (Context, int, Intent, int), getActivities (Context, int, Intent [], int), getBroadcast (Context, int, Intent, int) 및  getService(Context, int, Intent, int) 가 반환 하는 객체를 다른 응용 프로그램으로 전달 할 수 있으므로 앱 개발자가 명시하는 작업을 수행 할 수 있다.</p>
<p><code>Pending Intent</code>를 다른 응용 프로그램에 제공하면 다른 응용 프로그램이 자신과 동일한 권한과 ID로 지정된 것처럼 작업을 수행할 수 있는 권한이 부여된다. 따라서 Pending Intent를 작성하는 방법에 주의해야 한다. 예를 들어, 제공하는 기본적인 인텐트는 컴포넌트 이름이 자신이 가진 컴포넌트들 중 하나를 명시적으로 지정해야 하며, 궁극적으로 그곳으로 보내지는 것을 보장해야 한다.</p>
<h3 id="사용되는-몇가지-사례">사용되는 몇가지 사례</h3>
<ul>
<li>사용자가 Notification을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(NotificationManager가 인텐트를 실행)</li>
<li>사용자가 AppWidget을 통해 특정한 동작을 할 때, 실행되는 인텐트를 생성함(홈 스크린이 인텐트를 실행)</li>
<li>미래의 특정 시점에 실행되는 인텐트를 선언함(안드로이드의 AlarmManager가 인텐트를 실행)</li>
</ul>
<p>안드로이드 앱을 구현할 때, 인터넷으로부터 파일을 다운로드 하는 로직은 대부분 서비스에서 이루어지도록 구성한다.  그런데 서비스는 액티비티와 달리 화면에 나타나지 않는다. 따라서 서비스는 다운로드의 진행중이라는 사실 및 진행 정도를 화면 상단에 위치한 <strong>노티피케이션의 상태바</strong>(Status bar)를 통해서 표현한다. 다운로드가 현재 진행 중이라는 상황을 표시하는 아이콘 등으로 말이다. 그리고 다운로드가 완료된 후에는 아이콘으로 다운로드 완료의 상태를 보여주게 된다.</p>
<p>사용자가 상태바의 아이콘을 확인하고 안드로이드 화면의 상태바를 누르면서 나타나는 바를 잡아 아래로 끌어당기면 나타나는 화면을 <strong>노티피케이션 리스트</strong> 또는 확장 메시지라 한다. 그리고 만약 서비스가 이 Notification List에 다운로드 완료를 표시를 추가해놓았고, 사용자가 이것을 클릭하면 노티피케이션은 사전에 서비스에서 작성한 <code>펜딩 인텐트</code>를 사용하여 다운로드된 파일을 읽을 수 있는 앱을 호출하고 다운로드 완료된 파일을 호출된 앱에서 재생 혹은 보여주게 된다.</p>
<p>펜딩 인텐트는 안드로이드 App의 각각의 컴포넌트들이 펜딩 인텐트를 생성할 수 있도록 다음과 같은 메소드를 제공한다. 아래의 메소드를 통해 펜딩 인텐트를 사용하고자 하는 컴포넌트 유형을 지정해야 한다는 뜻이다.</p>
<ul>
<li>getActivity(Context, int, Intent, int)</li>
<li>getBroadcast(Context, int, Intent, int)</li>
<li>getService(Context, int, Intent, int)</li>
</ul>
<p>여기서 Context는 <code>현재 App의 Context</code>이다.</p>
<p><strong># Example</strong><br>
노래를 재생하는 중이고 이것이 상태바에 Notification으로 보여질 때 사용자가 이 Noti를 클릭하면 Notification은 이전에 전달받은 Pending Intent를 실행한다. Pending Intent가 <code>getActivity()</code>에 의해 생성된 것이며 감싸고 있는 intent 또한 특정 화면을 실행시키는 intent라면 이것이 그대로 실행되어 노래 화면이 뜨게 된다.</p>
<p>이때 주의할 점은 Activity는 새로운 테스크를 생성하여 그곳에 쌓이게 된다. 마치 Intent의 flag가 <code>NEW_TASK</code>로 설정된 것처럼 실행되기 때문에 유의해야 한다. 하나의 Activity만 생성되도록 보장하기 위해선 AndroidManifest 파일에  lanunchMode = “singleTop” 으로 설정해주어야 한다.</p>
<h2 id="안드로이드에서-task와-process의-차이점">안드로이드에서 Task와 Process의 차이점</h2>
<p>애플리케이션 컴포넌트가 처음 시작될 때 실행 중인 다른 컴포넌트가 없으면 안드로이드 시스템은 프로세스를 새로 생성시킨다. 기본적으로 애플리케이션의 컴포넌트들은 같은 프로세스의 기본 스레드에서 실행된다. 이후의 컴포넌트들이 시작할 때는 이미 생성된 프로세스 내에서 시작되며 컴포넌트별로 별도의 프로세스에서 실행되도록 할 수도 있고 어느 프로세스에서든 추가적인 스레드를 생성하여 작업할 수 있다.</p>
<p>Manifest 파일에서 <code>android:process</code> 특성을 설정함으로써 다른 프로세스에 해당 컴포넌트를 실행시킬 수 있다. 안드로이드 시스템에서 메모리가 부족할 경우 우선순위가 낮은 프로세스부터 종료시킨다. 우선순위는 <code>Foregorund, Visible, Service, Background, Cached</code> 프로세스 순이다.</p>
<p>눈에 보이는 프로세스는 <strong>Foreground와 Service</strong> 프로세스이며 Visible은 다이얼로그가 뜨는 경우 뒤에 액티비티가 가려지지만 사용자에게 보이는 경우에 해당한다.</p>
<p><strong>Service</strong>는 사용자가 볼 수는 없지만 프로세스에 필요한 작업은 진행하기에 그 다음 우선순위를 가지며 <strong>Background</strong>는 뒤로 밀려난 프로세스이기에 종료될 수 있다. 마지막 <strong>Cached</strong> 프로세스는 컴포넌트가 없는 빈 프로세스이지만 다음에 실행할 때 로드 시간을 절약하기 위해 캐시된 상태이다.</p>
<p><strong>Task</strong>는 각 애플리케이션마다 사용하는 Activity들을 Stack 구조로 저장 및 관리하는 컬렉션이다. 따라서 사용자가 화면의 전환 흐름을 자연스럽게 경험하도록 보장한다. 또한 Task는 다른 애플리케이션이나 프로세스에 속하는 Activity를 같은 Task에 저장시킴으로써 사용자로 하여금 하나의 애플리케이션에서 작동하는 듯한 경험을 하도록 한다. 단말기에서 사용중인 애플리케이션 리스트를 보는 것이 Task 단위로 보여지는 것이다. 하지만 실질적으로 Activity는 다른 프로세스 상에서 돌아가는 컴포넌트이며 프로세스간 통신을 통해 정보를 주고 받는 것이다.</p>
<h2 id="a-앱에서-b-앱의-액티비티를-부를-경우">A 앱에서 B 앱의 액티비티를 부를 경우</h2>
<p>Task에는 해당 애플리케이션에 속한 컴포넌트뿐만 아니라 다른 애플리케이션 컴포넌트도 쌓일 수 있다. 다른 애플리케이션의 컴포넌트를 실행하는 방법으로 <code>PackageManager</code>의 getLaunchIntentForPackage()가 있고 Intent에 <code>setComponent()</code>를 사용하는 방법이 있는데 전자의 경우 항상 새로운 Task를 생성하여 그곳에서 컴포넌트를 실행시키며 후자의 경우 현재의 Task에서 컴포넌트를 실행시키게 된다.</p>
<p>이 부분은 추후 공부를 더 해볼 예정.</p>
<h2 id="화면-렌더링-속도를-개선하는-방법">화면 렌더링 속도를 개선하는 방법</h2>
<p>기본적으로 View의 움직임이 어색하거나 스크롤이 버벅거리거나 렌더링이 느린 경우는 <strong>뷰를 그리는 속도가 16ms 보다 오래걸리는 현상</strong>이다. 초당 60 프레임의 속도로 화면을 그려주어야 사람의 시각에 어색함이 없이 보이는데 그리는 시간이 이보다 오래 걸릴 경우 버벅이는 문제가 발생할 수 있다. 따라서 렌더링이 느리다면 2가지를 의심해 봐야 한다.</p>
<ol>
<li>View Hierarchy가 너무 많은지 의심해 볼 것.</li>
</ol>
<p>View는 그려지기 전에 Measure, Layout, Draw의 3단계를 계층적으로 실행한다. 만약 계층이 매우 길고 복잡하다면 당연히 View가 그려지는 시간 또한 오래 걸릴 것이기 때문이다. 계층을 줄이려 <code>ConstraintLayout</code>과 <code>FlexboxLayout</code>를 적극 사용한다면 줄일 수 있을 것이다.</p>
<ol start="2">
<li>onDraw()에서 오버드로우 현상이 일어나는지 확인할 것.</li>
</ol>
<p><code>onDraw()</code> 함수 안에서 객체 생성을 하였는지, 오래 걸리는 작업을 실행하지 않는지 확인하여 문제가 되는 로직을 수정하거나 제거할 것이다.</p>
<p><strong># ConstrainLayout?</strong><br>
ConstrainLayout은 뷰의 상하좌우를 주변 또는 부모 뷰와 연관을 지어 위치시킬 수 있다. bias를 통해 비율적으로 배치시킬 수도 있고, chain을 사용하여 마치 그룹화한 것처럼 사용도 가능하다. 또한 ratio를 사용하여 너비와 높이를 비율대로 설정할 수도 있는 등 매우 유연한 배치가 가능하다. <code>ConstrainLayout</code>의 가장 큰 장점은 <strong>View Hierarchy</strong>를 <strong>수평적으로 평평하게</strong> 만든다. 최대 8 계층으로 구성되어 있는 RelativeLayout 구조를 하나의 계층으로 줄일 수 있는 효과를 볼 수 있다.</p>
<p><strong># FlexBoxLayout?</strong><br>
태그와 같은 항목이 하나의 뷰 안에 일렬로 즐비할 경우 한 줄이 가득 차면 다음 줄로 View를 정렬시키는 기능이 필요할 때 사용할 수 있는 Layout이다. <code>FlexBoxLayout</code>은 부모 레이아웃의 너비에 따라 자식 뷰를 여러 행에 걸쳐 <strong>동적</strong>으로 맞추는 기능을 제공한다. 기존에는 LinearLayout을 통해 구현 가능하긴 하지만 ScrollView와 같이 사용하면서 View의 너비를 일일이 계산하여 다음 행으로 배치시키는 코드를 직접 구현하는 방식으로 커스텀을 해야했다. <code>FlexBoxLayout</code>을 사용하면 이러한 작업을 자동으로 처리해주기에 잘못된 구현으로 인해 오버헤드가 발생하는 문제를 방지할 수 있다.</p>
<h2 id="thred간-통신-방법">Thred간 통신 방법</h2>
<p>Android의 UI를 담당하는 쓰레드는 메인 쓰레드(UI 쓰레드)인데, 오랜 시간이 걸리는 작업을 메인 쓰레드에서 수행할 경우 앱의 성능이 저하된다. 따라서 여분의 쓰레드를 사용하여 작업을 수행해야 하고, 이 결과를 반영하기 위해 메인 쓰레드와의 통신이 필요하게 된다. 그래서 메인 쓰레드에 접근하는 방법은 <strong>Looper</strong>와 <strong>Handler</strong>를 이용하면 된다. <strong>그리고 UI 작업을 메인 쓰레드에서만 담당하는 이유는 두 개 이상의 쓰레드를 사용할 때의 동기화 이슈를 차단하기 위함이다.</strong></p>
<p><strong>Android는 Java의 쓰레드를 좀 더 쉽게 사용할 수 있도록 래핑한 HandlerThread, AsyncTask를 제공한다.</strong></p>
<p><strong>1. Looper</strong><br>
메인 쓰레드는 내부적으로 <strong>Looper</strong>를 가지며 그 안에는 Message Queue가 포함된다. <code>Message Queue</code>는 쓰레드가 다른 쓰레드나 혹은 자기 자신으로부터 전달받은 Message를 보관하는 Queue(FIFO)이다. Looper는 무한 루프를 돌며 자신이 속한 쓰레드의 Message Queue에서 Message 객체를 차례로 꺼내서 Handler가 처리하도록 전달한다.</p>
<p>메인 쓰레드는 기본적으로 Looper가 생성되어 있으나, 새로 생성한 쓰레드는 새로운 Looper를 생성해주어야 한다. Android는 Looper가 기본적으로 생성되어 있는 HandlerThred를 제공한다.</p>
<ul>
<li><strong>Message Queue에 저장되는 객체</strong>
<ul>
<li>문자와 필드로 구성된 Message 객체</li>
<li>Runnable 객체</li>
</ul>
</li>
</ul>
<p><strong>2. Handler</strong><br>
Looper로부터 받은 Message를 실행, 처리하거나 다른 쓰레드로부터 메시지를 받아서 Message Queue에 넣는 역할을 하는 쓰레드 간의 통신 장치이다. <strong>일반적으로 UI 갱신을 위해 사용된다.</strong> (뷰나 뷰 그룹에서 제공하는 메소드는 단일 스레드 모델(Thread-Unsafe)</p>
<h2 id="anr">ANR</h2>
<p><code>ANR</code>은 Android Not Responding의 약자로 오랜 시간이 걸리는 작업을 메인 쓰레드에서 담당하면 앱의 반응성이 낮아질 수 있고, 사용자의 불편함을 방지하고자 시스템이 <strong>ANR</strong> 상태로 전환시킬 수 있다. 따라서 시간이 걸리는 작업은 여분의 쓰레드를 사용해야 하고, 이 작업 결과를 반영하기 위해 메인 쓰레드와 통신하는 방법이 필요하다.</p>
<p><strong># ANR상태 예시</strong><br>
-&gt; input 이벤트에 5초 안에 반응하지 않을 경우(Activity)<br>
-&gt; BroadcastRecevier가 10초 이내로 실행하지 않을 경우(UI가 없는 브로드캐스트 리시버와 서비스도 실행 주체가 메인 쓰레드이기 때문에)</p>
<p><strong># ANR대처 방법</strong><br>
-&gt; 시간이 걸리는 긴 작업은 쓰레드로 처리<br>
-&gt; Progress bar로 진행 상황을 보여주어 사용자를 기다리게 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/17/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%913/" target="_blank" rel="noopener">안드로이드 면접 3</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/07/Android-For-Interview-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/06/Android-What-is-DeepLink/"
                            aria-label=": [안드로이드] 딥링크"
                        >
                            [안드로이드] 딥링크
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-06T18:40:16+09:00">
	
		    Jan 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="applink-deeplink">Applink? Deeplink??</h2>
<ol>
<li>DeepLink</li>
</ol>
<p><strong>딥링크</strong>는 인텐트 필터의 일종으로 사용자들이 직접적으로 안드로이드 앱 내의 액티비티에 접근하는 것을 허용한다. 다른 앱에서 또는 웹브라우저에서의 링크를 클릭했을 때 해당 링크의 scheme을 보고 앱을 실행하게 되며, 해당 링크를 처리하는 2개 이상의 앱이 있다면 사용자에게 다이얼로그를 띄워 앱을 실행할 수 있도록 유도한다.</p>
<ol start="2">
<li>AppLink</li>
</ol>
<p><strong>앱링크</strong>는 인증된 웹 사이트 URL을 기반으로 하는 딥링크이다. 링크 클릭시 앱이 설치되어 있다면 즉시 열어서 보여주고 없다면 웹으로 이동한다. 다이얼로그는 나타나지 않는다.</p>
<img src="/img/android_deeplink_applink_diff.png" width="400" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=922" target="_blank" rel="noopener">딥링크와 앱링크의 차이점</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/06/Android-What-is-DeepLink/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/06/Android-View-Functions/"
                            aria-label=": [안드로이드] View 함수"
                        >
                            [안드로이드] View 함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-06T16:13:04+09:00">
	
		    Jan 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드 앱 개발을 하면서 layout이나 button 같은 UI 관련 클래스들은 모두 View를 상속 받아서 생성된다. 이 중에 ViewGroup은 button이나 ImageView 같은 것과는 다르게 자식 뷰를 가질 수 있으며 이를 배치하는 역할을 한다.</p>
<p>자신만의 button이나 view를 만들고 싶다면 View 클래스를 상속받아서 필요한 메소드를 오버라이드 하면된다.</p>
<p>자신만의 layout을 만들고 싶다면 ViewGroup 클래스를 상속받아서 필요한 메소드들을 오버라이드 하면된다.</p>
<ul>
<li>Custom View는 View 클래스를 상속하여 만든다.</li>
<li>Custom Layout은 ViewGroup 클래스를 상속하여 만든다.</li>
</ul>
<h2 id="view가-그려지는-과정">View가 그려지는 과정</h2>
<p>뷰는 포커스를 얻으면 레이아웃을 그리도록 요청한다. 이때 레이아웃의 계층 구조 중 루트 뷰를 제공해야 한다. 따라서 그리기는 루트노드에서 시작되어 트리를 따라 전위 순회 방식으로 그려진다. [전위 순회 방식 : 루트-&gt;왼쪽-&gt;오른쪽] 부모 뷰는 자식 뷰가 그려지기 전에(즉, 자식 뷰 뒤에) 그려지며 형제 뷰는 전위 방식에 따라 순서대로 그려진다. 레이아웃을 그리는 과정은 <strong>측정</strong>(measure) 단계와 <strong>레이아웃</strong>(layout) 단계를 통해 그려지게 된다.</p>
<p><strong>measure(int widthMeasureSpec, int heightMeasureSpec)</strong></p>
<p>부모 노드에서 자식 노드를 경유하며 실행되며, 뷰의 크기를 알아내기 위해 호출된다. 이것은 뷰의 크기를 측정하는 것은 아니며 실제 크기 측정은 <code>onMeasure(int, int)</code>를 통해 이루어진다. measure(int, int)의 내부에서 onMeasure(int, int)를 호출함으로써 뷰의 크기를 알아낸다. 측정 과정에서는 부모 뷰와 자식 뷰간의 크기 정보를 전달하기 위해 2가지의 클래스를 사용한다.</p>
<ol>
<li>ViewGroup.LayoutParams</li>
</ol>
<p>자식 뷰가 부모 뷰에게 자신이 어떻게 측정되고 위치를 정할지 요청하는데 사용된다. ViewGroup의 sub class에 따라 다른 ViewGroup.LayoutParams의 sub class가 존재할 수 있다. 예를 들어 ViewGroup의 sub class인 <code>RelativeLayout</code>의 경우 자신만의 ViewGroup.LayoutParams의 sub class는 자식 뷰를 수평적으로 또는 수직적으로 가운데 정렬을 할 수 있는 능력이 있다.</p>
<ul>
<li>숫자</li>
<li>MATCH_PARENT</li>
<li>WRAP_CONTENT</li>
</ul>
<ol start="2">
<li>ViewGroup.MeasureSpec</li>
</ol>
<p>부모 뷰가 자식 뷰에게 요구 사항을 전달하는데 사용된다.</p>
<ul>
<li>UNSPECIFIED : 부모 뷰는 자식 뷰가 원하는 치수대로 결정한다.</li>
<li>EXACTLY : 부모 뷰가 자식 뷰에게 정확한 크기를 강요한다.</li>
<li>AT MOST : 부모 뷰가 자식 뷰에게 최대 크기를 강요한다.</li>
</ul>
<p><strong>layout(int l, int t, int r, int b)</strong></p>
<p>부모 노드에서 자식 노드를 경유하며 실행되며 뷰와 자식 뷰들의 크기와 위치를 할당할 때 사용된다. <code>measure(int, int)</code>에 의해 각 뷰에 저장된 크기를 사용하여 위치를 지정한다. 내부적으로 <code>onLayout()</code>을 호출하고 onLayout()에서 실제 뷰의 위치를 할당하는 구조로 되어있다.</p>
<p>measure()와 layout() 함수는 내부적으로 각각 onMeasure()와 onLayout() 함수를 호출한다. 이것은 final로 선언된 measure()와 layout() 대신 onMeasure()와 onLayout()을 구현(override)할 것을 장려하기 위해서이다.</p>
<p>뷰의 measure()함수가 반환할때, 뷰의 getMeasureWidth()와 getMeasureHeight()값이 설정된다. 만약 자식 뷰 측정값의 합이 너무 크거나 작을 경우 다시 <code>measure()</code> 함수를 호출하여 크기를 재측정한다.</p>
<h2 id="view-lifecycle">View Lifecycle</h2>
<img src="/img/android_view_method.png" width="400" height="300">
<ol>
<li>Constructor<br>
모든 뷰는 생성자에서부터 출발한다. 생성자에서 초기화를 진행하고, default 값을 설정한다. 뷰는 초기설정을 쉽게 세팅하기 위해서 <code>AttributeSet</code>이라는 인터페이스를 지원한다. 먼저, attrs.xml 파일을 만들고 이것을 부름으로써 뷰의 설정값을 쉽게 설정할 수 있다.<br>
<img src="/img/android_view_attrs.png" width="700" height="300"></li>
</ol>
<ol start="2">
<li>onAttachedToWindow<br>
부모 뷰가 <code>addView(childView)</code> 함수를 호출하고 나서 자식 뷰는 윈도우에 붙게 된다.(attached) 이때부터 뷰의 id를 통해 접근할 수 있다.</li>
</ol>
<ol start="3">
<li>onMeasure<br>
뷰의 크기를 측정하는 단계이다. 매우 중요한 단계이며, 대부분의 경우 레이아웃에 맞게 특정크기를 가져야 한다. 여기에는 두 단계의 과정이 있다.</li>
</ol>
<p>(1) 뷰가 원하는 사이즈를 계산한다.<br>
(2) <code>MeasureSpec</code>에 따라 크기와 mode를 가져온다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>MeasureSpec</code>의 mode를 체크하여 뷰의 크기를 적용한다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width;</span><br><span class="line"><span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">  width = widthSize;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">  width = Math.min(desiredWidth, widthSize);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  width = desiredWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>onLayout<br>
이 단계에서 뷰의 크기와 위치를 할당한다.</li>
</ol>
<ol start="5">
<li>onDraw<br>
뷰를 실제로 그리는 단계이다. <code>Canvas</code>와 <code>Paint</code>객체를 사용하면 필요한 것을 그리게 된다. Canvas 객체는 onDraw 함수의 파라미터로 제공된다. <strong>Canvas 객체를 이용하여 뷰의 모양을 그리고 Paint 객체를 이용하여 뷰의 색을 그린다.</strong></li>
</ol>
<img src="/img/android_view_onDraw.png" width="700" height="300">
<p>여기서 주의할 점은 <strong><code>onDraw()</code> 함수를 호출시 많은 시간이 소요된다는 점이다.</strong> Scroll 또는 Swipe 등을 할 경우 뷰는 다시 onDraw()와 onLayout() 함수를 다시 호출하게 된다. 따라서 함수 내에서 객체 할당을 피하고 한 번 할당된 객체를 재사용할 것을 권장한다.</p>
<img src="/img/android_view_ondraw2.png" width="700" height="300">
<img src="/img/android_view_ondraw3.png" width="700" height="300">
<ol start="6">
<li>View Update<br>
View Lifecycle을 보면 뷰를 다시 그리도록 유도하는 <code>invalidate()</code>와 <code>requestLayout()</code> 함수를 볼 수 있다. 이것은 런타임에 뷰를 다시 그릴 수 있게 한다. 각각의 사용 용도는 아래와 같다.</li>
</ol>
<ul>
<li>invalidate() : 단순히 뷰를 다시 그릴 때 사용한다. 예를 들어 뷰의 text 또는 color가 변경되거나 touch interactivity가 발생할 때 onDraw() 함수를 재호출하면서 뷰를 업데이트한다.</li>
<li>requestLayout() : onMeasure() 부터 다시 뷰를 그린다. 뷰의 사이즈가 변경될 때 그것을 다시 측정해야 하기 때문에 Lifecycle을 <code>onMeasure()</code> 부터 순회하면서 뷰를 그린다.</li>
</ul>
<ol start="7">
<li>Animation<br>
뷰의 animation은 frame 단위의 프로세스이다. 예를 들어 뷰가 점점 커질 때 뷰를 한 단계씩 차례대로 커지도록 할 것이다. 그리고 각 단계마다 invalidate()를 호출하여 뷰를 그릴 것이다. 대표적으로 애니메이션에 사용하는 클래스는 <code>ValueAnimator</code>이다.</li>
</ol>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/06/Android-View-Functions/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/04/Java-What-is-Marker-interface/"
                            aria-label=": [Java] 마커인터페이스"
                        >
                            [Java] 마커인터페이스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-04T15:35:44+09:00">
	
		    Jan 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>직렬화할 때 사용하는 방법 중에 Serializable과 Parcelable 두 개가 있다.<br>
그 중에서 Serializable을 공부하던 중 이것이 마커 인터페이스라고 부르는 것을 보았다.<br>
그래서 생긴 의문은 도대체 <strong>마커 인터페이스</strong>는 무엇인가</p>
                    
                        <a
                            href="/2019/01/04/Java-What-is-Marker-interface/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] 마커인터페이스"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/04/Java-What-is-Reflection/"
                            aria-label=": [Java] Reflection"
                        >
                            [Java] Reflection
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-04T15:14:43+09:00">
	
		    Jan 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>안드로이드 개념을 공부하던 중 <strong>직렬화</strong>라는 개념에 대해서 공부를 했다. 직렬화란 메모리에 올라가 있는 정보를 byte 단위의 코드로 나열하는 것이다. 이를 통해서 객체와 같은 정보를 전달할 수 있게 하는 것이다.</p>
                    
                        <a
                            href="/2019/01/04/Java-What-is-Reflection/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] Reflection"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/04/Android-What-is-Singleton-Pattern/"
                            aria-label=": [디자인패턴] 싱글톤 패턴"
                        >
                            [디자인패턴] 싱글톤 패턴
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-04T00:35:28+09:00">
	
		    Jan 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/ETC/">ETC</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>싱글톤 패턴</h2>
                    
                        <a
                            href="/2019/01/04/Android-What-is-Singleton-Pattern/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [디자인패턴] 싱글톤 패턴"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/03/Android-What-is-serialization/"
                            aria-label=": [안드로이드] 직렬화에 관해서"
                        >
                            [안드로이드] 직렬화에 관해서
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-03T21:46:29+09:00">
	
		    Jan 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><a href="#%EC%A7%81%EB%A0%AC%ED%99%94%EB%9E%80?">직렬화란?</a></li>
<li><a href="#%EC%97%AD%EC%A7%81%EB%A0%AC%ED%99%94%EB%9E%80?">역직렬화란?</a></li>
<li><a href="#Serializable">Serializable</a></li>
<li><a href="#Parcelable">Parcelable</a></li>
</ul>
<h2 id="직렬화란">직렬화란?</h2>
<ul>
<li><strong>직렬화</strong>는 메모리 내에 존재하는 정보를 보다 쉽게 전송 및 전달하기 위해 byte 코드 형태로 나열하는 것이다. 여기서 메모리 내에 존재하는 정보는 즉 객체를 말한다.</li>
<li>JVM(Java Virtual Machine)의 메모리에 상주 되어있는 객체 데이터를 바이트 형태로 변환하는 기술</li>
</ul>
<p>따라서 직렬화는 주로 객체들을 통째로 파일로 저장하거나 전송하고 싶을 때 사용한다. 나는 안드로이드 앱 개발을 할 때 액티비티간의 데이터를 전달할 때 인텐트를 사용하고 이 인텐트에 전달할 데이터를 추가한다.</p>
<p>복잡한 클래스의 객체를 이동하려는 경우에는 Serializable 또는 Parcelabe을 사용하여 직렬화하여 인텐트에 추가해서 데이터를 이동하면 된다.</p>
<h2 id="역직렬화란">역직렬화란?</h2>
<ul>
<li>byte로 변환된 Data를 원래대로 Object나 Data로 변환하는 기술을 역직렬화라고 한다.</li>
<li>직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태</li>
</ul>
<h2 id="serializable">Serializable</h2>
<p>Java에서는 Value Object를 쉽게 직렬화 하기위해 <strong>Serializable</strong>이라는 interface가 있다. 이는 Marker Interface로서 단순히 implement하는 것만으로도 JVM에게 직렬화가 가능하다는 것을 알려주기 때문에 사용하는게 매우 쉬운 편이다.</p>
<p>Serializable은 Android SDK가 아닌 표준 Java의 인터페이스이다.</p>
<p>이 인터페이스를 구현한 클래스의 객체는 이제 한 액티비티에서 다른 액티비티로 이동할 준비가 된다. 다음 코드를 보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String firstName, String lastName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Serializable은 해당 클래스가 직렬화 대상이라고 알려주기만 할뿐 어떠한 메소드도 가지지 않는 단순한 <strong>마커 인터페이스</strong>이므로 사용자는 매우 쉽게 사용할 수 있다.</p>
<p>사용방법이 쉽다는 것은 곧 시스템적인 비용이 비싸다는 것을 의미한다.</p>
<p><strong>Serializable</strong>은 내부에서 <code>Reflection</code>을 사용하여 직렬화를 처리한다. Reflection은 프로세스 동작 중에 사용되며 처리 과정 중에 많은 추가 객체를 생성한다. 이 많은 쓰레기들은 가비지 컬렉터의 타깃이 되고 가비지 컬렉터의 과도한 동작으로 인하여 성능 저하 및 배터리 소모가 발생한다.</p>
<h2 id="parcelable">Parcelable</h2>
<p><strong>Parcelable</strong>은 직렬화를 위한 또 다른 인터페이스이다. Serializable과는 달리 표준 Java가 아닌 Android SDK의 인터페이스이다.</p>
<p>Parcelabledms Reflection을 사용하지 않도록 설계되엇다. Serializable과는 달리 직렬화 처리 방법을 사용자가 명시적으로 작성하기 때문에 자동으로 처리하기 위한 Reflection이 필요없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String firstName, String lastName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeString(<span class="keyword">this</span>.firstName);</span><br><span class="line">        dest.writeString(<span class="keyword">this</span>.lastName);</span><br><span class="line">        dest.writeInt(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Person</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = in.readString();</span><br><span class="line">        <span class="keyword">this</span>.lastName = in.readString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>마커 인터페이스인 Serializable과는 달리 <strong>Parcelable</strong>은 구현해야 하는 필수 메소드를 포함하기 때문에 클래스에 <code>보일러 플레이트</code> 코드가 추가된다. 이는 클래스를 이해하기 어렵고 새로운 기능을 추가하기 힘들게 만든다. 또한 코드의 추가로 클래스가 복잡해질수록 유지 보수가 어려워지는 원인이 된다.</p>
<p>Parcelable의 사용법은 조금 어렵다. 필수적으로 정의해야 하는 메소드가 두 가지가 있다.</p>
<p><strong>describeContent()</strong></p>
<ul>
<li>Parcel 객체에 내용을 기술한다. FileDescriptor 같은 특별한 객체가 들어가면 이 부분을 통해서 알려줘야 한다. 보통은 0을 리턴한다.</li>
</ul>
<p><strong>writeToParcel(Parcel out, int flag)</strong></p>
<ul>
<li>직렬화시 container 역할을 하는 Parcel안에 데이터를 넣는 작업을 한다.</li>
</ul>
<p>이 두가지 메소드를 정의해야함과 동시에 <code>CREATOR</code>라는 static field(정적 필드)를 반드시 가지고 있어야 한다. 이는 선언과 동시에 초기화 되어야 한다. <strong>CREATOR 객체는 나중에 역직렬화 시 사용된다.</strong></p>
<p>CREATOR 구현에는 다음의 두 가지 메소드를 구현해야 한다.</p>
<p><strong>createFromParcel(Parcel source)</strong></p>
<ul>
<li>parcel된 데이터를 다시 원래대로 객체로 변환시켜 주는 작업을 한다.</li>
</ul>
<p><strong>newArray(int size)</strong></p>
<ul>
<li>전달하는 객체가 배열일 경우 즉, Parcel.createTypeArray()를 호출했을 때 불리며 배열을 다시 할당하기 위해 사용한다.</li>
</ul>
<p>parcelable은 이러한 분해와 조립을 돕는다. 이 과정에서 순서가 있고 직렬화될 변수들을 직접 세팅하여 빠른 속도를 낸다.</p>
<p>Serializable이 시스템 비용을 발생한다면 Parcelable은 구현과 유지, 보수에 드는 사용자의 노력을 비용으로 지불해야 한다.</p>
<h2 id="parcelable-vs-serializable">Parcelable VS Serializable</h2>
<p>인터넷에서는 Parcelable과 Serializable을 비교하는 정보들을 많이 찾을 수 있다. 인터넷에서 쉽게 접할 수 있는 접근법과 다른 접근법이 존재하기에 여기에 적으려고 한다. 이 글의 참고는 아래에 적어놓았다.</p>
<ol>
<li>Parcelable이 Serializable보다 빠르다.</li>
</ol>
<img src="/img/parcelable_vs_serializable_speed.png" width="500" height="300">
<p>많이 볼 수 있는 위의 결과는 Parcelable이 Serializable보다 10배 이상 빠르다는 것을 보여준다. 일부분도 그렇게 생각한다고 한다.</p>
<ol start="2">
<li>다른 의견</li>
</ol>
<p>두번째 의견은 <strong>기본 사용법에 의한 Serializable</strong>은 Parcelable보다 느리다는 것이다. 이 말의 뜻을 잘 살펴보면 다음과 같다.</p>
<p>Parcelable은 위에서 설명한 것처럼 하나의 클래스 객체만을 위한 특별한 사용자 정의 코드를 작성해야만 한다. 사용자가 정의한 코드의 도움으로 <strong>Parcelable</strong>은 Serializable과는 달리 쓰레기를 생성할 이유가 없고 그 결과 성능도 더 좋다.</p>
<p>그러나 <strong>기본 사용법에 의한 Serializable</strong>은 Java의 자동 직렬화 프로세스를 사용한다. 이 과정은 분명 Parcelable과 같은 수고로움은 없지만 처리 과정에서 많은 쓰레기를 만들어낸다. 따라서 더 나쁜 결과를 보여주게 된다.</p>
<p>지금부터 조금 다른 방법으로 Serializable을 사용해 볼 것이다. Serializable에서 자동으로 처리되는 직렬화 <strong>프로세스는 사용자가 구현한 writeObject(), readObject() 메소드로 대체될 수 있다.</strong> 사용자가 구현한 직렬화 메소드와 함께 Serializable 접근 방식을 사용하려면 다음의 메소드를 반드시 구현해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>
<p>마치 Parcelable의 사용법처럼 Serializable의 writeObject()와 readObject() 메소드에는 해당 클래스에 맞는 처리 로직을 포함시킬 수 있다. 제대로 수행된다면 기본 사용법에 의한 Serializable 방식에서 발생하는 쓰레기가 더 이상 생성되지 않을 것이다.</p>
<p>이 글 원본 작성자가 테스트한 결과는 놀랍다고 한다. 특정 클래스 처리 로직을 구현한 Serializable은 Parcelable보다 쓰기 속도가 3배 이상, 읽기의 경우 1.6배 더 빠르다고 한다.</p>
<h2 id="잠깐">잠깐!</h2>
<p>기본 사용법에 의한 Serializable보다 Parcelable이 빠르다고 했다. 그 이유를 살펴보면 Serializable은 내부적으로 <strong>리플렉션</strong>을 사용해서 이로 인해 많은 오브젝트 생성과 그에 따라 잦은 GC의 동작으로 인해 애플리케이션의 성능을 낮추는 배터리를 소모한다.</p>
<p>그렇다면 Parcelable은 왜 더 빠른 것일까??</p>
<p>Parcelable은 IPC(프로세스간 통신)을 이용하기 때문이다. 프로세스들 사이에서 서로 데이터를 주고 받는 것을 <code>IPC</code>라고 한다. 프로세스간의 메모리 영역은 서로 공유할 수 없기에 Parcelable 인터페이스는 커널 메모리를 통해 데이터를 다른 프로세스로 전달하는 통로를 만들어준다.</p>
<img src="/img/parcelable_IPC.png" width="500" height="300">
<h2 id="잠깐">잠깐!</h2>
<p>위에서 등장하는 보일러플레이트 코드는 무엇일까???</p>
<p>IT 업계에서 <strong>보일러 플레이트</strong>는 변경없이 재사용할 수 있는 저작품을 의미하며 보일러 플레이트 코드는 재사용이 가능한 코드를 의미한다.</p>
<p>이 보일러 플레이트라는 단어는 철강 업계에서 유래되었는데 증기 보일러 내에 사용되는 커다란 압연 강판을 보일러 플레이트라고 불었으며 “강철처럼 튼튼하다.” &quot;반복적으로 재사용이 가능할 정도로 강력하다&quot;라는 의미가 있다고 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://aroundck.tistory.com/3114" target="_blank" rel="noopener">[Java] writeObject 와 readObject 는 무엇인가?</a> - 참고해야할 자료 즉, 추후 공부해야할 내용들</li>
<li><a href="https://medium.com/udacity-android-nanodegree/android-parcelable-vs-serializable-f2d7d2f4a2a" target="_blank" rel="noopener">Android : Parcelable vs Serializable</a></li>
<li><a href="https://medium.com/@limgyumin/parcelable-vs-serializable-%EC%A0%95%EB%A7%90-serializable%EC%9D%80-%EB%8A%90%EB%A6%B4%EA%B9%8C-bc2b9a7ba810" target="_blank" rel="noopener">Parcelable vs Serializable , 정말 Serializable은 느릴까?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/03/Android-What-is-serialization/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/01/archives/2/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/01/archives/4/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 3 of 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
