
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2019/1 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2019/01/archives/4/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/03/Android-What-is-retrofit/"
                            aria-label=": [안드로이드] Retrofit"
                        >
                            [안드로이드] Retrofit
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-03T18:14:23+09:00">
	
		    Jan 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="안드로이드-통신-라이브러리-요약">안드로이드 통신 라이브러리 요약</h2>
<p>저는 안드로이드 앱을 개발하면 서버와 통신을 하기 위해서 편리한 방법인 Retrofit은 사용했다. 하지만 이러한 편리함을 알기 전에 왜 이렇게 편리하게 사용하는지 살펴보아야 할 것 같다.</p>
<p>초기에 안드로이드에서의 통신이라면 <strong>HttpClient</strong>를 사용하는 것이었다. HttpClient라고 해도 DefaultHttpClient라고 불리는 Apache HTTP Client와 AndroidHttpClient라는 Http Client 변종 등이 사용되고 있었다. 하지만, HttpClient에는 몇 가지 버그가 있어 2011년에는 Google의 Android Develpoers의 블로그에서 HttpUrlConnection이 권장되고 나서 이쪽이 주로 사용되고 있었다.</p>
<p>그후, Volley는 사용법이 복잡했던 HttpUrlConnection의 대안으로 Google이 만들었다는 것도 있고 표준 라이브러리로 사용되었다. Square의 OkHttp도 인기가 높고, 많이 사용되어왔다.</p>
<p>하지만 Android 5.1에서 HttpClient가 Deprecated된 후, HTTPClient에 의존하는 Volley도 Deprecated되었다. Square에서 만들어진 라이브러리인 OkHttp와 그 래퍼인 Retrofit은 단 하나 선택 같은 상태가 되었다.</p>
<h2 id="retrofit">Retrofit</h2>
<p>Retrofit은 OkHttp의 상위 구현체로 enqueue와 excute를 사용하여 동기, 비동기 처리를 지원한다. 이러한 비동기 처리를 쉽게 지원하는 volley, retrofit 중에 무엇을 사용할지 고민했으나 인터페이스 내에 어노테이션으로 HTTP 메소드를 정의하여 그 행위를 알아보기 쉽게 표현하여 가독성이 높은 Retrofit을 사용했다. 추가적으로 Retrofit은 플러그인 형태로 클라이언트와 직렬화를 위한 convert를 선택할 수 있어 유지보수에 편하다.</p>
<p>반면에 volley는 이미지 캐시, 요청에 우선순위를 부여하는 등 추가적인 기능이 있지만 직렬화를 직접 세팅해줘야하고 멀티파트 업로드 시에도 리퀘스트의 재정의가 필요하다.</p>
<p>이렇듯 추가적인 기능이 더 많은건 volley이지만 간편하고 유지보수에 능하며 좀 더 REST api에 적합한 라이브러리라 생각되어 Retrofit을 사용했다.</p>
<h2 id="retrofit을-사용한-이유">Retrofit을 사용한 이유?</h2>
<p>서버와 통신을 하려면 Http 통신을 해야한다. 기본적으로 <code>HttpUrlConnection</code>을 이용한 네트워크 통신이 있지만 매번 connection 설정, input / output stream 생성 및 할당 등 반복적인 작업이 발생한다. 이것을 도와주는 라이브러리가 <code>Okhttp</code>이다. 나는 Okhttp의 존재를 알기만 했고 사용해보지는 않았다.</p>
<p>Retrofit의 장점은 속도, 편의성, 가독성이 있다. 가장 비교하기 좋은 <code>Okhttp</code>는 사용시 대개 <code>Asynctask</code>를 통해 비동기로 실행하게 되는데 <strong>Asynctask</strong>가 성능상 느리다는 이슈가 있었다. <code>Retrofit</code>에서는 <strong>Asynctask</strong>를 사용하지 않고 자체적인 비동기 실행과 스레드 관리를 통해 속도를 훨씬 빠르게 끌어올렸다. 약 3~10배 차이가 난다고 한다.</p>
<p>또한 Okhttp에서도 쿼리스트링, <em>request</em>, <em>response</em> 설정 등 반복적인 작업이 필요한데, Retrofit에서는 이런 과정을 모두 라이브러리에 넘겨서 처리하도록 하였다. 따라서 사용자는 함수 호출시에 파라미터만 넘기면 되기에 훨씬 작업량이 줄어들고 사용하기 편리하다.</p>
<p>마지막으로 <strong>가독성</strong>이 매우 좋다. interface 내에 <strong>annotation</strong>을 사용하여 호출할 함수를 파라미터와 함께 정의해놓고, 네트워크 통신이 필요한 순간에 구현없이 해당 함수를 호출하기만 하면 통신이 이루어지기에 <strong>코드를 읽기가 매우 편하다.</strong> <code>Asynctask</code>를 쓰지 않기에 불필요하게 코드가 길어질 필요도 없으며, 콜백 함수를 통해 결과가 넘어오도록 되어있어 매우 직관적인 설계가 장점이다.</p>
<p>네트워크 통신에 <code>Volley</code>라는 라이브러리도 있지만 몇가지 문제점이 있었다. StringRequest 생성시 파라미터 값을 <strong>encoding</strong>해주어야 하는 불편함과 통신 실패시 <strong>ErrorResponse</strong> 안에 <strong>ResponseBody</strong>가 담기지 않는 문제가 있다.</p>
<h3 id="구현-방법">구현 방법</h3>
<p>application 클래스를 상속받은 <strong>ApplicationController</strong>라는 클래스를 만들고 싱글톤으로 구현하여 onCreate() 내부에 레트로핏 빌더를 이용해 클라이언트와 컨버터를 설정하고 인터페이스를 선택한다.</p>
<p><strong>application 클래스를 상속받은 이유는?</strong><br>
메인 액티비티의 통신 부 이전에 retrofit에 대한 세팅을 하기 위해 상속받았다. application 클래스는 애플리케이션 컴포넌트들이 공통으로 사용하는 공유 클래스이다. 해당 클래스를 상속받아 구현한 클래스의 onCreate 메소드는 시스템의 진입점이 되어 가장 먼저 실행된다.</p>
<h3 id="동기와-비동기란">동기와 비동기란?</h3>
<p>데이터를 받는 방식인 동기와 비동기. 이 둘의 개념에 대해서 알고 넘어가자.</p>
<ol>
<li>동기(synchronous : 동시에 일어나는)</li>
</ol>
<p>동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속인데, 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 즉시 주어져야 한다.</p>
<ul>
<li>요청과 결과가 한 자리에서 동시에 일어남</li>
<li>A 노드와 B 노ㄷ 사이의 작업 처리 단위를 동시에 맞추겠다.</li>
<li>동기적 일처리 방식 : 순차적으로 일을 스스로 끝내 나가는 방식</li>
</ul>
<ol start="2">
<li>비동기(Asynchronous : 동시에 일어나지 않는)</li>
</ol>
<p>비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을거라는 약속이다.</p>
<ul>
<li>요청한 결과가 그 자리에서 결과가 주어지지 않는다.</li>
<li>노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.</li>
<li>비동기적 일처리 방식 : 해야할 일을 위임하고 기다리는 방식</li>
</ul>
<p>동기와 비동기는 상황에 따라서 각각의 <strong>장단점</strong>이 존재한다.<br>
<code>동기방식</code>은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고,<br>
<code>비동기방식</code>은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다는 장점이 있다.</p>
<p>동기와 비동기 방식의 예는 아래의 블로그를 참고하자.</p>
<p><a href="http://private.tistory.com/24" target="_blank" rel="noopener">공부해서 남주자</a></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://private.tistory.com/24" target="_blank" rel="noopener">동기와 비동기의 개념과 차이</a></li>
<li><a href="https://wayhome25.github.io/nodejs/2017/02/18/nodejs-06-Asynchronous-synchronous/" target="_blank" rel="noopener">동기와 비동기 프로그래밍 (Asynchronous-synchronous)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/03/Android-What-is-retrofit/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/03/Android-ImageLoadingLibrary/"
                            aria-label=": [안드로이드] Image Loading Library"
                        >
                            [안드로이드] Image Loading Library
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-03T15:19:02+09:00">
	
		    Jan 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>앱을 만들면서 ImageView에 사진을 띄우고자 하는 경우가 많았다.</p>
<ol>
<li>안드로이드 앱 안의 drawable 폴더의 리소스를 보여주는 경우</li>
<li>안드로이드 디바이스 안에 저장되어 있는 사진을 보여주는 경우(갤러리 혹은 기타 내부 사진)</li>
<li>이미지 URL을 로드해서 보여주는 경우</li>
</ol>
<p>위의 1,2번 같은 경우는 안드로이드 기기 내부의 리소스를 불러오는 작업이므로 예외사항도 적고 실제 구현도 복잡하지 않다. 하지만 3번과 같은 경우는 http 클라이언트나 서버 통신을 이용해 ImageView에 보여주어야 하는 경우이다. 나는 이 같은 경우에서 <code>Glide</code>라는 라이브러리를 사용했는데, 사용할 때는 사용법이 쉬웠지만, 내부 동작이나 원리가 무엇인지 몰랐다.</p>
<p>그래서 Glide의 내부 동작 및 원리를 공부하고 이와 비슷한 Picasso와의 비교도 해보겠다.</p>
<h2 id="기본-사용방법">기본 사용방법</h2>
<p>기본적인 사용방법은 Picasso, Glide가 거의 똑같은 방식이다.</p>
<p><strong>Picasso</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Picasso.with(context).load(<span class="string">"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg"</span>).into(imageView)</span><br></pre></td></tr></table></figure>
<p><strong>Glide</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(context).load(<span class="string">"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg"</span>).into(imageView)</span><br></pre></td></tr></table></figure>
<p>다만, with() 함수에서 Picasso는 Context만을 지원하는 반면에 Glide는 Context 뿐만 아니라 다른 객체들도 사용할 수 있다. 즉, Picasso에 비해서 Glide의 with() 함수가 더 많은 인자를 받아서 사용할 수 있어서 많은 곳에서 사용할 수 있다는 장점이 있다.</p>
<img src="/img/android_picasso.with.png" width="300" height="300">
<center>Picasso
</center>
<img src="/img/android_glide_with.png" width="300" height="300">
<center>Glide</center>
<h2 id="기본-bitmap-포맷">기본 Bitmap 포맷</h2>
<p>1920x1080의 이미지를 768x432 크기의 ImageView에서 각각 로드한 경우 보여지는 이미지는 아래와 같다. 그림을 잘 보면 Glide의 이미지 화질이 Picasso보다 좋지 않음을 확인할 수 있다.</p>
<img src="/img/android_diff_glide_picasso.png" width="600" height="300">
<p>이유는 <strong>Picasso는 Bitmap 포맷은 ARGB_8888로 사용하고 Glide는 Bitmap 포맷을 RGB_565를 사용한다.</strong> RGB_565는 ARGB_8888에 비해서 화질은 떨어지지만 메모리의 용량을 50% 적게 사용한다는 이점을 가지고 있다.</p>
<p>아래 그림은 Picasso와 Glide의 메모리 사용량을 비교한 그래프이다. (8MB 정도는 기본적으로 애플리케이션에서 사용하는 메모리 사용량이고 그 이상이 각각 이미지로딩 라이브러리에서 사용하는 메모리 사용량이다.)</p>
<img src="/img/android_image_library_memory_use_compare.png" width="600" height="300">
<p>만약 메모리 용량보다 이미지의 화질이 더 중요하다고 생각한다면 Picasso를 사용하거나 Glide의 Bitmap 포맷을 ARGB_8888로 변경하여 사용할 수 있다.</p>
<p>이는 GlideModule을 상속받는 클래스를 하나 지정해서 기본 포맷을 ARGB_8888로 설정하고 이 GlideModule을 매니페스트에 등록시켜주면 된다.</p>
<p><strong>CustomGlideModule.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelphoneGlideModule</span> <span class="keyword">implements</span> <span class="title">GlideModule</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(Context context, GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 포맷을 ARGB_8888로 변경</span></span><br><span class="line">       builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888);</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(Context context, Glide glide)</span> </span>&#123;</span><br><span class="line">        glide.register(SelphoneImage.class, InputStream.class, <span class="keyword">new</span> SelphoneGlideUrlLoader.Factory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AndroidManifest.xml</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Glide모듈을 Custom하게 변경 --&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">    android:name=<span class="string">"kr.co.selphone.library.glide.SelphoneGlideModule"</span></span><br><span class="line">    android:value=<span class="string">"GlideModule"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>만약 Glide의 기본 Bitmap 포맷을 ARGB_8888로 변경했다면 Glide는 이전에 비해 2배 정도 더 많은 메모리를 사용하는 것을 확인할 수 있다. 이제는 같은 Bitmap 포맷을 사용하는데도 Picasso가 Glide보다 훨씬 많은 메모리 사용량을 보이고 있다.[왜 그럴까…?]</p>
<img src="/img/android_image_library_memory_use_compare2.png" width="600" height="300">
<p>그 이유는 Glide와 Picasso의 <strong>캐시 정책</strong>이 다르기 때문이다. <code>Picasso</code>는 1920x1080 크기의 원본 이미지를 메모리로 가져와서 GPU에서 실시간으로 리사이징해서 768x432의 ImageView에 할당한다.<br>
하지만 Glide는 바로 768x432크기로 이미지를 메모리로 가져와서 ImageView에 할당시키기 때문에 메모리 사용량이 적은 것이다.</p>
<p>만약, Picasso에서도 Glide와 같은 방식을 취하고 싶다면 <code>resize()</code> 함수를 이용하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Picasso</span><br><span class="line">    .with(context)</span><br><span class="line">    .load(<span class="string">"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg"</span>)</span><br><span class="line">    .resize(<span class="number">768</span>,<span class="number">432</span>)</span><br><span class="line">    .into(imageView)</span><br></pre></td></tr></table></figure>
<p>ImageView의 크기를 매번 적어주기 번거롭거나 알아오기 귀찮다면 <code>fit()</code> 함수를 사용하면 같은 효과를 볼 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Picasso</span><br><span class="line">    .with(context)</span><br><span class="line">    .load(<span class="string">"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg"</span>)</span><br><span class="line">    .fit()</span><br><span class="line">    .into(imageView)</span><br></pre></td></tr></table></figure>
<p>위 방법을 사용할 경우 Picasso, Glide 모두 같은 메모리 사용량을 보일 것이다.</p>
<img src="/img/android_image_library_memory_use_compare3.png" width="600" height="300">
<h2 id="이미지-캐시">이미지 캐시</h2>
<p>그 전에 <strong>캐싱</strong>은 명령어들과 데이터들을 기억장치 또는 캐시를 저장하는 디스크에 일시적으로 저장하는 기술을 말한다.</p>
<p>이미지를 캐시하는 방식에서도 기본적인 정책은 Glide와 Picasso가 다르다. 위의 예시처럼 1920x1080 이미지를 768x432 크기의 ImageView에 로드하는 경우 Glide는 768x432 크기의 이미를 캐시하는 반면, Picasso는 1920x1080의 원본 이미지를 캐시하게 된다.</p>
<img src="/img/android_diff_glide_picasso_size.png" width="600" height="300">
<p>만약 1920x1080 이미지를 다시 384x216 크기의 ImageVIew로 로드한다고 할 경우 Picasso는 이미 원본 이미지를 캐시해서 그대로 가지고 있지만 Glide는 또 하나의 384x216 크기의 이미지 파일을 캐시하게 된다.</p>
<p>Glide는 같은 이미지를 다른 크기의 ImageView에 로드한다는 이유로 2번의 이미지 다운로드와 리사이징 작업이 필요하게 된다.(내 생각에는 비효율적이라고 생각한다.)</p>
<p>만약 Glide에서 원본 크기의 이미지를 캐시하도록 설정하고 싶은 경우 아래와 같이 캐시 정책을 추가해주면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Glide</span><br><span class="line">    .with(context)</span><br><span class="line">    .load(<span class="string">"https://cdn.vox-cdn.com/thumbor/97LMDBshI0KBwq2N0_NnP5_0QSE=/0x0:2040x1360/1520x1013/filters:focal(857x517:1183x843):format(webp)/cdn.vox-cdn.com/uploads/chorus_image/image/57358643/jbareham_170504_1691_0020.0.0.jpg"</span>)</span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.ALL)</span><br><span class="line">    .into(imageView)</span><br></pre></td></tr></table></figure>
<p>위의 정책을 적용하고 난 뒤부터는 모든 Glide를 이용하여 로드할 때 원본 이미지를 가져와서 캐시하게 된다.</p>
<p>Glide는 이미지를 최대한 빨리 로드해주는데에 최적화 되어있기 때문에 이러한 정책을 기본적으로 적용하고 있다. 원본 이미지를 가져오는 정책과 이를 로드하는 속도는 반비례 관계에 있기 때문에 이미지 로딩 속도와 캐시에 관련해서는 원하는 방향에 맞게 설정해주면 좋다.</p>
<h2 id="추가-함수-사용방법-비교">추가 함수 사용방법 비교</h2>
<p><strong>Resize</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso</span></span><br><span class="line">.resize(<span class="number">300</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glide</span></span><br><span class="line">.override(<span class="number">300</span>,<span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Center Crop</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso</span></span><br><span class="line">.centerCrop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glide</span></span><br><span class="line">.centerCrop()</span><br></pre></td></tr></table></figure>
<p><strong>PlaceHolder와 Error이미지</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picasso</span></span><br><span class="line">.placeHolder(R.drawable.placeholder)</span><br><span class="line">.error(R.drawable.imageNot)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glide</span></span><br><span class="line">.placeHolder(R.drawable.placeholder)</span><br><span class="line">.error(R.drawable.imageNot)</span><br></pre></td></tr></table></figure>
<p><strong>한글이 포함된 URL처리</strong></p>
<p>Picasso에서는 URL에 한글이 포함되어 있으면 ANR(Application Not Responsding)을 발생하며 앱을 종료시킨다. 그러나 Gliude는 URL에 한글이 포함되어도 아무 문제가 없다.</p>
<h2 id="glide에서만-가능한-기능">Glide에서만 가능한 기능</h2>
<ol>
<li>
<p>GIF<br>
Glide에서는 ImageView에 GIF 파일을 로드할 수 있다. 하지만 GIF를 빈번하게 사용하면 많은 메모리 사용량을 보이기 때문에 적절하게 GIF를 사용해야 한다.</p>
</li>
<li>
<p>Thumbnail 기능<br>
용량이 큰 이미지의 경우 thumbnail() 함수를 이용하여 우선 10% 만큼만 가져와서 흐릿하게나마 먼저 보여주고 그 다음 전체 이미지를 로드해서 사용자에게 좀더 쾌적한 UI를 제공해줄 수 있다. [%는 사용자가 지정할 수 있다.]</p>
</li>
<li>
<p>Custom Animation<br>
Picasso에서는 단순이 fade in 기능의 애니메이션만을 지원하는 반면, Glide에서는 .animate(ViewPropertyAnimation.Animator)을 이용하여 여러 애니메이션을 보여줄 수 있다.</p>
</li>
<li>
<p>Custom load<br>
기본적으로 Image Resource, URL, 휴대폰 내장 이미지를 로드하는 기능 외에도 Custom Model을 만들어서 이를 로드하는 기능도 지원하고 있다.</p>
</li>
</ol>
<h2 id="더-복잡한-내용">더 복잡한 내용</h2>
<p>안드로이드에서 비트 맵 캐싱에 대한 부분은 까다롭다. 그래서 우리는 이미지의 비트맵 포맷을 편리하게 캐싱해주는 Glide를 사용한다. Glide도 비트 맵 캐싱에 관한 작업을 수행하므로 이와 관련있다.</p>
<p>Glide는 디스크 캐시와 메모리 캐시를 사용한다.</p>
<h2 id="잠깐">잠깐!</h2>
<p>이미지 로드 라이브러리 중에서 Fresco에 대해서 간단하게 알고 넘어가자.</p>
<ul>
<li>facebook에서 공개한 이미지 라이브러리.</li>
<li>널리 알려져 있는 UIL, Glide, Picasso 와 비교하여 가장 최근에 공개되었다.</li>
<li>다만, 아직 최근에 공개된 라이브러라서 레퍼런스가 많지 않고 Fresco의 ImageView를 사용해야한다는 것이 단점이다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://gun0912.tistory.com/19" target="_blank" rel="noopener">[안드로이드/Android]Picasso와 Glide 비교분석</a></li>
<li><a href="https://developer.android.com/topic/performance/graphics/cache-bitmap" target="_blank" rel="noopener">글라이드, 비트맵 캐싱 정책</a></li>
<li><a href="http://meylady.tistory.com/49" target="_blank" rel="noopener">안드로이드 이미지캐시(메모리캐시, 디스크캐시)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/03/Android-ImageLoadingLibrary/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/03/Android-Diff-of-DP-SP/"
                            aria-label=": [안드로이드] SP와 DP의 차이"
                        >
                            [안드로이드] SP와 DP의 차이
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-03T14:30:22+09:00">
	
		    Jan 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="스크린의-실제-단위-px">스크린의 실제 단위 PX</h2>
<p>px은 화면을 구성하는 최소 단위이다.<br>
px 단위는 화면의 전체 화면 크기와 상관없이 지정한 수치만큼 표시되는 절대적 표시 단위이므로 안드로이드에서는 px보다는 DP 단위를 사용하면 좋다.</p>
<h2 id="dpi">DPI</h2>
<p>DPI는 Dots Per Inch로 1인치에 들어가는 픽셀을 나타내는 단위이다.<br>
예를 들어 100DPI는 1인치당 픽셀이 100개가 포함된다는 것을 의미한다.<br>
개수가 많을수록 고밀도이며 안드로이드에서 주요 DPI는 아래와 같다.</p>
<ul>
<li>ldpi : 120dpi</li>
<li>mdpi : 160dpi(기본)</li>
<li>hdpi : 240dpi</li>
<li>xhdpi : 320dpi</li>
<li>xxhdpi : 480dpi</li>
<li>xxxhdpi : 640dpi</li>
</ul>
<p>안드로이드의 기준 DPI는 160DPI이다.<br>
160 DPI인 경우 밀도 독립단위 DP와 PX이 같은 크기를 갖는다.<br>
즉, 160DPI에서는 1dp는 1px이 된다.</p>
<p><code>DP</code>(Density-Independent Pixels)는 UI 레이아웃을 정의할 때 레이아웃 치수나 위치를 지정하기 위해 사용하는 단위이다. 픽셀 독립 단위이며 화면의 크기가 달라도 동일한 비율로 보여주기 위해 안드로이드에서 정의한 단위이며 큰 화면, 작은 화면에 상관없이 같은 크기로 나타난다.</p>
<p><code>SP</code>(Scale-Independent Pixels)는 UI 레이아웃을 정의할 때 텍스트의 크기를 지정하기 위해 사용하는 단위이다.</p>
<p>안드로이드 설정 화면에서 사용자는 안드로이스 시스템 전체에서 보여지는 텍스트의 크기를 선택하여 설정할 수 있는데 SP는 해당 설정에 영향을 받는다. 예를 들어, 시스템 설정에서 텍스트 크기를<br>
&quot;최대 크케&quot;로 설정하게 되면 UI 레이아웃을 정의할 때 <strong>SP</strong>로 크기를 지정해놓은 TextView의 텍스트 크기가 영향을 받아 커진다. 반면에 TextView의 텍스트 크기를 <strong>DP</strong>로 설정하게 되면 시스템 설정의 텍스트 크기 값의 변화에 상관없이 일정한 크기를 유지한다.</p>
<p>그래서 디자인 명세에 따라서는 텍스트 크기의 값의 단위를 SP를 사용하는 것이 아니라 DP를 사용하는 것이 좋을 경우도 있을 것이다. 다시 말해, 언제나 일관성 있게 화면에서 똑같은 텍스트 크기를 표현하고자 하는 경우에는 SP가 아닌 DP 단위를 사용하도록 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@dev.chamo/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-sp%EC%99%80-dp%EC%9D%98-%EC%B0%A8%EC%9D%B4-491d920fa262" target="_blank" rel="noopener">[안드로이드] SP와 DP의 차이</a></li>
<li><a href="https://blog.cracker9.io/2018/03/13/Android_DPI/" target="_blank" rel="noopener">초보 디자이너를 위한 안드로이드 DP(Dip), PX, DPI의 개념</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/03/Android-Diff-of-DP-SP/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/"
                            aria-label=": [안드로이드] ListView vs RecyclerView"
                        >
                            [안드로이드] ListView vs RecyclerView
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-03T09:53:38+09:00">
	
		    Jan 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>신입 개발자를 위한 <a href="https://github.com/WooVictory/Ready-For-Tech-Interview" target="_blank" rel="noopener">Repository</a>를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다.</p>
<p>우리가 사용하는 앱 중에서 가장 많이 등장하는 것은 무엇일까?? 그 중의 하나는 바로 리스트라고 해도 과언이 아닐 것이다. 사용자에게 리스트 즉, 목록을 보여주는 것이 가장 많이 등장한다. 그렇다면 이 리스트를 구현하는 방법에는 무엇이 있을까??</p>
<h2 id="listview">ListView</h2>
<p>ListView는 이름에서도 알 수 있듯이 리스트 즉, 목록을 구현하는데 사용된다. ListView는 안드로이드에 임베디드 되어 있는 코드로 동작하며, API level 1부터 존재했다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    Holder holder = <span class="keyword">new</span> Holder();</span><br><span class="line">    View rowView = inflater.inflate(R.layout.item_list, <span class="keyword">null</span>);</span><br><span class="line">    holder.tv = (TextView) rowView.findViewById(R.id.text);</span><br><span class="line">    holder.img = (ImageView) rowView.findViewById(R.id.image);</span><br><span class="line">    holder.tv.setText(result[position]);</span><br><span class="line">    holder.img.setImageResource(imageId[position]);</span><br><span class="line">    rowView.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            Toast.makeText(context, <span class="string">"You Clicked "</span> + result[position], Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> rowView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 형태는 가장 일반적인 ListView의 getView() 접근 방법이다. 하지만 위와 같이 동작하게 되면 getView() 즉, ListView의 <strong>재사용성이 떨어지게 된다.</strong></p>
<p>재사용이라는게 getView()는 현재 화면상에 아이템이 보일 때 호출되는 함수이다. 예를 들어, 아이템이 20개가 있고 이를 스크롤한다고 가정하면 스크롤 시에도 getView() 함수는 계속해서 호출된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Holder holder = <span class="keyword">new</span> Holder();</span><br><span class="line">View rootView = inflater.inflate(R.layout.item_list, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>
<p>또한, 위의 코드는 별도의 null 처리가 없으므로 스크롤을 할 때마다 inflate를 통해서 View의 create가 발생하고 findViewById도 함께 호출된다. [이러한 부분들이 비효율적이다.] 리스트의 특성상 하나의 View만 있으면 이 View가 연속적으로 사용이 가능한 형태가 만들어지면 되는데 ListView는 이러한 것이 강제적이지 않아서 힘들다.</p>
<p>그래서 <code>ViewHolder</code>의 개념이 등장하게 된다. 구글의 권장 사항이라 강제적이지는 않다. <strong>다만 위와 같이 inflate와 findViewById를 리스트뷰에서 연속적으로 발생시키면 메모리와 성능에 악영향을 미칠 수 있다.</strong> 그래서 ViewHolder 패턴을 사용하는 것을 권장한다.</p>
<h3 id="listview에-viewholder-패턴을-적용한다면">ListView에 ViewHolder 패턴을 적용한다면?</h3>
<p>아래는 ViewHolder 패턴을 적용한 코드이다. convertView == null일 경우에만 inflate와 findViewById가 호출되어 view가 생성된다. 그리고 rootView의 setTag를 호출하여 생성된 ViewHolder를 임시 저장해둔다.</p>
<p>메모리에 문제가 없다면 최초 1회만 생성되고 이후 else 문을 통해서 getTag()를 호출하여 ViewHolder를 꺼내와서 ViewHolder에 접근이 가능한 형태가 만들어지게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 최초에 convertView가 null이므로, inflate를 처리한다</span></span><br><span class="line">    <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 전역으로 생성한 rootView에 inflate</span></span><br><span class="line">        rootView = inflater.inflate(R.layout.item_list, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ViewHolder을 생성</span></span><br><span class="line">        Holder holder = <span class="keyword">new</span> Holder();</span><br><span class="line">        holder.tv = (TextView) rowView.findViewById(R.id.text);</span><br><span class="line">        holder.img = (ImageView) rowView.findViewById(R.id.image);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// setTag : holder 임시 저장</span></span><br><span class="line">        rootView.setTag(holder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// rootView에 convertView를 셋팅</span></span><br><span class="line">        rootView = convertView;</span><br><span class="line">        <span class="comment">// rootView에서 holder을 꺼내온다</span></span><br><span class="line">        holder = (Holder) rootView.getTag();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder.tv.setText(result[position]);</span><br><span class="line">    holder.img.setImageResource(imageId[position]);</span><br><span class="line">    rowView.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            Toast.makeText(context, <span class="string">"You Clicked "</span> + result[position], Toast.LENGTH_LONG).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> rootView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 구현하는 것이 ListView에 ViewHolder 패턴을 적용하는 것이라고 보면 된다. 하지만 강제적이지 않아서 구현하는 것이 귀찮은 작업이 된다.</p>
<p>그리고 커스텀이 많고 하나의 리스트에 다양한 ViewHolder를 만들기가 쉽지 않다. 예를 들면 다음과 같은 경우이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">사진이 포함된 ViewHolder</span><br><span class="line">텍스트만 있는 ViewHolder</span><br><span class="line">오른쪽이 스크롤 되는 ListView가 포함된 ViewHolder</span><br></pre></td></tr></table></figure>
<p>물론 우리는 ViewHolder 패턴을 이해하고 만들면 괜찮지만, 대부분의 개발자들은 귀찮을 것을 싫어한다… ㅎㅎ [내 생각^.^] 그래서 구글은 귀찮음을 해소하기 위해 RecyclerView라는 것을 만들어서 내놓았다.</p>
<h2 id="listview의-장단점">ListView의 장/단점</h2>
<p><strong>장점</strong></p>
<ul>
<li>ListView는 간단하게 리스트를 만드는 부분에 있어서는 장점을 가지고 있다. [ex) 텍스트만 있는 리스트]</li>
<li>간단한 아이템 형태를 만드는 경우에는 빠르게 적용이 가능한 ArrayAdapter를 제공한다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>아이템의 애니메이션 처리가 쉽지 않다.</li>
<li>리스트에는 한 개 이상의 View가 필요한 경우가 있지만 커스텀으로 작업하기 쉽지 않다.</li>
<li>ViewHolder 패턴을 강제적으로 사용하지 않으므로 고비용의 findViewById가 매번 호출될 수 있다.</li>
</ul>
<h2 id="recyclerview">RecyclerView</h2>
<p>롤리팝(5.0) 버전이 ListView보다 유연하고 성능이 향상된 RecyclerView와 함께 발표되었다. 기존의 ListView는 커스터마이징 하기에 힘들었고, 구조적인 문제로 성능상의 문제도 있어다.</p>
<p>RecyclerView는 ListView의 문제를 해결하기 위해 개발자에게 더 다양한 형태로 커스터마이징 할 수 있도록 제공되었다. RecyclerView와 ListView의 가장 큰 차이점은 LayoutManager와 ViewHolder 패턴의 의무적인 사용, Item에 대한 뷰의 변형이나 애니메이션할 수 있는 개념이 추가된 것이다.</p>
<p><strong>Create Lists</strong></p>
<p>creating Lists and Cards에 정의된 List 표현이다.</p>
<img src="/img/android_recyclerview.png" width="500" height="300">
<p>widget인 RecyclerView는 LayoutManager를 통해서 View를 그리는 방법을 정의한다. RecyclerView.Adapter에서는 Data의 ViewHolder 정의에 따라서 UI가 선택되고 이를 표현하게 된다.</p>
<ul>
<li>강제적인 ViewHolder의 적용으로 View의 <strong>재사용</strong>을 가능하게 해준다.</li>
<li>많은 데이터를 리스트 형태로 제공이 가능하다.</li>
<li>RecyclerView.ItemAnimator을 이용하여 Item의 Animator를 이용할 수 있다.</li>
<li>LayoutManager를 통해서 아이템의 배치 방법을 다양하게 적용할 수 있다.</li>
</ul>
<p><strong>주요 클래스</strong></p>
<ul>
<li>Adapter : 기존의 ListView에서 사용하는 Adapter와 같은 개념으로 데이터와 아이템에 대한 View 생성</li>
<li>ViewHolder : 재활용 View에 대한 모든 서브 뷰를 보유</li>
<li>LayoutManager : 아이템 항목을 어떻게 배치하는가를 결정</li>
<li>ItemDecoration : 아이템 항목에서 서브뷰에 대한 처리</li>
<li>ItemAnimation : 아이템 항목이 추가, 삭제되거나 정렬될 때 애니메이션 처리를 할 수 있다.</li>
</ul>
<ol>
<li>Adapter</li>
</ol>
<p>리스트뷰는 데이터가 어디서 왔느냐에 따라 BaseAdapter를 상속한 ArrayAdapter(배열로부터 데이터를 가져올 때 사용), CursorAdapter(DB로부터 데이터를 가져올 때 사용), SimpleAdapter(XMl 등으로부터 가져올 때 사용)를 구분하여 사용한다.</p>
<p>하지만 RecyclerView는 Universal한 Adapter를 사용하여 데이터 소스를 처리한다. 이것은 리싸이클러뷰의 <strong>유연성</strong>을 보여준다. 다음의 3가지 인터페이스를 구현해야 한다.</p>
<ul>
<li>onCreateViewHolder(ViewGroup parent, int viewType) : 뷰 홀더를 생성하고 뷰를 붙여주는 부분이다.</li>
<li>onBindViewHolder(CustomViewHolder holder, int position) : 재활용 되는 뷰가 호출하여 실행되는 메소드, 뷰 홀더를 전달하고 어댑터는 position의 데이터를 결합시킨다.</li>
<li>getItemCount() : 데이터의 개수 반환</li>
</ul>
<p>getItemCount() -&gt; onCreateViewHolder() -&gt; onBindViewHolder() 순으로 호출된다.</p>
<p>리스트뷰가 사용했던 getView() 메소드는 매번 호출되면서 null 처리를 해주는 귀찮은 작업을 해줘야했다면, onCreateViewHolder는 새롭게 생성될 때만 호출된다.</p>
<ol start="2">
<li>ViewHolder</li>
</ol>
<p>리스트뷰에서는 뷰홀더 패턴을 권장했다. UI를 수정할 때마다 부르는 findViewById()를 뷰홀더 패턴을 이용해 한번만 호출함으로써 리스트뷰의 지연을 초래하는 무거운 연산을 줄여주었다. 이 문제를 리싸이클러뷰에서는 뷰홀더 패턴을 항상 사용하도록(강제하도록) 함으로써 해결했다.</p>
<p>하지만 실제로 앱의 퍼포먼스를 향상시켜주지만 최신의 디바이스는 뷰홀더 패턴을 사용하지 않은 리스트뷰나 리싸이클러뷰의 성능 차이는 미세하다.</p>
<p><strong>단지 차이점은 리싸이클러뷰는 뷰홀더 패턴이 강제되는 것일 뿐이다.</strong> 이전의 리스트뷰는 선택적이었지만 성능 차이가 너무 컸기 때문에 변화된 것으로 생각된다. 간과하기 쉬운 중요한 점은 뷰홀더 패턴을 사용한 리스트뷰와 리싸이클러뷰의 성능은 같다.</p>
<ol start="3">
<li>LayoutManager</li>
</ol>
<p>리스트뷰는 수직 스크롤만 가능하다. 리스트뷰를 수평으로 사용할 수는 없었다. 그것을 구현하기 위한 몇가지 방법이 있지만 리스트뷰는 그렇게 동작하도록 디자인 되지 않았다고 한다.</p>
<p>그러나 이제 리싸이클러뷰에서는 수직뿐만 아니라 수평 스크롤 또한 지원한다. 뿐만 아니라 더 다양한 타입의 리스트들을 지원하고, 커스텀할 수 있도록 해준다. 많은 타입의 리스트를 사용학 위해서 LayoutManager를 사용하면 된다.</p>
<blockquote>
<p>LayoutManager의 종류</p>
</blockquote>
<ol>
<li>LinearLayoutManager</li>
</ol>
<ul>
<li>Vertical(가로) / Horizontal(세로) 형태로 아이템을 배치한다.</li>
</ul>
<ol start="2">
<li>GridLayoutManager</li>
</ol>
<ul>
<li>한 줄에 1개 이상의 이미지를 표시할 수 있지만 아이템의 크기는 줄의 첫 번째 아이템의 크기에 따라서 달라질 수 있다.(고정시에는 모두 고정)</li>
</ul>
<ol start="3">
<li>StaggeredGridLayoutManager</li>
</ol>
<ul>
<li>그리드 형태의 아이템에 크기를 다양하게 적용할 수 있다.</li>
</ul>
<ol start="4">
<li>Custom LayoutManager</li>
</ol>
<ul>
<li>3개의 레이아웃 매니저를 상속받아 구현할 수 있다.</li>
</ul>
<ol start="4">
<li>Item Decoration</li>
</ol>
<p>리스트뷰에서는 XML에 파라미터를 추가함으로써 쉽게 divide할 수 있었다. 리싸이클러뷰에서는 RecyclerView.ItemDecoration 클래스를 통해 divider를 원하는 아이템에 추가할 수 있도록 되었다. 조금 복잡해졌지만 동적인 데코레이팅이 가능해졌다.</p>
<ol start="5">
<li>Item Animator</li>
</ol>
<p>Material Design에 대해 조명된 이후로 리스트에서의 애니메이션을 무궁무진한 가능성을 가지게 되었다. 리스트뷰에서는 아이템의 삽입이나 삭제에 특별한 애니메이션이 없었다.</p>
<p>하지만 리싸이클러뷰에서는 RecyclerView.ItemAnimator 클래스를 통해 애니메이션을 핸들링 할 수 있게 되었다. 이 클래스를 통해서 아이템의 삽입, 삭제, 이동에 대한 커스터마이징이 가능하고, 또한 DefaultItemAnimator가 제공되므로 커스터마이징이 필요 없이 사용할 수도 있다.</p>
<p>notifyItemChanged(int position), notifyItemInserted(int position), notifyItemRemoved(int position)을 ItemAnimator을 통해 특정 아이템에 대한 애니메이션을 발생시킬 수 있습니다.</p>
<ol start="6">
<li>클릭 이벤트 처리</li>
</ol>
<p>터치 이벤트를 통해 사용자가 아이템을 클릭했는지 롱클릭 했는지를 직접처리</p>
<p>RecycleView.OnItemTouchListener은 리싸이클러뷰의 터치 이벤트를 감지한다. 좀 복잡하지만 개발자에게 터치 이벤트를 인터셉트하는 제어권한을 주게 되었다.</p>
<p>안드로이드 공식 문서에서는 터치 이벤트를 인터셉트함으로서 리싸이클러뷰에게 전달하기 전에 조작함으로써 유용하게 사용될 수 있다고 한다.(ListView에서 아이템을 클릭시 콜백 받을 수 있는 리스너는 RecyclerViewd에는 존재하지 않음.)</p>
<p>즉, RecyclerView에는 Click 이벤트에 대한 처리를 자체적으로 할 수 없다. 그래서 onClickListener를 달아줘야 하는 문제가 발생한다.</p>
<p>내가 사용하는 방법으로는 RecyclerView를 사용하는 액티비티에서 View.OnClickListener를 상속받고 그 액티비티의 Context를 RecyclerView.Adapter에서 만든 함수에게 넘긴다.</p>
<p>이 함수는 액티비티에서 받은 Context(여기에 View.OnClickListener이 포함되어 있음)를 Adapter 클래스의 View.OnClickListener 타입의 변수인 ItemClick을 초기화한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onItemClikc</span><span class="params">(l : <span class="type">View</span>.<span class="type">OnClickListener</span>)</span></span>&#123;</span><br><span class="line">    ItemClick = l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그러면 Adapter는 ClickListener 정보를 받아서 onCreateViewHolder에서 만든 View를 리턴하기 전에 그 View에게 onClickListener를 붙여주면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: HomeFilterViewHolder &#123;</span><br><span class="line">     <span class="keyword">var</span> view = LayoutInflater</span><br><span class="line">         .from(parent.context).inflate(R.layout.home_course_filter_list, parent, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">     view.setOnClickListener(onItemClick)</span><br><span class="line">     <span class="keyword">return</span> HomeFilterViewHolder(view)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>DiffUtil</li>
</ol>
<p><code>DiffUtil</code>은 데이터의 변화를 감지하여 뷰를 갱신하는 클래스이다. areItemsTheSame, areContentsTheSame, getChangedPayload 등을 오버라이딩하여 데이터간 변화를 감지한다.</p>
<p>RecyclerView.Adapter에서 notifyItemMoved, notifyItemRangeChanged, notifyItemRangeInserted, notifyItemRangeRemoved 등이 호출되면 DiffUtil에서 해당 범위의 데이터의 변화를 감지하고 뷰를 선택적으로 갱신함으로써 비용이 큰 notifyDataSetChanged 대신 효율적으로 사용될 수 있다.</p>
<p>추가적인 DiffUtil 클래스의 메소드를 확인하고 싶다면 아래 글을 참고하자.<br>
<a href="https://medium.com/sopt/do-it-sopt-android-seminar-4-beb2d9245a4b" target="_blank" rel="noopener">about RecyclerView</a></p>
<h2 id="정리">정리</h2>
<p>그럼 간단하게 ListView와 RecyclerView의 차이점을 표 형식으로 정리해서 보겠다. 아래의 표는 블로그를 참고했으며 참고 링크는 아래에 적어놓았다.</p>
<img src="/img/android_diff_listview_recyclerview.png" width="500" height="300">
<p><strong>다음 세가지를 비교/정리</strong></p>
<ul>
<li>
<p>ListView<br>
리스트뷰에서는 BaseAdapter를 상속받은 ArrayAdapter나 CursorAdapter 등을 사용한다.<br>
ViewHolder 패턴을 선택적으로 구현하기 때문에 구현하지 않는 경우 각각의 View를 그릴 때마다 findViewById()를 호출하기 때문에 성능 저하 문제가 발생한다.<br>
getView() 메소드에서 뷰를 그릴 때마다 findViewById()를 매번 호출하여 성능이 저하된다.</p>
</li>
<li>
<p>ListView+ViewHolder<br>
리스트뷰에서 ViewHolder 패턴을 구현한다면 성능에 관해서는 RecyclerView와 비슷하지만 기존의 ListView는 뷰 커스텀 작업에 대한 유연성이 떨어진다.</p>
</li>
<li>
<p>RecyclerView<br>
리싸이클러뷰는 ViewHolder 패턴의 사용을 강제하고 Adapter 클래스를 직접 구현하기 때문에 뷰 커스텀 작업에 대한 유연성이 ListView보다 더욱 쉽고 편하다.</p>
</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://crystal-k.tistory.com/16" target="_blank" rel="noopener">리사이클러 뷰 RecyclerView 정리</a></li>
<li><a href="http://itmining.tistory.com/12" target="_blank" rel="noopener">[안드로이드] RecyclerView란? (RecyclerView와 ListView 차이)</a></li>
<li><a href="http://armful-log.tistory.com/27" target="_blank" rel="noopener">[안드로이드] RecyclerView ( ListView와 차이 )</a></li>
<li><a href="http://virusworld.tistory.com/90" target="_blank" rel="noopener">Android - ViewHolder 패턴</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/03/Android-Diff-of-ListView-and-RecyclerView/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-SharedPreference/"
                            aria-label=": [안드로이드] SharedPreference"
                        >
                            [안드로이드] SharedPreference
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T19:26:08+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="sharedpreference">SharedPreference</h2>
<ul>
<li>간단한 값 저장에 DB를 사용하기에는 복잡하기 때문에 SharedPreference를 사용하면 적합하다.</li>
<li>Key-Value 쌍으로 데이터를 저장한다.</li>
<li>간단한 데이터를 읽고 쓰기에 유용하다.</li>
<li><strong>자동 로그인, 앱 초기 설정값, 다시보지 않기</strong> 등에 사용된다.</li>
<li>애플리케이션에 파일 형태로 저장된다.
<ul>
<li>data/data/패키지명/shared_prefs/SharedPreference이름.xml 위치에 저장된다.</li>
</ul>
</li>
<li>애플리케이션이 삭제되기 전까지 보존된다. 애플리케이션이 삭제되면 저장된 정보가 날라간다.</li>
</ul>
<h2 id="사용법">사용법</h2>
<ol>
<li>객체 생성 및 데이터 저장</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> USER_NAME : String = <span class="string">"Woo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> editor : SharedPreference.Editor = pref.eidt()</span><br><span class="line">editor.putString(<span class="string">"key"</span>, <span class="string">"value"</span>)</span><br><span class="line">editor.putInt(<span class="string">"intKey"</span>,<span class="number">2</span>)</span><br><span class="line">editor.commit()</span><br></pre></td></tr></table></figure>
<ol>
<li>getSharedPreference()</li>
</ol>
<ul>
<li>getSharedPreference() 함수를 통하여 SharedPreference 객체를 얻는다.</li>
<li>첫 번째 인자 USER_NAME은 해당 SharedPreference의 이름이다. 특정 이름으로 생성할 수 있고 해당 이름으로 xml 파일이 생성된다.</li>
<li>두 번째 인자는 mode이고 읽기/쓰기 권한과 관련된 mode라고 생각하면 된다.</li>
</ul>
<ol start="2">
<li>editor 객체 얻기</li>
</ol>
<ul>
<li>editor 객체를 통해서 데이터의 읽기, 쓰기 작업을 수행한다.</li>
</ul>
<ol start="3">
<li>데이터 저장</li>
</ol>
<ul>
<li>putString() : key-value 형태로 데이터를 저장한다.
<ul>
<li>위에서는 intKey라는 key 값으로 2라는 int형 value를 저장하고 있다.</li>
<li>작업이 완료되었을 때는 반드시 editor.commit()을 수행한다.</li>
</ul>
</li>
</ul>
<ol start="2">
<li>데이터 꺼내오기 및 삭제하기</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> USER_NAME : String = <span class="string">"Woo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)</span><br><span class="line">pref.getString(<span class="string">"key"</span>,<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드에서는 getString()을 통해서 원하는 데이터를 Key 값을 이용해서 찾아 꺼낼 수 있다.</li>
<li>그리고 해당 Key로 저장된 값이 없다면 default로 지정한 &quot; &quot; 값이 꺼내지게 된다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> USER_NAME : String = <span class="string">"Woo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> pref : SharedPreference = getSharedPreference(USER_NAME, MODE_PRIVATE)</span><br><span class="line"><span class="keyword">val</span> editor : SharedPreference.Editor = pref.eidt()</span><br><span class="line">pref.remove(<span class="string">"key"</span>)</span><br><span class="line">pref.clear()</span><br><span class="line">pref.commit()</span><br></pre></td></tr></table></figure>
<ul>
<li>pref.remove() : Key값으로 삭제할 데이터를 찾아서 삭제한다.</li>
<li>pref.clear() : USER_NAME으로 된 객체의 모든 정보(데이터)를 삭제한다.</li>
</ul>
<p>이렇게 SharePreference를 사용하면 간단한 데이터를 저장하야 사용할 수 있고 자동 로그인과 같은 기능을 구현할 수 있다. 즉, 간단한 값을 저장하여 계속 유지되도록 하고 싶을 때 사용하기 좋다.</p>
<p>저는 SharedPreference를 Object 즉, static하게 만들어서 어디서든 접근할 수 있도록 사용하고 있다. 이렇게 구현해야 저장한 값을 어디서든 불러와서 사용할 수 있기 때문이다.</p>
<h2 id="추가-객체-저장하기">추가 - 객체 저장하기</h2>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 데이터 저장</span></span><br><span class="line"><span class="keyword">var</span> mPref : SharedPreference = getPreference(MODE_PRIVATE)</span><br><span class="line"><span class="keyword">var</span> eidtor : SharedPreference.Editor = mPref.editor()</span><br><span class="line"><span class="keyword">var</span> gson = Gson()</span><br><span class="line"><span class="keyword">var</span> json : String = gson.toJson(MyObject) <span class="comment">// gsont을 json 형식으로 변환</span></span><br><span class="line">editor.putString(<span class="string">"MyObject"</span>, json) <span class="comment">// json 객체 저장</span></span><br><span class="line">editor.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 꺼내오기</span></span><br><span class="line"><span class="keyword">var</span> gson = Gson()</span><br><span class="line"><span class="keyword">var</span> json : String = mPref.getString(<span class="string">"MyObject"</span>,<span class="string">""</span>)</span><br><span class="line"><span class="keyword">var</span> obj : MyObject = gson.fromJson(json, MyObject::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="comment">// fromJson 함수를 통해서 json 객체를 꺼내와서 MyObject 클래스의 형태처럼 gson으로 저장한다.</span></span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-SharedPreference/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-Permission-MarshMellow/"
                            aria-label=": [안드로이드] 런타임 퍼미션"
                        >
                            [안드로이드] 런타임 퍼미션
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T18:29:08+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-runtime-permission">1. Runtime Permission</h2>
<p>안드로이드 버전 6.0 즉, MarshMellow 이전 버전에서는 사용자가 <strong>앱을 설치하는 시점에 한번만 동의를 받으면 그 이후에는 문제없이 해당 권한들을 사용할 수 있었다.</strong> 즉, 앱을 설치할 때 필요한 권한들에 대한 동의를 얻는 것이다.</p>
<p>사용자가 해당 권한을 이 앱에서 사용하는 것에 대해서 꺼림직해 하거나 마음에 들지 않는다면 앱을 사용하지 않는 방법이 유일하다. 그로 인해 수많은 피싱앱이 생겼고, 일부 앱에서는 과도한 권한을 요구하는 경우도 있었다.</p>
<p>하지만 안드로이드 6.0 마시멜로우 버전 이상에서는 권한 허용 여부를 묻지 않는다. <strong>앱에서 해당 권한이 필요할때마다 사용자로부터 권한을 허가받도록 변경되었다.</strong> 또한, 사용자가 권한을 허가했더라도 사용자는 설정화면(설정 &gt; 애플리케이션 &gt; 앱이름 &gt; 권한)을 통해 언제든지 권한을 허용/거부할 수 있다.</p>
<p>그래서 우리는 해당 권한이 실행될 때마다 권한을 사용할 수 있는지 확인해야 하고, 권한을 사용할 수 없는 경우에는 사용자로부터 권한을 허가받는 기능을 추가해주어야 한다.</p>
<h2 id="2-모든-권한을-다-체크해야-하는가">2. 모든 권한을 다 체크해야 하는가?</h2>
<p>그렇다면 모든 권한을 다 체크해야 할까? 아니다.<br>
<strong>우리가 AndroidManifest.xml에서 선언한 모든 권한에 대해서 허가를 받아올 필요는 없다.</strong> 구글이 정의한 Normal Permission과 Dangerous Permission 중 <code>Dangerous Permission</code>에 대해서만 권한을 체크해주면 된다.</p>
<p><a href="https://developer.android.com/guide/topics/security/permissions?hl=ko#normal-dangerous" target="_blank" rel="noopener">Normal Permission and Dangerous Permission</a></p>
<p>Normal Permission과 Dangerous Permission에 대한 내용은 위의 링크를 참고하면 된다.</p>
<p>그러면 우리는 Dangerous Permission에 대해서만 체크하고 허가를 받으면 된다. 아래는 Dangerous Permission과 permissions groups 표이다. 이외의 Permission들은 체크하지 않아도 된다.</p>
<img src="/img/android_dangerous_permission.png" width="500" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://gun0912.tistory.com/55" target="_blank" rel="noopener">[안드로이드/Android]6.0 마시멜로우 권한체크하고 최적화하기</a></li>
<li><a href="https://developer.android.com/guide/topics/security/permissions?hl=ko#normal-dangerous" target="_blank" rel="noopener">안드로이드 개발자 문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-Permission-MarshMellow/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-is-Intent/"
                            aria-label=": [안드로이드] 인텐트"
                        >
                            [안드로이드] 인텐트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T17:28:41+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="intent란">Intent란?</h2>
<p>안드로이드 어플리케이션을 구성하는 4가지 기본 요소에는 <strong>Activity, Service, Broadcast Receiver, Content Provider</strong>가 있다. <code>인텐트</code>는 이러한 어플리케이션 구성요소 즉, 컴포넌트간에 작업 수행을 위한 정보를 전달하는 역할을 한다.</p>
<p>인텐트를 가장 손쉽게 사용한 예로는 액티비티간 화면 전환을 들 수 있다. 즉 인텐트는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 <strong>명시적</strong>으로 표시되기도 하고, 속성들이 <strong>암시적</strong>으로 표시되기도 한다.</p>
<p>또한 호출된 컴포넌트 B가 호출한 컴포넌트 A로 어떠한 결과를 전달할 때도 인텐트가 사용된다. 어떠한 컴포넌트를 호출하느냐에 따라서 사용되는 대표적인 메소드는 다음과 같은 것들이 존재한다.</p>
<ul>
<li>startActivity() : 새로운 액티비티 화면을 띄울 때 사용</li>
<li>startService(), bindService() : 서비스와 관련된 메소드</li>
<li>broadcastIntent() : 브로드캐스팅을 수행할 때</li>
</ul>
<p>인텐트의 기본 구성 요소로는 액션(Action)과 데이터(Data)가 존재한다. <strong>액션</strong>은 수행할 기능이며, <strong>데이터</strong>는 액션이 수행될 대상 데이터을 의미한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예를 들어 아래의 코드가 있다고 하자.</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_DIAL, Uri.parse(<span class="keyword">data</span>))</span><br></pre></td></tr></table></figure>
<p>액션은 ACTION_DIAL 즉, 전화 다이얼을 걸라는 액션이며,<br>
data 값을 uri로 파싱한 Uri.pars(data)라는 것은 액션이 수행할 data 즉 전화번호일 것이다.</p>
<p>&quot;요약하면 Uri로 파싱한 전화번호 data를 대상으로 전화다이얼을 걸어라&quot;라는 뜻이고 이 뜻을 인텐트에 담아 안드로이드 시스템에게 전달하면 되는 것이다.</p>
<h2 id="인텐트-동작-순서">인텐트 동작 순서</h2>
<ul>
<li>Componenet가 ActivityManager에게 다른 컴포넌트의 실행을 요청</li>
<li>ActivityManager는 패키지 정보를 가지고 있는 PacakageManager에게 컴포넌트 정보 요청</li>
<li>유요한 컴포넌트임을 확인하면 컴포넌트를 실행</li>
<li>여기서 실행을 요청할 때 컴포넌트의 정보가 <strong>Intent</strong>이다.</li>
<li>Intent는 IPC 통신을 위한 직렬화 객체로 Parcelable을 통해 직렬화 되어 있다.</li>
<li>즉, 이 객체는 다른 프로세스로 전달하기 위한 데이터 그 자체이다.</li>
<li>활성화 될 컴포넌트 정보 + 활성화 될 컴포넌트에게 전달할 데이터</li>
<li>activity의 경우 startActivity()</li>
<li>service의 경우 startService()</li>
<li>Broadcast Recevier의 경우 sendBroadcast()</li>
<li>외부 패키지에서 접근하려면 <activity exported="true"> 이어야 한다.</activity></li>
</ul>
<h2 id="intent의-종류">Intent의 종류</h2>
<p>안드로이드의 4대 컴포넌트가 상호 통신을 위해 사용하는 인텐트는 크게 두가지로 나뉜다.</p>
<ol>
<li>명시적 인텐트</li>
</ol>
<p>인텐트에 클래스 객체네 컴포넌트 이름을 지정하여 호출될 대상을 확실히 알 수 있는 경우에 사용하는 것을 <strong>명시적 인텐트</strong>라고 한다. 주로 애플리케이션 내부에서 사용한다.</p>
<p>간단하게 현재 액티비티에서 SecondActivity로 화면 전환을 하는 코드는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener&#123;</span><br><span class="line">            <span class="comment">// 주의해서 볼 코드</span></span><br><span class="line">            <span class="keyword">var</span> intent = Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, SecondActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>새로운 인텐트 객체인 intent를 생성하면서 this@MainActivity 즉, getContext와 같은 현재 액티비티 정보가 담겨있는 정보와 SecondActivity 즉, 호출할 컴포넌트를 파라미터로 넘겨준다. 그리고 startActivity()에 인텐트 객체인 intent를 파라미터로 넘겨주면 새로운 화면인 SecondActivity가 실행된다. startActivity()는 새로 띄우는 액티비티로부터 받는 응답을 처리할 필요가 없을 때 간단하게 사용된다.</p>
<p>이에 반해 **startActivityForResult()**의 경우 새로 띄운 액티비티로부터 받는 응답을 처리할 경우에 사용된다.</p>
<ol start="2">
<li>암시적 인텐트</li>
</ol>
<p><strong>인텐트의 액션과 데이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다.</strong> 즉 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.</p>
<p>특정 컴포넌트에서 암시적 인텐트를 받기 위해서는 매니페스트 파일에서 <intent-filter> 요소와 함께 어플리케이션 컴포넌트 각각에 대해서 하나 이상의 인텐트 필터를 선언해야 한다. 각각의 컴포넌트는 action, data, category를 기반으로 해서 자신이 받길 원하는 인텐트의 유형을 명시해야 한다.</intent-filter></p>
<p>안드로이드 시스템은 전달되는 암시적 인텐트가 매니페스트에 존재하는 인텐트 필터 중의 하나와 매칭되는 경우 해당 컴포넌트로 암시적 인텐트를 전달해준다.</p>
<p>암시적 인텐트를 사용하는 대표적인 경우로 <strong>문서 편집기</strong>를 예로 들 수 있다. 카카오톡으로 친구가 자신의 자소서를 봐달라며 PDF 파일을 첨부했다. 우리는 그 PDF를 클릭하여 열기를 하면 해당 안드로이드 폰에 PDF를 편집하거나 보여줄 수 있는 많은 애플리케이션들이 서로 자기가 그 PDF 파일을 보여줄 수 있다고 손을 든다.</p>
<p>그러면 안드로이드 시스템에서는 ‘PDF를 열 수 있는 앱들이 이렇게 많은데 어떤거 선택할래?’ 라고 애플리케이션을 선택할 수 있는 위젯을 띄워준다. 이런 일련의 과정을 가능하게 하는 녀석이 <strong>암시적 인텐트</strong>이다.</p>
<blockquote>
<p>그럼 왜 암시적 인텐트를 사용할까??</p>
</blockquote>
<p>위의 예에서 우리는 친구의 자소서 PDF 파일을 열려고 한다. 여기서 PDF 파일을 열기 위해 이미 많은 PDF 리더 앱들이 존재한다. 그런데 굳이 우리가 PDF 리더를 만드는 것은 현실적으로 좋은 방법이 아니다. 따라서 <strong>이미 기존에 어떤 기능들을 지원하는 앱들이 있는 경우에 암시적 인텐트를 사용해서 그 앱들을 사용하면 되는 것</strong>이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 네이버 페이지</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"http://m.naver.com"</span>))</span><br><span class="line">startActivity(intent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전화 걸기</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"tel:010-0000-0000"</span>))</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<p>위와 같이 암시적 인텐트는 보통 액션(Action)과 데이터(data)라는 속성으로 구성되어 있다. 이 두 가지 속성 말고도 Category, Type, Component, Extras라는 속성을 가진다. 여기서 Component라는 속성을 지정할 경우 컴포넌트 클래스 이름을 명시적으로 지정하게 되는데 이 경우가 <strong>명시적 인텐트</strong>에 속하게 된다.</p>
<p>결국 암시적 인텐트는 Component 속성을 제외한 나머지 속성들로 구성되며, 이러한 속성들에 부합하는 컴포넌트가 실행된다.[호출할 대상들이 달라질 수 있다.]</p>
<p>안드로이드 폰에서 위의 코드 중 네이버에 접속하는 코드를 실행한 결과 화면은 아래와 같다.</p>
<img src="/img/android_intent.png" width="500" height="300">
<p>이와 같이 암시적 인텐트는 그 속성에 부합하는 컴포넌트가 여러 개 있을 때 선택할 수 있도록 해준다.</p>
<h2 id="intent-flag">Intent Flag</h2>
<p>안드로이드 애플리케이션 개발을 하다가 Activity에 대해 중복을 방지하거나 다른 상황에 대처할 때 Flag에 대해 잘 관리를 한다면 Activity에 대한 이해를 할 수 있고 관리 또한 용이하게 할 수 있다.</p>
<img src="/img/android_task.png" width="500" height="300">
<p><strong>안드로이드 태스크란?</strong>(Android Task, Activity Stack)</p>
<ul>
<li>Task는 애플리케이션에서 실행되는 액티비티를 보관하고 관리하며 Stack 형태의 연속된 Activity들로 이루어진다.</li>
<li>LIFO(Last In First Out) 즉, 후입 선출 형태로 나중에 적재된 액티비티일수록 가장 먼저 사용된다.</li>
<li>만약 1-&gt;2-&gt;3 페이지 순으로 액티비티를 이동했을 때 실행 순서대로 Task에 push 했다가 back 버튼을 누르면 3-&gt;2-&gt;1 페이지 순으로 Task에서 pop 시켜 돌아간다.</li>
<li>서로 다른 애플리케이션 간의 이동에도 Task를 이용해 사용자 경험(UX)를 유지시켜준다.</li>
<li>최초 적재 액티비티는 Root Activity라고도 하며 애플리에키션 런처로부터 시작된다.</li>
<li>마지막으로 적재되는 액티비티는 Top Activity라고 하며 현재 화면에 활성화 되어 있는 액티비티를 말한다.</li>
<li>Task 내에는 서로 다른 애플리케이션의 액티비티들이 포함될 수 있어 애플리케이션에 경계 없이 하나의 애플리케이션인 것처럼 보이게 해준다.</li>
<li>Task의 Stack내에 존재하는 액티비티들은 모두 묶여서 background와 foreground로 함께 이동한다.</li>
<li>홈버튼 클릭 : task interrupt -&gt; background</li>
<li>홈버튼 롱클릭 : recent task -&gt; foreground</li>
<li>Flag를 사용하여 Task 내의 액티비티의 흐름을 제어할 수 있다.</li>
</ul>
<p><strong>어피니티란?</strong>(Android Affinity)</p>
<ul>
<li>애플리케이션 내의 액티비티들은 하나의 어피니티(affinity : 친화력)을 가지고 있다.</li>
<li>AndroidManifest 파일에서 <activity> 요소의 taskAffinity 속성을 사용해 개별 affinity가 지정 가능하다.</activity></li>
<li>FLAG_ACTIVITY_NEW_TASK 플래그를 가진 인텐트 객체로부터 호출된 allowTaskReparenting 속성을 true로 가지고 있는 액티비티에 한해 affinity가 동작한다.</li>
<li>위 조건이 만족한 상황에서 시작된 액티비티는 자신과 동일한 어피니티를 갖는 태스크가 있을 경우 해당 태스크로 이동한다.</li>
<li>즉, [b] 어피니티를 가진 A 액티비티가 호출되어 해당 테스크에 속해있을 때 [b] 어피니티를 가진 태스크가 호출되면 A 액티비티는 [b] 어피니티를 가진 태스크로 이동한다.</li>
<li>어피니티에 의해 테스크가 이동된 후에 back 버튼으로 반환시 원래 해당하던 테스크로 돌아간다.</li>
<li>하나의 애플리케이션내에서 하나 이상의 기능을 갖는 애플리케이션이 존재할 경우 각 액티비티별로 다른 어피니티를 지정해 관리할 수 있다.</li>
</ul>
<p>Flag를 사용하는 방법은 AndroidManifest 파일에서 사용하는 방법과 Intent 코드로 사용하는 방법이 있다.</p>
<ol>
<li>AndroidManifest에서 사용하기</li>
</ol>
<p>안드로이드의 launchMode 속성을 사용하여 적용할 수 있다. 원하는 액티비티에 속성을 추가하여 적용하면 된다. launchMode에서 사용 가능한 속성은 다음과 같이 4가지만 가능하다.</p>
<ul>
<li>standard : 스택 중 어느 곳에나 위치 가능하며 <strong>여러 개의 인스턴스가 생성 가능하다.</strong></li>
<li>singleTop : 스택 중 어느 곳에나 위치 가능하며 여러 개의 인스턴스가 생성 가능하고 호출한 activity와 현재 최상위 activity가(top activity) <strong>동일한 경우 최상위 activity가 재사용</strong>된다.(기존 최상위 activity는 pop)</li>
<li>singleTask : 루트 액티비티로만 존재하며 <strong>하나의 인스턴스만 생성 가능</strong>하다. (타 task에서 동일 activity 사용 불가) 다른 액티비티 실행시 동일 Task 내에서 실행이 가능하다.</li>
<li>singleInstance : 루트 액티비티로만 존재하며 하나의 인스턴스만 생성 가능하고 <strong>태스크 내에 해당 액티비티 하나만 속할 수 있어</strong> 다른 액티비티를 실행시키면 새로운 Task가 생성되어 (FLAG_ACTIVITY_NEW_TASK와 동일) 그 Task 내에 포함된다.</li>
</ul>
<ol start="2">
<li>소스 코드에서 플래그를 사용하고 싶을 때는 Intent에 addFlags(), setFlags() 메소드를 사용한다.</li>
</ol>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK : 동일 affinity의 task가 있으면 그곳에 실행되고 아니면 새로운 task를 실행한다.[실행은 액티비티를 만들어 테스크에 넣는 것을 의미]</li>
<li>FLAG_ACTIVITY_SINGLE_TOP :  호출되는 액티비티가 최상위에 존재할 경우에는 해당 액티비티를 다시 생성하지 않고 존재하던 액티비티를 재사용한다. [실행시 재사용 액티비티의 실행은 onPause(), onNewIntent(), onResume() 순으로 호출된다.]
<ul>
<li>[B]를 single top 설정 : [A][B] 상태에서 [B] 호출 시 =&gt; [A][재사용된 B]</li>
<li>[A]를 single top 설정 : [B][A] 상태에서 [B] 호출 시 =&gt; [B][A][B]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_NO_HISTORY : 해당 액티비티는 재활성화시(back 키를 눌러 다시 활성화될 때) pop된다.
<ul>
<li>[B]를 no history 설정 : [A][B][A] 상태에서 back 키 사용시 [A]가 pop되고 [B] 역시 no history에 의해 pop =&gt; [A] 만 남음.</li>
</ul>
</li>
<li>FLAG_ACTIVITY_REORDER_TO_FRONT : activity 호출 시 이미 같은 activity가 task 내에 있으면 같은 activity는 pop시키고 해당 activity가 push 된다.
<ul>
<li>[A]를 reorder to front 설정 : [A][B] 상태에서 [A] 호출 시 같은 activity인 [A]가 pop되고 =&gt; [B][A]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_CLEAR_TOP : 해당 task에 있는 모든 activity를 pop시키고 해당 activity가 root activity로 task에 push된다.
<ul>
<li>[A]를 clear top 설정 : [A][B] 상태에서 [A] 호출시 모두 pop되고 =&gt; [A]</li>
<li>단, 해당 플래그는 액티비티를 모두 onDestroy()시킨 후 새롭게 onCreate()시키기 때문에 [A]를 유지하려면 FLAG_ACTIVITY_SINGLE_TOP 플래그와 함께 사용하면 된다.</li>
</ul>
</li>
<li>추가적인 플래그는 아래의 안드로이드 개발자 문서를 참고하자.</li>
<li><a href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT" target="_blank" rel="noopener">추가 정보</a></li>
</ul>
<p><strong>Clear Task</strong></p>
<ul>
<li>Task를 오랫동안 사용하지 않고 방치해두면 시스템은 Root Activity를 제외한 모든 액티비티를 Clear 시킨다.</li>
<li>이러한 동작은 Activity의 속성을 수정하여 제어할 수 있다.</li>
</ul>
<ol>
<li>alwaysRetainTaskState<br>
Task의 Root Activity에 true로 설정되어 있다면 상단에 언급되었던 동작은 발생하지 않으며 Task는 오랜 시간 이후에도 Stack에 있는 모든 Activity를 유지한다.</li>
</ol>
<ol start="2">
<li>clearTaskOnLaunch<br>
이 속성이 true로 설정되어 있으면 alwaysRetainTaskState과 정반대로 사용자가 Task를 떠났다가 다시 돌아올 때마다 항상 Stack은 Root Activity로 정리된다.</li>
</ol>
<ol start="3">
<li>finishOnTaskLaunch<br>
이 속성은 clearTaskOnLaunch와 유사하지만 전체 Task가 아닌 단일 Activity에서 동작한다. 그리고 그것은 Root Activity를 포함한 어떤 Activity가 사라지는 원인이 될 수도 있다. true로 설정되어 있을 때, Activity는 현재 Sessing 동안 Task의 일부만 유지한다. 만일 사용자가 해당 Task를 벗어났다가 다시 돌아오면 더 이상 존재하지 않는다.</li>
</ol>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://limkydev.tistory.com/35" target="_blank" rel="noopener">인텐트 (intent 명시적, 암시적)</a></li>
<li><a href="https://newgenerationkorea.wordpress.com/2015/07/09/%EC%9D%B8%ED%85%90%ED%8A%B8intent%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/" target="_blank" rel="noopener">인텐트란 무엇인가?</a></li>
<li><a href="http://androidhuman.tistory.com/262" target="_blank" rel="noopener">내가 누군지 말해줘! - 인텐트 필터</a></li>
<li><a href="http://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-%ED%83%9C%EC%8A%A4%ED%81%AC%EB%9E%80-Task-Activity-Stack-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EB%9E%80-Android-Affinity-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%9E%80" target="_blank" rel="noopener">안드로이드/Android 태스크란? (Task, Activity Stack) 어피니티란? (Android Affinity) 플래그란? (Android Flag)</a></li>
<li><a href="http://kylblog.tistory.com/21" target="_blank" rel="noopener">안드로이드 Intent Flag 정리(Activity 관리)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-is-Intent/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-Is-Fragment/"
                            aria-label=": [안드로이드] Fragment"
                        >
                            [안드로이드] Fragment
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T12:31:10+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="fragment란">Fragment란??</h2>
<p>Fragment란 하나의 Activity가 여러 개의 분할된 화면을 가지도록 만들기 위해 고안된 개념이다. 다양한 크기의 화면을 가진 모바일 환경이 늘어나고 태블릿의 큰 화면에 대한 <code>Activity의 비효율성</code>이 부각되었다. 이처럼 하나의 디스플레이 화면 안에서 다양한 화면을 보여주고 싶은 니즈를 충족시키기 위해 등장한 것이 Fragment이다.</p>
<p>Fragment를 사용하면 다른 Activity에서도 <strong>재사용</strong>할 수 있다는 장점이 있다. 또한 전체 화면인 Activity에서 부분 화면을 만드는 데 주로 사용된다.</p>
<p>Fragment는 항상 Activity 위에 올라가 있어야 한다. 자체 생명주기를 갖지만, Activity의 생명주기에 종속적이다. Activity가 소멸되면 그 위의 Fragment도 소멸된다.</p>
<p>안드로이드 4대 컴포넌트(Activity, Service, Broadcast Receiver, Content Provider)들은 <strong>인텐트</strong>를 이용하여 상호 간에 통신을 진행한다. 하지만 Fragment는 안드로이드의 4대 컴포넌트에 속하는 구성 요소가 아니다. 따라서 인텐트를 사용하여 값을 전달할 수 없다.</p>
<p>그래서 Fragment 간에 값을 전달하고 상호 통신을 하기 위해서 고안된 것이 <code>Bundle</code>이라는 것이다. Fragment는 Bundle이라는 객체를 통해서 Fragment 간의 데이터 전달을 수행한다.</p>
<blockquote>
<p>추가 내용</p>
</blockquote>
<p>Fragment는 자신이 속한 Activity와만 통신을 해야하며, 항상 자신이 속한 Activity를 통해서 다른 Fragment나 Activity와 통신해야 한다.<br>
Fragment와 Activity가 통신할 수 있는 방법에는 3가지 방법이 있다.</p>
<ol>
<li>Bundle - Acticity는 Fragment를 생성 후, 데이터를 넣은 bundle을 전달할 수 있다. Fragment는 onActivityCreated() 메소드에서 bundle을 받게 된다.</li>
<li>Method - Activity는 Fragment의 메소드를 호출할 수 있다.</li>
<li>Listener - Fragment는 interface를 사용하여 Activity에서 리스너 이벤트를 발생시킬 수 있다.</li>
</ol>
<p>하나의 Activity에 속하는 다수의 Fragment가 동시에 동작 가능하다. Activity는 한 화면을 다 차지해야 하는데 Fragment는 화면 일부만 점유해도 동작 가능하기 때문에 화면을 분할하여 부분마다 독립적인 유저 인터페이스를 구현할 수 있다. Activity의 일부분을 차지하는 각각의 Fragment는 자신만의 유저 인터페이스를 보여주고, 사용자의 입력에 반응한다.</p>
<p>기기의 화면 크기나 화면 방향 등에 따라 달라지는 Activity의 레이아웃에 맞추어 Fragment의 레이아웃을 재배열하거나 결합할 수 있다. 예를 들어 태블릿에서는 Activity에 두 개의 Fragment를 추가한 유저 인터페이스를 보여주지만 핸드폰에서는 Activity당 하나의 Fragment를 추가한 유저 인터페이스를 보여준다.</p>
<h2 id="fragments-lifecycle">Fragment’s LifeCycle</h2>
<p>Fragment는 생명 주기를 갖지만, Activity의 생명주기에 종속적인 특성이 있다.</p>
<img src="/img/fragment_lifecycle.png" width="500" height="300">
<ul>
<li>
<p>onAttach()</p>
<ul>
<li>Fragment가 Activity에 추가될 때 한번 호출된다.</li>
<li>하지만 아직 완벽하게 생성된 것은 아니다.</li>
<li>Fragment가 Activity에 대한 참조를 얻기 위해 사용되어진다.</li>
</ul>
</li>
<li>
<p>onCreate()</p>
<ul>
<li>본격적으로 Fragment가 Activity의 호출을 받아 생성되는 시점이다.</li>
<li>Fragment의 생명주기는 Activity의 생명주기에 <strong>종속적</strong>이라고 앞에서 언급했다. 이 단계에서는 Activity도 생성 중에 있는 시기이기 때문에 Activity에 있는 컨트롤을 참조하거나 Fragment의 요소들을 초기화할 때 불안정한 경우가 있다.</li>
<li>Activity의 onCreate()에서는 view, UI 작업을 할 수 있지만, Fragment의 onCreate()에서는 할 수 없다.</li>
<li>Activity의 onCreate 메소드가 아직 완료된 시점이 아니라서 유저 인터페이스와 관련있는 것을 제외한 Fragment에서 사용되는 리소스들이 초기화된다.</li>
<li>Fragment가 paused 또는 stop 되었다가 다시 resume되었을 때 유지하고 싶은 Fragment의 컴포넌트들을 여기서 초기화 해주어야 한다.</li>
</ul>
</li>
</ul>
<p>setRetainInstance(true)를 호출하여 Fragment의 인스턴스를 유지하도록 할 수 있다. 이 때 다음의 세가지가 기존과 달라진다.</p>
<ol>
<li>Activity가 재생성되어도 Fragment가 유지되기 때문에 onCreate는 호출되지 않는다.</li>
<li>onDestroy()가 호출되지 않지만, Activity로부터 Fragment가 detach될 때 onDetach()는 호출된다.</li>
<li>onAttach(Activity)와 onActivityCreated(Bundle)는 호출된다.</li>
</ol>
<ul>
<li>onCreateView(LayoutInflater, ViewGroup, Bundle)
<ul>
<li>Fragment에 속한 각종 View나 viewGroup에 대한 <strong>UI 바인딩 작업을 할 수 있다.</strong></li>
<li>Fragment의 유저 인터페이스가 화면에 그려지는 시점에 호출된다.</li>
<li>XML 레이아웃을 inflate하여 Fragment를 위한 View를 생성하고 Fragment 레이아웃의 root에 해당되는 View를 Activity에게 리턴해야 한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>inflate?</p>
</blockquote>
<p>inflate는 XML 레이아웃에 정의된 뷰나 레이아웃을 읽어서 메모리상의 view 객체를 생성해주는 것이다.</p>
<ul>
<li>
<p>onActivityCreated()</p>
<ul>
<li>Activity에서 Fragment를 모두 생성하고(View 생성) 난 다음에 호출된다.</li>
<li>Activity에서 onCreate() 다음에 호출되는 메소드이다.</li>
<li>Activity와 Fragment가 드디어 연결되는 시점이다.</li>
<li>Activity와 Fragment의 View가 모두 생성된 시점이라 findViewById()를 사용하여 View 객체에 접근하는게 가능하다.</li>
</ul>
</li>
<li>
<p>onStart()</p>
<ul>
<li>Fragment가 사용자에게 보여지기 전에 호출되는 함수이다.</li>
<li>Fragment가 속한 Activity가 start 된 것과 관련있음.</li>
</ul>
</li>
<li>
<p>onResume()</p>
<ul>
<li>Fragment가 비로소 화면에 보이는 단계이다.</li>
<li>사용자에게 <strong>focus</strong>를 잡은 상태.</li>
<li>사용자와의 상호 작용이 가능하다.</li>
<li>Fragment가 속한 Activity가 resume된 것과 관련있음.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 사용되지 않을 때 호출되는 함수들</strong></p>
<ul>
<li>
<p>onPause()</p>
<ul>
<li>Activity가 pause되어 Fragment는 사용자와의 상호작용을 중지한다.</li>
<li>Fragment가 중지되는 시점을 정의한다. Fragment의 정지가 반드시 Fragment의 소멸을 의미하는 것은 아니지만 다시 해당 Fragment로 돌아온다는 보장도 없기 때문에 이 시점에서 <strong>남겨두어야 하거나 보존해야 할 자료들을 저장</strong>한다.</li>
</ul>
</li>
<li>
<p>onStop()</p>
<ul>
<li>Activity에 의해 stop되었거나 Fragment의 수행이 Activity에 의해 수정되었을 경우로 Fragment는 더 이상 보이지 않게 되며, Fragment 기능은 중지한다.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 destroy될 때 다음 순서대로 호출된다.</strong></p>
<ul>
<li>
<p>onDestroyView()</p>
<ul>
<li>Fragment가 화면에서 보이지 않고 View의 현재 상태가 저장된 후 호출된다.</li>
<li><strong>Fragment의 View들을 제거(destroy)한다.</strong></li>
<li>Back Stack을 사용했다면, 해당 Fragment로 돌아올 때 onCreateView()가 호출된다.</li>
<li>onCreateView에서 초기화했던 UI들을 여기서 해제하면 된다.</li>
</ul>
</li>
<li>
<p>onDestroy()</p>
<ul>
<li>Fragment를 더 이상 사용하지 않을 때 호출된다.</li>
<li>Activity와 연결이 끊어진 상태는 아니지만 Fragment는 동작하지 않는다.</li>
<li>Fragment를 제거하기 직전.</li>
<li>시스템에서 onDestory()가 항상 호출되는 것을 보장해주지 않는다.</li>
</ul>
</li>
<li>
<p>onDetach()</p>
<ul>
<li>onDetach가 호출된 후, Fragment를 비로소 제거하고 Activity와의 연결도 해제한다.</li>
<li>Framgnet의 View hierarchy가 더 이상 존재하지 않게 된다.</li>
<li>부모 Activity가 즉, 종속된 Activity가 생명주기를 완전하게 마치지 않고 종료되었다면 onDetach()는 호출되지 않을 수도 있다.</li>
</ul>
</li>
</ul>
<h2 id="액티비티와-프래그먼트-차이">액티비티와 프래그먼트 차이</h2>
<p>위에서 언급했듯이 태블릿이 등장하면서 큰 화면에 대한 액티비티의 <strong>비효율성</strong>이 부각되었다. 태블릿의 큰 화면에 여러 액티비티를 보여주기 위해 나온 것이 프래그먼트이다. 하나의 액티비티에 여러 레이아웃을 배치하여 구성할 수도 있지만 <code>프래그먼트</code>를 사용하면 다른 액티비티에서도 <strong>재사용</strong>이 가능하고 <strong>자체 생명주기</strong>를 가지기에 생명주기에 따라 다양한 구현이 가능하다. 또한 자체 입력 이벤트를 가지기에 다이나믹한 인터렉션이 가능하다.</p>
<p>프래그먼트의 생명주기는 액티비티의 생명주기에 <strong>종속적</strong>이기에 액티비티에서 <code>onCreate()</code>가 호출되면 프래그먼트에서는 <code>onActivityCreated()</code>가 호출되고 액티비티에서 <code>onPause()</code>가 호출되면 프래그먼트도 <code>onPause()</code>가 된다.</p>
<p>프래그먼트에서 액티비티와 통신을 하려면 getActivity()를 호출하면 액티비티 객체를 사용할 수 있으며 프래그먼트에서 발생하는 이벤트는 <code>onAttach()</code>에서 _interfactionListener_를 호출하고 액티비티에서 이것을 구현함으로써 이벤트에 대한 처리와 프래그먼트간 통신이 가능하다.</p>
<p>액티비티를 관리하는 스택이 있듯이 프래그먼트에도 <strong>백스택</strong>이라는 스택 구조가 존재하며 이것은 액티비티가 관리한다. <code>FragmentTransaction</code> 객체의 addToBackStack() 함수를 사용하여 프래그먼트를 백스택에 저장하면 사용자가 뒤로가기 버튼을 눌렀을 때 프래그먼트의 이전 상태로 되돌려주는 기능을 제공할 수 있다.</p>
<img src="/img/android_compare_activity_fragment.png" width="500" height="300">
<img src="/img/android_compare_activity_fragment2.png" width="500" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/01/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%912/" target="_blank" rel="noopener">액티비티와 프래그먼트 차이</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-Is-Fragment/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Java-Type-of-Error/"
                            aria-label=": [Java] RunTime Error vs Compile Error"
                        >
                            [Java] RunTime Error vs Compile Error
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T10:58:48+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>자바를 공부하며 항상 등장하는 말은 컴파일과 런타임이다. 하지만 두 용어에 대한 개념이 확실하지 않아 이번 기회에 정리하고 넘어가겠다.</p>
                    
                        <a
                            href="/2019/01/02/Java-Type-of-Error/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] RunTime Error vs Compile Error"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/01/archives/3/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 4 of 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
