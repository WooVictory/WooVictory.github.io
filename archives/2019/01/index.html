
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives: 2019/1 - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/2019/01/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/31/Android-AAC-Room/"
                            aria-label=": 11일차 [안드로이드] AAC - Room 실습"
                        >
                            11일차 [안드로이드] AAC - Room 실습
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-31T22:32:55+09:00">
	
		    Jan 31, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>Room은 Android Architecture Components(AAC) 중 하나이다. Room에 대해서 저번에 살펴봤지만, 헷갈리고 개념이 정립되어 있지 않아 다시 정리하려고 한다. 이번에는 개념적인 부분보다는 실제로 어떻게 사용을 할 수 있는지에 초점을 맞추려고 한다.</p>
<h2 id="room의-3가지-주요-구성요소">Room의 3가지 주요 구성요소</h2>
<ul>
<li>RoomDatabase : 데이터베이스의 holder를 구성하며 관계형 데이터에 대한 연결을 해준다.</li>
<li>조건
<ol>
<li>RoomDatabase를 extends하는 클래스는 <strong>abstract</strong> 클래스이다.</li>
<li>annotaion으로 eneities(Table 구조와 mapping되는 clas)를 포함해야 한다.</li>
<li>클래스 내부에 DAO(Data Access Object)를 포함해야 한다.</li>
</ol>
</li>
<li>Entity : 데이터베이스 내의 테이블을 나타낸다.</li>
<li>Dao : 데이터베이스에 접근하는 데 사용되는 함수를 정의한다.(Query를 포함한다.)</li>
</ul>
<img src="/img/room_Database_structure.png" width="600" height="300">
<h2 id="entity">Entity</h2>
<ul>
<li>Entity는 object이자 데이터베이스의 테이블을 나타낸다.</li>
<li>Entity 파일의 특징은 class의 변수들이 column이 되어 데이터베이스의 테이블로 된다는 것이다.</li>
<li>ColumnInfo로 필드의 이름을 설정하지 않는다면 필드의 이름과 같은 Column 이름으로 생성된다.</li>
<li>이때, 실제 table로 만들고 싶지 않은 필드에는 @Ignore 어노테이션을 선언한다.</li>
</ul>
<p><strong>Annotation 속성</strong></p>
<p>@Entity(name = “word_table”)<br>
: Entity의 테이블 명을 선언한다.<br>
@PrimaryKey<br>
: 모든 Entity는 PrimaryKey가 필요하다.(값을 구별하기 위한 식별자)<br>
@ColumnInfo(name = “word”)<br>
: 테이블에서 word라는 이름으로 데이터베이스 column 사용</p>
<p><code>Entity에는 getter 함수가 필수적으로 존재해야 하고 변수들은 public 형태여야 한다.</code></p>
<p>@Embeded<br>
: 필드로 object를 갖는 경우 사용한다.</p>
<ul>
<li>Annotaion과 관련된 속성은 구글 공식 문서를 참고하거나 블로그의 다른 글을 참고하면 좋을 것 같다.</li>
<li><a href="https://woovictory.github.io/2019/01/25/Android-Room-Basic/">5일차 [안드로이드] Room</a></li>
</ul>
<h2 id="dao-만들기">DAO 만들기</h2>
<ul>
<li>DAO는 SQL 쿼리를 지정하고 메소드 호출을 연결한다.</li>
<li>쿼리는 별도의 스레드에서 동작하며 메인 스레드에서 동작하지 않는다.(UI - Thread에서는 동작하면 앱에 에러가 난다.)</li>
<li>Interface class 혹은 abstract class로 사용한다.</li>
<li>@Dao 어노테이션을 지정한다.</li>
<li>Dao에서는 데이터베이스에 있는 테이블에서 사용할 쿼리를 지정하고 메소드와 연결을 한다. 단순히 정의만 해놓는다.</li>
</ul>
<p><strong>주의</strong></p>
<p>AppDatabase object를 생성하는 코드는 비용이 많이 들기 때문에 <strong>Singleton</strong>으로 구현해야 한다.</p>
<h2 id="room-database-만들기">Room Database 만들기</h2>
<ul>
<li>Room Database는 SQLite 데이터베이스 상위에 있는 데이터베이스 계층을 말한다.</li>
<li>Room은 DAO를 이용하여 데이터베이스의 쿼리를 실행한다.</li>
<li>기본적으로 UI 성능 저하를 피하기 위해서 Room에서는 main thread에서 쿼리를 실행할 수 없다.</li>
<li><strong>LiveData</strong>는 필요할 때 백그라운드 스레드에서 쿼리를 비동기적으로 자동 실행하여 규칙을 적용한다.</li>
<li>Room 클래스는 abstract 여야 하며, RoomDatabase를 상속받아야 한다.</li>
<li>일반적으로 RoomDatabase 객체를 생성하는 코드는 비용이 많이 들기 때문에 싱글톤으로 구현해 하나의 객체만 유지한다.</li>
</ul>
<p><strong>어노테이션</strong><br>
@Database(entities = {Word.class}, version = 1)<br>
: Room Database를 정의한다. entities는 데이터베이스에 사용될 Entity를 나타낸다. version는 추후 데이터베이스의 변경 사항이 있을 시 변경해야 할 사항이다.</p>
<h2 id="repository-만들기">Repository 만들기</h2>
<ul>
<li>Repository는 여러 데이터에 대한 접근을 할 수 있는 class이다.</li>
<li>주로 로컬 데이터(앱 내장 데이터)를 가져올 지 네트워크에서 데이터를 가져올 지를 다룬다.</li>
</ul>
<img src="/img/android_room_repository.png" width="600" height="300">
<ul>
<li>Dao의 멤버 변수와 word를 넣을 list 변수를 만들어 준다.</li>
<li>AsyncTask를 만들어서 Database에 insert 하는 작업을 수행한다.</li>
<li>이유는? UI - Thread에서 수행할 경우 오류가 발생한다.</li>
</ul>
<h2 id="viewmodel">ViewModel?</h2>
<p>내가 참고한 예제에서는 <strong>ViewModel</strong>을 사용하였다. 하지만, ViewModel에 대한 이해가 잘 되지 않아서 사용하지 않고 예제를 조금 다른 방식으로 수정하였다. 그래도 일단, ViewModel이 무엇인지 간단하게 살펴보자.</p>
<ul>
<li>ViewModel의 역할은 UI에 데이터를 제공하고 변경된 사항들을 업데이트 해준다.</li>
<li>그리고 ViewModel 저장소(Repository)와 UI(Fragment / Activity) 사이에 통신 역할을 한다.</li>
<li>이것은 <strong>저장소와 UI를 분리</strong>하여 각자의 역할을 명확하게 할 수 있다.</li>
</ul>
<p><strong>주의</strong></p>
<ol>
<li>
<p>ViewModel에 context를 저장하면 안된다.<br>
-&gt; 이유는 디바이스가 회전할 때 Activity가 제거되었다가 다시 생성되는데 이때, ViewModel은 제거된 것을 참조하기 때문에 <strong>메모리 누수</strong>가 발생한다. 그래서 application을 사용하기 위해 extends로 AndroidViewModel을 사용한다.</p>
</li>
<li>
<p>ViewModel은 프로세스 종료 후 남아있지 않기 때문에 onSaveInstanceState() 함수를 대체하지 않는다.</p>
</li>
</ol>
<h2 id="livedata">LiveData??</h2>
<p>LiveData는 중요한 개념 중 하나이다. 여기서는 간단하게 Room에서 어떻게 사용되는지만 보고 추후에 공부할 예정이다.</p>
<ul>
<li><code>observer</code>라는 것을 만들어 실제 변경이 일어나면 UI에 적용한다.</li>
<li>ViewModel에서 데이터베이스 호출 없이 코드를 쉽게 테스트할 수 있다.</li>
</ul>
<p>예제는 Github에 있으니 확인할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view/#16" target="_blank" rel="noopener">Android Room with a View - Java</a></li>
<li><a href="https://m.blog.naver.com/rjs5730/221302132817" target="_blank" rel="noopener">(Android) Room Persistence Library 실습 -2</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/31/Android-AAC-Room/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/30/DatabaseBasic/"
                            aria-label=": 10일차 [데이터베이스] 데이터베이스 기초 "
                        >
                            10일차 [데이터베이스] 데이터베이스 기초 
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-30T11:08:34+09:00">
	
		    Jan 30, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/데이터베이스/">데이터베이스</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>안드로이드에서 Room을 이용하면 내부 DB를 사용할 수 있고, 간단한 쿼리문도 사용할 수 있다. 여기까지는 문제가 없는데, 내가 서버, DB 용어와 개념을 몰라서 이해가 잘 안간다. 그래서 간단하게 찾아서 공부하기 위해 작성된 글이다.</p>
<h2 id="데이터베이스란">데이터베이스란??</h2>
<ul>
<li><strong>여러 사람에 의해 공유되어 사용될 목적으로 통합하여 관리되는 데이터의 집합을 말한다.</strong> 자료 항목의 중복을 없애고 자료를 구조화하여 저장함으로써 자료 검색과 갱신의 효율을 높인다.</li>
<li>논리적으로 연관된 하나 이상의 자료의 모음으로 그 내용을 고도로 구조화함으로써 검색과 갱신의 효율화를 꾀한 것이다.</li>
<li>몇 개의 자료 파일을 조직적으로 통합하여 자료 항목의 중복을 없애고 자료를 구조화하여 기억시켜 놓은 자료의 집합체라고 할 수 있다.</li>
</ul>
<p><strong>왜 사용하는가?</strong></p>
<p><strong>데이터베이스란 다수의 사용자가 사용하는 데이터들의 공유와 운영을 위해 저장해 놓는 공간을 말한다.</strong> 프로그램을 만들다 보면 프로그램 사용자들에 의해 생성된 데이터, 프로그래머가 필요에 의해 프로그램에 넣어 놓은 데이터 등 필연적으로 많은 데이터들이 생성되어지게 된다. 여기서 데이터베이스를 사용하지 않으면 이 데이터들은 프로그램을 종료하는 순간 전부 날아가게 되는 불행한 상황을 맞이하게 된다.</p>
<p>따라서, 이런 현상을 방지하기 위해 데이터들을 데이터베이스에 넣고 보관하는 방법을 사용하는 것이다.</p>
<h2 id="기초-용어">기초 용어</h2>
<ul>
<li>엔티티(Entity) : <strong>사람, 장소, 사물, 사건 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 실세계의 객체이다.</strong> 예를 들어, 사원 번호가 1206이고 김창섭인 사원, 과목 코드가 CS372인 운영체제 등이 있다. 이렇게 실체가 있는 것 뿐만 아니라 추상적인 것도 있다. 프로젝트 번호가 P101인 프로젝트, 학과 번호가 D316인 학과는 추상적인 개념의 엔티티가 될 수 있다.</li>
<li>스키마(Schema) : 데이터를 설명하는 데이터. 메타데이터(Metadata)라고도 한다. 예를 들어 <code>홍길동, 1994-06-27</code>이라는 데이터가 있을 경우에는 이를 <code>이름, 생년원일</code>이라는 스키마로 설명할 수 있다.</li>
</ul>
<h2 id="database-용어">Database 용어</h2>
<img src="/img/database_basic.png" width="600" height="300">
<ul>
<li>Table(Relation) : 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위를 말한다. 예로 부서에 관한 정보를 저장하는 부서 Relation(혹은 부서 Table)이 있다. 한 릴레이션은 데이터베이스에 표현되는 한 엔티티에 관한 정보를 저장하는 데 사용된다.</li>
<li>식별자(identifier) : 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각을 구분할 수 있는 논리적인 개념이다.</li>
<li>식별자의 특징
<ul>
<li>유일성 : 하나의 릴레이션에서 모든 행은 서로 다른 키 값을 가져야 한다.</li>
<li>최소성 : 꼭 필요한 최소한의 속성들로만 키를 구성해야 한다.</li>
</ul>
</li>
<li>튜블(Tuple) : 테이블에서 행을 의미한다. 같은 말로 레코드(Record) 혹은 로우(Row)라고 하기도 한다. 튜플은 릴레이션에서 같은 값을 가질 수 없다.
<ul>
<li>카디날리티(Cardinality) : 튜플의 수</li>
</ul>
</li>
<li>어트리뷰트(Attribute) : 테이블에서 열을 의미한다. 같은 말로 칼럼(Column)이라고도 한다.
<ul>
<li>디그리(Degree) : 어트리뷰트의 수를 의미한다.</li>
</ul>
</li>
<li>도메인(Domain) : Relation에서 각각의 속성(Attribute)들이 취할 수 있는 같은 타입의 원자 값들의 집합이다.</li>
</ul>
<h2 id="key">Key</h2>
<ul>
<li>키(Key) : 한 Relation에서 각각의 Tuple(행)을 유일하게 식별하기 위해 사용하는 하나 혹은 그 이상의 속성들(Attribute)의 집합이다.</li>
</ul>
<p><strong>유일성과 최소성</strong></p>
<ul>
<li>유일성 : 하나의 키로 어떠한 행을 바로 찾아낼 수 있는 성질. ex) 주민등록번호</li>
<li>최소성 : 레코드(튜플)을 식별하는데 꼭 필요한 속성들로만 구성되어 있는 성질. ex) {주민등록번호+학번}은 최소성을 만족시키지 않는다. 주민등록번호로만 tuple(행)을 구분할 수 있기 때문이다.</li>
</ul>
<img src="/img/student_relation.png" width="800" height="300">
<img src="/img/sukang_relation.png" width="800" height="300">
<ol>
<li>후보키(Cadidate Key)</li>
</ol>
<ul>
<li>릴레이션을 구성하는 속성들 중에서 튜블을 <strong>유일하게 식별할 수 있는 속성들의 부분집합을 의미한다.</strong></li>
<li>모든 릴레이션은 반드시 하나 이상의 후보키를 가져야한다.</li>
<li>릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다.</li>
</ul>
<p>ex) &lt;학생&gt; 릴레이션에서 '학번’이나 '주민번호’는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키가 될 수 있다. 즉, 기본키가 될 수 있는 키들을 후보키라고 한다.</p>
<ol start="2">
<li>기본키(Primary Key)</li>
</ol>
<ul>
<li>후보키 중에서 선택한 주키(Main key)</li>
<li>한 릴레이션에서 <strong>특정 튜플을 유일하게 구별할 수 있는 속성</strong></li>
<li><strong>Null 값을 가질 수 없다.</strong>(개체 무결성의 첫 번째 조건)</li>
<li>기본 키로 정의된 속성에는 <strong>동일한 값이 중복되어 저장될 수 없다.</strong>(개체 무결성의 두 번째 조건)</li>
</ul>
<p>ex) &lt;학생&gt; 릴레이션에서는 '학번’이나 '주민번호’기 기본키가 될 수 있고, &lt;수강&gt; 릴레이션에서는 ‘학번’+'과목명’으로 조합해야 기본키가 만들어 질 수 있다. 왜냐하면 &lt;수강&gt; 릴렝션에서는 ‘학번’ 속성과 ‘과목명’ 속성은 개별적으로 기본키로 사용할 수 없다. 다른 튜플들과 구별되지 않기 때문이다.</p>
<p>1004 학번을 가진 학생이 영어와 전산 과목을 수강하고 있다고 하면 학번만으로는 특정 튜플을 유일하게 구별할 수 없다. 그리고 영어 과목을 수강하는 학생들은 한명이 아니라 여러 명이 될 수 있기 때문에 유일하게 구별할 수 없다.</p>
<ol start="3">
<li>대체키(Alternate Key)</li>
</ol>
<ul>
<li><strong>후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말한다.</strong></li>
<li>보조키라고도 한다.</li>
</ul>
<p>ex) &lt;학생&gt; 릴레이션에서 '학번’을 기본키로 정의하면 '주민번호’는 대체키가 된다.</p>
<ol start="4">
<li>슈퍼키(Super Key)</li>
</ol>
<ul>
<li><strong>슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키</strong>로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타내지 않는다.</li>
<li>릴레이션을 구성하는 모든 튜플에 대해 <strong>유일성은 만족하지만, 최소성은 만족시키지 못한다.</strong></li>
</ul>
<p>ex) &lt;학생&gt; 릴레이션에서는 ‘학번’, ‘주민번호’, ‘학번’+‘주민번호’+‘성명’ 등으로 슈퍼키를 구성할 수 있다. 또한, 여기서 최소성을 만족시키지 못한다는 말은 ‘학번’+‘주민번호’+'성명’가 슈퍼키인 경우 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, ‘성명’ 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못한다.</p>
<p>즉, 뭉쳤을 경우 유일성이 생기고, 흩어지면 몇몇 속성들은 독단적으로 유일성 있는 키로 사용할 수 없다. 이것을 최소성을 만족하지 못한다고 한다.</p>
<ol start="5">
<li>외래키(Foreign Key)</li>
</ol>
<ul>
<li>관계(Relation)를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성이다.</li>
<li>외래키는 <strong>참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구</strong>로 사용된다.</li>
<li><strong>외래키로 지정되면 참조하는 테이블의 기본키에 없는 값은 입력할 수 없다.</strong>(참조 무결성 조건)</li>
</ul>
<p>ex) &lt;수강&gt; 릴레이션이 &lt;학생&gt; 릴레이션을 참조하고 있으므로 &lt;학생&gt; 릴레이션의 '학번’은 기본키이고, &lt;수강&gt; 릴레이션의 '학번’은 외래키이다.<br>
즉, 각 릴레이션의 입장에서 속성은 기본키가 되기도 하고, 외래키가 되기도 한다.</p>
<p>ex) &lt;수강&gt; 릴레이션의 '학번’에는 &lt;학생&gt; 릴레이션의 '학번’에 없는 값은 입력할 수 없다.</p>
<h2 id="쿼리-문법의-세-종류와-각-문법">쿼리 문법의 세 종류와 각 문법</h2>
<p><strong>SQL</strong>(Structured Query Language)</p>
<ul>
<li>관계형 데이터베이스에서 사용하는 표준 질이 언어를 말한다.</li>
<li>사용 방법이나 문법이 다른 언어(Java, C, C#)보다 단순하다.</li>
<li>모든 DBMS에서 사용 가능하다.</li>
<li>인터프리터 언어</li>
<li>대소문자를 구별하지 않는다.</li>
</ul>
<ol>
<li>데이터 정의 언어(DDL)</li>
</ol>
<ul>
<li>데이터베이스 검색, 등록, 삭제, 갱신을 하기 위해 사용하는 데이터베이스 언어</li>
<li>데이터베이스의 검색 및 업데이트 등 데이터 조작을 위해 사용</li>
<li>데이터베이스의 스키마를 정의, 생성, 수정하는 기능</li>
<li>테이블 생성, 컬럼 추가, 타입 변경, 각종 제약조건 지정, 수정 등</li>
</ul>
<table>
<thead>
<tr>
<th>SQL문</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create</code></td>
<td>데이터베이스 객체를 생성</td>
</tr>
<tr>
<td><code>drop</code></td>
<td>데이터베이스 객체를 삭제</td>
</tr>
<tr>
<td><code>alter</code></td>
<td>기존에 존재하는 데이터베이스 객체를 다시 정의</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>데이터 조작 언어(DML)</li>
</ol>
<ul>
<li>관계형 데이터베이스의 구조를 정의한다.</li>
<li>쌍, 속성, 관계 인덱스 파일 위치 등 데이터베이스 고유의 특성을 포함한다.</li>
<li>데이터베이스의 테이블에 있는 내용을 직접 조작하는 기능</li>
<li>테이블의 레코드(튜플)을 CRUD(Create, Retrieve, Update, Delete)</li>
</ul>
<table>
<thead>
<tr>
<th>SQL문</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert</code></td>
<td>데이터베이스 객체에 데이터를 입력</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>데이터베이스 객체에 데이터를 삭제</td>
</tr>
<tr>
<td><code>update</code></td>
<td>데이터베이스 객체 안의 데이터 수정</td>
</tr>
<tr>
<td><code>select</code></td>
<td>데이터베이스 객체 안의 데이터 조회</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>데이터 제어 언어(DCL)</li>
</ol>
<ul>
<li>데이터베이스에서 데이터에 대한 액세스를 제어하기 위한 데이터베이스 언어 또는 데이터베이스 언어 요소</li>
<li>박탈, 연결, 권한 부여, 질의, 자료 삽입, 갱신, 삭제 등</li>
<li>데이터베이스의 테이블에 접근 권한이나 CRUD 권한을 정의하는 기능</li>
<li>특정 사용자에게 테이블의 조회권한 허가 / 금지 등</li>
</ul>
<table>
<thead>
<tr>
<th>SQL문</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>grant</code></td>
<td>데이터베이스 객체에 권한을 부여</td>
</tr>
<tr>
<td><code>revoke</code></td>
<td>이미 부여된 데이터베이스 객체 권한을 취소</td>
</tr>
</tbody>
</table>
<h2 id="crud">CRUD</h2>
<p>CRUD(Create, Retrieve, Update, Delete)</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>조작</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create</code></td>
<td>생성</td>
<td>insert</td>
</tr>
<tr>
<td><code>read(retrieve)</code></td>
<td>읽기(인출)</td>
<td>select</td>
</tr>
<tr>
<td><code>update</code></td>
<td>갱신</td>
<td>update</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>삭제</td>
<td>delete</td>
</tr>
</tbody>
</table>
<ul>
<li>Create : 데이터베이스 객체 생성
<ul>
<li>insert into</li>
<li>새로운 레코드를 추가</li>
</ul>
</li>
<li>Update : 데이터베이스 객체 안의 데이터를 수정
<ul>
<li>update</li>
<li>특정 조건의 레코드의 컬럼 값을 수정</li>
</ul>
</li>
<li>Delete : 데이터베이스 객체의 데이터 삭제
<ul>
<li>delete</li>
<li>특정 조건의 레코드를 삭제</li>
</ul>
</li>
<li>Retrieve : 데이터베이스 객체 안의 데이터 검색
<ul>
<li>select</li>
<li>조건을 만족하는 레코드를 찾아 특정 컬럼 값을 표시(모두 표시 : *)</li>
</ul>
</li>
</ul>
<h2 id="예제">예제</h2>
<p><strong>1.select 명령문</strong><br>
SELECT 컬럼명 FROM 테이블명 WHERE 조건절;</p>
<p>ex)</p>
<ul>
<li>
<p>Q : 국가 코드가 'KOR’으로 되어 있는 도시의 이름을 구하시오.</p>
</li>
<li>
<p>A : SELECT Name FROM City WHERE CountryCode=‘KOR’;</p>
</li>
<li>
<p>Q : 인구가 500만 이상인 도시들의 이름을 구하시오</p>
</li>
<li>
<p>A : SELECT Name FROM City WHERE Population &gt; 5000000;</p>
</li>
</ul>
<p><strong>2. insert into 명령문</strong><br>
INSERT INTO 테이블명(컬럼명) VALUES(값);</p>
<p>ex)</p>
<p><code>주의</code> : 각각의 필드와 대응 시켜줘서 insert를 시켜주어야 한다.</p>
<p>INSERT INTO City (ID, Name, CountryCode, District, Population) values (10000, “Sample”, “KOR”, “Seoul”, 1000000);</p>
<p><code>주의</code> : 아래의 경우에는 모든 컬럼 값들이 일일히 필드와 대응되면 생략이 가능하다.</p>
<p>INSERT INTO City values(20000, &quot;SampleTest<br>
, “KOR”, “Busan”, 2000000);</p>
<p>결과 확인</p>
<p>// ID가 20000인 레코드 출력<br>
SELECT * FROM City WHERE ID = 20000;<br>
// ID가 20000인 레코드 출력<br>
SELECT * FROM City WHERE ID = 10000;</p>
<p><strong>3. update 명령문</strong><br>
UPDATE 테이블명 SET 컬럼명=값, … WHERE 조건절;</p>
<p>ex)</p>
<p>// ID가 10000인 레코드의 name을 &quot;SampleUSA&quot;로 변경<br>
UPDATE City SET Name = “SampleUSA” WHERE ID = 10000;</p>
<p>결과 확인<br>
// ID가 10000인 레코드 출력<br>
SELECT * FROM City WHERE ID = 10000;</p>
<p><strong>4. delete 명령문</strong><br>
DELETE FROM 테이블명 WHERE 조건절;</p>
<p>ex)</p>
<p>// ID가 20000이며 Population이 2000000인 레코드를 삭제<br>
DELETE FROM City WHERE (ID = 20000) AND (Population = 2000000);</p>
<p>// ID가 10000이며 Population이 1000000인 레코드를 삭제<br>
DELETE FROM City WHERE (ID = 10000) AND (Population = 1000000);</p>
<p>결과 확인</p>
<p>// ID가 10000인 레코드 출력<br>
SELECT * FROM City WHERE ID = 10000;<br>
// ID가 20000인 레코드 출력<br>
SELECT * FROM City WHERE ID = 20000;</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://limkydev.tistory.com/108" target="_blank" rel="noopener">[DataBase] 키(Key)의 개념 및 종류</a></li>
<li><a href="https://wkdtjsgur100.github.io/database-terms/" target="_blank" rel="noopener">데이터베이스 용어 및 기초 개념 정리(DBMS, Key관련 용어, 테이블 관련 용어 등)</a></li>
<li><a href="https://coding-factory.tistory.com/77" target="_blank" rel="noopener">[DB기초] DataBase 개념 및 용어 설명</a></li>
<li><a href="https://hojak99.tistory.com/327" target="_blank" rel="noopener">[DB] SQL 기초</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/30/DatabaseBasic/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/30/Android-What-is-ConstraintLayout/"
                            aria-label=": 9일차 [안드로이드] ConstraintLayout"
                        >
                            9일차 [안드로이드] ConstraintLayout
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-30T01:05:45+09:00">
	
		    Jan 30, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/30/Android-What-is-ConstraintLayout/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/29/Android-MpAndroidChart/"
                            aria-label=": 8일차 [안드로이드] MpAndroidChart"
                        >
                            8일차 [안드로이드] MpAndroidChart
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-29T15:57:06+09:00">
	
		    Jan 29, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>MpAndroidChart는 그래프 라이브러리 중 하나이다. 가장 널리 알려져 있고, Github의 star가 가장 많은 그래프 라이브러리이다. 라이브러리를 선택할 때 중요하게 생각해야 할 점 중의 하나로는 <code>star</code>가 많은 것을 선택하라고 한다. 그 이유는 star가 많은 것은 그만큼 오픈 소스 라이브러리 활동이 활발하여 오류에 대한 수정이나 기능 추가 같은 활동들이 활발하기 때문이라고 한다. 그래서 나는 안드로이드에서 그래프를 그리기 위해 <strong>MpAndroidChart</strong> 라이브러리를 사용했다.</p>
<h2 id="종류">종류</h2>
<p>종류는 Github에서도 확인할 수 있듯이 엄청 다양하다. 그 중에서 나는 <strong>LineChart</strong>를 이용해서 원하는 데이터를 표현하려고 했다. 한국말로는 꺾은선 그래프라고도 하며, 이를 이용해서 데이터를 간단하게 표시할 수 있다.</p>
<p>LineaChart 말고도 다양한 그래프들이 존재한다. 예를 들면, BarChart, PieChart 등등이 있다.</p>
<h2 id="삽질-후기">삽질 후기</h2>
<p>그렇다면 내가 원하는 데이터를 그래프에 표시하기 위해서 삽질했던 후기를 정리하고자 한다.</p>
<p>##1. 데이터 생성**</p>
<p>그래프에서 표현하고자 하는 데이터를 생성해야 한다. 데이터는 <strong>Entry</strong>라고 하는 라이브러리에서 제공하는 타입으로 만들면 된다. 기본적으로 x, y의 Float(실수)형 데이터를 넣어서 만들 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Entry&gt; entires = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">entries.add(<span class="keyword">new</span> Entry(<span class="number">0</span>,<span class="number">1f</span>));</span><br><span class="line">entries.add(<span class="keyword">new</span> Entry(<span class="number">1</span>,<span class="number">2f</span>));</span><br><span class="line">entries.add(<span class="keyword">new</span> Entry(<span class="number">2</span>,<span class="number">3f</span>));</span><br><span class="line">entries.add(<span class="keyword">new</span> Entry(<span class="number">3</span>,<span class="number">4f</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>entries를 이용해 LineDataSet을 생성한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LineDataSet lineDataSet = <span class="keyword">new</span> LineDataSet(entries, <span class="string">"Emotion"</span>);</span><br><span class="line"><span class="comment">// entries와 지정할 label을 생성자에 넘겨준다.</span></span><br><span class="line"></span><br><span class="line">lineDataSet.setLineWidth(<span class="number">2</span>); <span class="comment">// 선 굵기</span></span><br><span class="line">lineDataSet.setCircleRadius(<span class="number">6</span>); <span class="comment">// 곡률</span></span><br><span class="line">lineDataSet.setCircleColor(ContextCompat.getColor(mContext, R.color.graphColor)); <span class="comment">// LineChart에서 Line Circle Color 설정</span></span><br><span class="line">lineDataSet.setCircleHoleColor(ContextCompat.getColor(mContext, R.color.graphColor)); <span class="comment">// LineChart에서 Line Hole Circle Color 설정</span></span><br><span class="line">lineDataSet.setColor(ContextCompat.getColor(mContext, R.color.graphColor)); <span class="comment">// LineChart에서 Line Color 설정</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 그리고 기타 설정 등도 할 수 있다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LineDataSet을 담는 LineData를 만들어준다. 여러 개의 라인 데이터가 들어갈 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LineData lineData = <span class="keyword">new</span> LineData(lineDataSet);</span><br><span class="line"><span class="comment">// 라인 데이터의 텍스트 컬러 / 사이즈를 설정할 수 있다.</span></span><br><span class="line"><span class="comment">// 물론 나는 사용하지 않았다.</span></span><br><span class="line">lineData.setValueTextColor(ContextCompat.getColor(getContext(), R.color.black));</span><br><span class="line">lineData.setValueTextSize(<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>또한, 추가적으로 x축, y축에 대한 label과 텍스트, 갯수 등을 설정할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x축 설정</span></span><br><span class="line">view.setLineData(lineData);</span><br><span class="line">xAxis = view.getXAxis(); <span class="comment">// x축에 대한 정보를 View로부터 받아온다.</span></span><br><span class="line">xAxis.setPosition(XAxis.XAxisPosition.BOTTOM); <span class="comment">// x축 표시에 대한 위치 설정으로 아래쪽에 위치시킨다.</span></span><br><span class="line">xAxis.setTextColor(R.color.black); <span class="comment">// x축 텍스트 컬러 설정</span></span><br></pre></td></tr></table></figure>
<ul>
<li>y축에 대한 설정은 왼쪽과 오른쪽 따로 제공하고 있기 때문에 각각 가져와서 사용하지 않는 방향은 비활성화 하는 것이 좋다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// y축 설정</span></span><br><span class="line"></span><br><span class="line">yLAxis = view.getYLeftAxis(); <span class="comment">// y축 왼쪽 데이터 가져오기.</span></span><br><span class="line">yLAxis.setTextColor(R.color.black); <span class="comment">// y축 텍스트 컬러 설정</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// y축 오른쪽 비활성화</span></span><br><span class="line">yRAxis = view.getYRightAxis();</span><br><span class="line">yRAxis.setDrawLabels(<span class="keyword">false</span>);</span><br><span class="line">yRAxis.setDrawAxisLine(<span class="keyword">false</span>);</span><br><span class="line">yRAxis.setDrawGridLines(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>위에는 기본적인 설정과 같다. 그리고 구글에 검색하면 쉽게 찾아볼 수 있는 글이다. 이제 x축과 y축을 사용하고 싶은 데이터로 custom하게 사용하는 방법을 정리하려고 한다.</li>
<li>먼저, x축에 내가 원하는 요일들을 설정하기 위해서 아래와 같은 클래스를 만들어준다. IAxisValueFormatter 인터페이스를 구현한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphAxisValueFormatter</span> <span class="keyword">implements</span> <span class="title">IAxisValueFormatter</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mValues;</span><br><span class="line">    <span class="comment">// 생성자 초기화</span></span><br><span class="line">    GraphAxisValueFormatter(String[] values)&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFormattedValue</span><span class="params">(<span class="keyword">float</span> value, AxisBase axis)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mValues[(<span class="keyword">int</span>) value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위와 같은 클래스를 만든다. 그리고 아래와 같이 custom 클래스를 지정하여줌으로써 x축의 데이터를 재가공한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xAxis.setValueFormatter(<span class="keyword">new</span> GraphAxisValueFormatter(mDays));</span><br><span class="line"><span class="comment">// mDays는 요일을 가지고 있는 String 배열</span></span><br></pre></td></tr></table></figure>
<ul>
<li>그렇다면 y축의 데이터를 재가공하기 위해서는 어떻게 하면될까?? 방법은 x축과 똑같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphYAxisValueFormatter</span> <span class="keyword">implements</span> <span class="title">IAxisValueFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] mEmojis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자 초기화</span></span><br><span class="line">    GraphYAxisValueFormatter(String[] values) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mEmojis = values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFormattedValue</span><span class="params">(<span class="keyword">float</span> value, AxisBase axis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mEmojis[(<span class="keyword">int</span>) value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>y축의 데이터를 재가공하기 위해서 custom하게 만든 클래스를 지정하면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yLAxis.setValueFormatter(<span class="keyword">new</span> GraphYAxisValueFormatter(mEmojis));</span><br><span class="line"><span class="comment">// mEmojis는 이모지를 가지고 있는 배열</span></span><br></pre></td></tr></table></figure>
<p><strong>2. y축 데이터 재가공</strong></p>
<ol>
<li>
<p>y축에 icon 삽입<br>
y축의 데이터를 재가공 하기 위해서 일단 y축의 이미지를 넣어야 한다는 생각으로 접근을 했다. 그래서 구글링을 통해서 MpAndroidChart에 이미지 혹은 icon을 삽입한 그래프를 찾아보았다. 일단, LineChart는 찾아볼 수 없었고, BarChart, PieChart에서는 손가락 안에 꼽을 수 있을 정도로 발견할 수 있었다.</p>
</li>
<li>
<p>라이브러리 커스텀<br>
그래서 라이브러리를 파헤쳐서 커스텀을 해보자는 마음을 먹었다. (어리석은 생각이었다.) 그래서 BarChart를 통해 이미지를 넣은 것을 보고 이를 토대로 LineChart를 커스텀하기로 마음을 먹었지만, LineChart에서는 이미지를 그릴 수 있는 메소드를 찾지 못했다.</p>
</li>
<li>
<p>y축 데이터에 이모지에 대한 유니코드 삽입<br>
두 개의 방법이 실패하고 제일 처음 생각했지만, 위에서 언급하지 않았던 방법인 이모지에 대한 유니코드 값을 넣어서 간단하게 구현해보는 방법이다. 처음에 이모지에 대한 유니코드를 넣어서 확인해보았는데, 적용이 되지 않아서 실패라고 생각을 했었다. 하지만, 갓자이너 여자친구의 도움으로 다른 사이트를 알았다.</p>
</li>
</ol>
<p>이 사이트에서 이모지에 대한 유니코드 값을 얻어서 그래프의 y축에 데이터를 재가공하였더니 이모지가 정상적으로 들어가는 것을 확인할 수 있었다. :)</p>
<p><strong>3. 중복과 간격 문제</strong></p>
<p>위의 2번까지의 과정을 해결하고 나니 내가 원하는 데이터로 재가공하여 그래프를 표현할 수 있게 되었다. 하지만, y축의 이모지 데이터가 중복해서 나오는 현상을 마주하게 되었다…</p>
<p>이 문제는 도대체 왜 그러는 것일까라는 의문을 가지고 구글링을 하고 커스텀을 위한 Class에서 return 하기 전에 로그 값을 찍는데 value가 float이라서 <strong>int</strong>로 캐스팅하는 과정에서 값이 손실되어서 같은 인덱스가 여러 번 참조되어 중복되는 것이라고 판단을 하게 되었다.</p>
<p>그래서 이를 해결할 수 있는 방법이 무엇이 있을까 생각해보고 이 라이브러이의 <code>issue</code> 탭에서 실마리를 찾아보고자 했다. 아니나 다를까 비슷한 문제를 직면한 사람을 찾을 수 있었다. 또한, 이에 대한 답변도 존재했다.</p>
<p>답변은 다음과 같았다. y축의 Max / Min 값을 지정하고 증가 간격(세분성) 설정을 true로 지정하고 세분 간격을 1.0f로 설정해주었다. 그리고 빌드를 해보니 내가 원하는 것처럼 이모지가 하나씩 증가하면서 나타나는 것을 확인할 수 있었다.</p>
<h2 id="느낀점">느낀점</h2>
<p>외부 라이브러리를 사용할 때는 정말로 star가 많은 것을 사용하자. 분명 내가 직면한 문제를 먼저 경험한 개발자들이 있을 것이다. issue 탭에서 문제와 답을 찾을 수 있으니 포기는 휴지통에 버리자.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href=""></a></li>
<li><a href=""></a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/29/Android-MpAndroidChart/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/26/Java-Singleton-Pattern/"
                            aria-label=": [Java] Singleton"
                        >
                            [Java] Singleton
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-26T12:52:38+09:00">
	
		    Jan 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>싱글톤 패턴을 사용함에 있어서 효율적인 holder에 의한 방식을 사용해서 구현했는데, 이 방법이 나오기까지 전의 방법들을 까먹어서 설명하기 힘들었다. 그래서 다시 상기하고자 간단하게 정리를 하려고 한다.</p>
                    
                        <a
                            href="/2019/01/26/Java-Singleton-Pattern/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] Singleton"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/25/Android-Room-Basic/"
                            aria-label=": 5일차 [안드로이드] Room"
                        >
                            5일차 [안드로이드] Room
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-25T16:08:11+09:00">
	
		    Jan 25, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>[2020.02.11 기준으로 수정과 동시에 내용을 추가하고 있습니다.]<br>
[2020.03.27 기준으로 글을 새롭게 작성하고 있습니다. 따라서 새로 작성되는 포스팅이 완료되면 해당 포스팅은 삭제될 예정입니다.]<br>
작성중인 글 : <a href="https://woovictory.github.io/2020/03/27/Android-Room-Concept/">Room 개념편</a><br>
[2020.04.25 기준 홍보 내용 추가]<br>
현재 신입 개발자를 위한 Repository를 운영하고 있습니다. <a href="https://github.com/WooVictory/Ready-For-Tech-Interview" target="_blank" rel="noopener">💻 신입 개발자로서 준비를 하기 위해 지식을 정리하는 공간 👨‍💻</a>이며, 운영체제, 자바, 네트워크, 데이터베이스 등의 내용이 정리되어 있습니다. 계속해서 꾸준히 추가 중이니 한번씩 들러서 봐주시면 감사하겠습니다. 또한, 도움이 된다면 Star를 꾹~ 눌러주시면 저에게 큰 힘이 됩니다 :)</p>
<p>Android Architecture Component 중 하나인 Room에 대해 알아보려고 한다.</p>
<h3 id="orm">[ORM]</h3>
<p>Room을 알아보기 전에 ORM이 무엇인지 살펴보자. ORM이란 Object Relational Mapping으로 데이터베이스와 객체 지향 프로그래밍 언어간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법으로 <strong>DB 테이블과 매핑되는 객체를 만들고 그 객체에서 DB를 관리하는 것이다.</strong></p>
<h3 id="room">[Room]</h3>
<p>Room은 SQLite의 기능을 최대한 활용하는 동시에 데이터베이스를 원활하게 접근할 수 있도록 SQLite 위에 추상화 계층을 제공 라이브러리라고 생각하면 된다.</p>
<ul>
<li>적은 양의 정형화된 데이터를 처리하는 애플리케이션은 로컬에서 해당 데이터를 유지함으로써 큰 이점을 얻을 수 있다.
<ul>
<li>ex) 관련 데이터를 캐시하는 것</li>
</ul>
</li>
<li>이렇게 하면 장치가 네트워크에 액세스할 수 없는 경우에도 사용자가 오프라인 상태일 때 해당 콘텐츠를 계속 탐색할 수 있다. 이후에 장치가 다시 온라인 상태가 되면 사용자가 시작한 모든 콘텐츠 변경 내용이 서버에 동기화된다.</li>
</ul>
<h3 id="사용해보기">[사용해보기]</h3>
<ol>
<li>gradle에 의존성을 추가한다.</li>
</ol>
<ul>
<li><strong>먼저, build.gradle 파일의 dependencies에 추가해준다.그래야지 Room을 사용할 수 있다.</strong></li>
<li>roomVersion은 사용하는 시점에 맞는 버전을 사용하면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//room</span></span><br><span class="line">implementation <span class="string">"android.arch.persistence.room:runtime:$roomVersion"</span></span><br><span class="line">kapt <span class="string">"android.arch.persistence.room:compiler:$roomVersion"</span></span><br></pre></td></tr></table></figure>
<h3 id="3가지-주요-컴포넌트">[3가지 주요 컴포넌트]</h3>
<p>Room은 엔티티(Entity), 데이터 접근 객체(Data Access Object), 룸 데이터 베이스(Room Database) 이렇게 총 3가지 구성요소로 나뉜다.</p>
<ol>
<li><strong>Database</strong></li>
</ol>
<ul>
<li>데이터베이스 홀더를 포함하고 앱의 지속적이고 관계가 있는 데이터에 대한 기본 연결을 위한 기본 액세스 지점 역할을 한다.</li>
<li><code>@Database</code>로 어노테이션된 클래스는 다음의 조건을 만족해야 한다.
<ul>
<li><strong>RoomDatabase</strong>를 상속받는 클래스는 추상 클래스이어야 한다.</li>
<li>어노테이션 내에 데이터베이스와 연관된 (즉, 데이터베이스에 들어갈 테이블) 엔티티의 목록을 포함한다.</li>
<li>파라미터가 0개인 추상 메소드를 포함하고 @Dao로 어노테이션된 클래스를 반환한다.</li>
</ul>
</li>
<li>런타임에 <code>Room.databaseBuilder() 또는 Room.inMemoryDatabaseBuilder()</code>를 호출하여 데이터베이스 인스턴스를 얻을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User and Book are classes annotated with @Entity.</span></span><br><span class="line"><span class="meta">@Database</span>(version = <span class="number">1</span>, entities = &#123;User.class, Book.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> class AppDatabase extends <span class="title">RoomDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// BookDao is a class annotated with @Dao. </span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> BookDao <span class="title">bookDao</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// UserDao is a class annotated with @Dao. </span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// UserBookDao is a class annotated with @Dao. </span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> UserBookDao <span class="title">userBookDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>데이터베이스에서 쿼리를 직접 실행하는 대신 Dao 클래스를 만드는 것이 좋다. Dao 클래스를 사용하면 보다 논리적인 계층에서 데이터베이스 통신을 추상화할 수 있다. 이 계층은 직접 sql 쿼리를 실행하는 것에 비해 테스트를 더 쉽게 할 수 있다.</li>
<li>Room은 애플리케이션이 컴파일 되는 동안 Dao 클래스의 모든 쿼리를 확인하여 쿼리 중 문제가 있는 경우 즉시 사용자에게 알려준다.</li>
</ul>
<ol start="2">
<li><strong>Entity</strong></li>
</ol>
<ul>
<li>데이터베이스 내에서 테이블을 나타낸다.</li>
<li>room을 사용할 때 관련 필드 집합을 엔티티들로 정의한다.</li>
<li>각 엔티티에 대해 항목(아이템)을 보관하기 위해 연결된 데이터베이스 객체 내에 테이블이 생성된다.</li>
<li>데이터베이스 클래스의 엔티티 array를 통해 엔티티 클래스를 참조해야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>필드를 유지하려면, 룸은 필드에 접근할 수 있어야 한다.</li>
<li>필드를 public으로 만들거나, getter / setter를 제공할 수 있다.</li>
<li>getter / setter method를 사용한다면 룸에서 JavaBeans 규칙을 기반으로 한다.[멤버 변수는 private형을 지정하여 선언한다.]</li>
</ul>
<blockquote>
<p>주의</p>
</blockquote>
<p>엔티티에는 빈 생성자 (해당 DAO 클래스가 각 지속 필드를 액세스할 수 있는 경우) 또는 매개 변수에 엔티티 필드와 일치하는 유형과 이름이 포함된 생성자가 있을 수 있다. 룸은 일부 필드만 수신하는 생성자와 같이 전체 또는 부분 생성자를 사용할 수도 있다.</p>
<p><strong>User a Primary Key</strong></p>
<ul>
<li>각 Entity는 최소 하나 이상의 필드를 기본키로 지정해야 한다.</li>
<li>필드가 하나만 있는 경우에도 <code>@PrimaryKey</code> 어노테이션을 사용하여 필드에 주석을 달 필요가 있다.</li>
<li>또한, 룸에서 엔티티에 자동으로 ID를 할당하도록 하려면 @PrimaryKey의 <strong>autoGenerate</strong> 속성을 설정할 수 있다.(기본은 false. ex: index가 자동으로 증가하는 경우와 같은)</li>
<li>엔티티가 복합 PrimaryKey가 있는 경우 @Entity 어노테이션의 <strong>primaryKeys</strong> 속성을 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(primaryKeys = &#123;<span class="string">"firstName"</span>, <span class="string">"lastName"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>기본적으로 룸은 클래스 이름을 데이터베이스 테이블 이름으로 사용한다.</li>
<li>만약 테이블이 다른 이름을 가지게 하고 싶다면, @Entity 어노테이션의 <strong>tableName</strong> 속성을 설정하면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>주의 : SQLite의 테이블 이름은 대소문자를 구분하지 않는다.</p>
</blockquote>
<ul>
<li>tableName 속성과 비슷하게 룸은 필드 이름을 데이터베이스의 column 이름으로 사용한다.</li>
<li>만약 column 이름을 다르게 하고 싶다면 <code>@ColumnInfo</code> 어노테이션을 추가하면 된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Ignore fields</strong></p>
<ul>
<li>기본적으로 룸은 엔티티에 정의된 각 필드에 대한 Column을 생성한다.</li>
<li>엔티티에 지속하고 싶지 않은 필드가 있는 경우 <code>@Ignore</code>를 사용하여 필드에 어노테이션을 추가할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>상위 엔티티에서 필드를 상속하는 경우, 일반적으로 @Entity 특성의 <strong>ignoredColumns</strong> 속성을 더 쉽게 추가해서 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(ignoredColumns = <span class="string">"picture"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteUser</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> hasVpn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Provide table search support</strong></p>
<p>추가 예정~~</p>
<ol start="3">
<li><strong>DAO(Data Access Object)</strong></li>
</ol>
<ul>
<li>데이터베이스에 접근할 수 있는 메소드를 포함하며, 데이터 접근 객체이다.</li>
<li>인터페이스로서 쿼리를 사용하는 메소드를 정의한다.</li>
<li>룸을 사용해 앱의 데이터에 접근하려면 DAO를 사용한다.</li>
<li>각 DAO에는 앱의 데이터베이스에 대한 추상적 액세스를 제공하는 방법이 포함되어 있으므로(interface내에 쿼리와 함께 함수만 정의) 이 Dao 객체들은 룸의 주요 구성요소를 형성한다.</li>
<li>쿼리 builder나 직접적인 쿼리 대신 DAO 클래스를 사용하여 데이터베이스에 접근하여 데이터베이스 구조의 다양한 구성 요소를 분리할 수 있다.</li>
<li>또한, DAO를 사용하면 애플리케이션을 테스트할 때 데이터베이스 접근을 쉽게 할 수 있다.</li>
<li>DAO는 인터페이스 또는 추상 클래스일 수 있다.
<ul>
<li>추상 클래스인 경우 선택적으로 RoomDatabase를 유일한 매개 변수로 사용하는 생성자를 가질 수 있다.</li>
<li>Room은 <strong>Compile time</strong>에 각 DAO 구현을 생성한다.</li>
</ul>
</li>
</ul>
<p><strong>Define methods for convenience</strong></p>
<ul>
<li>DAO 클래스를 사용하여 나타낼 수 있는 여러가지 편리한 쿼리가 있다.</li>
</ul>
<p><strong>1. Insert</strong></p>
<ul>
<li>DAO 메소드를 작성하고 @Insert로 어노테이션을 지정할 때, Room은 단일 트랜잭션의 데이터베이스에 모든 매개변수를 삽입하는 구현을 생성한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBothUsers</span><span class="params">(User user1, User user2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsersAndFriends</span><span class="params">(User user, List&lt;User&gt; friends)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@Insert 메소드는 매개 변수를 1개만 받으면 삽입된 항목의 새 rowId인 long 타입의 값을 반환할 수 있다. 매개변수가 배열 또는 집합인 경우 Long[] 또는 List<long>을 대신 반환해야 한다.</long></li>
<li>@Insert에 <code>onConflict</code> 속성을 지정할 수 있다.  테이블에 Entity를 삽입할 때 같은 값인 경우, <strong>충돌</strong>이 발생하는데 이 충돌을 어떻게 해결할지를 정의할 수 있다.
<ul>
<li>위에서는 Replace로 지정하여 충돌 발생 시 새로 들어온 데이터로 교체한다.</li>
</ul>
</li>
</ul>
<p><strong>2. update</strong></p>
<ul>
<li><code>update</code> 방법은 테이터베이스에서 매개 변수로 지정된 엔티티 집합을 수정한다. 각 엔티티의 기본 키와 일치하는 조회를 사용한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>일반적으로 필요하진 않지만, update를 사용하면 데이터베이스에서 업데이트된 행 수를 나타내는 int 값을 반환할 받을 수 있다.</li>
</ul>
<p><strong>3. Delete</strong></p>
<ul>
<li><code>Delete</code> 방법은 매개 변수로 지정된 엔티티 집합을 데이터베이스에서 제거한다. 기본키를 사용하여 삭제할 엔티티를 찾는다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteusers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>update와 비슷하게 삭제를 하면 데이터베이스에서 제거된 행 수를 나타내는 int 값을 반환할 수 있다.</li>
</ul>
<p><strong>4. Query</strong></p>
<ul>
<li><code>@Query</code>는 DAO 클래스에서 사용되는 주석이다.</li>
<li>데이터베이스에서 읽기 / 쓰기 작업을 수행할 수 있다.</li>
<li>각 @Query 메소드는 Compile time에 확인되므로 쿼리에 문제가 있으면 Runtim Error 대신 <code>Compile Error</code>가 발생한다.</li>
<li>또한, 룸은 반환된 객체의 필드 이름이 쿼리 응답의 해당 열 이름과 일치하지 않는 경우 룸은 다음 두 가지 방법 중 하나로 경고를 표시한다.
<ul>
<li>일부 필드 이름만 일치하는 경우 경고를 표시한다.</li>
<li>필드 이름이 일치하지 않으면 오류가 발생한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>모든 사용자를 load하는 간단한 쿼리이다.</li>
<li>Compile time에 룸은 사용자 테이블의 모든 Column을 쿼리한다는 것을 알고 있다. 쿼리에 구문 오류가 있거나 사용자 테이블이 데이터베이스에 없는 경우, Room은 앱 컴파일 시 적절한 메시지가 포함된 오류를 표시한다.</li>
</ul>
<p><strong>5. Passing parameters into the query</strong></p>
<ul>
<li>대부분의 경우 특정 연령보다 나이가 많은 사용자만 표시하는 등의 필터링 작업을 수행하려면 매개 변수를 쿼리에 전달해야 한다.</li>
<li>다음에서 확인할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersOlderThan(<span class="keyword">int</span> minAge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 쿼리를 컴파일할 때, Room은 :minAge bind 매개 변수와 minAge 메소드 매개변수를 일치시킨다. Room은 매개 변수 이름을 사용하여 매치를 수행한다. 일치하지 않는 경우 앱 컴파일 시 오류가 발생한다.</li>
<li>다음과 같이 여러 매개변수를 전달하거나 조회에서 여러 번 참조할 수도 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersBetweenAges(<span class="keyword">int</span> minAge, <span class="keyword">int</span> maxAge);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :search "</span> +</span><br><span class="line">           <span class="string">"OR last_name LIKE :search"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserWithName</span><span class="params">(String search)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6. Returning subsets of columns</strong></p>
<ul>
<li>대부분의 경우 엔티티의 몇 가지 필드만 있으면 된다.</li>
<li>예를 들어 UI는 사용자에 대한 모든 세부 정보가 아니라 사용자의 성과 이름만 표시할 수 있다. 앱의 UI에 표시되는 열만 가져오면 리소스가 절약되고 쿼리가 더 빨리 완료된다.</li>
<li>Room을 사용하면 결과 Column 집합을 반환될 개체로 매핑할 수 있는 쿼리에서 Java 기반 개체를 반환할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java Object</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Query 메소드에서 이 자바 객체를 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadFullName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Room은 쿼리가 first_name, last_name 열에 대한 값을 반환하고 이러한 값을 NameTuple 클래스의 필드에 매핑할 수 있음을 이해한다.</li>
<li>따라서 룸에서 적절한 코드를 생성할 수 있다.</li>
<li>쿼리가 너무 많은 열을 반환하거나 NameTuple 클래스에 없는 열을 반환하면 룸에 경고가 표시된다.</li>
</ul>
<p><strong>7. Passing a collection of arguments</strong></p>
<ul>
<li>일부 쿼리는 런타임까지 알 수 없는 정확한 수의 매개 변수를 사용하여 많은 매개 변수를 전달해야 할 수 있다.</li>
<li>예를 들어, regions의 하위 집합에서 모든 사용자에 대한 정보를 검색할 수 있다.</li>
<li>Room은 매개변수가 집합을 나타내는 시점을 파악하고 제공된 매개변수 수에 따라 런타임에 매개변수를 자동으로 확장한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadUsersFromRegions</span><span class="params">(List&lt;String&gt; regions)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8. Observable queries</strong></p>
<ul>
<li>쿼리를 수행하며 데이터가 변경될 때 앱의 UI가 자동으로 업데이트 되는 경우가 많다.</li>
<li>이를 수행하기 위해서는 쿼리 메소드 description에 <strong>LiveData</strong> 유형의 반환 값을 사용한다.</li>
<li>Room은 데이터베이스가 업데이트될 때 LiveData를 업데이트하는데 필요한 모든 코드를 생성한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHEHE region IN (:regions)"</span>)</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; loadUserFromRegionsSync(List&lt;String&gt; regions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>9. Reactive queries with RxJava</strong></p>
<p>추가 예정~~</p>
<h3 id="연습해보기">[연습해보기]</h3>
<ul>
<li><code>Entity</code> : database의 row와 mapping되는 class. 즉, table의 구조를 나타내는데 Database에서 <strong>entities</strong> 함수를 통해 접근할 수 있다.</li>
</ul>
<p>@Ignore를 붙이지 않는한 DB에 지속적으로 유지된다.<br>
entity는 empty 생성자나, 부분 field만 갖는 생성자, full field에 대한 생성자 모두를 가질 수 있다.</p>
<ul>
<li><code>DAO</code> : database를 접근하는 함수들이 정의되는 class or interface이다. @Database로 정의된 class는 내부에 인자가 없고 @Dao annotation이 되어 있는 class를 return하는 abstract 함수를 포함하고 있다.</li>
</ul>
<p>아래의 예제는 하나의 entity와 하나의 Dao를 갖는 형태이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao.java</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>) </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE uid IN (:userIds)"</span>) </span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">loadAllByIds</span><span class="params">(<span class="keyword">int</span>[] userIds)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :first AND "</span> + <span class="string">"last_name LIKE :last LIMIT 1"</span>) </span><br><span class="line">    <span class="function">User <span class="title">findByName</span><span class="params">(String first, String last)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Insert</span> <span class="keyword">void</span> </span><br><span class="line">    insertAll(User... users); </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Delete</span> <span class="keyword">void</span> </span><br><span class="line">    delete(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDatabase.java</span></span><br><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위 3개의 class가 완성되면 아래와 같이 DB의 instance를 얻을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppDatabase db = Roo.databaseBuilder(getApplicationContext(), AppDatabase.class, <span class="string">"database-name"</span>).build();</span><br></pre></td></tr></table></figure>
<p><code>AppDatabase object를 생성하는 코드는 비용이 많이 들기 때문에 싱글톤으로 구현해야 한다.</code></p>
<h2 id="entities">Entities</h2>
<p>@Database의 annotation에 속성으로 포함된 entitiy는 실제 @Entity annotation을 붙인 class로 만들어야 한다. 이는 각 table로 생성되며, 실제 colume으로 만들고 싶지 않은 field가 있다면 <code>@Ignore</code>를 붙인다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Field는 public 형태이어야 하며, private으로 할 경우 getter와 setter를 java beans convention에 따라 만들어야 한다.</p>
<h2 id="primary-key">Primary Key</h2>
<p>column이 하나라도 PK는 지정되어야 한다. @PrimaryKey annotation을 이용하거나 복합 PK의 경우 @Entity 속성으로 primarykeys를 이용한다.</p>
<p>또한, Id를 autogenerate하려면 @PrimaryKey 속성에 <code>autoGenerate</code> 속성(true)을 넣는다.</p>
<p>추가적으로 class 이름은 table 명이 된다. table 명을 바꾸고 싶다면 @Entity 속성으로 <code>tableName</code>을 넣으면 된다.</p>
<p>만약 field 이름을 column으로 쓰고 싶지 않다면 <code>@ColumnInfo</code>로 표기해야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 복합 PK 사용시</span></span><br><span class="line"><span class="meta">@Entity</span>(primaryKeys = &#123;<span class="string">"firstName"</span>, <span class="string">"lastName"</span>&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 테이블 이름을 직접 지정할 때</span></span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Column을 직접 지정할 때</span></span><br><span class="line"><span class="meta">@Entity</span>(tableName = <span class="string">"users"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="indices-and-uniqueness">Indices and uniqueness</h2>
<p>Indext는 아래와 같이 만들 수 있다.(결합 index도 생성 가능)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(indices = &#123;<span class="meta">@Index</span>(<span class="string">"name"</span>),<span class="meta">@Index</span>(value = &#123;<span class="string">"last_name"</span>,<span class="string">"address"</span>&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Unique 제약 조건은 아래와 같이 표기할 수 있다.</li>
<li>예제) 결합 조건에 대한 unique index</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(indices = &#123;<span class="meta">@Index</span>(value = &#123;<span class="string">"first_name"</span>, <span class="string">"last_name"</span>&#125;,</span><br><span class="line">        unique = <span class="keyword">true</span>)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    Bitmap picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreignKey도 설정할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(foreignKeys = <span class="meta">@ForeignKey</span>(entity = User.class,</span><br><span class="line">        parentColumns = <span class="string">"id"</span>,</span><br><span class="line">        childColumns = <span class="string">"user_od"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"user_id"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> useerId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="nested-objects">Nested objects</h2>
<p>Entity 클래스가 field로 object를 갖는 경우 <code>@Embeded</code>를 사용한다. 단, 해당 table에는 Embeded된 클래스의 column도 똑같은 하나의 column으로 취급된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String street;</span><br><span class="line">    <span class="keyword">public</span> String state; <span class="keyword">public</span> String city;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"post_code"</span>) </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> postCode;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Embeded</span></span><br><span class="line">    <span class="keyword">public</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>즉, 위 예제에서 User table에는 id, firstName, street, state, city, post_cde 컬럼이 존재한다. Embeded 안에서 embeded를 가질 수 있으며, 만약 column 이름이 중복되는 경우 <code>prefix</code>를 사용하여 unique하게 column 이름을 설정한다.</p>
<h2 id="daodata-access-objectsdaos">DAO(Data Access Objects)(DAOs)</h2>
<p>Dao는 abstract class나 interface가 될 수 있다. RoomDatabase를 인자로 받는 생성자를 만드는 경우에만 abstract class가 될 수 있다. Room은 절대로 main thread에서 query 작업을 하지 않는다. <code>allowMainThreadQueries()</code>를 호출하더라도 불가능하다.<br>
LiveData는 return하는 비동기 query의 경우에는 가능하다.(어차피 background에서 수행되므로) - 무슨 말이지…?</p>
<h3 id="insert">Insert</h3>
<p>@Insert로 표기하며, single transaction으로 처리된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = OnConflictStrategy.REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertBothUser</span><span class="params">(User user1, User user2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUsersAndFriends</span><span class="params">(User user, List&lt;User&gt; friends)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Entity로 정의된 class만 인자로 받거나, 그 class의 collection 또는 array만 인자로 받을 수 있다. 또한, 인자가 하나인 경우 long type의 return(insert된 값의 rowId)을 받을 수 있고, 여러 개인 경우 long[], List<long>을 받을 수 있다.</long></p>
<h3 id="update">Update</h3>
<p>Update를 사용하여 Entity set을 update 한다. return 값으로 변경된 rows 수를 받을 수 있다. update는 PK 기준으로 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUsers</span><span class="params">(User... user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete">Delete</h3>
<p><code>Delete</code>를 사용하여 Entity set을 delete 한다. return 값으로 변경된 rows 수를 받을 수 있다. 삭제 key는 PK를 기준으로 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUsers</span><span class="params">(User... users)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="query">Query</h3>
<p><code>@Query</code>를 사용하여 DB를 조회할 수 있다. compile time에 return되는 object의 field와 sql 결과로 나오는 column의 이름이 맞는지 확인하여 일부가 match되면 warning, match 되는게 없다면 error를 보낸다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>select문에 parameter가 들어가야 하는 경우 아래와 같이 넣을 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age &gt; :minAge"</span>)</span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersOlderThan(<span class="keyword">int</span> minAge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>아래와 같이 여러 개의 parameter도 사용할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge"</span>) </span><br><span class="line">    <span class="keyword">public</span> User[] loadAllUsersBetweenAges(<span class="keyword">int</span> minAge, <span class="keyword">int</span> maxAge); </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE first_name LIKE :search "</span> + <span class="string">"OR last_name LIKE :search"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserWithName</span><span class="params">(String search)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>만약 일부 컬럼만 조회하고 싶다면 따로 return class를 만들어서 요청할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return 받을 class를 정의</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameTuple</span></span>&#123;</span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name = <span class="string">"first_name"</span>)</span><br><span class="line">    <span class="keyword">public</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ColumnInfo</span>(name=<span class="string">"last_name"</span>) </span><br><span class="line">    <span class="keyword">public</span> String lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadFullName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>또한, 정해지지 않은 개수의 parameter가 넘어가야 하는 경우 아래와 같이 수행 가능하다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT first_name, last_name FROM user WHERE region IN (:regions)"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NameTuple&gt; <span class="title">loadUsersFromRegions</span><span class="params">(List&lt;String&gt; regions)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>기타 등등의 기능들을 포함하고 있다. 하지만, 아래는 필요에 따라 찾아보면서 기능을 사용하면 될 것 같다.</p>
<h3 id="using-tye-converters">Using tye converters</h3>
<p>Room은 primitive type(원시 타입 ex. int, String 등등)과 그 wrapping 타입만 지원한다. 하지만, 그 외에 type을 사용할 경우 <strong>TypeConverter</strong>를 사용하여 type을 치환해야 한다.</p>
<p>예를 들어, DB에서는 timestamp로 되어 있고, java code에서는 Date class로 되어 있는 경우 우선 아래와 같이 <code>converter</code>를 만든다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span></span>&#123;</span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">fromTimestamp</span><span class="params">(Long value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value == <span class="keyword">null</span>? <span class="keyword">null</span> : <span class="keyword">new</span> Date(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TypeConverter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">dateToTimestamp</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date == <span class="keyword">null</span>? <span class="keyword">null</span> : date.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>이 두개의 converting 함수는 서로 converting 해주고 있다.</li>
<li><code>@TypeConverters</code>를 이용하여 적용할 곳에 넣는다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDatabase.java</span></span><br><span class="line"><span class="meta">@Database</span>(entities = &#123;User.java&#125;, version= <span class="number">1</span>)</span><br><span class="line"><span class="meta">@TypeConverters</span>(&#123;Converters.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserDao.java</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE birthday BETWEEN :from AND :to"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findUsersBornBetweenDates</span><span class="params">(Date from, Date to)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@TypeConverter를 지정하는 위치에 따라 scope이 달라진다.</li>
<li>예제처럼 Database에 넣으면 Dao와 entity 모두 영향을 받는다.</li>
<li>Dao나 Entity, POJO에 넣을 수도 있고, Entity의 특정 field, Dao의 특정 method or 특정 parameter에 넣을 수 있다.</li>
</ul>
<h3 id="database-migration">Database migration</h3>
<p>database migration이 필요한 경우 entity class에 수정 항목을 반영해야 한다. 또한 데이터를 날리지 않기 위해서 mirgration을 할 수 있는 방법을 제공한다.</p>
<p>migration을 등록하면, runtime에 migration을 수행하며 정해놓은 순서대로 migration이 가능하다. migration을 등록할 때는 <strong>시작 버전과 끝 버전을 넣어야 한다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Room.databaseBuilder(getApplicationContext(), MyDb.class, <span class="string">"database-name"</span>).addMigrations(MIGRATION_1_2, MIGRATION_2_3).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_1_2 = <span class="keyword">new</span> Migration(<span class="number">1</span>,<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> </span>&#123; </span><br><span class="line">        database.execSQL(<span class="string">"CREATE TABLE `Fruit` (`id` INTEGER, "</span> + <span class="string">"`name` TEXT, PRIMARY KEY(`id`))"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Migration MIGRATION_2_3 = <span class="keyword">new</span> Migration(<span class="number">2</span>, <span class="number">3</span>) &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">migrate</span><span class="params">(SupportSQLiteDatabase database)</span> </span>&#123; </span><br><span class="line">        database.execSQL(<span class="string">"ALTER TABLE Book "</span> + <span class="string">" ADD COLUMN pub_year INTEGER"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>migration 코드가 없으면 Room은 DB를 그냥 rebuild한다.</code>(기존 데이터는 날아간다.)</li>
<li>또한, migration에 들어가는 query는 상수에 넣지말고, 직접 넣는게 migration 로직을 유지하는데더 좋다.</li>
<li>migration이 끝나고 나면, schema에 대한 유효성을 확인을 하고, 문제가 있을 경우 mismatch된 부분에 정보를 담은 exception을 발생 시킨다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://tourspace.tistory.com/28" target="_blank" rel="noopener">Android Architecture Components #6 - Room</a></li>
<li><a href="https://developer.android.com/training/data-storage/room/defining-data#java" target="_blank" rel="noopener">Defining data using Room entities</a></li>
<li><a href="https://developer.android.com/training/data-storage/room/#java" target="_blank" rel="noopener">Save data in a local database using Room</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/25/Android-Room-Basic/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/24/Etc-Git-Issue-Use/"
                            aria-label=": 4일차 [Git] Issue 탭 이용하기"
                        >
                            4일차 [Git] Issue 탭 이용하기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-24T01:00:24+09:00">
	
		    Jan 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>부스트 캠프를 하면서 오늘이 4일차이다. 지금까지 배운 것은 데일리 스크럼을 하면서 오늘의 상태와 할 것들을 상기하는 시간을 갖는다. 정말 간단하게 하면서 5~10분 정도로 진행한다.</p>
<p>그리고 항상 어제 저녁에 작성했던 <strong>snippet</strong>을 보면서 어제는 어떤 일을 했고, 오늘은 어떤 일을 할지 다시 한번 생각한다.</p>
<p><strong>snippet</strong></p>
<p>[오늘 완료 업무]</p>
<ul>
<li>기능 정의서 세분화</li>
<li>WBS 파일 git 업로드</li>
<li>팀 Repository issue 탭 추가</li>
</ul>
<p>[내일 업무]</p>
<ul>
<li>피드백 반영</li>
<li>안드로이드 기본 구조 세팅</li>
</ul>
<p>위와 같은 업무들을 작성한다. 보통 스니펫은 6시 퇴근이라고 가정한다면 5시? 정도에 회의를 통해서 스니펫을 공유하는 작업을 거친다. 우리는 지금 슬랙에 채널을 이용해서 공유하고 있다.</p>
<p>그 다음으로는 Github을 이용한 협업 능력이다. 일단 지금까지 Github을 사용하면서 나는 Github flow를 바탕으로 협업을 진행했다. 그리고 부스트 캠프를 통해서 Git flow를 알게 되었고, 공부도 진행했다. 공부하면서 느낀 점은 Git은 정말 지옥이라는 점과 많은 명령어가 존재한다는 점이다. [Git에 대한 공부는 앞에 포스팅을 참고하면 된다. 제목이 #일차가 붙은 것들이다.]</p>
<p>어떤 회사에서는 <code>Jira</code> 라는 애자일 프로세스 툴을 사용해서 이슈를 관리하고 이슈마다 나오는 티켓? 번호를 기준으로 해서 피쳐를 나누고 개발을 한다고 한다. 하지만, 유료이고 설치가 조금 까다롭다고 해서 우리는 Jira를 사용하지 않고 다른 방법을 사용하기로 했다.</p>
<h2 id="issue-발행">Issue 발행</h2>
<p>Issue는 모든 것이 이슈라고 불릴 수 있다. 새로운 추가될 기능, 개선 해야할 기능, 버그 등등 모든 것이 이슈라고 볼 수 있다. 모든 활동 내역에 대해서 이슈를 등록하고 그 이슈 기반으로 작업을 하게 된다.</p>
<p>우리는 Github의 issue 탭을 사용해서 이를 기반으로 feature 브랜치를 생성해서 작업할 예정이다.</p>
<h3 id="issue-template">Issue Template</h3>
<p>이슈 템플릿을 사용해서 형식을 지정하여 사용할 수 있다. .github/ 디렉토리 밑에 ISSUE_TEMPLATE.md 파일에 템플릿을 지정해서 사용할 수 있다. 우리는 issue 템플릿은 사용하지 않는다.</p>
<h2 id="issue-작업">Issue 작업</h2>
<p>다음 예제의 사진을 통해서 등록된 issue를 살펴보자.</p>
<img src="/img/github_issue.png" width="500" height="200">
<ul>
<li>Assignees : 해당 작업의 담당자</li>
<li>Labels : 해당 작업의 성격을 지정한다.</li>
<li>Milestone : 해당 작업이 속한 파트</li>
</ul>
<img src="/img/github_milestone.png" width="500" height="200">
<p>다른 것들은 이해하기 쉽지만 Milestone은 생소하다. Milestone은 이번 출시 버전이 1.0.0일 경우 해당 버전이든 이슈(작업) 기능 강화, 새 기능추가, 버그 기타 등등 모든 이슈를 Version 1.0.0 Milestone이라는 항목에 추가하면 위 그림처럼 Version 1.0.0에 대한 전체적인 상황을 한 눈에 볼 수가 있는 장점이 있다.</p>
<p><strong>1. Issue 생성</strong></p>
<p>일단, 우리는 먼저 Github의 issue 탭에 들어가서 <strong>기능 정의서</strong>를 기반으로 issue를 생성한다. 이슈는 <code>스토리_기능</code>의 형태로 이슈를 생성했다. 기본 기능들을 미리 이슈 탭을 이용해서 기능을 정리한 것이다. 이슈를 생성할 때 자동으로 번호가 발급되는데 이 <strong>번호</strong>를 사용해서 feature 브랜치를 생성할 것이다.</p>
<p><strong>2. 브랜치 생성</strong></p>
<p>이제 발급된 이슈 번호를 기준으로 <strong>feature</strong> 브랜치를 생성하면 된다. Git flow에 따라서 develop 브랜치에서 feature 브랜치를 딴다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_#033_util_sharedpreference develop</span><br></pre></td></tr></table></figure>
<p>위의 명령어는 develop으로부터 feature_#033_util_sharedpreference라는 브랜치를 생성하고 그 브랜치로 이동하는 것을 의미한다.</p>
<p><strong>3. 작업 수행 후 commit</strong></p>
<p>코드를 수정하거나 클래스를 만드는 등의 작업을 수행하고 커밋을 해준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;#003_feat_쉐어드 프리퍼런스 구현&quot;</span><br></pre></td></tr></table></figure>
<p>위의 명령어는 git add와 git commit을 합친 형태이다. 메시지도 위와 같은 형식을 지켜서 작성한다.</p>
<p><strong>4. 원격 저장소로 push 작업</strong></p>
<p>이제 commit도 완료했으니 원격 저장소(origin)으로 push를 하면 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin feature_#033_util_sharedpreference</span><br></pre></td></tr></table></figure>
<p><strong>5. PR &amp; Merge</strong></p>
<p>이제 Merge를 해달라는 Pull Request를 작성한다.</p>
<img src="/img/github_PR.png" width="500" height="200">
<ul>
<li>PR의 이름은 Feature #033 util SharedPreference로 작성한다.</li>
<li>내용은 PR Template을 이용하여 개요와 작업 사항, 사용 방법 등을 작성한다.</li>
<li>그리고 작성자와 라벨을 달고 리뷰어를 설정한 뒤 PR를 날린다.</li>
<li>코드 리뷰를 받는다.</li>
<li>수정 사항이 있다면 코드를 수정하고 다시 push를 날린다.</li>
<li>여기서 <code>resolved #이슈번호</code>로 작성하면 merge될 때 해당 issue는 자동으로 삭제된다.(아주 간편한 기능!!!)</li>
</ul>
<img src="/img/github_PR2.png" width="500" height="200">
<ul>
<li>그러면 수정 사항에 대해서 링크가 나오고 위와 같이 답글을 달아준다.</li>
<li>그리고 코드 리뷰가 완료되고 리뷰어가 approve를 해주면 자신이 merge를 한다.</li>
<li>그리고 해당 브랜치는 더는 필요가 없다고 판단되면 Delete branch 버튼을 통해서 Remote에 있는 브랜치 삭제 해주면 된다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.popit.kr/github%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0-part1-%EC%9D%B4%EC%8A%88-%EB%B0%9C%EA%B8%89-%EB%B6%80%ED%84%B0-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0%EA%B9%8C/" target="_blank" rel="noopener">GitHub로 프로젝트 관리하기 Part1 - 이슈 발급 부터 코드리뷰까지</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/24/Etc-Git-Issue-Use/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/23/Etc-Git-Flow-2/"
                            aria-label=": 3일차 [Git] Git-Flow"
                        >
                            3일차 [Git] Git-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-23T17:51:47+09:00">
	
		    Jan 23, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>어제 Git-Flow를 공부하면서 기초 개념과 용어에 대한 혼란이 너무 많이 왔었다. 오늘이 3일차인데, 아직 Git에서 헤매는 부분이 너무 많다.</p>
<p>오늘의 일정은 아래와 같은 일정이었다. 이런 일정을 <strong>snippet</strong>이라는 용어로 부른다.</p>
<p><strong>[오늘의 업무]</strong></p>
<ul>
<li>Daily Scrum [매일의 상태를 체크]</li>
<li>코드 컨벤션 구체화</li>
<li>Git 과제 완료</li>
<li>github 초기 설정</li>
<li>기능 정의서 정리</li>
</ul>
<p>오늘의 업무를 일찍 끝내서 남은 시간은 Git을 공부하는데 투자했다. 먼저, 간단한 용어를 정리하고 <strong>Git-Flow</strong>에 대한 내용을 정리할 예정이다.</p>
<h2 id="git-vs-github">Git vs Github</h2>
<ul>
<li><code>Git</code>은 대표적인 <strong>분산 버전 관리 시스템</strong>으로, 사용자의 프로젝트에 포함된 파일의 변경 사항을 관리하고 추적하는 도구이다.</li>
<li><code>Github</code>은 Git을 사용하는 프로젝트를 지원하는 <strong>웹 호스팅 서비스</strong>이다.</li>
</ul>
<h2 id="git-pointer">#Git Pointer</h2>
<p><strong>HEAD</strong></p>
<ul>
<li>현재 Branch가 가리키는 가장 최근 Commit</li>
</ul>
<p><strong>Master Branch</strong></p>
<ul>
<li>가장 기본이 되는 Branch</li>
<li>Master branch는 Git에서 기본으로 생성해준다.</li>
</ul>
<p><strong>origin</strong></p>
<ul>
<li>원격 Repository를 뜻하는 Alias</li>
<li>Alias이므로 이름을 변경할 수 있다.</li>
</ul>
<p><strong>origin/master</strong></p>
<ul>
<li>원격 Repository의 Master branch</li>
</ul>
<p><strong>origin/HEAD</strong></p>
<ul>
<li>원격 Repository가 바라보는 버전</li>
</ul>
<h2 id="gitflow-workflow">Gitflow Workflow</h2>
<ul>
<li>nvie.com의 <strong>빈센트 드리센</strong>이 제안한 것이다.</li>
<li>대형 프로젝트에도 적용할 수 있는 좀 더 엄격한 작업 절차를 갖는다.</li>
<li>Gitflow Workflow의 핵심 컨셉은 master와 develop, 두 개의 메인 브랜치를 이용한다는 것이다.
<ul>
<li><strong>master branch</strong> : 릴리즈 이력을 관리하기 위해 사용. 즉, 배포 가능한 상태만을 관리한다.</li>
<li><strong>develop branch</strong> : 기능 개발을 위한 브랜치들을 병합하기 위해 사용. (모든 기능이 추가되고 버그가 수정되어 배포 가능한 상태라면 ‘master’ 브랜치에 merge 한다.) 평소에는 이 브랜치를 기반으로 개발을 진행한다.</li>
</ul>
</li>
</ul>
<h2 id="1중앙-원격-저장소-자신의-원격-저장소-로컬-저장소의-개념">1.중앙 원격 저장소, 자신의 원격 저장소, 로컬 저장소의 개념</h2>
<ul>
<li>
<p>중앙 원격(remote) 저장소</p>
<ul>
<li>여러 명이 같은 프로젝트를 관리하는 데 사용하는 그룹 계정의 중립된 원격 저장소</li>
<li>Organization을 만들어 사용할 수 있다. Organization의 사용자와 저장소는 팀으로 관리되고 저장소의 권한 설정도 팀으로 관리한다.</li>
</ul>
</li>
<li>
<p>자신의 원격(remote) 저장소</p>
<ul>
<li>remote repository라고 불린다.</li>
<li>파일이 Github 전용 서버에서 관리되는 원격 저장소</li>
</ul>
</li>
<li>
<p>로컬(local) 저장소</p>
<ul>
<li>local repository라고 불린다.</li>
<li>내 PC에 파일이 저장되는 개인 전용 저장소, 지역 저장소의 개념이다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-1.png" width="700" height="500">
<img src="/img/github-collaboration-2.png" width="700" height="500">
<h2 id="2-프로젝트-참여자는-git-clone-명령으로-로컬-저장소를-만든다">2. 프로젝트 참여자는 git clone 명령으로 로컬 저장소를 만든다.</h2>
<p>git clone 명령으로 중앙 원격 저장소(remote repository)를 복제하여 자신의 로컬 저장소(local repository)를 만들 수 있다. 프로젝트 참여자는 clone 한 이 로컬 저장소에서 작업을 수행하면 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 터미널에서 자신이 원하는 디렉토리로 이동한 후 clone 명령어 입력</span><br><span class="line"></span><br><span class="line">git clone [중앙 remote repository URL]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>git clone</code> 명령은 아래의 명령들을 포함한 작업이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 해당 디렉토리를 빈 Git 저장소로 만드는 작업</span><br><span class="line">git init</span><br><span class="line">// 현재 작업 중인 Git 저장소에 팀의 중앙 원격 저장소를 추가한다. 이름을 origin으로 짓고 긴 서버 주소(URL) 대신 사용한다. 마치 별명과 같다.</span><br><span class="line">git remote add origin [중앙 remote repository URL]</span><br><span class="line">// 중앙 원격 저장소(origin)의 master 브랜치 데이터를 로컬에 가져오기만 하는 작업</span><br><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fetch와 pull의 차이</p>
</blockquote>
<ul>
<li>fetch : 원격 저장소의 데이터를 로컬에 가져오기만 하는 작업</li>
<li>pull : 원격 저장소의 데이터를 가져와 자동으로 병합까지 하는 작업</li>
<li>즉, 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우에는 fetch 명령어를 사용한다.</li>
<li><code>pull = fetch + merge</code></li>
</ul>
<img src="/img/github-collaboration-3.png" width="700" height="500">
<img src="/img/github-collaboration-4.png" width="700" height="500">
<h2 id="3먼저-할-일은-develop-브랜치를-만드는-것이다">3.먼저 할 일은 Develop 브랜치를 만드는 것이다.</h2>
<p><strong>방법[1] : GUI 도구를 이용한 생성(이 방법을 추천)</strong></p>
<p>‘master’ 브랜치를 기준으로 develop 브랜치를 만든다. 여기서는 Pull Request를 이용할 것이기 때문에 <strong>GUI 도구를 이용한 생성 방법</strong>을 사용한다.[이 방법을 추천한다고 한다!!]</p>
<img src="/img/github-collaboration-5.png" width="700" height="500">
<ul>
<li>Github 페이지에서 <strong>Branch:master</strong>를 클릭한 후 새로 생성할 브랜치의 이름을 <strong>develop</strong>으로 적는다. [이때, branch를 생성할 수 있는 사용자는 Owner 권한이 있는 사용자]</li>
</ul>
<img src="/img/github-collaboration-6-1.png" width="700" height="500">
<ul>
<li>새로 생성한 develop branch를 <strong>default branch</strong>로 설정해야 한다.</li>
</ul>
<img src="/img/github-collaboration-6-3.png" width="700" height="500">
<ul>
<li><strong>develop branch를 default branch로 설정하는 이유는?</strong>
<ul>
<li>Git-flow에서 평소에는 develop branch를 기반으로 개발을 진행하기 때문에 <code>git push origin some-feature</code>(내 로컬 저장소의 some-feature branch를 중앙 원격 저장소로 올리는 명령)를 한 후, Github 페이지에서 해당 some-feature branch에 대해 merge를 할 때 중앙 원격 저장소의 ‘master’ branch가 아닌 default로 설정되어 있는 <strong>develop</strong>에 병합하도록 설정하기 위함이다.</li>
</ul>
</li>
</ul>
<p><strong>방법[2] : 팀 구성원 중 한 명이 자신의 로컬 저장소에 빈 develop 브랜치를 만들고 중앙 저장소로 푸쉬</strong></p>
<img src="/img/github-collaboration-7.png" width="700" height="500">
<ul>
<li>이 경우는 팀원 중 한 명이 자신의 로컬 저장소에 빈 develop branch를 생성한다.
<ul>
<li><code>git branch develop</code></li>
</ul>
</li>
<li>그 다음, 중앙 원격 저장소(origin)에 develop branch를 푸시한다.
<ul>
<li><code>git push -u origin develop</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># develop 브랜치 생성</span><br><span class="line">git branch develop</span><br><span class="line"></span><br><span class="line"># 중앙 원격 저장소 origin으로 develop branch push</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>
<ul>
<li>그런 다음 Github 페이지에서 자신이 push한 ‘develop’ branch를 병합해달라는 Pull Request를 날린다.</li>
</ul>
<img src="/img/github-collaboration-7-1.png" width="700" height="500">
<ul>
<li>프로젝트 관리자는 해당 pull request를 merge 하여 새로운 ‘develop’ branch를 중앙 원격 저장소에 생성한다.</li>
</ul>
<img src="/img/github-collaboration-7-2.png" width="700" height="500">
<ul>
<li>그 다음에는 방법[1]과 같은 방법으로 develop branch를 default branch로 설정한다.</li>
</ul>
<h2 id="4-팀-구성원-모두가-gitflow-workflow를-적용할-준비를-한다">4. 팀 구성원 모두가 Gitflow workflow를 적용할 준비를 한다.</h2>
<p>이제 팀 구성원들은 중앙 저장소를 복제하고(처음에 clone 했으면 넘어가도 좋다.), 중앙 저장소와 연결된 개발 브랜치를 만들어야 한다.</p>
<img src="/img/github-collaboration-8.png" width="700" height="500">
<figure class="highlight plain"><figcaption><span>checkout -b develop origin/develop```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이제 팀 구성원 모두가 이 워크플로우를 적용하기 위한 준비가 되었다. 다음 단계로 넘어가보자.</span><br><span class="line"></span><br><span class="line">## 5. 설명을 위해 현재 로컬에서 작업 중인 branch 위치를 표시한다.</span><br><span class="line"></span><br><span class="line">중앙 원격 저장소에는 master, develop branch가 있고, 자신의 로컬 저장소에도 master, develop branch와 로그인 기능을 구현한 feature/login branch가 있다고 가정한다. 또한, 현재는 master branch에서 작업 중이라고 가정하고 아래와 같이 작업 중인 위치를 표시한다.</span><br><span class="line">(Gitflow Workflow에서는 대부분의 작업이 **develop** branch에서 이루어진다.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/img/github-collaboration-9.png&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6. 새로운 기능 개발을 위해 격리된 branch를 만든다.</span><br><span class="line"></span><br><span class="line">로컬 저장소에서 branch를 따고, 코드를 수정하고, 변경 내용을 커밋한다. 이때, &apos;master&apos; branch에서 기능 개발을 위한 브랜치를 따는 것이 아니라 우리가 앞서 설정에서 default branch로 설정한 &apos;**develop**&apos; branch에서 따야한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">git checkout -b [branch name] develop</span><br><span class="line"></span><br><span class="line"># 아래의 두 명령어를 합하면 위와 같다.</span><br><span class="line">git branch [branch name] develo</span><br><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure>
<img src="/img/github-collaboration-10.png" width="700" height="500">
<h2 id="7-로컬-저장소의-새로운-기능-브랜치를-중앙-원격-저장소remote-repository에-푸시한다">7. 로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 푸시한다.</h2>
<ul>
<li>새로 만든 브랜치(feature/login branch)에 새로운 기능에 대한 내용을 커밋한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;Write commit message&quot;</span><br><span class="line"></span><br><span class="line"># 위의 명령어는 아래의 두 명령어를 합한 것</span><br><span class="line">$ git add . # 변경된 모든 파일을 스테이징 영역에 추가</span><br><span class="line">$ git add [some-file] # 스테이징 영역 some-file 추가</span><br><span class="line">$ git commit -m &quot;Write commit message&quot; # local 작업 작업 폴더에 history 하나를 쌓는다. [commit]</span><br></pre></td></tr></table></figure>
<ul>
<li>커밋을 완료했다면, 내가 작업한 내용을 포함한 브랜치(feature/login branch)를 중앙 원격 저장소에 올린다.</li>
<li><code>$git push origin feature/login branch</code></li>
<li>이는 로컬 저장소의 백업 역할을 할 뿐만 아니라, 다른 팀 구성원들이 나의 작업 내용과 진도를 확인할 수도 있어 좋은 습관이라 할 수 있다.</li>
</ul>
<p><strong>방법[1] : 팀이 pull request를 이용하는 경우</strong></p>
<ul>
<li>로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 push한 후, 프로젝트 관리자에게 자신의 기여분을 반영해 달라는 pull request를 보낸다.<br>
= 새로 만든 기능 개발용 브랜치도 중앙 저장소에 올려서 팀 구성원들과 개발 내용에 대한 의견(코드 리뷰)등을 나눌 수 있다.</li>
<li>이후에는 모든 팀원이 변경한 코드 내용을 확인하고 마지막으로 확인한 팀원 또는 프로젝트 관리자가 변경 내용을 중앙 원격 코드 베이스에 병합(merge)하는 작업을 한다.</li>
<li>이는 일종의 로컬 저장소 백업 역할을 하기도 한다.</li>
</ul>
<blockquote>
<p>Pull Request란?</p>
</blockquote>
<ul>
<li>기능 개발을 끝내고 master에 바로 병합(merge)하는 것이 아니라, 브랜치를 중앙 원격 저장소에 올리고 병합(merge)해달라고 요청하는 것이다.</li>
</ul>
<img src="/img/github-collaboration-11-1.png" width="700" height="500">
<ul>
<li>GUI 도구를 이용한 pull request
<ol>
<li>Github 페이지에서 <strong>Pull Request</strong> 버튼을 이용하면, 어떤 branch를 제출할 지 정할 수 있다.</li>
<li>기능을 구현한 branch(여기서는 feature/login branch)를 프로젝트의 중앙 원격 저장소의 develop branch에 병합해 달라고 요청한다.</li>
</ol>
</li>
</ul>
<img src="/img/github-collaboration-11-2.png" width="700" height="500">
<ul>
<li>GUI 도구를 이용한 merge
<ol>
<li>Github 페이지에서 Pull Request 버튼을 누른 후, File changed 탭에서 변경 내용을 확인한다.</li>
<li>Conversation 탭으로 이동하여 Confirm merge를 하면 중앙 원격 코드 베이스(‘develop’ branch)에 병합된다.</li>
<li>위에서 ‘develop’ branch를 default branch로 설정했기 때문에 자동으로 ‘develop’ branch로 merge 도니다.</li>
<li>충돌이 일어난 경우는 팀원들과 합의 하에 충돌 내용을 수정한 후 병합을 진행한다.</li>
</ol>
</li>
</ul>
<p><strong>방법[2] : 팀이 pull request를 이용하지 않는 경우</strong></p>
<ul>
<li>기능 브랜치를 병합하기 전에 반드시 자신의 로컬 저장소 develop branch에 중앙 원격 저장소의 변경 내용을 반영해서 최신 상태로 만들어야 한다.</li>
<li>또한 자신이 직접 새로운 기능에 대한 병합을 할 때, ‘master’ branch에 병합하지 않도록 주의해야 한다.</li>
</ul>
<img src="/img/github-collaboration-12-1.png" width="700" height="500">
<img src="/img/github-collaboration-12-2.png" width="700" height="500">
<img src="/img/github-collaboration-12-3.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -u 옵션 : 새로운 기능 브랜치와 동일한 이름으로 중앙 원격 저장소의 브랜치로 추가한다.</span><br><span class="line"></span><br><span class="line">// 로컬의 기능 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$ git push -u origin feature/login branch</span><br><span class="line"></span><br><span class="line">// -u 옵션으로 한 번 연결한 후에는 옵션 없이 아래의 명령만으로 기능 브랜치를 올릴 수 있다.</span><br><span class="line">$ git push origin feature/login branch</span><br></pre></td></tr></table></figure>
<h2 id="8-중앙-원격-저장소와-자신의-로컬-저장소를-동기화하기-위해-로컬-저장소의-branch를-develop-branch로-이동한다">8. 중앙 원격 저장소와 자신의 로컬 저장소를 동기화하기 위해 로컬 저장소의 branch를 develop branch로 이동한다.</h2>
<p>// 로컬 저장소의 branch를 develop branch로 이동<br>
<code>$git checkout develop</code></p>
<img src="/img/github-collaboration-13.png" width="700" height="500">
<h2 id="9-중앙-원격-저장소의-코드-베이스에-새로운-커밋이-있다면-다음과-같이-가져온다">9. 중앙 원격 저장소의 코드 베이스에 새로운 커밋이 있다면 다음과 같이 가져온다.</h2>
<p>중앙 원격 저장소(origin)의 메인 코드 베이스(‘develop’ branch)가 변경되었으므로, 프로젝트에 참여하는 모든 개발자가 자신의 로컬 저장소를 동기화해서 최신 상태로 만들어야 한다.</p>
<ul>
<li><code>$git pull origin develop</code>
<ul>
<li>중앙 원격 저장소(origin)의 변경 내용을 develop 브랜치에 반영해서 동기화한다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-14.png" width="700" height="500">
<img src="/img/github-collaboration-15.png" width="700" height="500">
<h2 id="10-새로운-기능을-추가하기-위해서-그-작업에-대한-branch를-생성하여-작업한다">10. 새로운 기능을 추가하기 위해서 그 작업에 대한 branch를 생성하여 작업한다.</h2>
<ul>
<li>중앙 원격 저장소와 동기화된 로컬 저장소의 ‘develop’ branch에서 새로운 작업에 대한 branch를 생성하여 다른 작업을 한다. 앞에서 했던 것과 동일하게 하면 된다.</li>
</ul>
<img src="/img/github-collaboration-16.png" width="700" height="500">
<ul>
<li>local에서 완성한 이전 작업 브랜치는 삭제한다.
<ul>
<li><code>$git branch -d feature/login</code></li>
</ul>
</li>
</ul>
<h2 id="11-배포하기">11. 배포하기</h2>
<p>만약 <strong>develop</strong> 브랜치에서 버전 1.2에 대한 기능이 모두 구현이 완료 되었으면 배포를 위한 전용 브랜치를 사용하여 배포 과정을 캡슐화 한다. 이렇게 함으로써 한 팀이 해당 배포를 준비하는 동안 다른 팀은 다음 배포를 위한 기능 개발을 계속할 수 있다. 이게 Gitflow의 장점이라고 생각한다.</p>
<p>버전 번호를 부여한 새로운 ‘release’ branch는 develop branch로부터 생성한다.</p>
<img src="/img/github-collaboration-17-1.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// develp 브랜치로부터 release 브랜치(release-1.2)를 생성</span><br><span class="line">$git checkout -b release-1.2 develop</span><br></pre></td></tr></table></figure>
<ul>
<li>이렇게 release 브랜치를 만드는 순간부터 배포 사이클이 시작된다.
<ul>
<li>release 브랜치에서는 배포를 위한 최종적인 버그, 수정, 문서 추가 등 릴리즈와 직접적으로 관련된 작업을 수행한다.</li>
<li>직접적으로 관련된 작업들을 제외하고는 release 브랜치에 새로운 기능을 추가로 병합하지 않는다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-17-2.png" width="700" height="500">
<img src="/img/github-collaboration-17-3.png" width="700" height="500">
<ul>
<li>release 브랜치에서 배포 가능한 상태가 되면(배포 준비가 완료되면)
<ul>
<li>배포 가능한 상태 : 새로운 기능을 포함한 상태로 모든 기능이 정상적으로 동작하는 상태를 말한다.</li>
</ul>
</li>
</ul>
<ol>
<li>‘master’ 브랜치에 병합한다.(이때, 병합한 커밋에 release 버전 태그를 부여!)</li>
<li>배포를 준비하는 동안 release 브랜치가 변경되었을 수 있으므로 배포 완료 후 ‘develop’ 브랜치에도 병합한다.</li>
<li>작업했던 release 브랜치는 삭제한다. 이때, 다음 번 배포(release)를 위한 개발 작업은 ‘develop’ 브랜치에서 계속 진행해 나간다.</li>
</ol>
<p><strong>방법[2] : 팀이 pull request를 이용하는 경우</strong></p>
<p>팀이 풀 리퀘스트를 통한 코드 리뷰를 하는 방식을 사용한다면 release 브랜치를 그대로 중앙 원격 저장소에 push 한 후 다른 팀원들의 리뷰나 확인 과정을 거쳐 'master’와 ‘develop’ branch에 병합한다.</p>
<h2 id="12-버그-수정하기">12. 버그 수정하기</h2>
<p>배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우(버그 발견…!), ‘master’ 브랜치에서 직접 브랜치[<strong>hotfix</strong> 브랜치]를 만들어 필요한 부분만을 수정한 후 다시 ‘master’ 브랜치에 병합하여 이를 배포해야 한다.</p>
<p>‘develop’ 브랜치에서 문제가 되는 부분을 수정하여 배포 가능한 버전을 만들기에는 시간도 많이 소요되고 안정성을 보장하기도 어렵기 때문이다.</p>
<img src="/img/github-collaboration-18-1.png" width="700" height="500">
<img src="/img/github-collaboration-18-2.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// hotfix 브랜치(hotfix-1.2.1)를 &apos;master&apos; 브랜치에서 분기(유일함)</span><br><span class="line">$ git chekcout -b hotfix-1.2.1 master</span><br><span class="line"></span><br><span class="line">/*문제가 되는 부분만을 빠르게 수정한다.*/</span><br><span class="line"></span><br><span class="line">/* 필요한 부분을 수정한 후 &apos;master&apos; 브랜치로 이동한다. */</span><br><span class="line">$git checkout master</span><br><span class="line">// &apos;master&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.</span><br><span class="line">$git merge --no-ff hotfix-1.2.1</span><br><span class="line"></span><br><span class="line">// 병합한 커밋에 새로운 버전 이름으로 태그를 부여한다.</span><br><span class="line">$git tag -a 1.2.1</span><br><span class="line"></span><br><span class="line">// &apos;master&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$git push origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* &apos;hotfix&apos; 브랜치의 변경 사항을 &apos;develop&apos; 브랜치에도 적용 */</span><br><span class="line">// develop 브랜치로 이동한다.</span><br><span class="line">$git checkout develop</span><br><span class="line"></span><br><span class="line">// &apos;develop&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.</span><br><span class="line">$git merge --no-ff hotfix-1.2.1</span><br><span class="line"></span><br><span class="line">// &apos;develop&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$git push origin develop</span><br><span class="line"></span><br><span class="line">// -d 옵션 : hotfix-1.2.1에 해당하는 브랜치를 삭제한다.</span><br><span class="line">$git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>
<ol>
<li>배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, ‘master’ 브랜치에서 hotfix 브랜치를 분기한다.(‘hotfix’ 브랜치만 master에서 바로 딸 수 있다.)</li>
<li>문제가 되는 부분만을 빠르게 수정한다.</li>
<li>다시 ‘master’ 브랜치에 병합(merge)하여 이를 안정적으로 다시 배포한다. 그리고 중앙 원격 저장소(origin)에 올린다.(push)</li>
<li>새로운 버전 이름으로 태그를 매긴다.</li>
<li>hotfix 브랜치에서의 변경 사항은 ‘develop’ 브랜치에도 병합(merge)한다. 이 develop 브랜치도 중앙 원격 저장소(origin)으로 push한다.</li>
<li>작업했던 hotfix 브랜치는 삭제한다.</li>
</ol>
<h2 id="추가-기능">추가 기능</h2>
<ul>
<li>fast forward : merge할 때 default로 지정된 방식인데, default로 merge를 할 경우 커밋 이력들이 표시된다.</li>
</ul>
<p>git checkout -b feature/login develop<br>
git commit<br>
git commit</p>
<p>git checkout develop<br>
git merge feature/login</p>
<p>을 수행하면 feature/login에서 수행했던 2번의 커밋 이력이 develop에 merge할 때 develop의 이력에 같이 표시된다.</p>
<ul>
<li>non fast forward :</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/05/12/how-to-collaborate-on-GitHub-3.html" target="_blank" rel="noopener">[GitHub] GitHub로 협업하는 방법[3] - Gitflow Workflow</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/23/Etc-Git-Flow-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/22/Etc-Github-Flow/"
                            aria-label=": 2일차 [Git] Github-Flow"
                        >
                            2일차 [Git] Github-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-22T17:00:40+09:00">
	
		    Jan 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>어제 Git-Flow를 공부해보았는데, 헷갈리는 부분이 너무 많다. 그래서 Github-Flow 방법에 대해서도 헷갈리는 부분이 많아 잘 정리된 블로그를 보고 공부했다.</p>
<p>&quot;사전 과제 Repository를 fork 떠서 수정하고 PR 날려주세요.&quot;라는 메일을 받았다. 나는 Github을 사용하고 이런 비슷한 방식으로 프로젝트를 진행해왔지만 이게 이 방식이 맞는지도 모르고 있었다.</p>
<h2 id="pull-request">Pull Request</h2>
<p>협업을 하다보면 Pull Request를 보내서 코드 리뷰를 거쳐 원격 저장소에 merge가 된다. 분명 중요하다. Pull Request를 위해서 아래와 같은 절차를 거쳤다.</p>
<ul>
<li>Fork</li>
<li>clone, remote 설정</li>
<li>branch 생성(안할 수도 있음)</li>
<li>수정 작업 후 add, commit, push</li>
<li>Pull Reqeust 생성</li>
<li>코드 리뷰, Merge Pull Request</li>
<li>Merge 이후 branch 삭제 및 동기화</li>
</ul>
<h3 id="fork">Fork</h3>
<ul>
<li>타켓 프로젝트의 저장소를 자신의 저장소로 Fork 한다.</li>
</ul>
<img src="/img/git_fork.png" width="700" height="500">
<h3 id="clone-remote-설정">Clone, remote 설정</h3>
<ul>
<li>fork로 생성한 본인 계정의 저장소에서 <strong>clone or download</strong> 버튼을 누르고 표시되는 url을 복사한다.</li>
</ul>
<img src="/img/git_clone.png" width="700" height="500">
<ul>
<li>Mac 기준에서 터미널을 켠다.</li>
<li>자신의 컴퓨터에서 작업을 하기 위해서 지정한 디렉토리로 가서 Fork한 저장소를 로컬에 Clone하기 위해서 아래의 명령어를 실행한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wayhome25/blog.github.io.git</span><br></pre></td></tr></table></figure>
<ul>
<li>이제, 로컬 저장소에 원격 저장소를 추가한다. 위 작업과 동일하게 github 저장소에서 <strong>clone or download</strong> 메뉴를 통해서 확인한 url을 사용한다.
<ul>
<li>원본 프로젝트 저장소 (직접 추가 필요)</li>
<li>fork한 로컬 프로젝트 (origin이라는 별명으로 기본으로 추가되어 있다. 따로 추가할 필요 없음)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 원본 프로젝트 저장소를 원격 저장소로 추가</span><br><span class="line"># 보통 upstream 사용</span><br><span class="line">$ git remote add real-blog(별명) https://github.com/원본계정/blog.github.io.git</span><br><span class="line"></span><br><span class="line"># 원격 저장소 설정 현황 확인방법</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="branch-생성">branch 생성</h3>
<ul>
<li>자신의 로컬 컴퓨터에서 코드를 추가하는 작업은 branch를 만들어서 진행한다.</li>
</ul>
<p><strong>개발을 하다보면 코드를 여러 개로 복사해야 하는 일이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는데, 이렇게 독립적으로 개발하는 것이 브랜치다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git branch develop master</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line"># 하나의 명령어로 축약 가능</span><br><span class="line">git checkout -b develop</span><br><span class="line"></span><br><span class="line"># 이제 2개의 브랜치가 존재한다.</span><br><span class="line">git branch</span><br><span class="line">* master</span><br><span class="line">develop</span><br></pre></td></tr></table></figure>
<h3 id="수정-작업-후-add-commit-push">수정 작업 후 add, commit, push</h3>
<ul>
<li>자신이 사용하는 코드 편집 툴을 활용하여 수정 작업을 진행한다.</li>
<li>작업이 완료되면 add, commit, push를 통해서 자신의 github repository(origin)에 수정사항을 반영한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># add, commit 같이 수행</span><br><span class="line">git commit -a -m &quot;Modify code&quot;</span><br><span class="line"></span><br><span class="line"># push</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>
<ul>
<li>push 진행 시에 branch 이름을 명시해주어야 한다.</li>
<li>위의 명령어는 develop 브랜치의 수정 내역을 origin으로 푸시한다는 것이다.</li>
</ul>
<h3 id="pull-request-생성">Pull Request 생성</h3>
<ul>
<li>push 완료 후 본인 계정의 github 저장소에 들어오면 <strong>Compare &amp; pull request</strong> 버튼이 활성화 되어 있다.</li>
<li>해당 버튼을 선택하여 메시지를 작성하고 <strong>PR</strong>을 생성한다.(날린다.)</li>
</ul>
<img src="/img/git_PR1.png" width="700" height="500">
<img src="/img/git_PR2.png" width="700" height="500">
<h3 id="코드-리뷰-merge-pull-request">코드 리뷰, Merge Pull Request</h3>
<ul>
<li>PR을 받은 원본 저장소 관리자는 코드 변경 내역을 확인하고 Merge 여부를 결정하기 전에 Review를 남긴다.</li>
<li>팀의 정책에 따라 Review가 1개 이상이면 Merge를 하는 등의 조건이 있을 수 있다.</li>
</ul>
<h3 id="merge-이후-동기화-및-branch-삭제">Merge 이후 동기화 및 branch 삭제</h3>
<ul>
<li>원본 저장소에 Merge가 완료되면 로컬 코드와 원본 저장소의 코드를 동기화 한다.</li>
<li>작업하던 로컬의 branch를 삭제한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 코드 동기화</span><br><span class="line">git pull real-blog(remote 별명)</span><br><span class="line"></span><br><span class="line">## ex</span><br><span class="line">git pull upstream</span><br><span class="line"></span><br><span class="line"># 브랜치 삭제(develop 브랜치 삭제)</span><br><span class="line">git branch -d develop(브랜치 별명)</span><br></pre></td></tr></table></figure>
<ul>
<li>나중에 추가로 작업할 일이 있으면 <code>git pull real-blog</code>명령을 통해 원본 저장소와 동기화를 먼저 진행하고, 세번째부터 일곱번째 작업을 반복한다.</li>
</ul>
<h2 id="느낀-점">느낀 점</h2>
<p>지금까지 내가 했던 방식이 Github-Flow 방법이라는 것을 알게 되었다. 원격 저장소를 자신의 개인 저장소로 fork 하는 방식으로 간단하게 사용할 수 있는 방법이다. 어제 공부했던 브랜치 전략은 <strong>Git-Flow</strong>로 브랜치를 나누어서 작업을 진행하는 것인데, 조금 더 복잡하다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://wayhome25.github.io/git/2017/07/08/git-first-pull-request-story/" target="_blank" rel="noopener">git 초보를 위한 풀리퀘스트(pull request) 방법</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/22/Etc-Github-Flow/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/21/Etc-Git-Flow/"
                            aria-label=": 1일차 [Git] Git-Flow"
                        >
                            1일차 [Git] Git-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-21T21:35:23+09:00">
	
		    Jan 21, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>Git-Flow</code> 전략에 대해서 알아볼 예정이다. 기존에 사용하던 방법은 이름을 몰랐고 그냥 프로젝트 팀원한테 배웠던 방식을 사용했다. 이름은 나중에 찾아보니 <strong>Github-Flow</strong>였다. Git-Flow를 알아보기 전에 Github-Flow가 무엇인지 알고 넘어가보자.</p>
<h2 id="github-flow">Github-Flow</h2>
<p>기본적으로 Git Repository를 살펴보면 Repository는 Upstream Repository(이하 Upstream Repository), Origin Remote Repository(이하 Origin Repository), Local Repository 이렇게 3가지 부분으로 구성된다.</p>
<ul>
<li><strong>Upstream Repository</strong> : 개발자들이 공유하는 저장소로 최신 소스코드가 저장되어 있는 원격 저장소.</li>
<li><strong>Origin Repository</strong> : Upstream Repository를 Fork한 원격 개인 저장소.</li>
<li><strong>Local Repository</strong> : 내 컴퓨터에 저장되어 있는 개인 저장소.</li>
</ul>
<img src="/img/github_flow_repository_structure.png" width="700" height="500">
<p>위 그림은 Git Repository 구성과 워크플로우를 설명하고 있다. Local Repository에서 작업을 완료한 후 작업 브랜치를 Origin Repository에 push한다. 그리고 Github에서 Origin Repository에 push한 브랜치를 Upstream Repository로 merge하는 <strong>Pull Request</strong>를 생성하는 코드리뷰를 거친 후 merge 한다. 다시 새로운 작업을 할 때 Local Repository에서 Upstream Repository를 pull 한다.</p>
<p>이런 워크 플로우를 두는 데에는 한 가지 이유가 있다고 한다. 그 이유는 개발자들의 실험정신(?)을 펼치기 위해서이다. 모두가 공유하고 있는 Repository에서 실험하기에는 위험이 있다고 생각하고, Forked한 Repository를 두면 부담 없이 실험들을 해볼 수 있다고 한다. 무엇보다 이런 구조로 가져갔을 때 개발자가 해야 할 작업들이 <strong>중앙집중식 워크플로우</strong>보다 일이 늘거나 크게 복잡해지지도 않는다고 한다.</p>
<h2 id="git-flow">Git-Flow</h2>
<p>Git-Flow를 사용했을 때 작업을 어떻게 하는지 살펴보기 전에 먼저 Git-Flow에 대해서 간단히 살펴보도록 하겠다.<br>
Git-Flow에는 5가지 종류의 브랜치가 존재한다. 항상 유지되는 메인 브랜치들(masger, develop)과 일정 기간 동안반 유지되는 보조 브랜치들(feature, release, hotfix)이 있다.</p>
<ul>
<li>master : 제품으로 출시될 수 있는 브랜치(배포하기 위함)</li>
<li>develop : 다음 출시 버전을 개발하는 브랜치(이쪽으로 merge함)</li>
<li>feature : 기능을 개발하는 브랜치(기능별로 feature를 나눔)</li>
<li>release : 이번 출시 버전을 준비하는 브랜치</li>
<li>hotfix : 출시 버전에서 발생한 버그를 수정하는 브랜치</li>
</ul>
<img src="/img/gitflow_1.png" width="700" height="500">
<center>Git-flow</center>
<p>위 그림을 일반적인 개발 흐름으로 살펴보자.</p>
<p>처음에는 master와 develop 브랜치가 존재한다. 물론 develop 브랜치는 master에서부터 시작된 브랜치이다. develop 브랜치에서는 상시로 버그를 수정한 커밋들이 추가된다. 새로운 기능 추가 작업이 있는 경우 develop 브랜치에서 feature 브랜치를 생성한다.</p>
<p>feature 브랜치는 언제나 develop 브랜치에서부터 시작하게 된다. 기능 추가 작업이 완료되었다면 feature 브랜치는 develop 브랜치로 merge 된다. develop에 이번 버전에 포함되는 모든 기능이 merge 되었다면 <code>QA</code>를 하기 위해 develop 브랜치에 수정된다. QA를 무사히 통과했다면 release 브랜치를 master와 develop 브랜치로 merge 한다. 마지막으로 출시된 master 브랜치에서 버전 태그를 추가한다.</p>
<p>그렇다면 우아한 형제들의 안드로이드 개발팀에서는 어떻게 <code>Git-Flow</code>를 지키는지 살펴보도록 하자.</p>
<p>##작업을 할 때 지켜야할 서로 간의 약속**</p>
<ol>
<li>작업을 시작하기 전에 JIRA 티켓을 생성한다.</li>
<li>하나의 티켓은 되도록 하나의 커밋으로 한다.</li>
<li>커밋 그래프는 최대한 단순하게 가져간다.</li>
<li>서로 공유하는 브랜치의 커밋 그래프는 함부로 변경하지 않는다.</li>
<li>리뷰어에게 꼭 리뷰를 받는다.</li>
<li>자신의 Pull Request는 스스로 merge 한다.</li>
</ol>
<h2 id="우아한-형제들-git-flow">우아한 형제들 Git-Flow</h2>
<p>아래에는 우아한 형제들에서 실제로 어떻게 작업하는지 알아보겠다. 아래의 Repository와 Branch는 앞으로 설명을 할 때 나오기 때문에 알아두고 가면 한결 수월하게 볼 수 있을 것이다.</p>
<ul>
<li>Repositories
<ul>
<li>upstream(Upstream Repository) : 중앙 원격 저장소</li>
<li>origin(Origin Repository) : 내 원격 저장소</li>
</ul>
</li>
<li>Branches
<ul>
<li>feature-user(사용자 관련 기능을 구현하는 feature branch)</li>
<li>bfm-100_login_layout(사용자 관련 기능 중 레이아웃 작업 branch)</li>
</ul>
</li>
</ul>
<p><strong>1.티켓 처리하기</strong></p>
<p>앞서 '작업을 할 때 지켜야 할 서로 간의 약속’에서 **하나의 티켓은 되도록 하나의 커밋으로 한다.**라고 했다. 그래서 기능을 구혀하기 전에 여러 개의 티켓으로 작업을 먼저 나누게 된다. 나눠진 티켓 중 <strong>로그인 레이아웃 생성</strong>이라는 티켓이 있고 이 티켓을 처리한다고 가정하고 살펴보겠다.</p>
<ol>
<li>
<p>upstream/feature-user 브랜치에서 작업 브랜치(bfm-100_login_layout)를 생성한다.<br>
<code>git checkout -b bfm-100_login_layout --track upstream/feature-user</code></p>
</li>
<li>
<p>작업 브랜치에서 소스코드를 수정한다.</p>
</li>
<li>
<p>작업 브랜치에서 변경 사항을 커밋한다.<br>
<code>git commit -m &quot;BFM-100 로그인 화면 레이아웃 생성&quot;</code></p>
</li>
<li>
<p>만약 커밋이 불필요하게 여러 개로 나뉘어져 있다면 squash?를 한다.(커밋 2개를 합쳐야 한다면)<br>
<code>git rebase -i HEAD~2</code></p>
</li>
<li>
<p>작업 브랜치를 upstrea/feature-user에 rebase 한다.</p>
</li>
<li>
<p>작업 브랜치를 origin에 push한다.</p>
</li>
<li>
<p>Github에서 bfm-100_login_layout 브랜치를 feature-user 브랜치에 merge하는 Pull Request를 생성한다.</p>
</li>
<li>
<p>같은 feature를 개발하는 동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다. 만약 혼자 featur를 개발한다면 1~2명의 동료에게 리뷰 승인을 받은 후 Pull Request를 merge 한다.</p>
</li>
</ol>
<p>위의 절차에서 4,5번 작업을 수행하는 이유는 커밋 그래프를 단순하게 가져가고 의미있는 커밋들로 관리하기 위함이다.</p>
<p>4번 작업을 예로 들면, ‘BFM-100 로그인 화면 레이아웃 생성’ 작업을 할 때 로그인 화면의 레이아웃을 생성한 커밋 하나와 view의 약간의 간격을 조정한 커밋 하나, 그리고 view의 id를 변경한 커밋하나, 이렇게 3개의 커밋으로 분리된 상태이다. 이 3개의 커밋이 그 의미를 나눌 필요가 없거나 코드 리뷰를 도와주지도 못한다면 커밋을 분리하는 것은 불필요하다고 판단하고 하나의 커밋으로 합치게 된다.</p>
<p>물론 항상 하나의 커밋으로 합쳐야만하는 것은 아니다. 하나의 티켓에 대한 작업이라도 커밋이 분리되어 있는게 낫다고 생각이 든다면 2개 이상의 커밋으로 나눌 수도 있다. 그러나 대부분은 티켓을 더 작게 나누지 못한 경우일 가능성이 높다.</p>
<p><strong>2. develop 변경사항을 feature로 가져오기</strong>(Optional)</p>
<p>작업을 할 때 브랜치의 수명은 되도록 짧게 가져가는게 좋지만, feature 브랜치에서 기능을 완료하는데 해야 할 작업들이 많아서 오래 걸리는 경우들이 있다. 그러다 보면 develop에 추가된 기능들이 필요한 경우가 종종 생기게 된다. 그럴 때는 feature 브랜치에 develop의 변경사항들을 가져와야 한다.</p>
<ol>
<li>feature-user 브랜치에 upstream/develop 브랜치를 merge 한다.</li>
<li>upstream/develop의 변경사항이 merge된 feature-user를 upstream에 push 한다.</li>
</ol>
<p><strong>3. 완료된 기능을 이번 출시 버전에 포함시키기</strong></p>
<p>드디어 feature-user 브랜치에서 작업하던 기능이 완료되었다. 이젠 feature 브랜치를 이번 출시 버전에 포함시키기 위해서 develop에 merge해야 한다.</p>
<ol>
<li>develop 브랜치에 upstream/feature-user 브랜치를 merge 한다.</li>
<li>upstream/feature-user 기능이 merge된 develop를 upstream에 push 한다.</li>
</ol>
<p><strong>4. QA 시작하기</strong></p>
<p>이번 버전에 포함되어야 할 기능들이 모두 완료되었다. 이제부터 출시 담당자가 해야 할 일이 많다. 출시 담당자는 QA를 시작하기 위해 먼저 release 브랜치를 develop 브랜치로부터 따서 생성하고 upstream에 push하여 release 브랜치를 공유한다.</p>
<ol>
<li>release-1.0.0 브랜치를 생성한다.</li>
<li>release-1.0.0 브랜치를 upstream에 push 한다.</li>
</ol>
<p><strong>5. QA 중 버그 수정하기</strong></p>
<p>개발을 완료한 후 QA 중 버그가 발생하지 않으면 좋겠지만 항상 생각치 못한 예외 상황들이 발생하게 된다. 예외 상황이 발생할 때마다 버그 티켓이 하나씩 생성되는데 이 티켓들을 모두 해결해야만 앱을 출시할 수 있다. 버그 티켓들도 티켓이기 때문에 '1. 티켓 처리하기’와 같은 방법으로 처리한다.</p>
<ol>
<li>release 브랜치에서 버그 티켓에 대한 브랜치를 생성한다.</li>
<li>버그를 수정한다.</li>
<li>버그 티켓에 대해 생성한 브랜치를 작업 브랜치라 하고 작업 브랜치에서 버그 수정 사항을 커밋한다.</li>
<li>작업 브랜치를 origin[ develop? ]에 push 한다.</li>
<li>Github에서 bfm-101_bug_login_id_max_length 브랜치를 release-1.0.0에 merge 하는 Pull Request를 생성한다.</li>
<li>동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다.</li>
</ol>
<p><strong>6. 앱출시</strong></p>
<p>발생하는 버그들을 모두 수정했다면 이젠 출시를 준비할 때이다. release 브랜치를 master 브랜치와 develop 브랜치에 merge하고 마지막으로 master 브랜치에서 버전 태그를 달아준다.</p>
<ol>
<li>release 브랜치를 최신 상태로 갱신한다.</li>
<li>release 브랜치를 develop 브랜치에 merge 한다.</li>
<li>develop 브랜치를 upstream에 push 한다.</li>
<li>release 브랜치를 master 브랜치에 merge 한다.</li>
<li>1.0.0 태그를 추가한다.</li>
<li>master 브랜치와 1.0.0 태그를 upstream에 push 한다.</li>
</ol>
<h3 id="중앙집중식-워크플로우">중앙집중식 워크플로우</h3>
<img src="/img/centralized_workflow.png" width="700" height="500">
<p>중앙집중식에서 개발자 두 명이 중앙저장소를 clone하고 각자 수정하는 상황을 생각해보자. 한 개발자가 자신이 한 일을 커밋하고 나서 아무 문제 없이 서버에 push한다. 그러면 다른 개발자는 자신의 일을 커밋하고 push 하기 전에 첫 번째 개발자가 한 일을 먼저 Merge 해야 한다. Merge를 해야 첫 번째 개발자가 작업한 내용을 덮어쓰지 않는다. 이런 개념은 Subversion과 같은 중앙집중식 버전 관리 시스템에서 사용하는 방식이고 Git에서도 당연히 이런 워크플로우를 사용할 수 있다.</p>
<p>팀이 작거나 이미 중앙집중식에 적응한 상황이라면 이 워크플로우에 따라 git을 도입하여 사용할 수 있다. 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다.</p>
<p>A와 B가 동시에 같은 부분을 수정하는 상황을 생각해보자. A가 먼저 작업을 끝내고 수정한 내용을 서버로 push한다. B도 마찬가지로 작업을 끝내고 수정한 내용을 서버로 push 하려 하지만 서버가 바로 받아주지 않는다. 서버에는 A가 수정한 내용이 추가되었기 때문에 push 하기 전에 Fetch로 받아서 Merge 한 후 Push 할 수 있다 이런 개념을 개발자에게 익숙해서 거부감 없이 도입할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html" target="_blank" rel="noopener">우린 Git-flow를 사용하고 있어요</a></li>
</ul>
<p><strong>회고</strong></p>
<p>Github-flow가 편하다는 생각이 아직 사라지지 않는다. 왜냐하면 git-flow는 브랜치가 많고 git의 명령어들이 많이 나와서 헷갈리는 부분이 너무 많다. 하지만 여러 사람이 협업할 때 브랜치를 기능별로 나눠서 하게 되기 때문에 효율이 좋은 것 같다.</p>
<p>아직 헷갈리는 부분이 많아서 자료를 조금 더 참고해서 공부해야겠다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/21/Etc-Git-Flow/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/2019/01/archives/2/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 1 of 4</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
