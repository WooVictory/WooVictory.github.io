
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/14/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/23/Etc-Git-Flow-2/"
                            aria-label=": 3일차 [Git] Git-Flow"
                        >
                            3일차 [Git] Git-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-23T17:51:47+09:00">
	
		    Jan 23, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>어제 Git-Flow를 공부하면서 기초 개념과 용어에 대한 혼란이 너무 많이 왔었다. 오늘이 3일차인데, 아직 Git에서 헤매는 부분이 너무 많다.</p>
<p>오늘의 일정은 아래와 같은 일정이었다. 이런 일정을 <strong>snippet</strong>이라는 용어로 부른다.</p>
<p><strong>[오늘의 업무]</strong></p>
<ul>
<li>Daily Scrum [매일의 상태를 체크]</li>
<li>코드 컨벤션 구체화</li>
<li>Git 과제 완료</li>
<li>github 초기 설정</li>
<li>기능 정의서 정리</li>
</ul>
<p>오늘의 업무를 일찍 끝내서 남은 시간은 Git을 공부하는데 투자했다. 먼저, 간단한 용어를 정리하고 <strong>Git-Flow</strong>에 대한 내용을 정리할 예정이다.</p>
<h2 id="git-vs-github">Git vs Github</h2>
<ul>
<li><code>Git</code>은 대표적인 <strong>분산 버전 관리 시스템</strong>으로, 사용자의 프로젝트에 포함된 파일의 변경 사항을 관리하고 추적하는 도구이다.</li>
<li><code>Github</code>은 Git을 사용하는 프로젝트를 지원하는 <strong>웹 호스팅 서비스</strong>이다.</li>
</ul>
<h2 id="git-pointer">#Git Pointer</h2>
<p><strong>HEAD</strong></p>
<ul>
<li>현재 Branch가 가리키는 가장 최근 Commit</li>
</ul>
<p><strong>Master Branch</strong></p>
<ul>
<li>가장 기본이 되는 Branch</li>
<li>Master branch는 Git에서 기본으로 생성해준다.</li>
</ul>
<p><strong>origin</strong></p>
<ul>
<li>원격 Repository를 뜻하는 Alias</li>
<li>Alias이므로 이름을 변경할 수 있다.</li>
</ul>
<p><strong>origin/master</strong></p>
<ul>
<li>원격 Repository의 Master branch</li>
</ul>
<p><strong>origin/HEAD</strong></p>
<ul>
<li>원격 Repository가 바라보는 버전</li>
</ul>
<h2 id="gitflow-workflow">Gitflow Workflow</h2>
<ul>
<li>nvie.com의 <strong>빈센트 드리센</strong>이 제안한 것이다.</li>
<li>대형 프로젝트에도 적용할 수 있는 좀 더 엄격한 작업 절차를 갖는다.</li>
<li>Gitflow Workflow의 핵심 컨셉은 master와 develop, 두 개의 메인 브랜치를 이용한다는 것이다.
<ul>
<li><strong>master branch</strong> : 릴리즈 이력을 관리하기 위해 사용. 즉, 배포 가능한 상태만을 관리한다.</li>
<li><strong>develop branch</strong> : 기능 개발을 위한 브랜치들을 병합하기 위해 사용. (모든 기능이 추가되고 버그가 수정되어 배포 가능한 상태라면 ‘master’ 브랜치에 merge 한다.) 평소에는 이 브랜치를 기반으로 개발을 진행한다.</li>
</ul>
</li>
</ul>
<h2 id="1중앙-원격-저장소-자신의-원격-저장소-로컬-저장소의-개념">1.중앙 원격 저장소, 자신의 원격 저장소, 로컬 저장소의 개념</h2>
<ul>
<li>
<p>중앙 원격(remote) 저장소</p>
<ul>
<li>여러 명이 같은 프로젝트를 관리하는 데 사용하는 그룹 계정의 중립된 원격 저장소</li>
<li>Organization을 만들어 사용할 수 있다. Organization의 사용자와 저장소는 팀으로 관리되고 저장소의 권한 설정도 팀으로 관리한다.</li>
</ul>
</li>
<li>
<p>자신의 원격(remote) 저장소</p>
<ul>
<li>remote repository라고 불린다.</li>
<li>파일이 Github 전용 서버에서 관리되는 원격 저장소</li>
</ul>
</li>
<li>
<p>로컬(local) 저장소</p>
<ul>
<li>local repository라고 불린다.</li>
<li>내 PC에 파일이 저장되는 개인 전용 저장소, 지역 저장소의 개념이다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-1.png" width="700" height="500">
<img src="/img/github-collaboration-2.png" width="700" height="500">
<h2 id="2-프로젝트-참여자는-git-clone-명령으로-로컬-저장소를-만든다">2. 프로젝트 참여자는 git clone 명령으로 로컬 저장소를 만든다.</h2>
<p>git clone 명령으로 중앙 원격 저장소(remote repository)를 복제하여 자신의 로컬 저장소(local repository)를 만들 수 있다. 프로젝트 참여자는 clone 한 이 로컬 저장소에서 작업을 수행하면 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 터미널에서 자신이 원하는 디렉토리로 이동한 후 clone 명령어 입력</span><br><span class="line"></span><br><span class="line">git clone [중앙 remote repository URL]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>git clone</code> 명령은 아래의 명령들을 포함한 작업이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 해당 디렉토리를 빈 Git 저장소로 만드는 작업</span><br><span class="line">git init</span><br><span class="line">// 현재 작업 중인 Git 저장소에 팀의 중앙 원격 저장소를 추가한다. 이름을 origin으로 짓고 긴 서버 주소(URL) 대신 사용한다. 마치 별명과 같다.</span><br><span class="line">git remote add origin [중앙 remote repository URL]</span><br><span class="line">// 중앙 원격 저장소(origin)의 master 브랜치 데이터를 로컬에 가져오기만 하는 작업</span><br><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<blockquote>
<p>fetch와 pull의 차이</p>
</blockquote>
<ul>
<li>fetch : 원격 저장소의 데이터를 로컬에 가져오기만 하는 작업</li>
<li>pull : 원격 저장소의 데이터를 가져와 자동으로 병합까지 하는 작업</li>
<li>즉, 단순히 원격 저장소의 내용을 확인만 하고 로컬 데이터와 병합은 하고 싶지 않은 경우에는 fetch 명령어를 사용한다.</li>
<li><code>pull = fetch + merge</code></li>
</ul>
<img src="/img/github-collaboration-3.png" width="700" height="500">
<img src="/img/github-collaboration-4.png" width="700" height="500">
<h2 id="3먼저-할-일은-develop-브랜치를-만드는-것이다">3.먼저 할 일은 Develop 브랜치를 만드는 것이다.</h2>
<p><strong>방법[1] : GUI 도구를 이용한 생성(이 방법을 추천)</strong></p>
<p>‘master’ 브랜치를 기준으로 develop 브랜치를 만든다. 여기서는 Pull Request를 이용할 것이기 때문에 <strong>GUI 도구를 이용한 생성 방법</strong>을 사용한다.[이 방법을 추천한다고 한다!!]</p>
<img src="/img/github-collaboration-5.png" width="700" height="500">
<ul>
<li>Github 페이지에서 <strong>Branch:master</strong>를 클릭한 후 새로 생성할 브랜치의 이름을 <strong>develop</strong>으로 적는다. [이때, branch를 생성할 수 있는 사용자는 Owner 권한이 있는 사용자]</li>
</ul>
<img src="/img/github-collaboration-6-1.png" width="700" height="500">
<ul>
<li>새로 생성한 develop branch를 <strong>default branch</strong>로 설정해야 한다.</li>
</ul>
<img src="/img/github-collaboration-6-3.png" width="700" height="500">
<ul>
<li><strong>develop branch를 default branch로 설정하는 이유는?</strong>
<ul>
<li>Git-flow에서 평소에는 develop branch를 기반으로 개발을 진행하기 때문에 <code>git push origin some-feature</code>(내 로컬 저장소의 some-feature branch를 중앙 원격 저장소로 올리는 명령)를 한 후, Github 페이지에서 해당 some-feature branch에 대해 merge를 할 때 중앙 원격 저장소의 ‘master’ branch가 아닌 default로 설정되어 있는 <strong>develop</strong>에 병합하도록 설정하기 위함이다.</li>
</ul>
</li>
</ul>
<p><strong>방법[2] : 팀 구성원 중 한 명이 자신의 로컬 저장소에 빈 develop 브랜치를 만들고 중앙 저장소로 푸쉬</strong></p>
<img src="/img/github-collaboration-7.png" width="700" height="500">
<ul>
<li>이 경우는 팀원 중 한 명이 자신의 로컬 저장소에 빈 develop branch를 생성한다.
<ul>
<li><code>git branch develop</code></li>
</ul>
</li>
<li>그 다음, 중앙 원격 저장소(origin)에 develop branch를 푸시한다.
<ul>
<li><code>git push -u origin develop</code></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># develop 브랜치 생성</span><br><span class="line">git branch develop</span><br><span class="line"></span><br><span class="line"># 중앙 원격 저장소 origin으로 develop branch push</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure>
<ul>
<li>그런 다음 Github 페이지에서 자신이 push한 ‘develop’ branch를 병합해달라는 Pull Request를 날린다.</li>
</ul>
<img src="/img/github-collaboration-7-1.png" width="700" height="500">
<ul>
<li>프로젝트 관리자는 해당 pull request를 merge 하여 새로운 ‘develop’ branch를 중앙 원격 저장소에 생성한다.</li>
</ul>
<img src="/img/github-collaboration-7-2.png" width="700" height="500">
<ul>
<li>그 다음에는 방법[1]과 같은 방법으로 develop branch를 default branch로 설정한다.</li>
</ul>
<h2 id="4-팀-구성원-모두가-gitflow-workflow를-적용할-준비를-한다">4. 팀 구성원 모두가 Gitflow workflow를 적용할 준비를 한다.</h2>
<p>이제 팀 구성원들은 중앙 저장소를 복제하고(처음에 clone 했으면 넘어가도 좋다.), 중앙 저장소와 연결된 개발 브랜치를 만들어야 한다.</p>
<img src="/img/github-collaboration-8.png" width="700" height="500">
<figure class="highlight plain"><figcaption><span>checkout -b develop origin/develop```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">이제 팀 구성원 모두가 이 워크플로우를 적용하기 위한 준비가 되었다. 다음 단계로 넘어가보자.</span><br><span class="line"></span><br><span class="line">## 5. 설명을 위해 현재 로컬에서 작업 중인 branch 위치를 표시한다.</span><br><span class="line"></span><br><span class="line">중앙 원격 저장소에는 master, develop branch가 있고, 자신의 로컬 저장소에도 master, develop branch와 로그인 기능을 구현한 feature/login branch가 있다고 가정한다. 또한, 현재는 master branch에서 작업 중이라고 가정하고 아래와 같이 작업 중인 위치를 표시한다.</span><br><span class="line">(Gitflow Workflow에서는 대부분의 작업이 **develop** branch에서 이루어진다.)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/img/github-collaboration-9.png&quot; width=&quot;700&quot; height=&quot;500&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6. 새로운 기능 개발을 위해 격리된 branch를 만든다.</span><br><span class="line"></span><br><span class="line">로컬 저장소에서 branch를 따고, 코드를 수정하고, 변경 내용을 커밋한다. 이때, &apos;master&apos; branch에서 기능 개발을 위한 브랜치를 따는 것이 아니라 우리가 앞서 설정에서 default branch로 설정한 &apos;**develop**&apos; branch에서 따야한다.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">git checkout -b [branch name] develop</span><br><span class="line"></span><br><span class="line"># 아래의 두 명령어를 합하면 위와 같다.</span><br><span class="line">git branch [branch name] develo</span><br><span class="line">git checkout [branch name]</span><br></pre></td></tr></table></figure>
<img src="/img/github-collaboration-10.png" width="700" height="500">
<h2 id="7-로컬-저장소의-새로운-기능-브랜치를-중앙-원격-저장소remote-repository에-푸시한다">7. 로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 푸시한다.</h2>
<ul>
<li>새로 만든 브랜치(feature/login branch)에 새로운 기능에 대한 내용을 커밋한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -a -m &quot;Write commit message&quot;</span><br><span class="line"></span><br><span class="line"># 위의 명령어는 아래의 두 명령어를 합한 것</span><br><span class="line">$ git add . # 변경된 모든 파일을 스테이징 영역에 추가</span><br><span class="line">$ git add [some-file] # 스테이징 영역 some-file 추가</span><br><span class="line">$ git commit -m &quot;Write commit message&quot; # local 작업 작업 폴더에 history 하나를 쌓는다. [commit]</span><br></pre></td></tr></table></figure>
<ul>
<li>커밋을 완료했다면, 내가 작업한 내용을 포함한 브랜치(feature/login branch)를 중앙 원격 저장소에 올린다.</li>
<li><code>$git push origin feature/login branch</code></li>
<li>이는 로컬 저장소의 백업 역할을 할 뿐만 아니라, 다른 팀 구성원들이 나의 작업 내용과 진도를 확인할 수도 있어 좋은 습관이라 할 수 있다.</li>
</ul>
<p><strong>방법[1] : 팀이 pull request를 이용하는 경우</strong></p>
<ul>
<li>로컬 저장소의 새로운 기능 브랜치를 중앙 원격 저장소(remote repository)에 push한 후, 프로젝트 관리자에게 자신의 기여분을 반영해 달라는 pull request를 보낸다.<br>
= 새로 만든 기능 개발용 브랜치도 중앙 저장소에 올려서 팀 구성원들과 개발 내용에 대한 의견(코드 리뷰)등을 나눌 수 있다.</li>
<li>이후에는 모든 팀원이 변경한 코드 내용을 확인하고 마지막으로 확인한 팀원 또는 프로젝트 관리자가 변경 내용을 중앙 원격 코드 베이스에 병합(merge)하는 작업을 한다.</li>
<li>이는 일종의 로컬 저장소 백업 역할을 하기도 한다.</li>
</ul>
<blockquote>
<p>Pull Request란?</p>
</blockquote>
<ul>
<li>기능 개발을 끝내고 master에 바로 병합(merge)하는 것이 아니라, 브랜치를 중앙 원격 저장소에 올리고 병합(merge)해달라고 요청하는 것이다.</li>
</ul>
<img src="/img/github-collaboration-11-1.png" width="700" height="500">
<ul>
<li>GUI 도구를 이용한 pull request
<ol>
<li>Github 페이지에서 <strong>Pull Request</strong> 버튼을 이용하면, 어떤 branch를 제출할 지 정할 수 있다.</li>
<li>기능을 구현한 branch(여기서는 feature/login branch)를 프로젝트의 중앙 원격 저장소의 develop branch에 병합해 달라고 요청한다.</li>
</ol>
</li>
</ul>
<img src="/img/github-collaboration-11-2.png" width="700" height="500">
<ul>
<li>GUI 도구를 이용한 merge
<ol>
<li>Github 페이지에서 Pull Request 버튼을 누른 후, File changed 탭에서 변경 내용을 확인한다.</li>
<li>Conversation 탭으로 이동하여 Confirm merge를 하면 중앙 원격 코드 베이스(‘develop’ branch)에 병합된다.</li>
<li>위에서 ‘develop’ branch를 default branch로 설정했기 때문에 자동으로 ‘develop’ branch로 merge 도니다.</li>
<li>충돌이 일어난 경우는 팀원들과 합의 하에 충돌 내용을 수정한 후 병합을 진행한다.</li>
</ol>
</li>
</ul>
<p><strong>방법[2] : 팀이 pull request를 이용하지 않는 경우</strong></p>
<ul>
<li>기능 브랜치를 병합하기 전에 반드시 자신의 로컬 저장소 develop branch에 중앙 원격 저장소의 변경 내용을 반영해서 최신 상태로 만들어야 한다.</li>
<li>또한 자신이 직접 새로운 기능에 대한 병합을 할 때, ‘master’ branch에 병합하지 않도록 주의해야 한다.</li>
</ul>
<img src="/img/github-collaboration-12-1.png" width="700" height="500">
<img src="/img/github-collaboration-12-2.png" width="700" height="500">
<img src="/img/github-collaboration-12-3.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -u 옵션 : 새로운 기능 브랜치와 동일한 이름으로 중앙 원격 저장소의 브랜치로 추가한다.</span><br><span class="line"></span><br><span class="line">// 로컬의 기능 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$ git push -u origin feature/login branch</span><br><span class="line"></span><br><span class="line">// -u 옵션으로 한 번 연결한 후에는 옵션 없이 아래의 명령만으로 기능 브랜치를 올릴 수 있다.</span><br><span class="line">$ git push origin feature/login branch</span><br></pre></td></tr></table></figure>
<h2 id="8-중앙-원격-저장소와-자신의-로컬-저장소를-동기화하기-위해-로컬-저장소의-branch를-develop-branch로-이동한다">8. 중앙 원격 저장소와 자신의 로컬 저장소를 동기화하기 위해 로컬 저장소의 branch를 develop branch로 이동한다.</h2>
<p>// 로컬 저장소의 branch를 develop branch로 이동<br>
<code>$git checkout develop</code></p>
<img src="/img/github-collaboration-13.png" width="700" height="500">
<h2 id="9-중앙-원격-저장소의-코드-베이스에-새로운-커밋이-있다면-다음과-같이-가져온다">9. 중앙 원격 저장소의 코드 베이스에 새로운 커밋이 있다면 다음과 같이 가져온다.</h2>
<p>중앙 원격 저장소(origin)의 메인 코드 베이스(‘develop’ branch)가 변경되었으므로, 프로젝트에 참여하는 모든 개발자가 자신의 로컬 저장소를 동기화해서 최신 상태로 만들어야 한다.</p>
<ul>
<li><code>$git pull origin develop</code>
<ul>
<li>중앙 원격 저장소(origin)의 변경 내용을 develop 브랜치에 반영해서 동기화한다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-14.png" width="700" height="500">
<img src="/img/github-collaboration-15.png" width="700" height="500">
<h2 id="10-새로운-기능을-추가하기-위해서-그-작업에-대한-branch를-생성하여-작업한다">10. 새로운 기능을 추가하기 위해서 그 작업에 대한 branch를 생성하여 작업한다.</h2>
<ul>
<li>중앙 원격 저장소와 동기화된 로컬 저장소의 ‘develop’ branch에서 새로운 작업에 대한 branch를 생성하여 다른 작업을 한다. 앞에서 했던 것과 동일하게 하면 된다.</li>
</ul>
<img src="/img/github-collaboration-16.png" width="700" height="500">
<ul>
<li>local에서 완성한 이전 작업 브랜치는 삭제한다.
<ul>
<li><code>$git branch -d feature/login</code></li>
</ul>
</li>
</ul>
<h2 id="11-배포하기">11. 배포하기</h2>
<p>만약 <strong>develop</strong> 브랜치에서 버전 1.2에 대한 기능이 모두 구현이 완료 되었으면 배포를 위한 전용 브랜치를 사용하여 배포 과정을 캡슐화 한다. 이렇게 함으로써 한 팀이 해당 배포를 준비하는 동안 다른 팀은 다음 배포를 위한 기능 개발을 계속할 수 있다. 이게 Gitflow의 장점이라고 생각한다.</p>
<p>버전 번호를 부여한 새로운 ‘release’ branch는 develop branch로부터 생성한다.</p>
<img src="/img/github-collaboration-17-1.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// develp 브랜치로부터 release 브랜치(release-1.2)를 생성</span><br><span class="line">$git checkout -b release-1.2 develop</span><br></pre></td></tr></table></figure>
<ul>
<li>이렇게 release 브랜치를 만드는 순간부터 배포 사이클이 시작된다.
<ul>
<li>release 브랜치에서는 배포를 위한 최종적인 버그, 수정, 문서 추가 등 릴리즈와 직접적으로 관련된 작업을 수행한다.</li>
<li>직접적으로 관련된 작업들을 제외하고는 release 브랜치에 새로운 기능을 추가로 병합하지 않는다.</li>
</ul>
</li>
</ul>
<img src="/img/github-collaboration-17-2.png" width="700" height="500">
<img src="/img/github-collaboration-17-3.png" width="700" height="500">
<ul>
<li>release 브랜치에서 배포 가능한 상태가 되면(배포 준비가 완료되면)
<ul>
<li>배포 가능한 상태 : 새로운 기능을 포함한 상태로 모든 기능이 정상적으로 동작하는 상태를 말한다.</li>
</ul>
</li>
</ul>
<ol>
<li>‘master’ 브랜치에 병합한다.(이때, 병합한 커밋에 release 버전 태그를 부여!)</li>
<li>배포를 준비하는 동안 release 브랜치가 변경되었을 수 있으므로 배포 완료 후 ‘develop’ 브랜치에도 병합한다.</li>
<li>작업했던 release 브랜치는 삭제한다. 이때, 다음 번 배포(release)를 위한 개발 작업은 ‘develop’ 브랜치에서 계속 진행해 나간다.</li>
</ol>
<p><strong>방법[2] : 팀이 pull request를 이용하는 경우</strong></p>
<p>팀이 풀 리퀘스트를 통한 코드 리뷰를 하는 방식을 사용한다면 release 브랜치를 그대로 중앙 원격 저장소에 push 한 후 다른 팀원들의 리뷰나 확인 과정을 거쳐 'master’와 ‘develop’ branch에 병합한다.</p>
<h2 id="12-버그-수정하기">12. 버그 수정하기</h2>
<p>배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우(버그 발견…!), ‘master’ 브랜치에서 직접 브랜치[<strong>hotfix</strong> 브랜치]를 만들어 필요한 부분만을 수정한 후 다시 ‘master’ 브랜치에 병합하여 이를 배포해야 한다.</p>
<p>‘develop’ 브랜치에서 문제가 되는 부분을 수정하여 배포 가능한 버전을 만들기에는 시간도 많이 소요되고 안정성을 보장하기도 어렵기 때문이다.</p>
<img src="/img/github-collaboration-18-1.png" width="700" height="500">
<img src="/img/github-collaboration-18-2.png" width="700" height="500">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// hotfix 브랜치(hotfix-1.2.1)를 &apos;master&apos; 브랜치에서 분기(유일함)</span><br><span class="line">$ git chekcout -b hotfix-1.2.1 master</span><br><span class="line"></span><br><span class="line">/*문제가 되는 부분만을 빠르게 수정한다.*/</span><br><span class="line"></span><br><span class="line">/* 필요한 부분을 수정한 후 &apos;master&apos; 브랜치로 이동한다. */</span><br><span class="line">$git checkout master</span><br><span class="line">// &apos;master&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.</span><br><span class="line">$git merge --no-ff hotfix-1.2.1</span><br><span class="line"></span><br><span class="line">// 병합한 커밋에 새로운 버전 이름으로 태그를 부여한다.</span><br><span class="line">$git tag -a 1.2.1</span><br><span class="line"></span><br><span class="line">// &apos;master&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$git push origin master</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* &apos;hotfix&apos; 브랜치의 변경 사항을 &apos;develop&apos; 브랜치에도 적용 */</span><br><span class="line">// develop 브랜치로 이동한다.</span><br><span class="line">$git checkout develop</span><br><span class="line"></span><br><span class="line">// &apos;develop&apos; 브랜치에 hotfix-1.2.1 브랜치 내용을 병합한다.</span><br><span class="line">$git merge --no-ff hotfix-1.2.1</span><br><span class="line"></span><br><span class="line">// &apos;develop&apos; 브랜치를 중앙 원격 저장소(origin)에 올린다.</span><br><span class="line">$git push origin develop</span><br><span class="line"></span><br><span class="line">// -d 옵션 : hotfix-1.2.1에 해당하는 브랜치를 삭제한다.</span><br><span class="line">$git branch -d hotfix-1.2.1</span><br></pre></td></tr></table></figure>
<ol>
<li>배포한 버전에 긴급하게 수정을 해야 할 필요가 있을 경우, ‘master’ 브랜치에서 hotfix 브랜치를 분기한다.(‘hotfix’ 브랜치만 master에서 바로 딸 수 있다.)</li>
<li>문제가 되는 부분만을 빠르게 수정한다.</li>
<li>다시 ‘master’ 브랜치에 병합(merge)하여 이를 안정적으로 다시 배포한다. 그리고 중앙 원격 저장소(origin)에 올린다.(push)</li>
<li>새로운 버전 이름으로 태그를 매긴다.</li>
<li>hotfix 브랜치에서의 변경 사항은 ‘develop’ 브랜치에도 병합(merge)한다. 이 develop 브랜치도 중앙 원격 저장소(origin)으로 push한다.</li>
<li>작업했던 hotfix 브랜치는 삭제한다.</li>
</ol>
<h2 id="추가-기능">추가 기능</h2>
<ul>
<li>fast forward : merge할 때 default로 지정된 방식인데, default로 merge를 할 경우 커밋 이력들이 표시된다.</li>
</ul>
<p>git checkout -b feature/login develop<br>
git commit<br>
git commit</p>
<p>git checkout develop<br>
git merge feature/login</p>
<p>을 수행하면 feature/login에서 수행했던 2번의 커밋 이력이 develop에 merge할 때 develop의 이력에 같이 표시된다.</p>
<ul>
<li>non fast forward :</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/05/12/how-to-collaborate-on-GitHub-3.html" target="_blank" rel="noopener">[GitHub] GitHub로 협업하는 방법[3] - Gitflow Workflow</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/23/Etc-Git-Flow-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/22/Etc-Github-Flow/"
                            aria-label=": 2일차 [Git] Github-Flow"
                        >
                            2일차 [Git] Github-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-22T17:00:40+09:00">
	
		    Jan 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>어제 Git-Flow를 공부해보았는데, 헷갈리는 부분이 너무 많다. 그래서 Github-Flow 방법에 대해서도 헷갈리는 부분이 많아 잘 정리된 블로그를 보고 공부했다.</p>
<p>&quot;사전 과제 Repository를 fork 떠서 수정하고 PR 날려주세요.&quot;라는 메일을 받았다. 나는 Github을 사용하고 이런 비슷한 방식으로 프로젝트를 진행해왔지만 이게 이 방식이 맞는지도 모르고 있었다.</p>
<h2 id="pull-request">Pull Request</h2>
<p>협업을 하다보면 Pull Request를 보내서 코드 리뷰를 거쳐 원격 저장소에 merge가 된다. 분명 중요하다. Pull Request를 위해서 아래와 같은 절차를 거쳤다.</p>
<ul>
<li>Fork</li>
<li>clone, remote 설정</li>
<li>branch 생성(안할 수도 있음)</li>
<li>수정 작업 후 add, commit, push</li>
<li>Pull Reqeust 생성</li>
<li>코드 리뷰, Merge Pull Request</li>
<li>Merge 이후 branch 삭제 및 동기화</li>
</ul>
<h3 id="fork">Fork</h3>
<ul>
<li>타켓 프로젝트의 저장소를 자신의 저장소로 Fork 한다.</li>
</ul>
<img src="/img/git_fork.png" width="700" height="500">
<h3 id="clone-remote-설정">Clone, remote 설정</h3>
<ul>
<li>fork로 생성한 본인 계정의 저장소에서 <strong>clone or download</strong> 버튼을 누르고 표시되는 url을 복사한다.</li>
</ul>
<img src="/img/git_clone.png" width="700" height="500">
<ul>
<li>Mac 기준에서 터미널을 켠다.</li>
<li>자신의 컴퓨터에서 작업을 하기 위해서 지정한 디렉토리로 가서 Fork한 저장소를 로컬에 Clone하기 위해서 아래의 명령어를 실행한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wayhome25/blog.github.io.git</span><br></pre></td></tr></table></figure>
<ul>
<li>이제, 로컬 저장소에 원격 저장소를 추가한다. 위 작업과 동일하게 github 저장소에서 <strong>clone or download</strong> 메뉴를 통해서 확인한 url을 사용한다.
<ul>
<li>원본 프로젝트 저장소 (직접 추가 필요)</li>
<li>fork한 로컬 프로젝트 (origin이라는 별명으로 기본으로 추가되어 있다. 따로 추가할 필요 없음)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 원본 프로젝트 저장소를 원격 저장소로 추가</span><br><span class="line"># 보통 upstream 사용</span><br><span class="line">$ git remote add real-blog(별명) https://github.com/원본계정/blog.github.io.git</span><br><span class="line"></span><br><span class="line"># 원격 저장소 설정 현황 확인방법</span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="branch-생성">branch 생성</h3>
<ul>
<li>자신의 로컬 컴퓨터에서 코드를 추가하는 작업은 branch를 만들어서 진행한다.</li>
</ul>
<p><strong>개발을 하다보면 코드를 여러 개로 복사해야 하는 일이 자주 생긴다. 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는데, 이렇게 독립적으로 개발하는 것이 브랜치다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git branch develop master</span><br><span class="line">git checkout develop</span><br><span class="line"></span><br><span class="line"># 하나의 명령어로 축약 가능</span><br><span class="line">git checkout -b develop</span><br><span class="line"></span><br><span class="line"># 이제 2개의 브랜치가 존재한다.</span><br><span class="line">git branch</span><br><span class="line">* master</span><br><span class="line">develop</span><br></pre></td></tr></table></figure>
<h3 id="수정-작업-후-add-commit-push">수정 작업 후 add, commit, push</h3>
<ul>
<li>자신이 사용하는 코드 편집 툴을 활용하여 수정 작업을 진행한다.</li>
<li>작업이 완료되면 add, commit, push를 통해서 자신의 github repository(origin)에 수정사항을 반영한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># add, commit 같이 수행</span><br><span class="line">git commit -a -m &quot;Modify code&quot;</span><br><span class="line"></span><br><span class="line"># push</span><br><span class="line">git push origin develop</span><br></pre></td></tr></table></figure>
<ul>
<li>push 진행 시에 branch 이름을 명시해주어야 한다.</li>
<li>위의 명령어는 develop 브랜치의 수정 내역을 origin으로 푸시한다는 것이다.</li>
</ul>
<h3 id="pull-request-생성">Pull Request 생성</h3>
<ul>
<li>push 완료 후 본인 계정의 github 저장소에 들어오면 <strong>Compare &amp; pull request</strong> 버튼이 활성화 되어 있다.</li>
<li>해당 버튼을 선택하여 메시지를 작성하고 <strong>PR</strong>을 생성한다.(날린다.)</li>
</ul>
<img src="/img/git_PR1.png" width="700" height="500">
<img src="/img/git_PR2.png" width="700" height="500">
<h3 id="코드-리뷰-merge-pull-request">코드 리뷰, Merge Pull Request</h3>
<ul>
<li>PR을 받은 원본 저장소 관리자는 코드 변경 내역을 확인하고 Merge 여부를 결정하기 전에 Review를 남긴다.</li>
<li>팀의 정책에 따라 Review가 1개 이상이면 Merge를 하는 등의 조건이 있을 수 있다.</li>
</ul>
<h3 id="merge-이후-동기화-및-branch-삭제">Merge 이후 동기화 및 branch 삭제</h3>
<ul>
<li>원본 저장소에 Merge가 완료되면 로컬 코드와 원본 저장소의 코드를 동기화 한다.</li>
<li>작업하던 로컬의 branch를 삭제한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 코드 동기화</span><br><span class="line">git pull real-blog(remote 별명)</span><br><span class="line"></span><br><span class="line">## ex</span><br><span class="line">git pull upstream</span><br><span class="line"></span><br><span class="line"># 브랜치 삭제(develop 브랜치 삭제)</span><br><span class="line">git branch -d develop(브랜치 별명)</span><br></pre></td></tr></table></figure>
<ul>
<li>나중에 추가로 작업할 일이 있으면 <code>git pull real-blog</code>명령을 통해 원본 저장소와 동기화를 먼저 진행하고, 세번째부터 일곱번째 작업을 반복한다.</li>
</ul>
<h2 id="느낀-점">느낀 점</h2>
<p>지금까지 내가 했던 방식이 Github-Flow 방법이라는 것을 알게 되었다. 원격 저장소를 자신의 개인 저장소로 fork 하는 방식으로 간단하게 사용할 수 있는 방법이다. 어제 공부했던 브랜치 전략은 <strong>Git-Flow</strong>로 브랜치를 나누어서 작업을 진행하는 것인데, 조금 더 복잡하다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://wayhome25.github.io/git/2017/07/08/git-first-pull-request-story/" target="_blank" rel="noopener">git 초보를 위한 풀리퀘스트(pull request) 방법</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/22/Etc-Github-Flow/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/21/Etc-Git-Flow/"
                            aria-label=": 1일차 [Git] Git-Flow"
                        >
                            1일차 [Git] Git-Flow
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-21T21:35:23+09:00">
	
		    Jan 21, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Git/">Git</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>Git-Flow</code> 전략에 대해서 알아볼 예정이다. 기존에 사용하던 방법은 이름을 몰랐고 그냥 프로젝트 팀원한테 배웠던 방식을 사용했다. 이름은 나중에 찾아보니 <strong>Github-Flow</strong>였다. Git-Flow를 알아보기 전에 Github-Flow가 무엇인지 알고 넘어가보자.</p>
<h2 id="github-flow">Github-Flow</h2>
<p>기본적으로 Git Repository를 살펴보면 Repository는 Upstream Repository(이하 Upstream Repository), Origin Remote Repository(이하 Origin Repository), Local Repository 이렇게 3가지 부분으로 구성된다.</p>
<ul>
<li><strong>Upstream Repository</strong> : 개발자들이 공유하는 저장소로 최신 소스코드가 저장되어 있는 원격 저장소.</li>
<li><strong>Origin Repository</strong> : Upstream Repository를 Fork한 원격 개인 저장소.</li>
<li><strong>Local Repository</strong> : 내 컴퓨터에 저장되어 있는 개인 저장소.</li>
</ul>
<img src="/img/github_flow_repository_structure.png" width="700" height="500">
<p>위 그림은 Git Repository 구성과 워크플로우를 설명하고 있다. Local Repository에서 작업을 완료한 후 작업 브랜치를 Origin Repository에 push한다. 그리고 Github에서 Origin Repository에 push한 브랜치를 Upstream Repository로 merge하는 <strong>Pull Request</strong>를 생성하는 코드리뷰를 거친 후 merge 한다. 다시 새로운 작업을 할 때 Local Repository에서 Upstream Repository를 pull 한다.</p>
<p>이런 워크 플로우를 두는 데에는 한 가지 이유가 있다고 한다. 그 이유는 개발자들의 실험정신(?)을 펼치기 위해서이다. 모두가 공유하고 있는 Repository에서 실험하기에는 위험이 있다고 생각하고, Forked한 Repository를 두면 부담 없이 실험들을 해볼 수 있다고 한다. 무엇보다 이런 구조로 가져갔을 때 개발자가 해야 할 작업들이 <strong>중앙집중식 워크플로우</strong>보다 일이 늘거나 크게 복잡해지지도 않는다고 한다.</p>
<h2 id="git-flow">Git-Flow</h2>
<p>Git-Flow를 사용했을 때 작업을 어떻게 하는지 살펴보기 전에 먼저 Git-Flow에 대해서 간단히 살펴보도록 하겠다.<br>
Git-Flow에는 5가지 종류의 브랜치가 존재한다. 항상 유지되는 메인 브랜치들(masger, develop)과 일정 기간 동안반 유지되는 보조 브랜치들(feature, release, hotfix)이 있다.</p>
<ul>
<li>master : 제품으로 출시될 수 있는 브랜치(배포하기 위함)</li>
<li>develop : 다음 출시 버전을 개발하는 브랜치(이쪽으로 merge함)</li>
<li>feature : 기능을 개발하는 브랜치(기능별로 feature를 나눔)</li>
<li>release : 이번 출시 버전을 준비하는 브랜치</li>
<li>hotfix : 출시 버전에서 발생한 버그를 수정하는 브랜치</li>
</ul>
<img src="/img/gitflow_1.png" width="700" height="500">
<center>Git-flow</center>
<p>위 그림을 일반적인 개발 흐름으로 살펴보자.</p>
<p>처음에는 master와 develop 브랜치가 존재한다. 물론 develop 브랜치는 master에서부터 시작된 브랜치이다. develop 브랜치에서는 상시로 버그를 수정한 커밋들이 추가된다. 새로운 기능 추가 작업이 있는 경우 develop 브랜치에서 feature 브랜치를 생성한다.</p>
<p>feature 브랜치는 언제나 develop 브랜치에서부터 시작하게 된다. 기능 추가 작업이 완료되었다면 feature 브랜치는 develop 브랜치로 merge 된다. develop에 이번 버전에 포함되는 모든 기능이 merge 되었다면 <code>QA</code>를 하기 위해 develop 브랜치에 수정된다. QA를 무사히 통과했다면 release 브랜치를 master와 develop 브랜치로 merge 한다. 마지막으로 출시된 master 브랜치에서 버전 태그를 추가한다.</p>
<p>그렇다면 우아한 형제들의 안드로이드 개발팀에서는 어떻게 <code>Git-Flow</code>를 지키는지 살펴보도록 하자.</p>
<p>##작업을 할 때 지켜야할 서로 간의 약속**</p>
<ol>
<li>작업을 시작하기 전에 JIRA 티켓을 생성한다.</li>
<li>하나의 티켓은 되도록 하나의 커밋으로 한다.</li>
<li>커밋 그래프는 최대한 단순하게 가져간다.</li>
<li>서로 공유하는 브랜치의 커밋 그래프는 함부로 변경하지 않는다.</li>
<li>리뷰어에게 꼭 리뷰를 받는다.</li>
<li>자신의 Pull Request는 스스로 merge 한다.</li>
</ol>
<h2 id="우아한-형제들-git-flow">우아한 형제들 Git-Flow</h2>
<p>아래에는 우아한 형제들에서 실제로 어떻게 작업하는지 알아보겠다. 아래의 Repository와 Branch는 앞으로 설명을 할 때 나오기 때문에 알아두고 가면 한결 수월하게 볼 수 있을 것이다.</p>
<ul>
<li>Repositories
<ul>
<li>upstream(Upstream Repository) : 중앙 원격 저장소</li>
<li>origin(Origin Repository) : 내 원격 저장소</li>
</ul>
</li>
<li>Branches
<ul>
<li>feature-user(사용자 관련 기능을 구현하는 feature branch)</li>
<li>bfm-100_login_layout(사용자 관련 기능 중 레이아웃 작업 branch)</li>
</ul>
</li>
</ul>
<p><strong>1.티켓 처리하기</strong></p>
<p>앞서 '작업을 할 때 지켜야 할 서로 간의 약속’에서 **하나의 티켓은 되도록 하나의 커밋으로 한다.**라고 했다. 그래서 기능을 구혀하기 전에 여러 개의 티켓으로 작업을 먼저 나누게 된다. 나눠진 티켓 중 <strong>로그인 레이아웃 생성</strong>이라는 티켓이 있고 이 티켓을 처리한다고 가정하고 살펴보겠다.</p>
<ol>
<li>
<p>upstream/feature-user 브랜치에서 작업 브랜치(bfm-100_login_layout)를 생성한다.<br>
<code>git checkout -b bfm-100_login_layout --track upstream/feature-user</code></p>
</li>
<li>
<p>작업 브랜치에서 소스코드를 수정한다.</p>
</li>
<li>
<p>작업 브랜치에서 변경 사항을 커밋한다.<br>
<code>git commit -m &quot;BFM-100 로그인 화면 레이아웃 생성&quot;</code></p>
</li>
<li>
<p>만약 커밋이 불필요하게 여러 개로 나뉘어져 있다면 squash?를 한다.(커밋 2개를 합쳐야 한다면)<br>
<code>git rebase -i HEAD~2</code></p>
</li>
<li>
<p>작업 브랜치를 upstrea/feature-user에 rebase 한다.</p>
</li>
<li>
<p>작업 브랜치를 origin에 push한다.</p>
</li>
<li>
<p>Github에서 bfm-100_login_layout 브랜치를 feature-user 브랜치에 merge하는 Pull Request를 생성한다.</p>
</li>
<li>
<p>같은 feature를 개발하는 동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다. 만약 혼자 featur를 개발한다면 1~2명의 동료에게 리뷰 승인을 받은 후 Pull Request를 merge 한다.</p>
</li>
</ol>
<p>위의 절차에서 4,5번 작업을 수행하는 이유는 커밋 그래프를 단순하게 가져가고 의미있는 커밋들로 관리하기 위함이다.</p>
<p>4번 작업을 예로 들면, ‘BFM-100 로그인 화면 레이아웃 생성’ 작업을 할 때 로그인 화면의 레이아웃을 생성한 커밋 하나와 view의 약간의 간격을 조정한 커밋 하나, 그리고 view의 id를 변경한 커밋하나, 이렇게 3개의 커밋으로 분리된 상태이다. 이 3개의 커밋이 그 의미를 나눌 필요가 없거나 코드 리뷰를 도와주지도 못한다면 커밋을 분리하는 것은 불필요하다고 판단하고 하나의 커밋으로 합치게 된다.</p>
<p>물론 항상 하나의 커밋으로 합쳐야만하는 것은 아니다. 하나의 티켓에 대한 작업이라도 커밋이 분리되어 있는게 낫다고 생각이 든다면 2개 이상의 커밋으로 나눌 수도 있다. 그러나 대부분은 티켓을 더 작게 나누지 못한 경우일 가능성이 높다.</p>
<p><strong>2. develop 변경사항을 feature로 가져오기</strong>(Optional)</p>
<p>작업을 할 때 브랜치의 수명은 되도록 짧게 가져가는게 좋지만, feature 브랜치에서 기능을 완료하는데 해야 할 작업들이 많아서 오래 걸리는 경우들이 있다. 그러다 보면 develop에 추가된 기능들이 필요한 경우가 종종 생기게 된다. 그럴 때는 feature 브랜치에 develop의 변경사항들을 가져와야 한다.</p>
<ol>
<li>feature-user 브랜치에 upstream/develop 브랜치를 merge 한다.</li>
<li>upstream/develop의 변경사항이 merge된 feature-user를 upstream에 push 한다.</li>
</ol>
<p><strong>3. 완료된 기능을 이번 출시 버전에 포함시키기</strong></p>
<p>드디어 feature-user 브랜치에서 작업하던 기능이 완료되었다. 이젠 feature 브랜치를 이번 출시 버전에 포함시키기 위해서 develop에 merge해야 한다.</p>
<ol>
<li>develop 브랜치에 upstream/feature-user 브랜치를 merge 한다.</li>
<li>upstream/feature-user 기능이 merge된 develop를 upstream에 push 한다.</li>
</ol>
<p><strong>4. QA 시작하기</strong></p>
<p>이번 버전에 포함되어야 할 기능들이 모두 완료되었다. 이제부터 출시 담당자가 해야 할 일이 많다. 출시 담당자는 QA를 시작하기 위해 먼저 release 브랜치를 develop 브랜치로부터 따서 생성하고 upstream에 push하여 release 브랜치를 공유한다.</p>
<ol>
<li>release-1.0.0 브랜치를 생성한다.</li>
<li>release-1.0.0 브랜치를 upstream에 push 한다.</li>
</ol>
<p><strong>5. QA 중 버그 수정하기</strong></p>
<p>개발을 완료한 후 QA 중 버그가 발생하지 않으면 좋겠지만 항상 생각치 못한 예외 상황들이 발생하게 된다. 예외 상황이 발생할 때마다 버그 티켓이 하나씩 생성되는데 이 티켓들을 모두 해결해야만 앱을 출시할 수 있다. 버그 티켓들도 티켓이기 때문에 '1. 티켓 처리하기’와 같은 방법으로 처리한다.</p>
<ol>
<li>release 브랜치에서 버그 티켓에 대한 브랜치를 생성한다.</li>
<li>버그를 수정한다.</li>
<li>버그 티켓에 대해 생성한 브랜치를 작업 브랜치라 하고 작업 브랜치에서 버그 수정 사항을 커밋한다.</li>
<li>작업 브랜치를 origin[ develop? ]에 push 한다.</li>
<li>Github에서 bfm-101_bug_login_id_max_length 브랜치를 release-1.0.0에 merge 하는 Pull Request를 생성한다.</li>
<li>동료에게 리뷰 승인을 받은 후 자신의 Pull Request를 merge 한다.</li>
</ol>
<p><strong>6. 앱출시</strong></p>
<p>발생하는 버그들을 모두 수정했다면 이젠 출시를 준비할 때이다. release 브랜치를 master 브랜치와 develop 브랜치에 merge하고 마지막으로 master 브랜치에서 버전 태그를 달아준다.</p>
<ol>
<li>release 브랜치를 최신 상태로 갱신한다.</li>
<li>release 브랜치를 develop 브랜치에 merge 한다.</li>
<li>develop 브랜치를 upstream에 push 한다.</li>
<li>release 브랜치를 master 브랜치에 merge 한다.</li>
<li>1.0.0 태그를 추가한다.</li>
<li>master 브랜치와 1.0.0 태그를 upstream에 push 한다.</li>
</ol>
<h3 id="중앙집중식-워크플로우">중앙집중식 워크플로우</h3>
<img src="/img/centralized_workflow.png" width="700" height="500">
<p>중앙집중식에서 개발자 두 명이 중앙저장소를 clone하고 각자 수정하는 상황을 생각해보자. 한 개발자가 자신이 한 일을 커밋하고 나서 아무 문제 없이 서버에 push한다. 그러면 다른 개발자는 자신의 일을 커밋하고 push 하기 전에 첫 번째 개발자가 한 일을 먼저 Merge 해야 한다. Merge를 해야 첫 번째 개발자가 작업한 내용을 덮어쓰지 않는다. 이런 개념은 Subversion과 같은 중앙집중식 버전 관리 시스템에서 사용하는 방식이고 Git에서도 당연히 이런 워크플로우를 사용할 수 있다.</p>
<p>팀이 작거나 이미 중앙집중식에 적응한 상황이라면 이 워크플로우에 따라 git을 도입하여 사용할 수 있다. 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다.</p>
<p>A와 B가 동시에 같은 부분을 수정하는 상황을 생각해보자. A가 먼저 작업을 끝내고 수정한 내용을 서버로 push한다. B도 마찬가지로 작업을 끝내고 수정한 내용을 서버로 push 하려 하지만 서버가 바로 받아주지 않는다. 서버에는 A가 수정한 내용이 추가되었기 때문에 push 하기 전에 Fetch로 받아서 Merge 한 후 Push 할 수 있다 이런 개념을 개발자에게 익숙해서 거부감 없이 도입할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://woowabros.github.io/experience/2017/10/30/baemin-mobile-git-branch-strategy.html" target="_blank" rel="noopener">우린 Git-flow를 사용하고 있어요</a></li>
</ul>
<p><strong>회고</strong></p>
<p>Github-flow가 편하다는 생각이 아직 사라지지 않는다. 왜냐하면 git-flow는 브랜치가 많고 git의 명령어들이 많이 나와서 헷갈리는 부분이 너무 많다. 하지만 여러 사람이 협업할 때 브랜치를 기능별로 나눠서 하게 되기 때문에 효율이 좋은 것 같다.</p>
<p>아직 헷갈리는 부분이 많아서 자료를 조금 더 참고해서 공부해야겠다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/21/Etc-Git-Flow/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/19/Android-MVP-Step11/"
                            aria-label=": [안드로이드] MVP 따라하기 11"
                        >
                            [안드로이드] MVP 따라하기 11
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-19T17:30:01+09:00">
	
		    Jan 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>Repository</h2>
<p>Repository 정의는 Memory cache를 할 수 있으며, Remote/Local 데이터를 불러오게 된다. SQLite 사용 시에는 <strong>Loaders</strong> 사용으로 비동기식 데이터를 쉽게 로드할 수 있는 방법을 사용하고, RxJava 등의 방법을 사용할 수 있다. [이 경우는 이번 글에서 다루지 않는다.]</p>
                    
                        <a
                            href="/2019/01/19/Android-MVP-Step11/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 11"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/19/Android-MVP-Step10/"
                            aria-label=": [안드로이드] MVP 따라하기 10"
                        >
                            [안드로이드] MVP 따라하기 10
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-19T14:11:31+09:00">
	
		    Jan 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>구글 Architecture에서 설명하는 모델 정의를 살펴보려고 한다.</p>
                    
                        <a
                            href="/2019/01/19/Android-MVP-Step10/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 10"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/19/Android-MVP-Step9/"
                            aria-label=": [안드로이드] MVP 따라하기 9"
                        >
                            [안드로이드] MVP 따라하기 9
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-19T13:40:29+09:00">
	
		    Jan 19, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는 MVP 패턴에서 사용할 수 있는 다양한 Model을 살펴보겠다.</p>
                    
                        <a
                            href="/2019/01/19/Android-MVP-Step9/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 9"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/18/Android-MVP-Step8/"
                            aria-label=": [안드로이드] MVP 따라하기 8"
                        >
                            [안드로이드] MVP 따라하기 8
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-18T20:58:46+09:00">
	
		    Jan 18, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는  8번째 시간이다. ㅎㅎ 지난번에 태환님의 동영상 강의를 보면서 AdapterContract 정의를 했고, 이어서 OnClickListener 정의를 해보려고 한다.</p>
                    
                        <a
                            href="/2019/01/18/Android-MVP-Step8/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 8"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/18/Android-MVP-Step7/"
                            aria-label=": [안드로이드] MVP 따라하기 7"
                        >
                            [안드로이드] MVP 따라하기 7
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-18T18:05:31+09:00">
	
		    Jan 18, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>다음을 정리</h2>
<p>이전 영상을 보면서 배웠던 내용은 View -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; View -&gt; Adapter을 정의하였다. 오늘은 아래 그림과 같이 View -&gt; Presenter -&gt; Model -&gt; Presenter -&gt; Adapter View/Model을 바로 갱신하게 된다. 그래서 Activity/Fragment의 View를 한 단계 더 분리하고, 이를 좀 더 편하게 관리하기 위함이다.</p>
                    
                        <a
                            href="/2019/01/18/Android-MVP-Step7/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 7"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/18/Android-MVP-Step6/"
                            aria-label=": [안드로이드] MVP 따라하기 6"
                        >
                            [안드로이드] MVP 따라하기 6
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-18T12:05:53+09:00">
	
		    Jan 18, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는 Adapter에 대한 Contract 정의하는 방법을 살펴보려 한다. 여기서는 Adapter에 대한 Contract를 정의하고 이를 상속받아서 사용하는 방법을 정리해보겠다.</p>
                    
                        <a
                            href="/2019/01/18/Android-MVP-Step6/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 6"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/17/Android-MVP-Step5/"
                            aria-label=": [안드로이드] MVP 따라하기 5"
                        >
                            [안드로이드] MVP 따라하기 5
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-17T09:32:11+09:00">
	
		    Jan 17, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는 참고하는 블로그의 태환님께서 영상 올리신걸 참고하여 Presenter를 분리하는 방법을 배웠다.</p>
                    
                        <a
                            href="/2019/01/17/Android-MVP-Step5/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] MVP 따라하기 5"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/13/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/15/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 14 of 25</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
