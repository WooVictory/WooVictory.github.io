
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/7/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/08/03/AsyncTask/"
                            aria-label=": [Android] AsyncTask"
                        >
                            [Android] AsyncTask
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-08-03T21:01:12+09:00">
	
		    Aug 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="overview">OverView</h2>
<p>안드로이드에서는 기본적으로 메인 스레드를 갖는다. 이를 <strong>UI 스레드</strong>라고 부르기도 하는데, UI 관련 작업을 해당 스레드에서만 작업하도록 제한하기 때문에 이렇게 부른다.</p>
<p>UI 스레드에서는 UI 관련 작업만 한다고 했는데, 그렇다면 파일을 다운로드 받거나 네트워크를 통해 데이터를 받아오는 입출력 작업 등의 시간이 오래 걸리는 작업을 하면 앱의 반응성이 낮아지고 안드로이드 시스템은 사용자의 사용성을 위해 <code>ANR(Application Not Responding)</code>을 발생시키게 된다.</p>
<p>이 문제를 해결하기 위해 안드로이드에서는 Handler, AsyncTask 등의 방법을 제공한다. 이번 포스팅에서 알아볼 친구는 <strong>AsyncTask</strong>이다. 그 중에서도 문제점과 유의사항이다. 사실 인터넷에 많은 사용법과 개념이 있으니 여기서는 다루지 않겠다.</p>
<h2 id="asynctask">AsyncTask</h2>
<p><strong>Google</strong>은 <code>AsyncTask</code>를 사용할 때, '수 초 내의 동작에만 사용’하는 것을 권장하고 있다. 그 이상의 작업을 하고 싶을 때는 별도의 스레드를 생성해 직접 구현하는 것을 권장한다. 그 <strong>이유는 AsyncTask가 액티비티에 종속되지 않기 때문이다.</strong></p>
<p><code>1. AysncTask 사용 규칙</code></p>
<ul>
<li>AsyncTask는 일회용 클래스이다. 두 번 이상 사용하면 안된다. 두 번째 execute() 호출시 오류가 발생한다.</li>
<li>AsyncTask 객체는 메인스레드에서 생성되어야 하고 실행되어야 한다.</li>
<li>AsyncTask의 콜백 메소드인 onPreExecute(), doInBackground(), onProgress() 등을 수동으로 호출하면 오류가 발생한다.</li>
</ul>
<p><code>2. AsyncTask가 액티비티에 종속되지 않아 생길 수 있는 문제</code></p>
<p>AsyncTask는 액티비티에 포함되지 않는다. 그래서 doInBackground()가 수행되고 있는 동안에 액티비티가 종료되면 수행되던 AsyncTask는 다음과 같은 2가지 문제가 발생할 수 있다.</p>
<ul>
<li><strong>액티비티 종료 시의 문제점</strong>
<ul>
<li>AsyncTask를 execute() 하고 doInBackground()가 수행되고 있는 동안에 액티비티가 먼저 종료되면 AsyncTask와 액티비티는 독립적인 존재이므로 AsyncTask가 종료되지 않는다. 액티비티가 종료되더라도 doInBackground()의 수행이 끝날 때까지 AsyncTask는 실행 중 상태를 유지하게 된다.</li>
<li>doInBackground() 수행 완료 후에 AsyncTask의 생명주기 상 onCancelled()나 onPostExecute() 메소드가 호출된다. 이때 존재하지 않은 액티비티의 UI에 접근을 한다면 메모리 누수(Memory Leak)이 발생하고 <code>IllegalArgumentException</code> 에러가 발생할 수 있다.</li>
</ul>
</li>
</ul>
<p>그래서 다음처럼 액티비티가 종료될 때, AsyncTask의 cancel() 메소드를 호출해 오류를 방지해야 한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    task.cancel(<span class="literal">true</span>)        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>디바이스의 화면 회전시의 문제점</strong>
<ul>
<li>액티비티 종료시의 문제점 사례와 같은 상황이다. 액티비티는 디바이스의 화면을 회전시키면 액티비티가 종료되고 새로운 액티비티가 생성된다. 그렇게 되면 액티비티의 모든 변수가 초기화되고 회전 전에 실행했던 AsyncTask는 계속 백그라운드에서 수행이 되고 doInBackground()가 종료되고 난 뒤에 UI 객체에 접근을 하면 메모리 누수와 스레드 <code>IllegalArgumentException</code> 에러가 발생할 수 있다.</li>
</ul>
</li>
</ul>
<p><code>3. AsyncTask를 취소하는 방법</code></p>
<p>AsyncTask는 수행 중에 cancel()을 호출하여 취소할 수 있다. cancel()이 한 번이라도 호출되면 isCancelled() 메소드는 true를 반환한다. 하지만 주의해야 할 것은 cancel()을 호출했다고 doInBackground()의 실행이 취소되는 것은 아니라는 점이다.</p>
<p>액티비티 종료나 화면이 회전되는 상황이 발생했을 때 cancel()을 호출하더라도 남아있는 작업은 계속 돌게 되어 원치 않은 상황이 될 수 있다. 그래서 작업 취소 요청에 바로 반응하기 위해서 doInBackground() 메소드에서 주기적으로 isCancelled()의 반환값을 확인하여 적절한 조치를 취해야 한다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://blog.naver.com/PostView.nhn?blogId=ironlove77&amp;logNo=221003037545" target="_blank" rel="noopener">안드로이드 | 스레드 | AsyncTask의 문제점과 유의사항</a></li>
<li><a href="https://webnautes.tistory.com/1082" target="_blank" rel="noopener">안드로이드 개념 및 예제 - AsyncTask</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/08/03/AsyncTask/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/31/RxJava-Chap01-Introduce/"
                            aria-label=": [RxJava] Chap01 리액티브 소개"
                        >
                            [RxJava] Chap01 리액티브 소개
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-31T13:38:38+09:00">
	
		    Jul 31, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <blockquote>
<p>해당 포스팅 글이 로컬에서만 보이는 문제로 인하여 재업로드한 글입니다.</p>
</blockquote>
<p>RxJava와 관련된 내용은 <a href="http://www.yes24.com/Product/goods/45506284" target="_blank" rel="noopener">RxJava 프로그래밍</a> 책을 구매하여 공부하면서 참고하였습니다. 앞으로 작성하는 RxJava 글은 위의 책으로 공부하면서 정리한 내용입니다. 문제가 된다면 해당 게시글을 삭제하도록 하겠습니다. 아래 글은 제가 책을 보고 공부한 내용과 참고한 내용으로 작성되었으므로 정확하지 않을 수 있으니 깃헙에 있는 이메일로 연락주시면 감사하겠습니다.</p>
<ul>
<li><a href="#%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">리액티브 프로그래밍</a></li>
</ul>
<h2 id="리액티브-프로그래밍">리액티브 프로그래밍</h2>
<p>리액티브 프로그래밍(Reative Programming)은 반응형 프로그래밍이라고도 한다. <strong>데이터 의 흐름과 전달에 관한 프로그래밍 패러다임</strong>이다. 기존의 명령형 프로그래밍은 주로 컴퓨터 하드웨어를 대상으로 프로그래머가 작성한 코드가 정해진 절차에 따라 순서대로 실행된다. <strong>리액티브 프로그래밍</strong>은 데이터 흐름을 먼저 정의하고 데이터가 변경되었을 때 연관되는 수식이나 함수가 업데이트되는 방식이다.</p>
<p>가장 쉽게 이해할 수 있는 예는 MS의 엑셀(즉, 스프레드 시트)이다. 엑셀에서 값을 변경했을 때 자동으로 반영되는 것이 이러한 예를 설명한다.</p>
<ul>
<li>기존의 명령형 프로그래밍 &lt;–&gt; 반응형 프로그래밍(즉, 리액티브 프로그래밍)</li>
<li><code>명령형 프로그래밍</code> 방식은 변경이 발생했다는 통지를 받아서 연말 매출액을 새로 계산하는 당겨오는(<strong>pull</strong>) 방식이지만, <code>리액티브 프로그래밍</code>은 데이터 소스가 변경된 데이터를 밀어주는(<strong>push</strong> 방식이다. 일종의 옵저버 패턴이라고 생각하면 된다.</li>
<li>명령형 프로그래밍의 반대말은 선언형 프로그래밍이라고도 한다.
<ul>
<li>ex) SQL.</li>
<li>반응형 프로그래밍은 선언형 프로그래밍을 지향한다.</li>
</ul>
</li>
</ul>
<h2 id="자바언어와-리액티브-프로그래밍">자바언어와 리액티브 프로그래밍</h2>
<ul>
<li>기존의 pull 방식의 프로그래밍 개념 -&gt; push 방식의 프로그래밍 개념으로 바뀜.</li>
<li><code>함수형 프로그래밍</code>의 지원을 받는다.</li>
</ul>
<p><strong>리액티브 프로그래밍</strong>에서는 데이터의 변화가 발생했을 때 변경이 발생한 곳(데이터 소스)에서 새로운 데이터를 보내(push 방식) 준다. 기존 자바 프로그래밍이 pull 방식이라면 리액티브 프로그래밍은 push 방식이다.</p>
<p>한편 우리가 아는 콜백이나 옵저버 패턴을 넘어서 RxJava 기반의 리액티브 프로그래밍이 되려면 <strong>함수형 프로그래밍</strong>이 필요하다. 콜백이나 옵저버 패턴은 옵저버가 1개이거나 단일 스레드 환경에서는 문제가 없지만, 멀티 스레드 환경에서는 사용시 많은 주의가 필요하다.<br>
대표적인 예가 <strong>데드락</strong>과 <strong>동기화</strong>문제이다.</p>
<p>추가적으로 <strong>함수형 프로그래밍은 부수 효과(side effect)가 없다.</strong> 부수 효과란 콜백이나 옵저버 패턴이 스레드에 안전하지 않은 이유가 같은 자원에 여러 스레드가 경쟁 조건(race condition)에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오는 것을 말한다. 한 두개의 스레드가 있을 때는 잘 동작하다가 수십, 수백개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이게 되고 디버깅도 어려워진다.</p>
<p>함수형 프로그래밍은 부수 효과가 없는 순수 함수(pure function)를 지향한다. 따라서 멀티 스레드 환경에서도 안전하다. 자바를 사용해 리액티브 프로그래밍을 하기 위해서는 <strong>함수형 프로그래밍의 도움이 필요하다.</strong></p>
<blockquote>
<p>그럼 여기서 말하는 함수형 프로그래밍은 무엇을 말하는 걸까?</p>
</blockquote>
<p>간략하게 말하면 함수형 프로그래밍 언어는 함수를 단지 호출하는 대상이 아닌 변수로도 할 수 있고 인자로도 넘길 수 있고 마음대로 지지고 볶고? 할 수 있다. (아직 개념이 정확히 잡히지 않아서. . ㅜㅜ) 어려운 말로는 일급 시민이라고 표현한다고 한다.</p>
<p>반응형 프로그래밍은 이런 함수형 언어의 도구들을 자유자재로 활용해야 한다. 예를 들어 Java 8에 도입된 람다 표현식은 반드시 알아야 한다.</p>
<h2 id="리액티브-프로그래밍-개념-다시-잡아보자">리액티브 프로그래밍 개념 다시 잡아보자.</h2>
<p>RxJava를 비롯해서 리액티브 프로그래밍을 공부하다 보면 새로 등장하는 개념으로 인해 많은 혼란을 겪는다고 한다. 일단, 프로그래밍 스타일이 너무 다르다. 자바는 객체 지향 언어인데 리액티브 프로그래밍은 뭔가 좀 다른 것 같다. 그리고 내가 문제를 바라보는 개념도 이전과는 달라야 하는 것 같다. 이 부분은 아직 감이 안잡히지만 천천히 잡아보도록 하겠다.</p>
<p>아무튼 어렵고 새로운 개념은 초반에 잘 잡아놓으면 나중에 공부할 때 도움이 많이 되기 때문에 여기서 잘 잡아서 앞으로 나아가자. 다음은 위키 백과에 나와 있는 설명 중 일부분이다.</p>
<blockquote>
<p>위키 백과의 일부</p>
</blockquote>
<ul>
<li>상호 작용 프로그램은 <strong>프로그램이 주도하는 속도</strong>로 사용자 혹은 다른 프로그램과 상호작용 한다.</li>
<li>사용자의 관점으로 볼 때 시분할 시스템은 상호작용 프로그램이다.</li>
<li><strong>리액티브 프로그래밍</strong>은 주변의 환경과 끊임없이 상호작용을 하는데 <code>프로그램이 주도하는 것이 아니라 환경이 변하면 이벤트를 받아 동작한다.</code></li>
<li>상호작용 프로그램은 자신의 속도에 맞춰 일하고 대부분 통신을 담당하는 반면 리액티브 프로그램은 외부 요구에 반응에 맞춰 일하고 대부분 정확한 인터럽트 처리를 담당한다.</li>
</ul>
<p>자바에서는 이런 RxJava와 같은 리액티브 프로그래밍을 하기 위해서 기반이 마련되야 한다. 즉, 데이터 소스를 정의할 수 있고 그것의 변경 사항을 받아서 내 프로그램에 알려줄 존재(<strong>push</strong>)가 필요하다. 이를 <strong>RxJava 라이브러리</strong>를 통해서 구현할 수 있다.</p>
<h2 id="rxjava를-만든-이유가-뭘까">RxJava를 만든 이유가 뭘까??</h2>
<p>RxJava는 지금 우리가 아주 아주 잘 사용하는 [넷플릭스](<a href="https://www.netflix.com/kr/" target="_blank" rel="noopener">https://www.netflix.com/kr/</a>)의 기술 블로그에서 처음 소개되었다. 성능 개선을 위해서 넷플릭스는 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅(??)하여 RxJava를 만들었다. 넷플릭스가 RxJava를 만든 핵심적인 이유는 아래와 같다.</p>
<ol>
<li>동시성을 적극적으로 끌어안기에 자바는 번거롭다.</li>
</ol>
<p>자바가 동시성(? 정확히 뭐지…?)을 처리하기에 번거롭기 때문에 넷플릭스는 클라이언트의 요청을 <strong>서비스 계층</strong>에서 동시성을 적극적으로 끌어안음으로 이를 해결했다. 클라이언트의 요청을 처리할 때 <strong>다수의</strong> 비동기 실행 흐름(스레드 등등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다고 한다.</p>
<ol start="2">
<li>자바의 Future를 조합하기 어렵다?!</li>
</ol>
<p>약 6년 전 (시간이 벌써 2019년이라니ㅜ.ㅜ) 내가 대학교 1학년일 때이다. 이 당시에 자바 8에서 제공하는 <strong>CompletableFuture</strong> 같은 클래스가 제공되지 않았다고 한다. 그래서 비동기 흐름을 조합할 수 있는 방법이 거의 없었고, RxJava에서는 이를 해결하려고 비동기 흐름을 조합<code>(Compose)</code>할 수 있는 방법을 제공한다.<br>
RxJava에서 조합하는 실행 단위를 <strong>리액티브 연산자</strong>(Operator)라고 한다.</p>
<ol start="3">
<li>콜백 지옥 탈출!</li>
</ol>
<p>콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황은 코드의 가독성을 떨어트린다. 또한, 문제 발생 시 디버깅을 어렵게 만든다. <strong>콜백</strong>은 비동기 방식으로 동작하는 가장 대표적인 패턴이다. 이런 지옥을 탈출하고자 RxJava에서는 콜백을 사용하지 않는 방향으로 설계하려고 했다.</p>
<h2 id="정리">정리</h2>
<p>위에서 쭉 반응형 프로그래밍(즉, 리액티브 프로그래밍)은 비동기 데이터의 흐름과 전달에 초점을 맞춘 패러다임이다. 그리고 함수형 프로그래밍 언어의 지원을 받고 이를 활용한다고 했다.</p>
<p>정리하자면 반응형 프로그래밍은 <code>함수형 프로그래밍 언어의 도구들을 가지고 데이터의 흐름을 Composable(구성 가능하게?!)하게 구현</code>하는 것이라고 할 수 있다.</p>
<h2 id="참고">참고</h2>
<ul>
<li>
<p><a href="https://brunch.co.kr/@yudong/33" target="_blank" rel="noopener">RxJava 반응형 프로그래밍이란 무엇인가?</a></p>
</li>
<li>
<p>아래는 참고하면 좋을 자료들!</p>
<ul>
<li><a href="https://medium.com/@jooyunghan/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-fab4e960d263" target="_blank" rel="noopener">함수형 프로그래밍이란 무엇인가?</a></li>
<li><a href="https://www.slideshare.net/ChiwonSong/20171104-frp-81598173" target="_blank" rel="noopener">함수형 프로그래밍</a></li>
<li><a href="https://poqw.github.io/RxJava2_1/" target="_blank" rel="noopener">RxJava에 관하여</a></li>
<li><a href="https://medium.com/@LIP/rxjava-29cfb3ceb4ca" target="_blank" rel="noopener">RxJava 기초</a></li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/31/RxJava-Chap01-Introduce/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/15/AndroidStudio-Live-Template/"
                            aria-label=": [Android] Live Template?!"
                        >
                            [Android] Live Template?!
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-15T11:24:17+09:00">
	
		    Jul 15, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>매일 아침 10시에 <code>Daily DevBlog</code>를 통해서 개발 관련 블로그 포스팅들이 메일로 온다. 이를 통해서 매일 아침 따끈따근한 소식을 볼 수 있고, 내가 관심 있어하는 주제가 있다면 얻을 수 있어서 굉장히 좋아하고 잘 사용하고 있다.</p>
<p>어쨋든, 오늘 글의 주제는 이게 아니다. 글을 보던 중 괜찮은 내용이 있어서 참고해서 작성하려고 한다. Android Studio의 <code>Live Template</code> 기능이다.</p>
<h2 id="live-template">Live Template</h2>
<p>지극히 주관적인 생각이지만, 개발자들은 귀찮은 걸 싫어하는 것 같다. 코딩을 하더라도 조금만 귀찮은 작업이라면 싫어한다. 그래서 IDE에서 제공하는 기능을 잘 사용한다면 귀찮음을 덜어줄 수 있다. 그 중에서 나는 <code>JetBrains</code>이 만든 IDE가 좋다고 생각한다. 물론, IDE에서 제공하는 기능을 잘 사용한다면 말이다.</p>
<p><strong>Live Template</strong>은 축약형 값을 입력하면 자주 쓰는 코드 구성을 불러오는 기능이다. 쉽게 말해 상용구이다. 안드로이드 스튜디오에서 기본적으로 제공하는 라이브 템플릿 중에서도 유용한 것들이 꽤 있고, 사용자가 직접 커스텀해 사용할 수도 있다.</p>
<p>하나의 예로, 우리가 자주 사용하는 반복문 중 for문을 사용한다고 가정해보자. for문의 fo만 입력해도 밑에 자동 완성으로 제공되는 모습을 볼 수 있을 것이다.</p>
<img src="/img/android_studio_exam.png" width="500" height="200">
<p>설정을 변경할 수도 있고, 사용자가 원하는 상용구를 추가할 수도 있다. <strong>환경 설정(Preferences) -&gt; Editor -&gt; Live Template</strong> 에 들어가면 템플릿을 확인할 수 있다.</p>
<h2 id="커스텀해보자">커스텀해보자.</h2>
<p>그렇다면 간단한 커스텀 템플릿을 만들어보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, MainActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<p>액티비티 이동을 위해서 이렇게 두 줄을 입력하기가 귀찮을 수 있다. 물론, 함수로 빼서 사용할 수도 있지만 그 경우는 제외하고 지금 상황만 보자. 그래서 <strong>축약형</strong>을 적었을 때, 위에 정의한 두 줄이 자동 생성되도록 하고 싶다. 현재 액티비티는 자동으로 완성되고, 이동할 두 번째 클래스명만 입력하도록 할 것이다.</p>
<p><code>cis</code>를 입력했을 때 아래의 두 줄이 뜨게 할 것이다. <strong>Preferences -&gt; Editor -&gt; Live Template</strong> 창에서 우측 상단의 <code>+</code> 버튼을 눌러 새로운 Template Group을 만든다. 만든 Group을 누른 상태에서 <code>+</code> 버튼을 한 번 더 누른 뒤, <strong>Live Template</strong>을 눌러 Template Text를 입력해준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = android.content.Intent(<span class="keyword">this</span>@$first$, $second$::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<img src="/img/android_studio_exam_2.png" width="800" height="200">
<p><code>android.content.Intent</code>를 입력함으로써 자동으로 import되도록 했다.</p>
<p>먼저, 이 템플릿을 어디에서 호출하여 사용할 것인지 지정해야 한다. 하단에 보면 주의사항 <strong>No applicable contexts</strong> 옆의 Define을 눌러 kotlin 전체에 체크해준다.</p>
<p>다음으로 $first$와 $second$는 자유롭게 정할 수 있는 변수명이다. 이 변수에 대한 설정은 Template Text 코드 우측 하단에 <strong>Edit variables</strong>에서 설정할 수 있다. 누르면 Expression을 불러 사용할 수 있다.</p>
<ul>
<li>first 변수 : 미리 정의되어 있는 함수 목록에서 클래스 이름을 불러오는 <code>className()</code> 메소드를 사용한다. 오른쪽에 있는 <strong>Skip if defined</strong>에 체크하면 템플릿을 불러온 후, 커서가 바로 second 변수 쪽으로 이동하도록 설정할 수 있다.</li>
<li>second 변수 : 직접 다음 액티비티 이름을 적어줄 것이기 때문에 아무 작업을 하지 않는다.</li>
</ul>
<img src="/img/android_studio_exam3.png" width="600" height="200">
<p>이제 Ok 버튼을 눌러서 마무리하면 코드에서 사용할 수 있다. 필자는 <code>cis</code>라는 축약형을 사용했다.</p>
<img src="/img/android_studio_exm4.png" width="600" height="200">
<p>위 그림을 보면 <code>cis</code> 축약형을 입력했을 때, 원하는 코드가 뜨는 것을 확인할 수 있다.</p>
<h2 id="결론">결론</h2>
<p>Live Template을 사용하면 간단한 코드를 작성하는 것을 템플릿화시켜서 아주 유용하게 사용할 수 있을 것 같다. 아주 유용한 기능이다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://blog.yena.io/studynote/2019/07/14/Android-Live-Templates.html" target="_blank" rel="noopener">[Android] Live Template 라이브 템플릿</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/15/AndroidStudio-Live-Template/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/08/DI/"
                            aria-label=": [Android] DI에 대해서"
                        >
                            [Android] DI에 대해서
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-08T15:09:36+09:00">
	
		    Jul 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="di">DI</h2>
<p><code>Dagger</code>는 DI 프레임워크이다 DI는 Dependency Injection(의존성 주입)의 준말이다. 의존성 주입이란 외부에서 의존 객체를 생성하여 넘겨주는 것을 의미한다. 예를 들어 A class가 B class를 의존할 때 B Object를 A가 직접 생성하지 않고 외부에서 생서아여 넘겨주면 의존성을 주입했다고 할 수 있다.</p>
<img src="/img/di_sample.jpeg" width="500" height="200">
<p>왼쪽은 A에서 B,C를 생성하는 일반적인 의존 형태이고, 오른쪽은 외부에서 의존 객체를 생성하고 주입하는 형태이다.</p>
<p>DI를 위해서는 객체를 생성하고 넘겨주는 외부의 뭔가가 필요하다. 이것이 DI 프레임워크가 하는 일이다. 외부에서 넘겨주는 무언가를 스프링에서는 컨테이너, <code>Dagger</code>에서는 <strong>Component</strong>와 <strong>Module</strong>이라고 부른다. DI는 이렇게 의존성이 있는 객체의 제어를 외부 Framework로 올리면서 IoC 개념을 구현한다. IoC는 Inversion of Control(제어의 역전)의 준말이다.</p>
<img src="/img/di_sample2.jpeg" width="500" height="200">
<p>외부 컨테이너가 객체를 생성하고 주입한다. 제어가 거꾸로 가는 개념을 IoC라고 하고, DI는 IoC를 구현하는 방법 중 하나이다.</p>
<p><strong>DI는 왜 필요할까?</strong></p>
<ol>
<li>의존성 파라미터를 생성자에 작성하지 않아도 되므로 보일러 플레이트 코드를 줄일 수 있다. 이를 통해서 유연한 프로그래밍이 가능하다.</li>
<li>Interface에 구현체를 쉽게 교체하면서 상황에 따라 적절한 행동을 정의할 수 있다. 이것은 특히 Mock 객체와 실제 객체를 바꿔가며 테스트할 때 유용하다. 즉, 테스트 가능한 코드를 작성할 수 있다. 이로 인해 재사용성이 높아지고 유지보수가 용이해진다.</li>
</ol>
<p>DI를 구현하는 방법은 다음과 같다.</p>
<ol>
<li>직접 Provider를 구성해 코드로 작성하는 방법</li>
<li>라이브러리로 넘겨서 처리하도록 하는 방법
<ul>
<li>Dagger2</li>
<li>koin</li>
</ul>
</li>
</ol>
<h2 id="dagger-이해하기">Dagger 이해하기</h2>
<p><strong>1. Inject</strong></p>
<p>의존성 주입을 요청한다. <code>Inject</code> 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다.</p>
<p><strong>2. Component</strong></p>
<p>연결된 Module을 이용하여 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다.</p>
<p><strong>3. Subcomponent</strong></p>
<p>Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위 계층 Component이다. Sub의 Sub도 가능하다. Subcomponent는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고, 없으면 부모로 올라가면서 검색한다.</p>
<p><strong>4. Module</strong></p>
<p>Component에 연결되어 의존성 객체를 생성한다. 생성 후 Scope에 따라 관리도 한다.</p>
<p><strong>5. Scope</strong></p>
<p>생성된 객체의 Lifecycle 범위이다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서 Scope을 보고 객체를 관리한다.</p>
<p>위의 5가지 개념을 따라 Dagger가 의존성을 주입하는 플로우는 다음과 같다.</p>
<img src="/img/di_flow.png" width="700" height="200">
<img src="/img/di_flow2.png" width="700" height="200">
<ul>
<li>Inject로 의존성을 요청하면 Subcomponent에서부터 Module을 검색하고, Scope에 따라 객체를 가져와 주입한다.</li>
</ul>
<p>koin과 관련된 글은 다음의 포스팅을 참고하면 된다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://medium.com/@maryangmin/di-%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%82%AC%EC%9A%A9%EB%B2%95%EA%B9%8C%EC%A7%80-dagger2-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-3332bb93b4b9" target="_blank" rel="noopener">DI 기본개념부터 사용법까지, Dagger2 시작하기</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/08/DI/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/05/RxJava-Chap07/"
                            aria-label=": [RxJava] Chap07. 디버깅"
                        >
                            [RxJava] Chap07. 디버깅
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-05T23:23:57+09:00">
	
		    Jul 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="디버깅">디버깅</h2>
<p>코딩하는 도중에 로그를 넣는 이유는 잘못되었을 때를 대처하기 위함이다. 하지만 RxJava 코드는 로그를 넣을 수 있는 공간이 없다. Observable로 시작하는 업스트림(upstream)과 그것을 받아서 처리하는 다운스트림(downstream)이 동일한 문장으로 이루어져 있기 때문이다. 즉, 전체 동작을 선언적으로 만들 수 있으므로 전체 맥락에 대한 가독성은 높아지지만 예외 코드를 어떻게 넣어야 하는지에 대한 어려움이 있다.</p>
<p>원래 함수형 프로그래밍은 함수의 부수 효과를 없도록 하는 것이 원칙이지만 doOnXXX() 계열 함수는 오히려 부수 효과를 일으켜서 내가 작성하는 코드가 문제없는지 알아볼 수 있게 도와준다.</p>
<p>이번 Chapter에서 알아보자.</p>
<h2 id="doonxxx-함수">doOnXXX() 함수</h2>
<p>doOnNext(), doOnComplete(), doOnError() 3가지 함수는 Observable의 알림 이벤트에 해당한다. Observable에서 어떤 데이터를 발행할 때는 onNext, 중간에 에러가 발생하면 onError, 모든 데이터를 발행하면 onComplete 이벤트가 발생한다. <strong>어떻게 보면 이 알림 이벤트를 위의 함수가 가로채서 디버깅을 할 수 있도록 도와주는 것이다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnXXX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.e(<span class="string">"onError"</span>, error))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | onNext() | debug = <span class="number">3</span></span><br><span class="line">main | value = <span class="number">3</span></span><br><span class="line">main | onNext() | debug = <span class="number">5</span></span><br><span class="line">main | value = <span class="number">5</span></span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>결과는 위와 같이 나온다. doOnNext(), doOnComplete(), doOnError() 함수를 사용해 로그를 출력해봤다. 모두 main 스레드에서 실행되었고, 실제로 Observable이 구독자에게 발행한 데이터는 value로 표시하였다.</p>
<p>하지만, doOnError() 함수의 동작을 보지 못했다. 다른 예제를 통해서 확인해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnXXX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">                .map(divider -&gt; <span class="number">1000</span> / divider)</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.e(<span class="string">"onError()"</span>, error.getMessage()))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">100</span></span><br><span class="line">main | value = <span class="number">100</span></span><br><span class="line">main | onNext() | debug = <span class="number">200</span></span><br><span class="line">main | value = <span class="number">200</span></span><br><span class="line">main | onError() | error = / by zero</span><br><span class="line">io.reactivex.exceptions.OnErrorNotImplementedException: <span class="function">The exception was not handled due to missing onError handler in the <span class="title">subscribe</span><span class="params">()</span> method call. Further reading</span></span><br></pre></td></tr></table></figure>
<p>어떤 수를 0으로 나누려고 하기 때문에 0 데이터가 발행될 때 에러가 발생하는 것을 볼 수 있다.</p>
<h2 id="dooneach-함수">doOnEach() 함수</h2>
<p>onNext, onComplete, onError 이벤트를 각각 처리하는 것이 아니라 한 번에 처리할 수 있기 때문에 편리하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"ONE"</span>, <span class="string">"TWO"</span>, <span class="string">"THREE"</span>)</span><br><span class="line">                .doOnEach(noti -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnNext()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onNext()"</span>, noti.getValue());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnComplete()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onComplete()"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (noti.isOnError()) &#123;</span><br><span class="line">                        Log.d(<span class="string">"onError()"</span>, noti.getError().getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = ONE</span><br><span class="line">main | value = ONE</span><br><span class="line">main | onNext() | debug = TWO</span><br><span class="line">main | value = TWO</span><br><span class="line">main | onNext() | debug = THREE</span><br><span class="line">main | value = THREE</span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>Notification<t> 객체는 발생한 이벤트의 종류를 알 수 있는 boolean 타입의 isOnNext(), isOnComplete(), isOnError() 함수를 제공한다. onNext()의 경우는 getValue() 함수를 호출하면 발행된 값을 얻을 수 있다. onError() 함수의 경우 getError() 함수를 호출하면 Throwable 객체를 얻을 수 있다.</t></p>
<p><code>doOnEach()</code> 함수는 오직 onNext, onComplete, onNext 이벤트만 처리한다. 그리고 람다식을 잘 활용하여 간결하 코드를 유지하도록 한다.</p>
<h2 id="doonsubscribe-doondispose-기타-함수">doOnSubscribe(), doOnDispose(), 기타 함수</h2>
<p>Observable의 알림 이벤트 중에는 onSubscribe와 onDispose 이벤트도 있다. 각각 Observable을 구독했을 때와 구독 해지했을 때의 이벤트를 처리할 수 있다.</p>
<ul>
<li>doOnSubscribe() : Observable을 구독했을 때 어떤 작업을 할 수 있다. 람다 표현식의 인자로는 구독의 결과로 나오는 Disposable 객체가 제공된다.</li>
<li>doOnDispose() : Observable의 구독을 해지했을 때 호출되며 인자는 Action 객체이다. 여러 스레드에서 Observable을 참조할 수 있기 때문에 Action 객체는 <code>Thread-Safe</code>하게 동작해야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnSubscribe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"2"</span>, <span class="string">"6"</span>)</span><br><span class="line">                .zipWith(Observable.interval(<span class="number">100L</span>, TimeUnit.MILLISECONDS), (a, b) -&gt; a)</span><br><span class="line">                .doOnSubscribe(data -&gt; Log.d(<span class="string">"onSubscribe()"</span>))</span><br><span class="line">                .doOnDispose(() -&gt; Log.d(<span class="string">"onDispose"</span>));</span><br><span class="line"></span><br><span class="line">        Disposable d = source.subscribe(Log::i);</span><br><span class="line"></span><br><span class="line">        CommonUtils.sleep(<span class="number">200</span>);</span><br><span class="line">        d.dispose();</span><br><span class="line">        CommonUtils.sleep(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | debug = onSubscribe()</span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool-<span class="number">1</span> | value = <span class="number">3</span></span><br><span class="line">main | debug = onDispose</span><br></pre></td></tr></table></figure>
<p>한편 doOnSubscribe()와 doOnDispose() 함수를 각각 호출하지 않고 한번에 호출하는 함수인 <code>doOnLifeCycle()</code> 함수가 존재한다. 위의 코드에서 doOnSubscribe()와 doOnDispose() 함수를 빼고 <code>doOnLifeCycle()</code> 함수를 사용하면 된다. 결과는 같다.</p>
<p>또한, <code>doOnTerminate()</code> 함수는 Observable이 끝나는 조건이 onComplete 혹은 onError 이벤트가 발생했을 때 실행하는 함수이다. 정확하게는 onComplete() 혹은 onError() 이벤트 발생 직전에 호출된다.</p>
<p>다음 코드를 통해서 결과를 확인해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doOnTerminate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>, <span class="string">"7"</span>)</span><br><span class="line">                .doOnTerminate(() -&gt; Log.d(<span class="string">"onTerminate()"</span>))</span><br><span class="line">                .doOnNext(data -&gt; Log.d(<span class="string">"onNext()"</span>, data))</span><br><span class="line">                .doOnComplete(() -&gt; Log.d(<span class="string">"onComplete()"</span>))</span><br><span class="line">                .doOnError(error -&gt; Log.d(<span class="string">"onError()"</span>, error.getMessage()))</span><br><span class="line">                .subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | onNext() | debug = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | onNext() | debug = <span class="number">3</span></span><br><span class="line">main | value = <span class="number">3</span></span><br><span class="line">main | onNext() | debug = <span class="number">5</span></span><br><span class="line">main | value = <span class="number">5</span></span><br><span class="line">main | onNext() | debug = <span class="number">7</span></span><br><span class="line">main | value = <span class="number">7</span></span><br><span class="line">main | debug = onTerminate()</span><br><span class="line">main | debug = onComplete()</span><br></pre></td></tr></table></figure>
<p>onComplete 이벤트가 발생하기 직전에 <code>doOnTerminate()</code> 함수가 호출되는 것을 확인할 수 있다.</p>
<h1 id="예외-처리">예외 처리</h1>
<p>자바에서는 예외를 처리할 때 try-catch문을 사용했지만, RxJava에서는 사용할 수 없다.<br>
사용한다면 다음과 같은 에러를 만나게 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OnErrorNotImplementedException</span><br></pre></td></tr></table></figure>
<p>RxJava 내부에서 onError를 함수의 인자로 넘긴다. 따라서 try-catch문을 활용할 수가 없다. 추가로 함수 체인이나 Observable 내부에서 예외가 발생해도 onError 이벤트가 발생하고 try-catch 문으로는 해결할 수 없다.</p>
<h2 id="onerrorretrun-함수">onErrorRetrun() 함수</h2>
<ul>
<li>에러도 어떠한 데이터로 보는 것이 적절하다.</li>
<li>예외가 발생했을 때 에러를 의미하는 다른 데이터로 대체한다.</li>
<li>onError 이벤트는 데이터 흐름이 바로 중단되므로 subscribe() 함수를 호출할 때, onError 이벤트를 처리하는 것은 OOM 같은 중대한 에러가 발생했을 때만 활용한다.</li>
<li>에러가 발생했을 때 내가 원하는 데이터로 대체할 수 있다.</li>
</ul>
<img src="/img/onErrorReturn.png" width="500" height="200">
<p>위의 그림에서 앞의 3개의 데이터가 정상적으로 발행되고 마지막 데이터에서 에러가 발생하는 경우, onErrorReturn() 함수는 인자로 넘겼던 기본ㄱ밧을 대신 발행하고 <strong>onComplete 이벤트가 발생한다. onError() 이벤트는 발생하지 않는다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] grades = &#123;<span class="string">"70"</span>, <span class="string">"60"</span>, <span class="string">"$100"</span>, <span class="string">"93"</span>, <span class="string">"83"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(grades)</span><br><span class="line">                .map(data -&gt; Integer.parseInt(data))</span><br><span class="line">                .onErrorReturn(e -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NumberFormatException) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data found!!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Grade is "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>에러를 <code>onErrorReturn()</code> 함수에서 처리하며 NumberFormatException 발생 시 -1을 리턴한다. subscribe() 함수는 성적 데이터를 처리하므로 0보다 커야 하낟. onErrorReturn() 함수에서 예외 발생 시 음수 값을 리턴했으므로 data가 0보다 작으면 에러 발생 여부를 판단하고 에러 로그를 출력한다.</li>
</ul>
<p><strong>onError 이벤트에서 예외를 처리하는 것과 다른 점</strong></p>
<ol>
<li>예외 발생이 예상되는 부분을 선언적으로 처리할 수 있다.</li>
<li>Observable을 생성하는 측과 구독하는 측이 서로 다를 수 있다는 점이다.
<ul>
<li>구독자는 Observable에서 발생할 수 있는 예외를 구독한 이후에 파악하는 것이 어렵다.</li>
<li>다시 말하면 Observable에서 에러 가능성을 명시하지 않았는데 구독자가 필요한 예외 처리를 빠짐없이 하는 것은 어렵다는 뜻이다. 이럴때 Observable을 생성하는 측에서 발생하는 예외 처리를 미리 해두면 구독자는 선언된 예외 상황을 보고 그에 맞는 처리를 할 수 있다.</li>
</ul>
</li>
</ol>
<ul>
<li>onErrorReturnItem() : onErrorReturn() 함수와 동일하지만 Throwable 객체를 인자로 전달하지 않기 때문에 코드는 좀 더 간결해진다. 즉, 가독성이 좋아진다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorReturn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] grades = &#123;<span class="string">"70"</span>, <span class="string">"60"</span>, <span class="string">"$100"</span>, <span class="string">"93"</span>, <span class="string">"83"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(grades)</span><br><span class="line">                .map(data -&gt; Integer.parseInt(data))</span><br><span class="line">                .onErrorRetrunItem(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data found!!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Grade is "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onerrorresumenext-함수">onErrorResumeNext() 함수</h2>
<ul>
<li>onErrorReturn(), onErrorReturnItem()은 에러가 발생한 시점에 특정 값으로 대체.</li>
<li>에러가 발생했을 때, 내가 원하는 Observable로 대체하는 방법이다.</li>
<li>Observable로 대체한다는 것은 에러 발생 시 데이터를 교체하는 것뿐만 아니라 관리자에게 이메일을 보낸다던가 자원을 해제하는 등의 추가 작업을 해야할 때 유용하다.</li>
</ul>
<img src="/img/onErrorResumeNext.png" width="500" height="200">
<p>에러가 발생했을 때, 특정 값을 원하는 Observable로 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">onErrorResumeNext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] salesData = &#123;<span class="string">"100"</span>, <span class="string">"200"</span>, <span class="string">"A300"</span>&#125;;</span><br><span class="line">        Observable&lt;Integer&gt; onParseError = Observable.defer(() -&gt; &#123;</span><br><span class="line">            Log.d(<span class="string">"send email to administrator"</span>);</span><br><span class="line">            <span class="keyword">return</span> Observable.just(-<span class="number">1</span>);</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line"></span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.fromArray(salesData)</span><br><span class="line">                .map(Integer::parseInt)</span><br><span class="line">                .onErrorResumeNext(onParseError);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(<span class="string">"Wrong Data Found!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.i(<span class="string">"Sales data: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = Sales data: <span class="number">100</span></span><br><span class="line">main | value = Sales data: <span class="number">200</span></span><br><span class="line">RxCachedThreadScheduler-<span class="number">1</span> | debug = send email to administrator</span><br><span class="line">RxCachedThreadScheduler-<span class="number">1</span> | error = Wrong Data Found!</span><br></pre></td></tr></table></figure>
<ul>
<li>이처럼 에러가 발생했을 때 관리자에게 이메일을 보내고 '-1’이라는 데이터를 발행하는 Observable로 대체한다.</li>
<li>onParseError 변수는 subscribeOn() 함수를 호출하여 IO 스케줄러에서 실행한다. 이처럼 내가 원하는 코드를 실행하는 스케줄러를 선언적으로 지정할 수 있어 활용범위가 넓다.</li>
</ul>
<h2 id="retry-함수">retry() 함수</h2>
<ul>
<li>예외 처리의 다른 방법은 재시도이다.</li>
<li>예를 들어 서버와 통신할 때 인터넷이 일시적으로 안되거나 서버에 일시적인 장애가 발생하면 클라이언트에서는 일정 시간 후에 다시 통신을 요청하는 것이 필요하다. 이때 1개의 API가 아닌 다수의 API를 연속해서 호출해야 하는 경우 재시도하는 시나리오가 복잡해질 수도 있다.</li>
<li>이런 것을 단순하게 처리할 수 있는 <code>retry()</code> 함수를 제공한다. onError 이벤트 발생 시 해당 처리를 재시도한다.</li>
</ul>
<img src="/img/retry.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .retry(<span class="number">5</span>)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            Log.it(<span class="string">"result: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>retry() 함수의 실행횟수는 5회로 지정한다. 마지막으로 에러 발생시 ERROR_CODE를 반환한다. 재시도 동작을 확인하기 위해서는 인터넷 환경을 끊은 상태에서 테스트를 진행해야 한다. 결과는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main | 645 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">main | 646 | error = api.github.com</span><br><span class="line">main | 646 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | error = api.github.com</span><br><span class="line">main | 647 | value = result: -500</span><br></pre></td></tr></table></figure>
<ul>
<li>5회의 재시도 후 최종 요청이 실패 처리되었다. <code>getT()</code> 함수를 통해서 api 접속을 시도하지만 예외가 발생해서 에러 로그를 찍는 부분으로 빠진다. 요청을 5번 시도하면서 계속 에러 로그를 찍고 그 후에 <code>onErrorReturn()</code> 함수에서 에러 코드를 반환하고 종료한다.</li>
<li>위에서 실행 시간이 문제가 있다. 재시도를 할 때 지연 시간이 없이 바로 재시도하기 때문에 도움이 되지 않는다. 지연 시간을 설정해서 재시도를 해보자.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryDelaySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> RETRY_MAX = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> RETRY_DELAY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .retry((retryCount, e) -&gt; &#123;</span><br><span class="line">                    Log.e(<span class="string">"retryCount: "</span> + retryCount);</span><br><span class="line">                    CommonUtils.sleep(RETRY_DELAY);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> retryCount &lt; RETRY_MAX ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(data -&gt; &#123;</span><br><span class="line">            Log.it(<span class="string">"result: "</span> + data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재시도 횟수는 5회이고 지연 시간 간격은 1000ms이다. 재시도할 때 CommonUtils.sleep() 함수를 호출해 1000ms 동안 대기한다.</li>
<li>api 호출을 하고 인터넷 연결이 되어 있지 않다면 재시도를 하게 된다. 5번까지 재시도를 하고 1000ms 간격으로 시도를 하면서 재시도 횟수를 로그를 통해 기록한다. 재시도 횟수가 5회 이하일 때는 true를 이후에는 false를 반환한다.</li>
<li>결과는 다음과 같다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main | 716 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">main | error = retryCount: 1</span><br><span class="line">main | 1721 | error = api.github.com</span><br><span class="line">main | error = retryCount: 2</span><br><span class="line">main | 2726 | error = api.github.com</span><br><span class="line">main | error = retryCount: 3</span><br><span class="line">main | 3726 | error = api.github.com</span><br><span class="line">main | error = retryCount: 4</span><br><span class="line">main | 4728 | error = api.github.com</span><br><span class="line">main | error = retryCount: 5</span><br><span class="line">main | 5732 | value = result: -500</span><br></pre></td></tr></table></figure>
<h2 id="retryuntil">retryUntil()</h2>
<ul>
<li>retry() 함수는 재시도를 지속할 조건이 없을 때 재시도를 중단한다.</li>
<li>재시도를 중단할 조건이 발생할 때까지 재시도 한다.</li>
<li>함수 원형은 다음과 같다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">retryUntil</span><span class="params">(<span class="keyword">final</span> BooleanSupplier stop)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>BooleanSupplier 객체는 인자는 없고 Boolean 값을 리턴하는 함수형 인터페이스다.</li>
<li>즉, retryUntil() 함수의 인자로 Boolean 값을 리턴하는 구문이 들어가야 한다. 이게 재시도를 중단할 조건을 의미한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryUntil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonUtils.exampleStart();</span><br><span class="line"></span><br><span class="line">        String url = <span class="string">"https://api.github.com/zen"</span>;</span><br><span class="line">        Observable&lt;String&gt; source = Observable.just(url)</span><br><span class="line">                .map(OkHttpHelper::getT)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .retryUntil(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (CommonUtils.isNetworkAvailable()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 중지.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    CommonUtils.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 계속 진행.</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .onErrorReturn(e -&gt; CommonUtils.ERROR_CODE);</span><br><span class="line"></span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// IO 스케줄러에서 실행되기 때문에 sleep 함수가 필요함.</span></span><br><span class="line">        CommonUtils.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>보통 재시도 로직은 별도의 스레드에서 동작하기 때문에 <strong>IO 스케줄러</strong>를 활용한다.</li>
<li>retryUntil() 함수의 인자인 람다 표현식에는 먼저 <code>CommonUtils.isNetworkAvailable()</code>를 호출해 네트워크가 사용 가능한 상태인지 확인한다. 만약, true를 반환하면 재시도를 중단하도록 true를 반환한다. 네트워크를 사용할 수 없는 상태라면 1000ms를 쉬고 재시도(재구독)한다. 이때 람다 표현식은 false를 반환한다.</li>
<li>결국 retryUntil 함수의 인자인 람다 표현식이 true를 반환해야 재시도를 중단하게 된다. false를 반환하면 재시도를 계속하게 된다.</li>
<li>결과는 다음과 같다. Process가 종료된 것은 인터넷에 연결되어 재시도가 끝났다는 것으로 해석할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RxCachedThreadScheduler-1 | 680 | error = api.github.com: nodename nor servname provided, or not known</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-2 | 1685 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-2 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-1 | 2691 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-2 | 3695 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-2 | Network is not available</span><br><span class="line">RxCachedThreadScheduler-1 | 4698 | error = api.github.com</span><br><span class="line">RxCachedThreadScheduler-1 | Network is not available</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<h2 id="retrywhen">retryWhen()</h2>
<ul>
<li>재시도와 관련된 함수 중 가장 복잡하다.</li>
<li>주로 재시도 조건을 동적으로 설정해야 하는 복잡한 로직을 구현할 때 사용한다.</li>
</ul>
<img src="/img/retryWhen.jpeg" width="500" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/07/05/RxJava-Chap07/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/"
                            aria-label=": [Android] RecyclerView ClickListener"
                        >
                            [Android] RecyclerView ClickListener
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-05T12:34:18+09:00">
	
		    Jul 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>이번에는 Android에서 RecyclerView를 사용할 때, 각 아이템의 ClickListener를 다는 방법에 대해서 설명하려고 한다. 여러가지 방법이 있겠지만, 이번에는 Kotlin의 특징 중 하나인 <strong>함수를 매개변수로 넘길 수 있다는 특징</strong>을 사용하려고 한다.</p>
                    
                        <a
                            href="/2019/07/05/Android-RecyclerView-ClickListener-kotlin/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] RecyclerView ClickListener"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/07/04/Android-EditTextFunction/"
                            aria-label=": [Android] EditText 유용한 기능"
                        >
                            [Android] EditText 유용한 기능
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-07-04T15:56:02+09:00">
	
		    Jul 04, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>안드로이드에서 EditText는 거의 필수적인 존재라고 봐도 무방할 것 같다. 자주 사용하지만, 매번 필요한 기능을 검색해보기 때문에 유용한 기능들을 정리하려고 포스팅하게 되었다.</p>
                    
                        <a
                            href="/2019/07/04/Android-EditTextFunction/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] EditText 유용한 기능"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/26/Android-Dialog-Context/"
                            aria-label=": [Android] Dialog Error?!"
                        >
                            [Android] Dialog Error?!
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-26T23:27:06+09:00">
	
		    Jun 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>Android 개발을 함에 있어서 <strong>AlertDialog</strong>를 사용하는 경우를 많이 접해봤을 것이다. 예를 들면, 야놀자 앱을 켰을 때 뜨는 광고가 Dialog의 한 예라고 볼 수 있다. 필자도 이러한 Dialog를 만들어야 하는데, 기본으로 제공하는 것이 아니라 Custom 해야 했다.</p>
                    
                        <a
                            href="/2019/06/26/Android-Dialog-Context/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] Dialog Error?!"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/25/Android-RecyclerView-BottomSpace/"
                            aria-label=": [Android] RecyclerView Bottom padding"
                        >
                            [Android] RecyclerView Bottom padding
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-25T20:30:17+09:00">
	
		    Jun 25, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>Android에서 RecyclerView의 사용은 거의 필수라고 할 수 있다. 왜냐하면 리스트를 보여주는 화면은 대부분의 앱에 존재할 것이기 때문이다. 이번 글은 간단하다. 리싸이클러뷰를 사용하는 사람이라면 글을 읽는데 어려움이 없을 것이다. 사실, 몰라도 볼 수 있다. 그만큼 간단한 글이다.</p>
                    
                        <a
                            href="/2019/06/25/Android-RecyclerView-BottomSpace/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] RecyclerView Bottom padding"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/24/Android-Progressbar-tip/"
                            aria-label=": [Android] 로딩시 어떻게 할 것인가?"
                        >
                            [Android] 로딩시 어떻게 할 것인가?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-24T23:37:18+09:00">
	
		    Jun 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>안드로이드 개발에서 서버로부터 데이터를 불러올 때, 네트워크 상황이 좋지 않다면 금방 불러올 수 없을 것이다. 시간이 어느 정도 걸린다. 또한, 불러오는 데이터 중 사진, 영상이 많거나 데이터의 양이 많다면 시간이 오래 걸린다.</p>
                    
                        <a
                            href="/2019/06/24/Android-Progressbar-tip/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] 로딩시 어떻게 할 것인가?"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/6/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/8/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 7 of 26</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
