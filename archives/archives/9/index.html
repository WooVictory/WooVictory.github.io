
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/9/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/kotlin-chap3/"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            [커니의 Kotlin] Chap3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T21:52:08+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/커니의-Kotlin/">커니의 Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>해당 글은 <strong>커니의 코틀린</strong> 책을 구매하여 공부하고 작성한 글입니다.</p>
                    
                        <a
                            href="/2019/05/28/kotlin-chap3/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/Two-Pointer-Algorithm/"
                            aria-label=": [알고리즘] 투포인터 알고리즘"
                        >
                            [알고리즘] 투포인터 알고리즘
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T12:39:06+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>신입 개발자를 위한 <a href="https://github.com/WooVictory/Ready-For-Tech-Interview" target="_blank" rel="noopener">Repository</a>를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다.</p>
<p>알고리즘 문제를 풀다가 완전 탐색으로 해결하면 시간 초과가 나서 어떻게 풀어야 하는가 하다가 검색해보니 <code>투 포인터 알고리즘</code>이라는 개념이 나와서 간단하게 정리하고 넘어가겠다.</p>
<p>1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 것을 얻는 형태이다. 이 때문에 투 포인터 알고리즘이라고 부른다.</p>
<p><strong>대표적인 문제</strong></p>
<ul>
<li><a href="https://www.acmicpc.net/problem/2003" target="_blank" rel="noopener">2003</a></li>
</ul>
<p>문제는 N칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소의 합이 M이 되는 경우의 수를 구하는 것이다. 모든 경우의 수를 다 테스트해보면, 구간 합을 구간합 배열로 O(1)만에 구한다고 해도 경우의 수가 (N^2)이 된다. 따라서 문제를 풀 수 없다.</p>
<p>이 문제에서 <strong>각 원소는 자연수이고 M 또한 자연수</strong>인데, 이 조건이 성립하면 사용할 수 있는 알고리즘은 다음과 같다.</p>
<ul>
<li>포인터 2개를 준비한다. 시작과 끝을 나타낼 수 있도록 start, end라고 하겠다.</li>
<li>맨 처음에는 start = end = 0이며, 항상 start&lt;=end 을 만족해야 한다.</li>
<li>이 두개의 포인터는 현재 부분 배열의 시작과 끝을 가리키는 역할을 한다.</li>
</ul>
<p>s = e일 경우 그건 크기가 0인 즉, 아무것도 포함하지 않는 부분 배열을 뜻한다. 이제 아래의 과정을 <strong>start&lt;N</strong> 인 동안 반복한다.</p>
<ol>
<li>현재 부분합이 M 이상이거나, 이미 end = N이면 start++</li>
<li>그렇지 않다면 end++</li>
<li>현재 부분합이 M과 같다면 count++</li>
</ol>
<p>쉽게 이해하자면, start와 end를 무조건 증가시키는 방향으로만 변화시켜가면서, 도중에 부분 배열의 합이 정확히 M이 되는 경우를 세는 것이다.</p>
<p>그림으로 보는게 편하다. 그림을 그리기에는 시간이 좀 걸려서 내가 보고 이해한 그림을 첨부하겠다. 아래 참고한 블로그를 보면 설명을 아주 잘해주셨다. 이것만 보면 이해가 될 것이다.</p>
<p>대표적인 문제를 풀어봤다. 백준 2003번으로 <strong>수들의 합2</strong> 문제이다. 풀이는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 투포인터 알고리즘</span></span><br><span class="line"><span class="comment"> * start : 시작</span></span><br><span class="line"><span class="comment"> * end : 끝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] input = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = parse(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = parse(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        String[] num = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = parse(num[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 부분합이 m 보다 큰 경우 start 가 가리키는 원소를 빼고</span></span><br><span class="line">            <span class="comment">// start 의 값을 증가시킨다. 즉, start 뒤로 이동.</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= m) &#123;</span><br><span class="line">                sum = sum - arr[start++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// end 가 n 에 도달하면 종료한다.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end == n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 위의 두 경우에 해당하지 않으면 end 는 뒤로 이동하면서 원소의 값을</span></span><br><span class="line">                <span class="comment">// sum 에 더한다.</span></span><br><span class="line">                sum = sum + arr[end++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 부분 합이 m 과 같다면 count 를 증가시켜준다.</span></span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://m.blog.naver.com/kks227/220795165570" target="_blank" rel="noopener">투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/Two-Pointer-Algorithm/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/What-is-Kotlin-Object/"
                            aria-label=": [Kotlin] Object"
                        >
                            [Kotlin] Object
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T00:25:51+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에는 static 개념이 없다. 사실 개념이 없다기 보다는 static keyword가 없기 때문에 Java의 static 개념을 코틀린에서 표현할 수 없다. 그래서 이를 어떻게 표현하는지 중점적으로 살펴보겠다.</p>
<ul>
<li>싱글톤을 정의하는 방법</li>
<li>동반 객체 companion object를 이용한 팩토리 메소드 구현</li>
<li>익명 클래스 선언</li>
</ul>
<p>위의 3가지를 <strong>object</strong> keyword를 이용해 표현한다.</p>
<h2 id="싱글톤">싱글톤</h2>
<p>코틀린에서는 object를 이용하여 클래스를 정의함과 동시에 객체를 생성할 수 있다. 말 그대로 싱글톤을 쉽게 구현할 수 있다. 이해하기 쉽게 간단한 예제를 만들었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPreference</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SharedPreference INSTACNE=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedPreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTACNE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTACNE = SharedPreference();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 자바에서 사용할 수 있는 간단한 싱글톤 패턴 구현 코드이다. 그럼 이제 코틀린에서 object를 사용해 바꿔보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreference&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    SharedPreference.init(applicationContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 object로 선언하면 클래스 선언과 동시에 객체가 생성된다. 따라서 객체 이름을 통해 property나 메소드에 접근할 수 있다.</p>
<p>object 클래스는 가장 바깥 클래스로 선언될 수도 있고, 내부에 중첩된 클래스 형태로 선언될 수도 있다. 하지만, 어떤 방식으로 선언되었던 간에 존재하는 object는 단일 객체만 존재한다.</p>
<h2 id="companion-object">companion object</h2>
<p>코틀린에서는 static을 지원하지 않는 대신 <code>top-level function</code>을 통해 같은 효과를 낼 수 있다. 단, top-level function은 class 내부에 선언된 private property에는 접근할 수 없는 제한을 받는다.</p>
<p>이를 해결하기 위해서 <code>companion object</code>라는 개념이 존재한다. 클래스의 인스턴스 생성과 상관없이 호출해야 하지만 class의 내부 정보에 접근할 수 있는 함수가 필요할 때 companion obejct를 class 내부에 선언한다. <strong>Java로 따지면 class 내부에 static 함수를 넣는다고 생각하면 된다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion obejct call!!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    A.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 A 클래스 내부에서 선언된 companion object는 호출할 때 클래스 이름으로 바로 호출할 수 있다. (Java의 static 함수와 동일한 형태이다.)</p>
<p>또한, <code>companion object</code>는 외부 클래스의 private property에도 접근이 가능하기 때문에, factory method를 만들 때 적합하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId: <span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> subscribingUser = User.newSubscribingUser(<span class="string">"jhsw0375@gmail.com"</span>)</span><br><span class="line">    <span class="keyword">val</span> facebookUser = User.newFacebookUser(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    println(subscribingUser.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 User 클래스는 <strong>private constructor</strong>를 가지기 때문에 외부에서 생성할 수 없다. 따라서 외부에서는 companion으로 제공되는 factory method를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</p>
<h2 id="companion-object의-사용">companion object의 사용</h2>
<p>companion object는 클래스 내부에 정의된 일반 객체이다. 따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object에 이름 명명</li>
<li>companion object 내부에 확장 함수나 property 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: Person = ... 생략.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    person = Person.Loader.fromJSON(<span class="string">"&#123;name: 'kim'&#125;"</span>)</span><br><span class="line">    person = Person.fromJSON(<span class="string">"&#123;name: 'lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>companion object에 이름을 붙일 수 있으며, 이름을 통해서 호출할 수도 있고 그냥 호출할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: JSONFactory&#123;</span><br><span class="line">        <span class="keyword">override</span> fromJSON(jsonText: String): Person = ... 생략</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> loadFromText<span class="type">&lt;T&gt;</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T&#123;</span><br><span class="line">    ... 생략.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    loadFromText(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 companion object가 특정 interface를 구현할 수도 있고, 이 interface를 넘겨줄 때는 외부 class 이름을 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"clicked!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">    clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 익명 클래스는 singleton이 아니다. 따라서 호출시 매번 객체가 생성된다는 점과 익명 클래스 내에서는 외부 클래스의 변수에 접근하여 값을 수정할 수도 있다.</p>
<h2 id="sharedpreferences-예제">SharedPreferences 예제</h2>
<p>Android에서는 간단한 값을 저장하기 위해서 <code>SharedPreferences</code>를 사용한다. 프로그램 어디서나 이 객체를 사용할 수 있어야 하기 때문에 일반적으로 <strong>Singleton</strong>을 이용해 구현하곤 한다. 자바에서는 싱글톤을 손쉽게 구현할 수 있다. 마찬가지로 코틀린에서도 object 개념을 사용해서 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreferenceManager&#123;</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> PREF_TOKEN = <span class="string">"token"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span>&#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 확장 함수를 사용한다. 따라서 edit(), apply() 함수를 호출할 필요가 없다. 모든 작업을 이 함수 하나로 대체할 수 있다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(operation: (<span class="type">SharedPreferences</span>.<span class="type">Editor</span>)</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> editor = edit()</span><br><span class="line">        operation(edit)</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> token: String</span><br><span class="line">        <span class="keyword">get</span>() = preferences.getString(PREF_TOKEN,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = preferences.edit&#123;</span><br><span class="line">            it.putString(PREF_TOKEN, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>간단하게 토큰을 저장하는 예제이다. 저장해서 확인해보는 과정까지 거친 코드이므로 잘 동작한다. 확장 함수를 만들어서 이를 통해 edit(), apply() 함수를 직접 호출할 필요가 없다. 작성한 함수만 사용하면 되기 때문이다.</p>
<p>또한, 여러 개의 함수를 만들 필요 없이 하나의 함수만 사용하면 되고 저장할 값이 필요하다면 token 처럼 만들어서 사용자 지정 get,set을 사용하여 값을 가져오고 저장하는 과정을 거치면 된다.</p>
<p>이 클래스를 만들기 위해서 처음에 어떻게 잘 짤 수 있을까를 먼저 고민해보았다. 그런데 바보 같은 생각이라는 걸 깨달았다. 처음부터 잘 짤 수는 없는 것이다. 완벽한 코드는 없으면 코드를 짜면서 공부를 하면서 수정하면 되는 것이다.</p>
<p>그러니 처음부터 완벽한 코드를 짜려고 애쓰지 않도록 마음 먹었다. 리팩토링을 하면 나의 코드를 더 발전시켜 나갈 수 있으니 말이다. 오늘은 여기까지!</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://lomza.totem-soft.com/tutorial-how-to-use-sharedpreferences-in-kotlin/" target="_blank" rel="noopener">[Tutorial] How to use SharedPreferences in Kotlin</a></li>
<li><a href="https://tourspace.tistory.com/109" target="_blank" rel="noopener">[Kotlin] 코틀린 object</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/What-is-Kotlin-Object/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/24/Algorithm-Set/"
                            aria-label=": [알고리즘] 부분집합"
                        >
                            [알고리즘] 부분집합
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-24T16:24:20+09:00">
	
		    May 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>백준에 있는 문제 중 1182번을 풀면서 부분집합에 대한 내용이 나와서 간단하게 정리하려고 한다.</p>
<p>예를 들어 배열 [1,2,3]이 있다고 가정하자. 그러면 부분집합은 아래와 같다.</p>
<p>[1]<br>
[2]<br>
[3]<br>
[1,2]<br>
[1,3]<br>
[2,3]<br>
[1,2,3]</p>
<p>부분 집합을 구할 수 있는 방법은 조합을 이용한 방법이 있고 재귀를 이용한 방법이 있다. 이번에는 후자인 재귀에 대해서만 알아보도록 하겠다.</p>
<p>두 가지 경우를 생각해보면 된다.</p>
<ol>
<li>현재 인덱스를 포함하는 경우</li>
<li>현재 인덱스를 포함하지 않는 경우</li>
</ol>
<p>위의 두 가지 경우를 visited 배열에 방문했는지 체크함으로써 분기시킬 수 있다. 두 가지 경우에 대해서 모두 확인한 후에 현재 인덱스가 n이 되면 출력한다.</p>
<p>출력할 때는 visited 배열의 값이 true인 원소들만 출력한다.<br>
코드는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        getSet(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getSet</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == n) &#123;</span><br><span class="line">            print(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[index] = <span class="keyword">false</span>;</span><br><span class="line">        getSet(arr, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        getSet(arr, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://bcp0109.tistory.com/17" target="_blank" rel="noopener">부분집합 PowerSet (Java)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/24/Algorithm-Set/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/22/RxJava-Chap03/"
                            aria-label=": [RxJava] Chap03"
                        >
                            [RxJava] Chap03
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-22T15:47:34+09:00">
	
		    May 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="연산자">연산자</h2>
<p>ReactiveX의 연산자는 꽤 많다. 이 연산자들을 모두 안다고 하더라도 기억하기는 어렵다. 하지만, 이름을 보고 내용을 짐작할 수 있고 마블 다이어그램이 도움이 된다. 필요할 때 찾아보자.</p>
<p>대신, 여기서 소개하는 연산자는 자주 사용되니 꼭 알아두자!</p>
<h3 id="1map">1.map()</h3>
<ul>
<li>입력값을 어떤 함수에 넣어서 원하는 값으로 변환하는 함수이다.</li>
<li>입력 데이터가 있고 그것을 변환해줄 중개업자가 있다고 생각하면 좋다.</li>
<li>map() 함수는 반환값을 확인한다. 또한, 스케줄러를 지원하지 않으므로 현재 스레드에서 실행된다.</li>
<li><code>일대일 함수</code></li>
</ul>
<img src="/img/rx_map.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map을 통해 10을 곱해준 값을 반환.</span></span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">            .map &#123; item -&gt; item * <span class="number">10</span> &#125;</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(it.message)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 참조도 가능.</span></span><br><span class="line">    Observable.just(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"YELLOW"</span>,<span class="string">"BLACK"</span>)</span><br><span class="line">            .map(Test::ballToIndex) </span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(it.message)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ballToIndex</span><span class="params">(color: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        <span class="string">"RED"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"YELLOW"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"BLUE"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2flatmap">2.flatMap()</h3>
<ul>
<li>map() 함수와 동일한 기능을 하지만 결과가 Observable로 나온다.</li>
<li>결과값이 Observable이므로 여러 개의 데이터를 발행할 수 있다.</li>
<li><code>일대다 함수</code> 혹은 <code>일대일 Observable</code> 함수이다.</li>
<li>1개를 발행할 수도 여러 개를 발행할 수도 있다.</li>
</ul>
<img src="/img/rx_flatmap.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 인터페이스를 통해 제네릭 타입을 선언.</span></span><br><span class="line">    <span class="keyword">val</span> getDoubleDiamonds : (String) -&gt; Observable&lt;String&gt; = &#123; ball: String -&gt;</span><br><span class="line">        Observable.just&lt;String&gt;(<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>, <span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3개의 데이터를 넣었는데 6개를 발행한다.</span></span><br><span class="line">    <span class="comment">// 일대다이고, Observable 을 반환한다.</span></span><br><span class="line">    <span class="comment">// 위에서 정의한 Function 인터페이스 사용.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">            .flatMap(getDoubleDiamonds)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"성공 : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"실패 : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인라인을 사용.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>)</span><br><span class="line">            .map &#123; ball -&gt;</span><br><span class="line">                Observable.just(<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>,<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Function&lt;T,R&gt; : T는 입력값을 의미하고 R은 결과 함수이다.</li>
<li>String을 넣으면 여러 개의 String을 발행하는 Observable이 나온다.</li>
<li><strong>여러 개의 데이터를 발행하는 방법은 Observable 뿐이다.</strong></li>
</ul>
<h3 id="3filter-함수">3.filter() 함수</h3>
<ul>
<li>Observable에서 <code>원하는 데이터만 걸러내는 역할</code>을 한다.</li>
<li>즉, 필요없는 데이터는 제거하고 관심있는 데이터만 filter() 함수를 통과한다.</li>
<li>간단한 수식을 적용하는 것과 원하는 조건을 작성할 수도 있다.</li>
</ul>
<img src="/img/rx_filter.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 짝수만 필터링.</span></span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">            .filter &#123; number -&gt;</span><br><span class="line">                number % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">result : <span class="number">2</span></span><br><span class="line">result : <span class="number">4</span></span><br><span class="line">result : <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>이외에도 filter() 함수와 비슷한 함수들이 존재한다. 이름만 보고 어떤 기능을 할지 짐작이 가능하다.</p>
<ul>
<li><code>first(default)</code> : Observable의 첫 번째 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다.</li>
<li><code>last(default)</code> : Observable의 마지막 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다.</li>
<li><code>take(N)</code> : 최초 N개 값만 가져온다.</li>
<li><code>takeLast(N)</code> : 마지막 N개 값만 필터한다.</li>
<li><code>skip(N)</code> : 최초 N개 값을 건너뛴다.</li>
<li><code>skipLast(N)</code> : 마지막 N개 값을 건너뛴다.</li>
</ul>
<p>사용 예제는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source = Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>)</span><br><span class="line">    <span class="keyword">var</span> single: Single&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. first</span></span><br><span class="line">    single = source.first(<span class="number">-1</span>)</span><br><span class="line">    single.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"first result : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. last</span></span><br><span class="line">    single = source.last(<span class="number">-1</span>)</span><br><span class="line">    single.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"last result : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. take</span></span><br><span class="line">    source.take(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"take result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. takeLast</span></span><br><span class="line">    source.takeLast(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"takeLast result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. skip -&gt; 300,400,500,600</span></span><br><span class="line">    source.skip(<span class="number">2</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"skip result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. skipLast -&gt; 100,200,300</span></span><br><span class="line">    source.skipLast(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"skipLast result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">first result : <span class="number">100</span></span><br><span class="line">last result : <span class="number">600</span></span><br><span class="line">take result : <span class="number">100</span></span><br><span class="line">take result : <span class="number">200</span></span><br><span class="line">take result : <span class="number">300</span></span><br><span class="line">takeLast result : <span class="number">400</span></span><br><span class="line">takeLast result : <span class="number">500</span></span><br><span class="line">takeLast result : <span class="number">600</span></span><br><span class="line">skip result : <span class="number">300</span></span><br><span class="line">skip result : <span class="number">400</span></span><br><span class="line">skip result : <span class="number">500</span></span><br><span class="line">skip result : <span class="number">600</span></span><br><span class="line">skipLast result : <span class="number">100</span></span><br><span class="line">skipLast result : <span class="number">200</span></span><br><span class="line">skipLast result : <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h3 id="4reduce">4.reduce()</h3>
<ul>
<li>발행한 데이터를 모두 사용하여 어떤 최종 결과 데이터를 합성할 때 활용한다.</li>
<li>함수형 프로그래밍의 가장 기본 연산자인 map/filter/reduce 패턴을 이루는 마지막 필수 함수이다.</li>
<li>Observable을 이용해 들어오는 데이터를 1개씩 모아서 최종 결과를 만들어야 할 때 사용한다고 생각하면 된다. 주로 수치와 관련된 계산 문제에서 활용하면 좋다.</li>
</ul>
<p>보통 Observable에 입력된 데이터를 필요한 map() 함수로 매핑하고, 원하는 데이터만 추출할 때는 불필요한 데이터를 걸러내는 filter() 함수를 사용한다. 또한 상황에 따라 발행된 데이터를 취합하여 어떤 결과를 만들어낼 때는 reduce 계열의 함수를 사용한다.</p>
<img src="/img/rx_reduce.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source: Maybe&lt;String&gt; = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">            .reduce &#123; ball1, ball2 -&gt;</span><br><span class="line">                <span class="string">"<span class="variable">$ball2</span>(<span class="variable">$ball1</span>)"</span></span><br><span class="line">            &#125;</span><br><span class="line">    source.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"reduce 결과 : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 람다 표현식을 별도 함수로 분리.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>)</span><br><span class="line">            .reduce(mergeBalls)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"reduce 함수로 분리한 결과 : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce() 함수를 호출하면 인자로 넘긴 람다 표현식에 의해 결과 없이 완료될 수도 있다. 따라서 Observable이 아니라 결과가 반환할 수도 아닐 수도 있는 <code>Maybe</code> 객체로 리턴된다.</p>
<h3 id="예제">예제</h3>
<p>다음과 같은 예제를 한번 작성해보자.</p>
<ol>
<li>전체 매출 데이터를 입력한다.</li>
<li>매출 데이터 중 TV 매출을 필터링한다.</li>
<li>TV 매출의 합을 구한다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 데이터 입력.</span></span><br><span class="line">    <span class="comment">// first : 상품 이름, second : 매출액.</span></span><br><span class="line">    <span class="keyword">var</span> sales = mutableListOf&lt;Pair&lt;String, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    sales.add(<span class="string">"TV"</span> to <span class="number">2500</span>)</span><br><span class="line">    sales.add(<span class="string">"Camera"</span> to <span class="number">300</span>)</span><br><span class="line">    sales.add(<span class="string">"TV"</span> to <span class="number">1600</span>)</span><br><span class="line">    sales.add(<span class="string">"Phone"</span> to <span class="number">800</span>)</span><br><span class="line">    sales.add(<span class="string">"Sofa"</span> to <span class="number">10000</span>)</span><br><span class="line">    sales.add(Pair(<span class="string">"TV"</span>, <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> source: Maybe&lt;<span class="built_in">Int</span>&gt; = Observable.fromIterable(sales)</span><br><span class="line">            <span class="comment">// 2. 매출 데이터 중 TV 매출을 필터링한다.</span></span><br><span class="line">            .filter &#123; sale -&gt;</span><br><span class="line">                sale.first == <span class="string">"TV"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// map 을 통해 sale 에서 매출액만 뽑는다.</span></span><br><span class="line">            .map &#123; sale -&gt;</span><br><span class="line">                sale.second</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. reduce 를 통해 매출의 합을 구한다.</span></span><br><span class="line">            .reduce &#123; sale1, sale2 -&gt;</span><br><span class="line">                sale1 + sale2</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// reduce 를 호출하기 때문에 Observable 이 아니라 Maybe 를 사용한다.</span></span><br><span class="line"></span><br><span class="line">    source.subscribe(&#123; total -&gt;</span><br><span class="line">        println(<span class="string">"TV Sale: $ <span class="variable">$total</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">TV Sale: $ <span class="number">4100</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/22/RxJava-Chap03/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/22/What-is-BackTracking/"
                            aria-label=": [알고리즘] 백트래킹"
                        >
                            [알고리즘] 백트래킹
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-22T12:03:06+09:00">
	
		    May 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>알고리즘을 푸는데 백트래킹 문제가 나왔다. 근데, 백트래킹의 정확한 의미를 잘 몰라서 간략하게 정리하려고 한다.</p>
<h2 id="백트래킹">백트래킹</h2>
<p>위키피디아의 정의를 보면 <strong>한정 조건을 가진 문제를 풀려는 전략</strong>이라고 나와있다. 즉, 모든 조합의 수를 살펴보는 것인데 단 조건이 만족할 때만 살펴본다.</p>
<p>설명을 덧붙이자면, 어떤 노드의 유망성을 점검한 후, 유망하지 않으면 그 노드의 부모 노드로 되돌아간 후 다른 자손 노드를 검색한다.</p>
<ul>
<li>유망성은 조건을 만족하는가 아닌가를 뜻한다.</li>
<li>즉, 유망하지 않으면 배제를 하고 부모 노드로 돌아가서 풀이 시간이 단축될 수 있다.</li>
<li>DFS에서 가지치기를 통해 가도되지 않는 루트는 고려하지 않고 탐색하는 완전탐색 기법 중 하나이다.</li>
</ul>
<p>백트래킹의 대표적인 문제는 <code>N-Queen 문제</code>이다. 이 문제를 통해서 백트래킹을 한 번 더 이해해보자.</p>
<p><strong>N-Queen</strong></p>
<p>크키가 NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구해보자.</p>
<p>4x4를 기준으로 문제를 풀어보자. 퀸이 어떻게 이동할 수 있는지만 알면 체스가 무엇인지 몰라도 된다. 퀸은 배치된 칸을 기준으로 오와 열, 대각선 이동이 가능한 말이다.</p>
<img src="/img/algo_queen.jpeg" width="400" height="200">
<p>빨간색 선이 퀸이 이동할 수 있는 경로이고, 첫 번째로 배치된 퀸과 공격할 수 없도록 배치하려면 2번째 줄은 2,3번 위치에 퀸을 놓아야 조건을 만족시킬 수 있다. 첫 번째 퀸의 위치를 (1,1)로 하면 트리구조는 다음과 같다.</p>
<img src="/img/algo_queen2.jpeg" width="400" height="200">
<p>이 문제를 가지치기를 하지 않는 DFS로 풀었다면 유망하지 않는 즉, 조건에 위배하는 (2,1), (2,2) 지점도 검사했을 것이다. 그러면 연산 횟수가 많아져 시간복잡도도 증가했을 것이다.</p>
<p>그래서 백트래킹에서 가지치기를 잘해야 한다. 백트래킹은 크게 4가지 절차로 구성되어 있다.</p>
<ol>
<li>DFS 수행 - 평소와 같이 깊이 우선 탐색인 DFS를 수행하여 노드를 찾는다.</li>
<li>유망한 노드 검토 - 방문한 노드를 포함해서 유망한 노드이면 서브트리(하위노드)로 이동하고 그렇지 않으면 백트래킹을 수행하낟.</li>
<li>방문한 노드의 하위 노드로 이동하여 다시 재귀를 통해 DFS를 수행한다.</li>
<li>백트래킹 수행 - 방문한 노드를 가지치기를 하고 상위 노드로 백트래킹한 후 DFS를 다시 수행한다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 22/05/2019</span></span><br><span class="line"><span class="comment"> * 완탐 : N-Queen</span></span><br><span class="line"><span class="comment"> * 백트래킹의 대표적인 문제.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        N = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] column = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>]; <span class="comment">// N행 까지 담기 위해. index -&gt; 행, value -&gt; 열.</span></span><br><span class="line">            column[<span class="number">1</span>] = i; <span class="comment">// 1행 i열에 퀸을 놓음.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. DFS 수행.</span></span><br><span class="line">            <span class="comment">// 1행 i 열에 퀸을 놓았을 경우 dfs 로 가능한 경우를 확인한다.</span></span><br><span class="line">            dfs(column, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] column, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// row 와 N 이 같다는 말은 N 번째 행까지 퀸을 놓았다는 의미이다.</span></span><br><span class="line">        <span class="comment">// 즉, 퀸을 다 놓았다는 말! 따라서 count 를 증가시킨다.</span></span><br><span class="line">        <span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">                column[row + <span class="number">1</span>] = i; <span class="comment">// (row+1)행 i열에 퀸을 놓는다.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 유망한 노드인지 판단.</span></span><br><span class="line">                <span class="keyword">if</span> (isPossible(column, row + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 3. 서브 트리로 이동.(해당 노드의 하위 노드)</span></span><br><span class="line">                    dfs(column, row + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 4. 백트래킹 수행. 해당 노드는 가지치기 됨.</span></span><br><span class="line">                    <span class="comment">// 아니면 백트래킹. 0이면 퀸을 못놓는다는 의미.</span></span><br><span class="line">                    column[row+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        column[row] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] column, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (row+1)이 들어오는데 그 전까지 즉, row 행 전까지 검사한다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i 행과 row 행의 열이 같으면 퀸을 놓을 수 없다.</span></span><br><span class="line">            <span class="keyword">if</span> (column[i] == column[row]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 행과 row 행의 열 값이 대각선 위치에 존재하면 퀸을 놓을 수 없다.</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(i - row) == Math.abs(column[i] - column[row])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 위의 경우가 모두 된다면 true 반환한다.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://thd0011.tistory.com/19" target="_blank" rel="noopener">[알고리즘] 백트래킹 (Backtracking) 알고리즘</a></li>
<li><a href="https://medium.com/@jeongdowon/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-backtracking-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-13492b18bfa1" target="_blank" rel="noopener">[알고리즘] Backtracking 이해하기</a></li>
<li><a href="https://idea-sketch.tistory.com/29" target="_blank" rel="noopener">뚜벅이 강군 블로그</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/22/What-is-BackTracking/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/13/What-is-UML/"
                            aria-label=": [개발 상식] UML"
                        >
                            [개발 상식] UML
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-13T16:18:42+09:00">
	
		    May 13, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/개발-상식/">개발 상식</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>모듈화를 함에 있어서 UML이 무엇인지, UML을 이용해 클래스 다이어그램을 작성하는 방법을 공부하기 위한 포스팅이다.</p>
<ul>
<li>UML(Unified Modeling Language)
<ul>
<li>시스템을 모델로 표현해주는 대표적인 모델링 언어.</li>
</ul>
</li>
<li>UML 다이어그램의 종류
<ol>
<li>구조 다이어그램
<ul>
<li><strong>클래스 다이어그램</strong>, 객체 다이어그램, 복합체 구조 다이어그램, 배치 다이어그램, 컴포넌트 다이어그램, 패키지 다이어그램.</li>
</ul>
</li>
<li>행위 다이어그램
<ul>
<li>활동 다이어그램, 상태 머신 다이어그램, 유즈 케이스 다이어그램, 상호작용 다이어그램.</li>
</ul>
</li>
</ol>
</li>
<li>UML 작성 도구
<ul>
<li><a href="http://staruml.io/" target="_blank" rel="noopener">http://staruml.io/</a></li>
<li><a href="http://www.umlet.com/" target="_blank" rel="noopener">http://www.umlet.com/</a></li>
</ul>
</li>
</ul>
<h3 id="클래스-다이어그램이란">클래스 다이어그램이란</h3>
<ul>
<li>시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 대표적인 UML 구조 다이어그램이다.</li>
<li>목적 : 시스템을 구성하는 클래스들 사이의 관계를 표현한다.</li>
</ul>
<h3 id="클래스">클래스</h3>
<ul>
<li>클래스란
<ol>
<li>동일한 속성과 행위를 정의한 객체의 집합.</li>
<li>객체를 생성하는 설계도.</li>
</ol>
</li>
<li>클래스는 <strong>변화의 기본 단위</strong>
<ul>
<li>디자인 패턴을 제대로 이해하려면 만들진 프로그램을 흔들어보고 어떤 것이 변화되는지를 잘 살펴봐야 한다.</li>
</ul>
</li>
<li>UML 클래스의 표현은 아래 그림과 같다.
<ul>
<li>가장 위 : 클래스 이름</li>
<li>중간 : 속성(클래스의 특징, 변수)</li>
<li>마지막 : 연산(클래스가 수행하는 책임, 메소드)</li>
<li>경우에 따라 속성과 연산 부분은 생략 가능.</li>
</ul>
</li>
</ul>
<img src="/img/uml-class.png" width="400" height="300">
<ul>
<li>속성과 연산의 가시화를 정의
<ul>
<li>UML에서는 접근 제어자를 사용해 나타낼 수 있다.</li>
</ul>
</li>
</ul>
<img src="/img/access-controller.png" width="600" height="300">
<ul>
<li>분석 단계와 설계 단계에서의 클래스 다이어그램은 아래와 같다.
<ul>
<li>분석 단계는 조금 더 간략하게 표시한다.</li>
<li>설계 단계는 보다 더 세밀하게 작성한다.</li>
</ul>
</li>
</ul>
<img src="/img/uml-class-example.png" width="600" height="300">
<h3 id="관계">관계</h3>
<p>UML에서 제공하는 클래스들 사이의 관계는 아래의 표와 같다.<br>
표를 먼저 보고 각 관계의 의미에 대해서 알아보도록 하자.</p>
<img src="/img/association.png" width="800" height="300">
<p>서로 의미있는 클래스들의 관계에는 크게 4가지 종류가 있다.<br>
일반적인 의미의 연결 관계인 <code>연관(association) 관계</code>, 전체와 부분을 나타내는 <code>집합(aggregation) 관계</code>, 다른 클래스의 속성을 물려받는 <code>상속(inheritance) 관계</code>, 그리고 한 클래스가 다른 클래스에 영향을 미치는 <code>의존(dependency) 관계</code>가 있다.</p>
<img src="/img/sample_association4.jpg" width="600" height="300">
<p>연관 관계와 의존 관계를 구분 짓는 가장 큰 기준은<br>
<strong>참조하는 클래스 인스턴스의 참조를 계속 유지하고 있느냐, 아니냐</strong>이다.<br>
아래의 코드에서 확인할 수 있다.</p>
<ul>
<li>연관 관계 : 참조를 유지한다.</li>
<li>의존 관계 : 참조를 짧게 유지하고 빠르게 끊는다.</li>
</ul>
<p><strong>의존(dependency) 관계</strong></p>
<ul>
<li>일반적으로 한 클래스가 다른 클래스를 사용하는 경우.
<ol>
<li>클래스의 속성에서 참조할 때</li>
<li>매개변수, 인자로 사용될 때</li>
<li>메소드 내부의 지역 변수로 참조될 때</li>
</ol>
</li>
<li>1 : 연관 관계 / 2,3 : 의존 관계</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 생성자.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 의존 관계 : 이 메소드 내부에서만 c의 참조를 유지한다.</span></span><br><span class="line">        <span class="comment">// 메소드 실행이 종료되면 c의 참조도 사라진다.</span></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.callC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드에서 확인할 수 있는 것처럼 짧은 시간 동안 이용하는 관계</li>
<li>UML에서는 다음과 같이 점선으로 나타낸다.</li>
</ul>
<img src="/img/dependency.jpg" width="600" height="300">
<p><strong>연관 관계</strong></p>
<ul>
<li>오랜 시간 동안 같이 할 객체와의 관계</li>
<li>예를 들어, 자동차와 자동차를 소유한 사람의 관계</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> C c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 생성자.</span></span><br><span class="line">        <span class="comment">// 연관 : 클래스 C에 대한 참조를 계속 유지하고 있음.</span></span><br><span class="line">        <span class="keyword">this</span>.c = <span class="keyword">new</span> C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c.callC();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/img/association.jpg" width="600" height="300">
<h4 id="의존-관계dependency">의존 관계(dependency)</h4>
<p>클래스가 연관, 상속, 집합 관계로 엮여 있는 것은 아니지만, 한 곳이 변경되면 그것을 사용하는 다른 곳도 같이 변경해줘야 하는 관계를 표현할 때 주로 사용한다. 주의해야 할 점은 연관 관계와 달리 <strong>의존 관계의 경우에는 클래스 인스턴스의 참조를 유지하고 있지 않다는 점이다.</strong> 참조를 계속적으로 유지하게 되면 이는 연관 관계로 표현해야 한다.</p>
<p>주로 다음과 같은 세 가지 경우에 의존 관계로 표현한다.</p>
<ol>
<li>한 클래스의 메소드가 다른 클래스의 객체를 인자로 받아 그 객체의 메소드를 사용한다.(가장 일반적이다.)</li>
<li>한 클래스의 메소드가 또 다른 클래스의 객체를 반환한다.</li>
<li>다른 클래스의 메소드가 또 다른 클래스의 객체를 반환한다. 이때 이 메소드를 호출하여 반환되는 객체의 메소드를 사용한다.</li>
</ol>
<h4 id="연관-관계association">연관 관계(association)</h4>
<p>한 객체가 다른 객체와 연결되어 있음을 나타낼 때 그들을 연관 관계로 지칭한다. 이 연관 관계에서 중요하게 볼 점은 <strong>연관 관계의 방향</strong>과 <strong>멀티플리시티</strong>이다.</p>
<p>연관 관계는 방향성을 가지며 양방향과 단방향으로 구분지을 수 있다.</p>
<ul>
<li>단방향 연관 관계 : 한쪽은 알지만 다른 쪽은 상대방의 존재를 모른다.
<ul>
<li>화살표로 표시한다.</li>
<li>아래의 UML House 클래스는 Person 클래스의 존재를 알고 있지만, Person은 House 클래스의 존재를 모른다.</li>
<li>House 클래스만 Person 클래스에 대한 참조값을 가지고 있고, Person은 House에 대한 어떠한 참조값도 가지고 있지 않는다.</li>
</ul>
</li>
</ul>
<img src="/img/sample_association2.jpg" width="600" height="300">
<ul>
<li>양방향 연관 관계 : 연결된 클래스들이 서로의 존재를 알고 있다.
<ul>
<li>실선으로 표시한다.</li>
<li>아래의 UML의 의미는 House와 Person 클래스는 서로의 존재를 알고 있으며, 반드시 한 사람 이상이 House에 속해야 한다는 뜻이다.</li>
</ul>
</li>
</ul>
<img src="/img/sample_association1.jpg" width="600" height="300">
<p>다대다 연관 관계는 양방향 연관 관계로 표현되는 것이 적절하다. 하지만 양방향 연관 관계를 구현하는 것은 복잡하기 때문에 보통 다대다 연관 관계를 <strong>일대다 단방향 연관 관계</strong>로 변환해 구현한다. -&gt; 연관 클래스</p>
<ul>
<li>연관 클래스
<ul>
<li>연관 관계에 추가할 속성이나 행위가 있을 때 사용한다.</li>
<li>연관 클래스를 일반 클래스로 변환
<ul>
<li>연관 클래스는 연관 관계가 있는 두 클래스 사이에 위치하며, 점선을 사용해 연결한다.</li>
<li><strong>이 연관 클래스를 일반 클래스로 변환하여 다대다에서 일대다 연관 관계로 변환한다.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/img/association-class-example.png" width="800" height="300">
<h4 id="일반화-관계">일반화 관계</h4>
<ul>
<li>한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에는 일반화 관계가 존재한다.</li>
<li>객체지향 개념에서는 일반화 관계를 <code>상속 관계(IS-A)</code>라고 한다</li>
</ul>
<img src="/img/generalization-class.png" width="800" height="300">
<ul>
<li>부모 클래스
<ul>
<li>추상적인 개념이며 위의 그림에서 가전제품에 해당.</li>
<li>자식 클래스에게 공통 속성이나 기능을 제공한다.</li>
<li>ex) 제조번호, 제조 회사 같은 공통 속성과 turnOn/Off 같은 공통 기능을 두고 자식 클래스에서 상속받아 구현할 수 있다.</li>
</ul>
</li>
<li>자식 클래스
<ul>
<li>구체적인 개념이며 아래의 제품들에 해당.</li>
</ul>
</li>
<li>추상 클래스
<ul>
<li>추상 메소드를 하나 이상 갖는 클래스</li>
<li>추상 메소드
<ul>
<li>부모 클래스에서 구현부 없이 선언부만 있는 함수</li>
<li>ex) turnOn/Off는 자식 클래스에서 구현함에 따라 달라지기 때문에 부모 클래스에서 추상 메소드로 선언한다.</li>
</ul>
</li>
<li>일반적인 클래스와 달리 객체를 생성할 수 없다.</li>
</ul>
</li>
<li>UML에서의 표현
<ul>
<li>이탤릭체 사용.</li>
</ul>
</li>
</ul>
<img src="/img/abstract-class-uml.png" width="800" height="300">
<h4 id="집합-관계">집합 관계</h4>
<ul>
<li>연관 관계의 특별 경우로 <strong>전체와 부분의 관계</strong>를 명확하게 명시하고자 할 때 사용한다.</li>
<li>aggregation(집합)과 composition(구성)을 구분하는 기분은 <strong>lifeCycle이 같느냐, 같지 않느냐</strong>이다.</li>
<li>lifeCycle이란 클래스 인스턴스의 생명주기를 말하는 것으로 생성에서 소멸까지의 과정이다.</li>
</ul>
<ol>
<li>집합 관계(aggregation)</li>
</ol>
<ul>
<li>한 객체가 다른 객체를 포함하는 것
<ul>
<li><strong>부분</strong>을 나타내는 객체를 다른 객체와 공유할 수 있다.</li>
</ul>
</li>
<li><strong>전체</strong>를 가리키는 클래스 방향에 빈 마름모 표시</li>
<li>전체 객체의 lifeCycle과 부분 객체의 lifeCycle은 독립적이다.
<ul>
<li>즉, 전체 객체가 사라진다 해도 부분 객체는 사라지지 않는다.</li>
</ul>
</li>
<li>예시 : 생성자에서 참조값을 인자로 받아 필드 세팅</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainBoard mb;</span><br><span class="line">    <span class="keyword">private</span> CPU c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(MainBorad mb, CPU c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mb = mb;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="comment">// 집합 연관 : 부분과 전체의 관계</span></span><br><span class="line">        <span class="comment">// 부분이 되는 객체를 외부에서 생성하여 넘겨 받는다.</span></span><br><span class="line">        <span class="comment">// 따라서 Computer 클래스가 없어져도 부분이 되는 객체들은 사라지지 않는다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>합성 관계(Composition)</li>
</ol>
<ul>
<li>부분 객체가 전체 객체에 속하는 관계
<ul>
<li><strong>부분</strong>을 나타내는 객체를 다른 객체와 공유할 수 없다.</li>
</ul>
</li>
<li><strong>전체</strong>를 가리키는 클래스 방향에 채워진 마름모로 표시</li>
<li>전체 객체의 lifeCycle과 부분 객체의 lifeCycle은 의존적이다.
<ul>
<li>즉, 전체 객체가 없어지면 부분 객체도 없어진다.</li>
</ul>
</li>
<li>예시 : 생성자에서 필드에 대한 객체를 생성한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainBoard mb;</span><br><span class="line">    <span class="keyword">private</span> CPU c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mb = <span class="keyword">new</span> MainBoard();</span><br><span class="line">        <span class="keyword">this</span>.c = <span class="keyword">new</span> CPU();</span><br><span class="line">        <span class="comment">// 합성 : 집합 관계 중에서도 강한 집합체의 의미를 갖는다.</span></span><br><span class="line">        <span class="comment">// 부분을 이루는 객체가 없이는 전체가 아무런 의미를 갖지 못한다.</span></span><br><span class="line">        <span class="comment">// Computer 클래스가 사라져 버리면 내부에서 생성된 MainBoard, CPU도 같이 사라진다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aggregation과 composition을 쉽게 설명하면 모자와 안경을 쓴 사람을 생각해보자. 이 사람을 구성하고 있는 요소에는 눈,팔,다리와 같이 사람이 죽으면 같이 없어지는 요소들이 있고, 안경,모자와 같이 바꿔 사용할 수 있는 요소들이 있다.</p>
<p>즉, 눈,팔,다리는 사람과 lifeCycle이 같은 Composition 관계이고 안경이나 모자는 Aggregation 관계인 것이다.</p>
<img src="/img/set-uml-example.png" width="800" height="300">
<h4 id="인터페이스와-실체화-관계">인터페이스와 실체화 관계</h4>
<ul>
<li>인터페이스란
<ul>
<li><strong>책임</strong>이며, 어떤 객체의 책임이란 객체가 해야 하는 일 또는 객체가 할 수 있는 일이다.</li>
<li>즉, 객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 본다.</li>
<li>공통되는 능력이 있는 것들을 대표하는 관점</li>
</ul>
</li>
<li>UML에서의 인터페이스 표현
<ul>
<li>빈 삼각형과 점선을 이용</li>
</ul>
</li>
<li>객체 지향 개념에서는 실체화 관계를 <strong>can do this</strong> 관계라고 한다.</li>
</ul>
<img src="/img/interface-uml.png" width="800" height="300">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/07/04/class-diagram.html" target="_blank" rel="noopener">[UML] 클래스 다이어그램 작성법</a></li>
<li><a href="https://geniusduck.tistory.com/entry/UML-%EA%B8%B0%EB%B3%B8%ED%8E%B8-%EA%B8%B0%EB%B3%B8-%ED%91%9C%EA%B8%B0-%ED%98%95%EC%8B%9D-%EB%B0%8F-%EA%B4%80%EA%B3%84%ED%91%9C%ED%98%84%EB%B2%95" target="_blank" rel="noopener">UML - 기본편 ( 기본 표기 형식 및 관계 표현법 )</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/13/What-is-UML/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy2/"
                            aria-label=": [Android] 백그라운드 실행 정책 Oreo"
                        >
                            [Android] 백그라운드 실행 정책 Oreo
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T17:58:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><code>안드로이드 Oreo(8.0)</code> 버전에서 등장한 백그라운드 실행 제한을 확인해보도록 하겠다. 안드로이드에서 백그라운드 실행은 상용 서비스에서 많이 사용되는 부분이기도 하고 꼭 알아야 하는 부분이라서 공부하면서 정리하려고 한다.</p>
<h2 id="1-oreo-버전-백그라운드-제한-개요">1. Oreo 버전 백그라운드 제한 개요</h2>
<p>앱이 백그라운드에서 실행될 때마다 디바이스의 리소스(예:RAM, 배터리)를 사용한다. 이는 사용자들에게 좋지 못한 경험을 제공한다. 예를 들어 백그라운드 작업으로 인해 디바이스의 배터리 수명이 저하되거나 비디오 시청, 게임, 카메라 사용과 같은 사용자의 디바이스 성능 저하가 발생할 수 있다.</p>
<p>동시에 실행되는 앱이 많은 수록 시스템에 많은 부하가 걸린다. 추가적인 앱이나 서비스가 백그라운드에서 실행 중이면 시스템에 추가적인 부하가 걸리고 사용자 환경이 나빠질 수 있다. 이런 문제가 발생할 가능성을 줄이기 위해 <strong>Android Oreo</strong> 버전에서는 사용자가 앱과 직접적으로 상호작용하지 않을 때 이 앱이 수행할 수 있는 작업을 제한한다. 두 가지 방식으로 제한된다.(여기서는 <code>백그라운드 서비스 제한</code>만 살펴보도록 하겠다.)</p>
<ol>
<li>
<p><strong>백그라운드 서비스 제한</strong> : 앱이 유휴 상태인 경우 백그라운드 서비스의 사용이 제한된다. 이 기능은 사용자에게 잘 보이는 포그라운드 서비스에는 적용되지 않는다.</p>
</li>
<li>
<p><strong>브로드캐스트 제한</strong> : 제한된 예외의 경우, 앱이 암시적 브로드캐스트에 등록하기 위해 자체 매니페스트를 사용할 수 없다. 그렇지만 앱이 런타임에 브로드캐스트에 등록할 수 있으며, 특정 앱을 대상으로 하는 명시적 브로드캐스트에 등록하기 위해 매니페스트를 사용할 수 있다.</p>
</li>
</ol>
<ul>
<li>
<p>기본적으로 이와 같은 제한은 Oreo 버전을 대상으로 하는 앱에만 적용된다. 하지만, 안드로이드 개발자라면 모든 버전을 고려해서 개발해야 하기 때문에 피할 수 없는 부분임이 분명하다. 그렇기 때문에 반드시 알고 넘어가야 한다.</p>
</li>
<li>
<p>추가적으로 이전에 살펴본 Service는 백그라운드에서 동작하는 컴포넌트이다. 하지만, Oreo 처럼 백그라운드 작업을 제한하게 된다면 우리가 원하는 작업을 수월하게 진행할 수 없다. 이 부분을 어떻게 해결할 수 있는지 고민해야 할 필요가 있다.</p>
</li>
</ul>
<p>대부분의 경우, 앱은 <strong>JobScheduler</strong> 작업을 사용해 이 제한을 해결할 수 있다. JobScheduler를 통해 앱이 실행되지 않을 때 작업을 수행하면서도, 사용자 환경에 영향을 미치지 않는 방식으로 이러한 작업을 예약할 수 있는 여지를 제공할 수 있다. 하지만, JobScheduler 역시 제한이 걸리는 점이 존재한다. 이 부분은 <strong>WorkManager</strong> 부분에서 공부하면서 살펴보자.</p>
<h2 id="2-백그라운드-실행-변화">2. 백그라운드 실행 변화</h2>
<p>앞선 포스팅에서 확인한 내용을 한번 더 정리하고 넘어가려 한다. 그리고 위에서 설명한 것처럼 사용자의 디바이스 배터리 수명을 개선하고 더 좋은 사용자 경험을 제공하기 위해 안드로이드는 몇가지 백그라운드 정책들을 변화시켜왔다.</p>
<ul>
<li>도즈모드와 앱 대기상태(Doze And App Standby) : 화면이 꺼지고 충전 상태가 아니며 대기 상태일 때 애플리케이션의 행동을 제한한다.</li>
<li>백그라운드 상태에서 위치 서비스 제약 : 백그라운드 상태에 있는 앱이 사용자의 현재위치를 검색할 수 있는 빈도를 제한한다.</li>
<li>백그라운드 서비스 제약 : 보이지 않는 CPU/Network 사용과 실행중인 백그라운드 서비스들을 제한한다.</li>
<li>가장 최근에는 사용자가 사용하지 않는 앱에서 사용할 수 있는 기기 리소스를 제한할 수 있는 <a href="https://developer.android.com/about/versions/pie/power#buckets" target="_blank" rel="noopener">앱 대기 버킷(App Standby Buckets)</a>과 앱이 좋지 않는 행동을 보이는 경우 백그라운드에서 시스템 리소스에 대한 앱의 접근을 제한하도록 사용자에게 경고하는 <a href="https://developer.android.com/topic/performance/background-optimization#bg-restrict" target="_blank" rel="noopener">앱 제한(App Restrictions)</a>과 <a href="https://developer.android.com/about/versions/pie/power#battery-saver" target="_blank" rel="noopener">배터리 절약 개선(Battery Saver improvements)</a> 정책이 추가되었다.</li>
</ul>
<h2 id="3-oreo-버전-백그라운드-실행-제한">3. Oreo 버전 백그라운드 실행 제한.</h2>
<p>위에서 언급한 것처럼 백그라운드에서 실행 중인 서비스가 디바이스의 리소스를 사용할 수 있으며, 그 결과로 사용자 경험이 악화될 가능성이 있다. 이러한 문제를 줄이기 위해 Oreo 버전부터 시스템은 여러가지 제한을 서비스에 적용한다.</p>
<p>먼저, 이를 이해하기 전에 애플리케이션이 <strong>Foreground</strong>인지 <strong>Background</strong>인지 명확하게 파악해야 한다. 아래와 같은 경우 애플리케이션이 Foreground에 있는 것으로 간주한다.</p>
<ul>
<li>액티비티가 시작되거나 일지 중지되거나 상관없이 액티비티가 가시적일 경우.</li>
<li>Foreground Service가 있는 경우.</li>
<li>Foreground 애플리케이션이 서비스를 갖는 애플리케이션에 바인딩하거나 콘텐츠 프로바이더를 사용하여 앱에 연결할 때.<br>
예를 들어 다른 앱이나 시스템이 아래의 내용에 바인딩하면 애플리케이션이 Foreground에 있는 것이다.
<ul>
<li>IME</li>
<li>Wallpaper Service</li>
<li>Notification listener</li>
<li>Voice 또는 text 서비스</li>
<li>자동차에서 스트리밍을 듣는 음악 앱(Android Auto일 때)</li>
</ul>
</li>
</ul>
<p>위의 조건들을 만족하지 못한다면 애플리케이션이 Background에 있는 것으로 간주된다.</p>
<blockquote>
<p><strong>바인드된 서비스는 영향을 받지 않는다.</strong></p>
</blockquote>
<ul>
<li>이러한 규칙은 바인드된 서비스에는 어떠한 영향도 미치지 않는다. 앱이 바인드된 서비스를 정의하는 경우, 해당 앱이 Foreground에 있는 없든 간에 다른 구성요소들이 이 서비스에 바인드할 수 있다.</li>
</ul>
<p>앱이 Foreground에 있는 동안에는 이 앱이 Foreground 및 Background 서비스를 자유롭게 생성하고 실행할 수 있다. 앱이 백그라운드로 이동하더라도 몇 분 동안은 앱이 서비스를 생성하고 사용하는 것이 여전히 허용된다. 이 기간이 끝나게 되면 앱이 유휴 상태로 간주된다. 이때 마치 앱이 서비스의 <code>Service.stopSelf()</code> 메소드를 호출한 것처럼 시스템이 앱의 백그라운드 서비스를 중지시킨다.</p>
<p>어떠한 상황에서는 백그라운드 앱이 몇 분 동안 임시 허용 목록이란 곳에 들어가기도 한다. 앱이 허용 목록에 있는 동안에는 제한 없이 서비스를 시작할 수 있으며 백그라운드 서비스도 실행이 허용된다. 사용자에게 보이는 다음과 같은 작업을 앱이 처리하는 경우에 앱이 허용 목록에 들어간다.</p>
<ul>
<li>우선순위가 높은 Firebase Cloud Messaging(FCM) 메시지 처리</li>
<li>SMS/MMS 메시지와 같은 브로드캐스트 수신</li>
<li>알림에서 <code>PendingIntent</code> 실행</li>
</ul>
<p>많은 경우 앱이 백그라운드 서비스를 <strong>JobScheduler</strong> 작업으로 대체할 수 있다. Android 8.0 이전에는 Foreground 서비스를 생성하는 일반적인 방법은 Background 서비스를 생성한 후 이 서비스를 Foreground 서비스로 승격시키는 것이었다.</p>
<p>Android 8.0에서는 좀 복잡하며 시스템은 백그라운드 앱이 Background 서비스를 생성하는 것을 허용하지 않는다. 이 때문에 Android 8.0에서는 새 서비스를 Foreground에서 시작하는 새로운 메소드 <code>Context.startForegroundService()</code>를 소개한다.</p>
<p>시스템이 서비스를 생성한 후, 앱은 5초 이내에 해당 서비스의 <strong>startForeground()</strong> 메소드를 호출하여 새 서비스의 알림을 사용자에게 표시해야 한다. 앱이 이 시간 내에 <strong>startForeground()</strong> 를 호출하지 않으면 시스템이 서비스를 중단하고 앱을 ANR로 선언하게 된다.</p>
<h2 id="5-사례와-해결-방법">5. 사례와 해결 방법</h2>
<p>백그라운드 실행 제한으로 인해 원하는 작업을 하는게 조금 어려워졌다. 개발자는 백그라운드 실행을 구현하기 위해 사용할 도구를 결정하려면 원하는 것을 명확하게 이해하고 어떤 제한 사항을 가지고 있어야 한다.</p>
<p>공식 문서에 나와있는 <strong>Guide to background Processing</strong>을 참고해서 알아보도록 하자.</p>
<p><strong>개요</strong><br>
안드로이드 앱은 UI 처리, 사용자와 상호작용, LifeCycle 이벤트 수신 등을 담당하는 Main Thread가 존재한다. Main Thread에서 너무 많은 작업이 발생하면 앱이 끊기거나 느려져서 사용자 경험이 좋지 않다. 즉, 사용자가 불편함을 느낄 수 있다.</p>
<p>비트맵 디코딩, 디스크 접근 또는 네트워크 요청 수행과 같은 시간이 오래 걸리는 실행 및 작업을 별도의 백그라운드 스레드에서 수행해야 한다. 일반적으로 몇 밀리초 이상 걸리는 것은 모두 백그라운드 스레드에 위임해야 한다. 이러한 작업 중 일부는 사용자가 앱을 활발하게 사용하는 동안 수행되어야 한다. 백그라운드 스레드에서 작업을 실행하고 앱을 사용하는 동안 기본 UI 스레드에서 작업을 실행하는 방법 그리고 두 스레드 간 통신 방법에 대해서는 다른 글을 참고하면 좋다.</p>
<p>애플리케이션은 또한 사용자가 백엔드 서버와 정기적으로 동기화하거나 앱 내에서 새로운 컨텐츠를 가져오는 등 앱을 사용하지 않을 때에도 실행해야 하는 일부 작업이 필요할 수 있다. 또한 애플리케이션은 사용자가 앱과 상호작용을 완료한 후에도 서비스가 즉시 실행되도록 요구할 수 있다. 이와 같은 경우를 해결하기 위해서 <strong>백그라운드 처리에 대한 고민이 필요하다.</strong></p>
<p><strong>백그라운드 처리의 과제</strong></p>
<p>백그라운드 작업은 RAM 및 배터리와 같은 기기의 제한된 리소스를 소비한다. 올바르게 사용하지 않을 경우 사용자에게 좋지 않은 경험을 제공할 수 있다.</p>
<p>안드로이드는 배터리를 극대화하고 좋은 앱 동작을 위해 앱 또는 Foreground Service Notification이 사용자에게 보이지 않을 때 백그라운드 작업을 제한한다.</p>
<p>다음은 위에서 언급한 버전별 백그라운드 정책의 변화를 보여준다.</p>
<ul>
<li>Android 6.0 : Doze 모드와 App Standby(앱 대기) 기능
<ul>
<li>도즈 모드는 화면이 꺼져 있고 기기가 정지해 있을 때 앱 동작을 제한한다.</li>
<li>앱 대기에서는 사용하지 않는 애플리케이션을 네트워크 접근, 작업 및 동기화를 제한하는 특수 상태로 전환한다.</li>
</ul>
</li>
<li>Android 7.0 : 암시적 브로드캐스트 리시버를 제한하고 개선된 도즈모드를 제공한다.</li>
<li>Android 8.0 : 백그라운드에서 위치를 파악하거나 캐시된 Wake lock을 해제하는 등 추가적인 백그라운도 동작 제한이 있다.</li>
<li>Android 9.0 : 앱 이용 패턴에 따라 자원에 대한 앱 요청이 동적으로 우선되는 App Standby Buckets를 소개했다.</li>
</ul>
<p>결국 내가 해야 할 작업을 정확히 이해하고 백그라운드 작업을 버전별 정책에 맞도록 개발하는 것이 중요하다.</p>
<p><strong>작업에 맞는 적합한 방법을 선택하자.</strong></p>
<p>아래의 예시를 확인해보고 생각해보자.</p>
<ul>
<li><strong>작업이 연기될 수 있거나 당장 일어날 필요가 있는가?</strong> 예를 들어, 사용자가 버튼을 클릭하는 것에 대응하여 네트워크에서 데이터를 가져와야 하는 경우 이 작업은 즉시 수행되어야 한다. 그러나 서버에 로그를 업로드하려면 앱의 성능이나 사용자 기대에 영향을 미치지 않고 작업을 연기할 수 있다.</li>
<li><strong>작업이 시스템에 상태에 따라 달라지는가?</strong> 장치에 전원 연결, 인터넷 연결 등과 같은 특정 조건을 충족할 때만 작업을 실행하기를 원할 수 있다. 예를 들어, 사용자의 앱은 주기적으로 저장된 데이터를 압축해야 할 수 있다. 사용자에게 영향을 주지 않도록 하려면 장치가 충전되고 유휴 상태일 때만 이 작업을 수행하기를 원할 것이다.</li>
<li><strong>작업이 정확한 시간에 실행되어야 하는가?</strong> 일정 관리 앱의 경우, 사용자가 특정 시간에 발생할 이벤트에 대해서 미리 알림을 설정하도록 할 수 있다. 사용자는 정확한 시간에 알림을 볼 수 있을 것으로 예상한다. 다른 경우, 앱은 작업이 실행될 때 정확하게 신경을 쓰지 않을 수 있다. 앱에는 &quot;작업 A가 먼저 실행되야 하고, 그 다음에 작업 B가 실행되어야 하며 다음에는 작업 C가 실행되어야 한다.&quot;와 같은 일반적인 요구 사항이 있을 수 있다. 하지만, 특정 시간에 실행되기 위해서는 작업이 필요하지 않다.</li>
</ul>
<img src="/img/android_background_way.png" width="600" height="300">
<ol>
<li>WorkManager</li>
</ol>
<p>모든 OS 백그라운드 실행 제한을 고려하여 백그라운드 실행에 권장되는 솔루션이다. 장치 또는 애플리케이션이 재시작되더라도, 작업이 연기될 수 있거나 작업이 실행될 것으로 예상되는 경우 <code>WorkManager</code>를 사용할 수 있다.</p>
<p>작업 조건(네트워크 가용성, 배터 등)이 만족될 때, 지연 가능한 백그라운드 작업을 멋지게 실행할 수 있다.</p>
<p>장점으로는 작업(일회성 또는 반복성)을 예약하거나 작업을 결합(체이닝)할 수 있다. 또한 장치가 유휴상태이거나 충전 중일 때 특정 이벤트를 트리거하거나 콘텐츠 프로바이더가 변경될 때 실행하는 것과 같은 실행 제한 조건을 적용할 수 있다.</p>
<p>한 가지 예로 로그를 압축하여 서버에 업로드 해야 하는 경우라면 두 가지 작업 요청을 만들어 수행할 수 있다.</p>
<ol>
<li>파일을 압축한다. -&gt; 이 단계에서 장치가 충전 중이어야 한다는 제한 조건을 추가할 수 있다.</li>
<li>서버에 업로드 한다. -&gt; 이 요청의 경우 네트워크가 사용 가능할 때만 작업이 실행되도록 네트워크 연결 제한 조건을 추가해야 한다.</li>
</ol>
<p>두 작업을 모두 큐에 넣은 뒤 WorkManager와 함께 필요한 리소스가 충족할 때 작업을 수행하도록 할 수 있다. 또 다른 장점으로는 전원 관리 기능을 존중하는 것이다. WorkManager는 제약 조건이 충족되며, Doze가 해제된다면 주어진 작업을 실행할 것이다.</p>
<p>자세한 내용은 다음 포스팅에서 정리할 예정이다.</p>
<ol start="2">
<li>Foreground Service</li>
</ol>
<p>앱에서 음악, 비디오 재생 또는 탐색과 같이 앱을 종료하거나 화면을 꺼도 지연되지 않고 사용자가 시작한 작업을 완료해야 하는 경우 Foreground Service를 사용해야 한다. Foreground Service를 사용한다는 것은 중요한 일을 하고 있으므로 죽여서는 안된다는 것을 시스템에 알린다. 그리고 Notification Bar에 띄워서 Foreground Service가 수행 중임을 표시해야 한다.</p>
<ol start="3">
<li>Alarm Manager</li>
</ol>
<p>정확한 시간에 작업을 실행해야 하고 사용자와 상호 작용이 포함되며 지연될 수 없는 경우 사용하면 된다. Alarm Manager는 사용자가 지정한 시간에 필요한 경우 사용자의 앱을 실행한다.</p>
<p>그러나 작업이 정확한 시간에 실행될 필요가 없다면 WorkManager가 더 나은 방법이다. WorkManager는 시스템 자원의 균형을 더 잘 맞출 수 있다. 예를 들어, 매 시간마다 작업을 실행해야 하지만 특정 시간에 작업을 실행할 필요가 없는 경우, WorkManager를 사용하여 반복 작업을 설정하면 된다.</p>
<p>또한, 알람이 발생하면 작업을 짧은 시간내에 끝내야 한다. 네트워크에 접근하지 못할 수도 있다.(도즈모드나 앱 대기 버킷 때문에) 네트워크가 필요하거나 시간이 오래 걸리는 작업을 수행하려면 위에서 언급한 WorkManager를 사용해야 한다. 알람이 울릴 때마다 장치는 저전력 모드를 벗어나 부분적 wake-lock을 유지하므로 시간이 지남에 따라 배터리 수명에 상당한 영향을 줄 수 있다.</p>
<ol start="4">
<li>Download Manager</li>
</ol>
<p>사용자가 앱을 통해서 시간이 오래 걸리는 Http 다운로드를 수행하고 있다면 Download Manager를 사용하면 된다. 클라이언트는 URI를 앱 프로세스 외부에 있을 수 있는 특정 대상 파일로 다운로드하도록 요청할 수 있다. Download Manager는 백그라운드에서 다운로드를 수행하여 Http 상호 작용을 관리하고 실패 후 또는 연결 변경 및 시스템 재부팅 전반에 걸쳐 다운로드를 재시도 한다.</p>
<p>요약하면 아래와 같다.</p>
<img src="/img/android_background_ways.png" width="600" height="300">
<p>파일을 다운로드 할 때 다운로드 매니저를 사용하면 될 것으로 예상이된다. 하지만, 다운로드 같은 경우 백그라운드에서 동작하고 시간이 오래 걸릴 수도 있기 때문에 백그라운드 정책에 위반될 상황이 생길 수도 있을 것 같다. 하지만, 다운로드 매니저가 내부적으로 어떻게 구현되어있는지 모르기 때문에 아직 확신할 수 없다. 관련 내용을 조금 더 찾아봐야 할 것 같다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=868" target="_blank" rel="noopener">새로운 안드로이드 백그라운드 실행 정책</a></li>
<li><a href="https://developer.android.com/guide/background/" target="_blank" rel="noopener">Guide to background processing - 공식 문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/Android-Background-Policy/"
                            aria-label=": [Android] 버전별 백그라운드 정책"
                        >
                            [Android] 버전별 백그라운드 정책
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T11:49:28+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>백그라운드 작업이 필요한데, 그 전에 구글에서 제한하고 있는 백그라운드 작업에 대해서 알아보려고 한다.</p>
<h2 id="1-버전별-백그라운드-정책-변천사">1. 버전별 백그라운드 정책 변천사</h2>
<p>안드로이드는 큰 업데이트마다 배터리를 관리하기 위한 여러 기능들을 포함해왔다. 아래의 내용을 확인해보자.</p>
<ul>
<li>롤리팝 5.0 : Job Scheduler의 등장. 작업을 미루거나 스케쥴링 할 수 있도록 함.</li>
<li>마시멜로우 6.0 : <a href="https://developer.android.com/about/versions/marshmallow/android-6.0-changes#behavior-power" target="_blank" rel="noopener">도즈 모드 및 앱 대기모드</a> 등장.
<ul>
<li>디바이스 또는 앱이 장시간 사용중이 아닐 때 즉, 화면이 꺼지고 충전중이 아닐 때, 네트워크의 접근을 제한하고 백그라운드 작업을 유예하기 시작.</li>
</ul>
</li>
<li>누가 7.0 : <a href="https://developer.android.com/about/versions/nougat/android-7.0-changes#doze" target="_blank" rel="noopener">개선된 도즈모드</a>
<ul>
<li>화면이 꺼지고 움직이지 않을 때 도즈모드의 하위 제약 조건이 적용되기 시작.</li>
</ul>
</li>
<li>오레오 8.0 : 백그라운드 제약
<ul>
<li>백그라운드 서비스와 위치 갱신을 제약하기 시작.</li>
</ul>
</li>
<li>파이 9.0 : 앱 대기 버킷, 배터리 세이버 개선.</li>
</ul>
<p>Oreo 버전 이상을 대상으로 업데이트 할 때 아래의 체크리스트를 확인하여 백그라운드 작업을 설정할 수 있다.</p>
<table>
<thead>
<tr>
<th style="text-align:left">현재 사용하고 있는 방법</th>
<th style="text-align:left">오레오 이상에서 사용해야 하는 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">JobScheduler</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Firebase JobDispatcher</td>
<td style="text-align:left">Firebase JobDispatcher</td>
</tr>
<tr>
<td style="text-align:left">Background Service</td>
<td style="text-align:left">JobScheduler</td>
</tr>
<tr>
<td style="text-align:left">Foreground Service</td>
<td style="text-align:left">Foreground Service와 해당 서비스를 종료해야 할 액션(stopService)</td>
</tr>
</tbody>
</table>
<p>WorkManager 라이브러리가 현재는 Alpha 단계이기 때문에 위의 방법들로 개발해야 하지만 정식 버전이 출시된다면 거의 모든 경우를 <code>WorkManager</code>로 해결할 수 있을 것 같다. 기대해보자~</p>
<h2 id="2-올바른-앱을-만드는-전략">2. 올바른 앱을 만드는 전략</h2>
<ul>
<li>백그라운드에서 수행하는 작업은 지연 가능할만한 작업들로 만든다.</li>
<li>Foreground Service를 사용할 때는 노티피케이션을 반드시 제공하여 사용자가 서비스를 중지할 수 있도록 한다.</li>
<li>알람, 네트워크 및 FCM 메시지와 같은 OS 기반의 작업에서는 이와 관련된 전원 관리 제한사항에 대한 문서 내용을 확인해보자.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://www.charlezz.com/?p=737" target="_blank" rel="noopener">안드로이드 버전별 백그라운드 정책</a></li>
<li><a href="https://developer.android.com/about/versions/oreo/background?hl=ko" target="_blank" rel="noopener">백그라운드 실행 제한 - 공식문서</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/Android-Background-Policy/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/12/What-is-Service/"
                            aria-label=": [안드로이드] Service"
                        >
                            [안드로이드] Service
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-12T10:31:56+09:00">
	
		    May 12, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="1-service란">1. Service란?</h2>
<p><strong>Service</strong>는 안드로이드 Application을 구성하는 4대 컴포넌트 중 하나이다. Activity처럼 사용자와 상호 작용을 하는 컴포넌트는 아니다. 때문에 UI가 존재하지 않으며 <strong>Background</strong>에서 동작하는 컴포넌트이다.</p>
<p>Service가 실행되고 있는 상태라면 안드로이드 OS에서는 해당 Process를 왠만하면 죽이지 않도록 방지하고 관리하게 된다. 그렇기 때문에 메모리 부족이나, 특별한 경우를 제외하고는 Background 동작을 수행하도록 설계되었다.</p>
<img src="/img/android_service.png" width="600" height="300">
<h2 id="2-service는-왜-필요할까">2. Service는 왜 필요할까?</h2>
<p>'Android Application을 구성하기 위해서 Service는 왜 필요할까?'라고 생각을 할 수 있다. 그 이유는 Activity 즉, 사용자가 보고 있는 화면이 종료된 상태에서도 동작하기 위해서 만들어졌고, 개발자는 구현을 해야 한다.</p>
<p>예를 들어서 Mp3 플레이어 같은 기능을 활용하는 경우가 될 수 있다. Mp3 플레이어는 화면이 종료된 상태에서도 계속 노래를 재생해야 하기 때문에 Background에서도 동작하도록 만들어야 한다. 따라서 <strong>Service</strong>를 사용해 구현하면 된다.</p>
<ul>
<li>파일 다운로드 같은 경우에도 사용할 수 있다.</li>
<li>애플리케이션이 실행 중이지 않을 때도 작업해야 하는 경우에도 사용할 수 있다.(애플리케이션이 실행 중일 때만 작업해야 하는 경우 <strong>스레드</strong> 사용을 권장한다.)</li>
</ul>
<p><strong><code>주의</code></strong><br>
Service가 Background에서 동작을 수행하는 컴포넌트라고 해서 Main Thread에서 실행되는 것이라고 생각하지 않을 수도 있다. 명심해야 할 점은 Android 4대 컴포넌트들은 모두 Main Thread에서 실행된다.</p>
<p>따라서 CPU 자원을 많이 소모하거나 네트워크 통신과 같은 시간이 오래 걸리는 작업은 별도의 Thread를 만들어서 처리해야 한다. 이 부분은 아래에서 ANR과 함께 설명하겠다.</p>
<h2 id="3-service-사용-방법">3. Service 사용 방법</h2>
<p>2가지 방법이 있으면 <code>startService()</code>와 <code>bindService()</code>이다.</p>
<ol>
<li><strong>startService() - 시작 타입의 서비스</strong></li>
</ol>
<ul>
<li>서비스를 상속받는 클래스를 작성하며, 정적 리시버와 유사하게 매니페스트 파일에 등록한다.</li>
<li>한 번 시작되면 백그라운드에서 무한정 실행된다.</li>
<li>작업을 완료하면 서비스가 종료된다.</li>
<li>간단한 작업들만 수행한다.</li>
<li>호출한 곳에 결과값을 반환하지 않고 계속해서 서비스한다.(음악 재생, 파일 다운로드 등)</li>
<li>하나의 프로세스 안에서 동작하며, 패키지내 컴포넌트들과 유기적으로 통신하는 역할을 한다.</li>
<li>생명 주기 : onCreate() -&gt; onStartCommand() -&gt; 실행 -&gt; onDestroy() -&gt; stopService()</li>
</ul>
<img src="/img/android_startService.png" width="600" height="300">
<ol start="2">
<li><strong>bindService() - 연결 타입의 서비스</strong></li>
</ol>
<ul>
<li>클라이언트 - 서버와 같이 동작하며 호출자(액티비티)에서 서비스에게 어떤 것을 요청하고 서비스는 요청을 처리한 후 결과값을 반환한다. (서비스가 서버의 역할을 수행.)</li>
<li>액티비티가 사라지면 서비스도 자동적으로 destroy되면서 없어진다.</li>
<li>하나의 서비스가 다수의 액티비티와 연결될 수 있다.</li>
<li>프로세스 내에서 다른 컴포넌트들과 서로 유기적으로 통신을 하며 <strong>또한, 어플 내의 기능을 외부에 제공하는 경우에 많이 사용된다. 즉, 다른 프로세스들 간에서도 Data 공유 및 통신이 유기적으로 가능하다.</strong></li>
<li>생명 주기 : onCreate() -&gt; onBind() -&gt; 실행 -&gt; onUnbind() -&gt; onDestory() -&gt; stopService()</li>
</ul>
<img src="/img/android_bindService.png" width="600" height="300">
<ol start="3">
<li><strong>intentService</strong></li>
</ol>
<ul>
<li>내부적으로 handlerThread가 동작하는 서비스</li>
<li>루퍼가 message Queue에 들어온 요청에 대해 순차적으로 처리한다.</li>
<li>Queue가 비게 되면 자동으로 서비스가 종료된다.</li>
<li>동시에 처리하는게 아니므로 성능은 조금 떨어지지만 순차적 실행이 보장된다.</li>
</ul>
<h2 id="4-service-사용시-주의사항">4. Service 사용시 주의사항.</h2>
<p>Android는 Linux 기반의 프로그램이다. 프레임워크 단에는 Linux로 구현되어 있다. 메모리 관리 또한 Linux 정책을 따르며 Linux Kernel에 의해서 관리된다.</p>
<img src="/img/android_linux_kernel.png" width="600" height="300">
<p>결국 여러 프로세스들을 커널에서 관리한다고 짐작할 수 있다.<br>
또한 하나의 프로세스 안에는 애플리케이션, 안드로이드 4대 컴포넌트, 스레드 등을 구성하고 있다. 즉, 4대 컴포넌트의 운명 또한 리눅스 커널에 달려있다는 걸 의미한다.</p>
<p>만약, 메모리 부족이나 과부하 등과 같은 현상이 발생했을 때 리눅스 커널이 프로세스를 강제로 종료시킬 수 있다.</p>
<img src="/img/android_process.png" width="600" height="300">
<p>여기서 주의해야 할 점이 있다. 바로 모든 컴포넌트들이 <strong>Main Thread</strong> 안에서 실행된다는 점이다. 안드로이드에서 Main Thread는 UI 작업을 처리하는 Thread이다. 따라서 Main Thread에서는 네트워크 작업이나 시간이 오래 걸리는 작업을 하게 되면 앱의 반응성이 낮아질 수 있다. 사용자의 불편함을 방지하고나 시스템이 <code>ANR</code> 상태로 전환시킬 수 있다.</p>
<p>Service 역시 Main Thread에서 동작하기 때문에 시간이 오래 걸리는 작업을 할 경우에는 별도의 작업 Thread를 만들어서 동작을 처리해야 한다. 그리고 작업 결과를 UI Thread에 반영하기 위해서 쓰레드 간 통신 방법을 이용해 반영해야 한다.</p>
<p>쓰레드간 통신 방법은 다음의 글을 참고하면 보면 될 것 같다.<br>
<strong><a href="https://woovictory.github.io/2019/01/07/Android-For-Interview-4/">쓰레드간 통신 방법</a></strong></p>
<p><strong>추가적인 내용들은 빠른 시일 내에 공부해서 포스팅할 예정이다.</strong></p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://limkydev.tistory.com/43" target="_blank" rel="noopener">[Android] 서비스(Service) 전반적인 개념</a></li>
<li><a href="https://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-Service-%EC%82%AC%EC%9A%A9%EB%B2%95" target="_blank" rel="noopener">안드로이드/Android Service 사용법</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/12/What-is-Service/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/8/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/10/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 9 of 28</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
