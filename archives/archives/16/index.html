
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/16/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-SharedPreference/"
                            aria-label=": [안드로이드] SharedPreference"
                        >
                            [안드로이드] SharedPreference
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T19:26:08+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>SharedPreference</h2>
<ul>
<li>간단한 값 저장에 DB를 사용하기에는 복잡하기 때문에 SharedPreference를 사용하면 적합하다.</li>
<li>Key-Value 쌍으로 데이터를 저장한다.</li>
<li>간단한 데이터를 읽고 쓰기에 유용하다.</li>
<li><strong>자동 로그인, 앱 초기 설정값, 다시보지 않기</strong> 등에 사용된다.</li>
<li>애플리케이션에 파일 형태로 저장된다.
<ul>
<li>data/data/패키지명/shared_prefs/SharedPreference이름.xml 위치에 저장된다.</li>
</ul>
</li>
<li>애플리케이션이 삭제되기 전까지 보존된다. 애플리케이션이 삭제되면 저장된 정보가 날라간다.</li>
</ul>
                    
                        <a
                            href="/2019/01/02/Android-SharedPreference/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] SharedPreference"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-Permission-MarshMellow/"
                            aria-label=": [안드로이드] 런타임 퍼미션"
                        >
                            [안드로이드] 런타임 퍼미션
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T18:29:08+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <h2>1. Runtime Permission</h2>
<p>안드로이드 버전 6.0 즉, MarshMellow 이전 버전에서는 사용자가 <strong>앱을 설치하는 시점에 한번만 동의를 받으면 그 이후에는 문제없이 해당 권한들을 사용할 수 있었다.</strong> 즉, 앱을 설치할 때 필요한 권한들에 대한 동의를 얻는 것이다.</p>
                    
                        <a
                            href="/2019/01/02/Android-Permission-MarshMellow/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [안드로이드] 런타임 퍼미션"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-is-Intent/"
                            aria-label=": [안드로이드] 인텐트"
                        >
                            [안드로이드] 인텐트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T17:28:41+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="intent란">Intent란?</h2>
<p>안드로이드 어플리케이션을 구성하는 4가지 기본 요소에는 <strong>Activity, Service, Broadcast Receiver, Content Provider</strong>가 있다. <code>인텐트</code>는 이러한 어플리케이션 구성요소 즉, 컴포넌트간에 작업 수행을 위한 정보를 전달하는 역할을 한다.</p>
<p>인텐트를 가장 손쉽게 사용한 예로는 액티비티간 화면 전환을 들 수 있다. 즉 인텐트는 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있으며, 이 정보에는 호출되는 컴포넌트 B의 이름이 <strong>명시적</strong>으로 표시되기도 하고, 속성들이 <strong>암시적</strong>으로 표시되기도 한다.</p>
<p>또한 호출된 컴포넌트 B가 호출한 컴포넌트 A로 어떠한 결과를 전달할 때도 인텐트가 사용된다. 어떠한 컴포넌트를 호출하느냐에 따라서 사용되는 대표적인 메소드는 다음과 같은 것들이 존재한다.</p>
<ul>
<li>startActivity() : 새로운 액티비티 화면을 띄울 때 사용</li>
<li>startService(), bindService() : 서비스와 관련된 메소드</li>
<li>broadcastIntent() : 브로드캐스팅을 수행할 때</li>
</ul>
<p>인텐트의 기본 구성 요소로는 액션(Action)과 데이터(Data)가 존재한다. <strong>액션</strong>은 수행할 기능이며, <strong>데이터</strong>는 액션이 수행될 대상 데이터을 의미한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예를 들어 아래의 코드가 있다고 하자.</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_DIAL, Uri.parse(<span class="keyword">data</span>))</span><br></pre></td></tr></table></figure>
<p>액션은 ACTION_DIAL 즉, 전화 다이얼을 걸라는 액션이며,<br>
data 값을 uri로 파싱한 Uri.pars(data)라는 것은 액션이 수행할 data 즉 전화번호일 것이다.</p>
<p>&quot;요약하면 Uri로 파싱한 전화번호 data를 대상으로 전화다이얼을 걸어라&quot;라는 뜻이고 이 뜻을 인텐트에 담아 안드로이드 시스템에게 전달하면 되는 것이다.</p>
<h2 id="인텐트-동작-순서">인텐트 동작 순서</h2>
<ul>
<li>Componenet가 ActivityManager에게 다른 컴포넌트의 실행을 요청</li>
<li>ActivityManager는 패키지 정보를 가지고 있는 PacakageManager에게 컴포넌트 정보 요청</li>
<li>유요한 컴포넌트임을 확인하면 컴포넌트를 실행</li>
<li>여기서 실행을 요청할 때 컴포넌트의 정보가 <strong>Intent</strong>이다.</li>
<li>Intent는 IPC 통신을 위한 직렬화 객체로 Parcelable을 통해 직렬화 되어 있다.</li>
<li>즉, 이 객체는 다른 프로세스로 전달하기 위한 데이터 그 자체이다.</li>
<li>활성화 될 컴포넌트 정보 + 활성화 될 컴포넌트에게 전달할 데이터</li>
<li>activity의 경우 startActivity()</li>
<li>service의 경우 startService()</li>
<li>Broadcast Recevier의 경우 sendBroadcast()</li>
<li>외부 패키지에서 접근하려면 <activity exported="true"> 이어야 한다.</activity></li>
</ul>
<h2 id="intent의-종류">Intent의 종류</h2>
<p>안드로이드의 4대 컴포넌트가 상호 통신을 위해 사용하는 인텐트는 크게 두가지로 나뉜다.</p>
<ol>
<li>명시적 인텐트</li>
</ol>
<p>인텐트에 클래스 객체네 컴포넌트 이름을 지정하여 호출될 대상을 확실히 알 수 있는 경우에 사용하는 것을 <strong>명시적 인텐트</strong>라고 한다. 주로 애플리케이션 내부에서 사용한다.</p>
<p>간단하게 현재 액티비티에서 SecondActivity로 화면 전환을 하는 코드는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        button.setOnClickListener&#123;</span><br><span class="line">            <span class="comment">// 주의해서 볼 코드</span></span><br><span class="line">            <span class="keyword">var</span> intent = Intent(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, SecondActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>새로운 인텐트 객체인 intent를 생성하면서 this@MainActivity 즉, getContext와 같은 현재 액티비티 정보가 담겨있는 정보와 SecondActivity 즉, 호출할 컴포넌트를 파라미터로 넘겨준다. 그리고 startActivity()에 인텐트 객체인 intent를 파라미터로 넘겨주면 새로운 화면인 SecondActivity가 실행된다. startActivity()는 새로 띄우는 액티비티로부터 받는 응답을 처리할 필요가 없을 때 간단하게 사용된다.</p>
<p>이에 반해 **startActivityForResult()**의 경우 새로 띄운 액티비티로부터 받는 응답을 처리할 경우에 사용된다.</p>
<ol start="2">
<li>암시적 인텐트</li>
</ol>
<p><strong>인텐트의 액션과 데이터를 지정하긴 했지만, 호출할 대상이 달라질 수 있는 경우에는 암시적 인텐트를 사용한다.</strong> 즉 설치된 애플리케이션들에 대한 정보를 알고 있는 안드로이드 시스템이 인텐트를 이용해 요청한 정보를 처리할 수 있는 적절한 컴포넌트를 찾아본 다음 사용자에게 그 대상과 처리 결과를 보여주는 과정을 거치게 된다.</p>
<p>특정 컴포넌트에서 암시적 인텐트를 받기 위해서는 매니페스트 파일에서 <intent-filter> 요소와 함께 어플리케이션 컴포넌트 각각에 대해서 하나 이상의 인텐트 필터를 선언해야 한다. 각각의 컴포넌트는 action, data, category를 기반으로 해서 자신이 받길 원하는 인텐트의 유형을 명시해야 한다.</intent-filter></p>
<p>안드로이드 시스템은 전달되는 암시적 인텐트가 매니페스트에 존재하는 인텐트 필터 중의 하나와 매칭되는 경우 해당 컴포넌트로 암시적 인텐트를 전달해준다.</p>
<p>암시적 인텐트를 사용하는 대표적인 경우로 <strong>문서 편집기</strong>를 예로 들 수 있다. 카카오톡으로 친구가 자신의 자소서를 봐달라며 PDF 파일을 첨부했다. 우리는 그 PDF를 클릭하여 열기를 하면 해당 안드로이드 폰에 PDF를 편집하거나 보여줄 수 있는 많은 애플리케이션들이 서로 자기가 그 PDF 파일을 보여줄 수 있다고 손을 든다.</p>
<p>그러면 안드로이드 시스템에서는 ‘PDF를 열 수 있는 앱들이 이렇게 많은데 어떤거 선택할래?’ 라고 애플리케이션을 선택할 수 있는 위젯을 띄워준다. 이런 일련의 과정을 가능하게 하는 녀석이 <strong>암시적 인텐트</strong>이다.</p>
<blockquote>
<p>그럼 왜 암시적 인텐트를 사용할까??</p>
</blockquote>
<p>위의 예에서 우리는 친구의 자소서 PDF 파일을 열려고 한다. 여기서 PDF 파일을 열기 위해 이미 많은 PDF 리더 앱들이 존재한다. 그런데 굳이 우리가 PDF 리더를 만드는 것은 현실적으로 좋은 방법이 아니다. 따라서 <strong>이미 기존에 어떤 기능들을 지원하는 앱들이 있는 경우에 암시적 인텐트를 사용해서 그 앱들을 사용하면 되는 것</strong>이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 네이버 페이지</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"http://m.naver.com"</span>))</span><br><span class="line">startActivity(intent)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 전화 걸기</span></span><br><span class="line"><span class="keyword">var</span> intent = Intent(Intent.ACTION_VIEW, Uri.parse(<span class="string">"tel:010-0000-0000"</span>))</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>
<p>위와 같이 암시적 인텐트는 보통 액션(Action)과 데이터(data)라는 속성으로 구성되어 있다. 이 두 가지 속성 말고도 Category, Type, Component, Extras라는 속성을 가진다. 여기서 Component라는 속성을 지정할 경우 컴포넌트 클래스 이름을 명시적으로 지정하게 되는데 이 경우가 <strong>명시적 인텐트</strong>에 속하게 된다.</p>
<p>결국 암시적 인텐트는 Component 속성을 제외한 나머지 속성들로 구성되며, 이러한 속성들에 부합하는 컴포넌트가 실행된다.[호출할 대상들이 달라질 수 있다.]</p>
<p>안드로이드 폰에서 위의 코드 중 네이버에 접속하는 코드를 실행한 결과 화면은 아래와 같다.</p>
<img src="/img/android_intent.png" width="500" height="300">
<p>이와 같이 암시적 인텐트는 그 속성에 부합하는 컴포넌트가 여러 개 있을 때 선택할 수 있도록 해준다.</p>
<h2 id="intent-flag">Intent Flag</h2>
<p>안드로이드 애플리케이션 개발을 하다가 Activity에 대해 중복을 방지하거나 다른 상황에 대처할 때 Flag에 대해 잘 관리를 한다면 Activity에 대한 이해를 할 수 있고 관리 또한 용이하게 할 수 있다.</p>
<img src="/img/android_task.png" width="500" height="300">
<p><strong>안드로이드 태스크란?</strong>(Android Task, Activity Stack)</p>
<ul>
<li>Task는 애플리케이션에서 실행되는 액티비티를 보관하고 관리하며 Stack 형태의 연속된 Activity들로 이루어진다.</li>
<li>LIFO(Last In First Out) 즉, 후입 선출 형태로 나중에 적재된 액티비티일수록 가장 먼저 사용된다.</li>
<li>만약 1-&gt;2-&gt;3 페이지 순으로 액티비티를 이동했을 때 실행 순서대로 Task에 push 했다가 back 버튼을 누르면 3-&gt;2-&gt;1 페이지 순으로 Task에서 pop 시켜 돌아간다.</li>
<li>서로 다른 애플리케이션 간의 이동에도 Task를 이용해 사용자 경험(UX)를 유지시켜준다.</li>
<li>최초 적재 액티비티는 Root Activity라고도 하며 애플리에키션 런처로부터 시작된다.</li>
<li>마지막으로 적재되는 액티비티는 Top Activity라고 하며 현재 화면에 활성화 되어 있는 액티비티를 말한다.</li>
<li>Task 내에는 서로 다른 애플리케이션의 액티비티들이 포함될 수 있어 애플리케이션에 경계 없이 하나의 애플리케이션인 것처럼 보이게 해준다.</li>
<li>Task의 Stack내에 존재하는 액티비티들은 모두 묶여서 background와 foreground로 함께 이동한다.</li>
<li>홈버튼 클릭 : task interrupt -&gt; background</li>
<li>홈버튼 롱클릭 : recent task -&gt; foreground</li>
<li>Flag를 사용하여 Task 내의 액티비티의 흐름을 제어할 수 있다.</li>
</ul>
<p><strong>어피니티란?</strong>(Android Affinity)</p>
<ul>
<li>애플리케이션 내의 액티비티들은 하나의 어피니티(affinity : 친화력)을 가지고 있다.</li>
<li>AndroidManifest 파일에서 <activity> 요소의 taskAffinity 속성을 사용해 개별 affinity가 지정 가능하다.</activity></li>
<li>FLAG_ACTIVITY_NEW_TASK 플래그를 가진 인텐트 객체로부터 호출된 allowTaskReparenting 속성을 true로 가지고 있는 액티비티에 한해 affinity가 동작한다.</li>
<li>위 조건이 만족한 상황에서 시작된 액티비티는 자신과 동일한 어피니티를 갖는 태스크가 있을 경우 해당 태스크로 이동한다.</li>
<li>즉, [b] 어피니티를 가진 A 액티비티가 호출되어 해당 테스크에 속해있을 때 [b] 어피니티를 가진 태스크가 호출되면 A 액티비티는 [b] 어피니티를 가진 태스크로 이동한다.</li>
<li>어피니티에 의해 테스크가 이동된 후에 back 버튼으로 반환시 원래 해당하던 테스크로 돌아간다.</li>
<li>하나의 애플리케이션내에서 하나 이상의 기능을 갖는 애플리케이션이 존재할 경우 각 액티비티별로 다른 어피니티를 지정해 관리할 수 있다.</li>
</ul>
<p>Flag를 사용하는 방법은 AndroidManifest 파일에서 사용하는 방법과 Intent 코드로 사용하는 방법이 있다.</p>
<ol>
<li>AndroidManifest에서 사용하기</li>
</ol>
<p>안드로이드의 launchMode 속성을 사용하여 적용할 수 있다. 원하는 액티비티에 속성을 추가하여 적용하면 된다. launchMode에서 사용 가능한 속성은 다음과 같이 4가지만 가능하다.</p>
<ul>
<li>standard : 스택 중 어느 곳에나 위치 가능하며 <strong>여러 개의 인스턴스가 생성 가능하다.</strong></li>
<li>singleTop : 스택 중 어느 곳에나 위치 가능하며 여러 개의 인스턴스가 생성 가능하고 호출한 activity와 현재 최상위 activity가(top activity) <strong>동일한 경우 최상위 activity가 재사용</strong>된다.(기존 최상위 activity는 pop)</li>
<li>singleTask : 루트 액티비티로만 존재하며 <strong>하나의 인스턴스만 생성 가능</strong>하다. (타 task에서 동일 activity 사용 불가) 다른 액티비티 실행시 동일 Task 내에서 실행이 가능하다.</li>
<li>singleInstance : 루트 액티비티로만 존재하며 하나의 인스턴스만 생성 가능하고 <strong>태스크 내에 해당 액티비티 하나만 속할 수 있어</strong> 다른 액티비티를 실행시키면 새로운 Task가 생성되어 (FLAG_ACTIVITY_NEW_TASK와 동일) 그 Task 내에 포함된다.</li>
</ul>
<ol start="2">
<li>소스 코드에서 플래그를 사용하고 싶을 때는 Intent에 addFlags(), setFlags() 메소드를 사용한다.</li>
</ol>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK : 동일 affinity의 task가 있으면 그곳에 실행되고 아니면 새로운 task를 실행한다.[실행은 액티비티를 만들어 테스크에 넣는 것을 의미]</li>
<li>FLAG_ACTIVITY_SINGLE_TOP :  호출되는 액티비티가 최상위에 존재할 경우에는 해당 액티비티를 다시 생성하지 않고 존재하던 액티비티를 재사용한다. [실행시 재사용 액티비티의 실행은 onPause(), onNewIntent(), onResume() 순으로 호출된다.]
<ul>
<li>[B]를 single top 설정 : [A][B] 상태에서 [B] 호출 시 =&gt; [A][재사용된 B]</li>
<li>[A]를 single top 설정 : [B][A] 상태에서 [B] 호출 시 =&gt; [B][A][B]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_NO_HISTORY : 해당 액티비티는 재활성화시(back 키를 눌러 다시 활성화될 때) pop된다.
<ul>
<li>[B]를 no history 설정 : [A][B][A] 상태에서 back 키 사용시 [A]가 pop되고 [B] 역시 no history에 의해 pop =&gt; [A] 만 남음.</li>
</ul>
</li>
<li>FLAG_ACTIVITY_REORDER_TO_FRONT : activity 호출 시 이미 같은 activity가 task 내에 있으면 같은 activity는 pop시키고 해당 activity가 push 된다.
<ul>
<li>[A]를 reorder to front 설정 : [A][B] 상태에서 [A] 호출 시 같은 activity인 [A]가 pop되고 =&gt; [B][A]</li>
</ul>
</li>
<li>FLAG_ACTIVITY_CLEAR_TOP : 해당 task에 있는 모든 activity를 pop시키고 해당 activity가 root activity로 task에 push된다.
<ul>
<li>[A]를 clear top 설정 : [A][B] 상태에서 [A] 호출시 모두 pop되고 =&gt; [A]</li>
<li>단, 해당 플래그는 액티비티를 모두 onDestroy()시킨 후 새롭게 onCreate()시키기 때문에 [A]를 유지하려면 FLAG_ACTIVITY_SINGLE_TOP 플래그와 함께 사용하면 된다.</li>
</ul>
</li>
<li>추가적인 플래그는 아래의 안드로이드 개발자 문서를 참고하자.</li>
<li><a href="https://developer.android.com/reference/android/content/Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT" target="_blank" rel="noopener">추가 정보</a></li>
</ul>
<p><strong>Clear Task</strong></p>
<ul>
<li>Task를 오랫동안 사용하지 않고 방치해두면 시스템은 Root Activity를 제외한 모든 액티비티를 Clear 시킨다.</li>
<li>이러한 동작은 Activity의 속성을 수정하여 제어할 수 있다.</li>
</ul>
<ol>
<li>alwaysRetainTaskState<br>
Task의 Root Activity에 true로 설정되어 있다면 상단에 언급되었던 동작은 발생하지 않으며 Task는 오랜 시간 이후에도 Stack에 있는 모든 Activity를 유지한다.</li>
</ol>
<ol start="2">
<li>clearTaskOnLaunch<br>
이 속성이 true로 설정되어 있으면 alwaysRetainTaskState과 정반대로 사용자가 Task를 떠났다가 다시 돌아올 때마다 항상 Stack은 Root Activity로 정리된다.</li>
</ol>
<ol start="3">
<li>finishOnTaskLaunch<br>
이 속성은 clearTaskOnLaunch와 유사하지만 전체 Task가 아닌 단일 Activity에서 동작한다. 그리고 그것은 Root Activity를 포함한 어떤 Activity가 사라지는 원인이 될 수도 있다. true로 설정되어 있을 때, Activity는 현재 Sessing 동안 Task의 일부만 유지한다. 만일 사용자가 해당 Task를 벗어났다가 다시 돌아오면 더 이상 존재하지 않는다.</li>
</ol>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://limkydev.tistory.com/35" target="_blank" rel="noopener">인텐트 (intent 명시적, 암시적)</a></li>
<li><a href="https://newgenerationkorea.wordpress.com/2015/07/09/%EC%9D%B8%ED%85%90%ED%8A%B8intent%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/" target="_blank" rel="noopener">인텐트란 무엇인가?</a></li>
<li><a href="http://androidhuman.tistory.com/262" target="_blank" rel="noopener">내가 누군지 말해줘! - 인텐트 필터</a></li>
<li><a href="http://arabiannight.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9CAndroid-%ED%83%9C%EC%8A%A4%ED%81%AC%EB%9E%80-Task-Activity-Stack-%EC%96%B4%ED%94%BC%EB%8B%88%ED%8B%B0%EB%9E%80-Android-Affinity-%ED%94%8C%EB%9E%98%EA%B7%B8%EB%9E%80" target="_blank" rel="noopener">안드로이드/Android 태스크란? (Task, Activity Stack) 어피니티란? (Android Affinity) 플래그란? (Android Flag)</a></li>
<li><a href="http://kylblog.tistory.com/21" target="_blank" rel="noopener">안드로이드 Intent Flag 정리(Activity 관리)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-is-Intent/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Android-What-Is-Fragment/"
                            aria-label=": [안드로이드] Fragment"
                        >
                            [안드로이드] Fragment
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T12:31:10+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="fragment란">Fragment란??</h2>
<p>Fragment란 하나의 Activity가 여러 개의 분할된 화면을 가지도록 만들기 위해 고안된 개념이다. 다양한 크기의 화면을 가진 모바일 환경이 늘어나고 태블릿의 큰 화면에 대한 <code>Activity의 비효율성</code>이 부각되었다. 이처럼 하나의 디스플레이 화면 안에서 다양한 화면을 보여주고 싶은 니즈를 충족시키기 위해 등장한 것이 Fragment이다.</p>
<p>Fragment를 사용하면 다른 Activity에서도 <strong>재사용</strong>할 수 있다는 장점이 있다. 또한 전체 화면인 Activity에서 부분 화면을 만드는 데 주로 사용된다.</p>
<p>Fragment는 항상 Activity 위에 올라가 있어야 한다. 자체 생명주기를 갖지만, Activity의 생명주기에 종속적이다. Activity가 소멸되면 그 위의 Fragment도 소멸된다.</p>
<p>안드로이드 4대 컴포넌트(Activity, Service, Broadcast Receiver, Content Provider)들은 <strong>인텐트</strong>를 이용하여 상호 간에 통신을 진행한다. 하지만 Fragment는 안드로이드의 4대 컴포넌트에 속하는 구성 요소가 아니다. 따라서 인텐트를 사용하여 값을 전달할 수 없다.</p>
<p>그래서 Fragment 간에 값을 전달하고 상호 통신을 하기 위해서 고안된 것이 <code>Bundle</code>이라는 것이다. Fragment는 Bundle이라는 객체를 통해서 Fragment 간의 데이터 전달을 수행한다.</p>
<blockquote>
<p>추가 내용</p>
</blockquote>
<p>Fragment는 자신이 속한 Activity와만 통신을 해야하며, 항상 자신이 속한 Activity를 통해서 다른 Fragment나 Activity와 통신해야 한다.<br>
Fragment와 Activity가 통신할 수 있는 방법에는 3가지 방법이 있다.</p>
<ol>
<li>Bundle - Acticity는 Fragment를 생성 후, 데이터를 넣은 bundle을 전달할 수 있다. Fragment는 onActivityCreated() 메소드에서 bundle을 받게 된다.</li>
<li>Method - Activity는 Fragment의 메소드를 호출할 수 있다.</li>
<li>Listener - Fragment는 interface를 사용하여 Activity에서 리스너 이벤트를 발생시킬 수 있다.</li>
</ol>
<p>하나의 Activity에 속하는 다수의 Fragment가 동시에 동작 가능하다. Activity는 한 화면을 다 차지해야 하는데 Fragment는 화면 일부만 점유해도 동작 가능하기 때문에 화면을 분할하여 부분마다 독립적인 유저 인터페이스를 구현할 수 있다. Activity의 일부분을 차지하는 각각의 Fragment는 자신만의 유저 인터페이스를 보여주고, 사용자의 입력에 반응한다.</p>
<p>기기의 화면 크기나 화면 방향 등에 따라 달라지는 Activity의 레이아웃에 맞추어 Fragment의 레이아웃을 재배열하거나 결합할 수 있다. 예를 들어 태블릿에서는 Activity에 두 개의 Fragment를 추가한 유저 인터페이스를 보여주지만 핸드폰에서는 Activity당 하나의 Fragment를 추가한 유저 인터페이스를 보여준다.</p>
<h2 id="fragments-lifecycle">Fragment’s LifeCycle</h2>
<p>Fragment는 생명 주기를 갖지만, Activity의 생명주기에 종속적인 특성이 있다.</p>
<img src="/img/fragment_lifecycle.png" width="500" height="300">
<ul>
<li>
<p>onAttach()</p>
<ul>
<li>Fragment가 Activity에 추가될 때 한번 호출된다.</li>
<li>하지만 아직 완벽하게 생성된 것은 아니다.</li>
<li>Fragment가 Activity에 대한 참조를 얻기 위해 사용되어진다.</li>
</ul>
</li>
<li>
<p>onCreate()</p>
<ul>
<li>본격적으로 Fragment가 Activity의 호출을 받아 생성되는 시점이다.</li>
<li>Fragment의 생명주기는 Activity의 생명주기에 <strong>종속적</strong>이라고 앞에서 언급했다. 이 단계에서는 Activity도 생성 중에 있는 시기이기 때문에 Activity에 있는 컨트롤을 참조하거나 Fragment의 요소들을 초기화할 때 불안정한 경우가 있다.</li>
<li>Activity의 onCreate()에서는 view, UI 작업을 할 수 있지만, Fragment의 onCreate()에서는 할 수 없다.</li>
<li>Activity의 onCreate 메소드가 아직 완료된 시점이 아니라서 유저 인터페이스와 관련있는 것을 제외한 Fragment에서 사용되는 리소스들이 초기화된다.</li>
<li>Fragment가 paused 또는 stop 되었다가 다시 resume되었을 때 유지하고 싶은 Fragment의 컴포넌트들을 여기서 초기화 해주어야 한다.</li>
</ul>
</li>
</ul>
<p>setRetainInstance(true)를 호출하여 Fragment의 인스턴스를 유지하도록 할 수 있다. 이 때 다음의 세가지가 기존과 달라진다.</p>
<ol>
<li>Activity가 재생성되어도 Fragment가 유지되기 때문에 onCreate는 호출되지 않는다.</li>
<li>onDestroy()가 호출되지 않지만, Activity로부터 Fragment가 detach될 때 onDetach()는 호출된다.</li>
<li>onAttach(Activity)와 onActivityCreated(Bundle)는 호출된다.</li>
</ol>
<ul>
<li>onCreateView(LayoutInflater, ViewGroup, Bundle)
<ul>
<li>Fragment에 속한 각종 View나 viewGroup에 대한 <strong>UI 바인딩 작업을 할 수 있다.</strong></li>
<li>Fragment의 유저 인터페이스가 화면에 그려지는 시점에 호출된다.</li>
<li>XML 레이아웃을 inflate하여 Fragment를 위한 View를 생성하고 Fragment 레이아웃의 root에 해당되는 View를 Activity에게 리턴해야 한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>inflate?</p>
</blockquote>
<p>inflate는 XML 레이아웃에 정의된 뷰나 레이아웃을 읽어서 메모리상의 view 객체를 생성해주는 것이다.</p>
<ul>
<li>
<p>onActivityCreated()</p>
<ul>
<li>Activity에서 Fragment를 모두 생성하고(View 생성) 난 다음에 호출된다.</li>
<li>Activity에서 onCreate() 다음에 호출되는 메소드이다.</li>
<li>Activity와 Fragment가 드디어 연결되는 시점이다.</li>
<li>Activity와 Fragment의 View가 모두 생성된 시점이라 findViewById()를 사용하여 View 객체에 접근하는게 가능하다.</li>
</ul>
</li>
<li>
<p>onStart()</p>
<ul>
<li>Fragment가 사용자에게 보여지기 전에 호출되는 함수이다.</li>
<li>Fragment가 속한 Activity가 start 된 것과 관련있음.</li>
</ul>
</li>
<li>
<p>onResume()</p>
<ul>
<li>Fragment가 비로소 화면에 보이는 단계이다.</li>
<li>사용자에게 <strong>focus</strong>를 잡은 상태.</li>
<li>사용자와의 상호 작용이 가능하다.</li>
<li>Fragment가 속한 Activity가 resume된 것과 관련있음.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 사용되지 않을 때 호출되는 함수들</strong></p>
<ul>
<li>
<p>onPause()</p>
<ul>
<li>Activity가 pause되어 Fragment는 사용자와의 상호작용을 중지한다.</li>
<li>Fragment가 중지되는 시점을 정의한다. Fragment의 정지가 반드시 Fragment의 소멸을 의미하는 것은 아니지만 다시 해당 Fragment로 돌아온다는 보장도 없기 때문에 이 시점에서 <strong>남겨두어야 하거나 보존해야 할 자료들을 저장</strong>한다.</li>
</ul>
</li>
<li>
<p>onStop()</p>
<ul>
<li>Activity에 의해 stop되었거나 Fragment의 수행이 Activity에 의해 수정되었을 경우로 Fragment는 더 이상 보이지 않게 되며, Fragment 기능은 중지한다.</li>
</ul>
</li>
</ul>
<p><strong>Fragment가 destroy될 때 다음 순서대로 호출된다.</strong></p>
<ul>
<li>
<p>onDestroyView()</p>
<ul>
<li>Fragment가 화면에서 보이지 않고 View의 현재 상태가 저장된 후 호출된다.</li>
<li><strong>Fragment의 View들을 제거(destroy)한다.</strong></li>
<li>Back Stack을 사용했다면, 해당 Fragment로 돌아올 때 onCreateView()가 호출된다.</li>
<li>onCreateView에서 초기화했던 UI들을 여기서 해제하면 된다.</li>
</ul>
</li>
<li>
<p>onDestroy()</p>
<ul>
<li>Fragment를 더 이상 사용하지 않을 때 호출된다.</li>
<li>Activity와 연결이 끊어진 상태는 아니지만 Fragment는 동작하지 않는다.</li>
<li>Fragment를 제거하기 직전.</li>
<li>시스템에서 onDestory()가 항상 호출되는 것을 보장해주지 않는다.</li>
</ul>
</li>
<li>
<p>onDetach()</p>
<ul>
<li>onDetach가 호출된 후, Fragment를 비로소 제거하고 Activity와의 연결도 해제한다.</li>
<li>Framgnet의 View hierarchy가 더 이상 존재하지 않게 된다.</li>
<li>부모 Activity가 즉, 종속된 Activity가 생명주기를 완전하게 마치지 않고 종료되었다면 onDetach()는 호출되지 않을 수도 있다.</li>
</ul>
</li>
</ul>
<h2 id="액티비티와-프래그먼트-차이">액티비티와 프래그먼트 차이</h2>
<p>위에서 언급했듯이 태블릿이 등장하면서 큰 화면에 대한 액티비티의 <strong>비효율성</strong>이 부각되었다. 태블릿의 큰 화면에 여러 액티비티를 보여주기 위해 나온 것이 프래그먼트이다. 하나의 액티비티에 여러 레이아웃을 배치하여 구성할 수도 있지만 <code>프래그먼트</code>를 사용하면 다른 액티비티에서도 <strong>재사용</strong>이 가능하고 <strong>자체 생명주기</strong>를 가지기에 생명주기에 따라 다양한 구현이 가능하다. 또한 자체 입력 이벤트를 가지기에 다이나믹한 인터렉션이 가능하다.</p>
<p>프래그먼트의 생명주기는 액티비티의 생명주기에 <strong>종속적</strong>이기에 액티비티에서 <code>onCreate()</code>가 호출되면 프래그먼트에서는 <code>onActivityCreated()</code>가 호출되고 액티비티에서 <code>onPause()</code>가 호출되면 프래그먼트도 <code>onPause()</code>가 된다.</p>
<p>프래그먼트에서 액티비티와 통신을 하려면 getActivity()를 호출하면 액티비티 객체를 사용할 수 있으며 프래그먼트에서 발생하는 이벤트는 <code>onAttach()</code>에서 _interfactionListener_를 호출하고 액티비티에서 이것을 구현함으로써 이벤트에 대한 처리와 프래그먼트간 통신이 가능하다.</p>
<p>액티비티를 관리하는 스택이 있듯이 프래그먼트에도 <strong>백스택</strong>이라는 스택 구조가 존재하며 이것은 액티비티가 관리한다. <code>FragmentTransaction</code> 객체의 addToBackStack() 함수를 사용하여 프래그먼트를 백스택에 저장하면 사용자가 뒤로가기 버튼을 눌렀을 때 프래그먼트의 이전 상태로 되돌려주는 기능을 제공할 수 있다.</p>
<img src="/img/android_compare_activity_fragment.png" width="500" height="300">
<img src="/img/android_compare_activity_fragment2.png" width="500" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://hyeonu1258.github.io/2018/04/01/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%20%EB%A9%B4%EC%A0%912/" target="_blank" rel="noopener">액티비티와 프래그먼트 차이</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/01/02/Android-What-Is-Fragment/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/01/02/Java-Type-of-Error/"
                            aria-label=": [Java] RunTime Error vs Compile Error"
                        >
                            [Java] RunTime Error vs Compile Error
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-01-02T10:58:48+09:00">
	
		    Jan 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>자바를 공부하며 항상 등장하는 말은 컴파일과 런타임이다. 하지만 두 용어에 대한 개념이 확실하지 않아 이번 기회에 정리하고 넘어가겠다.</p>
                    
                        <a
                            href="/2019/01/02/Java-Type-of-Error/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] RunTime Error vs Compile Error"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/31/Java-static-concept/"
                            aria-label=": [Java] Static"
                        >
                            [Java] Static
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-31T11:52:46+09:00">
	
		    Dec 31, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p><code>Static</code>이라는 키워드는 보통 변수나 메소드 앞에서 사용한다.</p>
                    
                        <a
                            href="/2018/12/31/Java-static-concept/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Java] Static"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Diff-Of-HTTP-HTTPS/"
                            aria-label=": [네트워크] HTTP와 HTTPS"
                        >
                            [네트워크] HTTP와 HTTPS
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T22:35:54+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="http의-문제점">HTTP의 문제점</h2>
<p>HTTP는 다음과 같은 문제점을 갖는다.</p>
<ol>
<li>HTTP는 평문 통신이기 때문에 도청이 가능하다.</li>
<li>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</li>
<li>완전성을 증명할 수 없기 때문에 변조가 가능하다.</li>
</ol>
<p>위 세 가지는 다른 암호화하지 않은 프로토콜에도 공통되는 문제점들이다.</p>
<p><strong>TCP/IP는 도청 가능한 네트워크이다.</strong></p>
<p>TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로도 도청할 수 있다. 평문으로 통신을 할 경우 메시지의 의미를 파악할 수 있기 때문에 암호화하여 통신해야 한다.</p>
<p>1번 문제를 보완하는 방법은 다음과 같다.</p>
<ol>
<li>
<p>통신 자체를 암호화<br>
SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화할 수 있다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure) or HTTP over SSL이라고 부른다.</p>
</li>
<li>
<p>콘텐츠를 암호화<br>
말 그대로 HTTP를 사용해서 운반하는 내용인 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다. 암호화해서 전송하면 받은 측에서는 그 암호를 해독하여 출력하는 처리가 필요하다.</p>
</li>
</ol>
<p><strong>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</strong></p>
<p>HTTP에 의한 통신에는 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 Request를 보낼 수 있다. IP 주소나 포트 등에서 그 웹 서버에 엑세스 제한이 없는 경우 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다. 이러한 특징은 여러 문제점을 유발한다.</p>
<ul>
<li>리퀘스트를 보낸 곳의 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지를 확인할 수 없다.</li>
<li>리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지를 확인할 수 없다.</li>
<li>통신하고 있는 상대가 접근이 허가된 상대인지를 확인할 수 없다.</li>
<li>어디에서 누가 리퀘스트 했는지 확인할 수 없다.</li>
<li>의미없는 리퀘스트도 수신한다. -&gt; DoS 공격을 방지할 수 없다.</li>
</ul>
<p>2번 문제를 보완하는 방법은 다음과 같다.</p>
<p><code>SSL</code>로 상대를 확인할 수 있다. SSL은 상대를 확인하는 수단으로 <strong>증명서</strong>를 제공하고 있다. 증명서는 신뢰할 수 있는 써드 파티로부터 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다.</p>
<p>이 증명서를 이용함으로써 통신 상대가 내가 통신하고자 하는 서버임을 나타내고 이용자는 개인 정보 누설 등의 위험성이 줄어들게 된다. 한 가지 이점을 더 꼽자면 클라이언트는 이 증명서로 본인 확인을 하고 웹 사이트 인증에서도 이용할 수 있다.</p>
<blockquote>
<p>SSL의 작동 과정</p>
</blockquote>
<ol>
<li>클라이언트가 SSL로 암호화된 페이지를 요청한다.(일반적으로 <a href="https://xn--o39a" target="_blank" rel="noopener">https://가</a> 사용된다.)</li>
<li>서버는 Public Key와 인증서를 함께 전송한다.</li>
<li>인증서가 신용있다고 판단한 CA(Certificate Authority)로부터 서명된 것인지 판단한다.</li>
<li>클라이언트는 Public Key를 사용해서 랜덤 대칭 암호화키와 URL, http 데이터를 암호화하여 서버로 전송한다.</li>
<li>서버는 Private Key를 이용하여 랜덤 대칭 암호화키와 URL, http 데이터를 복호화한다.</li>
<li>서버는 요청받은 URL에 대한 응답을 랜덤 대칭 암호화키를 이용해서 암호화해서 클라이언트로 전송한다.</li>
<li>클라이언트는 대칭 키를 이용해서 http 데이터를 복호화하고 데이터를 이용한다.</li>
</ol>
<p>SSL의 인증과 암호화 과정을 통해 3번 문제 또한 해결할 수 있다.</p>
<p><strong>완전성을 증명할 수 없기 때문에 변조가 가능하다.</strong></p>
<p>여기서 완전성이란 <code>정보의 정확성</code>을 의미한다. 서버 또는 클라이언트에서 수신한 내용이 송신측에서 보낸 내용과 일치한다라는 것을 보장할 수 없는 것이다. 리퀘스트나 리스폰스가 발신된 후에 상대가 수신하는 사이에 누군가에 으해 변조되더라도 이 사실을 알 수 없다. 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 공격을 중간자 공격(Main-in-the-Middle)이라고 부른다.</p>
<p>3번 문제를 보완하는 방법은 2번 문제를 보완하는 방법으로도 해결이 가능하다.</p>
<p>MD5, SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 존재하지만 확실히 확인할 수 있는 것은 아니다. 확실히 방지하기에는 <strong>HTTPS</strong>를 사용해야 한다. SSL에는 인증이나 암호화, 그리고 다이제스트 기능을 제공하고 있다.</p>
<h2 id="https">HTTPS</h2>
<p>HTTPS는 HTTP 통신하는 소켓 부분은 SSL or TLS라는 프로토콜로 대체한 것이다. HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.<br>
HTTPS의 SSL에서는 공통키 암호화 방식과 공개키 암호화 방식을 모두 사용한다.(두 개를 혼합한 하이브리드 암호화 시스템) 공통키를 공개키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식아.</p>
<p>[공통키, 공개키, 대칭키 암호화 방식이 뭘까…?]</p>
<p>모든 웹 페이지에서 HTTPS를 사용하지 않는다. 그 이유는 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 많이 필요로 하기 때문이다. 통신할 때마다 암호화를 하면 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 Request 수가 줄어들게 된다. 따라서 민감한 정보를 다룰 때만 HTTPS에 의한 암호화 통신을 사용한다.<br>
그러나! 개인정보를 주고 받지 않아도 SSL을 이용해야 한다. 어느 사이트에 접속하는지, 어떤 행동을 하는지 공개될 수 있다. 모든 사용자의 행동 및 정보는 보호받아야 할 권리가 있다. 예를 들어, A 사이트에서 로그인 페이지로 넘어갈 때 해커가 가짜 로그인 페이지로 보낼 수 있는 확률도 존재한다.</p>
<h2 id="참고">참고</h2>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Diff-Of-HTTP-HTTPS/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Erro-Flow-Control/"
                            aria-label=": [네트워크] 흐름/혼잡/오류 제어 기법"
                        >
                            [네트워크] 흐름/혼잡/오류 제어 기법
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T19:19:04+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>TCP의 가장 큰 특징은 <strong>신뢰성</strong>이다. 이러한 신뢰성을 구성해 주는 방법인 <strong>흐름 제어, 혼잡 제어, 오류 제어</strong>에 대해 알아보도록 하자.</p>
<h2 id="흐름-제어">흐름 제어</h2>
<p>송신(호스트) &lt;&gt; 수신(호스트)</p>
<p>흐름 제어는 수신측과 송신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다.<br>
만약 송신측의 전송량이 수신측의 처리량보다 많은 경우, 전송된 패킷은 수신측의 큐를 넘어서 손실될 문제가 발생할 수 있기 때문에 <strong>송신측의 패킷 전송량을 제어하게 된다.</strong></p>
<h3 id="흐름-제어-방법">흐름 제어 방법</h3>
<ol>
<li>정지-대기(Stop and Wait)</li>
</ol>
<img src="/img/stop_and_wait.png" width="400" height="200">
<ul>
<li>매번 전송한 패킷에 대해 응답을 받아야만 그 다음 패킷을 전송할 수 있다.</li>
<li>구조가 간단한 대신, 하나를 주고 하나를 받기 때문에 <strong>비효율적이다.</strong></li>
</ul>
<ol start="2">
<li>슬라이딩 윈도우(Sliding Window)</li>
</ol>
<p>수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법이다.</p>
<p><strong>이처럼 슬라이딩 윈도우 기법을 통하여 송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적으로 바뀜으로써 흐름제어를 수행한다.</strong></p>
<ul>
<li>윈도우는 전송, 수신 스테이션 양쪽에서 만들어진 <code>버퍼(Buffer)</code>의 크기이다.</li>
<li>윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수)</li>
<li>슬라이딩 윈도우 기법은 Stop and Wait 기법의 비효율성을 개선한 기법이다.</li>
<li>ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다.</li>
</ul>
<img src="/img/error_flow_control_2.png" width="400" height="200">
<p>위와 같은 구조에서 데이터 0과 1을 전송했다고 가정하면 슬라이딩 윈도우의 구조는 아래와 같이 변한다. 윈도우의 크기는 전송한 데이터 프레임만큼 왼쪽 경계가 줄어들게 된다.</p>
<img src="/img/error_flow_control_3.png" width="400" height="200">
<p>이때 수신측에서 ACK라는 프레임을 받게 된다면 전송측은 0과 1 데이터를 정상적으로 받았음을 알게 되고, 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다.</p>
<img src="/img/error_flow_control_4.png" width="400" height="200">
<blockquote>
<p>조금 더 자세한 설명</p>
</blockquote>
<p><strong># 전송측 윈도우</strong></p>
<img src="/img/transfer_window.png" width="400" height="200">
<p><strong># 수신측 윈도우</strong></p>
<img src="/img/receive_window.png" width="400" height="200">
<h2 id="혼잡-제어">혼잡 제어</h2>
<p>송신(호스트) &lt;&gt; 라우터(네트워크)</p>
<p>혼잡 제어는 송신측의 데이터 전달과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.</p>
<p>송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 하지만 이러한 네트워크 상의 라우터가 항상 한가로운 상황은 아니다. 만약, 한 라우터에게 데이터가 몰릴 경우 다시 말해 혼잡할 경우, 라우터는 자신에게 온 데이터를 모두 처리할 수 없다.<br>
그렇게 되면 호스트들은 또 다시 재전송을 하게 되고 결국 혼잡을 가중시켜 오버플로우나 데이터 손실을 발생시킨다. <strong>따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서는 보내는 데이터의 전송 속도를 강제로 줄이게 된다.</strong></p>
<h3 id="혼잡-제어-방법">혼잡 제어 방법</h3>
<ol>
<li>AIMD</li>
</ol>
<p>AIMD(Additive Increase / Multiplicative Decrease)라고 불리며, 합 증가 / 곱 감소라고 부른다.</p>
<p>처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간내에 보내는 패킷의 수)를 1씩 증가시켜 가면서 전송하는 방법이다. 만일 패킷 전송을 실패하거나 일정한 시간을 넘으면 패킷 전송 속도를 절반으로 줄이게 된다.</p>
<p>이 방식은 <strong>공평한 방식</strong>이다. 이 방식을 사용하는 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 <code>평형 상태</code>로 수렴하게 되는 특징이 있다.</p>
<p><strong>문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하며 오랜 시간이 걸리게 되고 네트워크가 혼잡해지는 상황을 미리 감지하지는 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.</strong></p>
<p>이러한 문제점들을 해결하기 위한 방법은 다음부터 소개될 것이다.</p>
<ol start="2">
<li>슬로우 스타트(Slow Start)</li>
</ol>
<p>AIMD 방식은 네트워크의 수용량 주변에서는 효율적으로 작동하지만 처음에 전송 속도를 올리는 데 걸리는 시간이 너무 길다는 단점이 있다.</p>
<p>Slow Start 방식은 AIMD 방식과 마찬가지로 패킷을 하나씩 보내는 것부터 시작하고 이 방식은 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window size가 2배가 된다.</p>
<p>따라서 전송 속도는 AIMD와는 다르게 지수 함수꼴로 증가하게 된다. 대신 <strong>혼잡 현상이 발생하면 Window Size를 1로 떨어뜨리게 된다.</strong></p>
<p>처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있으므로 혼잡 현상이 발생하였던 Window Size의 절반까지는 이전처럼 지수 함수 꼴로 Window Size를 증가시키고 그 이후부터는 완만하게 1씩 증가시키는 방식이다.</p>
<ol>
<li>초기 혼잡 Window Size 1로 전송 = 전송 호스트는 하나의 패킷만 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 2로 하여 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도우의 크기를 4로 하여 전송</li>
<li>수신 호스트로부터 수신응답을 수신하면 윈도위의 크기를 8로 하여 전송</li>
</ol>
<img src="/img/error_flow_control_10.png" width="400" height="200">
<ul>
<li>미리 정해진 임계 값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다.</li>
<li>Slow Start란 이름을 사용하지만, 매 전송마다 두 배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수 함수적으로 증가한다.</li>
<li>전송되어지는 데이터의 크기가 임계 값에 도달하면 <strong>혼잡 회피</strong> 단계로 넘어간다.</li>
</ul>
<ol start="3">
<li>혼잡 회피(Congestion Avoidance)</li>
</ol>
<p>윈도우의 크기가 임계 값에 도달한 이후에 데이터의 손실이 발생할 확률이 높아지게 된다. 이는 데이터를 전송함에 있어서 조심하는 단계이다.</p>
<p>전송한 데이터에 대한 ACK를 받으면 윈도우의 크기를 1씩 증가시킨다.<br>
전송하는 데이터의 증가를 왕복시간 동안에 하나씩만 증가시킨다.</p>
<ul>
<li>수신 호스트로부터 일정 시간 동안까지 ACK를 수신하지 못하는 경우</li>
</ul>
<ol>
<li>타임아웃의 발생</li>
<li>네트워크에 혼잡이 발생했다고 인식<br>
-&gt; 윈도우의 크기를 즉, 세그먼트의 수를 1로 줄임<br>
-&gt; 동시에 임계 값을 패킷 손실이 발생하였을 때의 윈도우 크기의 반으로 줄임</li>
</ol>
<ol start="4">
<li>빠른 회복(Fast Recovery)</li>
</ol>
<p>빠른 회복은 Congestion이 발생했을 때 Window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이는 AIMD의 AI 즉, Additive Increase 하는 방법이다.</p>
<p>Fast Recovery를 적용하면 혼잡 상황을 한 번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.</p>
<ol start="5">
<li>빠른 재전송(Fast Retransmission)</li>
</ol>
<p>3개의 연속된 중복 ACK를 수신하는 경우에 패킷의 손실로 간주하여 타임아웃이 발생하기 전에 해당 패킷을 <strong>재전송</strong>한다. 그리고 이러한 현상이 일어난 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 반으로 줄인다.</p>
<ol start="6">
<li>TCP Reno</li>
</ol>
<p>N개의 중복 ACK 발생 시 ssthresh(slow start threshold)값을 Congestion Window(cwnd) 사이즈의 반으로 줄여 빠른 복구(Fast Recovery)를 수행하여 선형적 증가를 하게 되며, TCP Time Out에 이르면 Slow Start를 시작한다.</p>
<ol start="7">
<li>TCP Tahoe</li>
</ol>
<p>N개의 중복 ACK 발생 시 바로 Slow Start를 시작한다.</p>
<p>TCP Tahoe와 TCP Reno는 ssthresh(slow start threshold) 값까지 지수적 증가(Slow-Start)를 하게 되고 ssthresh를 넘어서면 선형적 증가(Additive Increase)를 하는 것까지는 동일하다. 차이가 생기는 기준은 N개의 중복 ACK가 발생할 경우이다.</p>
<h2 id="오류-제어">오류 제어</h2>
<p>오류 제어 기법은 오류 검출(Error detection)과 재전송(retransmission)을 포함한다.<br>
ARQ(Automatic Repeat Request) 기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다. ARQ 기법은 흐름 제어 기법과 관련되어 있는데 stop and wait은 stop and wait ARQ로, Sliding Window는 GBn(Go-Back-n) ARQ 또는 SR(Selective-Reject) ARQ 형태로 구혀한다.</p>
<h3 id="오류-제어-방법">오류 제어 방법</h3>
<blockquote>
<p>ARQ : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식</p>
</blockquote>
<ol>
<li>Stop and Wait ARQ</li>
</ol>
<p>전송측은 수신측에서 보내준 ACK를 받을 때까지 프레임의 복사본을 유지한다.<br>
식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 부여한다.</p>
<p>수신측이 데이터를 받지 못했을 경우, NAK를 송신측에게 보내고<br>
NAK를 받은 송신측은 데이터를 재전송한다.</p>
<p><strong>만약 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송한다.</strong></p>
<img src="/img/stop_and_wait_arq.png" width="400" height="200">
<ol start="2">
<li>Go-Back-n ARQ(GBn ARQ)</li>
</ol>
<p>전송된 프렘이이 손상되거나 분실될 경우, <strong>확인된 마지막 프레임 이후로 모두 재전송</strong>하는 기법이다.</p>
<p>슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별을 해야한다.</p>
<ul>
<li>ACK : 다음 프레임을 전송</li>
<li>NAK : 손상된 프레임 자체 번호를 반환</li>
</ul>
<p><strong>재전송 되는 경우는 다음과 같다.</strong></p>
<p><strong># 1. NAK 프레임을 받았을 경우</strong></p>
<p>만약 수신측으로 0부터 5까지의 데이터를 보내었다고 가정한다. 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 받게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다.</p>
<p>그러나 만약 수신측에서 데이터 오류 프레임2가 잘못 되었다는 것을 발견하고 NAK 2를 전송측에 보낸다. NAK 2를 받은 전송측은 데이터 프레임2가 잘못 되었다는 것을 알고 데이터를 재전송한다.</p>
<p>GBn ARQ의 특징은 바로 이 데이터를 재전송하는 부분이다. GBn ARQ는 NAK(n)을 받아 데이터를 재전송하게 되면, n 데이터만을 재전송하는 것이 아니라 n 데이터 이후의 데이터를 모두 재전송한다.</p>
<p><strong># 2. 전송 데이터 프레임의 분실</strong></p>
<p>GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 재전송과 수신측의 폐기이다. 수신측에서 데이터 1을 받았는데 갑자기 다음에 데이터 3을 받게 된다면 수신측에서는 데이터 2를 못받았으므로 데이터 3을 폐기하고 NAK 2를 전송측에 보낸다.</p>
<p>NAK 2를 받은 전송측은 위의 1의 경우에서와 같이 NAK 2 데이터부터 모두 재전송을 실시하며 수신측은 기존 받았던 데이터 중 NAK(n)으로 보내었던 대상 데이터 이후의 데이터를 모두 폐기하고 재전송 받는다.</p>
<p><strong># 3. 지정된 타임아웃 내의 ACK 프레임 분실(Lost ACK)</strong></p>
<p>전송 스테이션은 분실된 ACK를 다루기 위해 타이머를 가지고 있다. 전송측에서는 이 타이머의 타임 아웃동안 ACK 데이터를 받지 못했을 경우, 마지막 ACK부터 재전송한다.</p>
<img src="/img/error_flow_control_6.png" width="400" height="200">
<p>위의 그림은 송신측이 데이터 3을 보내고 수신측은 데이터 3을 받았지만 오류가 발생했을 경우이다. 이 경우에 송신측은 연속적으로 데이터를 보내지만 수신측은 데이터 3에서 오류가 발생했으므로 NAK 3을 송신측으로 보낸다.</p>
<p>수신측은 데이터 3 이후로 온 데이터 프레임을 모두 폐기하며 송신측은 데이터 3부터 재전송하게 된다.</p>
<img src="/img/error_flow_control_7.png" width="400" height="200">
<p>위의 그림은 송신측에서 데이터 2를 보내는 도중에 분실된 경우이다. 이 경우 수신측은 데이터 0, 1은 맞게 받았지만 2를 받지 않고 3을 받게 되어 받은 데이터를 폐기하고 NAK 2를 송신측에게 보낸다.</p>
<p>그럼 송신측은 NAK 2를 받고 데이터 2부터 송신측은 수신측으로 데이터를 재전송하게 된다.</p>
<ul>
<li>전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송한다.</li>
<li>수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다.</li>
<li>타임아웃(ACK 분실)일 경우, 마지막 ACK된 데이터부터 재전송한다.</li>
</ul>
<ol start="3">
<li>Selective-Reject(SR) ARQ</li>
</ol>
<p>GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다. SR ARQ는 손상된, 분실된 프레임만 재전송한다.</p>
<p>그렇기 때문에 별도의 데이터 재정렬을 수행해야 하며, <strong>별도의 버퍼를 필요로 한다.</strong></p>
<h2 id="gbn-arq-기법과-sr-arq-기법의-비교">GBn ARQ 기법과 SR ARQ 기법의 비교</h2>
<img src="/img/error_flow_control_8.png" width="400" height="200">
<img src="/img/error_flow_control_9.png" width="400" height="200">
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://90nam.tistory.com/23" target="_blank" rel="noopener">TCP Tahoe와 TCP Reno</a></li>
<li><a href="http://www.jidum.com/jidums/view.do?jidumId=424" target="_blank" rel="noopener">TCP/IP 혼잡제어</a></li>
<li><a href="http://jsonsang2.tistory.com/17" target="_blank" rel="noopener">흐름 제어와 혼잡 제어</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Erro-Flow-Control/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-Packet-Switching-Method/"
                            aria-label=": [네트워크] 가상회선 패킷 교환 vs 데이터그램 패킷 교환"
                        >
                            [네트워크] 가상회선 패킷 교환 vs 데이터그램 패킷 교환
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T17:20:32+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>패킷 교환 방식은 접속 방식에 따라서 데이터 그램 방식과 가상회선 방식으로 구분된다.</p>
<h2 id="데이터그램-패킷-교환-방식">데이터그램 패킷 교환 방식</h2>
<p>데이터를 전송하기 전에 논리적 연결이 설정되지 않으며 패킷이 독립적으로 전송된다.<br>
이를 <code>데이터그램</code>이라 한다.<br>
패킷을 수신한 라우터는 최적의 경로를 선택하여 패킷을 전송하는데 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있다.(<strong>비연결 지향형</strong>)<br>
<strong>송신 측에서 전송한 순서와 수신 측에 도착한 순서가 다를 수 있다.</strong></p>
<img src="/img/datagram_packet.png" width="500" height="200">
<h2 id="가상회선-패킷-교환-방식">가상회선 패킷 교환 방식</h2>
<p>데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(<strong>연결 지향형</strong>) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다.<br>
데이터 그램은 패킷마다 라우터가 경로를 선택하지만,<br>
가상회선 방식은 경로를 설정할 때 한 번만 수행한다.</p>
<img src="/img/virtual_circut_packet.png" width="500" height="200">
<h2 id="비교">비교</h2>
<p>정해진 시간 안이나 다량의 데이터를 연속으로 보낼 때는 <strong>가상 회선 방식</strong>이 적합하다.<br>
짧은 메시지의 일시적인 전송에는 <strong>데이터그램 방식</strong>이 적합하다.</p>
<p>네트워크 내의 한 노드가 다운되면 <strong>데이터그램 방식</strong>은 다른 경로를 새로 설정하지만,<br>
<strong>가상회선 방식</strong>은 그 노드를 지나는 모든 가상회선을 잃게 된다.</p>
<p>[부족한 내용 업데이트 해야 함.]</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://gotwo.tistory.com/107" target="_blank" rel="noopener">데이터그램 패킷 교환 vs 가상회선 패킷 교환</a></li>
<li><a href="http://blog.naver.com/PostView.nhn?blogId=eronica&amp;logNo=40007289876" target="_blank" rel="noopener">참고할 예정 : 패킷교환방식인 데이터그램방식과 가상회선방식을 비교</a></li>
<li><a href="http://security-nanglam.tistory.com/179" target="_blank" rel="noopener">참고할 예정 : [데이터그램(Datagram) &amp;  가상회선(Virtual Circuit)]</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-Packet-Switching-Method/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/12/28/Network-UDP-TCP-Concept/"
                            aria-label=": [네트워크] UDP와 TCP"
                        >
                            [네트워크] UDP와 TCP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-12-28T15:14:42+09:00">
	
		    Dec 28, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>인터넷은 트랜스포트 계층에 연결형 프로토콜과 비연결형 프로토콜. 이렇게 두 개의 주된 프로토콜을 갖는다.</p>
<h2 id="udp"># UDP</h2>
<p>UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 <strong>비연결형</strong> 프로토콜이다. IP 데이터크램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.</p>
<p>UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.</p>
<p>UDP가 특별히 유용한 분야는 <code>클라이언트-서버 상황</code>이다. 종종 클라이언트는 서버로 짧은 요청을 보내고 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실되면, 클라이언트는 time-out되고 다시 시도할 수 있다. <strong>코드가 간단할 뿐만 아니라 TCP처럼 초기 설정에서 요구되는 프로토콜에서보다 적은 메시지가 요구된다.</strong></p>
<p><strong>UDP가 사용되는 분야</strong></p>
<ol>
<li>DNS<br>
어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.</li>
</ol>
<ol start="2">
<li>실시간 멀티미디어<br>
실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 패킷 형식으로 전송하는 <code>실시간 트랜스포트 프로토콜(RTP :: Real-time Transprot Protocol)</code>이 탄생했다.<br>
RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 <strong>멀티 플렉싱</strong>하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지들로 전송될 수 있다. RTP는 단지 UDP를 사용하기 때문에 전달, 지연, 손실 등에 대한 보장이 없다.<br>
[멀티플렉싱이 뭘까…?]</li>
</ol>
<p>이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 바로 전 패킷보다 <strong>하나 높은 번호가 주어진다.</strong> 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 분실되었는지 알 수 있게 한다. 만약 한 패킷이 없다면 이를 획득하기 위해 목적지에서의 최상의 동작은 보간(Interpolation)에 의해 손실한 값에 대한 근사치를 얻는 것이다.<br>
재전송은 재전송된 패킷이 유용하기에 너무 늦게 도착하므로 실용적인 옵션이 아니다. 그러므로 RTP는 확인 응답이 없고 재전송을 요청하는 메커니즘도 없다.</p>
<p>서로 다른 경로로 패킷을 처리함에도 순서를 부여하거나 재조립을 하거나 또는 흐름제어, 혼잡제어 등의 신뢰성 처리를 하지 않기 때문에 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성 있는 데이터의 전송을 보장하지 못한다는 단점도 존재한다.</p>
<h2 id="tcp"># TCP</h2>
<p>대부분의 인터넷 응용분야들은 <strong>신뢰성과 순차적인 전달</strong>을 필요로 한다. UDP로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 <code>TCP</code>이다.</p>
<p>TCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 <strong>신뢰성 있는 바이트 스트림</strong>을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 서비스를 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다.</p>
<p>또한, TCP는 연결형 프로토콜로 3-way-handshake 과정을 통해서 연결을 설정하고 4-way-handshake 과정을 통해서 연결을 해제[가상 회선 방식]한다. 흐름 제어 및 혼잡 제어를 통해 높은 <strong>신뢰성</strong>을 보장한다. 그러나 이러한 기능 때문에 UDP보다 속도가 느리다. 그리고 전송 순서를 보장하며 수신 여부를 확인할 수 있다.<br>
<strong>TCP는 연속성보다 신뢰성이 있는 전송이 중요할 때 사용하는 프로토콜이다.</strong><br>
하나의 연결을 설정하려면 한쪽(서버)은 listen과 accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 listen과 accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 다른 한 쪽(client)은 connect를 실행하고 목적지 IP 주소와 포트 번호, 수신 가능한 최대 TCP 세그먼트 크기 그리고 기타 사용자 데이터를 명시한다.</p>
<p><strong>1. TCP 연결방식</strong></p>
<p>모든 TCP 연결은 <strong>전이중(full-duplex), 점대점(point to point) 방식</strong>이다.<br>
전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며<br>
점대점이란 각 연결이 정확히 2개의 종단점을 가지고 있음을 의미한다.<br>
TCP는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다. 또한 메시지 스트림이 아니라 바이트 스트림의 형태를 갖는다. 메시지의 시작에서 끝까지 경계가 유지되지 않는다.</p>
<p><strong>2. TCP 특징</strong></p>
<ul>
<li>TCP 연결상의 모든 바이트가 고유의 32-비트 순서번호(sequence number)를 갖는다.</li>
<li>송수신 TCP 개체들은 세그먼트의 형태로서 데이터를 주고받는다. 한 세그먼트는 고정 2바이트 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다.</li>
<li>TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다.</li>
<li>세그먼트 크기에는 두 가지 제약요소가 있다.
<ul>
<li>모든 세그먼트들은 TCP 헤더를 포함하여 IP 수용량인 65,515 바이트를 넘을 수 없다는 것.</li>
<li>모든 네트워크는 정해진 **MTU(Maximum transfer Unit,최대 전송 단위)**를 갖는데 각 세그먼트는 이 MTU를 넘을 수 없다는 것.</li>
</ul>
</li>
<li>TCP는 IP와 함께 사용하는데 IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.</li>
<li>TCP는 신뢰성있는 데이터 전송을 지원하는 연결 지향형 프로토콜이다.</li>
<li>연결지향형인 TCP는 3-way-handshake 과정을 통해 연결 후 통신을 시작한다.</li>
<li>TCP에서 사용하는 포트 번호의 수는 0 ~ 65535(=2^16)이며, 총 65536개가 사용 가능하다.</li>
<li></li>
</ul>
<p>TCP 개체들에 의해 사용되는 기본 프로토콜은 동적으로 윈도우 크기를 조절할 수 있는 <strong>슬라이딩 윈도우(Sliding Window)프로토콜</strong>이다. 송신자는 한 세그먼트를 전송할 때, <strong>타이머를 구동</strong>시킨다. 그 세그먼트가 목적지에 도달하면 수신측 TCP 개체는 다음에 받으려고 하는 순서번호와 같은 응답 번호를 포함하는 세그먼트를 송신측으로 보낸다. 보낼 데이터가 있다면 그 데이터와 함께 보낸다.<br>
-Ex) 예를 들어, 송신측에 보낼 세그먼트가 3개 있고 번호는 1,2,3이라고 하자. 송신자는 1번 세그먼트를 수신측에 보낸다. 세그먼트가 목적지에 도달하면 수신측 TCP는 다음에 받으려고 하는 순서번호와 같은 확인 응답 번호 2를 포함하는 세그먼트를 송신측에 보낸다.</p>
<p>만일 확인 응답의 수신 전에 보낼 때 구동시킨 타이머가 종료되면 송신자는 그 세그먼트를 재전송한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 장치가 필요하며, 스트림 내의 각 바이트가 자기 고유의 <code>offset</code>을 가지고 있는데 이것을 장치로 한다.</p>
<p>TCP에서 <strong>흐름 제어</strong>는 가변크기의 <code>슬라이딩 윈도우</code>를 사용하여 처리된다. window size 필드는 확인 응답된 바이트에서 시작하여 얼마나 많은 바이트가 보내질 수 있는지를 나타낸다. 그러나 이 경우 좋지 않은 상황이 발생할 수 있다. 송신자는 응용프로그램에서 데이터가 올 때마다 전송할 필요가 없고 수신자도 마찬가지로 데이터를 받은 즉시 확인 응답을 해야 하는 것은 아니다.<br>
<strong>버퍼를 사용하면 되기 때문에 데이터를 모아서 보내거나 그것을 받고 애플리케이션에게 모아서 전달할 수 있는 것이다.</strong></p>
<p>인터렉티브 에디터<br>
네이글 알고리즘<br>
애플리케이션에서 수신된 데이터를 1바이트씩 가져가는 것<br>
3가지 추후 공부</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/12/28/Network-UDP-TCP-Concept/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/15/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/17/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 16 of 26</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
