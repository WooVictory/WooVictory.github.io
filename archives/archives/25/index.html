
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/25/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/06/08/BOJ11723/"
                            aria-label=": [11723] 집합"
                        >
                            [11723] 집합
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-06-08T14:35:26+09:00">
	
		    Jun 08, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>한 동안 졸업 작품과 다른 것들로 인해서 바빠서 알고리즘을 풀지 못했다… 이런 나를 반성하면서 다시 꾸준하게 알고리즘을 풀면서 공부해야겠다!!</p>
<h2 id="문제-httpswwwacmicpcnetproblem11723">문제 : <a href="https://www.acmicpc.net/problem/11723" target="_blank" rel="noopener">https://www.acmicpc.net/problem/11723</a></h2>
<p><code>Explain</code></p>
<p>비어있는 공집합 S가 있고, 문제에 나온 명령어가 주어졌을 때 명령어에 따라 연산을 진행한다.</p>
<blockquote>
<p>입력 : 첫 줄에 수행하는 연산의 수인 M이 주어진다. (1&lt;=M&lt;=3,000,000)</p>
</blockquote>
<blockquote>
<p>출력 : check 연산이 주어질 때마다, 출력한다.</p>
</blockquote>
<p><code>Key Points</code></p>
<p>간단하게 <code>비트 마스크</code>를 이용하여 문제를 풀어보았다. 비트 마스크를 이용하여 문제에 원하는 추가, 삭제, 검색 등을 구현할 수 있다.</p>
<p>문제에서 집합에 추가하는 수인 x의 범위가 1&lt;=x&lt;=20이다. 하지만, 비트 마스크는 0 ~ N-1 까지의 수를 저장하고 있기 때문에 문제를 풀기 위해서는 입력 받은 수 모두 1을 빼주어서 0 ~ 19 로 맞추고 문제를 풀면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ11723</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException, IOException </span>&#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 내가 배운 비트마스크는 0~N-1 까지의 수를 저장하고 있기 때문에</span></span><br><span class="line">		<span class="comment">// 이 문제를 풀기 위해서는 입력으로 받은 수를 모두 1을 빼주고 0~19로 만든 다음에 구현하면 된다.</span></span><br><span class="line">		<span class="comment">// 왜냐하면 문제에서 집합에 추가할 수 있는 x의 범위가 1~20이기 때문에 내가 배운 비트마스크의 범위인 0~N-1을 맞추기 위해서</span></span><br><span class="line">		<span class="comment">// 입력받은 집합에서 1씩 빼주어 0~19 사이의 범위로 맞춘다.</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>; <span class="comment">// 처음에 비어있는 집합 생성</span></span><br><span class="line">		<span class="keyword">int</span> M = Integer.parseInt(bf.readLine()); <span class="comment">// test_case</span></span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++) &#123;</span><br><span class="line">			StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">			String command = st.nextToken();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(command.equals(<span class="string">"add"</span>)) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">				x--;</span><br><span class="line">				s = s | (<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(command.equals(<span class="string">"remove"</span>)) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">				x--;</span><br><span class="line">				s = s &amp; ~(<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(command.equals(<span class="string">"check"</span>)) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">				x--;</span><br><span class="line">				<span class="keyword">int</span> tmp = s &amp; (<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">				<span class="keyword">if</span>(tmp !=<span class="number">0</span>) &#123;</span><br><span class="line">					sb.append(<span class="string">"1"</span>);</span><br><span class="line">					sb.append(<span class="string">"\n"</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					sb.append(<span class="string">"0"</span>);</span><br><span class="line">					sb.append(<span class="string">"\n"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(command.equals(<span class="string">"toggle"</span>)) &#123;</span><br><span class="line">				<span class="keyword">int</span> x = Integer.parseInt(st.nextToken());</span><br><span class="line">				x--;</span><br><span class="line">				s = s ^ (<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(command.equals(<span class="string">"all"</span>)) &#123;</span><br><span class="line">				s = (<span class="number">1</span>&lt;&lt;N) - <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(command.equals(<span class="string">"empty"</span>)) &#123;</span><br><span class="line">				s = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(sb.toString());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/06/08/BOJ11723/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/06/04/boostcourse2/"
                            aria-label=": [BoostCourse] 2. Event와 ListView"
                        >
                            [BoostCourse] 2. Event와 ListView
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-06-04T23:29:38+09:00">
	
		    Jun 04, 2018
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스크롤뷰-사용하기">스크롤뷰 사용하기</h1>
<hr>
<ol>
<li>테이블 레이아웃</li>
</ol>
<ul>
<li>격자 형태로 뷰를 배치할 때 사용한다.</li>
<li>TableLayout 안쪽에 TableRow를 넣으면 그것이 한 줄을 나타낸다.</li>
<li>각각의 줄(행)이 추가할 때는 TableRow 태그를 이용해서 추가하면 된다.</li>
<li>여러 개의 TableRow가 추가될 수 있고 각각의 TableRow 안에는 여러 개의 뷰가 들어갈 수 있는 구조로 되어 있다.</li>
<li>리니어 레이아웃 안에 리니어 레이아웃을 넣는 방식을 사용해도 격자 모양을 만들 수 있지만 테이블 레이아웃을 사용하면 좀 더 쉽게 만들 수 있다.</li>
<li>TableRow 태그 안에 있는 Button에 layout_column 속성을 이용해서 해당되는 칼럼의 인덱스에 위치시킬 수 있다.</li>
</ul>
<blockquote>
<p>stretchColumns란?</p>
</blockquote>
<p>TableRow에 Button과 같은 위젯을 추가하게 되면 각각이 칼럼이 된다. 그리고 0,1,2 이렇게 번호를 가지고 추가가 된다. 하지만, 이렇게 되면 오른쪽에 공간이 남게 되기 때문에 이 공간을 버튼 3개가 꽉 차게 가지고 싶다면??</p>
<p>stretchColumns라는 속성을 사용하면 된다. 콤마로 구분하게 되는 0,1,2 이렇게 값을 넣어주면 0,1,2가 남아있는 여유 공간을 다 차지하도록 해준다.<br>
즉, 0,1,2 세개의 칼럼이 추가가 되는데, 그거를 전부 다 가로를 꽉 채워달라는 의미</p>
<ol start="2">
<li>스크롤뷰(ScrollView)</li>
</ol>
<ul>
<li>글자나 이미지가 들어간 뷰가 화면 영역을 벗어나면 보이지 않게 된다.</li>
<li>이 때는 손가락으로 스크롤 하여 보이지 않는 부분을 보이도록 만들어주어야 한다.</li>
<li><code>ScrollView</code>는 이런 스크롤 기능을 쉽게 만들 수 있도록 도와준다.</li>
<li><strong>ImageView</strong>나 <strong>TextView</strong>등의 뷰를 <code>ScrollView</code>로 감싸주면 ScrollView가 뷰의 영역을 계산하게 된다. 그리고 화면에 보이는 공간을 넘어갔을 때 자동으로 스크롤을 만들어 준다.</li>
<li>ScrollView의 속성으로 상,하 스크롤을 할 것인지 좌,우 스크롤을 할 지 설정할 수 있다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/06/04/boostcourse2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/19/sopt-seminar5/"
                            aria-label=": [SOPT] Seminar5"
                        >
                            [SOPT] Seminar5
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-19T14:22:15+09:00">
	
		    May 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Inno-SOPT/">Inno_SOPT</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스플래쉬-폰트-아이콘">스플래쉬 + 폰트 + 아이콘</h1>
<hr>
<ol>
<li><code>스플래쉬(Splash)</code></li>
</ol>
<p><img src="/img/splash.png" alt=""></p>
<ul>
<li>백그라운드에 있지 않은 어플리케이션을 실행했을 때 <strong>맨 처음 나오는 화면</strong><br>
(보통은 로그인 하기 전에 나오는 화면)을 말한다.</li>
<li>사용자로 하여금 앱이 실행되고 있음을 보여준다.</li>
<li>로그인 전에 <strong>서버와 통신해야 할 부분이나 기타 처리할 데이터가 있으면 이 화면에서 처리</strong>한다.</li>
</ul>
<ol start="2">
<li><code>폰트</code></li>
</ol>
<ul>
<li>외부 폰트를 안드로이드 스튜디오 내에서 사용할 수 있도록 xml로 작성한다.</li>
<li>res -&gt; new -&gt; Android Resource Directroy에서 font를 추가</li>
<li>사용할 폰트를 font 폴더에 추가한다.</li>
<li>그리고 추가한 폰트를 사용하는 xml 파일을 작성한다.</li>
<li>그리고 layout xml 파일에서 사용할 폰트 xml 파일을 적용한다.</li>
</ul>
<ol start="3">
<li><code>아이콘</code></li>
</ol>
<p><em>우리가 사용하는 앱의 아이콘은 어떻게 설정할까요??</em></p>
<ul>
<li>그렇게 어렵지 않습니다.</li>
<li>res -&gt; mimmap -&gt; new -&gt; Image Asset에서 새로운 아이콘 이미지 추가<br>
<strong>Path</strong>에서 사용하고 싶은 이미지를 불러오고 적용 시키면 끝!!</li>
</ul>
<h1 id="화면의-이해">화면의 이해</h1>
<hr>
<ol>
<li><strong>해상도</strong> : 하나의 이미지를 표혀하는데 몇 개의 픽셀(pixel) 또는 도트(dot)로 나타내는 지의 정도를 알려주는 지표</li>
</ol>
<ul>
<li>안드로이드 운영체제를 가진 <strong>device</strong>는 다양한 종류가 존재한다. 즉 너무나도 다양한 해상도가 존재하는 것이다. 이처럼 다양한 해상도를 가진 device에 뷰를 맞춰서 개발하는 것은 힘든 일이다.</li>
<li>이와 같은 문제를 잘 해결하기 위해서 다음에서 설명하는 개념들을 잘 알고 있어야 한다.</li>
</ul>
<ol start="2">
<li><code>픽셀의 이해</code></li>
</ol>
<ul>
<li>픽셀은 <strong>고정값</strong>이다.</li>
<li>그래서 크기가 변한다.</li>
<li>값은 고정이지만 해상도별로 달라보이는 문제가 발생한다.</li>
<li>그래서 값은 고정이어도 크기는 <strong>변한다</strong>.</li>
<li>그래서 픽셀로는 화면에 대응하기가 힘들다.</li>
<li>픽셀 : 기기 대응이 힘들다.</li>
</ul>
<ol start="3">
<li><code>DP</code></li>
</ol>
<ul>
<li>dp는 디바이스에 따라 값이 변한다.</li>
<li>그래서 크기가 고정된다.</li>
<li>기기 해상도에 따라 네모 사이즈가 <strong>같아</strong>보인다.<br>
(디바이스 해상도에 따라 크기의 사이즈가 조정되었기 때문)</li>
<li>그래서 device는 달라도 크기는 <strong>고정된다</strong>.</li>
<li><strong>이 때문에 디자이너가 여러 dp에 대응하게끔 이미지를 준다</strong>.</li>
</ul>
<blockquote>
<p>문제</p>
</blockquote>
<ul>
<li><strong>같은 dp</strong>라 할지라도 화면 너비, 높이에 따라 <strong>차지하는 정도는 달라질 수 있다</strong>.즉, <code>여백 문제</code>가 발생함</li>
<li><strong>크기 중심</strong>으로 갈 지 <strong>여백 중심</strong>으로 갈 지 잘 판단해야 한다.</li>
<li>우선적으로는 사용할 <strong>대표 기기</strong>를 선정하는 것이 그나마 수치의 오차를 줄일 수 있는 방법</li>
<li>사실상, 가장 확실한 방법은 기기마다 레이아웃을 짜는 것이지만, 쉽지는 않다.</li>
</ul>
<ol start="4">
<li><code>SP</code></li>
</ol>
<ul>
<li><strong>글자</strong>에 많이 쓰이는 사이즈 단위</li>
<li>글자가 가지는 고유의 사이즈에 <code>비례</code>해서 크기가 변하는 것</li>
<li>기본 원리는 <strong>dp와 유사</strong></li>
<li>사용자가 설정한 <strong>글꼴에 따라 호환</strong>되어 사이즈 조정</li>
</ul>
<h1 id="디자이너와-협동하기">디자이너와 협동하기</h1>
<hr>
<blockquote>
<p>방법</p>
</blockquote>
<ol>
<li>서로가 고생하기</li>
</ol>
<p>디자이너는 모든 기기에 대한 디자인을 만든다<br>
개발자는 모든 기기에 대한 레이아웃을 짠다.</p>
<p><em>가능할까?</em><br>
Build 클래스를 통해 기기 분류가 가능하다. 가장 정확한 방법이지만, <strong>SOPT</strong>에서 진행하는 2주간의 <code>App Jam</code>에서는 시간이 부족하고 불가능한 방법이다.</p>
<ol start="2">
<li>적당히 타협하기</li>
</ol>
<ul>
<li><strong>중요도</strong>를 묻는다.<br>
– <strong>뷰 자체의 크기</strong>가 중요하면 뷰 위주로 값을 넣을 것<br>
– <strong>배치 및 공간</strong>이 중요하면 여백 위주로 값을 넣을 것</li>
<li>기기들의 태생적 <strong>한계</strong>를 공유한다.<br>
– 기기가 너무 다양한 나머지 디자인적인 <strong>차이와 한계</strong>가 존재한다.<br>
– 디자이너가 <strong>기준</strong>으로 정한 기기 이외의 기기들과는 보이는 모습이 조금 <strong>달라 질 수 있음</strong>을 충분히 인지시키자.</li>
<li><strong>수치</strong>를 최대한 자세하게 요구한다.<br>
– 길이든 색상이든 일단 <strong>최대한 빈틈없이</strong> 알려달라 할 것<br>
– 수치를 보면 <strong>무엇이 중요</strong>한지(자체 크기, 공간) 어느정도 판단 가능</li>
<li>이미지 이름은 꼭 <code>소문자, 밑줄(_) 그리고 숫자 조합</code>지어달라 한다.</li>
</ul>
<h1 id="과제">과제</h1>
<ul>
<li>세미나 시간 동안 디자이너와 협업한 View 완성하기(SeekBar 사용)</li>
<li>참고 : 기능은 구현하지 않고 View 만 구현하였습니다.</li>
</ul>
<p><code>Github</code> : <a href="https://github.com/WooVictory/SOPT_22th_Seminar5_HomeWork" target="_blank" rel="noopener">https://github.com/WooVictory/SOPT_22th_Seminar5_HomeWork</a></p>
<ul>
<li>다른 뮤직 플레이어 (Progressbar Wheel 사용)</li>
</ul>
<p><code>Github</code> : <a href="https://github.com/WooVictory/SOPT_22th_Seminar5_Preview" target="_blank" rel="noopener">https://github.com/WooVictory/SOPT_22th_Seminar5_Preview</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/19/sopt-seminar5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/19/BOJ9025/"
                            aria-label=": [9025] 맥주 마시며 걸어가기"
                        >
                            [9025] 맥주 마시며 걸어가기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-19T00:39:21+09:00">
	
		    May 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/9025" target="_blank" rel="noopener">https://www.acmicpc.net/problem/9025</a></p>
<hr>
<p><code>Key Points</code></p>
<p>편의점의 위치가 상근이네 집 즉 출발점과 가까운 위치에 있는 것이 아니라 일일히 확인해봐야 한다.<br>
그 말은 모든 경우를 다 해봐야 하는 것이다. 즉, <code>BFS</code>로 문제를 접근해서 풀어야 한다.</p>
<p><code>Explain</code></p>
<ol>
<li>시작위치, 편의점위치, 도착지의 좌표 모두 클래스 배열인 location[]에 넣어준다.</li>
<li>시작위치로부터 출발한다. (큐에 넣어준다.)</li>
<li>출발하여 location[] 클래스 배열 안에 있는 조건에 맞는 좌표를 방문한다.</li>
<li>조건은 출발위치로부터 다음 위치의 차이가 1000이하이고, 방문하지 않은 점이어야 한다.</li>
<li>페스티벌 위치 즉 도착지와 계속 비교하면서 페스티벌 위치라면 즉시 boolean success를 true로 변경하고 빠져나온다.</li>
<li>boolean success에 따라 결과를 출력하면 된다.</li>
</ol>
<p><code>Code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Exam9205 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws NumberFormatException, IOException &#123;</span><br><span class="line">		// 모든 경우를 다 해보는 BFS 문제</span><br><span class="line"></span><br><span class="line">		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">		int test_case = Integer.parseInt(bf.readLine());</span><br><span class="line">		// 테스크 케이스 입력</span><br><span class="line"></span><br><span class="line">		for(int i=0;i&lt;test_case;i++) &#123;</span><br><span class="line">			int N = Integer.parseInt(bf.readLine());</span><br><span class="line">			LOCATION[] location = new LOCATION[N+2]; // 모든 위치의 좌표를 저장하기 위한 클래스 배열</span><br><span class="line">			int[] check = new int[N+2]; // 방문했는지 안했는지 확인하기 위한 배열</span><br><span class="line">			Queue&lt;LOCATION&gt; q = new LinkedList&lt;LOCATION&gt;();</span><br><span class="line">			boolean success = false; // 도착지에 도달하면 true로 바꾼다.</span><br><span class="line">			</span><br><span class="line">			for(int j=0;j&lt;N+2;j++) &#123;</span><br><span class="line">				StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;);</span><br><span class="line">				location[j] = new LOCATION(Integer.parseInt(st.nextToken())</span><br><span class="line">						,Integer.parseInt(st.nextToken()));</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			// 입력 끝</span><br><span class="line">			LOCATION start = location[0]; // 출발지점</span><br><span class="line">			LOCATION end = location[N+1]; // 도착지점</span><br><span class="line">			</span><br><span class="line">			q.add(start); // 큐에 넣는다. </span><br><span class="line">			</span><br><span class="line">			while(!q.isEmpty()) &#123;</span><br><span class="line">				LOCATION current = q.poll(); // 삭제하면서 원소를 뺀다.</span><br><span class="line">				if(current.equals(end)) &#123; // 도착지점에 도착하면 success를 true로 바꾸고 탈출</span><br><span class="line">					success = true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				for(int j=1;j&lt;N+2;j++) &#123;</span><br><span class="line">					if(check[j] == 0 &amp;&amp; Math.abs(current.x - location[j].x) + </span><br><span class="line">							Math.abs(current.y - location[j].y) &lt;=1000) &#123;</span><br><span class="line">								// 조건 : 방문하지 않았고, 좌표의 차이가 1000이하인 것들만 큐에 저장한다.</span><br><span class="line">						q.add(location[j]); // 큐에 넣는다.</span><br><span class="line">						check[j] = 1; // 방문했음을 표시</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if(success)</span><br><span class="line">				System.out.println(&quot;happy&quot;);</span><br><span class="line">			else</span><br><span class="line">				System.out.println(&quot;sad&quot;);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 좌표를 저장하는 클래스 배열</span><br><span class="line">class LOCATION&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	</span><br><span class="line">	LOCATION(int x, int y)&#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/19/BOJ9025/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/19/BOJ2407/"
                            aria-label=": [2407] 조합"
                        >
                            [2407] 조합
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-19T00:07:07+09:00">
	
		    May 19, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="문제-httpswwwacmicpcnetproblem2407">문제 : <a href="https://www.acmicpc.net/problem/2407" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2407</a></h2>
<p><code>Key Points</code></p>
<p>이 문제를 풀기 위해서는 먼저 <strong>순열과 조합</strong>의 개념에 대해 알고 있어야 한다.</p>
<ul>
<li>순서가 있는 경우 : 순열(Permutation) [서로 다른 n 개 중 r 개를 뽑아서 나열하는 경우]</li>
<li>순서가 없는 경우 : 조합(Combination) [서로 다른 n 개 중 r 개를 뽑는 경우]</li>
</ul>
<p>아래와 같은 방법으로 계산한다.<br>
<img src="/img/combination.png" alt=""></p>
<p><img src="/img/com2.png" alt=""></p>
<p>이 문제는 <strong>메모이제이션</strong>이라는 방법을 이용하여 조합의 공식에 따라서 구했다.</p>
<p><code>Explain</code></p>
<p><code>Memoization</code>(메모이제이션)은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 <strong>저장</strong>함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 <strong>실행 속도를 빠르게</strong>하는 기술이다. <strong>동적 계획법의 핵심</strong>이 되는 기술이다.</p>
<p><strong>메모이제이션</strong>을 이용하면 조합의 값을 구하기 위해 파스칼 삼각형의 꼭대기까지 올라갈 필요 없이 바로 좌우측 상단의 값을 메모리에서 불러와 이용할 수 있다.</p>
<p><code>Code</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Exam2407 &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		BigInteger[][] list;</span><br><span class="line">		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">		BigInteger big = new BigInteger(&quot;1&quot;);</span><br><span class="line">		</span><br><span class="line">		StringTokenizer st = new StringTokenizer(bf.readLine(), &quot; &quot;);</span><br><span class="line">		int n = Integer.parseInt(st.nextToken());</span><br><span class="line">		int m = Integer.parseInt(st.nextToken());</span><br><span class="line">		</span><br><span class="line">		list = new BigInteger[10001][10001];</span><br><span class="line">		list[1][0] = list[1][1] = big;</span><br><span class="line">		</span><br><span class="line">		for(int i=2;i&lt;=n;i++) &#123;</span><br><span class="line">			for(int j=0;j&lt;=i;j++) &#123;</span><br><span class="line">				if(i == j || j == 0) &#123;</span><br><span class="line">					list[i][j] = big;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					list[i][j] = list[i-1][j-1].add(list[i-1][j]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(list[n][m]);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/19/BOJ2407/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/18/BOJ14501/"
                            aria-label=": [14501] 퇴사"
                        >
                            [14501] 퇴사
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-18T23:06:58+09:00">
	
		    May 18, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>문제 : <a href="https://www.acmicpc.net/problem/14501" target="_blank" rel="noopener">https://www.acmicpc.net/problem/14501</a></p>
<p><code>Key Points</code></p>
<p><img src="/img/14501.png" alt=""></p>
<p>위의 상담 일정표에서 확인 할 수 있듯이 힌트를 얻을 수 있다. 백준이는 오늘로부터 N+1일째 되는 날 퇴사를 한다. 그래서 남은 N일 동안 최대한 많은 상담을 하려 한다.<br>
<strong>1일에 상담을 하게 되면</strong>, <strong>2일, 3일에 있는 상담은 할 수 없게 된다.</strong><br>
마찬가지로 2일에 있는 상담을 하게 되면, 3,4,5,6일에 잡혀있는 상담을 할 수 없게 된다.</p>
<p><code>Explain</code></p>
<p>문제를 위한 점화식을 도출해보자.<br>
<code>dp[N] = N일까지 얻는 이익</code> 이라 하자.<br>
N일을 기준으로 N일 이전에 이익을 얻을 수 있는 경우를 모두 비교하면 된다.</p>
<p>dp[5] = Max(5일의 이익 + 1일까지의 이익, 5일까지의 이익)<br>
dp[5] = Max(5일의 이익 + 2일까지의 이익, 5일까지의 이익)<br>
dp[5] = Max(5일의 이익 + 3일까지의 이익, 5일까지의 이익)<br>
dp[5] = Max(5일의 이익 + 4일까지의 이익, 5일까지의 이익)</p>
<p>위와 같이 dp 배열의 값을 문제의 조건을 성립시켜 가면서 갱신해 나간다.</p>
<p><code>Code</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam14501</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException, IOException </span>&#123;</span><br><span class="line">		</span><br><span class="line">		BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">		<span class="keyword">int</span> N = Integer.parseInt(bf.readLine());</span><br><span class="line">		<span class="comment">// test_case 입력 받는다.</span></span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">// 최대값</span></span><br><span class="line">		<span class="keyword">int</span>[] T = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>]; <span class="comment">// 상담하는데 걸리는 기간 T</span></span><br><span class="line">		<span class="keyword">int</span>[] P = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>]; <span class="comment">// 상담하는데 드는 비용 P</span></span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>]; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">			StringTokenizer st = <span class="keyword">new</span> StringTokenizer(bf.readLine(), <span class="string">" "</span>);</span><br><span class="line">			T[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">			P[i] = Integer.parseInt(st.nextToken());</span><br><span class="line">			dp[i] = P[i];</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// dp[N] = N일때까지 얻은 이익</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 처음 상담은 두 번째 for문에서 등장함.</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i-j &gt;=T[j]) &#123; <span class="comment">// 처음 상담 기간을 지나고 계속해서 갱신하기 위함</span></span><br><span class="line">					dp[i] = Math.max(P[i]+dp[j], dp[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// dp 배열이 갱신된다.</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 갱신된 배열을 가지고 max 값을 찾는다.</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i+T[i]&lt;=N+<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(max&lt;dp[i]) &#123;</span><br><span class="line">					max = dp[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(max);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/18/BOJ14501/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/17/network/"
                            aria-label=": 네트워크 :: 네트워크?"
                        >
                            네트워크 :: 네트워크?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-17T23:09:03+09:00">
	
		    May 17, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/네트워크/">네트워크</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="http-소개">HTTP 소개</h1>
<hr>
<h2 id="http란">HTTP란??</h2>
<p>HyperText Transfer Protocol의 약자로 하이퍼 텍스트 문서를 교환하기 위하여 사용된 <strong>통신 규약</strong>이다. 즉, <strong>Web Server</strong>와 <strong>Web Client</strong> 간의 통신을 하기 위한 통신 규약이다. <strong>HTTP</strong>는 1989년 팀 버너스-리에 의해 처음 설계되어 인터넷을 통한 <strong>월드 와이드 웹</strong><code>(WWW)</code>기반에서 전 세계적인 <code>정보 공유</code>를 이루는데 큰 역할을 하였다.<br>
<strong>HTTP</strong>는 웹에서만 사용하는 프로토콜로 <strong>TCP/IP</strong> 기반으로 한 지점에서 다른 지점(서버와 클라이언트)으로 <strong>요청</strong>과 <strong>응답</strong>을 전송한다.</p>
<h2 id="http-특징">HTTP 특징</h2>
<ul>
<li>HTTP 메시지는 HTTP 서버와 HTTP 클라이언트에 의해서 해석이 된다.</li>
<li><code>TCP/IP</code>를 이용하는 응용 프로토콜</li>
<li>HTTP는 연결 상태를 <strong>유지하지 않는</strong> 비연결성 프로토콜 (이러한 <strong>단점</strong>을 해결하기 위해 <code>Cookei</code>와 <code>Seesing</code>등장)</li>
<li>HTTP는 연결을 유지하지 않는 프로토콜이기 때문에 <code>요청(request)/응답(response)</code> 방식으로 동작한다.</li>
</ul>
<h2 id="동작">동작</h2>
<p><img src="/img/http.png" alt=""></p>
<p>예를들면, 클라이언트(client) 즉, 사용자가 브라우저를 통해서 어떠한 서비스를 url을 통하거나 다른 것을 통해서 <strong>요청</strong>(request)을 하면 서버에서는 해당 요청사항에 맞는 결과를 찾아서 사용자에게 <strong>응답</strong>(response)하는 형태로 동작합니다</p>
<ul>
<li>요청 : client -&gt; server</li>
<li>응답 : server -&gt; client</li>
</ul>
<p>HTML 문서만이 HTTP 통신을 위한 유일한 정보 문서는 아니다 Plain text로부터 JSON 데이터 및 XML과 같은 형태의 정보도 주고 받을 수 있으며, 보통은 client가 어떤 정보를 HTML 형태로 받고 싶은지, JSON 형태로 받고 싶은지 명시해주는 경우가 많다.</p>
<h2 id="http의-get과-post-비교">HTTP의 GET과 POST 비교</h2>
<p>둘 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 <strong>요청</strong>할 때 사용하는 방식이다. 하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용할 수 있도록 알아보자.</p>
<ul>
<li><code>GET</code></li>
</ul>
<p>우선 <code>GET 방식</code>은 요청하는 데이터가 <strong>HTTP Request Message</strong>의 <code>Header</code> 부분의 url에 담겨서 전송된다. 때문에 url 상에 <strong>?</strong> 뒤에 데이터가 붙어 request를 보내게 되는 것이다. 이러한 방식은 url이라는 공간에 담겨가기 때문에 전송할 수 있는 <strong>데이터의 크기가 제한적</strong>이다. 또 <code>보안</code>이 필요한 데이터에 대해서는 데이터가 그대로 <strong>노출</strong>되므로 GET 방식은 적절하지 한다.(ex. password)</p>
<ul>
<li><code>POST</code></li>
</ul>
<p><code>POST 방식</code>의 request는 <strong>HTTP Message의 Body</strong> 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 <code>보안</code>면에서 낫다. (하지만 보안적인 측면에서는 암호화를 하지 않는다면 고만고만하다…^^)</p>
<p>우선 <code>GET</code>은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여주는 용도이지 서버의 값이나 상태 등을 변경하지 않는다.  <strong>SELECT</strong>적인 성향을 가지고 있다고 볼 수 있다. 반면에 <code>POST</code>는 서버의 값이나 상태를 <strong>변경</strong>하기 위해서 또는 <strong>추가</strong>하기 위해서 사용된다.</p>
<p>부수적인 차이점을 좀 더 살펴보면 <code>GET</code> 방식의 요청은 브라우제에서 <strong>Caching</strong>할 수 있다. 때문에 <code>POST</code> 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 Caching 되었던 데이터가 요청될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.</p>
<h1 id="tcp-3-way-handshake-amp-4-way-handshake">TCP 3-way-handshake &amp; 4-way-handshake</h1>
<ul>
<li>연결 성립(Connection Establishment)</li>
</ul>
<p><img src="/img/3way.png" alt=""></p>
<ol>
<li>client는 server에 접속을 요청하는 <code>SYN(a)</code>을 보낸다.</li>
<li>server는 client의 요청인 <code>SYN(a)</code>을 받고 client에게 요청을 수락한다는 <code>ACK(a+1)</code>와 <code>SYN(b)</code>이 설정된 패킷을 발송한다.</li>
<li>client는 server의 수락 응답인 <code>ACK(a+1)</code>와 <code>SYN(b)</code> 패킷을 받고 <code>ACK(b+1)</code>를 server로 보내면 연결이 <strong>성립</strong>(establish)된다.</li>
</ol>
<ul>
<li>연결 해제(Connection Termination)</li>
</ul>
<p><img src="/img/4way.png" alt=""></p>
<ol>
<li>client가 연결을 종료하겠다는 <strong>FIN 플래그</strong>를 전송한다.</li>
<li>server는 client의 요청(FIN)을 받고 알겠다는 확인 메시지로 <strong>ACK</strong>를 보낸다.<br>
2-1. 그리고 나서는 데이터를 모두 보낼 때까지 잠깐 <strong>TIME_OUT</strong>이 된다.</li>
<li>데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 client에게 <strong>FIN 플래그</strong>를 전송한다.</li>
<li>client는 <strong>FIN 메시지</strong>를 확인했다는 **메시지(ACK)**를 보낸다.</li>
<li>client의 <strong>ACK 메시지</strong>를 받은 server는 소켓 <strong>연결을 close</strong>한다.</li>
<li>client는 아직 server로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 <strong>세션</strong>을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (<strong>TIME_WAIT</strong>)</li>
</ol>
<blockquote>
<p>SYN : synchronize sequence number<br>
ACK : acknowledgement</p>
</blockquote>
<p><strong>TCP header</strong>에는 <strong>Code Bit</strong>(Flag bit)라는 부분이 존재한다. 이 부분은 총 <strong>6bit</strong>로 이루어져 있으며 각각 한 bit들이 의미를 가지고 있다. <code>Urg-Ack-Psh-Rst-Syn-Fin</code> 순서로 되어 있으며 해당 위치의 비트가 1이면 해당 패킷이 어떠한 내용을 담고 있는 패킷이닞를 나타낸다. SYN 패킷일 경우에는 000010이 되고, ACK 패킷일 경우에는 010000이 되는 것이다.</p>
<blockquote>
<p>Why tow types of packets?</p>
</blockquote>
<p>일단 연결을 성립하려면 서로 통신이 가능한지를 먼저 파악하기 위해 패킷을 먼저 주고 받아야 한다는 것까지 이해가 되었다. 그런데 두 종류의 패킷을 주고 받는 다는 것은 <strong>요청</strong>과 <strong>응답</strong>에 대한 패킷을 주고 받아야 하기 때문에 두 종류인 것이다.</p>
<p>client가 자신의 목소리가 들리는지 물어본다.(SYN) server는 client의 목소리가 들린다고 말한다.(SYN+1) 그리고 자신(server)의 목소리가 들리는지 물어본다. (ACK) client는 server의 목소리가 들린다고 말한다. (ACK+1) 이런 과정인 셈이다. <strong>TCP Connection</strong>은 <code>양방향성 connection</code>이다. client에서 server의 존재를 알리고 패킷을 보낼 수 있다는 것을 알리듯, server에서도 client에게 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 한다. 그렇기 때문에 2-way-handshake로는 부족하고 3-way-handshake를 사용해야 한다.</p>
<blockquote>
<p>Why randomized sequence number?</p>
</blockquote>
<p>처음 client에서 SYN 패킷을 보낼 때 Sequence Number에는 랜덤한 숫자가 담겨진다. 초기 sequence number ISN이라고 한다.</p>
<blockquote>
<p>ISN이 0부터 시작하지 않고 난수를 생성해서 number를 설정하는 이유는 무엇일까???</p>
</blockquote>
<p>그에 대한 해답은 여기서 확인할 수 있다.<br>
Connection을 맺을 때 사용하는 포트(port)는 유한 범위 내에서 사용하고 시간이 지남에 따라 <strong>재사용</strong>된다. 따라서 두 통신 호스트가 <strong>과거에 사용된 포트 번호 쌍</strong>을 <strong>사용하는 가능성이 존재</strong>한다. server 측에서는 패킷의 SYN을 보고 패킷을 구분하게 되는데 난수가 아닌 순차적인 number가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있는 문제가 생긴다. 이러한 문제가 발생할 가능성을 줄이기 위해 <code>난수</code>로 <strong>ISN</strong>을 설정하는 것이다.</p>
<h1 id="tcp-vs-udp">TCP vs UDP</h1>
<blockquote>
<p>인터넷은 Transport 계층에 연결형 프로토콜과 비연결형 프로토콜 두 개의 주된 프로토콜을 갖는다.</p>
</blockquote>
<ol>
<li><code>UDP</code><br>
UDP(<strong>User Datagram Protocol</strong>)는 <strong>비연결형</strong> 프로토콜이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다.<br>
또한, UDP는 <strong>흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다</strong>. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.</li>
</ol>
<p>UDP가 특별히 유용한 분야는 <strong>Client-Server</strong> 상황이다. 종종 client는 server로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, client는 time out 되고 다시 시도할 수 있다. <strong>코드가 간단</strong>할 뿐만 아니라 TCP처럼 초기설정에서 요구되는 프로토콜에서보다 적은 메시지가 요구된다.</p>
<p>UDP를 사용한 것들에는 <code>DNS</code>가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. <strong>사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.</strong></p>
<p>UDP가 사용되는 또 다른 분야로는 <strong>실시간 멀티미디어</strong>가 있다. 실시간 멀티미디어의 응용이 많아지면서 오디오와 비디오 데이터 패킷 형식으로 전송하는 <strong>실시간 트랜스포트 프로토콜</strong> <code>(RTP : Real-time Transport Protocol)</code>이 탄생했다. RTP의 기본 기능은 UDP 패킷의 단일 스트림으로 몇몇 실시간 데이터 스트림을 <strong>멀티플렉싱</strong>하는 것이다. UDP 스트림은 단일 목적지 또는 다중 목적지로 전송될 수 있다. RTP는 단지 일반적인 UDP를 사용하기 때문에 전달, 지연, 손실 등에 대한 특별한 보장이 없다.</p>
<p>이런 점들을 보완하기 위한 몇 가지 장치들이 존재한다. RTP 스트림에서 보내지는 각 패킷은 바로 전 패킷보다 <strong>하나 높은 번호</strong>가 주어진다. 이런 번호 부여 방식은 목적지로 하여금 어느 패킷이 <strong>분실되었는지</strong> 알 수 있게 한다. 만약 한 패킷이 없다면 이를 획득하기 위해 목적지에서의 최상의 동작은 <strong>보간</strong>(Interpolation)에 의해 손실한 값에 대한 근사치를 얻는 것이다. 재전송은 재전송된 패킷이 유용하기에 너무 늦게 도착하므로 실용적인 옵션이 아니다. 그러므로 <strong>RTP</strong>는 확인 응답이 없고 재전송을 요청하는 매커니즘도 없다.</p>
<ol start="2">
<li><code>TCP</code></li>
</ol>
<blockquote>
<p>대부분의 인터넷 응용분야들은 <code>신뢰성</code>과 <code>순차적인 전달</code>을 필요로 한다. UDP로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 <strong>TCP</strong>이다.</p>
</blockquote>
<p><code>TCP(Transmission Control Protocol)</code>는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 <strong>바이트 스트림</strong>을 전송하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 <strong>소켓</strong>이라고 부르는 종단점을 생성함으로써 이루어진다. 각 소켓은 호스트의 IP 주소와 그 호스트에 국한된 16비트로 구성된 포트라고 불리는 소켓 번호를 갖는다. TCP 서비스를 하기 위해서는 송신측 소켓과 수신측 소켓이 연결되어 있어야 한다.</p>
<p>모든 TCP 연결은 <code>전이중(full-duplex)</code>, <code>점대점(point to point)</code> 방식이다.<br>
전이중이란 전송이 <strong>양방향으로 동시</strong>에 일어날 수 있음을 의미하며 점대점이란 각 연결이 <strong>정확히 2개의 종단점</strong>을 가지고 있음을 의미한다. <code>TCP</code>는 <strong>멀티 캐스팅</strong>이나 <strong>브로드 캐스팅</strong>을 <code>지원하지 않는다</code>. 또한 메시지 스트림이 아니라 <strong>바이트 스트림</strong>의 형태를 갖는다. 메시지의 시작에서 끝까지의 경계가 유지되지 않는다.</p>
<p>TCP의 <code>특징</code>은 TCP 연결상의 모든 바이트가 고유의 <strong>32-비트 순서번호</strong>(<strong>sequence nunmber</strong>)를 갖는다는 것이다. 송수신 TCP 개체들은 <strong>세그먼트</strong>의 형태로서 데이터를 주고 받는다. 한 세그먼트는 고정 2바이트 헤더와 그 뒤를 따르는 0개 이상의 데이터 바이트들로 구성된다. TCP 소프트웨어는 세그먼트가 얼마나 커야 하는지를 결정한다. 세그먼트 크기에는 두 가지 <code>제약요소</code>가 있다. 한 가지는 모든 세그먼트들은 <strong>TCP 헤더를 포함하여 IP 수용량인 65,515바이트를 넘을 수 없다</strong>는 것이며 나머지 하나는 모든 네트워크는 정해진 MTU(Maximum transfer Unit, 최대 전송 단위)를 갖는데 각 세그먼트는 <strong>MTU를 넘을 수 없다</strong>는 것이다.</p>
<p>TCP 개체들에 의해 사용되는 기본 프로토콜은 <strong>동적</strong>으로 윈도우 크기를 조절하는 <code>슬라이딩 윈도우(sliding window)프로토콜</code>이다. 송신자는 한 세그먼트를 전송할 때, <strong>타이머를 구동</strong>시킨다. 그 세그먼트가 목적지에 도달하면, 수신측 TCP 개체는 <strong>다음에 받으려고 하는 순서번호와 같은 확인 응답 번호를 포함</strong>하는 <strong>세그먼트</strong>를 송신측으로 보낸다. 보낼 데이터가 있다면 그 데이터와 함께 보낸다.<br>
만일 확인 응답의 수신 전에 보낼 때 구동시킨 타이머가 종료되면 송신자는 그 세그먼트를 <strong>재전송</strong>한다. 세그먼트들이 순서가 뒤바뀐 상태로 도착할 수 있으며, 재전송 경우에 대해 올바르게 수신된 상태인지를 알 수 있도록 하는 장치가 필요하다. 스트림 내의 각 바이트가 자기 고유의 <code>offset</code>을 가지고 있는 것을 그 장치로 한다.</p>
<p>TCP에서 <code>연결 설정(connection establishment)</code>는 <code>3-way-handshake</code>를 통해 행해진다. 하나의 연결을 설정하려면 한쪽(서버)은 listen과 accept를 실행함으로써 연결 요청을 수동적으로 기다린다. 이 listen과 accept는 특정 근원지를 명시할 수도 있고 하지 않을 수도 있다. 다른 한쪽(client)은 <strong>connect</strong>를 실행하고 목적지 IP 주소와 포트, 수신 가능한 최대 TCP 세그먼트 크기 그리고 기타 사용자 데이터를 명시한다.</p>
<p>TCP에서 <code>흐름제어</code>는 가변 크기의 <strong>슬라이딩 윈도우</strong>를 사용하여 처리된다. window size 필드는 확인 응답된 바이트에서 시작하여 얼마나 많은 바이트가 보내질 수 있는지를 나타낸다. 그러나 이 경우 좋지 않은 상황이 발생할 수 있다. 송신자는 응용 프로그램에서 데이터가 올 때마다 전송할 필요가 없고 수신자도 마찬가지로 데이터를 받은 즉시 확인 응답을 해야 하는 것이 아니다. <strong>버퍼</strong>를 사용하면 되기 때문에 데이터를 모아서 보내거나 그것을 받고 애플리케이션에서 모아서 전달할 수 있는 것이다.</p>
<p><em>각 키보드 입력마다 즉시 반응해야 하는 '인터렉티브 에디터(Interactive Editor)라면 어떨까??</em><br>
송신측에서 한 번에 <strong>1 바이트씩</strong> 데이터를 전송해오는 것이다. 이러한 상황을 해결하기 위해 <strong>지연 확인 응답</strong>(delayed acknowledgement)방법을 사용한다. 응답 메시지를 전송하는 것과 윈도우 사이즈를 갱신하는 것을 지연시키는 것이다. 하지만 이 방법이 네트워크 부하를 감소시켜준다고 할 지라도 송신측에서는 계속해서 1바이트씩 보내게 된다.</p>
<p>그래서 <code>네이글 알고리즘(Nagle Algorithm)</code>을 통해 해결하곤 한다. 데이터가 한 번에 한 바이트씩 송신자에게 올 경우, 첫 번째 바이트만을 송신하고 나머지는 보낸 바이트에 대한 명백한 확인 응답이 올 때까지 <strong>버퍼</strong>에 보관한다는 것이다. 그리고 버퍼 내의 모든 문자를 하나의 <code>TCP 세그먼트</code>로서 전송한 후, 또 응답 메시지가 도착할 때까지 버퍼에 전송할 데이터를 저장한다. 하지만 이 알고리즘이 <strong>교착상태</strong>를 야기할 수 있고 그 결과 웹 페이지의 다운을 초래할 수 있다.</p>
<p><em>그런데 애플리케이션이 수신된 데이터를 1 바이트씩 가져간다면 어떻게 될까??</em><br>
수신측은 버퍼에서 1 바이트가 비었기 때문에 <strong>window size</strong>를 1 바이트로 설정해서 응답을 하게 되고 송신측은 <strong>window size</strong>가 1 바이트니 1 바이트만큼의 데이터를 전송하게 된다. 1 바이트의 데이터를 보내기 위해서 41 바이트의 패킷 구성을 하는 비효율적인 상황이 발생하게 된다. 이런 상황을 <code>silly window syndrome</code>이라고 하는데, 이 상황을 최적화 하기 위해 1 바이트에 해당하는 윈도우 사이즈를 통보하지 않는다. 설정 당시 통보한 세그먼트의 최대 크기를 처리할 수 있게 되거나, 버퍼의 반이 빈 상태가 될 때까지 통보하지 않는 것이다. 송신자 측도 윈도우 사이즈가 커질 때까지 기다리는 것이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/17/network/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/17/DataStructure/"
                            aria-label=": 자료구조 :: 자료구조?"
                        >
                            자료구조 :: 자료구조?
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-17T01:07:37+09:00">
	
		    May 17, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/자료구조/">자료구조</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>[2020.05.12]<br>
이 글은 굉장히 오래 전에 작성된 글입니다. 그래서 정리라기 보다는 내용을 한 곳에 썼다는 표현이 나을 것 같네요! 삭제하려고 했지만, 많은 내용을 담고 있어 레거시로 유지하려고 합니다. :) 이 페이지의 내용들이 여러 포스팅으로 나누어 작성되었으니 그 글을 참고하면 좋을 것 같습니다.</p>
<h1 id="자료구조란-무엇인가">자료구조란 무엇인가??</h1>
<p>자료구조 하면 무엇이 떠오를까요??? 흔한 자료구조의 형태로 <code>큐(Queue)</code>나 <code>스택(Stack)</code> 혹은 연결 리스트(Linked List), 트리(Tree) 등을 떠올리거나 선택정렬, 삽입 정렬 등등의 정렬 알고리즘 등이 먼저 떠오릅니다.</p>
<p>사전적인 의미는 <code>자료(data)</code>의 집합을 의미하며, 각 원소들이 <strong>논리적으로 정의된 규칙</strong>에 의해 나열되며 자료에 대한 처리를 <strong>효율적</strong>으로 수행할 수 있도록 자료를 구분하여 표현한 것이라고 한다.</p>
<p>목적은 명확하다. <code>자료</code>를 더 <strong>효율적으로 저장</strong>하고, 관리하기 위해 사용하며, 잘 선택된 자료구조는 <strong>실행시간을 단축</strong>시켜주거나 <strong>메모리 용량의 절약</strong>을 이끌어 낼 수 있다.</p>
<blockquote>
<p>자료구조의 선택 기준</p>
</blockquote>
<ul>
<li>자료의 처리 시간</li>
<li>자료의 크기</li>
<li>자료의 활용 빈도</li>
<li>자료의 갱신 정도</li>
<li>프로그램의 용이성</li>
</ul>
<p>자료의 처리를 보다 효율적으로 하기 위해서 위와 같은 사항을 고려하여 선택, 사용해야 한다.</p>
<h1 id="자료구조의-특징">자료구조의 특징</h1>
<ol>
<li>효율성</li>
</ol>
<p>자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 따라서 적절한 자료구조를 선택하여 사용한다면 업무의 효율이 올라갈 것이다.<br>
Ex) 검색에 대한 알고리즘을 구현할 때, 데이터의 양이 많다면 순차 검색을 사용하는 것보다 이분 검색을 활용하는 것이 더 효율적일 것이다. 왜냐하면 학생이라는 테이블에 학생에 대한 데이터가 100만개 있다고 할 때, 순차 검색으로 데이터를 검색하게 되면 운이 좋을 때는 1번의 연산으로 찾을 수 있지만, 운이 없을 경우에는 100만번의 연산을 거쳐야 할 것이다. 이에 반해 이분 검색은 연산의 횟수가 훨씬 줄어든다. 이와 같이 목적에 맞는 자료구조를 사용하는 것이 효율적이다.</p>
<ol start="2">
<li>추상화</li>
</ol>
<p>추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념만 간추려 내는 것이다. 자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입할 것이며, 어느 시점에 이러한 데이터를 어떻게 사용할 것인지에 대해서 초점을 맞출 수 있기 때문에 구현 외적인 부분에 더 시간을 쏟을 수 있다. 알고리즘 자체에는 중점을 두지 않는다.</p>
<p>마찬가지로 자료구조 내부의 구현은 중요하지 않다. 어떻게 구현했는지 보다 어떻게 사용해야 하는지를 알고 있어야 한다.<br>
Ex) Stack의 경우 먼저 들어간 것이 나중에 나오는 LIFO(Last In First Out)의 형태를 가지고 있다. 그리고 push() 함수를 이용해서 데이터를 삽입할 수 있고, pop() 함수를 이용해서 데이터를 추출할 수 있다. 그 함수 내부 구현이 어떻게 되었는지는 중요하지 않다. 사람마다 다른 코드를 작성할 것이고, 사용 언어, 개발 툴 등 환경적인 변수에 의해 다른 코드가 나올 것이기 때문에 추상적인 개념에 대해서만 이해하고 있다면 사용할 수 있다.</p>
<ol start="3">
<li>재사용성</li>
</ol>
<p>자료구조를 설계할 때 특정 프로그램에서만 동작하게 설계 하지는 않는다. 다양한 프로그램에서 동작할 수 있도록 범용성 있게 설계하기 때문에 해당 프로젝트가 아닌 다른 프로젝트에서도 사용할 수 있어야 한다.</p>
<h1 id="자료구조의-분류">자료구조의 분류</h1>
<p>자료구조는 크게 <strong>선형 자료구조</strong>와 <strong>비선형 자료구조</strong>로 나뉜다.</p>
<ol>
<li><code>선형 자료구조</code> : 데이터가 일렬로 나열되어 있는 것을 뜻한다.</li>
</ol>
<ul>
<li>배열(Array)</li>
<li>연결 리스트(Linked List)</li>
<li>스택(Stack)</li>
<li>큐(Queue)</li>
</ul>
<ol start="2">
<li><code>비선형 자료구조</code> : 특정한 형태를 띄고 있는 것을 뜻함</li>
</ol>
<ul>
<li>트리(Tree)</li>
<li>그래프(Graph)</li>
</ul>
<h1 id="array-vs-linked-list">Array vs Linked List</h1>
<blockquote>
<p>Array</p>
</blockquote>
<p>가장 기본적인 자료구조인 <code>Array</code> 자료구조는, <strong>논리적 저장 순서</strong>와 <strong>물리적 저장 순서</strong>가 <code>일치</code>한다. 따라서 <code>인덱스(index)</code>로 해당 원소에 접근할 수 있다. 그렇기 때문에 찾고자 하는 원소의 인덱스 값을 알고 있으면 시간 복잡도 O(1)에 해당 원소로 접근할 수 있다. 즉 <strong>random access</strong>가 가능하다는 장점이 존재</p>
<p>하지만 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤(O(1)), 또 한 가지의 작업을 추가적으로 해줘야 하기 때문에, 시간이 더 걸린다. 만약, 배열 중 어느 원소를 삭제했다고 했을 때, <strong>배열의 연속적인 특징이 깨지게 된다.</strong> 즉 빈 공간이 생기는 것이다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 <code>shift</code>해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)가 된다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity와 worst case는 O(n)이 된다.<br>
삽입의 경우도 마찬가지이다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1씩 <code>shift</code> 해줘야 하므로 이 경우도 시간 복잡도 O(n)을 갖게 된다.</p>
<blockquote>
<p>Linked List</p>
</blockquote>
<p>이 부분에 대한 문제점을 해결하기 위한 자료구조가 <code>Linked List</code>이다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. 따라서 이 부분만 다른 값으로 바꿔주면 삭제와 삽입을 시간 복잡도 O(1)만에 해결할 수 있다.<br>
하지만 <code>Linked List</code> 역시 한 가지 문제가 존재한다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 하는 과정에 있어서 <strong>첫 번째 원소부터 모두 확인</strong>해봐야 한다는 것이다. Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다. 이것은 일단 삽입하고 정렬하는 것과 마찬가지이다. 이 과정 때문에, 어떠한 원소를 삭제 또는 추가하고자 했을 때, 그 원소를 찾기 위해서 시간 복잡도 O(n)의 시간이 추가적으로 발생하게 된다.</p>
<p>결국 <code>Linked List</code> 자료구조는 Search에도 O(n)의 시간 복잡도를 갖고, 삽입, 삭제에 대해서도 O(n)의 시간 복잡도를 갖는다. 그렇다고 해서 아주 쓸모 없는 자료구조는 아니기에, 우리가 아직 배우는 것이다. Tree 구조의 근간이 되는 자료구조이며, Tree에서 사용되었을 때, 그 유용성이 드러난다.</p>
<h1 id="stack-and-queue">Stack and Queue</h1>
<blockquote>
<p>Stack</p>
</blockquote>
<p><code>선형 자료구조</code>의 일종으로 <strong>Last In First Out(LIFO)</strong> 즉, 나중에 들어간 원소가 먼저 나온다. 이것이 Stack의 가장 큰 특징이다. 차곡 차곡 쌓이는 구조로 먼저 Stack에 들어가게 된 원소는 맨 바닥에 깔리게 된다. 그렇기 때문에 늦게 들어간 녀석들은 그 위에 쌓이게 되고 호출 시 가장 위에 있는 녀석이 호출되는 구조이다.</p>
<blockquote>
<p>Queue</p>
</blockquote>
<p><code>선형 자료구조</code>의 일종으로 <strong>Fist In First Out(FIFO)</strong> 즉, 먼저 들어간 놈이 먼저 나온다. Stack과는 반대로 먼저 들어간 놈이 맨 앞에서 대기하고 있다가 먼저 나오게 되는 구조이다.</p>
<h1 id="tree">Tree</h1>
<p>트리는 스택이나 큐와 같은 선형 구조가 아닌 <strong>비선형 자료구조</strong>이다. 트리는 <code>계층적 관계</code>를 표현하는 자료구조이다. <code>트리</code>라는 자료구조는 표현에 집중한다.</p>
<blockquote>
<p>트리를 구성하고 있는 구성요소들 - 용어</p>
</blockquote>
<ul>
<li>Node(노드) : 트리를 구성하고 있는 각각의 요소를 의미</li>
<li>Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선을 의미</li>
<li>Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드를 의미</li>
<li>Termianl Node( = leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드를 의미</li>
<li>Internal Node(내부 노드, 비단말 노드) : 단말 노드를 제외한 모든 노드로 루트 노드를 포함한다.</li>
</ul>
<h2 id="binary-tree이진-트리">Binary Tree(이진 트리)</h2>
<p>루트 노드를 중심으로 두 개의 서브 트리(큰 트리에 속하는 작은 트리)로 나뉘어 진다. 또한 나뉘어진 두 서브 트리 모두 이진 트리어야 한다. 즉, 각 노드가 자식을 최대 2명을 가지는 트리를 의미한다. 재귀적인 정의라 맞는듯 하면서도 이해가 쉽지 않을 듯 하다. 덧붙이자면 공집합도 이진 트리로 포함시켜야 한다. 그래야 재귀적으로 조건을 확인해갔을 때, leaf node에 다 달았을 때, 정의가 만족되기 때문이다.</p>
<p>트리에서는 각 <strong>층별</strong>로 숫자를 매겨서 이를 트리의 <code>Level</code>이라고 하낟. 루트 노드부터 시작하고 루트 노드의 level은 9이다. 그리고 트리의 최고 level을 가리켜 해당 트리의 <code>height(높이)</code>라고 한다.</p>
<blockquote>
<p>완전 이진 트리(Complete Binary Tree)</p>
</blockquote>
<p><img src="/img/binary_tree.png" alt=""></p>
<p>그림과 같이 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워지고 자식이 2개이고 꽉 찬 트리르 완전 이진 트리라고 한다.<br>
완전 이진 트리의 노드 개수는 2^(level-1)이다.</p>
<blockquote>
<p>포화 이진 트리(Full Binary Tree)</p>
</blockquote>
<p>모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리라고 한다.</p>
<p>Full Binary Tree와 Complete Binary Tree는 노드의 개수가 n일 때, i번째 노드에 대해서 parent(i) = i/2, left_child(i) = 2i, right_child(i) = 2i+1 의 index 값을 갖는다.</p>
<p><img src="/img/tree.png" alt=""></p>
<p>이러한 최악의 경우 한쪽으로 계속 쏠리게 되는 형태 또한 이진 트리이다. 이러한 경우 사실 트리를 쓰는 이유가 사라지게 된다. 트리의 특정한 경우이지만 이렇게 된다면, 탐색, 삽입, 삭제, 메모리 성능 모든 면에서 배열에 비해 좋은 것이 없다.</p>
<ul>
<li>이진 트리의 순회 방법</li>
</ul>
<ol>
<li>전위 순회(Preorder) : 루트 -&gt; 왼쪽 서브트리 -&gt; 오른쪽 서브트리</li>
<li>중위 순회(Inorder) : 왼쪽 서브트리 -&gt; 루트 -&gt; 오른쪽 서브트리</li>
<li>후위 순회(Postorder) : 왼쪽 서브트리 -&gt; 오른쪽 서브트리 -&gt; 루트</li>
</ol>
<h2 id="bstbinary-search-tree">BST(Binary Search Tree)</h2>
<p>효율적인 탐색을 위한 저장방법이 무엇일까를 고민해야 한다. 이진 탐색 트리는 이진 트리의 일종이다. 단 이진 탐색 트리에는 <strong>데이터를 저장하는 규칙이 있다.</strong> 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.</p>
<ul>
<li>규칙1 : 이진 탐색 트리의 노드에 저장된 키는 유일하다.</li>
<li>규칙2 : 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떤 노드의 키보다 크다.</li>
<li>규칙3 : 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떤 노드의 키보다 작다.</li>
<li>규칙4 : 왼쪽과 오른쪽 서브트리도 이진 탐색 트리다.</li>
</ul>
<p>이진 탐색 트리의 탐색 연산은 O(log n)의 시간 복잡도를 갖는다. 사실 정확히 말하면 O(h)라고 표현하는 것이 맞다. 트리의 높이를 하나씩 더해갈수록 추가할 수 있는 노드의 수가 두 배씩 증가하기 때문이다. 하지만 이러한 이진 탐색 트리는 Skewed Tree(편향 트리)가 될 수 있다. 저장 순서에 따라 계속 한 쪽으로만 노드가 추가되는 경우가 발생하기 때문이다.<br>
이럴 경우 성능에 영향을 미치게 되며, 탐색의 <strong>Worst Case</strong>가 되고 시간 복잡도는 O(n)이 된다.</p>
<p>배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다. 이를 해결하기 위해 <code>Rebalancing</code> 기법이 등장했다. 균형을 잡기 위한 트리 구조의 재조정을 <code>Rebalancing</code>이라 한다. 이 기법을 구현한 트리에는 여러 종류가 존재하는데 긎 ㅜㅇ에서 하나가 뒤에서 살펴볼 <code>Red-black-Tree</code>이다.</p>
<h2 id="binary-heap">Binary Heap</h2>
<p>자료구조의 일종으로 Tree의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 <code>Complete Binary Tree</code>이다. 배열에 트리의 값을 넣어 줄 때, 0번째는 건너뛰고 1번 index 부터 루트 노드가 시작된다. 이는 노드의 고유번호 값과 배열의 index를 일치시켜 혼동을 줄이기 위함이다.<br>
힙에는 <code>최대힙(max heap)</code>과 <code>최소힙(min heap)</code> 두 종류가 있다.</p>
<p><code>Max heap</code>이란, 각 노드의 값이 해당 children의 값보다 크거나 같은 **Complete Binary Tree(완전 이진 트리)**를 말한다. [Min heap은 그 반대]</p>
<p>Max heap에서는 Root noed에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 시간 복잡도가 O(1)이다. 그리고 complete binary tree 이기 때문에 배열을 사용하여 효율적으로 관리할 수 있다 (즉, random access가 가능하다. Min heap에서는 최소값을 찾는데 소요되는 연산의 시간복잡도가 O(1)이다.) 하지만 heap의 구조를 계속 유지하기 위해서는 제거된 루트 노드를 대체할 다른 노드가 필요하다. 여기서 heap은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간 복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.</p>
<h2 id="red-black-tree">Red Black Tree</h2>
<p>RBT(Red-Black Tree)는 BST를 기반으로 하는 <strong>트리 형식의 자료구조</strong>이다. 결론부터 말하자면 Red-Black Tree에 데이터를 저장하게 되면 Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다. 동일한 노드의 개수일 때, <strong>depth</strong>를 최소화하여 <code>시간 복잡도를 줄이는 것</code>이 핵심 아이디어이다. 동일한 노드의 개수일 때, <strong>depth</strong>가 최소가 되는 경우는 tree가 완전 이진 트리(complete binary tree)인 경우이다.</p>
<h3 id="red-black-tree의-정의">Red-Black Tree의 정의</h3>
<p>RBT는 다음의 성질을 만족하는 BST이다.</p>
<ol>
<li>각 노드는 <code>Red</code> or <code>Black</code>라는 색깔을 갖는다.</li>
<li>Root node의 색깔은 <code>Black</code>이다.</li>
<li>각 leaf node는 <code>black</code>이다.</li>
<li>어떤 노드의 색깔이 <code>red</code>라면 두 개의 children 의 색깔은 모두 black이다.</li>
<li>각 노드에 대해서 노드로부터 descendant leaves까지의 단순 경로는 모두 같은 수의 black nodes들을 포함하고 있다. 이를 해당 노드의 <code>Black-Height</code>라고 한다.<br>
cf) Black-Height : 노드 x로부터 노드 x를 포함하지 않은 leaf node까지의 simple path 상에 있는 black node들의 개수</li>
</ol>
<h3 id="red-black-tree의-특징">Red-Black Tree의 특징</h3>
<ol>
<li>Binary Search Tree이므로 BST의 특징을 모두 갖는다.</li>
<li>Root node부터 leaf node 까지의 모든 경로 중 최소 경로와 최대 경로의 크기 비율은 2보다 크지 않다. 이러한 상태를 <code>balanced</code> 상태라고 한다.</li>
<li>노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장한다. 이러한 NIL들을 leaf node로 간주한다.</li>
</ol>
<h3 id="삽입">삽입</h3>
<p>우선 BST의 특성을 유지하면서 노드를 삽입한다. 그리고 삽입된 노드의 색깔을 RED로 지정한다. Red로 지정하는 이유는 Black-Height 변경을 최소화하기 위함이다. 삽입 결과 RBT의 특성 위배시 노드의 색깔을 조정하고, Black-Height가 위배되었다면 <strong>rotation</strong>을 통해 height를 조정한다. 이러한 과정을 통해 RBT의 동일한 height에 존재하는 internal node들의 Black-height가 같아지게 되고 최소 경로와 최대 겨올의 크기 비율이 2미만으로 유지된다.</p>
<h3 id="삭제">삭제</h3>
<p>삭제도 삽입과 마찬가지로 BST의 특성을 유지하면서 해당 노드를 삭제한다. 삭제될 노드의 child의 개수에 따라 rotation 방법이 달라지게 된다. 그리고 만약 지워진 노드의 색깔이 Black이라면 Black-height가 1 감소한 경로에 black node가 1개 추가되도록 rotation하고 노드의 색깔을 조정한다. 지워진 노드의 색깔이 red라면 Violation이 발생하지 않으므로 RBT가 그대로 유지된다.</p>
<h1 id="hashtable">HashTable</h1>
<p><code>hash</code>는 내부적으로 <strong>배열</strong>을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 갖는다. 특정한 값을 Search하는데 데이터 고유의 <code>인덱스</code>로 접근하게 되므로 average case에 대하여 시간 복잡도가 O(1)이 되는 것이다. (항상 O(1)이 아니고 average case에 대해서 O(1)인 것은 collision 때문이다.) 하지만 문제는 이 인덱스로 저장되는 key 값이 불규칙하다는 것이다.</p>
<p>그래서 <strong>특별한 알고리즘을 이용하여</strong> 저장할 데이터와 <strong>고유한 숫자를 만들어 낸 뒤</strong> 이를 인덱스로 사용한다. 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치이기 때문에, 삽입 연산 시 다른 데이터의 사이에 끼어들거나, 삭제 시 다른 데이터로 채울 필요가 없으므로 연산에서 추가적인 비용이 없도록 만들어진 구조이다.</p>
<h2 id="hash-function">hash function</h2>
<p>'특별한 알고리즘’을 통해 고유한 인덱스 값을 설정하는 것이 중요하다. '특별한 알고리즘’을 <code>hash method</code>또는 <code>해시 함수(hash function)</code>라고 하고 이 메소드에 의해 반환된 데이터의 고유의 숫자 값을 <code>hashcode</code>라고 한다. 저장되는 값들의 key 값을 <code>hash function</code>을 통해서 <strong>작은 범위의 값들로</strong> 바꿔준다.</p>
<p>하지만 어설픈 <code>hash function</code>을 통해서 key 값들을 결정한다면 동일한 값이 도출될 수가 있다. 이렇게 되면 동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것인데 이를 <code>Collision</code>이라고 한다.</p>
<ul>
<li>Collision : 서로 다른 두 개의 키가 같은 인덱스로 hashing(hash 함수를 통해 계산됨을 의미)되면 같은 곳에 저장할 수 없게 된다.</li>
</ul>
<p>일반적으로 좋은 <code>hash function</code>는 키의 일부분을 참조하여 해쉬 값을 만들지 않고 키 전체를 참조하여 해쉬 값을 만들어 낸다. 하지만 좋은 해쉬 함수는 키의 어떤 특성을 가지고 있느냐에 따라 달라지게 된다.</p>
<p><code>hash function</code>를 무조건 1:1로 만드는 것보다 <strong>Collision</strong>을 최소화하는 방향으로 설계하고 발생하는 Collision에 대비해 어떻게 대응할 것인가가 더 중요하다. 1:1 대응이 되도록 만드는 것이 거의 불가능하기도 하지만 그런 hash function를 만들어봤자 그건 array와 다를바 없고 메모리를 너무 차지하게 된다.</p>
<p><strong>Collision</strong>이 많아질 수록 Search에 필요한 시간 복잡도가 O(1)에서 O(n)에 가까워진다. 어설픈 hash function는 hash를 hash답게 사용하지 못하도록 한다. 좋은 hash function를 선택하는 것은 hash table의 성능 향상에 필수적인 것이다.</p>
<p>따라서 hashing된 인덱스에 이미 다른 값이 들어 있다면 세 데이터를 저장할 다른 위치를 찾은 뒤에야 저장할 수 있는 것이다. 따라서 충돌 해결은 필수이며 그 방법들에 대해 알아보자.</p>
<h2 id="resolve-confilct">Resolve Confilct</h2>
<ol>
<li>Open Address 방식(개방 주소법)</li>
</ol>
<p>해시 충돌이 발생하면, (즉 삽입하려는 해시 버킷이 이미 사용중인 경우) <strong>다른 해시 버킷에 해당 자료를 삽입하는 방식</strong>이다. 버킷이란 바구니와 같은 개념으로 <strong>데이터를 저장하기 위한 공간</strong>이라고 생각하면 된다. 다른 해시 버킷이란 어떤 해시 버킷인가???</p>
<p>공개 주소 방식이라고도 불리는 이 알고리즘은 Collision이 발생하면 데이터를 저장할 장소를 찾아 헤맨다. <strong>Worst Case</strong>의 경우 비어있는 버킷을 찾지 못하고 탐색을 시작한 위치까지 되돌아 올 수 있다. 이 과정에서도 방법이 존재하고, 3가지를 살펴보겠다.</p>
<ul>
<li>Linear Probing : 순차적으로 탐색하며 비어있는 버킷을 찾을 때까지 계속 진행된다.</li>
<li>Quadratic probing : 2차 함수를 이용해 탐색할 위치를 찾는다.</li>
<li>Double hashing probing : 하나의 해쉬 함수에서 충돌이 발생하면 2차 해쉬 함수를 이용해 새로운 주소를 할당한다. 위 두 가지 방법에 비해 많은 연산량을 요구하게 된다.</li>
</ul>
<ol start="2">
<li>Seperate Chaining 방식(분리 연결법)</li>
</ol>
<p>일반적으로 Open Addressing은 Separate Chaining보다 느리다. Open Addressing의 경우 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 더 높아지기 때문이다. 반면 <code>Separate Chaining</code> 방식의 경우 해시 <strong>충돌이 잘 발생하지 않도록 보조 해시 함수를 통해 조정</strong>할 수 있다면 <strong>Worst Case에 가까워 지는 빈도를 줄일 수 있다</strong>. Java 7에서는 Separate Chaining 방식을 사용하여 HashMap을 구현하고 있다. Separate Chaining 방식으로는 두 가지 구현 방식이 존재한다.</p>
<ul>
<li>
<p>연결 리스트를 사용하는 방식(Linked List)<br>
각각의 버킷들을 연결 리스트로 만들어 <code>Collision</code>이 발생하면 해당 버킷의 list에 추가하는 방식이다. 연결 리스트의 특징을 그대로 이어받아 삭제 또는 삽입이 간단하다. 하지만 단점도 그대로 물려받아 작은 데이터들을 저장할 때 연결 리스트 자체의 <strong>오버헤드</strong>가 부담이 된다. 또 다른 특징으로는, 버킷을 계속해서 사용하는 Open Address 방식에 바해 테이블의 확장을 늦출 수 있다.</p>
</li>
<li>
<p>Tree를 사용하는 방식<br>
기본적인 알고리즘은 <code>Separate Chaining</code> 방식과 동일하며 연결 리스트 대신 트리를 사용하는 방식이다. 연결 리스트를 사용할 것인가와 트리를 사용할 것인가에 대한 기준은 하나의 해시 버킷에 할당된 <code>key-value</code> 쌍의 개수이다. 데이터의 개수가 적다면 Linked List를 사용하는 것이 맞다.<br>
Tree는 기본적으로 메모리 사용량이 많기 때문이다. 데이터 개수가 적을 때 Worst Case를 살펴보면 트리와 링크드 리스트의 성능 상 차이가 거의 없다. 따라서 메모리 측면을 봤을 때 데이터 개수가 적을 때는 링크드 리스트를 사용한다.</p>
</li>
</ul>
<p><strong>데이터가 적다는 것은 얼마나 적다는 것을 의미하는가?</strong><br>
앞에서 말했듯이 기준은 하나의 해시 버킷에 할당된 key-value 쌍의 개수이다. 이 키-값 쌍의 개수가 6개, 8개를 기준으로 결정한다. 기준이 두 개 인것이 이상하게 느껴질 수 있다. 7은 어디로 갔는가? 링크드 리스트의 기준과 트리의 기준을 6과 8로 잡은 것은 변경하는데 소요되는 비용을 줄이기 위함이다.</p>
<p><strong>한 가지 상황을 가정해보자.</strong><br>
해시 버킷에 6개 의 key-value 쌍이 들어있었다. 그리고 하나의 값이 추가되었다. 만약 기준이 6과 7이라면 자료구조를 링크드 리스트에서 트리로 변경해야 한다. 그러다 바로 하나의 값이 삭제된다면 다시 트리에서 링크드 리스트로 자료구조를 변경해야 한다. 각각 자료구조로 넘어가는 기준이 1이라면 Switching 비용이 너무 많이 필요하게 되는 것이다. 그래서 2라는 여유를 남겨두고 기준을 잡아준 것이다. 따라서 데이터의 개수가 6개에서 7개로 증가했을 때는 링크드 리스트의 자료구조를 취하고 있을 것이고 8개에서 7개로 감소했을 때는 트리의 자료구조를 취하고 있을 것이다.</p>
<ul>
<li>Open Address vs Separate Chaining</li>
</ul>
<p>일단 두 방식 모두 Worst Case 에서 O(M)이다. 하지만 <code>Open Address</code>방식은 연속된 공간에 데이터를 저장하기 때문에 <code>Separate Chaining</code>에 비해 <strong>캐시 효율이 높다</strong>. 따라서 데이터의 개수가 충분히 적다면 <code>Open Address</code> 방식이 <code>Separate Chaining</code> 보다 더 성능이 좋다.<br>
한 가지 차이점이 더 존재한다. Separate Chaining방식에 비해 Open Address방식은 버킷을 계속해서 사용한다. 따라서 Separate Chaining 방식은 테이블의 <strong>확장을 보다 늦출 수 있다.</strong></p>
<p><strong>보조 해시 함수</strong></p>
<p>보조 해시 함수의 목적은 <code>key</code>의 해시 값을 변형하여 <strong>해시 충돌 가능성을 줄이는 것</strong>이다. <code>Separate Chaining</code> 방식을 사용할 때 함께 사용되며 보조 해시 함수로 <strong>Worst Case</strong>에 가까워지는 경우를 줄일 수 있다.</p>
<ol start="3">
<li>해시 버킷 동적 확장(Resize)</li>
</ol>
<p>해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만 해시 충돌로 인해 성능 상 손실이 발생한다. 그래서 <strong>HashMap</strong>은 key-value 쌍 데이터 개수가 일정 개수 이상이 되면 해시 버킷의 개수를 두 배로 늘린다. 이렇게 늘리면 해시 충돌로 인한 성능 손실 문제를 어느 정도 해결할 수 있다.<br>
<code>일정 개수 이상</code> -&gt; 해시 버킷 크기를 두 배로 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. <strong>0.75</strong> -&gt; <strong>load factor</strong>라고 불린다.</p>
<h1 id="graph">Graph</h1>
<p><strong>Graph</strong> : 정점과 간선의 집합<br>
cf) 트리 또한 그래프이며, 그 중 사이클이 허용되지 않는 그래프를 말한다.</p>
<h2 id="그래프-관련-용어-정리">그래프 관련 용어 정리</h2>
<ol>
<li>
<p>Undirected Graph<br>
정점과 간선의 연결 관계에 있어서 방향성이 없는 그래프</p>
</li>
<li>
<p>Directed Graph(Diagraph)<br>
간선에 방향성이 포함되어 있는 그래프</p>
</li>
<li>
<p>Degree(차수)</p>
</li>
</ol>
<p>Undirected Graph에서 각 정점에 연결된 Edge의 개수를 말한다. Directed Graph에서는 간선에 방향성이 존재하기 때문에 Degree가 두 개로 나뉘게 된다.<br>
각 정점으로부터 나가는 간선의 개수를 <strong>OutDegree</strong>라 하고, 들어오는 간선의 개수를 <strong>Indegree</strong>이라 한다.</p>
<ol start="4">
<li>가중치 그래프(Weight Graph)와 부분 그래프(Sub Graph)</li>
</ol>
<p><strong>가중치 그래프</strong>란 간선에 가중치 정보를 두어서 구성한 그래프를 말한다. 반대의 개념인 <strong>비가중치 그래프</strong> 즉, 모든 간선의 가중치가 동일한 그래프도 존재한다. 부분 집합과 유사한 개념으로 부분 그래프라는 것이 있다. 부분 그래프는 본래의 그래프의 일부 정점 및 간선으로 이루어진 그래프를 말한다.</p>
<ol start="5">
<li>그래프를 구현하는 두 방법</li>
</ol>
<ul>
<li>
<p>인접 행렬(adjacent matrix) : 정방 행렬을 사용하는 방법<br>
해당하는 위치의 value 값을 통해서 vertex(정점)간의 연결 관계를 O(1)로 파악할 수 있다. Edge 개수와는 무관하게 V^2의 공간 복잡도를 갖는다. Dense graph를 표현할 때 적절한 방법이다.</p>
</li>
<li>
<p>인접 리스트(adjacent list) : 연결 리스트를 사용하는 방법</p>
</li>
</ul>
<p>vertex(정점)의 adjacent list를 확인해봐야 하므로 vertex간 연결되어 있는지 확인하는데 오래 걸린다. 공간 복잡도는 O(E+V)이다. <strong>Sparse graph</strong>를 표현하는데 적당한 방법</p>
<ol start="6">
<li>그래프 탐색</li>
</ol>
<p>그래프는 정점의 구성 뿐만 아니라 간선의 연결에도 규칙이 존재하지 않기 때문에 탐색이 복잡하다. 따라서 그래프의 모든 정점을 탐색하기 위한 방법은 다음의 두 가지 알고리즘을 기반으로 한다.</p>
<ul>
<li>깊이 우선 탐색(Depth First Search : DFS)</li>
</ul>
<p>그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 <strong>한 정점으로만 나아간다</strong>라는 방법을 우선으로 탐색한다. 일단 연결된 정점으로 탐색하는 것이다. 연결할 수 있는 정점이 있을 때까지 계속 연결하다가 더 이상 연결되지 않은 정점이 없으면 바로 그 전 단계의 정점으로 돌아가서 연결할 수 있는 정점이 있는지 살펴봐야 할 것이다. 갔던 길을 되돌아 오는 상황이 존재하는 미로찾기처럼 구성하면 되는 것이다.<br>
어떤 자료구조를 사용해야할까?? Stack이다.<br>
시간 복잡도 : O(V+E) … vertex개수+edge개수</p>
<ul>
<li>너비 우선 탐색(Breadth First Search : BFS)</li>
</ul>
<p>그래프 상에 존재하는 임의의 한 정점으로부터 연결되어 있는 <strong>모든 정점으로 나아간다</strong>. Tree에서의 Level Order Traversal 형식으로 진행되는 것이다. BFS에서는 자료구조로 <code>Queue</code>를 사용한다. 연락을 취할 정점의 순서를 기록하기 위한 것이다. 우선, 탐색을 시작하는 정점을 <code>Queue</code>에 넣는다.(enqueue) 그리고 <strong>dequeue</strong>를 하면서 정점과 간선으로 연결되어 있는 정점들을 <strong>enqueue</strong>한다. 즉 vertex들을 방문한 순서대로 queue에 저장하는 방법을 사용하는 것이다.<br>
시간 복잡도 : O(V+E) … vertex개수 + edge 개수<br>
<strong>BFS로 구한 경로는 최단 경로</strong></p>
<ol start="7">
<li>Minimum Spanning Tree</li>
</ol>
<p>그래프 G의 spanning tree 중 edge weight의 합이 최소이 <code>spanning tree</code>를 말한다. 여기서 말하는 <code>spanning tree</code>란 그래프 G의 모든 vertex가 cycle이 없이 연결된 형태를 말한다.</p>
<ol start="8">
<li>Kruskal Algorithm</li>
</ol>
<p>초기화 작업으로 <strong>edge</strong> 없이 vertex들만으로 그래프를 구성한다. 그리고 weight가 제일 작은 edge부터 검토한다. 그러기 위해서는 edge Set을 non-decreasing으로 해야 한다. 그리고 가장 작은 weight에 해당하는 edge를 추가하는데 추가할 때 그래프에 cycle이 생기지 않는 경우에만 추가한다. spanning tree가 완성되면 모든 vertex들이 연결된 상태로 종료가 되고 완성될 수 없는 그래프에 대해서는 모든 edge에 대해 판단이 이루어지면 종료된다.</p>
<ul>
<li>
<p>어떻게 cycle 생성 여부를 판단하는가??<br>
graph의 각 vertex에 <strong>set-id</strong>라는 것을 추가적으로 부여한다. 그리고 초기화 과정에서 모두 1~n까지의 값으로 각각의 vertex들을 초기화한다. 여기서 0은 어떠한 edge와도 연결되지 않았음을 의미하게 된다. 그리고 연결할 때마다 <strong>set-id</strong>를 하나로 통일시키는데, 값이 동일한 <strong>set-id</strong>개수가 많은 <strong>set-id</strong> 값으로 통일시킨다.</p>
</li>
<li>
<p>Time Complexity(시간 복잡도)</p>
</li>
</ul>
<ol>
<li>
<p>Edge의 weight를 기준으로 sorting - O(E log E)</p>
</li>
<li>
<p>cycle 생성 여부를 검사하고 set-id를 통일 - O(E + V log V) =&gt; 전체 시간 복잡도 : O(E log E)</p>
</li>
<li>
<p>Prim Algorithm</p>
</li>
</ol>
<p>초기화 과정에서 한 개의 vertex로 이루어진 초기 그래프 A를 구성한다. 그리고 나서 그래프 A 내부에 있는 vertex로부터 외부에 있는 vertex 사이의 edge를 연결하는데 그 중 가장 작은 weight의 edge를 통해 연결되는 vertex를 추가한다. 어떤 vertex건 간에 상관없이 edge의 weight를 기준으로 연결하는 것이다. 이렇게 연결된 vertex(정점)는 그래프 A에 포함된다. 위 과정을 반복하고 모든 vertex들이 연결되면 종료한다.</p>
<p>Time Complexity(시간 복잡도)<br>
=&gt; 전체 시간 복잡도 : O(E log V)</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/17/DataStructure/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/05/sopt-seminar4/"
                            aria-label=": [SOPT] Seminar4"
                        >
                            [SOPT] Seminar4
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-05T17:55:30+09:00">
	
		    May 05, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Inno-SOPT/">Inno_SOPT</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="통신의-기본">통신의 기본</h1>
<h2 id="http">HTTP?</h2>
<ul>
<li>하이퍼텍스트 기반(링크 기반)으로 데이터를 주고 받는다.</li>
<li>인터넷 상에서 데이터를 주고 받기 위한 Client/Server 모델을 따르는 프로토콜</li>
<li>가장 성공적으로 평가받는 프로토콜</li>
</ul>
<h2 id="프로토콜">프로토콜</h2>
<p><img src="/img/protocol.png" alt=""></p>
<h2 id="clientserver">Client/Server</h2>
<p><img src="/img/client.png" alt=""></p>
<h2 id="주요-메소드">주요 메소드</h2>
<ul>
<li><code>GET</code><br>
: 데이터 받기<br>
: URL 혹은 URL에 변수를 포함시켜(포함시키지 않을 수도 있음) 데이터를 받는 방식</li>
<li><code>POST</code><br>
: 데이터 생성<br>
: 데이터를 Body(일종의 객체)에 감싸서 보내는 방식</li>
<li><code>PUT</code><br>
: 데이터 업데이트<br>
: <code>POST</code>와 마찬가지로 Body에 감싸서 보내는 방식<br>
: 성공적으로 보내면 데이터가 업데이트 된다.</li>
<li><code>DELETE</code><br>
: 데이터 삭제<br>
: 성공적으로 보내면 데이터가 삭제 된다.</li>
</ul>
<h2 id="in-android">In Android</h2>
<ul>
<li>Http 기반 <strong>REST API</strong>(GET,POST,PUT,DELETE)를 <code>Retrofit2</code> 라이브러리를 통해 사용</li>
<li>REST API의 표현식인 <strong>JSON</strong>을 <strong>Object</strong> 개념으로 바꿔주는 GSON 라이브러리를 함께 사용</li>
</ul>
<h1 id="retrofit2">Retrofit2</h1>
<h2 id="retrofit2이란">Retrofit2이란?</h2>
<ul>
<li>Http REST API 통신을 위한 라이브러리</li>
<li>@ annotation 형식을 통해 사용</li>
<li>인터페이스를 통해 쉽게 구현 할 수 있다.</li>
<li><strong>JSON</strong>을 간단하게 처리할 수 있다.</li>
</ul>
<h2 id="jsongson">JSON/GSON</h2>
<ol>
<li><code>JSON</code></li>
</ol>
<ul>
<li><code>JSON</code>이란 ‘Key’:value 조합을 갖는 데이터를 말한다.</li>
<li><code>value</code>에는 <strong>숫자, 문자열, 배열, 논리, 객체</strong>가 올 수 있다.</li>
<li>JSON 자체를 <strong>배열</strong>로 받을 수 있다.</li>
<li><strong>객체</strong>는 <strong>중괄호</strong>로 {} 구분하고, <strong>배열</strong>을 <strong>대괄호</strong>로 [] 구분한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&quot;JSON Object&quot; : &#123;</span><br><span class="line">	&quot;name&quot; : &quot;Lee&quot;,</span><br><span class="line">	&quot;age&quot; : 25,</span><br><span class="line">	&quot;part&quot; : android,</span><br><span class="line">	&quot;etc&quot; : &#123;</span><br><span class="line">		&quot;dog&quot; : false,</span><br><span class="line">		&quot;cat&quot; : false</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JSON Object</span><br><span class="line"></span><br><span class="line">&quot;JSON Array&quot; : [</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;name&quot; : &quot;탁형민&quot;,</span><br><span class="line">		&quot;nick&quot; : &quot;탁클라운&quot;</span><br><span class="line">		&quot;age&quot; : 25</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;name&quot; : &quot;류수한&quot;,</span><br><span class="line">		&quot;nick&quot; : &quot;류뚱&quot;</span><br><span class="line">		&quot;age&quot; : 25</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;name&quot; : &quot;이종찬&quot;,</span><br><span class="line">		&quot;nick&quot; : &quot;종팡&quot;</span><br><span class="line">		&quot;age&quot; : 26</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// JSON Array</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>GSON</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;JSON Object&quot; : &#123;</span><br><span class="line">	&quot;name&quot; : &quot;Lee&quot;,</span><br><span class="line">	&quot;age&quot; : 25,</span><br><span class="line">	&quot;part&quot; : android</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 JSON을 아래의 객체로 사용할 수 있게끔 변환해주는 라이브러리</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class JSON&#123;</span><br><span class="line">	var name : String,</span><br><span class="line">	var age : Int,</span><br><span class="line">	var part : String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>JSON</strong>의 Key와 객체의 변수명은 같아야 한다.</li>
<li>물론 타입도 맞춰줘야 한다.</li>
</ul>
<h2 id="glide">Glide</h2>
<ul>
<li><strong>이미지 로드</strong> 라이브러리</li>
<li>서버에서 받은 이미지 <code>url</code>을 로드할 수 있게끔 도와준다.</li>
<li>이미지 비율에 맞게 사이즈 조정</li>
<li>Out of memory 방지</li>
<li>기본 사용법</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Glide.with(Context)</span><br><span class="line">.load(서버에서 받아 온 이미지 url)</span><br><span class="line">.into(이미지를 받을 뷰 객체)</span><br></pre></td></tr></table></figure>
<h1 id="과제">과제</h1>
<ol>
<li>복습 : 세미나 시간동안 구현한 것 완성 + 상세보기 화면 구현</li>
<li>응용 : 상세보기 화면에서 댓글 구현(댓글 달기, 삭제)</li>
<li>심화 : 서버 API가 없으므로 간단한 로그인 &amp; 회원 가입 기능 구현(SharedPreference 사용)</li>
</ol>
<p><code>Github</code> : <a href="https://github.com/WooVictory/SOPT_22th_Seminar4_HomeWork" target="_blank" rel="noopener">https://github.com/WooVictory/SOPT_22th_Seminar4_HomeWork</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/05/sopt-seminar4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/05/05/sopt-seminar3/"
                            aria-label=": [SOPT] Seminar3"
                        >
                            [SOPT] Seminar3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-05-05T11:48:08+09:00">
	
		    May 05, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Inno-SOPT/">Inno_SOPT</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="recyclerview">RecyclerView</h1>
<ul>
<li>특징<br>
<strong>반복되는 패턴</strong> 적용에 유리한 View(일종의 <code>리스트</code>)<br>
<strong>LayoutManager</strong> 속성을 추가하여 리스트 타입을 쉽게 변경 할 수 있다.<br>
<strong>재활용성</strong>이 뛰어난 구조</li>
</ul>
<h2 id="구성-요소">구성 요소</h2>
<p><strong>DataClass</strong><br>
<strong>ViewHolder</strong><br>
<strong>LayoutManager</strong><br>
<strong>Adapter</strong></p>
<h2 id="dataclass">DataClass</h2>
<p><img src="/img/kakaotalk.png" alt=""></p>
<ul>
<li>위의 네모난 채팅방을 item이라고 하며, 이 item에 들어갈 **데이터(자료형)**가 무엇인지 명시</li>
<li>프로필 이미지(Int), 채팅방 이름(String), 미리보기(String), 날짜(String)이 표시 된다.</li>
</ul>
<p><img src="/img/api.png" alt=""></p>
<ul>
<li>위 서버의 Response를 보고 작성한 DataClass</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data class GetBoardResponse(</span><br><span class="line">        var message : String,</span><br><span class="line">        var data : ArrayList&lt;GetBoardResponseData&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">class GetBoardResponseData(</span><br><span class="line">        var board_idx : Int,</span><br><span class="line">        var board_title : String?,</span><br><span class="line">        var board_content : String,</span><br><span class="line">        var board_view : Int,</span><br><span class="line">        var board_photo : String?,</span><br><span class="line">        var board_writetime : String?,</span><br><span class="line">        var user_id : String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>서버 API를 보고 DataClass를 작성할 경우에는 서버의 Key값과 동일하게 변수명을 작성하여야 한다.</li>
</ul>
<h2 id="viewholder">ViewHolder</h2>
<p><img src="/img/kakaotalk.png" alt=""></p>
<ul>
<li>Item에 들어갈 View가 무엇인지 명시</li>
<li>프로필 이미지(ImageView), 채팅방 이름(TextView), 미리보기((TextView), 날짜((TextView)</li>
</ul>
<h2 id="layoutmanger">LayoutManger</h2>
<p><img src="/img/layoutmanager.png" alt=""></p>
<ul>
<li>Item들의 배치 방식을 결정</li>
<li>LinearLayoutManager(선형), StaggeredGridLayoutManager(지그재그, 정확히는 가변 그리드), GridLayoutManager(사진첩 형태)</li>
<li>이번 세미나에서는 <strong>LinearLayoutManager</strong>를 통해서 수직 배치를 할 예정!</li>
</ul>
<h2 id="adapter">Adapter</h2>
<p><img src="/img/kakaotalk.png" alt=""></p>
<ul>
<li><strong>DataClass</strong>와 <strong>ViewHolder</strong>를 연결</li>
<li>이번 세미나에서는 DataClass의 프로필 이미지(Int)을 ViewHolder의 프로필 ImageView에, 채팅방(String)을 채팅방 TextView에, 미리보기(String)을 미리보기 TextView에 연결, 날짜(String)를 날짜 TextView에 연결한다.</li>
<li>서버와 통신을 할 경우에는 DataClass를 서버의 Response(응답)을 보고 작성하게 되는데, DataClass가 서버의 응답을 받아서 ViewHolder와 연결을 해주면 된다!!</li>
<li>DataClass가 중요한 부분!!</li>
<li>연결 후 RecyclerView가 Adapter를 잡게 함으로써 사용자에게 보여준다.</li>
</ul>
<h1 id="과제">과제</h1>
<ol>
<li>복습 : RecyclerView를 이용한 리스트 만들기 [hint : color값 넘기기!]</li>
<li>응용 : Item 요소 중에서 '프로필 이미지’를 클릭하면 프뢸 이미지만 볼 수 있는 Activity로 넘어가도록 작성 [hint : Adapter의 ViewHolder를 변경하면 됨]<br>
[주의 : Item을 클릭하면 상대방과의 채팅방으로 이동하는 Activity와는 별개로 작성해야 함]</li>
<li>심화 : RecyclerView의 Header를 만들어서 다른 형태의 Item도 RecyclerView에 포함되도록 작성</li>
</ol>
<p><code>Github</code> : <a href="https://github.com/WooVictory/SOPT_22th_Seminar3_HomeWork" target="_blank" rel="noopener">https://github.com/WooVictory/SOPT_22th_Seminar3_HomeWork</a></p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/05/05/sopt-seminar3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/24/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/26/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 25 of 28</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
