
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>Archives - VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/archives/23/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/12/java-basic-7/"
                            aria-label=": [Java] 7. 제어자"
                        >
                            [Java] 7. 제어자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-12T17:14:53+09:00">
	
		    Aug 12, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ul>
<li><strong>제어자</strong>는 클래스와 멤버 선언 시 사용해 부가적인 의미를 부여하는 키워드.
<ul>
<li>접근 제어자 : 두 개 이상 사용 불가.</li>
<li>기타 제어자 : 여러 개 함께 사용 가능.</li>
</ul>
</li>
</ul>
<h1 id="접근-제어자"># 접근 제어자</h1>
<ul>
<li>정보 은닉을 위해 접근 제어자 기능을 제공한다.
<ul>
<li><strong>정보 은닉</strong> : 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야 한다는 개념.</li>
</ul>
</li>
<li>클래스 외부에서의 직접적인 접근을 허용하지 않는 멤버를 설정해 정보 은닉을 구체화할 수 있다.</li>
</ul>
<p>자바에서는 다음과 같은 네 가지의 접근 제어자를 제공한다.</p>
<ol>
<li>private</li>
<li>public</li>
<li>default</li>
<li>protected</li>
</ol>
<p><strong>1. private</strong></p>
<p><strong>private 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부에 공개되지 않으며, 외부에서는 직접 접근할 수 없다.</li>
<li>자바 프로그램은 private 멤버에 직접 접근할 수 없으며,<br>
해당 객체의 <strong>public 메소드</strong>를 통해서만 접근할 수 있다.<br>
따라서 private 멤버는 public 인터페이스를 직접 구성하지 않고, 클래스 내부의 세부적인 동작을 구현하는데 사용된다.</li>
</ul>
<img src="/img/private.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name =<span class="string">"이승우"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>private 멤버는 해당 멤버를 선언한 클래스에서만 접근할 수 있다.</li>
<li>다른 클래스에서 Person 클래스의 name에 접근하고자 할 때는 2와 같이 Person 클래스에 <strong>public</strong>으로 메소드를 선언하여 private로 선언된 name에 접근할 수 있다.</li>
<li>1과 같이 메소드를 private로 선언하게 된다면, 다른 클래스에서 Person 클래스의 name에 접근할 수 없다.</li>
</ul>
<p><strong>2. public</strong></p>
<p><strong>public 접근 제어자</strong>를 사용하여 선언된 클래스 멤버는</p>
<ul>
<li>외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있다.</li>
<li>자바 프로그램은 public 메소드를 통해서만 해당 객체의 private 멤버에 접근할 수 있다. public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행한다.</li>
</ul>
<img src="/img/public.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EveryWhere</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String var = <span class="string">"누구든지 허용"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. default(package-private)</strong></p>
<ul>
<li>클래스 및 클래스 멤버의 접근 제어 기본값으로 <strong>default 접근 제어자</strong>를 사용한다.</li>
<li>접근 제어자가 지정되지 않으면 default 접근 제어자를 자동으로 갖는다.</li>
</ul>
<p>default 접근 제어를 가지는 멤버는</p>
<ul>
<li>같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있습니다.</li>
<li>상속 관계에 있더라도 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<img src="/img/default.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지만 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamePackage</span></span>&#123;</span><br><span class="line">    String sameVar = <span class="string">"같은 패키지는 허용"</span>; <span class="comment">// default 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">같은 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    String var = <span class="string">"다른 패키지는 접근 불가"</span>; <span class="comment">// 1 : default 필드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SamePackage sp = <span class="keyword">new</span> SamePackage();</span><br><span class="line">        System.out.println(sp.sameVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1에서 var 변수는 다른 패키지에서는 접근할 수 없다.</li>
</ul>
<p><strong>4. protected</strong></p>
<p>자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축한다. 여기에 부모 클래스(parent class)와 관련된 접근 제어자가 하나 더 존재한다.</p>
<p><strong>protected 멤버는</strong></p>
<ul>
<li>부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급됩니다.</li>
<li>상속 관계에 있을 경우 다른 패키지에서도 접근 가능.</li>
<li>상속 관계가 아닌 경우 다른 패키지에서 접근 불가능.</li>
</ul>
<p>클래스의 protected 멤버에 접근할 수 있는 영역은 다음과 같다.</p>
<ol>
<li>이 멤버를 선언한 클래스의 멤버</li>
<li>이 멤버를 선언한 클래스가 속한 패키지의 멤버</li>
<li>이 멤버를 선언한 클래스를 상속받은 자식 클래스(child class)의 멤버</li>
</ol>
<img src="/img/protected.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">같은 패키지는 접근 허용</span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String sameVar = <span class="string">"다른 패키지에 속하는 자식 클래스까지 허용"</span>;</span><br><span class="line">    <span class="comment">// protected 필드</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">다른 패키지에 속하는 자식 클래스도 접근 허용</span><br><span class="line"><span class="keyword">package</span> test.other;</span><br><span class="line"><span class="keyword">import</span> test.SameClass;</span><br><span class="line"><span class="comment">// test 패키지의 SameClass 클래스를 불러들여 포함시킴</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">SameClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SameClass sameClass = <span class="keyword">new</span> SameClass();</span><br><span class="line">        System.out.println(sameClass.sameVar);</span><br><span class="line">        <span class="comment">// 다른 패키지에 속하는 자식 클래스까지 허용</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="접근-제어자의-접근-범위"># 접근 제어자의 접근 범위</h2>
<p>자바에서 접근 제어자의 접근 범위가 보다 많은 제어자부터 적은 제어자 순으로 나열하면 다음과 같다.<br>
자바에서는 클래스나 멤버를 선언할 때, 접근을 허용할 범위에 맞는 접근 제어자를 선택하는 것이 매우 중요하다.</p>
<p>public -&gt; protected -&gt; default -&gt; private</p>
<img src="/img/range.png" width="600" height="200">
<h1 id="기타-제어자"># 기타 제어자</h1>
<p>기타 제어자의 종류로는 다음과 같습니다.</p>
<ol>
<li>final 제어자</li>
<li>static 제어자</li>
<li>abstract 제어자</li>
</ol>
<p><strong>1.final</strong></p>
<ul>
<li><strong>final 제어자</strong>는 '변경할 수 없다’는 의미로 사용된다.</li>
<li>즉, 필드나 지역 변수에 사용하면 값을 변경할 수 없는 <code>상수(constant)</code>가 된다.</li>
<li>클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없다.</li>
<li>메소드에 사용하면 오버라이딩을 통한 재정의를 할 수 없다.</li>
<li>자바에서 final 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드, 필드, 지역 변수</li>
</ul>
</li>
</ul>
<p>?? 어디지??<br>
<code>메소드 오버라이딩</code>이란 상속받은 부모 클래스의 메소드를 재정의하여 사용하는 것을 의미합니다.</p>
<p>자바에서는 상속이라는 것을 통해 다른 클래스의 private 멤버를 제외한 모든 메소드를 상속받을 수 있습니다. 이렇게 상속받은 메소드는 그대로 사용해도 되고, 필요한 동작을 위해 <strong>재정의</strong>하여 사용할 수도 있습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> VAR; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> MAX_NUM = <span class="number">10.2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : Car 클래스는 <strong>상속을 통해 서브 클래스를 생성할 수 없다.</strong><br>
2 : VAR 필드는 <strong>상수화</strong>되어 값을 변경할 수 없다.<br>
3 : 이 메소드는 오버라이딩을 통해 재정의할 수 없다.<br>
4 : 이 지역 변수는 상수화되어 값을 변경할 수 없다.</p>
<p><strong>2.static</strong></p>
<ul>
<li>변수에 static 제어자를 사용하면 클래스 변수가 된다.</li>
<li>메소드에 static 제어자를 사용하면 클래스 메소드가 된다.</li>
<li>특징
<ol>
<li>프로그램 시작시 최초에 단 한 번만 생성되고 초기화 된다.</li>
<li>인스턴스를 생성하지 않고도 바로 사용할 수 있다.</li>
<li>해당 클래스의 모든 인스턴스가 공유한다.</li>
</ol>
</li>
<li>자바에서 static 제어자를 사용할 수 있는 대상은 다음과 같습니다.
<ul>
<li>메소드, 필드, 초기화 블록</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> var; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">static</span>&#123; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>&#123; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 클래스 필드(static 변수) - Car 클래스의 인스턴스들이 공유한다.<br>
2 : static 초기화 블록으로 보통 클래스 필드의 초기화를 진행<br>
3 : 클래스 메소드(static 메소드)</p>
<p><strong>3.abstract</strong></p>
<ul>
<li>abstract 제어자는 '추상적인’이라는 의미로 사용된다.</li>
<li>선언부만 있고 구현부가 없는 메소드를 <strong>추상 메소드</strong>라 하며, 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>하나 이상의 추상 메소드를 포함하고 있는 추상 클래스도 반드시 <code>abstract</code> 제어자를 붙여야 한다.</li>
<li>자바에서 abstract 제어자를 사용할 수 있는 대상은 다음과 같다.
<ul>
<li>클래스, 메소드</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">break</span><span class="params">()</span></span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1 : 추상 클래스<br>
2 : 추상 메소드</p>
<h2 id="제어자의-조합"># 제어자의 조합</h2>
<ul>
<li>접근 제어자와 기타 제어자를 한 대상에 사용할 수 있다.</li>
<li>모든 경우가 가능한 것은 아니며 대상에 따라 조금 다르다.</li>
</ul>
<img src="/img/combination_2.png" width="500" height="200">
<ol>
<li>
<p>클래스에서 final과 abstract는 함께 사용할 수 없다.<br>
<strong>final</strong> 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, <strong>abstract</strong> 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용할 수 있으므로, 상반된 이 두 제어자는 클래스에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 static과 abstract는 함께 사용할 수 없다.<br>
<strong>abstract</strong> 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, <strong>static</strong> 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private과 abstract는 함께 사용할 수 없다.<br>
: <strong>abstract</strong> 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, <strong>private</strong> 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없다.</p>
</li>
<li>
<p>메소드에 private와 final은 함께 사용할 필요가 없다.<br>
메소드에 사용된 <strong>final</strong> 제어자와 <strong>private</strong> 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없게 된다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있습니다.</p>
</li>
</ol>
<blockquote>
<p>private 제어자를 사용한 메소드에는 자식 클래스가 접근할 수 없으므로 메소드 오버라이딩을 통한 재정의를 할 수 없다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/12/java-basic-7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/10/java-basic-6/"
                            aria-label=": [Java] 6. 메소드와 생성자"
                        >
                            [Java] 6. 메소드와 생성자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-10T15:31:15+09:00">
	
		    Aug 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="메소드"># 메소드</h1>
<ul>
<li>클래스의 멤버 중 기능을 표현하는 <strong>메소드</strong></li>
<li>특정 작업을 수행하기 위한 명령문의 집합</li>
<li>중복되는 코드의 작성을 피할 수 있다.</li>
<li>모듈화로 인해 가독성이 좋아진다.</li>
<li>유지보수 또한 쉽다.</li>
</ul>
<blockquote>
<p>메소드를 작성할 때는 되도록 하나의 메소드가 하나의 기능만을 수행하도록 작성하는 것이 좋다.</p>
</blockquote>
<p><strong>메소드의 정의 및 호출</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSpeed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accelerationTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accelerate</span><span class="params">(<span class="keyword">int</span> speed, <span class="keyword">int</span> second)</span></span>&#123; <span class="comment">// 선언부</span></span><br><span class="line">        System.out.println(second + <span class="string">"초간 속도를 시속 "</span> + speed + <span class="string">"(으)로 가속함!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();<span class="comment">// 객체 생성</span></span><br><span class="line">    myCar.acceleratea(<span class="number">60</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 메소드 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>메소드 시그니처</strong>란 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킨다.<br>
만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면 이 두 메소드의 시그니처는 같다고 할 수 있다.</li>
<li>메소드를 호출할 때 멤버 참조 연산자(.)를 사용하여 호출한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 객체참조변수이름.메소드이름(); <span class="comment">// 매개변수가 없는 메소드의 호출</span></span><br><span class="line"><span class="number">2</span>. 객체참조변수이름.메소드이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...); <span class="comment">// 매개변수가 있는 메소드의 호출</span></span><br></pre></td></tr></table></figure>
<h1 id="생성자"># 생성자</h1>
<p>클래스로부터 객체를 생성하면 해당 객체는 즉시 메모리에 생성된다.<br>
하지만 이 객체는 모든 인스턴스 변수가 초기화되지 않은 상태이다.<br>
클래스 변수와 인스턴스 변수를 별도로 초기화하지 않으면 타입에 맞는 값으로 자동 초기화된다.</p>
<p>사용자가 원하는 값으로 인스턴스 변수를 초기화하려면 일반적인 초기화 방식으로는 할 수 없다. private 변수도 있기 때문이다.<br>
따라서 private 인스턴스 변수에도 접근할 수 있는 초기화만을 위한 <strong>public</strong> 메소드가 필요하다.</p>
<p>초기화만을 위한 메소드는 객체가 생성된 후부터 사용되기 전까지 반드시 인스턴스 변수의 초기화를 위해 호출되어야 한다.</p>
<p>자바에서 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 <code>생성자(constructor)</code>라는 메소드를 제공한다. <strong>생성자의 이름은 해당 클래스의 이름과 같아야 한다.</strong></p>
<ol>
<li><strong>생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.</strong></li>
<li>생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.</li>
<li>객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, <strong>메소드 오버로딩</strong>이 가능하다.</li>
<li>생성자는 인스턴스 생성 시 딱 한번 호출되는 메소드이다.</li>
<li>return문도 정의되어 있지 않다.</li>
</ol>
<p><strong>생성자의 선언</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 클래스이름()&#123; ... &#125; <span class="comment">// 매개변수가 없는 생성자 선언</span></span><br><span class="line"><span class="number">2</span>. 클래스이름(인수<span class="number">1</span>,인수<span class="number">2</span>, ...)&#123; ... &#125; <span class="comment">// 매개변수가 있는 생성자 선언</span></span><br></pre></td></tr></table></figure>
<p><strong>생성자의 호출</strong></p>
<ul>
<li><strong>new</strong> 키워드를 사용하여 객체를 생성할 때 자동으로 생성자가 호출된다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 생성자</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 객체 생성 및 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="기본-생성자">기본 생성자</h2>
<p>모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다. 하지만, <strong>특별히 생성자를 정의하지 않고도 인스턴스를 생성할 수 있다.</strong> 자바 컴파일러가 <code>기본 생성자(default constructor)</code>를 기본적으로 제공해주기 때문이다.</p>
<ul>
<li>기본 생성자는 매개변수를 하나도 가지지 않으며, 아무런 명령어도 포함하고 있지 않다.</li>
<li>자바 컴파일러가 컴파일 시 클래스에 생성자가 하나도 정의되어 있지 않으면, 자동으로 기본 생성자를 추가한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">기본생성자 : 클래스이름()&#123;&#125; </span><br><span class="line">예시 : Car()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>위와 같이 기본 생성자는 어떠한 매개변수도 전달받지 않으며, 기본적으로 아무런 동작도 하지 않는다. 다음 코드는 Car 클래스에 생성자를 정의하지 않고, 기본 생성자를 호출하는 코드이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(); <span class="comment">// 기본 생성자의 호출</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 Car 클래스의 객체인 myCar는 기본 생성자를 호출하여 생성된다. Car 클래스에 기본 생성자가 존재하지 않는다. 기본 생성자가 없을 경우 자바 컴파일러가 컴파일 시 자동으로 생성해준다.</p>
<p>기본 생성자는 아무 동작도 하지 않는다. 따라서 인스턴스 변수를 클래스 필드에서 바로 초기화할 수 있다. <strong>인스턴스 변수의 초기화는 생성자를 사용하거나 클래스 필드에서 수행할 수 있다.</strong></p>
<p>만약 매개변수를 가지는 생성자를 하나라도 정의했다면, 기본 생성자는 자동으로 추가되지 않는다. 따라서 매개변수를 가지는 생성자를 하나 이상 정의한 후 기본 생성자를 호출하면, 오류가 발생한다. 이 경우에는 기본 생성자를 직접 추가해줘야 한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Practice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car(<span class="number">3242</span>, <span class="string">"아반떼"</span>); <span class="comment">// 2. 객체 생성 및 생성자의 호출</span></span><br><span class="line">        Car yourCar = <span class="keyword">new</span> Car(); <span class="comment">// 3. 기본 생성자의 호출 -&gt; 오류 발생</span></span><br><span class="line">        System.out.println(myCar.getModel()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 갖는 생성자를 정의하고 있다. 따라서 자바 컴파일러는 Car 클래스에 기본 생성자를 추가하지 않는다.</li>
<li>3번에서 기본 생성자를 호출하여 인스턴스를 생성하려고 한다. 자바 컴파일러가 오류를 발생시킨다. 오류를 발생을 없애기 위해서는 Car 클래스에 기본 생성자를 추가하면 된다.</li>
</ul>
<h1 id="this와-this"># this와 this()</h1>
<ul>
<li>this 참조 변수 : <strong>인스턴스가 바로 자기 자신을 참조하는데 사용하는 변수이다.</strong> this 참조 변수는 해당 인스턴스의 주소를 가리키고 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 생성자의 매개변수 이름과 인스턴스 변수의 이름이 같을 경우에는 <strong>인스턴스 변수 앞에 this 키워드를 붙여 구분해야 한다.</strong></p>
<p>자바에서는 this 참조 변수를 사용하여 인스턴스 변수에 접근할 수 있다. this 참조 변수를 사용할 수 있는 영역은 인스턴스 메소드뿐이며, 클래스 메소드에서는 사용할 수 없다. 모든 인스턴스 메소드에는 this 참조 변수가 숨겨진 지역 변수로 존재하고 있다.</p>
<ul>
<li>this() 메소드 : <strong>this() 메소드는 생성자 내부에서만 사용할 수 있으며, 같은 클래스의 다른 생성자를 호출할 때 사용한다.</strong> this() 메소드에 인수를 전달하면 생성자 중에서 메소드 시그니처가 일치하는 다른 생성자를 찾아 호출해줍니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1234</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"소나타"</span>;</span><br><span class="line"></span><br><span class="line">    Car(<span class="keyword">int</span> number, String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Car()&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">33</span>,<span class="string">"그랜져"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number+<span class="string">"년식의 "</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Car myCar = <span class="keyword">new</span> Car();</span><br><span class="line">    System.out.println(myCar.getModel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>매개변수를 가지는 생성자는 this 참조 변수를 사용하여 인스턴스 변수에 접근한다.</li>
<li>또한, 매개변수를 가지지 않은 기본 생성자는 내부에서 this() 메소드를 사용하여 매개 변수를 가진 생성자를 호출한다.</li>
<li>이처럼 내부적으로 다른 생성자를 호출하여 인스턴스 변수를 초기화할 수 있다.</li>
</ul>
<blockquote>
<p>단, 한 생성자에서 다른 생성자를 호출할 때는 반드시 해당 생성자의 첫 줄에서만 호출할 수 있습니다.</p>
</blockquote>
<h1 id="메소드-오버로딩"># 메소드 오버로딩</h1>
<ul>
<li>핵심은 <code>메소드 시그니처</code>
<ul>
<li>메소드 시그니처 : 메소드의 선언부에 명시되는 매개변수의 리스트를 말한다.</li>
<li>두 메소드의 매개변수의 개수와 타입, 그 순서까지 모두 같다면 두 메소드의 시그니처는 같다고 할 수 있다.</li>
</ul>
</li>
<li><strong>메소드 오버로딩</strong>은 같은 이름의 메소드를 매개변수의 개수와 타입을 다르게하여(중복) 정의하는 것이다.</li>
</ul>
<p><strong>즉, 메소드 오버로딩은 서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의하는 것이다.</strong></p>
<p>메소드 오버로딩을 통해 메소드에 사용되는 이름을 절약할 수 있다.<br>
또한, 메소드를 호출할 때 전달할 매개변수의 타입이나 개수에 대해 신경 쓰지 않아도 된다. <strong>메소드 오버로딩은 OOP의 특징 중 하나인 다형성의 한 예다.</strong></p>
<ul>
<li>메소드 오버로딩의 대표적인 예 : <code>println()</code>
<ul>
<li>전달받은 매개변수의 타입에 따라 다양한 원형 중 적절한 원형을 호출한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">메소드 원형</span><br><span class="line"><span class="number">1</span>. println()</span><br><span class="line"><span class="number">2</span>. println(<span class="keyword">boolean</span> x)</span><br><span class="line"><span class="number">3</span>. println(<span class="keyword">char</span> x)</span><br><span class="line"><span class="number">4</span>. println(<span class="keyword">char</span>[] x)</span><br><span class="line"><span class="number">5</span>. println(<span class="keyword">double</span> x)</span><br><span class="line"><span class="number">6</span>. println(<span class="keyword">float</span> x)</span><br><span class="line"><span class="number">7</span>. println(<span class="keyword">int</span> x)</span><br><span class="line"><span class="number">8</span>. println(<span class="keyword">long</span> x)</span><br><span class="line"><span class="number">9</span>. println(Object x)</span><br><span class="line"><span class="number">10</span>. println(String x)</span><br></pre></td></tr></table></figure>
<p><strong>메소드 오버로딩의 조건</strong></p>
<ol>
<li>메소드의 이름이 같아야 한다.</li>
<li>메소드의 시그니처 즉, 매개변수의 개수와 타입이 달라야 한다.</li>
</ol>
<ul>
<li><strong>메소드 오버로딩은 반환 타입과는 관계가 없다.</strong></li>
<li><strong>메소드의 시그니처는 같은데 반환 타입만이 다른 경우에는 오버로딩이 성립하지 않는다.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">// 전달받은 숫자 그대로 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1)</span></span>&#123; </span><br><span class="line">        System.out.println(num1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 두 정수의 곱 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1*num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 정수와 실수의 합 출력</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        System.out.println(num1+num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Test test = <span class="keyword">new</span> Test();</span><br><span class="line">    test.display(<span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">// 2</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="number">3.14</span>); <span class="comment">// 3</span></span><br><span class="line">    test.display(<span class="number">10</span>,<span class="string">'a'</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>컴파일러는 사용자가 오버로딩된 함수를 호출하면 같은 메소드 시그니처를 갖는 메소드를 찾아서 호출한다.</li>
</ul>
<p>4번에서 문제가 발생한다. 자바에서 char형 데이터는 int형 뿐만 아니라 double형으로도 타입 변환될 수 있기 때문이다.</p>
<p>이 호출은 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출해야 할 지 불명확하다. 자바에서는 오버로딩한 메소드의 이러한 모호한 호출을 허용하지 않으며, 위와 같은 경우에는 <strong>더 작은 표현 범위를 가지는 int형으로 자동 타입 변환된다.</strong></p>
<p>4번 라인의 display() 메소드 호출은 영문 소문자 'a’의 아스키 코드값이 97이므로, int형으로 자동 타입 변환되어 두 수의 곱이 출력된다.</p>
<h1 id="재귀-호출"># 재귀 호출</h1>
<ul>
<li><code>재귀 호출(recursive call)</code>이란 메소드 내부에서 해당 메소드가 또 다시 호출되는 것을 의미한다.</li>
<li><strong>메소드 내에 재귀 호출을 중단하도록 조건이 변경된 명령문을 반드시 포함해야 한다.</strong></li>
</ul>
<p><strong>재귀 호출의 개념</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        result+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>재귀 호출을 사용하지 않고 반복문으로 만든 메소드이다.</li>
<li>규칙</li>
</ul>
<ol>
<li>1부터 4까지의 합은 1부터 3까지의 합에 4를 더하면 됩니다.</li>
<li>1부터 3까지의 합은 1부터 2까지의 합에 3을 더하면 됩니다.</li>
<li>1부터 2까지의 합은 1부터 1까지의 합에 2를 더하면 됩니다.</li>
<li>1부터 1까지의 합은 그냥 1입니다.</li>
</ol>
<p>위의 알고리즘을 의사코드(psedo code)로 작성하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">시작</span><br><span class="line">    <span class="number">1</span>. n이 <span class="number">1</span>이 아니면, n과 <span class="number">1</span>부터 (n-<span class="number">1</span>)까지의 합을 더한 값을 반환함</span><br><span class="line">    <span class="number">2</span>. n이 <span class="number">1</span>이면, 그냥 <span class="number">1</span>을 반환함</span><br><span class="line">끝</span><br></pre></td></tr></table></figure>
<blockquote>
<p>의사 코드(psedo code)란 특정 프로그래밍 언어의 문법에 맞춰 작성된 것이 아닌, 일반적인 언어로 알고리즘을 표현한 코드를 말한다.</p>
</blockquote>
<p>의사 코드로 작성하고 바로 코드로 옮겨서 재귀 호출을 구현한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursiveSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">// n이 1이면, 그냥 1을 반환</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> n+recursiveSum(n-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// n이 1이 아니면, n을 1부터 (n-1)까지의 합과 더한 값을 반환</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if 문이 존재하지 않으면, 이 프로그램은 실행 직후 <code>스택 오버플로우(stack overflow)</code>에 의해 종료될 것이다. 따라서 if문처럼 재귀 호출을 중단하기 위한 조건문을 반드시 포함해야 한다.</p>
<blockquote>
<p>스택 오버플로우는 메모리 구조 중 스택 영역에서 해당 프로그램이 사용할 수 있는 메모리 공간 이상을 사용하려고 할 때 발생한다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/10/java-basic-6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/10/open-tutorials-8/"
                            aria-label=": 생활코딩 :: supervisor"
                        >
                            생활코딩 :: supervisor
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-10T10:51:48+09:00">
	
		    Aug 10, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="supervisor">supervisor</h1>
<p>우리가 자바스크립트 코드를 수정하면 node가 이것을 알아서 감지하지 못합니다. 그래서 우리는 코드를 수정하고 서버를 껐다 켜야 하는 번거로운 작업을 수행하고 변경된 내용이 반영되는 것을 확인할 수 있습니다.</p>
<p>이러한 작업은 이미 실행된 프로그램이 루프를 계속 돌고 있기 때문에 우리가 변경한 내용이 반영되지 않는 것입니다.</p>
<ul>
<li>watch : 변경된 사항을 보고 있다가 변경이 일어났을 때 자동으로 node를 내부적으로 껐다가 키는 것</li>
</ul>
<p>먼저, npm install supervisor -g 를 통해서 전역적으로 설치한 후</p>
<p><code>supervisor app.js</code>를 통해 코드를 수행하면 app.js가 실행이 되고 app.js의 코드를 수정하고 변경된 사항을 저장하면 아래와 같이 서버가 자동으로 꺼졌다가 켜지는 것을 확인할 수 있습니다.</p>
<img src="/img/app_js.png" width="400" height="200">

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/10/open-tutorials-8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/09/java-basic-5/"
                            aria-label=": [Java] 5. 클래스"
                        >
                            [Java] 5. 클래스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-09T19:11:44+09:00">
	
		    Aug 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="객체지향-프로그래밍oop"># 객체지향 프로그래밍(OOP)</h1>
<p>객체 지향 프로그래밍(Object-Oriented Programming)에서는 모든 데이터를 <strong>객체</strong>로 취급하며, 객체가 바로 프로그래밍의 중심이 된다.</p>
<p><strong>프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.</strong><br>
상태 -&gt; Property로 정의.<br>
행위 -&gt; Method로 정의.</p>
<p><strong>장점</strong></p>
<ul>
<li>코드 재사용성이 높다.
<ul>
<li>만들어 놓은 클래스를 가져와 사용할 수 있고, 상속을 통해 확장하여 사용할 수 있다.</li>
</ul>
</li>
<li>유지보수가 쉽다.
<ul>
<li>수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메소드로 있기 때문에 해당 부분만 수정하면 된다.</li>
</ul>
</li>
<li>대형 프로젝트에 적합하다.
<ul>
<li>클래스 단위로 모듈화시켜 개발할 수 있으므로 업무 분담이 쉽다.</li>
</ul>
</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>실행 처리 속도가 상대적으로 느리다.</li>
<li>객체가 많으면 용량이 커질 수 있다.</li>
<li>설계시 많은 시간과 노력이 필요하다.</li>
</ul>
<h1 id="클래스와-인스턴스"># 클래스와 인스턴스</h1>
<p><strong>클래스</strong><br>
어떤 문제를 해결하이 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 <strong>변수와 메소드</strong>로 정의한 것이다.</p>
<p><strong>인스턴스</strong><br>
클래스에서 정의한 것을 토대로 <strong>실제 메모리상에 할당된 것</strong>으로 실제 프로그램에서 사용되는 데이터이다.</p>
<p>독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있다.<br>
하지만 해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유하게 된다.</p>
<h1 id="메소드"># 메소드</h1>
<p>클래스는 멤버로 속성을 표현하는 필드와<br>
기능을 표현하는 <strong>메소드</strong>를 갖는다.<br>
메소드는 특정 작업을 수행하기 위한 명령문의 집합.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시</li>
<li>반환 타입 : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시</li>
<li>메소드 이름 : 메소드를 호출하기 위한 이름을 명시</li>
<li>매개변수 목록 : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시</li>
<li>구현부: 메소드의 고유 기능을 수행하는 명령문의 집합</li>
</ol>
<p>자바에서 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다.<br>
하지만, <code>메소드 오버로딩(overloading)</code>을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다.</p>
<p><strong>메소드 오버로딩</strong></p>
<p>매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다.</p>
<p>메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다.<br>
또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 된다.</p>
<h1 id="클래스의-구성-요소"># 클래스의 구성 요소</h1>
<p>클래스의 멤버<br>
필드 : 속성을 표현<br>
메소드 : 기능을 표현<br>
생성자 : 객체의 필드를 초기화하는 메소드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123; <span class="comment">// 클래스 이름</span></span><br><span class="line">    <span class="keyword">private</span> String modelName; <span class="comment">// 필드</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelYear; <span class="comment">// 필드</span></span><br><span class="line"></span><br><span class="line">    Car(String modelName, <span class="keyword">int</span> modelYear)&#123; <span class="comment">// 생성자</span></span><br><span class="line">        <span class="keyword">this</span>.modelName = modelName;</span><br><span class="line">        <span class="keyword">this</span>.modelYear = modelYear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span></span>&#123; <span class="comment">// 메소드</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.modelYear+<span class="string">"년식 "</span>+<span class="keyword">this</span>.modelName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>필드(field)</code>
<ul>
<li>클래스에 포함된 <strong>변수</strong>를 의미한다. 클래스 내에 선언된 위치에 따라서 다음과 같이 구분된다.</li>
</ul>
</li>
</ul>
<ol>
<li>클래스 변수(static variable)</li>
<li>인스턴스 변수(instance variable)</li>
<li>지역 변수(local variable)</li>
</ol>
<p><a href="https://woovictory.github.io/2018/08/06/java-basic-algorithm/">Java :: 기초에서 확인가능합니다.</a></p>
<ul>
<li>
<p><code>메소드(method)</code></p>
<ul>
<li>특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있으며, 중복되는 코드의 반복적인 프로그래밍을 피할 수 있게 된다.</li>
<li>유지보수가 용이하다.</li>
</ul>
</li>
<li>
<p><code>생성자(constructor)</code></p>
<ul>
<li>클래스를 가지고 객체를 생성하면, 해당 객체는 메모리에 즉시 생성된다. 하지만 이렇게 생성된 객체는 모든 인스턴스 변수가 아직 초기화되지 않은 상태이다.</li>
<li>객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 <strong>초기화</strong>할 수 있는 <code>생성자(constructor)</code>라는 메소드를 제공한다. 자바에서 <strong>생성자의 이름은 클래스의 이름과 같아야 한다.</strong></li>
</ul>
</li>
</ul>
<h1 id="클래스의-선언"># 클래스의 선언</h1>
<img src="/img/class.png" width="600" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">클래스이름 객체참조변수이름; <span class="comment">// 1</span></span><br><span class="line">Car myCar; </span><br><span class="line"></span><br><span class="line">객체참조변수이름 = <span class="keyword">new</span> 클래스이름(); <span class="comment">// 2</span></span><br><span class="line">myCar = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">클래스이름 객체참조변수이름 = <span class="keyword">new</span> 클래스이름(); <span class="comment">// 3</span></span><br><span class="line">Car myCar = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>
<p>1번 : 객체 참조 변수 선언<br>
2번 : 객체를 생성한다.(메모리상에 할당된다.) 객체의 주소를 미리 선언한 참조 변수에 저장한다.<br>
3번 : 선언과 동시에 생성한다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/09/java-basic-5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/09/open-tutorials-7/"
                            aria-label=": 생활코딩 :: POST"
                        >
                            생활코딩 :: POST
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-09T18:37:01+09:00">
	
		    Aug 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="get-vs-post">Get vs Post</h1>
<hr>
<p>서버와 웹 브라우져가 상호작용하는 과정에서 크게 보면 두 가지 방법이 있습니다.</p>
<ul>
<li>
<p>GET : 우리가 지금까지 웹 브라우져에서 웹 서버로 정보를 요청할 때 사용한 방식이며, 기본 방법입니다.</p>
<ul>
<li>기본적으로 웹 브라우저에 주소를 입력해서 정보를 가져오는 것은 <code>get</code> 방식입니다.</li>
<li>쿼리스트링을 사용하는 방법 역시 정보를 가져오는 것이기 때문에 <code>get</code> 방식입니다.</li>
<li>즉, 우리가 서버에게 어떠한 정보를 요청해서 가져오는 방식을 말합니다.</li>
</ul>
</li>
<li>
<p>POST : 사용자의 정보를 서버로 전송할 때는 POST 방식을 사용합니다.</p>
</li>
</ul>
<h1 id="form">form</h1>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">        meta(charset=<span class="string">'utf-8'</span> method=<span class="string">"get"</span>)</span><br><span class="line">    body</span><br><span class="line">        form(action=<span class="string">"/form_receiver"</span>)</span><br><span class="line">            p</span><br><span class="line">                input(type =<span class="string">"text"</span>, name=<span class="string">'title'</span>)</span><br><span class="line">            p</span><br><span class="line">                textarea(name=<span class="string">'description'</span>)</span><br><span class="line">            p</span><br><span class="line">                input(type=<span class="string">"submit"</span>)</span><br></pre></td></tr></table></figure>
<p>form을 이용해서 '/form_receiver’에 해당되는 url을 생성해주었고 사용자가 입력한 title과 description은 제출 버튼을 누르면 해당 url을 통해서 서버로 값을 보내줍니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/form_receiver'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title = req.query.title;</span><br><span class="line">    <span class="keyword">var</span> description = req.query.description;</span><br><span class="line">    res.send(title+<span class="string">", "</span>+description);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>지금까지 한 것은 get 방식입니다. post 방식은 url을 통해서 데이터 즉 값을 보내지 않습니다.</p>
<h1 id="post">Post</h1>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/form_receiver'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"Hello, GET"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/form_receiver'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">"Hello, POST"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>사용자가 <strong>Post</strong> 방식으로 데이터를 전송하면 우리는 Post라는 메소드에 Controller를 연결시켜서 실행시킬 수 있습니다. form.jade 파일의 form 태그에서 method를 get인지 post인지 지정함에 따라서 사용자의 요청은 get과 post로 나뉘어 질 수 있고, 이러한 요청이 서버로 들어오게 되면 각각에 맞는 라우터에 걸려서 해당 익명 함수 즉, Controller의 동작을 수행할 수 있습니다.</p>
<blockquote>
<p>그러면 post 방식으로 전송했을 때, post 방식으로 전송한 데이터를 우리 애플리케이션에서는 어떻게 받을 수 있을까요??</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/form_recevier'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title = req.body.title;</span><br><span class="line">    <span class="keyword">var</span> description = req.body.description;</span><br><span class="line">    res.send(title+<span class="string">", "</span>+description+<span class="string">"in Post"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Post 방식에서는 get 방식과는 다르게 <code>body</code>라는 객체를 통해서 사용자가 전송한 값을 받을 수 있습니다. 하지만, 코드를 실행하고 서버를 킨 다음에 테스트를 해보면 에러를 만날 수 있습니다.</p>
<p>기본적으로 post 방식으로 전달된 데이터는 정의되어 있지 않습니다. 이 데이터를 사용하려면 <code>body-parser</code>나 <code>multer</code>와 같은 <strong>mmiddleware</strong>를 설치해야 합니다.</p>
<ul>
<li>body-parser : post 방식으로 전송한 데이터를 우리의 애플리케이션에서 사용할 수 있도록 해주는 일종의 plug-in 또는 확장 기능이라고 생각하면 됩니다. body-parser를 우리의 애플리케이션에 포함시켜서 작동하도록 하면 우리는 req 객체 안의 body 객체를 사용할 수 있습니다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span>&#125;))</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/form_recevier'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title = req.body.title;</span><br><span class="line">    <span class="keyword">var</span> description = req.body.description;</span><br><span class="line">    res.send(title+<span class="string">", "</span>+description+<span class="string">"in Post"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>위의 코드를 통해서 npm을 통해서 우리 프로젝트에 포함시킨 <code>body-parser</code>란 모듈을 가져올 수 있습니다.</li>
<li>우리가 가져온 body-parser란 모듈을 애플리케이션 객체에 use를 하면 이 모듈을 붙이는 것입니다. 즉, application 객체에 body-parser라는 모듈을 붙이는 것입니다.</li>
<li>그리고 앞으로 이 애플리케이션으로 들어오는 모든 요청들은 <code>body-parser</code>라는 <strong>미들웨어</strong>를 먼저 통과한 다음에 라우터가 동작하게 됩니다.</li>
<li>제일 앞쪽에서 body-parser가 항상 대기하고 있다가 사용자 요청이 들어오면 body-parser가 동작하면서 사용자가 포스트 방식으로 전송한 데이터를 우리가 사용할 수 있도록 하는 역할을 합니다.</li>
</ul>
<p>정리하자면, <code>body-parser</code>라는 모듈을 추가했고, 이 body-parser라는 모듈을 우리의 애플리케이션에 <strong>user</strong>라는 메소드를 통해서 연결시켰습니다. 그러면 사용자에게서 들어오는 모든 요청들이 있을 때 <strong>body-parser</strong>가 제일 먼저 실행됩니다. 그러면 body-parser가 실행이 될 때, body-parser는 사용자가 post 방식으로 전송한 데이터가 있다면 애플리케이션 안에서 req 객체가 원래 가지고 있지 않았던 body라는 객체를 body-parser가 추가합니다. 그리고 사용자가 전송한 데이터의 이름이 title이라면 body라는 객체에 title이라는 프로퍼티에 그 값을 넣어서 사용자에게 제공합니다.</p>
<h1 id="get과-post의-용도">Get과 Post의 용도</h1>
<hr>
<ul>
<li>
<p>get<br>
:  어떤 정보에 대한 주소를 나타낼 때는 url 상에 모든 정보를 포함시켜야 합니다.</p>
</li>
<li>
<p>post<br>
: 사용자가 id와 password를 입력해서 서버에서 전송해야 하는 경우라면 get 방식을 이용하게 된다면 url 상에 정보가 나타나게 됩니다. 하지만, 이 경우 우리의 id와 password가 노출될 위험이 있기 때문에 이러한 정보는 url 상에 정보가 표시되지 않는 방식인 post 방식을 사용해야 합니다.</p>
</li>
</ul>
<p>하지만, 본질적으로 get 방식이건 post 방식이건 어떤 데이터가 전송되는가라는 것을 얻어내는 노력의 난이도가 조금 다를 뿐이지 본질적으로 다 알아낼 수 있기 때문에 post 방식이 get 방식보다 충분히 안전하다고 할 수 없고 둘 다 불안전합니다. 중간에 누군가가 데이터를 가로채지 못하게 하는 것은 다른 방법이 필요합니다.<br>
ex. https(ssl)</p>
<p>또 하나는 url을 통해서(쿼리스트링) 우리가 길이가 굉장히 긴 정보를 전송할 때, url을 통해서 쿼리스트링에 포함시켜서 get 방식으로 전달한다면 그 정보가 굉장히 크면 url 규격상 일정한 길이보다 더 길어지면 서버가 정보를 버립니다. 또는 브라우저가 전송을 하지 않을수도 있습니다.<br>
<strong>따라서 이런 경우에는 데이터가 중간에 끊기지 않고 온전히 전체 데이터가 대규모로 전송되려면 전송 방법을 post로 지정해야 합니다.</strong></p>
<h1 id="요약">요약</h1>
<hr>
<ul>
<li><code>get 방식</code>
<ul>
<li>get 방식을 통해서 전송된 쿼리 스트링의 데이터에 따라서 다른 결과를 보여줄 수 있습니다.</li>
<li>쿼리 스트링으로 데이터를 전송했을 때의 중요한 장점</li>
<li>express가 기본적으로 제공함</li>
</ul>
</li>
<li><code>post 방식</code>
<ul>
<li>url에 데이터가 포함되지 않고 데이터가 조용히 암시적으로 동작하기 때문에 불필요하게 정보가 노출되지않음</li>
<li>용량이 큰 데이터를 전송하는데 제한이 없음</li>
<li>express가 기본적으로 제공하지 않기 때문에 body-parser라는 middleware를 로드하고 application의 use를 통해서 붙여서 사용자로부터 들어오는 요청을 중간에 가로채서 post 방식이라면 req 객체의 body라는 객체를 추가시켜주는 역할을 한다. 그리고 body라는 객체에는 form으로 전송될 때 name의 값으로 전달된 데이터의 이름이 body 객체에 프로퍼티로 들어오기 때문에 form의 이름을 통해서 사용자가 전송한 데이터를 받을 수 있습니다.</li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/09/open-tutorials-7/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/09/open-tutorials-6/"
                            aria-label=": 생활코딩 :: URL"
                        >
                            생활코딩 :: URL
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-09T15:39:19+09:00">
	
		    Aug 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="쿼리-스트링">쿼리 스트링</h1>
<hr>
<p>어떠한 사용자의 입력이 있을 때, 그 입력에 따라서 적당한 다른 결과를 보여주는 것이 의미있는 즉, 기능성이 있는 <strong>애플리케이션</strong>이라고 할 수 있습니다.</p>
<img src="/img/url_string.png" width="400" height="200"> 
<p>지금까지는 사용자가 어떤 <strong>주소</strong>로 접근하느냐에 따라서 사용자에게 다른 결과를 보여주었습니다.</p>
<p>만약 우리의 웹사이트가 <code>a.com</code>이라고 한다면 사용자가 path에 <code>/login</code>을 하게 되면 <strong>login</strong>에 해당되는 Route가 그 라우트와 연결되어 있는 Controller(익명 함수)를 호출해서 적당한 결과를 만들어 내는 것이 애플리케이션의 구조입니다.</p>
<img src="/img/path.png" width="400" height="200"> 
<p>그림과 같이 paht만 놓고 본다면 서로 다른 결과를 사용자에게 보여주지만, <code>http://a.com/topic</code>이라는 path 한 개는 사용자에게 언제나 똑같은 결과만을 보여줍니다. 사고를 좀 더 확장해보면 이 <strong>topic</strong>으로 사용자가 접근했을 때도 경우에 따라서 다른 결과를 보여줄 수 있다면 더 좋을 것입니다.</p>
<p>이것을 하기 위해서 <code>쿼리 스트링</code>을 배울 것입니다.</p>
<img src="/img/topic.png" width="400" height="200"> 
<ul>
<li><strong>topic</strong>이라는 라우터에 id가 1이라고 하는 값을 전달하고 있습니다.
<ul>
<li>1이라는 숫자에 해당되는 결과를 처리해서 화면에 보여줍니다.</li>
</ul>
</li>
<li>결과적으로 topic이라는 단 하나의 path로, 다른 말로 단 하나의 라우터로 id 값을 다르게 주는 것에 따라서 다른 결과를 만들어 낼 수 있습니다.</li>
<li>? 뒤에 나타나는 정보를 <strong>쿼리 스트링</strong>이라고 합니다.</li>
</ul>
<h1 id="query-객체-사용법">query 객체 사용법</h1>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/topic'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(req.query.id);</span><br><span class="line">    res.send(req.query.id+<span class="string">', '</span>+req.query.name)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>topic이라는 path가 가리키는 <strong>Controller</strong>가 쿼리 스트링을 어떻게 알 수 있을까??</p>
<ul>
<li>사용자는 주소를 통해서 웹 페이지에 접근하고 있고, 사용자는 우리에게 <strong>요청</strong>을 하고 있습니다. 이러한 요청과 관련된 정보는 <code>req</code>라는 첫 번째 매개변수에 값으로 request 정보가 들어오게 됩니다.</li>
<li>쿼리 스트링으로 전달된 값이 이 함수의(Controller의) 첫 번째 매개변수의 값인 req에 query라고 하는 객체에 id라고 하는 프로퍼티 값으로 들어옵니다.</li>
</ul>
</li>
<li>
<p>express는 req라는 값을 전달하며, req는 query라고 하는 객체를 갖습니다. 그리고 query라는 객체는 사용자가 전달한 쿼리스트링을 프로퍼티로 갖습니다.</p>
</li>
<li>
<p>topic?id=1&amp;name=“이승우”</p>
<ul>
<li>쿼리스트링을 통해서 우리가 애플리케이션에 전달할 수 있는 값은 하나가 아니라 여러 개 일수도 있습니다. 값을 구분하는 구분자로 쿼리스트링은 <code>&amp;</code>를 사용합니다.</li>
</ul>
</li>
</ul>
<h1 id="query-객체의-활용">query 객체의 활용</h1>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/topic'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> topics = [</span><br><span class="line">		<span class="string">'Javascript is ...'</span>,</span><br><span class="line">		<span class="string">'Nodejs is ...'</span>,</span><br><span class="line">		<span class="string">'Express is ...'</span></span><br><span class="line">	];</span><br><span class="line">	<span class="keyword">var</span> output = <span class="string">`</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=0"&gt;JavaScript&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=1"&gt;Nodejs&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=2"&gt;Express&lt;/a&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		<span class="subst">$&#123;topics[req.query.id]&#125;</span></span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">	res.send(output);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>쿼리스트링</strong> : 어떤 애플리케이션에서 정보를 전달할 때 사용하는 URL의 약속되어 있는 국제적인 표준입니다.</li>
<li>그리고 쿼리스트링으로 전달된 값은 <strong>request</strong> 영역이기 때문에 첫 번째 매개변수에 담겨 있는 값인 <strong>req</strong> 객체, 또 그 객체가 가지고 있는 <strong>query</strong>라는 객체 또 그 객체 안에 있는 <strong>id</strong> 값을 통해서 가져올 수 있습니다.</li>
</ul>
<h1 id="시멘틱-url">시멘틱 URl</h1>
<hr>
<p><code>topic/?id=2</code>가 아니라 쿼리스트링이 없이 <code>topic/2</code>와 같은 깔끔한 URL을 통해서 애플리케이션을 제어할 수 있습니다. 이런 방식의 URL 체계를 <strong>시멘틱 URL</strong>이라고 합니다.</p>
<p>하지만, 기존의 쿼리스트링 방식의 URL을 사용하면 <code>topic/2</code>와 같은 URL을 잡아내지 못하고, 주소 뒤에 오는 숫자 값을 사용하기 위해서는 <strong>시멘틱 URL</strong>에서는 <code>params</code>를 이용합니다.<br>
따라서 아래와 같은 수정이 필요합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/topic/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topics = [</span><br><span class="line">		<span class="string">'Javascript is ...'</span>,</span><br><span class="line">		<span class="string">'Nodejs is ...'</span>,</span><br><span class="line">		<span class="string">'Express is ...'</span></span><br><span class="line">	];</span><br><span class="line">	<span class="keyword">var</span> output = <span class="string">`</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=0"&gt;JavaScript&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=1"&gt;Nodejs&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		&lt;a href="/topic?id=2"&gt;Express&lt;/a&gt;&lt;br&gt;&lt;br&gt;</span></span><br><span class="line"><span class="string">		<span class="subst">$&#123;topics[req.params.id]&#125;</span></span></span><br><span class="line"><span class="string">	`</span></span><br><span class="line">	res.send(output);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>쿼리 스트링</strong>을 사용해 접근하는 경우<br>
: <code>req.query.id</code>로 접근하면 됩니다.</li>
<li><strong>시멘틱 URL</strong>(path 방식)을 사용해 접근하는 경우<br>
: <code>req.params.id</code>로 접근하면 됩니다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/09/open-tutorials-6/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/09/open-tutorials-5/"
                            aria-label=": 생활코딩 :: 템플릿"
                        >
                            생활코딩 :: 템플릿
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-09T13:59:53+09:00">
	
		    Aug 09, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Node-js/">Node.js</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="템플릿-엔진이란-무엇인가">템플릿 엔진이란 무엇인가?</h1>
<hr>
<ul>
<li>
<p>정적인 방법과 동적인 방법의 장/단점을 가지고 있습니다.</p>
<ul>
<li>정적인 파일만 서비스한다면 필요없지만, <strong>동적인 결과를 정적인 파일에 담기 위해 사용합니다.</strong></li>
<li>풀어 설명하자면, 자바스크립트 코드로 연산된 결과를 변수에 넣고 변수를 뷰 파일에서도 사용할 수 있게끔 합니다.</li>
</ul>
</li>
<li>
<p>템플릿 엔진을 사용하는 이유</p>
<ul>
<li>클라이언트 요청에 따라 웹 페이지에 들어가는 내용(결과)이 달라질 수 있어서 정적인 부분과 동적인 부분을 따로 하기위해 사용합니다.</li>
</ul>
</li>
<li>
<p><code>app.js</code> 내 html 코드를 쓰지 않아도 됩니다.</p>
</li>
<li>
<p>뷰 파일과 자바스크립트 코드를 한 파일에 정의하지 않고 <strong>따로 따로</strong> 사용할 수 있습니다.</p>
</li>
<li>
<p>자바스크립트로 연산된 결과를 뷰 파일에 쉽게 넣을 수 있습니다.</p>
</li>
<li>
<p>템플릿 엔진 중 <code>Jade</code>를 사용합니다.</p>
</li>
<li>
<p>템플릿 엔진을 이용하면 <strong>짧은 코드로 장황한 HTML 코드를 만들어 낼 수 있는 기능</strong>을 제공합니다.</p>
</li>
<li>
<p>템플릿 엔진 안에서 <strong>변수</strong>도 사용할 수 있다.</p>
</li>
</ul>
<h1 id="express와-함께-템플릿-엔진-사용">Express와 함께 템플릿 엔진 사용</h1>
<hr>
<p>Express는 템플릿 엔진 기능이 없기 때문에 사용하기 위해서 템플릿 엔진을 설치해서 express와 연결한 다음에 사용하면 됩니다.</p>
<p>'npm install jade --save’를 통해 모듈을 설치합니다.</p>
<p>이를 통해 <strong>node_modules</strong> 폴더에 Jade가 추가되고, <strong>package.json</strong> 파일에 Jade가 dependencies 항목으로 추가됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.set(<span class="string">'view engine'</span>,<span class="string">'jade'</span>);</span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./views'</span>);</span><br><span class="line"><span class="comment">// 위의 한 줄을 생략해도 express 기본적으로 views라는 디렉토리를 찾도록 설정되어 있습니다.</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/template'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">'temp'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>view engine : 약속되어 있는 이름</li>
<li>jade : 템플릿 엔진</li>
</ul>
<p>express의 application에게 <code>jade</code>라는 템플릿 엔진을 set합니다.</p>
<p>우리가 설치한 jade라고 하는 템플릿 엔진과 우리가 지금 만들고 있는 애플리케이션 프레임워크인 express를 연결합니다.</p>
<p>그리고 <code>views</code>라는 폴더를 생성해줍니다. 앞으로의 jade 파일은 이 디렉토리에 저장합니다. (템플릿 엔진들의 템플릿 파일을 views라는 파일에 넣습니다.)</p>
<ul>
<li>‘/template/’ 경로를 통해서 들어온 사용자에게 함수가 실행되면서 temp라는 템플릿 파일을 웹 페이지로 렌더링해서 전송한다는 뜻입니다.</li>
<li>템플릿 엔진의 코드에 따라서 만들어진 템플릿 파일을 읽어옵니다.</li>
<li>temp라는 파일은 <strong>views</strong> 폴더에 위치합니다.</li>
</ul>
<p>response 즉, 응답으로 temp를 render하게 되면 express는 내부적으로 위쪽에 정의해놓은 views라고 하는 디렉토리에서 우리가 템플리세 엔진으로 jade를 정해놓았기 때문에 jade의 확장자인 temp.jade라는 파일을 찾아서 그 파일에 있는 내용을 jade의 문법에 따라서 해석한 후에 결과를 가져오고 그것을 사용자에게 response하는 코드입니다.</p>
<h1 id="jade-문법">Jade 문법</h1>
<hr>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">    head</span><br><span class="line">    body</span><br><span class="line">        h1 Hello Jade</span><br><span class="line">        ul</span><br><span class="line">            - for(var i=0;i<span class="tag">&lt;<span class="name">5;i++)</span></span></span><br><span class="line"><span class="tag">                <span class="attr">li</span> <span class="attr">coding</span></span></span><br><span class="line"><span class="tag">        </span></span><br><span class="line"><span class="tag">        <span class="attr">div</span>= <span class="string">time</span> // <span class="attr">jade</span>의 변수</span></span><br></pre></td></tr></table></figure>
<p>들여쓰기를 통해서 head 태그와 body 태그를 html 태그 안에 넣을 수 있습니다. 하지만, 웹 페이지에서 소스보기를 통해서 확인하면 코드의 가독성이 떨어지고 이쁘지 않은 모습을 볼 수 있습니다. 이럴 때는 <code>app.locals.pretty = true;</code>라는 코드를 추가해주면 이쁘게 바뀐 모습을 확인할 수 있습니다.</p>
<p>반복적인 작업을 할 때는 <strong>for문</strong>을 이용하면 되는데, 이는 화면에 출력하는 코드가 아니고 <strong>프로그래밍적</strong>으로 제어하기 위한 코드입니다. 이러한 코드는 앞에 <code>-</code>라는 <strong>Jade</strong> 안에서 약속되어 있는 특수 기호를 붙이면 jade는 -를 보고 for가 화면에 출력되는 것이 아니라는 것을 알게 됩니다. for는 Jade 안에서 반복문으로 사용됩니다.</p>
<p>Html을 작성하는 것이 훨씬 더 간결하게 가능해집니다. 그리고 동시에 프로그래머블하다는 특성을 가지게 됩니다.</p>
<p>time이라는 변수로 현재 시간을 넣기 위해서는 jade 안에서 가능한 것이 아니고 jade를 사용하는 express 쪽에서 변수 값을 주입해주어야 합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/template'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">'temp'</span>, &#123;<span class="attr">time</span>: <span class="built_in">Date</span>()&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>render</strong> 함수의 두 번째 인자로 객체를 전달합니다. time이라는 객체가 render에 의해서 temp.jade라고 하는 template에 흘러들어가게 됩니다. 그러면 temp가 가리키고 있는 temp.jade는 내부적으로 time이라는 변수를 사용할 수 있게 됩니다. 우리가 넘긴 변수 값이 jade 파일 안에서 사용될 수 있습니다. 변수의 값은 여러 개가 전달될 수 있으며, <strong>Jade</strong> 파일에서 명시된 것과 <strong>동일한 이름</strong>을 사용해야 합니다.</p>
<h1 id="정리">정리</h1>
<hr>
<p>먼저, 'npm install jade --save’를 통해서 사용할 템플릿 엔진인 <strong>Jade</strong>를 설치합니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'jade'</span>);</span><br><span class="line">app.set(<span class="string">'views'</span>, <span class="string">'./views'</span>);</span><br><span class="line">app.get(<span class="string">'/template'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">'temp'</span>, &#123;<span class="attr">time</span> : <span class="built_in">Date</span>(), <span class="attr">_title</span> : <span class="string">'Jade'</span>&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>설치된 jade와 express를 연결하기 위해서 위의 코드를 통해서 환결 설정을 해줍니다.</li>
<li>그리고 우리가 어떤 특정한 템플릿을 사용하고 싶다면,
<ul>
<li><code>temp.jade</code>를 사용하고 싶다면 <strong>res</strong>가 가지고 있는 메소드 중에서 <strong>render</strong>라는 메소드를 호출하면서 첫 번째 인자로 그 템플릿의 이름을 전달해주면 render가 내부적으로 템플릿을 읽어서 그 템플릿 엔진의 문법에 따라서 해석한 다음에 사용자에게 response 해줍니다.</li>
<li>만약에 템플릿에 데이터를 주입하고 싶다면, 객체를 정의해서 그 객체의 프로퍼티 값으로 원하는 값을 전달하면 그 템플릿 엔진에서는 <code>= time</code>과 같이 문법을 통해서 변수의 값을 화면에 출력할 수 있습니다.</li>
</ul>
</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/09/open-tutorials-5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/06/java-basic-4/"
                            aria-label=": [Java] 4. 배열"
                        >
                            [Java] 4. 배열
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-06T23:21:14+09:00">
	
		    Aug 06, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="배열array"># 배열(Array)</h1>
<ul>
<li><strong>같은 타입</strong>의 변수들로 이루어진 유한 집합</li>
<li>배열을 구성하는 각각의 값을 배열 요소라고 한다.</li>
<li>위치를 가리키는 숫자를 <strong>인덱스</strong>라고 한다. 인덱스는 0부터 시작하고 0을 포함한 양의 정수만을 가질 수 있다.</li>
<li><strong>같은 종류</strong>의 데이터를 많이 다뤄야 하는 경우에 사용.</li>
<li>1차원, 2차원, 다차원 배열이 존재</li>
</ul>
<h2 id="배열의-초기화">배열의 초기화</h2>
<ul>
<li>다양한 초기화 방법들이 존재한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열의 선언과 동시에 초기화할 수 있음</span></span><br><span class="line"><span class="keyword">int</span>[] grade1 = &#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열의 선언과 동시에 초기화할 수 있음</span></span><br><span class="line"><span class="keyword">int</span>[] grade2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함</span></span><br><span class="line"><span class="keyword">int</span>[] grade3;</span><br><span class="line">grade3 = &#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 이미 선언된 배열은 이 방법으로만 초기화 가능</span></span><br><span class="line"><span class="keyword">int</span>[] grade4;</span><br><span class="line">grade4 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>위의 grade1, grade2, grade4 배열은 초기화 블록에 맞춰 자동으로 배열의 길이가 설정된다.</p>
<h1 id="다차원-배열"># 다차원 배열</h1>
<ul>
<li>2차원 이상의 배열을 의미하며, 배열 요소로 또 다른 배열을 가지는 배열을 의미한다.</li>
<li>2차원 배열 : 배열 요소로 1차원 배열을 가지는 배열</li>
<li>3차원 배열 : 배열 요소로 2차원 배열을 가지는 배열</li>
</ul>
<p><strong>2차원 배열</strong></p>
<ul>
<li>배열의 요소로 1차원 배열을 가지는 배열.</li>
<li>자바에서 2차원 배열을 나타내는 타입을 따로 제공하지 않는다. - 1차원 배열의 배열 요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있다.</li>
</ul>
<img src="/img/two_dimesion_array.png" width="400" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        arr[i][j] = k;</span><br><span class="line">        k+=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">        System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(arr.length); <span class="comment">// 2</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>].length);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>arr.length</code>는 2차원 배열인 arr의 배열 요소의 총 개수인 <strong>2</strong>를 반환.</li>
<li><code>arr[i].length</code>는 arr의 각 배열 요소인 1차원 배열이 가지고 있는 배열 요소의 총 개수인 <strong>3</strong>을 반환.</li>
</ul>
<ol>
<li>2차원 배열의 선언과 동시에 초기화하는 방법</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>가변 배열(dynamic arrya)</li>
</ol>
<ul>
<li>2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써, 행마다 다른 길이의 배열을 요소로 저장할 수 있다.</li>
<li>이렇게 행마다 다른 길이의 배열을 저장할 수 있는 배열을 **가변 배열(dynami array)**이라고 한다.</li>
<li>배열을 생성할 때 열에 해당하는 인덱스를 생략하면 가변 배열을 만들 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>가변 배열도 초기화 블록을 사용해 배열을 선언과 동시에 초기화할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;,</span><br><span class="line">    &#123;<span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="배열의-복사"># 배열의 복사</h1>
<ul>
<li>배열은 한 번 생성하면 그 길이를 변경할 수 없다.</li>
<li>더 많은 데이터를 저장하기 위해서는 더 큰 배열을 만들고, 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다.</li>
<li>배열의 복사를 위해 다음과 같은 방법이 존재한다.</li>
</ul>
<ol>
<li>System 클래스의 <strong>arraycopy()</strong> 메소드
<ul>
<li>가장 좋은 성능을 보이며, 배열의 복사만을 위해 만들어짐</li>
</ul>
</li>
<li>Arrays 클래스의 <strong>copyOf()</strong> 메소드
<ul>
<li>현재 배열의 복사를 위해 가장 많이 사용되며, 좀 더 유연함</li>
</ul>
</li>
<li>Object 클래스의 <strong>clone()</strong> 메소드
<ul>
<li>이전 배열과 같은 길이의 배열밖에 만들 수 없음</li>
</ul>
</li>
<li>for문과 인덱스를 이용한 복사</li>
</ol>
<ul>
<li><code>arraycopy(), copyOf() 메소드와 for문을 이용한 복사</code>는 배열의 길이를 마음대로 늘일 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> newLen = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 1. System 클래스의 arraycopy() 메소드</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[newLen];</span><br><span class="line">System.arraycopy(arr1, <span class="number">0</span>, arr2, <span class="number">0</span>, arr1.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Arrays 클래스의 copyOf() 메소드</span></span><br><span class="line"><span class="keyword">int</span>[] arr3 = Arrays.copyOf(arr1, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Object 클래스의 clone() 메소드</span></span><br><span class="line"><span class="keyword">int</span>[] arr4 = (<span class="keyword">int</span>[])arr1.clone();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for 문과 인덱스를 이용한 복사</span></span><br><span class="line"><span class="keyword">int</span>[] arr5 = <span class="keyword">new</span> <span class="keyword">int</span>[newLen];</span><br></pre></td></tr></table></figure>
<h1 id="enhanced-for문"># Enhanced for문</h1>
<ul>
<li>JDK 1.5부터는 배열과 컬렉션의 모든 요소를 참조하기 위한 <code>Enhanced for문</code>이라는 반복문이 새롭게 추가되었다.</li>
<li>이 반복문은 배열과 컬렉션 프레임워크에서 유용하게 사용됩니다.</li>
</ul>
<p><strong>Enhanced for문</strong>은 명시한 배열이나 컬렉션의 길이만큼 반복되어 실행됩니다. 루프마다 각 요소는 명시한 변수의 이름으로 저장되며, 명령문에서는 이 변수를 사용하여 각 요소를 참조할 수 있습니다.</p>
<p><strong>예시</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">45</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(타입 변수명 : 배열 또는 컬렉션)&#123;</span><br><span class="line">    <span class="comment">// 반복할 문장</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e : arr)&#123;</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>타입은 배열 또는 컬렉션의 요소 타입과 일치해야 한다.</li>
<li>배열 또는 컬렉션에 저장된 값이 매 반복마다 하나씩 순서대로 읽혀서 변수에 저장된다.</li>
<li>하지만, Enhanced for문은 요소를 참조할 때만 사용하는 것이 좋으며, 요소의 값을 변경하는 작업에는 적합하지 않습니다. 다음 코드를 통해 확인할 수 있습니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr1.length;i++)&#123;</span><br><span class="line">    arr1[i]+=<span class="number">10</span>; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e : arr2)&#123;</span><br><span class="line">    e+=<span class="number">10</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : arr1)</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : arr2)</span><br><span class="line">    System.out.print(e+<span class="string">" "</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>1번에서는 for문을 이용하여 각 배열 요소에 10을 더하고 있다. for문을 사용하면, 각 배열 요소의 값을 쉽게 변경할 수 있다.</li>
<li>2번에서는 Enhanced for문을 이용하여 각 배열 요소에 10을 더하고 있다. 하지만 실행 결과를 살펴보면, 원본 배열에는 아무런 변화가 없음을 알 수 있다.</li>
<li>이유는 Enhanced for문 내부에서 사용되는 배열 요소는 배열 요소 그 자체가 아닌 <strong>배열 요소의 복사본</strong>이기 때문이다. 따라서 Enhanced for문에서 배열 요소의 값을 변경하여도 원본 배열에는 아무런 영향을 주지 못하게 된다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/06/java-basic-4/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/06/java-basic-3/"
                            aria-label=": [Java] 3. 제어문"
                        >
                            [Java] 3. 제어문
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-06T18:41:07+09:00">
	
		    Aug 06, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="제어문"># 제어문</h1>
<ul>
<li>원하는 결과를 얻기 위해서 순차적인 흐름을 제어해야 하는 경우가 생긴다. 이 때 사용하는 명령문을 <strong>제어문</strong>이라고 하며, 조건문과 반복문 등이 이에 해당한다.</li>
</ul>
<h2 id="조건문">조건문</h2>
<ul>
<li>주어진 조건식의 결과에 따라 별도의 명령을 수행하도록 제어하는 명령문이다.</li>
<li>가장 기본이 되는건 if문이다.</li>
</ul>
<p><strong>1. if문</strong></p>
<p>조건식의 결과가 <strong>참</strong>이면 주어진 명령문을 실행하며, <strong>거짓</strong>이면 아무것도 실행하지 않는다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"이승우"</span>;</span><br><span class="line"><span class="keyword">if</span>(name == <span class="string">"이승우"</span>)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">// 조건식의 결과가 참일 때 실행하고자 하는 명령문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. if / else 문</strong></p>
<p>if문과 함께 사용하는 else문은 if문과는 반대로 주어진 조건식의 결과가 <strong>거짓</strong>이라면 주어진 명령문을 실행한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ch&gt;=<span class="string">'a'</span> &amp;&amp; ch&lt;=<span class="string">'z'</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"해당 문자는 영문 소문자입니다."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"해당 문자는 영문 소문자가 아닙니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. if/ else if / else 문</strong></p>
<p>if/else if/else문은 마치 새로운 구문처럼 보이지만, 사실은 두 개의 if/else 문이 연달아 나온 것뿐입니다. 이러한 if/else if/else문은 조건식을 여러 개 명시할 수 있으므로 중첩된 if문을 좀 더 간결하게 표현할 수 있습니다.</p>
<p><strong>4. switch문</strong></p>
<p>if/else 문과 마찬가지로 주어진 조건 값의 결과에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문이다. 이러한 switch문은 if/else 보다 <strong>가독성이 더 좋으며</strong>, 컴파일러가 최적화를 쉽게 할 수 있어 <strong>속도 또한 빠른 편</strong>이다.</p>
<p>하지만 switch문의 조건 값으로는 int형으로 승격할 수 있는(integer promotion) 값만이 사용될 수 있다. 즉, 자바에서는 switch 문의 조건 값으로 byte, short, char, int 형의 변수나 리터럴을 사용할 수 있다.</p>
<p>또한, 이러한 기본 타입에 해당하는 데이터를 객체로 포장해주는 래퍼 클래스(Wrapper class) 중에서 위에 해당하는 Byte, Short, Character, Integer 클래스의 객체도 사용할 수 있습니다.</p>
<p>enum 키워드를 사용한 열거체(enumeration type)와 String 클래스의 객체도 사용할 수 있습니다. 따라서 switch문은 if/else 문보다는 사용할 수 있는 상황이 적습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(ch)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 a입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 e입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 i입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 o입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 u입니다."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"해당 문자는 모음이 아닙니다."</span>)</span><br><span class="line">        breakl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>각 case절, default 절은 반드시 <strong>break</strong> 키워드를 포함해야 한다.</li>
<li>switch문에서 사용된 break 키워드는 조건 값에 해당하는 case/default절이 실행된 뒤에 switch문을 빠져나가게 해준다.</li>
<li>break 키워드가 없다면 해당 조건 이후의 case절이 전부 실행된다.</li>
</ul>
<p><strong>5.삼항 연산자에 의한 조건문</strong></p>
<ul>
<li>간단한 if/else 문은 삼항 연산자를 이용하여 간결하게 표현할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">조건식? 반환값<span class="number">1</span> : 반환값<span class="number">2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">조건식의 결과가 참이라면 반환값<span class="number">1</span>을 반환하고, </span><br><span class="line">거짓이라면 반환값<span class="number">2</span>를 반환합니다.</span><br></pre></td></tr></table></figure>
<h1 id="반복문"># 반복문</h1>
<ul>
<li>프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 명령문이다.</li>
<li>프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 제어문 중 하나이다.</li>
</ul>
<h2 id="while문">while문</h2>
<p>while문은 특정 조건을 만족할 때까지 계속해서 주어진 명령문을 반복 실행합니다.</p>
<img src="/img/while.png" width="600" height="200">
<ul>
<li>먼저 조건식이 참(true)인지를 판단하여, 참이면 내부의 명령문을 실행한다.</li>
<li>그리고 조건식의 결과를 변경하는 명령문이 실행된다.</li>
<li>내부의 명령문을 전부 실행하고 나면, 다시 조건식으로 돌아와 또 한 번 참인지를 판단한다.</li>
<li>조건식을 만족할 때까지 반복문을 수행한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">    System.out.println((i+<span class="number">1</span>)+<span class="string">"번째 실행중 입니다."</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while문의 내부에 조건식의 결과를 변경하는 명령문이 존재하지 않을 때는 프로그램이 <strong>무한루프</strong>에 빠지게 된다. 이 경우 영원히 종료되지 않습니다.</li>
<li>while문을 작성할 때는 조건식의 결과가 어느 순간 거짓을 갖도록 조건식의 결과를 변경하는 명령문을 반드시 포함시켜야 한다.</li>
<li>위의 코드에서 <code>i++</code> 명령문을 제거하면 무한 루프에 빠지게 된다.</li>
</ul>
<h2 id="do-while문">do / while문</h2>
<p>while문은 루프에 진입하기 전에 먼저 조건식부터 검사한다. 하지만, <code>do/while</code>문은 먼저 루프를 한 번 실행한 후에 조건식을 검사한다. 즉, do/while문은 조건식의 결과와 상관없이 무조건 한 번은 루프를 실행한다.</p>
<img src="/img/do_while.png" width="600" height="200">
<h2 id="for문">for문</h2>
<p><strong>for문</strong>은 while문과는 달리 자체적으로 <code>초기식, 조건식, 증감식</code>을 모두 포함하고 있는 반복문이다. 따라서 while문보다는 좀 더 간결하게 표현할 수 있다.</p>
<img src="/img/for.png" width="600" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">"for 문이 "</span> + (i + <span class="number">1</span>) + <span class="string">"번째 반복 실행중입니다"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"for 문이 종료된 후 변수 i의 값은 "</span>+ i + <span class="string">"입니다."</span>);</span><br></pre></td></tr></table></figure>
<p>for문 안에서만 사용하는 변수를 초기식에서 직접 선언할 수 있습니다. 이렇게 for문에서 직접 선언된 변수는 for문이 종료되면 같이 <strong>소멸</strong>된다.</p>
<h1 id="기타-제어문"># 기타 제어문</h1>
<p>일반적으로 조건식의 검사를 통해 루프로 진입하면, 다음 조건식을 검사하기 전까지 루프 안에 있는 모든 명령문을 실행한다. 하지만, <strong>continue</strong>문과 <strong>break</strong>문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있도록 도와준다.</p>
<h2 id="continue문">continue문</h2>
<p>루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 <strong>다음 조건식의 판단으로 넘어가게 해준다.</strong> 보통 반복문 내에서 특정 조건에 대한 예외 처리를 하고자 할 때 자주 사용된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">5</span> == <span class="number">0</span> || i%<span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="break문">break문</h2>
<p>루프 내에서 사용하여 해당 반복문을 완전히 종료시킨 뒤, 반복문 바로 다음에 위치한 명령문을 실행한다. 즉 루프 내에서 조건식의 판단 결과와 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용한다. <strong>가장 가까운 반복문을 빠져나가는 것이다.</strong></p>
<h2 id="이름을-가지는-반복문break-with-label">이름을 가지는 반복문(break with label)</h2>
<p>일반적인 break문은 단 하나의 반복문만을 빠져나가게 해준다. 따라서 여러 반복문이 중첩된 상황에서 한 번에 모든 반복문을 빠져나가거나, 특정 반복문까지만 빠져나가고 싶을 때는 다른 방법을 사용해야 한다.</p>
<p>이때 사용할 수 있는 방법이 반복문에 <strong>이름</strong>(label)을 설정하는 것이다. 가장 바깥쪽 반복문이나 빠져나가고 싶은 특정 반복문에 이름을 설정한 후, break 키워드 다음에 해당 이름을 명시하면 된다.</p>
<p>그러면 해당 break 키워드는 현재 반복문이 아닌 해당 이름의 반복문 바로 다음으로 프로그램의 실행을 옮겨준다.</p>
<p>단, 이때 이름(label)은 가리키고자 하는 반복문의 키워드 바로 앞에 위치해야 한다. 이름과 반복문의 키워드 사이에 명령문이 존재하면, 자바 컴파일러는 오류를 발생시킨다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">llLoop :</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> llLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i + <span class="string">" * "</span> + j + <span class="string">" = "</span> + (i * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"구구단 4단까지 출력!"</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">결과</span><br><span class="line"><span class="number">2</span> * <span class="number">2</span> = <span class="number">4</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span></span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> * <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="number">4</span> * <span class="number">8</span> = <span class="number">32</span></span><br><span class="line"><span class="number">4</span> * <span class="number">9</span> = <span class="number">36</span></span><br></pre></td></tr></table></figure>
<ul>
<li>이름(label)을 가지는 반복문을 통해서 구구단 2단~4단까지 출력하는 코드이다.</li>
<li>C언어나 C++과는 달리 자바에는 goto문이 없다. 이렇게 반복문을 가리키는 <code>이름(label)</code>은 break문이나 continue문에만 사용될 수 있다.</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/06/java-basic-3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2018/08/03/java-basic-2/"
                            aria-label=": [Java] 2. 연산자"
                        >
                            [Java] 2. 연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2018-08-03T23:41:53+09:00">
	
		    Aug 03, 2018
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="연산자"># 연산자</h1>
<ul>
<li>
<p>x&lt;&lt;2+1 : 쉬프트 연산자(&lt;&lt;)는 덧셈 연산자보다 우선순위가 낮습니다. 그래서 해당 식은 <code>x&lt;&lt;(2+1)</code>과 같습니다.</p>
</li>
<li>
<p>data &amp; 0xFF == 0 : 논리연산자(&amp;)는 비교연산자(==)보다 우선순위가 낮으므로 비교연산을 먼저 수행한 후에 논리연산이 수행됩니다. 따라서 해당 식은 <code>data &amp; (0xFF == 0)</code>과 같습니다.</p>
</li>
<li>
<p>x&lt;-1 || x&gt;3 &amp;&amp; x&lt;5 : 논리연산자 중에서 AND를 의미하는 &amp;&amp;가 OR을 의미하는 ||보다 우선순위가 높습니다. 그래서 해당 식은 <code>x&lt;-1 || (x&gt;3 &amp;&amp; x&lt;5)</code>과 같습니다.</p>
</li>
<li>
<p>증감 연산자의 연산 순서 : 증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라집니다. 다음 예제를 통하여 확인해볼 수 있습니다.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> y = x-- + <span class="number">5</span> + --x;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"x : "</span>+x+<span class="string">", y : "</span>+y);</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">x : <span class="number">8</span>, y : <span class="number">23</span></span><br></pre></td></tr></table></figure>
<img src="/img/operation_process.png" width="400" height="200">
<ul>
<li><strong>instanceof 연산자</strong> : 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 반환해준다. 즉, 해당 객체가 어떤 클래스나 인터페이스로부터 생성되었는지를 판별해 주는 역할을 한다.
<ul>
<li>instanceof 연산자는 왼쪽 피연산자인 인스턴스가 오른쪽 피연산자인 클래스나 인터페이스로부터 생성되었으면 <code>true</code>를, 아니면 <code>false</code>를 반환한다.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	A a = <span class="keyword">new</span> A();</span><br><span class="line">	B b = <span class="keyword">new</span> B();</span><br><span class="line">	System.out.println(a <span class="keyword">instanceof</span> A);</span><br><span class="line">	System.out.println(b <span class="keyword">instanceof</span> A);</span><br><span class="line">	System.out.println(a <span class="keyword">instanceof</span> B);</span><br><span class="line">	System.out.println(b <span class="keyword">instanceof</span> B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h2 id="형-변환">형 변환</h2>
<ul>
<li><code>산술 변환</code> : 연산을 수행하기 전 피연산자 타입의 일치를 위해 <strong>자동 형 변환</strong>되는 것을 말한다. 이항 연산뿐만 아니라 단항 연산에서도 일어난다. 규칙은 다음과 같습니다.</li>
</ul>
<ol>
<li>
<p><strong>두 피연산자의 타입을 같게 일치시킨다.</strong> <strong>(보다 큰 타입으로 일치)</strong></p>
<ul>
<li>피연산자의 값 손실을 최소화한다.</li>
<li>long + int -&gt; long + long -&gt; long</li>
<li>float + int -&gt; float + float -&gt; float</li>
</ul>
</li>
<li>
<p><strong>피연산자의 타입이 int보다 작은 타입이면 int로 변환됩니다.</strong></p>
<ul>
<li>JVM의 피연산자 스택이 피연산자를 4 Byte로 저장하기 때문에 int형보다 작은 데이터 타입은 int형으로 변환된 후 연산이 수행된다.</li>
</ul>
<ul>
<li>byte + short -&gt; int + int -&gt; int</li>
<li>char + short -&gt; int + int -&gt; int</li>
</ul>
</li>
</ol>
<ul>
<li>그리고 int보다 작은 타입, 예를 들면 char나 short의 표현범위가 좁아서 연산 중에 <strong>오버플로우</strong>(Overflow)가 발생할 가능성이 높기 때문에 만들어진 것입니다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a = <span class="number">1000000</span> * <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">long</span> b = <span class="number">1000000</span> * <span class="number">1000000L</span>;</span><br><span class="line">System.out.println(<span class="string">"a = "</span>+a);</span><br><span class="line">System.out.println(<span class="string">"b = "</span>+b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">a = -<span class="number">727379968</span>;</span><br><span class="line">b = <span class="number">1000000000000</span>;</span><br></pre></td></tr></table></figure>
<p>위의 예제에서 '1000000 * 1000000’의 결과가 1000000000000(2 * 10의 12승)임에도 불구하고, -727379968라는 결과가 출력된다.</p>
<p>그 이유는 int 타입과 int 타입의 연산 결과는 int 타입인데, 연산결과가 int 타입의 최대 값인 1000000000(2 * 10의 9승)을 넘으므로 오버플로우(Overflow)가 발생했기 때문이다. <strong>이미 오버플로우가 발생한 값을 아무리 long 타입의 변수에 저장해도 소용 없다.</strong></p>
<p>b에서 처럼 1000000L으로 <strong>형 변환</strong>을 통해서 1000000도 long형으로 타입을 맞춘 후에 연산을 수행한 값을 long형 타입의 변수 b에 저장한다면 올바른 결과를 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>; <span class="comment">// c1에는 문자 'a'의 코드값인 97이 저장됩니다.</span></span><br><span class="line"><span class="keyword">char</span> c2 = c1; <span class="comment">// c1에 저장되어 있는 값이 c2에 저장됩니다.</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">' '</span>; <span class="comment">// c3를 공백으로 초기화</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = c1 + <span class="number">1</span>; <span class="comment">// 'a'+1 -&gt; 97 + 1 -&gt; 98</span></span><br><span class="line"></span><br><span class="line">c3 = (<span class="keyword">char</span>)(c1+<span class="number">1</span>);</span><br><span class="line">c2++;</span><br><span class="line">c3++;</span><br></pre></td></tr></table></figure>
<p>위 예제에서 c2++; 대신에 c2 = c2+1;을 사용하면 에러가 발생하게 됩니다. 이유는 c2+1의 연산결과는 int형이며, 그 결과를 다시 c2에 담으려면 형변환 연산자를 이용해 char형으로 형변환해야 하기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = c2+<span class="number">1</span>; <span class="comment">// 컴파일 에러 발생 O</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'a'</span>+<span class="number">1</span>; <span class="comment">// 컴파일 에러 발생 X</span></span><br></pre></td></tr></table></figure>
<p>‘a’+1은 <strong>리터럴</strong>간의 연산이기 때문에 에러가 발생하지 않는다. 상수 또는 리터럴 간의 연산은 실행과정 동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다. 컴파일러가 미리 덧셈 연산을 수행하기 때문에 실행 시에는 덧셈 연산이 수행되지 않는다. 수식에 변수가 들어가있는 경우에는 컴파일러가 미리 계산을 할 수 없기 때문에 형 변환을 해줘야 한다.<br>
<code>char ch2 = (char)(c1+1)</code> 그렇지 않으면 컴파일 에러가 발생한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0.1</span>;</span><br></pre></td></tr></table></figure>
<p>float 타입의 값을 double 타입으로 형 변환하면, 부호와 지수는 달라지지 않고 그저 기수의 빈자리를 0으로 채울뿐이므로 0.1f를 double 타입으로 형 변환해도 그 값은 여전히 달라지지 않는다.</p>
<p><strong>즉, float 타입의 값을 정밀도가 더 높은 double 타입으로 형변환했다고 해서 오차가 적어지는 것은 아니다.</strong></p>
<h2 id="와-equals-차이">==와 equals() 차이</h2>
<ol>
<li>형태의 차이<br>
가장 단순한 차이점은 형태의 차이다.</li>
</ol>
<ul>
<li>equals()는 메소드이다. 객체끼리 내용을 비교할 수 있도록 한다.</li>
<li>== 는 비교를 위한 연산자이다.</li>
</ul>
<ol start="2">
<li>주소값 비교와 내용 비교<br>
비교할 수 있는 대상에 대한 부분이다.</li>
</ol>
<ul>
<li>equals() 메소드는 비교하고자 하는 <strong>대상의 내용 자체를 비교</strong>한다.</li>
<li>== 연산자는 비교하고자 하는 대상의 <strong>주소값을 비교</strong>한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(str1 == str2)&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"같은 문자열입니다."</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 	System.out.println(<span class="string">"다른 문자열입니다."</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str1.equals(str2))&#123;</span><br><span class="line">	System.out.println(<span class="string">"같은 문자열입니다."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">"다른 문자열입니다."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>str1과 str2의 내용이 &quot;abc&quot;로 같은데도 <code>==</code>로 비교하면 false의 결과를 얻게 된다. <strong>내용은 같지만 str1과 str2가 서로 다른 객체이기 때문이다.</strong> 그러나 <strong>equals()는 객체가 달라도 내용이 같으면 true를 반환한다.그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다.</strong></p>
<h2 id="효율적인-연산">효율적인 연산</h2>
<ul>
<li>효율적인 연산
<ul>
<li>OR 연산 '||'의 경우, 두 피연산자 중 어느 한 쪽만 '참’이어도 전체 연산결과가 '참’이므로 좌측 피연산자가 'true(참)'이면, 우측 피연산자의 값은 평가하지 않는다.</li>
<li>AND 연산 '&amp;&amp;'의 경우, 어느 한 쪽만 '거짓(0)'이어도 전체 연산결과가 '거짓(0)'이므로 좌측 피연산자가 '거짓(0)'이면, 우측 피연산자의 값은 평가하지 않는다.</li>
</ul>
</li>
</ul>
<p>비트 XOR 연산자 '^'는 두 피연산자의 비트가 다를 때만 1이 된다. 그리고 <strong>같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아온다는 특징이 있어서 간단한 암호화에 사용된다.</strong></p>
<p>비트 전환 연산자는 피연산자의 타입이 int보다 작으면 int로 자동 형변환(산술 변환) 후에 연산하기 때문에 연산 결과는 32자리의 2진수입니다.</p>
<p>쉬프트 연산자의 좌측 피연산자는 산술변환이 적용되어 int보다 작은 타입은 int 타입으로 자동 변환되고 연산결과 역시 int 타입이 됩니다. 그러나 쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않습니다.</p>
<!--변수 앞에 키워드 `final`을 붙이면 상수가 됩니다. 상수는 반드시 선언과 동시에 값을 저장해야하며, 한 번 저장된 값은 바꿀 수 없습니다.-->

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2018/08/03/java-basic-2/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/22/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/archives/24/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 23 of 28</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
