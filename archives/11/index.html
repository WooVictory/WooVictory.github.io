
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/11/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/06/Algo-Anagram/"
                            aria-label=": [알고리즘] Anagrm"
                        >
                            [알고리즘] Anagrm
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-06T15:32:04+09:00">
	
		    Apr 06, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="anagram이란"># Anagram이란?</h2>
<p>동일한 알파벳을 재배열하여 만들 수 있는 문장이나 단어를 말한다.<br>
예를 들면, <code>listen</code> <code>silent</code> 두 단어는 애너그램이다.</p>
<p>개념은 간단하다. 사실 풀이도 간단하게 풀 수 있다.</p>
<p><strong>중요한 점</strong><br>
알파벳의 위치만 바꿔서 단어를 만들기 때문에 두 단어 사이에는 결국 같은 알파벳이 존재하게 된다. 이 점을 활용하여 두 단어를 알파벳 순으로 정렬해서 같은지 아닌지 비교하여 문제를 풀 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 대소문자를 구분하지 않기 때문에 문자열의 문자를 모두 대문자로 바꾼다.</span></span><br><span class="line">       <span class="comment">// 그리고 String을 char 배열로 변환한다.</span></span><br><span class="line">       <span class="keyword">char</span>[] char_a = a.toUpperCase().toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] char_b = b.toUpperCase().toCharArray();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 알파벳 순으로 정렬한다.</span></span><br><span class="line">       Arrays.sort(char_a);</span><br><span class="line">       Arrays.sort(char_b);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 다시 문자열에 할당한다. </span></span><br><span class="line">       String str_a = <span class="keyword">new</span> String(char_a);</span><br><span class="line">       String str_b = <span class="keyword">new</span> String(char_b);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 그러면 정렬도 했으니 같은 문자열이 담겨 있게 된다.</span></span><br><span class="line">       <span class="comment">// 같은 문자열일 경우 애너그램이라고 할 수 있으므로 true를 리턴한다.</span></span><br><span class="line">       <span class="keyword">if</span> (str_a.equals(str_b)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://jbeight.tistory.com/487" target="_blank" rel="noopener">애너그램</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/06/Algo-Anagram/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/02/Algo-BFS/"
                            aria-label=": [알고리즘] 그래프 탐색 Part2. BFS"
                        >
                            [알고리즘] 그래프 탐색 Part2. BFS
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-02T11:25:23+09:00">
	
		    Apr 02, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="그래프-탐색이란"># 그래프 탐색이란</h1>
<p>그래프 탐색에 대해서는 DFS 글에서도 확인할 수 있다.</p>
<ul>
<li><a href="https://woovictory.github.io/2019/04/01/Algo-DFS/">[알고리즘] DFS</a></li>
</ul>
<h1 id="너비-우선-탐색"># 너비 우선 탐색</h1>
<p>너비 우선 탐색(Breadth-First Search)은 BFS라고 부른다. (이하 BFS라고 하겠다.)</p>
<p>루트 노드(혹은 다른 임의의 노드)에서 시작해 인접한 노드를 먼저 탐색하는 방법.</p>
<ul>
<li>시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.</li>
<li>즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색하는 것이다.</li>
<li>사용하는 경우 : <strong>두 노드 사이의 최단 경로</strong> 혹은 <strong>임의의 경로를 찾고 싶을 때</strong> 이 방법을 선택한다.
<ul>
<li>Ex) 지구상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Ash와 Vanessa 사이에 존재하는 경로를 찾는 경우</li>
<li>깊이 우선 탐색의 경우 : 모든 친구 관계를 다 살펴봐야 할지도 모른다.</li>
<li>너비 우선 탐색의 경우 : Ash와 가까운 관계부터 탐색.</li>
</ul>
</li>
<li>BFS가 DFS보다 좀 더 복잡하다.</li>
</ul>
<p><strong>BFS의 특징</strong></p>
<ul>
<li>직관적이지 않은 면이 있다.
<ul>
<li>BFS는 시작 노드에서 시작해서 거리에 따라 단계별로 탐색한다고 볼 수 있다.</li>
</ul>
</li>
<li>BFS는 <strong>재귀적으로 동작하지 않는다.</strong></li>
<li>그래프 탐색의 경우 <strong>어떤 노드를 방문했었는지 여부를 반드시 검사</strong>해야 한다는 것이다.
<ul>
<li>이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다.</li>
</ul>
</li>
<li>BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료 구조인 <code>큐(Queue)</code>를 사용한다.
<ul>
<li>즉, <strong>선입선출</strong> 원칙으로 탐색</li>
<li>일반적으로 큐를 이용해서 반복적 형태로 구현하는 것이 가장 잘 동작한다.</li>
</ul>
</li>
</ul>
<p><strong>BFS의 탐색 과정</strong></p>
<ol>
<li>a 노드(시작 노드)를 방문한다.(방문한 노드 체크)
<ul>
<li>큐에 방문된 노드를 삽입한다.(enqueue)</li>
<li>초기 상태의 큐에는 시작 노드만 저장
<ul>
<li>즉, a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다.</li>
</ul>
</li>
</ul>
</li>
<li>큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다.
<ul>
<li>큐에서 꺼낸 노드를 방문한다.</li>
<li>큐에서 꺼낸 노드와 인접한 노드들을 모두 방문한다.
<ul>
<li>인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다.(dequeue)</li>
</ul>
</li>
<li>큐에 방문된 노드를 삽입한다.(enqueue)</li>
</ul>
</li>
<li>큐가 소진될 때까지 계속한다.</li>
</ol>
<p><strong>BFS의 구현</strong></p>
<ul>
<li>구현 방법
<ul>
<li>자료 구조인 <code>큐(Queue)</code>를 사용.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 02/04/2019</span></span><br><span class="line"><span class="comment"> * DFS와 BFS 복습</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ1260_RE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt;[] a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> n = convert(input[<span class="number">0</span>]); <span class="comment">// 정점의 개수</span></span><br><span class="line">        <span class="keyword">int</span> m = convert(input[<span class="number">1</span>]); <span class="comment">// 간선의 개수</span></span><br><span class="line">        <span class="keyword">int</span> start = convert(input[<span class="number">2</span>]); <span class="comment">// 시작할 정점 번호</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열 초기화.</span></span><br><span class="line">        a = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            String[] inputs = br.readLine().split(SPACE);</span><br><span class="line">            <span class="keyword">int</span> u = convert(inputs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> v = convert(inputs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 양방향 그래프일 경우 양쪽 다 추가해준다.</span></span><br><span class="line">            a[u].add(v);</span><br><span class="line">            a[v].add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 방문할 정점이 여러 개인 경우 정점 번호가 가장 작은 것부터 탐색하기 위해서 정렬한다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Collections.sort(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        bfs(start);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convert</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        visit[start] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = queue.remove(); <span class="comment">// 큐에서 정점을 뺀다.</span></span><br><span class="line"></span><br><span class="line">            System.out.print(x + SPACE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y : a[x]) &#123;</span><br><span class="line">                <span class="comment">// 방문한 적이 있는지 체크한다.</span></span><br><span class="line">                <span class="keyword">if</span> (!visit[y]) &#123;</span><br><span class="line">                    <span class="comment">// 해당 정점을 방문한 적이 없다면 방문했다고 true 로 체크한다.</span></span><br><span class="line">                    <span class="comment">// 그리고 해당 정점을 큐에 넣는다.</span></span><br><span class="line">                    visit[y] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.add(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 입력</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>BFS의 시간 복잡도</strong></p>
<ul>
<li>N : 정점의 개수, E : 간선의 개수</li>
<li>인접 리스트로 표현된 그래프 : O(N+E)</li>
<li>인접 행렬로 표현된 그래프 : O(N^2)</li>
<li>DFS와 마찬가지로 그래프 내에 적은 숫자의 간선만을 가지는 <strong>희소 그래프</strong>의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html" target="_blank" rel="noopener">[알고리즘] 너비 우선 탐색(BFS)이란</a></li>
<li><a href="https://mygumi.tistory.com/102" target="_blank" rel="noopener">[그래프] DFS와 BFS 구현하기 :: 마이구미</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/02/Algo-BFS/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/01/Algo-DFS/"
                            aria-label=": [알고리즘] 그래프 탐색 Part3. DFS"
                        >
                            [알고리즘] 그래프 탐색 Part3. DFS
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-01T23:07:30+09:00">
	
		    Apr 01, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><strong>목차</strong></p>
<ul>
<li><a href="#%EA%B7%B8%EB%9E%98%ED%94%84-%ED%83%90%EC%83%89%EC%9D%B4%EB%9E%80">그래프 탐색이란</a></li>
<li><a href="#%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89">깊이 우선 탐색</a></li>
</ul>
<h1 id="그래프-탐색이란"># 그래프 탐색이란</h1>
<ul>
<li>하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것</li>
<li>Ex) 특정 도시에서 다른 도시로 갈 수 있는지 없는지, 전자 회로에서 특정 단자와 단자가 서로 연결되어 있는지 등등</li>
</ul>
<h1 id="깊이-우선-탐색"># 깊이 우선 탐색</h1>
<p>깊이 우선 탐색(Depth-First Search)은 DFS라고도 부른다.(이하 DFS라고 하겠다.)</p>
<p>루트 노트(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법이다.</p>
<ul>
<li>미로를 탐색할 때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 이곳으로부터 다른 방향으로 다시 탐색을 진행하는 방법과 유사하다.</li>
<li>즉, 넓게(wide) 탐색하기 전에 <code>깊게(deep)</code> 탐색하는 것이다.</li>
<li>사용하는 경우 : <strong>모든 노드를 방문</strong>하고자 하는 경우에 이 방법을 선택한다.</li>
<li>DFS가 BFS보다 좀 더 간단하다.</li>
<li>단순 검색 속도 자체는 BFS에 비해서 느리다.</li>
</ul>
<p><strong>DFS의 특징</strong></p>
<ul>
<li>자기 자신을 호출하는 <strong>순환 알고리즘의 형태</strong>를 가지고 있다.</li>
<li>전위 순회를 포함한 다른 형태의 트리 순회는 모두 DFS의 한 종류이다.</li>
<li>이 알고리즘을 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 <strong>어떤 노드를 방문했었는지 여부를 반드시 검사</strong>해야 한다는 것이다.
<ul>
<li>이를 검사하지 않을 경우 무한 루프에 빠질 위험이 있다.</li>
</ul>
</li>
</ul>
<p><strong>DFS 탐색 과정</strong></p>
<ol>
<li>a 노드(시작 노드)를 방문한다.
<ul>
<li>방문한 노드는 방문했다고 표시한다.</li>
</ul>
</li>
<li>a와 인접한 노드들을 차례로 순회한다.
<ul>
<li>a와 인접한 노드가 없다면 종료한다.</li>
</ul>
</li>
<li>a와 이웃한 노드 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.
<ul>
<li>b를 시작 정점으로 DFS를 다시 시작하여 b의 이웃 노드들을 방문한다.</li>
</ul>
</li>
<li>b의 분기를 전부 완벽하게 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안된 정점을 찾는다.
<ul>
<li>즉, b의 분기를 전부 완벽하게 탐색한 뒤에야 a의 다른 이웃 노드를 방문할 수 있다는 뜻이다.</li>
<li>정점을 모두 방문했으면 종료한다.</li>
<li>아직 방문이 안된 정점이 있으면 그 정점을 시작 정점으로 DFS를 시작한다.</li>
</ul>
</li>
</ol>
<p><strong>DFS의 구현</strong></p>
<ul>
<li>구현 방법은 2가지가 있다.
<ol>
<li><strong>순환 호출 이용</strong> 즉, 재귀 함수 호출.</li>
<li><strong>명시적인 스택 사용</strong>
<ul>
<li>명시적인 스택을 사용하여 방문한 정점들을 스택에 저장하였다가 다시 꺼내어 작업한다.</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>만약 어떤 정점에서 더 방문할 노드가 없다면 자신을 불렀던 정점으로 돌아간다.<br>
이 과정을 구현하기 위해 <code>스택(Stack)</code>을 사용한다.</p>
<p>방문하는 순서대로 정점을 스택에 쌓고, 방문이 끝나면 스택에서 pop하는 형태로 구현이 가능하다. 재귀 함수 또한 스택 메모리 공간에 쌓아 올려지는 구조를 띄므로 <strong>재귀 함수를 사용하여도 이것을 구현할 수 있다.</strong></p>
<p><strong>DFS의 시간 복잡도</strong></p>
<ul>
<li>DFS는 그래프(정점의 수:N, 간선의 수:E)의 모든 간선을 조회한다.
<ul>
<li>인접 행렬로 표현된 그래프 : O(N^2)
<ul>
<li>없는 간선도 저장한다.</li>
</ul>
</li>
<li>인접 리스트로 표현된 그래프 : O(N+E)</li>
</ul>
</li>
<li>그래프 내에 적은 숫자의 간선만을 가지는 <strong>희소 그래프</strong>의 경우 인접 행렬보다 인접 리스트를 사용하는 것이 유리하다.</li>
<li>보통은 E &lt;&lt; N^2 이기 때문에 인접 리스트를 사용한다.</li>
</ul>
<p><strong>DFS 구현</strong></p>
<ul>
<li>인접 리스트를 사용하여 구현한다.</li>
<li>재귀 함수 호출을 사용한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by victory_woo on 02/04/2019</span></span><br><span class="line"><span class="comment"> * DFS와 BFS 복습</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BOJ1260_RE</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt;[] a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] visit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> n = convert(input[<span class="number">0</span>]); <span class="comment">// 정점의 개수</span></span><br><span class="line">        <span class="keyword">int</span> m = convert(input[<span class="number">1</span>]); <span class="comment">// 간선의 개수</span></span><br><span class="line">        <span class="keyword">int</span> start = convert(input[<span class="number">2</span>]); <span class="comment">// 시작할 정점 번호</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 배열 초기화.</span></span><br><span class="line">        a = <span class="keyword">new</span> ArrayList[n + <span class="number">1</span>];</span><br><span class="line">        visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            a[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            String[] inputs = br.readLine().split(SPACE);</span><br><span class="line">            <span class="keyword">int</span> u = convert(inputs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> v = convert(inputs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 양방향 그래프일 경우 양쪽 다 추가해준다.</span></span><br><span class="line">            a[u].add(v);</span><br><span class="line">            a[v].add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 방문할 정점이 여러 개인 경우 정점 번호가 가장 작은 것부터 탐색하기 위해서 정렬한다.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Collections.sort(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convert</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 방문한 적이 있다면 종료한다.</span></span><br><span class="line">        <span class="keyword">if</span> (visit[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit[x] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 방문한 순서 출력</span></span><br><span class="line">        System.out.print(x+<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y : a[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[y]) &#123;</span><br><span class="line">                dfs(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">입력</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line">출력 결과</span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html" target="_blank" rel="noopener">[알고리즘] 깊이 우선 탐색(DFS)이란</a></li>
<li><a href="https://limkydev.tistory.com/93" target="_blank" rel="noopener">[Algorithm] DFS 깊이탐색</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/01/Algo-DFS/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/04/01/Algo-What-is-DFS/"
                            aria-label=": [알고리즘] 그래프 탐색 Part1. 개요"
                        >
                            [알고리즘] 그래프 탐색 Part1. 개요
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-04-01T10:12:18+09:00">
	
		    Apr 01, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="그래프-탐색"># 그래프 탐색</h1>
<p>그래프를 탐색하는 방법에는 널리 사용되는 두 가지 방식이 있다.</p>
<ul>
<li>DFS는 깊이 우선 탐색(Depth-First Search)이다.</li>
<li>BFS는 너비 우선 탐색(Breadth-First Search)이다.</li>
<li>먼저 <strong>그래프</strong>라는 자료구조에 대한 지식이 있어야 한다.</li>
</ul>
<h2 id="그래프">그래프</h2>
<p>자료 구조의 일종이다.<br>
그래프는 정점과 간선의 집합이다.</p>
<p><strong>용어</strong></p>
<ul>
<li>정점(Vertex) : 노드라고도 부른다.</li>
<li>간선(Edge) : 정점 간의 관계를 나타낸다.
<ul>
<li>두 정점을 이어준다.</li>
<li>자기 자신을 이을 수도 있다.(루프)</li>
<li>간선에 방향이 있기도 하고 없기도 하다.</li>
<li>가중치가 있기도 하고 없기도 하다.</li>
</ul>
</li>
<li>경로(Path) : 정점 A에서 B로 가는 경로</li>
<li>사이클 : 정점 A에서 다시 A로 돌아오는 경로</li>
<li>단순 경로 / 단순 사이클 : 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클을 의미한다.
<ul>
<li>특별한 말이 없으면 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.</li>
</ul>
</li>
<li>방향 있는 그래프 : 간선에 방향이 존재한다. A -&gt; C는 있지만 C -&gt; A는 없다.</li>
<li>방향 없는 그래프 : A - C와 같이 간선에 방향이 없다. 이는 A -&gt; C와 C -&gt; A를 나타낸다. <strong>양방향 그래프</strong>라고도 한다.</li>
<li>간선 여러개 : 두 정점 사이에 간선이 여러 개일 수도 있다.
<ul>
<li>두 간선은 서로 다른 간선이다.</li>
<li>최소 비용을 구할 때는 가중치가 적은 것을 선택하면 된다.</li>
</ul>
</li>
<li>루프 : 간선의 양 끝 점이 같은 경우다. A -&gt; A</li>
<li>가중치(Weight) : 간선에 가중치가 있는 경우를 말한다.
<ul>
<li>A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등.</li>
<li>가중치가 없는 경우에는 1이라고 생각하면 된다.</li>
</ul>
</li>
<li>차수(Degree) : 정점과 연결되어 있는 간선의 개수를 말한다.</li>
</ul>
<p><strong>그래프의 표현</strong></p>
<ul>
<li>정점 : 변수 하나로 개수를 표현하면 된다.</li>
<li>간선 : 무엇과 무엇이 연결되어 있는지를 저장해야 한다. (그래프를 저장하는 방식.)</li>
</ul>
<p>그래프를 구현하는데 있어서 다음과 같은 두 가지 방식을 사용할 수 있다. 참고로 무방향 그래프를 기준으로 설명하겠다.</p>
<ul>
<li>그래프를 저장하는 방식
<ol>
<li>인접 행렬</li>
<li>인접 리스트</li>
</ol>
</li>
</ul>
<p>먼저, 인접 행렬은 정점(V)이 N개 일때, NxN의 2차원 배열로 나타낼 수 있다.</p>
<img src="/img/graph_array.png" width="700" height="300">
<p>인접 행렬을 일반적으로 a라고 이름을 짓는다.<br>
a[1][5] = 1의 의미는 정점 1과 정점 5의 간선이 연결되어 있다는 뜻이다.<br>
무방향이기 때문에 a[5][1] 또한 1이다. 빨간색 줄을 통해서 확인할 수 있다.<br>
인접 행렬의 값이 1이라면, 정점 간의 간선이 존재한다는 것이고, 0이라면 존재하지 않는다는 것이다.<br>
(현재 위의 예에서는 가중치가 없지만, 가중치를 넣을 때는 1 대신 가중치를 넣으면 된다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> v1 = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> v2 = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    a[v1][v2] = <span class="number">1</span>;</span><br><span class="line">    a[v2][v1] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이번에는 인접 리스트를 확인해보자.</p>
<img src="/img/graph_arraylist.png" width="700" height="300">
<p>인접행렬은 2차원 배열의 행과 열을 통해 정점 간의 간선을 표현했는데, 인접 리스트는 이와 다르다. 1에 연결되어 있는 간선들을 A[1]에 저장하고, A[2]에는 2에 연결되어 있는 간선을 저장한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;[] a = (ArrayList&lt;Integer&gt;[]) <span class="keyword">new</span> ArrayList[N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)&#123;</span><br><span class="line">    a[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> v1 = sc.nextInt();</span><br><span class="line">    <span class="keyword">int</span> v2 = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    a[v1].add(v2);</span><br><span class="line">    a[v2].add(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>같은 목적이지만 배열과 리스트를 통해 다르게 저장함으로써 큰 차이를 볼 수 있다.<br>
인접 행렬은 크기가 정점과 간선의 개수와 상관없이 정점 갯수 x 정점 갯수이기 때문에 공간 복잡도가 O(V^2)이다.<br>
하지만, 인접 리스트는 필요한 공간만 쓰기 때문에 O(V+E)가 된다.<br>
인접 행렬보다는 인접 리스트를 사용하는게 훨씬 효율적이다.</p>
<h2 id="dfs"># DFS</h2>
<p><strong>한 우물만 깊게 파다가 막히면 그제서야 돌아가서 다른 우물을 파는 성향</strong>이 있다고 할 수 있다.<br>
모든 정점을 1번씩 방문한다.</p>
<img src="/img/dfs_1.png" width="500" height="300">
<ul>
<li>먼저 정점 하나를 선택한다.</li>
<li>그리고 <strong>그 정점의 아직 방문하지 않은 인접한 정점 중 하나를 선택해 방문</strong>한다.</li>
<li>0이 인접한 1을 방문하면 그 다음번에는 0에 인접한 다른 정점들보다 1에 인접한 정점들이 우선적으로 방문된다.</li>
</ul>
<img src="/img/dfs_2.png" width="500" height="300">
<ul>
<li>0번 정점에서 시작한다. 인접한 정점이 여러 개라면 그 중 번호가 제일 작은 것부터 방문한다.</li>
<li><strong>빨간색</strong>이 지금 막 방문한 노드이고 <strong>녹색</strong>은 이전에 방문한 노드, <strong>파란색</strong>은 아직 방문하지 않은 노드이다.</li>
<li>일단 처음 방문한 0번 노드와 인접한 노드는 1,2번이다.</li>
<li>이 중에서 더 작은 번호의 1번 노드를 방문한다.</li>
<li>그 다음에 2번 노드를 방문하는게 아니라 주체가 바뀌어서 1번 노드의 인접한 0,3,5번 노드 중 하나를 방문할 계획이다.</li>
<li>0번은 이미 방문했으니 3,5번 중 하나를 다음에 방문한다. 번호가 더 작은 3번 노드를 방문한다.</li>
</ul>
<img src="/img/dfs_3.png" width="500" height="300">
<ul>
<li>위의 그림처럼 더 작은 번호의 3번 노드를 방문한다. 다음에는 선택지가 하나밖에 없다. -&gt; 4번 노드</li>
</ul>
<img src="/img/dfs_4.png" width="500" height="300">
<ul>
<li>역시 선택지는 5번 노드밖에 없다.</li>
</ul>
<img src="/img/dfs_5.png" width="500" height="300">
<ul>
<li>5번 노드에서 더 이상 방문할 인접 노드가 없다. 모두 방문했기 때문.</li>
<li>이때는 5번 노드에서 추가로 다른 노드를 방문하지 않고, 자기를 불렀던 4번 노드로 돌아가서 4번 노드의 인접한 노드들 중 아직 방문하지 않은 정점을 찾아 방문해야 한다.</li>
<li>4번에서도 그게 없다면, 4번을 불렀던 3번으로 돌아가고 이와 같은 과정을 반복해서 0번 노드까지 돌아가게 된다.</li>
</ul>
<img src="/img/dfs_6.png" width="500" height="300">
<ul>
<li>0번 노드의 인접한 정점 중 아직 방문하지 않은 나머지 정점 2번 노드를 방문한다.</li>
</ul>
<img src="/img/dfs_7.png" width="500" height="300">
<ul>
<li>2번 노드는 마찬가지로 6번 노드를 방문한다.</li>
</ul>
<img src="/img/dfs_8.png" width="500" height="300">
<ul>
<li>6번 노드는 7번 노드를 이어서 방문한다.</li>
<li>여기서 또 7번 노드는 더 이상 방문할 곳이 없다.</li>
<li>이제 6번 노드로 돌아가서 6번 노드의 인접한 다른 정점인 8번 노드를 방문한다.</li>
</ul>
<img src="/img/dfs_9.png" width="500" height="300">
<ul>
<li>8번 노드를 방문하고 나면 아무리 돌아가도 더 이상 남아 있는 노드 중 방문할 정점이 없다.</li>
<li>이러면 탐색이 종료된 것이고, <strong>시작점인 0번 노드와 직/간접적으로 연결되어 있는 모든 노드를 탐색한 것이다.</strong></li>
</ul>
<p>이 과정에서 만약 어떤 정점에서 더 방문할 노드가 없다면 자신을 불렀던 정점으로 돌아간다.<br>
이걸 구현하기 위해서 <code>스택(Stack)</code>을 사용한다.</p>
<p>방문하는 순서대로 정점을 스택에 쌓고, 방문이 끝나면 스택에서 pop하는 형태로 구현이 가능하다. 재귀 함수 또한 스택 메모리 공간에 쌓아 올려지는 구조를 띄므로 재귀 함수를 사용하여도 이것을 구현할 수 있다.</p>
<p><strong>시간 복잡도</strong></p>
<p>인접 행렬을 사용하는 경우 : <code>O(V^2)</code><br>
인접 리스트를 사용하는 경우 : <code>O(V+E)</code> - 정점과 간선의 개수 합이다.</p>
<h2 id="bfs"># BFS</h2>
<p>역시 모든 정점을 한 번씩 순회한다.<br>
DFS와 대립되는 성질을 갖고 있으며, 사용되는 곳도 매우 다르다.<br>
<strong>BFS</strong> 역시 컴포넌트의 개수를 세거나 각 컴포넌트의 크기를 구하는데는 사용 가능하다.</p>
<p>DFS가 한 우물만 계속 파다가 끝을 보고 나서야 다른 곳으로 옮기는 데 반해, BFS는 <strong>모든 곳을 똑같이 조금씩 조금씩 판다.</strong></p>
<img src="/img/bfs_1.png" width="500" height="300">
<ul>
<li>dfs와 동일한 그래프를 사용한다.</li>
<li>맨 처음에 0번 정점부터 방문을 시작한다.</li>
</ul>
<img src="/img/bfs_2.png" width="500" height="300">
<ul>
<li>DFS와 다르게 <strong>0번 정점과 인접한 정점들부터 무조건 먼저 다 방문된다.</strong></li>
</ul>
<img src="/img/bfs_3.png" width="500" height="300">
<ul>
<li>그 다음은 바로 전 단계에서 방문한 1,2번 정점들로부터 인접한 3,5,6,8번 정점들이 반드시 먼저 방문된다.</li>
</ul>
<img src="/img/bfs_4.png" width="500" height="300">
<ul>
<li>마지막으로 4,7번 정점이 방문된다.</li>
<li>각 단계의 정점들은 그 안에서 방문 순서가 바뀔 수는 있지만, 다른 단계와는 방문 순서가 절대 뒤섞이지 않는다.</li>
<li>0번 노드, 즉 시작점을 방문한 것을 0단계라 하고 그 다음부터 1,2,3 단계라고 부를 때, <strong>K단계에 방문하는 정점들은 시작점으로부터 최단거리가 k이다.</strong></li>
<li>최단 거리 : 여기서는 가중치가 없으니까 A와 B의 최단거리는 A에서 B로 이동하는데 필요한 최소 개수의 간선이라고 보면 된다.</li>
</ul>
<p>DFS에 스택이 필요했던 것과 대조적으로 <strong>BFS는 큐가 필요하다.</strong><br>
BFS는 먼저 방문한 노드들부터 본다.</p>
<p>먼저 시작점을 큐에 넣고 방문했다고 표시한다.<br>
그리고 큐가 비어있지 않을 때까지 방문을 시도한다.<br>
큐에서 지금 나온 정점의 인접한 노드들 중 아직 방문하지 않은 애들을 다시 큐에다 넣어준다.<br>
이런 식으로 먼저 방문한 노드들부터 차례대로 방문해 나간다.</p>
<ul>
<li>모든 가중치가 1인 경우에 최단 거리를 찾는 알고리즘이 된다.<br>
최단 거리를 찾는 문제일 때, 모든 가중치가 1이라면 BFS를 사용한다.</li>
</ul>
<h2 id="마치며">마치며…</h2>
<p>음, 아직 뭔가 감이 잡히진 않는다.<br>
그래프를 탐색할 때 DFS와 BFS의 차이점은 알겠고 개념도 알겠는데 문제를 풀 때 어떻게 구현해야 하는지 잘 모르겠다.<br>
다음 포스팅에서 직접 구현해보면서 정리해보도록 하겠다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://kks227.blog.me/220785731077" target="_blank" rel="noopener">깊이 우선 탐색(Depth-First Search) (수정 2019-02-17)</a></li>
<li><a href="https://kks227.blog.me/220785747864" target="_blank" rel="noopener">너비 우선 탐색(Breadth-First Search) (수정 2018-11-22)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/04/01/Algo-What-is-DFS/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/26/Java-Diff-Array-ArrayList/"
                            aria-label=": [Java] Array VS ArrayList"
                        >
                            [Java] Array VS ArrayList
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-26T12:54:58+09:00">
	
		    Mar 26, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>정렬과 관련된 알고리즘 문제를 풀고 있었다.<br>
문제는 <a href="https://www.acmicpc.net/problem/11650" target="_blank" rel="noopener">좌표 정렬하기</a>이다.<br>
비교적 간단한 문제이지만 Array와 ArrayList 모두 사용해서 풀 수 있는 문제이다.</p>
<p>하지만, <strong>실행 시간이 다르다.</strong> 왜 다른지 찾아보기로 했다.</p>
<ol>
<li>배열(Array)</li>
</ol>
<ul>
<li>배열의 크기는 한번 정하면 변경할 수 없다.</li>
<li>ex) int[] arr = new int[10];</li>
<li>배열 초기화 시에 메모리에 할당되어 ArrayList보다 빠른 속도를 가진다.</li>
<li>다차원이 가능하다.</li>
</ul>
<ol start="2">
<li>ArrayList</li>
</ol>
<ul>
<li>크기가 가변적이다. 저장하는 데이터의 수에 따라서 크기가 변한다.</li>
<li>데이터 추가는 add(), 삭제는 remove()를 사용한다.</li>
<li>데이터 추가, 삭제 시 <strong>메모리를 재할당하기 때문에 속도가 배열보다 느리다.</strong></li>
</ul>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="http://blog.naver.com/PostView.nhn?blogId=sangrime&amp;logNo=220622445166" target="_blank" rel="noopener">[JAVA] Array와 ArrayList 차이와 사용법</a></li>
<li><a href="https://allg.tistory.com/26" target="_blank" rel="noopener">[자료구조/List] 자바 배열(Array)과 ArrayList 차이점 및 활용</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/26/Java-Diff-Array-ArrayList/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/25/java-data-structure/"
                            aria-label=": [Java] 기초"
                        >
                            [Java] 기초
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-25T12:27:02+09:00">
	
		    Mar 25, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Java/">Java</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바를 사용해 알고리즘을 풀 때 유용하게 사용되는 것들을 정리합니다.</p>
<h1 id="입력"># 입력</h1>
<p>자바에서 입력을 받는 방법은 아래와 같이 두 가지가 존재합니다.</p>
<ol>
<li>Scanner 클래스 사용</li>
<li>BufferedReader 객체 사용</li>
</ol>
<h2 id="scanner"># Scanner</h2>
<ul>
<li>가장 간단하게 입력 받을 수 있는 방법.</li>
<li>BufferedReader보다 나중에 등장했다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Scanner 객체 생성</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 숫자를 입력.</span></span><br><span class="line"><span class="keyword">int</span> number = sc.nextInt(); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 공백을 포함시키지 않고 입력을 받는다.</span></span><br><span class="line">String word1 = sc.next(); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 공백을 포함해서 입력을 받는다.</span></span><br><span class="line">String word2 = sc.nextLine(); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 문자열을 입력받아서 문자열의 첫번째 문자에 접근할 수 있다.</span></span><br><span class="line"><span class="keyword">char</span> ch = sc.next().charAt(<span class="number">0</span>); </span><br><span class="line">   String str = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line">str.charAt(<span class="number">0</span>); <span class="comment">// 'H' </span></span><br><span class="line">str.charAt(<span class="number">1</span>); <span class="comment">// 'e'</span></span><br><span class="line">str.charAt(<span class="number">2</span>); <span class="comment">// 'l'</span></span><br><span class="line">str.charAt(<span class="number">3</span>); <span class="comment">// 'l'</span></span><br><span class="line">str.charAt(<span class="number">4</span>); <span class="comment">// 'o'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>str.charAt() : <code>charAt()</code>을 이용해서str 문자열에 존재하는 문자에 접근할 수 있습니다. () 안에는 인덱스를 이용해서 접근합니다.</li>
</ul>
<ul>
<li>charAt() : index를 사용해 문자열에서 문자 하나에 접근할 수 있다.</li>
<li>문자열 입력
<ul>
<li>sc.next() : 문자열에 개행문자나, 공백이 존재하면 무시하고 문자열만 입력받는다.</li>
<li>sc.nextLine() : 문자열에 공백이 존재하면 포함시켜서 그대로 입력받습니다. 한 줄 단위로 입력받기 때문에 개행문자도 한 줄로 인식합니다.</li>
</ul>
</li>
</ul>
<p><strong>장점</strong><br>
Scanenr는 사용하기 편리하다.<br>
세분화 시켜서 데이터를 입력 받을 수 있다는 점입니다.</p>
<ul>
<li><strong>sc.nextInt()</strong> : Int형 데이터를 입력받습니다.</li>
<li><strong>sc.nextDouble()</strong> : Double형 데이터를 입력받습니다.</li>
<li><strong>sc.nextBoolean()</strong> : Boolean형 데이터를 입력받습니다.</li>
<li><strong>sc.next()</strong> :  String형 데이터를 입력받지만, 공백을 포함한 문자열에서 공백은 포함하지 않고, 공백 전까지만 입력받습니다.</li>
<li><strong>sc.nextLine()</strong> : String형 데이터를 입력받지만, 공백을 포함한 문자열에서 공백을 포함해서 입력받습니다.</li>
</ul>
<p><strong>단점</strong><br>
BuffredReader보다 속도가 느리다는 단점이 존재한다.</p>
<h2 id="bufferedreader"># BufferedReader</h2>
<ul>
<li>Scanner보다 속도가 훨씬 빠르다.</li>
<li>사용법이 Scanner보다 선언할 게 많다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BufferedReader 객체 선언</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">int</span> number = Integer.parseInt(br.readLine());</span><br></pre></td></tr></table></figure>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(<a href="http://System.in" target="_blank" rel="noopener">System.in</a>));</p>
<p><code>readLine()</code>는 데이터를 읽어오는 함수이고, String 리턴 값을 가진다.</p>
<p><code>InputStreamReader</code>는 입력을 character 단위로 읽어 들인다. 키보드로 입력하는 글자 한개에 해당된다고 할 수 있습니다. 하지만 한 글자가 아닌 줄 단위의 문자열을 입력으로 받으려면 불편하다. 어떻게 해야 할까??</p>
<p>정답은 BufferedReader이다.</p>
<p><code>BufferedReader</code>는 InputStreamReader에 버퍼링 기능을 추가한 것으로 데이터를 사용자가 요청할 때마다 매번 읽어오기 보다는 <strong>일정량 사이즈</strong>로 한번에 읽어온 후 <strong>Buffer</strong>에 보관합니다. 그리고 사용자가 요구할 때 버퍼에서 읽어오게 합니다. 결국 BufferedReader를 이용하면 속도를 향상시키고 시간의 부하를 줄일 수 있게 됩니다.</p>
<p><strong>StringTokenizer</strong></p>
<ul>
<li>Scanner의 경우 <strong>nextInt</strong>()는 입력하면 자동으로 공백 다음의 숫자를 받는다.</li>
<li>입력받은 String에서 구분자를 통해서 구분하기 위해서 사용한다.</li>
<li>기본 설정은 공백을 기준으로 문자열을 나눈다.</li>
<li>split() 함수와 비슷하다.</li>
<li><code>nextTokne()</code> 함수를 사용해 입력 값을 공백으로 구분하여 순서대로 호출할 수 있다.</li>
</ul>
<p><strong>Scanner</strong>의 경우 그냥 nextInt를 입력하면 알아서 공백 다음 숫자를 받기 때문에 어려움 없이 사용할 수 있지만, 이 부분에서도 BufferedReader를 사용할 경우에는 조금 다른 방식을 취해야합니다. <code>StringTokenizer</code>를 이용하는 방식입니다. 이름과 같이 String을 특정 <strong>구분자값</strong>을 통해 분리하는 함수입니다. 기본적으로는 공백을 기준으로 문자열을 가릅니다. <code>split()</code>함수와 비슷하다고 생각하면 됩니다.</p>
<p>사용법은 어렵지 않다. 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">StringTokenizer st = <span class="keyword">new</span> StringTokenizer(br.readLine());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> test = Integer.parseInt(st.nextToken());</span><br><span class="line"><span class="keyword">int</span> number = Integer.parseInt(st.nextToken());</span><br></pre></td></tr></table></figure>
<h2 id="결론"># 결론</h2>
<p><strong>Scanner</strong></p>
<ul>
<li>버퍼 크기 : 1024 chars</li>
<li>입력하는 데이터 타입에 따라 다르게 입력받을 수 있다.</li>
<li>동기화되지 않는다.</li>
<li>예외를 숨긴다.</li>
</ul>
<p><strong>BufferedReader</strong></p>
<ul>
<li>버퍼 크기 : 8192 chars</li>
<li>문자열을 읽고 원하는 타입으로 바꾸기 위해 형 변환을 진행한다.</li>
<li>동기화가 된다.</li>
<li>예외 발생시 IOException 처리를 던진다.</li>
<li>큰 파일을 읽을 때는 버퍼 크기가 크므로 BufferedReader이 좋습니다.</li>
</ul>
<p>동기화라는 것에 대해서 조금 살펴보았습니다. 이 부분은 운영체제(즉, OS) 분야에서 다루는 내용이지만, 꼭 알아야 하는 내용이기도 합니다. 저는 아직 OS 공부를 하지 않았지만, 공부하면서 찾아본 내용과 예전 학교 수업시간에 들었던 내용을 떠올리면서 정리했습니다.</p>
<p><strong>BufferedReader는 멀티 쓰레드에 안전하고, Scanner는 안전하지 않다.</strong> 라는 말이 있습니다. 그것이 위에서의 3번의 경우입니다.</p>
<p>멀티 쓰레드의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유하기 때문에 서로의 작업에 영향을 줄 수 있습니다. 예를 들어, A 쓰레드가 작업 중입니다. 그러던 중 B 쓰레드에게 넘깁니다. B 쓰레드에서 공유 데이터를 변경하고 A 쓰레드에 다시 제어권을 넘긴다면 예기치 않은 결과가 나올 수 있습니다. 제대로 된 처리를 위해서는 A 쓰레드가 작업이 끝날 때까지 다른 쓰레드가 영향을 주지 않아야 합니다.</p>
<p>그리하여 멀티 쓰레드를 활용하는 소켓 예제에서는 대부분 BufferedReader를 많이 사용한다고 합니다.</p>
<h1 id="pair"># Pair</h1>
<ul>
<li><strong>두 자료형 T1과 T2를 묶어서 사용할 수 있도록 해주는 역할을 합니다.</strong></li>
<li>같은 자료형 뿐만 아니라 서로 다른 자료형 T1과 T2를 묶어서 사용할 수 있도록 해주는 역할을 합니다.</li>
<li>즉, 두 객체를 하나의 객체로 취급할 수 있도록 묶어주는 클래스입니다.</li>
</ul>
<h2 id="구현"># 구현</h2>
<p>항상 두 개를 묶어서 사용하고, 첫 번째 자료는 first, 두 번째 자료는 second로 접근할 수 있습니다. C++ 언어에서는 STL이라는 Standard Template Library를 이용해서 사용할 수 있지만, 자바에서는 제공되지 않아서 직접 구현해서 사용해야 하는 것으로 알고 있습니다.</p>
<p>자바는 기본적으로 반환 결과를 2개 이상 제공하지 않습니다. 그래서 2개 이상의 결과를 반환 받기 위해서는 객체나 배열의 형태를 보이게 됩니다. C++에서는 pair가 존재하지만, 자바에서는 없는 것으로 알고 있습니다.<br>
여러가지 자료를 찾아보다가 밑에 코드를 찾았습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">L</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> L left;</span><br><span class="line">      <span class="keyword">final</span> R right;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(L left, R right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &lt;L,R&gt; <span class="function">Pair&lt;L,R&gt; <span class="title">of</span><span class="params">(L left, R right)</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;L,R&gt;(left, right);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="tuple"># Tuple</h1>
<ul>
<li><code>Tuple이란 여러 개의 자료형을 묶을 수 있는 클래스입니다.</code></li>
<li>tuple은 pair와 같지만 두 개가 아니라 여러 개를 묶을 수 있습니다.</li>
<li>.first, .second, .third …가 아니고 get을 이용해서 인덱스로 접근해야 합니다.</li>
</ul>
<h2 id="구현">구현</h2>
<p>자바에서는 pair와 tuple이 존재하지 않기 때문에 구현해서 사용해야 합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tuple</span>&lt;<span class="title">X</span>,<span class="title">Y</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> X x;</span><br><span class="line">   <span class="keyword">private</span> Y y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(X x, Y y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> X <span class="title">getX</span><span class="params">()</span></span>&#123; <span class="comment">// get을 이용해서 접근</span></span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Y <span class="title">getY</span><span class="params">()</span></span>&#123; <span class="comment">// get을 이용해서 접근</span></span><br><span class="line">      <span class="keyword">return</span> y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(X x)</span></span>&#123; <span class="comment">// set을 이용해서 값을 설정</span></span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(Y y)</span></span>&#123; <span class="comment">// set을 이용해서 값을 설정</span></span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="biginteger"># BigInteger</h1>
<p>Java에서 정수를 계산할 때, byte,short,int,long등의 기본 데이터 타입의 범위를 초과하는 경우가 있습니다. 이런 경우에, <code>BigInteger Class를 사용하는 방법이 있습니다.</code></p>
<p>기본 자료형 크기 이상의 정수가 필요하다면 <strong>BigInteger Class</strong>를 사용할 수 있습니다.<br>
<code>BigInteger Class는 숫자의 크기에 제한 없이 무한대의 정수를 저장할 수 있습니다.</code><br>
math 클래스에 포함되어 있습니다.</p>
<blockquote>
<p>즉, 범위는 <code>무한대</code></p>
</blockquote>
<h2 id="객체-생성-방법">객체 생성 방법</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"100000"</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"1000"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="연산">연산</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"a+b = "</span> + a.add(b)); <span class="comment">// 더하기</span></span><br><span class="line">System.out.println(<span class="string">"a-b = "</span> + a.subtract(b)); <span class="comment">// 빼기</span></span><br><span class="line">System.out.println(<span class="string">"a*b = "</span> + a.multiply(b)); <span class="comment">// 곱하기</span></span><br><span class="line">System.out.println(<span class="string">"a/b = "</span> + a.divide(b)); <span class="comment">// 나누기(몫)</span></span><br><span class="line">System.out.println(<span class="string">"a%b = "</span> + a.remainder(b)); <span class="comment">// 나머지</span></span><br><span class="line">System.out.println(<span class="string">"gcd(a,b) = "</span> + a.gcd(b)); <span class="comment">//a와 b의 최대공약수</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"ZERO = "</span> + BigInteger.ZERO); <span class="comment">// 0</span></span><br><span class="line">System.out.println(<span class="string">"ONE = "</span> + BigInteger.ONE); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="string">"TEN = "</span> + BigInteger.TEN); <span class="comment">// 10</span></span><br><span class="line">System.out.println(<span class="string">"a^10 = "</span> + a.pow(<span class="number">10</span>)); <span class="comment">// a 제곱</span></span><br></pre></td></tr></table></figure>
<h2 id="비교">비교</h2>
<ul>
<li>compareTo - int type의 변수를 사용</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = sc.nextBigInteger(); <span class="comment">// 무한대의 정수를 입력받을 수 있다.</span></span><br><span class="line">BigInteger b = sc.nextBigInteger(); <span class="comment">// 무한대의 정수를 입력받을 수 있다. </span></span><br><span class="line"><span class="keyword">int</span> c = a.compareTo(b);</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123; <span class="comment">// a가 b보다 작을 경우</span></span><br><span class="line">    System.out.println(<span class="string">"&lt;"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// a와 b가 같은 경우</span></span><br><span class="line">    System.out.println(<span class="string">"=="</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// a가 b보다 클 경우</span></span><br><span class="line">    System.out.println(<span class="string">"&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"compareTo = "</span> + c);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>equals - boolean type의 변수를 사용</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> e = a.equals(b);</span><br><span class="line"><span class="keyword">if</span>(e)&#123;</span><br><span class="line">	System.out.println(<span class="string">"=="</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"!="</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"equals = "</span> + e);</span><br></pre></td></tr></table></figure>
<h2 id="주의할-점">주의할 점</h2>
<p>Q. 생성자의 매개변수를 <strong>문자형</strong>으로 전달해야 하는 이유는?<br>
A. 숫자형으로 표현할 수 있는 범위를 벗어났기 때문에 문자형으로 표현하는 것입니다.</p>
<h1 id="bigdecimal"># BigDecimal</h1>
<p><strong>BigDecimal</strong>은 <code>무한한 크기의 부동 소수점 숫자</code> 즉, 실수를 다루기 위해 사용됩니다.<br>
이유는 컴퓨터의 특성으로 인해서 float이나 double은 실수 연산시 정확한 결과가 나오지 않기 때문입니다.<br>
하지만, <code>BigDecimal</code>을 사용하면 계산은 번거롭지만 정확한 결과를 얻을 수 있습니다.<br>
<strong>BigInteger</strong>와 유사한 방식으로 숫자를 다룹니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.3"</span>);</span><br><span class="line">BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.4"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(b1.add(BigDecimal.valueOf(<span class="number">0.5</span>)));</span><br><span class="line">System.out.println(b1.multiply(b2));</span><br><span class="line">System.out.println(b1.divide(b2, BigDecimal.ROUND_UP));</span><br><span class="line">System.out.println(b1.divide(b2, <span class="number">5</span>, BigDecimal.ROUND_UP));</span><br><span class="line"></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">BigDecimal a = sc.nextBigDecimal();</span><br><span class="line"><span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">		</span><br><span class="line">System.out.println(a.pow(b).toPlainString());</span><br></pre></td></tr></table></figure>
<h2 id="bigdecimal의-자주-사용되는-메소드">BigDecimal의 자주 사용되는 메소드</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span> <span class="comment">//값을 float형으로 반환</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span> <span class="comment">//값을 double형으로 반환</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigInteger <span class="title">toBigInteger</span><span class="params">()</span> <span class="comment">//값을 BigInteger로 반환 (소수점 아래는 날아감)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span> <span class="comment">//덧셈 + 연산</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal subtrahend)</span> <span class="comment">//뺄셈 - 연산</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal multiplicand)</span> <span class="comment">//곱셈 * 연산</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor)</span> <span class="comment">//나눗셈 / 연산</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">remainder</span><span class="params">(BigDecimal divisor)</span> <span class="comment">//나머지 % 연산</span></span></span><br></pre></td></tr></table></figure>
<p>일반 실수형을 계산할 때는 아래와 같은 오차가 발생합니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">  d1 += d2;</span><br><span class="line">  System.out.println(d1);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">결과 : </span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.2000000000000002</span></span><br><span class="line"><span class="number">1.3000000000000003</span></span><br><span class="line"><span class="number">1.4000000000000004</span></span><br><span class="line"><span class="number">1.5000000000000004</span></span><br></pre></td></tr></table></figure>
<p>BigDecimal의 생성자는 여러가지가 있지만, <strong>가장 정확한 계산을 위해서는 문자열을 인자로 하는 생성자를 이용해야 합니다.</strong> 실수형 인자를 사용하면 정확한 계산의 의미가 없어집니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">0.1</span>;  </span><br><span class="line"></span><br><span class="line">BigDecimal bd1 = <span class="keyword">new</span> BigDecimal(String.valueOf(d1));</span><br><span class="line">BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(String.valueOf(d2)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)&#123;</span><br><span class="line">  bd1 = bd1.add(bd2);</span><br><span class="line">  System.out.println(bd1.toString());</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">결과 :</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line"><span class="number">1.3</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="number">1.5</span></span><br></pre></td></tr></table></figure>
<p>그리고 <strong>BigDecimal</strong>의 값을 출력하려면 setScale(scale, roundingMode)로 단위 및 라운딩 모드를 설정하거나 toString() 또는 toPlainString() 메소드를 사용한다. <strong>toString()</strong> 메소드는 과학적 표기를 사용할 수 있지만, <strong>toPlainString()</strong> 메소드는 그렇지 않습니다.</p>
<blockquote>
<p>과학적 표기란? <code>0.1^10</code>의 <strong>과학적 표기</strong>는 <strong>1E-10</strong> 그렇지 않은 <strong>일반 표기</strong>는 <strong>0.0000000001</strong></p>
</blockquote>
<h1 id="bufferedwriter"># BufferedWriter</h1>
<ul>
<li>일반적으로 출력할 때 <code>System.out.prinlnt()</code> 사용</li>
<li>테스크 케이스가 작을 때는 속도 차이가 미미하다. 하지만 테스트 케이스가 매우 커지면 속도 차이가 확연하다고 한다.</li>
<li>언제 사용하고 언제 사용하지 않을까?
<ul>
<li>출력이 많은 경우 : BuffredWriter 사용.</li>
<li>출력이 적은 경우 : System.out.println() 사용.</li>
</ul>
</li>
<li>bw(BuffredWriter 객체)의 사용이 끝나면 flush()나 close() 함수를 이용해 객체를 반환해줘야 한다. 반환하지 않으면 출력이 제대로 이뤄지지 않을 수도 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">bw.writer(<span class="string">"Hello \b"</span>);</span><br><span class="line">bw.flush();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure>
<h1 id="eof"># EOF</h1>
<hr>
<ul>
<li>알고리즘 문제를 풀다 보면 EOF 문제에 대해 봉착하는 경우가 있습니다.</li>
<li><strong>EOF(End Of File)</strong> : <strong>파일 끝</strong>을 의미하며, 데이터 소스로부터 더 이상 읽을 데이터가 없음을 나타냅니다.</li>
</ul>
<p>알고리즘 문제를 풀다보면 <strong>입력 부분의 기준이 없는</strong> 문제를 본 적이 있을 것입니다. 자바에서는 입력 클래스가 <strong>Scanner,BufferedReader</strong> 2가지로 구성됩니다.</p>
<p><strong># Scanner 클래스의 EOF 처리 방법</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(sc.hasNextLine())&#123;</span><br><span class="line">	sc.nextLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(sc.hasNextInt())&#123;</span><br><span class="line">	sc.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong># BufferedReader의 EOF 처리 방법</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">String input = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((input = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="배열"># 배열</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] array2;</span><br><span class="line"></span><br><span class="line">array2 = Arrays.copyOf(array1,<span class="number">10</span>);</span><br><span class="line">Arrays.sort(array1);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Arrays.copyOf(array1,10)</code> : arrya1을 길이 10으로 해서 똑같이 복사하는 함수입니다.</li>
<li><code>Arrays.sort(array1)</code> :  array1을 정렬해주는 함수입니다. 자바 컬렉션 프레임워크 중의 하나로 볼 수 있습니다.</li>
</ul>
<h1 id="입력-속도-비교"># 입력 속도 비교</h1>
<hr>
<p>Scanner와 BufferedReader의 입력 받는 속도를 비교해본다.</p>
<p><strong>1. Scanner를 이용해 100만까지의 데이터를 입력받는다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inputExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">long</span> st1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            t= sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"소요 시간 : "</span>+(System.currentTimeMillis() - st1)+<span class="string">"ms"</span>);</span><br><span class="line">        sc.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">소요시간 : <span class="number">2441</span>ms</span><br></pre></td></tr></table></figure>
<ul>
<li>소요 시간 : 2.5초</li>
<li>빠른 것 같지만 실제 알고리즘 문제에서 수의 범위는 천만~1억에 이르는 경우도 종종 있다.</li>
<li>다른 연산도 있기 때문에 빠른 속도라고는 할 수 없다.</li>
</ul>
<p><strong>2. BufferedReader를 이용해 100만까지의 데이터를 입력받는다.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inputExam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        bf.readLine();</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">long</span> st2 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            t = Integer.parseInt(bf.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"소요 시간 : "</span>+(System.currentTimeMillis() - st2)+<span class="string">"ms"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">소요 시간 : <span class="number">4</span>ms</span><br></pre></td></tr></table></figure>
<ul>
<li>소요 시간 : 0.4초</li>
<li>한 줄을 통째로 입력 받는 방식이기 때문에 1 2 3 4 … 과 같이 한 줄로 입력이 들어올 때 Scanner에 비해 훨씬 성능이 높다.</li>
<li>문제를 풀 때 코드의 문제가 없는데 시간 초과가 난다면 문제의 범위를 다시 확인해보고 입력 방식을 알맞게 바꾸면 해결할 수 있을 것이다.</li>
</ul>
<h2 id="bufferedreader-추가-이야기"># BufferedReader 추가 이야기!</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">String s = bf.readLine(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> a = bf.read(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(bf.readLine()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1번 : 입력받을 값이 String일 때</li>
<li>2번 : 입력받을 값이 int일 때</li>
<li>3번 : int 값 + enter 까지 입력받을 때</li>
</ul>
<p>알고리즘 사이트에서 대부분의 데이터 입력은 한줄씩 띄워진 상태로 입력이 들어옵니다. 따라서 <strong>int b</strong>를 입력받은 방법처럼 일단 스트링으로 개행문자(엔터)까지 포함해 통째로 받아온 다음 형 변환을 통해 저장합니다.</p>
<p>또한 new BufferedReader(new InputStreamReader(<a href="http://System.in" target="_blank" rel="noopener">System.in</a>),1024); 이렇게 버퍼 사이즈를 직접 지정할 수도 있는데, 아무것도 지정하지 않을 시 디폴트 사이즈 버퍼를 갖습니다. 어지간한 문제는 디폴트 사이즈로 충분하다고 하네요… ㅎㅎ;</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/25/java-data-structure/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/24/Algo-Get-the-Prime/"
                            aria-label=": [소수 구하기] 에라토스테네스의 체"
                        >
                            [소수 구하기] 에라토스테네스의 체
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-24T14:09:02+09:00">
	
		    Mar 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>소수를 구하는 방법은 여러가지가 있다. 하지만 시간이 덜 거리고 빠르게 찾을 수 있는 방법이 있다면 사람들은 그 방법을 사용하지 않을까? 맞다. 사람들은 짧은 시간이 걸리는 것을 선호한다. 세상의 공짜란 없듯이 짧은 시간이 걸리는 방법은 구현 방법이 기존보다는 조금 어렵다. 그렇다면 어떤 방법인지 알아보자.</p>
<blockquote>
<p>소수란?</p>
</blockquote>
<p>1과 자기 자신으로만 나누어 떨어지는 수를 <strong>소수</strong>라고 한다. 즉, 자기 자신보다 작은 수들로 나누어봐서 하나라도 나누어 떨어지는 수가 존재하면 소수가 아니라는 뜻이다.</p>
<h2 id="에라토스테네스의-체">에라토스테네스의 체</h2>
<p><strong>소수</strong>의 개념을 간단하게 알아봤으니 <code>에라토스테네스의 체</code> 방법을 알아보자.</p>
<ul>
<li>120까지의 모든 소수를 구한다고 가정해보자.</li>
<li>2부터 120까지 수를 배열에 모두 넣는다.</li>
<li><strong>소수가 아닌 수들을 모두 체크해버린다.</strong></li>
</ul>
<p>2를 제외한 모든 2의 배수를 체크한다.<br>
3을 제외한 모든 3의 배수를 체크한다.<br>
4를 제외한 모든 4의 배수를 체크한다.</p>
<p>이와 같은 방식으로 소수가 아닌 수들을 체크한다. 그러면 배열에서 체크되지 않은 수들은 <strong>소수만 남게 된다.</strong> 생각보다 그렇게 어렵지 않고 간단하게 이해하고 구현할 수 있다.</p>
<h2 id="첫-번째-방법"># 첫 번째 방법</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_LINE = <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="comment">// 자신과 같지 않고 0으로 나누어 떨어지면 소수가 아니다. </span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] !=i &amp;&amp; arr[j] % i == <span class="number">0</span>)&#123;</span><br><span class="line">                    arr[j] = <span class="number">0</span>; <span class="comment">// 소수가 아닌 경우 0을 넣는다. </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                bw.write(i + NEW_LINE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 방식으로 구하면 <strong>에라토스테네스의 체</strong> 방식을 이용하지 않는 방식보다 시간이 오래 걸린다. 그러면 우리가 이 방식을 사용하는 의미가 없지 않는가?? 이제 <strong>에라토스테네스의 체</strong>를 이용해 최상의 소수 구하기 프로그램을 만들어보자.</p>
<h2 id="두-번째-방법"># 두 번째 방법</h2>
<p>체크할 때 모든 수를 다 돌면서 체크할 필요 없이 <strong>체크할 배수만큼만 반복문을 돌게 하는 것</strong>이다. 그리고 이미 <strong>0으로 체크되어버린 수의 배수는 확인하지 않는다.</strong> 왜냐하면 어떤 수가 소수가 아니라면 그 수의 배수도 소수가 아니기 때문이다.</p>
<p>ex)<br>
2를 제외한 2의 배수를 체크한다.<br>
2,4,6,8,10,12,14 …</p>
<p>4를 제외한 4의 배수를 체크한다.<br>
4,6,8,12,16,…<br>
<code>이미 2의 배수를 체크할 때 체크가 되어 있기 때문에 건너뛸 수 있다.</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_LINE = <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPACE = <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        String[] input = br.readLine().split(SPACE);</span><br><span class="line">        <span class="keyword">int</span> m = Integer.parseInt(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 에라토스테네스의 체에서 0과 1은 제외하고 시작하기 때문에 체크한다.</span></span><br><span class="line">        check[<span class="number">0</span>] = check[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 체크되어 있으면 건너뛴다.</span></span><br><span class="line">            <span class="comment">// 체크가 되어 있다는 뜻은 소수가 아니라는 뜻이다.</span></span><br><span class="line">            <span class="keyword">if</span> (check[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 해당 수의 배수만큼 반복문을 돌면서 체크한다. </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="comment">// 소수가 아닌 것들을 true로 체크한다.</span></span><br><span class="line">                check[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!check[i]) &#123;</span><br><span class="line">                bw.write(i + NEW_LINE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 경우 결과는 매우 짧은 시간이 나오는 것을 확인할 수 있었다. 앞으로 소수를 구할 때는 <code>에라토스테네스의 체</code> 방식을 이용하자.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://marobiana.tistory.com/91" target="_blank" rel="noopener">소수 구하기 최적의 알고리즘 (2) - 에라토스테네스의 체</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/24/Algo-Get-the-Prime/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/23/Algo-Shell-Sort/"
                            aria-label=": [알고리즘] 정렬 알고리즘 Part2"
                        >
                            [알고리즘] 정렬 알고리즘 Part2
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-23T01:05:14+09:00">
	
		    Mar 23, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>저번에 살펴봤던 기본적인 정렬 알고리즘에 이어 이번에는 조금 어려운 정렬 알고리즘을 살펴보자. 물론 이번 것도 어려운 것은 아니지만 상대적으로 비교해봤을 때 저번 정렬 알고리즘들보다 어렵다!</p>
<h2 id="쉘-정렬"># 쉘 정렬</h2>
<ul>
<li><strong>삽입 정렬을 보완</strong>한 알고리즘이다.</li>
<li>삽입 정렬이 어느 정도 정렬된 배열에 대해서는 대단히 빠르다는 것에 착안한 것이다.
<ul>
<li>삽입 정렬의 최대 문제점 : 요소들이 삽입될 때, 이웃한 위치로만 이동한다.</li>
<li>다시 말해서 만약 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야 제자리로 갈 수 있다.</li>
<li>삽입 정렬과 다르게 <strong>쉘 정렬</strong>은 전체의 리스트를 한 번에 정렬하지 않는다. 그래서 <strong>요소들이 멀리 떨어진 위치로 이동할 수 있다.</strong></li>
</ul>
</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ol>
<li>먼저 정렬해야 할 리스트를 일정한 기준에 따라 분류한다.</li>
<li>연속적이지 않은 여러 개의 부분 리스트를 생성한다.<br>
(실제로 여러 개의 부분 리스트가 생기고 이것들을 병합하는 것이 아니라, 단순히 gap 값으로 간격을 주어 부분 리스트가 만들어진 것처럼 구현한다. )</li>
<li>각 부분 리스트를 삽입 정렬을 이용하여 정렬한다.</li>
<li>모든 부분 리스트가 정렬되면 다시 전체 리스트를 더 적은 개수의 부분 리스트로 만든 후에 알고리즘을 반복한다.</li>
<li>위의 1~4번까지의 과정을 리스트의 개수가 1이 될 때까지 반복한다.</li>
</ol>
<p>기본 로직은 이렇지만 사실 잘 와닿지 않는다. 한 번 더 살펴보자.</p>
<ul>
<li>정렬해야 할 리스트의 각 <strong>k번째</strong> 요소를 추출해서 부분 리스트를 만든다. 이때, k를 <code>간격(gap)</code>이라고 한다.
<ul>
<li>간격(gap) 즉 k의 초기값 : (정렬할 값의 개수) / 2</li>
<li>생성된 부분 리스트의 개수는 gap과 같다.</li>
</ul>
</li>
<li>각 회전마다 간격 k를 절반으로 줄인다. 즉, 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다.
<ul>
<li>간격은 홀수로 하는 것이 좋다. (간격을 정하는 방법은 여러가지다.)</li>
<li>간격을 절반으로 줄일 때 짝수가 나오면 +1을 해서 홀수로 만든다.</li>
</ul>
</li>
<li>간격 k(gap)가 1이 될 때까지 반복한다.</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>연속적이지 않은 부분 리스트에서 자료의 교환이 일어나면 <strong>더 큰 거리를 이동한다.</strong> 따라서 교환되는 요소들이 삽입 정렬보다는 최종 위치에 있을 가능성이 높아진다.</li>
<li>부분 리스트는 어느 정도 정렬된 상태이기 때문에 부분 리스트의 개수가 1이 되게 되면 쉘 정렬은 기본적으로 삽입 정렬을 수행하는 것이지만 <strong>정렬된 상태이므로 삽입 정렬보다 더욱 빠르게 수행된다.</strong></li>
<li>알고리즘이 간단해서 쉽게 구현이 가능하다.</li>
</ul>
<p><strong>시간 복잡도</strong></p>
<ul>
<li>평균 : O(N^1.5)</li>
<li>최악의 경우 : O(N^2)</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>연속적이지 않은 부분 리스트에서 자료의 교환을 진행하여 <strong>더 큰 거리를 이동</strong>한다. 기존의 삽입 정렬에서는 한 칸씩 이동하며 비교를 하여 key 값의 자리를 찾았기 때문에 먼 거리를 이동할 경우 그만큼 반복 비교 연산이 많이 일어나는 단점이 있었다. 더 큰 거리를 이동함으로써 <strong>교환되는 요소들이 삽입 정렬보다는 최종 위치에 더 가까이 있을 가능성이 높아진다.</strong></li>
<li>최종 자리를 더 빨리 찾아감으로써 <strong>연산의 횟수를 줄이는데 기여할 수 있다.</strong></li>
<li>삽입 정렬은 어느 정도 정렬이 된 배열에서 더 빠르게 동작한다는 것을 앞의 포스팅에서 살펴봤다. 이 점을 토대로 한 번에 정렬을 끝내는 것이 아니라 <strong>부분 리스트를 구성해 조금씩 정렬된 상태를 만들어가는 것</strong>이므로 삽입 정렬에 비해 <strong>속도가 점점 더 빠르게</strong> 수행된다.</li>
</ul>
<h2 id="합병-정렬"># 합병 정렬</h2>
<ul>
<li><code>존 폰 노이만</code> 선생님이 제안한 방법.</li>
<li>일반적인 방법으로 구현했을 때 이 정렬은 <strong>안정</strong> (stable) 정렬에 속하며, <strong>분할 정복 알고리즘</strong>의 하나이다.</li>
<li>분할 정복(divide and conquer) 방법
<ul>
<li>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.</li>
<li>분할 정복 방법은 대개 <strong>순환 호출</strong>을 이용하여 구현한다.</li>
</ul>
</li>
<li>오름 차순을 기준으로 정렬한다.</li>
</ul>
<p><strong>기본 로직은 다음과 같다.</strong></p>
<ol>
<li>리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.(리스트의 길이가 1이 될때까지 반으로 잘게 나눈다.) 그렇지 않은 경우에는</li>
<li>정렬되지 않은 리스트를 절반으로 나눠 비슷한 크기의 두 부분 리스트로 나눈다.</li>
<li>각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.</li>
<li>두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.</li>
</ol>
<p><strong>구체적으로 다시 설명해보면 다음과 같다.</strong></p>
<ul>
<li>최종 목표는 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 것이다.</li>
<li>합병 정렬은 다음의 단계들로 이루어진다.
<ul>
<li><strong>분할</strong>(Divide) : 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.</li>
<li><strong>정복</strong>(Conquer) : 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 <code>순환 호출</code>(재귀 호출)을 이용하여 다시 분할 정복 방법을 적용한다.</li>
<li><strong>결합</strong>(Combine) : 정렬된 부분 배열을 하나의 배열에 합병한다.</li>
</ul>
</li>
<li>합병 정렬의 과정
<ul>
<li>추가적인 리스트가 필요하다.</li>
<li>각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다.(재귀 호출)</li>
<li>합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 <strong>합병</strong>(Merge)하는 단계이다.</li>
</ul>
</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>안정적인 정렬 방법이다. <strong>stable</strong>하다.</li>
<li>데이터의 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. -&gt; O(n logn)으로 동일.</li>
<li>만약 레코드를 <strong>연결 리스트</strong>(LinkedList)로 구성하면 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
<ul>
<li>제자리 정렬(in-place sorting)을 구현할 수 있다.</li>
</ul>
</li>
<li>따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>만약 레코드를 <strong>배열</strong>로 구성하면, 임시 배열이 필요하다.
<ul>
<li>메모리 낭비를 초래할 수 있다.</li>
<li>제자리 정렬(in-place sorting)이 아니다.</li>
</ul>
</li>
<li>레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.</li>
</ul>
<p><strong>시간 복잡도</strong><br>
크기가 N인 배열을 반으로 쪼개면서 분할한다.<br>
한 번 분할하면 N/2, N/2 -&gt; 2개가 생기고,<br>
그 다음 분할하면 N/4, N/4, N/4, N/4 -&gt;4개</p>
<p>이처럼 분할 과정은 매번 반씩 감소하므로 밑이 2인 log N만큼 반복해야 크기가 1인 배열로 분할 할 수 있다.</p>
<p>각 분할별로 합병을 진행하므로 합병 정렬의 시간 복잡도는 O(NlogN)이다.</p>
<ul>
<li>평균 : NlogN</li>
<li>최악 : NlogN</li>
<li>최상 : NlogN</li>
</ul>
<p>다음의 글을 참고하자. -&gt; <a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html" target="_blank" rel="noopener">병합 정렬의 시간복잡도</a></p>
<h1 id="퀵-정렬"># 퀵 정렬</h1>
<ul>
<li>오름차순을 기준으로 정렬한다.</li>
<li>'찰스 앤터니 리처드 호어’가 개발한 정렬 알고리즘이다.</li>
<li><strong>불안정 정렬</strong>에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 <strong>비교 정렬</strong>에 속한다.</li>
<li>분할 정복 알고리즘의 하나로, 평균적으로 <code>매우 빠른 수행 속도</code>를 갖는다.
<ul>
<li>Merge Sort와 달리 퀵 정렬은 리스트를 <strong>비균등</strong>하게 나눈다.</li>
</ul>
</li>
<li><strong>분할 정복 방법</strong>(Divide and Conquer)
<ul>
<li>문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.</li>
<li>분할 정복 방법은 순환 호출(재귀 호출)을 이용하여 구현한다.</li>
</ul>
</li>
</ul>
<p><strong>기본 로직은 다음과 같다.</strong></p>
<ol>
<li>리스트 안에서 하나의 원소를 선택한다. 이 원소를 <strong>피봇</strong>이라고 한다.</li>
<li>피봇을 기준으로 왼쪽에는 피봇보다 작은 원소들을 옮기고 오른쪽에는 피봇보다 큰 원소들을 옮긴다.</li>
<li>피봇을 제외한 왼쪽 부분 집합과 오른쪽 부분 집합을 다시 정렬한다.
<ul>
<li>분할된 부분 집합에 대해 <strong>순환 호출</strong>을 이용하여 정렬을 반복한다.</li>
<li>부분 집합에 대해서도 다시 피봇을 정하고 피봇 기준으로 2개의 부분 집합으로 나누는 과정을 반복한다.</li>
</ul>
</li>
<li>부분 집합이 더 이상 분할이 불가능할 때까지 반복한다.
<ul>
<li>리스트의 크기가 0이나 1이 될 때까지 반복한다.</li>
</ul>
</li>
</ol>
<p><strong>퀵 정렬에서 알아야 할 개념</strong></p>
<ul>
<li>분할(Divide) : 정렬할 자료들을 피봇을 중심으로 좌, 우 2개의 부분집합으로 나누는 것을 말한다.</li>
<li>정복(Conquer) : 부분집합의 원소들 중에서 피봇보다 작은 원소들은 왼쪽, 큰 원소들을 오른쪽 부분집합으로 정렬하는 과정이다.</li>
<li>부분 집합의 크기가 더 이상 나눌 수 없을 때까지(부분 집합의 원소가 1개 이하) 분할, 정복 과정이 반복된다.</li>
<li><strong>피봇</strong> : 기준 값(일반적으로 전체 원소 중 가운데에 위치한 원소)</li>
<li>L : 왼쪽에서 오른쪽으로 움직이며 피봇보다 큰 원소를 찾아 L로 지정.</li>
<li>R : 오른쪽에서 왼쪽으로 움직이며 피봇보다 작은 원소를 찾아 R로 지정.</li>
</ul>
<p><strong>장점</strong></p>
<ul>
<li>속도가 빠르다.
<ul>
<li>시간 복잡도가 O(NlogN)을 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.</li>
</ul>
</li>
<li>추가 메모리 공간을 필요로 하지 않는다.
<ul>
<li>퀵 정렬은 O(NlogN) 만큼의 메모리를 필요로 한다.</li>
</ul>
</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
<ul>
<li>퀵 정렬의 불균형 분할을 방지하기 위해 피봇을 선택할 때 리스트를 더욱 균등하게 분할할 수 있는 데이터를 선택한다.</li>
<li>Ex) 리스트 내의 몇 개의 데이터 중에서 크기순으로 <strong>중간 값</strong>을 피봇으로 선택한다.</li>
</ul>
</li>
</ul>
<p><strong>시간 복잡도</strong></p>
<ul>
<li>평균, 최선 : O(NlogN)</li>
<li>최악 : O(N^2)</li>
</ul>
<p>일반적으로는 O(NlogN)의 성능을 나타내지만,<br>
피봇이 항상 최솟값이나 최댓값으로 잡힙다면 최악의 성능인 O(N^2) 나온다.<br>
이미 정렬된 리스트에 대해서 첫 번째 원소 혹은 마지막 원소를 피봇으로 선택할 경우 최악의 성능을 맛 볼 수 있다.</p>
<p><strong>그래서 중간 값을 피봇으로 선택하는 것이 시간 복잡도가 최악의 경우인 O(N^2)을 피할 수 있는 방법이기도 하다.</strong></p>
<h2 id="느낀-점">느낀 점</h2>
<p>정렬 알고리즘은 크게 보면 두 가지 분류로 나눌 수 있을 것 같다.</p>
<ul>
<li>단순(구현이 간단)하지만 비효율적인 방법
<ul>
<li>삽입 정렬, 선택 정렬, 버블 정렬</li>
</ul>
</li>
<li>복잡하지만 효율적인 방법
<ul>
<li>퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬</li>
</ul>
</li>
</ul>
<p>이 중에서 퀵 정렬이 가장 어려웠다. 개념을 이해하고 코드를 보는데 이해가 되지 않았다. 여러 사람들이 정리한 블로그를 참고해서 코드를 보니까 조금씩 구현이 달라서 방향을 잡지 못했다.</p>
<p>그래서 2개의 블로그를 참고해서 코드를 돌려보면서 실제로 디버깅을 해보니까 이해가 확실히 갔다. 생각보다 정렬 알고리즘이 재미있었다. 기억력이 오래 갔으면 좋겠지만 아닐 수도 있으니 빠른 시일 내에 복습을 해야겠다.</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://gmlwjd9405.github.io/2018/05/08/algorithm-shell-sort.html" target="_blank" rel="noopener">[알고리즘] 셸 정렬(shell sort)이란</a></li>
<li><a href="https://mattlee.tistory.com/76" target="_blank" rel="noopener">&lt;셸 정렬(shell sort)&gt; 기본 개념 및 알고리즘</a></li>
<li><a href="https://prosto.tistory.com/177" target="_blank" rel="noopener">퀵 정렬(Quick Sort) - C언어/자료구조</a></li>
<li><a href="https://creatordev.tistory.com/70" target="_blank" rel="noopener">자바로 구현하는 퀵정렬 (Quick Sort) 알고리즘</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html" target="_blank" rel="noopener">[알고리즘] 퀵 정렬(quick sort)이란</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/23/Algo-Shell-Sort/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/20/Algo-Select-Sort/"
                            aria-label=": [정렬] 정렬 알고리즘 Part1"
                        >
                            [정렬] 정렬 알고리즘 Part1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-20T17:04:04+09:00">
	
		    Mar 20, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>정렬 알고리즘은 개발자 면접을 보기 위해서 꼭 필요한 내용이다.<br>
하나씩 정리해보고 숙지해보자.<br>
정렬 알고리즘은 다음과 같이 간단하게 나눠볼 수 있다.</p>
<ul>
<li><strong>단순하지만 비효율적인 방법</strong>
<ul>
<li>선택 정렬, 삽입 정렬, 버블 정렬</li>
</ul>
</li>
<li><strong>복잡하지만 조금 더 효율적인 방법</strong>
<ul>
<li>퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬</li>
</ul>
</li>
</ul>
<p><strong>Q. 정렬은 왜 사용할까?</strong><br>
탐색을 빠르게 하기 위해서 정렬을 한다.<br>
하지만 정렬 방법은 많고 이 중에서 제일 빠른 걸 사용해야 한다.<br>
같은 시간 복잡도를 갖더라도 요소에 따라 달라질 수 있으니 알아보자.</p>
<h2 id="선택-정렬"># 선택 정렬</h2>
<p>기본이 되는 정렬 중 하나이다. 현재 위치에 들어갈 값을 찾아 정렬하는 배열이다. 현재 위치에 저장될 값의 크기가 작냐, 크냐에 따라서 최소 선택 정렬(오름차순으로 정렬)과 최대 선택 정렬(내림차순으로 정렬)이 있다.</p>
<p><strong>기본로직은 아래와 같다.</strong></p>
<ol>
<li>정렬되지 않은 인덱스의 맨 앞에서부터 이를 포함한 그 이후 배열의 값 중 가장 작은 값을 찾는다.</li>
<li>가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.</li>
<li>다음 인덱스에서 위의 과정을 반복한다.</li>
</ol>
<p>쉽게 설명하면 기준이 되는 수와 나머지 수를 비교해서 가장 작은 수를 앞으로 계속 보내는 정렬이다. 간단하지만 매우 비효율적이다.</p>
<p>최악의 경우, 최선의 경우, 평균적인 경우 모두 <code>시간 복잡도 : O(N^2)</code>을 갖는다.</p>
<p><strong>장점</strong></p>
<ul>
<li>데이터의 양이 적을 때 좋은 성능을 나타냄</li>
<li>적은 값을 선택하기 위해서는 비교는 여러번 수행되지만 교환횟수가 적다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>100개 이상의 자료에 대해서는 속도가 급격히 떨어져 적절히 사용되기 힘들다.</li>
</ul>
<h2 id="버블-정렬"># 버블 정렬</h2>
<ul>
<li>서로 인접한 두 원소를 검사하여 정렬하는 알고리즘을 갖는다.
<ul>
<li>인접한 2개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.</li>
</ul>
</li>
<li>선택 정렬과 기본 개념이 유사함.</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ol>
<li>버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를 … n-1번째 자료와 n번째 자료를 비교하여 교환하면서 자료를 정렬한다.</li>
<li>1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동한다.</li>
<li>이렇기 때문에 2회전에서는 맨 끝에 있는 자료가 정렬에서 제외되고, 2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다. 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.</li>
</ol>
<p>쉽게 설명하면 현재 원소와 다음 원소를 비교해서 큰 원소를 뒤로 보내는 정렬이다.</p>
<p>최악의 경우, 최선의 경우, 평균적인 경우 모두 <code>시간 복잡도 : O(N^2)</code>을 갖는다.<br>
이미 정렬된 데이터에 대해서 검사하는데는 O(N)으로 간단하게 할 수 있다.</p>
<p><strong>장점</strong></p>
<ul>
<li>구현이 쉽다.</li>
<li>이미 정렬된 데이터를 정렬할 때 가장 빠르다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>다른 정렬에 비해 정렬 속도가 느리다.</li>
<li>역순배열을 정렬할 때 가장 느리다.</li>
<li>정말 비효율적이라 거의 쓰이지 않는다.</li>
</ul>
<h2 id="삽입-정렬"># 삽입 정렬</h2>
<p>삽입 정렬의 기본 개념은 손안의 카드를 정렬하는 방법과 유사하다.</p>
<ul>
<li>새로운 카드를 기존의 정렬된 카드 사이에 올바른 자리를 찾아 삽입한다.</li>
<li>새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.</li>
<li>자료 배열의 모든 요소를 <strong>앞에서부터 차례대로 이미 정렬된 배열 부분과 비교</strong>하여 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘.</li>
<li>매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.</li>
</ul>
<p><strong>기본 로직은 아래와 같다.</strong></p>
<ul>
<li>오름차순을 기준으로 정렬한다.</li>
</ul>
<ol>
<li>기준이 되는 인덱스는 두 번째 자료부터 시작한다. 이 기준이 되는 인덱스를 <strong>Key</strong>라고 하겠다. Key가 들어갈 자리를 찾는게 핵심이다.</li>
<li>Key는 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료들을 뒤로 옮기고 지정한 자리에 Key 자료를 삽입하여 정렬한다.</li>
<li>즉, 두 번째 자료는 첫 번째 자료와 비교하고 세 번째 자료는 두 번째와 첫 번째 자료 …  이런 방식으로 비교해서 기준이 되는 자료가 들어갈 위치를 찾는다.</li>
<li>최종적으로 Key가 들어갈 위치를 찾았다면 자료들을 한칸씩 뒤로 이동시키고 그 자리에 삽입한다.</li>
</ol>
<p>쉽게 말하면 기준이 되는 인덱스의 앞쪽(왼쪽)을 검사하여 기준이 되는 인덱스가 들어갈 자리를 찾아서 삽입하는 정렬이다.</p>
<p>최악의 경우 : O(N^2) - 자료가 역순으로 정렬되어 있을 경우/작은 값이 뒤에 몰려있을 경우<br>
최선의 경우 : O(N) - 이동없이 1번의 비교만 이루어질 경우<br>
평균적인 경우 : O(N^2)</p>
<p><strong>장점</strong></p>
<ul>
<li>stable한 정렬 방법</li>
<li>적은 수를 정렬할 경우 알고리즘 자체가 간단해서 다른 복잡한 정렬 방법보다 유리할 수 있다.</li>
<li>대부분의 수가 이미 정렬되어 있는 경우에 매우 효율적이다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>비교적 많은 수들의 이동을 포함한다.</li>
<li>비교할 수가 많고 크기가 클 경우에 적합하지 않다.</li>
</ul>
<h2 id="결론">결론</h2>
<p>위에서 살펴본 정렬 알고리즘들은 비교적 구현이 간단하다. 그리고 이해하기도 어렵지 않다. 하지만 속도가 느리다는 단점이 존재한다. 다음에는 이보다 속도가 좋은 정렬 알고리즘을 살펴보도록 하겠다.</p>
<p><strong>stable과 unstable</strong></p>
<ul>
<li>stable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌지 않는 경우</li>
<li>unstable : 정렬할 때 같은 값을 가진 수들이 정렬 전과 정렬 후에 순서가 바뀌는 경우</li>
</ul>
<p>다음의 예를 한 번 생각해보자.<br>
ex) 5, 4, 8, 8, 5, 3, 1, 10, 6<br>
숫자가 있고 순서를 부여해보자.<br>
ex 5(1), 4(2), 8(3), 8(4), 5(5), 3(6), 1(7), 10(8), 6(9)</p>
<p>()안의 숫자는 해당 노드(수)가 들어온 순서를 뜻한다. 만약 정렬할 시에 key 값을 기준으로 정렬을 하되, 같은 key 값을 가진 노드는 들어온 순서에 따라 다시 정렬되어야 한다면 어떻게 할 것인가? 다음 결과와 같이 최종적으로 정렬된 정보가 바로 stable한 것이다. 정렬된 결과는 다음과 같다.</p>
<p>ex) 1(7), 3(6), 4(2), 5(1), 5(5), 6(9), 8(3), 8(4), 10(8)</p>
<ul>
<li><strong>선택 정렬</strong> : unstable</li>
</ul>
<p>ex) 5(1), 4(2), 5(3), 2(4), 3(5)<br>
위에서 5(1)과 2(4)를 교환한다.<br>
ex) 2(4), 4(2), 5(3), 5(1), 3(5)<br>
위의 결과가 나온다. 처음의 순서를 유지하지 않게 된다. 이러한 이유로 선택 정렬은 stable한 결과를 보장할 수 없기 때문에 <strong>unstable</strong>하다고 한다.</p>
<ul>
<li><strong>버블 정렬</strong> : stable</li>
<li><strong>삽입 정렬</strong> : stable</li>
</ul>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://dpdpwl.tistory.com/17" target="_blank" rel="noopener">[Algorithm]선택정렬 예제(selection sort)</a></li>
<li><a href="https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html" target="_blank" rel="noopener">정렬 기본</a></li>
<li><a href="http://blog.naver.com/zephyehu/150013176075" target="_blank" rel="noopener">stable과 unstable에 대하여</a></li>
<li><a href="https://marobiana.tistory.com/85" target="_blank" rel="noopener">[JAVA] Insertion Sort (삽입정렬)</a></li>
<li><a href="https://geekhub.tistory.com/62" target="_blank" rel="noopener">기술면접 list - 알고리즘</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/20/Algo-Select-Sort/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/03/02/2018-Review/"
                            aria-label=": [2018 회고]"
                        >
                            [2018 회고]
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-03-02T00:23:37+09:00">
	
		    Mar 02, 2019
    	
    </time>
    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>2019년이 되고 3달이나 지났다. 회고라는 걸 해본 적이 없지만 지인의 회고를 보고 영감을 받아서 작성하겠다고 마음을 먹었다. 2018년은 나에게 힘들고 아프면서 많은 걸 경험하게 해줬다.<br>
이 회고는 내가 2018년 동안 <strong>어떤 걸 했고, 어떤 걸 느꼈는지 내가 내린 선택과 결과</strong>를 잊지 않기 위해 작성할 예정이다.<br>
그리고 2019년에는 <strong>어떤 마음 가짐과 목표를 세우고 달려나갈지 생각</strong>하기 위함이다.</p>
<p><code>2019.03.05</code> 기준으로 다시 작성한다. 왜냐하면 캠프 끝난 기념으로 제주도 여행을 갔다 왔기 때문이다…ㅎㅎ 즐겁게 놀고 잘 쉬다가 왔으니 새로운 마음가짐으로 회고를 할 예정이다.</p>
<ul>
<li><a href="#%EB%AF%B8%EC%9C%A0%EB%B0%95%EC%8A%A4">미유박스</a></li>
<li><a href="#%EC%84%9C%EC%9A%B8%EC%8B%9C-%EA%B3%B5%EB%AA%A8%EC%A0%84">서울시 공모전</a></li>
<li><a href="#SK-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EA%B4%80%EA%B4%91-%EA%B3%B5%EB%AA%A8%EC%A0%84">SK 스마트 관광 공모전</a></li>
<li><a href="#%ED%9A%8C%EC%82%AC-%EC%83%9D%ED%99%9C">회사 생활</a></li>
<li><a href="#%EB%B6%80%EC%8A%A4%ED%8A%B8-%EC%BA%A0%ED%94%84">부스트 캠프</a></li>
</ul>
<h2 id="미유박스"># 미유박스</h2>
<p><a href="http://sopt.org/wp/" target="_blank" rel="noopener"><strong>SOPT</strong></a> 22기 앱잼을 했던 프로젝트 미유박스이다. 솝트 22기에 다시 안드로이드 파트원으로 지원하면서 세웠던 목표는 <strong>수상</strong>과 <strong>성장</strong> 두 가지로 요약할 수 있다. 왜냐하면 전기수에 <code>Lang</code>이라는 프로젝트에서 부족한 실력으로 인해서 결과물을 내지 못했던 경험이 있기 때문에 더 잘하고 싶다는 욕심이 생겼다.</p>
<p>미유박스는 사전 팀빌딩 없이 네트워킹을 통해 들어가게 되었다. 수상을 하고 싶다는 목표를 가지고 참여했지만, 안드로이드 개발자는 나를 포함해 2명 뿐이었다. 자신감이 하락하는 소리가 들린다. 그래도 포기는 너무 이른 생각이었다.</p>
<p>2주 동안 정말 치열하고 재미있게 프로젝트를 진행했다. 밤 새는 걸 못하던 나는 앱잼 기간동안 잠도 많이 줄여야 했고 합숙하는 동안은 거의 매일 같이 밤 새고 아침에 잠 들었다. 그래도 팀원들과 즐거운 분위기 속에서 개발을 했기 때문에 힘들다는 생각은 적게 할 수 있었다.</p>
<p>노력의 결과로 우리 팀은 <strong>대상</strong>이라는 명예를 얻을 수 있었다. 이 상은 나에게 있어서 의미가 컸다. 내가 노력한 결과로 상을 받은 경험을 처음이었기 때문이다. 좋은 분위기를 이끌어준 팀원들과 함께 노력한 결과가 수상으로 이어져서 기분이 정말 좋았다.</p>
<p>기능은 많지 않았지만 앱을 안정적으로 만들고 <strong>결제 기능</strong>을 테스트용으로 구현할 수 있어서 좋은 경험을 했다.</p>
<blockquote>
<p>이를 통해서 내가 느꼈던 점은 다음과 같다.</p>
</blockquote>
<ul>
<li>안드로이드 개발자로서 &quot;<strong>자신감</strong>&quot;을 얻을 수 있었고, 전보다 성장했음을 느낄 수 있었다.</li>
<li>안드로이드 개발에 대한 &quot;<strong>흥미</strong>&quot;를 일깨워 줄 수 있는 경험이 되었다.</li>
<li>미유박스는 앞으로의 내 행보에 발판을 마련해준 중요한 경험이 되었다. 앞으로도 미유박스 팀은 꾸준하게 오래 보는 사이가 되었으면 좋겠다. ^_^</li>
</ul>
<img src="/img/MeowBox.png" width="700" height="300">
<h2 id="서울시-공모전"># 서울시 공모전</h2>
<p>미유박스에서 같이 개발했던 형의 소개로 일정에 없던 공모전에 참여하게 되었다. 공모전을 준비해 본 경험이 없어서 하고 싶은 마음은 계속 있었다. 그러던 와중에 좋은 기회가 생겼다. 아는 형을 제외하고는 다 처음 보는 사이였다. 프로젝트의 기획 단계는 마무리가 되었고 디자인과 개발만 시작하면 되는 시점이었다.</p>
<p>그래서 뭔가 날로 먹는 느낌이 강해서 찜찜했지만 개발을 시작하면서 그 생각은 사라졌다. 너무 여유를 부렸던 탓인지 개발 속도는 진전이 없었다. 나는 공모전을 해보고 싶었고 상을 받고 싶은 욕심이 있었기 때문에 빨리 개발을 진행할 수 있도록 분위기를 유도했다. 그래도 어느정도 진전이 있었다.</p>
<p>같이 하기로 했던 한 분이 좋은 기회로 인턴에서 정직원으로 전환이 되었다고 했다. 그래서 그 분을 대체할 분을 데리고 오셨고 기분 좋게 개발을 하는가 싶었다. <strong>인생은 고난의 연속이라고 했던 누군가의 말이 생각났다.</strong> 대타로 들어오신 분이 사정이 있어서 빠지게 되었다. 그래서 기능 한개가 비어버리게 되었고, 이 부분까지 내가 맡아서 개발을 진행했다.</p>
<p>덕분에 <code>내가 처음에 맡았던 기능 + 대타 분이 떠나서 구현해야 하는 기능</code>을 신경 써야 했다. 또 하필, 이 기간은 내가 3~4달 동안 <strong>위워크</strong>에 있는 회사에서 잠깐 일했던 기간이기도 했다.(이 얘기는 밑에서 등장한다.) 그래서 회사에 갔다가 퇴근하고 공모전을 하면서 하루에 4~5시간 밖에 못 잤던 걸로 기억한다.</p>
<p>너무 힘들었지만 공모전을 한다고 결정한 나에게 포기하는 모습을 보여주고 싶지 않았다. 그래서 시간을 할애해서 정말 열심히 했다. 내가 선택한 일에 대해서 후회하고 싶지 않았던 마음과 공모전을 하고 싶었던 나의 버킷 리스트를 잘 실천하고 싶은 두 개의 마음이 나를 열심히 하게 한 원동력이 된 것 같다.</p>
<p>좋은 결과를 얻지는 못했지만, 재미있는 사람들과 공모전을 하면서 즐거웠다. 짧고 치열한 기간에 개발을 하자고 팀원들한테 얘기하면서 쪼았지만 잘 따라서 마무리를 해준 것을 고맙게 생각하고 있다.</p>
<blockquote>
<p>서울시 공모전을 하면서 느낀 점</p>
</blockquote>
<ul>
<li>내가 내린 결정에 대해서 후회하지 않고, 책임감을 가지고 일을 진행해야 한다는 걸 배웠다.</li>
<li>개발적인 부분을 다른 사람한테 설명하기 위해서는 내가 많은 지식을 알고 있어야 한다는 걸 알았다.</li>
<li>Git을 조금 더 능숙하게 다룰 줄 알았다면 더 편하게 협업을 하지 않았을까를 깨닫게 되었다.</li>
</ul>
<h2 id="kb-app-challenge"># KB App Challenge</h2>
<p>아마 지금 와서 2018년도에 했던 일들을 다시 하라고 한다면 나는 못할 것 같다. 내가 활동하던 SOPT에서 주최한 <strong>KB App Challenge</strong>였다. KB의 클라우드 관련 신기술인 <a href="https://www.clayon.io/" target="_blank" rel="noopener"><strong>클래용</strong></a>을 활용하여 유스 고객을 타겟으로 하여 금융 관련 지식들을 라이브 방송을 통해 알려주고 포인트를 쌓을 수 있는 애플리케이션의 프로토 타입을 개발했다.</p>
<p>프로젝트 기간이 <strong>2주</strong>였기 때문에 기획을 빨리 픽스하고 개발에 도입했다. 안드로이드 개발은 80% 정도 혼자 진행했다. 회사를 다니면서 퇴근하면 바로 종각역 근처에 위치한 <strong>패스트 파이브</strong>로 향했다. 2주 동안 짧고 치열하게 프로젝트를 완성시키고 최종 발표를 했다.</p>
<p>최종 발표는 KB 본사 건물에서 진행했고, KB 회장님을 비롯하여 임직원분들이 오셔서 우리가 진행한 프로젝트를 보고 평가해주셨다. 훌륭한 팀원들 덕분에 2등을 할 수 있었다. 아마도 <strong>최우수상</strong>이었던 걸로 기억한다. <code>100만원</code> 상금을 받고 5명이서 20만원씩 나눴다. 뜻깊은 경험도 하고 평생 만날 기회가 없을 KB 회장님도 직접 뵙고 사진도 찍고 상금까지 얻을 수 시간이었다.</p>
<blockquote>
<p>KB 프로젝트를 하며 느낀 점</p>
</blockquote>
<ul>
<li>앱 개발자로서 UI를 더 생각해보고 신경쓸 수 있었다. 그래서 UI를 만들 때 전보다 개선된 걸 느낄 수 있었다.</li>
<li>기존에 사용했던 기술이 아닌 색다른 기술을 사용해 볼 수 있어서 좋았다. 결국은 <strong>Youtube Player API</strong>를 사용했지만, 영상 재생을 구현하는 방법에 대해서 고민해 볼 수 있는 좋은 시간이었다.</li>
</ul>
<img src="/img/kb_app_challenge.png" width="700" height="300">
<center>[ KB App Challenge 사진 ]</center>
<p>나는 눈에 띄는 파란색 니트를 입고 가운데서 사진을 찍었다. 재밌었다. :)</p>
<h2 id="sk-스마트-관광-공모전"># SK 스마트 관광 공모전</h2>
<p>공모전을 하고 싶었던 나의 소망이 좀 이상했다. 한 번에 3개씩 하겠다는게 아니었는데 어쩌다 보니 1개는 먼저 진행했고 2개가 기간이 겹치는 문제가 발생했다. ㅠ_ㅠ 앞의 KB가 끝나자마자 바로 <code>SK 스마트 관광 공모전</code>을 시작했다.</p>
<p><strong>미유박스</strong>(자주 등장한다.ㅎㅎ)를 함께 진행했던 팀원들과 다른 사람 몇명을 추가해서 공모전을 진행했다. 팀원이 14명이었다. 지금 생각해도 너무 많았던 것 같다. 그래서 우리 팀의 목표는 무조건 1등이었다. 왜냐하면 1등은 상금이 <code>1천만원</code>이었기 때문이다. 14명이서 나누면 약 70만원 가량의 상금을 얻을 수 있었다. 생각만 해도 행복하다.ㅎ0ㅎ</p>
<p>앞에서 진행했던 KB 프로젝트와 회사 생활로 인해서 <a href="https://github.com/WooVictory/DMZing-Andorid" target="_blank" rel="noopener"><strong>DMZing</strong></a>(우리 프로젝트 애플리케이션 이름이다.)의 초기 기획 단계에 많이 참여하지 못한 점이 아쉽고 미안하다. 아무튼 나는 마감 기간이 2주 정도 남았을 때 개발에 들어갔다. 안드로이드 개발을 할 때 운이 없는 건지 팀 프로젝트를 할 때 계속 두 명이서 진행했다. 힘들었다. . . ㅠㅠ</p>
<p>2주 동안 치열하게 잠을 줄여가면서 개발에 몰두했고 마무리를 잘해서 <code>Google Play Store</code>에도 올리는 경험을 했다. 이번 프로젝트에서 내가 하고 싶었던 건 <strong>중복을 없애고 재사용</strong>을 하는 것과 <strong>효율적으로 코드를 작성</strong>해보는 것이었다. 하지만, 기간이 짧기도 했고 시간이 많지 않아서 2개의 목표는 달성하지 못했다.</p>
<p>운이 좋게도 본선에 진출해서 최종 발표를 할 수 있는 기회를 얻었다. 기획과 디자인을 담당했던 친구들이 가서 발표를 하고 마무리를 잘 해줬다. 그리고 12월 00일에 최종 결과 발표가 있었다. 우리는 시간이 되는 사람들끼리 모여서 최종 결과를 받기 위해서 종각 근처의 <strong>콘랩</strong>으로 향했다. 대상을 받을거라고 김칫국을 마시던 우리는 <strong>장려상</strong>을 받고 아쉬워 했다. 그래도 함께 열심히 노력한 과정을 알기 때문에 빨리 잊어버렸다.</p>
<p><code>100만원</code>이라는 상금을 받고 14명이 나눠 가졌다. 대략 7만원 정도씩 가질 수 있었다. 나는 받았던 상금을 모으고 일했던 돈을 보태서 <strong>아이폰XS</strong>로 핸드폰을 바꿨다. 좋은 기회가 있어서 생각보다 저렴하게 구매했고 지금 만족하면서 잘 쓰고 있다. <a href="https://goodgid.github.io/" target="_blank" rel="noopener"><strong>갓기용</strong></a>님에게 항상 감사하고 있다.ㅎㅎ</p>
<blockquote>
<p>SK 스마트 관광 프로젝트를 하면서 느낀점</p>
</blockquote>
<ul>
<li>바쁘게 사는 건 좋지만 너무 빡빡한 일정은 좋지 않다는 것을 느꼈다. 여유가 없었기 때문에 회고를 할 수 있는 시간이 없었다. 그리고 <strong>KB 프로젝트</strong>와 <strong>SK 관광 프로젝트</strong>가 겹쳤기 때문에 한 가지에 집중하기 힘들어서 능률이 떨어지는 느낌을 받았다.</li>
<li>여유를 어느 정도 가지고 프로젝트나 일을 할 때는 한가지에 집중하는게 중요하다는 걸 깨달았다.</li>
<li>Store에 실제로 올리면서 <strong>개인 정보 취급 방침</strong>이 필요하다는 걸 알게 되었고, APK 파일을 추출하는 법에 대해서도 알 수 있었다. 개발자로서 꼭 필요한 경험을 할 수 있었다.</li>
</ul>
<h2 id="회사-생활"># 회사 생활</h2>
<p>4학년 1학기를 깔끔하게 마무리하고 2학기는 6학점만 남겨놓았다. 그래서 OCU라는 인터넷 강의를 2개 잡고 2학기에는 학교를 다니지 않았다. 이 기간 동안 무엇을 할까 고민을 많이 했다. 취업 준비를 해야 하는 시기가 맞지만, 나는 아직 취업 준비를 하고 싶지 않았다. 휴식을 취하고 싶었고, 돈을 벌고 싶은 마음이 있었다. 그래서 알바를 할까 생각을 했지만, 시간 낭비를 하지 않고 관련된 업무를 하면서 돈을 벌 수 있는 기회를 찾았다.</p>
<p>그러던 와중에 아는 지인이 다니는 회사를 추천받았다. 간단하게 말해서 인공지능에게 필요한 학습 데이터를 가공하는 업무였다. 타이틀은 거창하고 인턴이었지만 나는 단순 업무를 하는 아르바이트라고 생각했다. 9월에 입사를 했고 회사를 다니는 동안 시간을 틈틈히 쪼개서 위에서 언급했던 <strong>KB 프로젝트</strong>와 <strong>SK 스마트 관광 프로젝트</strong> 2개를 진행했다.</p>
<p>계약 기간이 12월 30일까지였기 때문에 나는 12월 30일에 퇴사를 했다. 3개월에서 4개월 정도의 짧은 기간이었지만 좋은 사람들을 만나고 회사를 다니면서 혼자 시간을 쪼개서 여러 가지를 할 수 있었다. 그리고 돈도 벌 수 있었다. 회사를 다니면서 많은 업무를 하지는 않았다. 처음부터 단순 업무라고 들었기 때문이다.</p>
<p>시간을 낭비했다고 생각하기도 하지만 내가 선택한 결정에 대해서 후회는 없다. 돈을 벌 수 있었고 더 바쁘게 생활하기도 했어서 오히려 나한테 자극을 줄 수 있는 시간이었다. 퇴사를 하면서 다음 회사는 &quot;<strong>내가 진짜 원하는 업무를 할 수 있는 회사에 들어가자</strong>&quot;라는 목표를 세웠다.</p>
<blockquote>
<p>회사를 다니면서 내가 느낀 점</p>
</blockquote>
<ul>
<li>첫 번째는 스타트업이라도 너무 작은 스타트업보다는 어느 정도 규모가 있는 스타트업이 좋을 것 같다는 점을 느꼈다. 규모가 너무 작으면 체계도 잘 잡혀있지 않은 것 같다.</li>
<li>두 번째는 식비나 교통비를 지원해주는 회사가 좋은 회사라는 것이다. 월급을 받지만 식비와 교통비로 지출이 생기기 때문에 돈 모으기가 힘들었다. 마지막에는 도시락을 싸서 다녔지만 아무래도 <code>식비+교통비</code>를 지원해준다면 꿈의 회사가 아닐까하는 생각이 들었다.</li>
<li>마지막으로 내가 진짜 원하는 업무를 하는 회사에 들어가서 재미있게 개발을 하자는 마음을 가지게 되었다.</li>
</ul>
<h2 id="부스트-캠프-후기-in-2019"># 부스트 캠프 후기 in 2019</h2>
<p>2018년은 프로젝트를 연달아서 쉬는 기간 없이 3개를 진행했다. <strong>발전이 없고</strong> 프로젝트만 계속 한 느낌?!을 받았다. 회고를 작성하지도 않았고 리뷰를 하지도 않았다. 심지어 프로젝트에 대한 정리도 하지 않았다. 아마 그래서 발전이 없었고 계속 같은 자리에 머물러 있는 것 같다는 느낌을 받았다. 이 상태로 있다가는 <strong>성장하는 개발자</strong>가 되지 못할 것 같았다.</p>
<p>그래서 나는 지금보다 한 단계 성장하고 다른 경험을 해보고 싶어서 <strong>부스트 캠프</strong>에 지원하게 되었다. 부스트 캠프는 네이버 계열사 중 하나인 <a href="https://connect.or.kr/" target="_blank" rel="noopener"><strong>커넥트 재단</strong></a>에서 진행하는 캠프이다. 내가 부스트 캠프에 지원하게 된 이유는 다음과 같은 것들을 얻고 싶어서다.</p>
<ol>
<li>현업에서 일하는 튜터님의 멘토링을 받고 좋은 조언들을 얻을 수 있다는 점</li>
<li>코드 리뷰를 통해서 코딩할 때 안좋은 습관을 없애고 실력을 쌓을 수 있다는 점</li>
<li>같은 분야를 공부하는 다른 개발자들을 만나보고 싶다는 점</li>
<li>자극을 받고 싶다는 점</li>
</ol>
<p>위의 4가지 이유로 인해서 부스트 캠프에 지원하게 되었다. 나는 지원서를 제출하고 1차 합격 메일을 받았다. 다음 절차는 <code>온라인 테스트</code>였다. 주말에 진행되었으며 안드로이드 관련 문제와 간단한 알고리즘 문제가 나왔다. 공부했던 부분에서 문제가 나와서 수월하게 풀 수 있었으며 알고리즘도 다행히 내가 풀 수 있는 수준이라고 생각을 해서 테스트를 잘 마무리 할 수 있었다.</p>
<p>테스트를 보고 나서 합격 여부를 모른채로 일단 면접 준비를 했다. 취업한 선배들의 말을 들어보니 합격 통지를 받고 면접까지의 기간이 길지 않아서 바로 준비하는게 좋다고 했다. 그래서 나는 테스트를 보고 다음날부터 면접에 대한 준비를 했다. <strong>온라인 테스트</strong>를 합격하고 면접 날짜가 나왔다. 사전에 면접 준비를 어느 정도 했기 때문에 떨리지 않았지만, 어떤 질문이 들어올지 예측할 수 없었다. 일단은 온라인 테스트 문제와 지원서를 기반으로 준비했다.</p>
<p>같이 지원하고 면접까지 붙은 학교 선배 및 후배와 함께 면접 준비를 했다. 혼자 준비한 것보다 확실히 도움이 많이 되었다. <strong>모의 면접</strong>을 통해서 긴장감을 풀 수 있었고 말할 때 태도나 말투를 고칠 수 있었다. 또한, 예상치 못한 질문을 듣고 부족한 부분을 더 공부할 수 있었다. 준비한 결과 부스트 캠프에 <code>최종 합격</code>을 할 수 있었다.</p>
<p>캠프를 하면서 내가 지원할 때 <strong>부스트 캠프</strong>를 통해서 얻고 싶었던 것들을 하나씩 얻고 배울 수 있었다.<br>
일단, 첫번째로 현업에서 일하시는 튜터님의 멘토링을 받을 수 있었다. 우리는 초반에 프로젝트 아키텍처 설계를 <strong>MVP</strong> 패턴으로 잡았다. 그리고 Model, View, Presenter의 의존성을 분리해서 개발을 시작했다. 그리고 튜터링을 받았는데 설계부터 잘못되었다는 평가를 받았다. 기존에는 뷰를 먼저 그리고 필요한 데이터를 그 때 그 때 작성했다. 이렇게 하면 변경 사항이 자주 발생하고 수정할 때도 굉장히 귀찮은 작업을 거치게 된다.</p>
<ol>
<li>튜터링을 받은 내용은 <code>요구사항 명세서</code>를 만들고 먼저 화면에 그릴 데이터를 고려하고 설계하는 것이다. 로직을 하나도 신경쓰지 않고 사용자게에 보여질 화면에 필요한 데이터를 설계한다.</li>
<li>MVP 패턴을 사용하므로 비즈니스 로직을 처리할 Repository 인터페이스를 설계한다.</li>
<li>2번에서 생성한 Repository 인터페이스를 구현한다.</li>
<li>Presenter 구현 및 View 인터페이스 설계</li>
<li>View 인터페이스 구현</li>
</ol>
<p>위와 같은 순서로 작업을 진행하는 것이 좋다는 피드백을 받았다. 기존에 개발해왔던 것과는 반대의 <strong>프로세스</strong>였다. Data를 먼저 고려하고 최종적으로 View는 가장 마지막에 구현하는 것이었다. 처음에는 이 프로세스가 적응이 되지 않고 왜 이렇게 하는지 이해가 잘 가지 않았다. 하지만, 계속 하다보니 적응이 되었고 <strong>요구사항 명세서</strong>를 잘 작성해 놓으니 추후에 유지보수나 수정할 때 손이 많이 가지 않았다. 덕분에 능률이 조금 더 오를 수 있었다.</p>
<p>또한, 관심사의 분리(SOC)를 하는데에도 도움이 많이 되었다. MVP 패턴을 사용하다보니 Model, View, Presenter 각각이 하는 역할이 명확해서 분리하는 것이 필요했다. 말은 쉽지만 실제로 개발을 하다보니 서로 의존성이 생기는 문제가 발생했다. 이 문제는 위의 <strong>요구사항 명세서</strong> 작성을 통해서 역할을 명확하게 분리할 수 있었고 의존성을 낮출 수 있게 되었다.</p>
<p>두번째는 <strong>코드리뷰</strong>였다. 지금까지 살면서 남의 코드를 봐온 적은 있지만 코드 리뷰를 해본 적이 없었고, 내 코드를 누군가가 리뷰해 준 적도 없었다. 내 첫 코드 리뷰는 엉망이라고 할 수 있다. 접근제어자는 막 갖다 붙였고, 전역 변수, 지역 변수도 구분할 줄 몰랐다. 그래서 조언을 받고 반성을 하면서 코드를 짤 때 <strong>생각을 많이 하고</strong> 짜는 습관을 가지게 되었다. 내가 짠 코드에 대해서 왜 이렇게 짰는지 생각해 볼 수 있는 습관을 가지게 된 것이 좋았다.</p>
<p>세번째는 같은 분야의 다른 개발자들을 만날 수 있었다는 점이다. 물론 <strong>SOPT</strong>를 통해서 많이 만났지만, 새로운 사람들을 만난다는 건 좋은 경험이었다. 처음 보는 사람들과 팀을 이루었다. 처음에는 굉장히 어색했지만, 시간이 지나면서 친해졌고 일상 이야기 뿐 아니라 개발적인 부분도 함께 공유하고 이야기 할 수 있어서 좋았다. 캠프에도 적응할 수 있어서 긴장이 많이 풀렸다. 또한, 내가 모르는 부분들도 많이 알게 되었고 전보다 시야가 넓어졌다.</p>
<p>마지막으로 다른 사람들을 통해서 많은 <strong>자극</strong>을 받을 수 있었다. 아마도 SOPT에서만 계속 있었다면 발전이 없고 그 자리에 머물러 있었을 것이라고 생각한다. 부스트 캠프에는 전국에서 안드로이드 개발에 관심이 있는 사람들이 모인 자리인 만큼 잘하는 사람들이 굉장히 많았다. 그 속에서 나는 남과 비교하면서 내 자신을 깎아내리기도 했었다. 하지만 시간이 조금 지나면서 <strong>부정적인 생각</strong>을 없애버렸고 <strong>그 사람들로부터 자극</strong>을 받기 시작했다. 이 자극은 나한테 큰 도움이 됐다. 앞으로 어떤 걸 공부해야 할지 방향을 잡을 수 있었고, 내게 부족한 점들을 확인할 수 있는 시간이었다.</p>
<p><code>부스트 캠프</code>를 하면서 좋았던 점은 좋은 팀원들, 튜터님과 함께 프로젝트를 진행하고 잘 마무리할 수 있었던 점이다. 한달이라는 기간 동안 싸우지 않고 프로젝트 동안 의견 충돌도 많지 않았다. 또한, 좋은 튜터님들을 알아 갈 수 있었던 것도 굉장히 좋았다. 안드로이드 개발자라면 모를 수 없는 <a href="https://gun0912.tistory.com/" target="_blank" rel="noopener"><strong>박상권</strong></a>을 실제로 보고 좋은 이야기도 많이 들으면서 값진 경험을 할 수 있었다. 그리고 조금 아쉬운 점은 캠프 동안 매일 기록하지 못했다는 것이다. 초반에는 기록할 시간이 있었지만 개발을 시작하고 나서는 시간적인 여유가 부족해서 기록을 하지 못했다.</p>
<p>그래도 <strong>부스트 캠프</strong>는 나에게 있어서 한 단계 성장할 수 있게 만들어준 발판이었다. 2019년의 시작은 힘들었지만, 추진력을 주었기에 감사한 마음이다.</p>
<ul>
<li>2019년도에는 <strong>끝까지 포기하지 않고 최선을 다하는</strong> 마음가짐을 가지고 꼭 취업을 하는게 목표다.</li>
<li>그리고 체력 관리도 필수적인 것 같다. 꾸준한 운동도 꼭 할 계획이다.</li>
</ul>
<img src="/img/boostcamp_android.png" width="700" height="300">
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://www.emoneynews.co.kr/news/articleView.html?idxno=68681" target="_blank" rel="noopener">KB금융, 대학생과 함께하는 ‘KB App Challenge’ 개최</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/03/02/2018-Review/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/10/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/12/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 11 of 26</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
