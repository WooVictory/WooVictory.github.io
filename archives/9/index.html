
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="VictoryWoo">
    <title>VictoryWoo</title>
    <meta name="author" content="VictoryWoo">
    
    
        <link rel="icon" href="https://woovictory.github.io/assets/images/develop.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://woovictory.github.io","author":{"@type":"Person","name":"VictoryWoo","sameAs":["https://github.com/WooVictory","https://www.facebook.com/WooVictory","https://www.linkedin.com/profile/","jhsw0375@gmail.com"],"image":"Victory.jpeg"},"name":"VictoryWoo","description":"","url":"https://woovictory.github.io"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="VictoryWoo">
<meta property="og:url" content="https://woovictory.github.io/archives/9/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="VictoryWoo">
    
    
        
    
    
        <meta property="og:image" content="https://woovictory.github.io/assets/images/Victory.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-125410253-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-125410253-1');
    </script>


    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/ "
            aria-label=""
        >
            VictoryWoo
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">VictoryWoo</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="Search"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.facebook.com/WooVictory"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/jhsw0375@gmail.com"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/09/What-is-MVVM/"
                            aria-label=": [Android] MVVM Part.1"
                        >
                            [Android] MVVM Part.1
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-09T22:37:20+09:00">
	
		    Jun 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <ol>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.1</a></li>
<li><a href="https://woovictory.github.io/2019/04/21/What-is-MVVM/">[Android] MVVM Part.2</a></li>
</ol>
<ul>
<li>LiveData</li>
<li>ViewModel</li>
<li>Databinding<br>
선수 지식 필요.</li>
</ul>
<p>Architecture 패턴에는 일반적으로 사용하는 MVC, MVP, MVVM이 있다. 이러한 Architecture 적용으로 얻는 이점은 안정적인 서비스 개발을 할 수 있으며 유지 보수를 빠르게 할 수 있다는 것이다.</p>
<p>먼저, MVP Architecture부터 살펴보자.</p>
<h2 id="1-mvp">1. MVP</h2>
<img src="/img/mvp_android.png" width="600" height="200">
<ul>
<li>Presenter : View에서 요청한 정보를 Model로부터 가공해서 View로 전달하는 부분</li>
</ul>
<p>Model과 View는 MVC와 동일하지만 사용자 입력을 View에서 받는다. 그리고 Model과 View는 각각 Presenter와 상호 작용을 하게 된다. 항상 Presenter를 거쳐 동작하는 셈이다.</p>
<p>그러므로 View와 Model은 서로를 알 필요가 전혀 없다. Presenter만 알면 된다. 그래서 MVC의 단점인 View와 Model의 의존성이 없어지게 된다.</p>
<p><code>정리하자면</code></p>
<ol>
<li>View로 사용자의 입력이 들어온다.</li>
<li>View는 Presenter에 작업 요청을 한다.</li>
<li>Presenter에서 필요한 데이터를 Model에 요청한다.</li>
<li>Model은 Presenter에 필요한 데이터를 응답한다.</li>
<li>Presenter는 View에 데이터를 응답한다.</li>
<li>View는 Presenter로부터 받은 데이터로 화면에 보여주게 된다.</li>
</ol>
<p>View에서 비즈니스 로직을 분리하는 부분은 성공적이다. Model 역시 분할되어 있어서 적용하기 쉽다. 하지만, View와 Presenter의 1:1 관계를 유지하는 덕분에 몇 가지 단점이 생긴다.</p>
<ul>
<li>중복 코드 발생한다.</li>
<li>View에 대한 의존성이 강해진다.</li>
</ul>
<p><strong>중복 코드?</strong></p>
<p>간단한 예를 들어보겠다.<br>
로그인과 로그아웃은 어떠한 화면에서도 호출될 수 있다. 기획상으로 가능하다면 말이다.<br>
A/B/C/D 4개의 화면이 있고, 언제든 로그인만 호출할 수 있다. 대부분은 로그인 Acitivity로 이동시키고 이를 구현하면 된다.</p>
<p>반대로 로그아웃이다. 단순하게 로그아웃한다고 생각해보자. 로그아웃 역시 A/B/C/D 화면에서 언제든 접근할 수 있다.</p>
<p><strong>MVP에서는?</strong></p>
<p>로그인, 로그아웃을 처리하는 비즈니스 로직은 A/B/C/D 화면에 종속적인 Presenter 4개에서 모두 호출하게 된다. 모델에서 실제 로그인, 로그아웃 처리 로직이 있는 부분은 가져다가 사용하는 것이다.</p>
<p>여기서 <strong>공통 코드</strong>가 발생하게 된다.</p>
<p><strong>공통 코드?</strong></p>
<p>MVP에서 발생하는 공통 코드를 어떻게 해결할 수 있을까?</p>
<ul>
<li>Presenter도 상속을 받아서 공통 코드를 해결</li>
<li>별도의 공통 로직을 가지는 새로운 클래스를 생성</li>
<li>Presenter 분리?</li>
</ul>
<p>위와 같은 공통 코드를 관리할 수는 있다.</p>
<p><strong>MVVM은 View Model 분리의 시작</strong></p>
<p>위에서 적은 Presenter를 분리하면 MVVM이 된다. <strong>View에 대한 모델을 분리하였기 때문에 ViewModel이다.</strong></p>
<p>즉,ViewModel은 View에 대한 모델 분리가 있어야 한다. View에서 사용하는 중복적인 Presenter의 코드가 발생하면 이를 ViewModel 하나로 분리해주는게 가장 이상적이다.</p>
<p>MVP의 기본 개념인 View와 Presenter의 1:1 관계 유지에서 벗어나기 위해서는 MVVM이 가장 좋은 해결책으로 보인다. 조금 더 이쁜 코드를 만들기 위해서는 최소한 View에 대한 Model은 정의해주어야 한다. 그렇게 해야 아래와 같은 처리가 가능해진다.</p>
<ul>
<li>View에 대한 종속성을 줄인다.
<ul>
<li>종속성을 줄이기 위해 ReactiveX, Databinding 등을 이용할 수 있다.</li>
</ul>
</li>
<li>View에 대한 Model 정의가 명확해야 한다.
<ul>
<li>이 ViewModel은 언제든 View에서 가져다 쓰기만 하면 되고, 불필요한 경우 해당 ViewModel만 버릴 수 있어야 한다.</li>
</ul>
</li>
<li>ViewModel에 대한 테스트가 가능해진다.
<ul>
<li>View에 대한 테스트와 완전하게 분리 가능하여 비즈니스 로직이 아닌 각각의 ViewModel 테스트가 가능해진다.</li>
</ul>
</li>
</ul>
<p><strong>MVVM의 ViewModel이란?</strong></p>
<p>MVVM은 고민을 많이 해야 하는 구조이다.</p>
<ul>
<li>ViewModel 분리가 필요할까?</li>
<li>분리했을 때 얻는 이점은?</li>
<li>종속성은?
<ul>
<li>ReactiveX, DataBinding 등을 이용해 해결할 수 있다.</li>
</ul>
</li>
<li>테스트 코드는?
<ul>
<li>테스트 코드는 유용해야 한다.</li>
</ul>
</li>
</ul>
<p>View에 대한 모델을 모두 분리한다면? 다음과 같이 구성할 수 있을 것이다.</p>
<ul>
<li>LoginViewModel : 로그인만 하는 모델</li>
<li>LogoutViewModel : 로그아웃만 하는 모델</li>
<li>UserInfoViewModel : 사용자 정보만을 가져와 가공한다.</li>
</ul>
<p>여기까지 MVP와 MVVM에 대해 차이점과 ViewModel에 대해 조금 알아봤다. 이제는 MVVM을 알아보도록 하자.</p>
<h2 id="2-mvvm">2. MVVM</h2>
<img src="/img/mvvm_android.png" width="600" height="200">
<p>Presenter 대신에 ViewModel이 존재한다.</p>
<ul>
<li>ViewModel : View를 표현하기 위해 만들어진 View를 위한 Model</li>
</ul>
<p>MVVM에서는 두 가지 디자인 패턴을 사용한다. <strong>Command 패턴</strong>과 <strong>Data binding</strong>이다. 이 두 가지 디자인 패턴을 사용함으로써 View와 ViewModel은 의존성이 완전히 사라지게 된다.</p>
<p>View에서 입력이 들어오고 Command 패턴을 통해서 ViewModel에 명령을 내리게 되고 Data binding으로 인해 ViewModel의 값이 변화하면 바로 View의 정보가 바뀌게 된다.</p>
<p><code>정리하자면</code></p>
<ol>
<li>View에 입력이 들어오면 Command 패턴으로 ViewModel에 명령을 한다.</li>
<li>ViewModel은 필요한 데이터를 Model에 요청한다.</li>
<li>Model은 ViewModel에 필요한 데이터를 응답한다.</li>
<li>ViewModel은 응답 받은 데이터를 가공해서 저장한다.</li>
<li>View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신된다.</li>
</ol>
<p><strong>왜 MVVM을 사용할까?</strong></p>
<p>전통적인 UI 개발에서 개발자는 윈도우, 사용자 컨트롤, 페이지를 사용해서 View를 만들곤 했다. 그리고 모든 논리 로직이 들어간 코드(핸들링, 초기화 그리고 데이터 모델 등)를 뷰 클래스에 정의한다. 이러한 방법은 뷰 클래스의 크기를 늘리고 UI와 데이터 그리고 비즈니스 사이의 <code>매우 강한 의존성</code>을 형성한다.</p>
<p>이와 같은 상황에서 여러 개발자들은 동시에 같은 뷰에서 작업하기 힘들어 질 것이다. 즉, 협업하는 상황에서 같은 화면을 함께 개발하지 못하고 서로 다른 화면을 개발해야 하는 비효율적인 상황이 발생할 것이다. 또한, 다른 개발자가 코드를 바꾸면 다른 부분을 망가뜨릴 위험도 존재한다.</p>
<p><strong>이처럼 모든 코드들이 한 클래스에 있는 것은 유지보수 그리고 테스트를 하는데 있어서 좋지 않다.</strong></p>
<ol>
<li>뷰(UI)</li>
<li>모델(UI 상에 보여지고 있는 데이터)</li>
<li>글루 코드(핸들링과 바인딩 그리고 비즈니스 로직)</li>
</ol>
<ul>
<li>글루 코드 : 서로 다른 코드를 접착시키는 코드</li>
<li>비즈니스 로직 : 데이터의 처리가 이루어지는 부분</li>
</ul>
<p>MVVM에서 글루 코드는 뷰 모델이다. 그래서 애플리케이션의 구조를 더욱 간단하고 유지가능할 수 있게 만들기 위해서는 <strong>관심사의 분리</strong>에 집중해야 한다.</p>
<p>만약, 뷰 모델에서의 프로퍼티 값이 변하게 되면 데이터 바인딩과 노티피케이션을 통해 자동으로 새로운 값을 알려준다. 만약 사용자가 저장하기 버튼을 클릭하는 액션을 뷰에서 취했을 때, 뷰모델은 요청된 명령을 실행한다. 이 과정에서 뷰모델은 모델의 데이터를 수정하고 뷰는 데이터를 수정하지 않는다. 뷰는 모델의 존재를 모른다. 반면 뷰 모델과 모델은 뷰를 인식하지 않는다. 모델은 뷰와 뷰 모델의 존재를 모른다.</p>
<p><strong>MVVM에 대해</strong></p>
<p>MVVM 패턴을 지켜 개발된 앱은 아래의 특징을 갖는다.</p>
<ol>
<li>관심사의 분리 - 하나의 소프트웨어를 최대한 기능적으로 작은 단위로 나눈다</li>
<li>테스트가 쉬워지고 큰 프로젝트도 상대적으로 관리하기 좋다.</li>
<li>SOLID 원칙을 지향한다.</li>
<li>앱이 구조적으로 약한 결합의 컴포넌트로 나눠진다.</li>
</ol>
<p>대체적으로 위와 같은 장점에 대해서 이야기를 하지만 결국 가장 큰 목적은 <strong>유지보수가 쉽고 테스트가 용이한 코드를 만드는 것이다.</strong></p>
<img src="/img/mvvm.png" width="600" height="200">
<p>View는 ViewModel에게 클릭 이벤트, 필요한 데이터 요청 등을 명시적으로 하고 ViewModel이 notify할 때까지 기다리게 된다.</p>
<p>동일하게 ViewModel은 Model을 통해 데이터를 요청하고 기다리게 된다. 각각의 컴포넌트간 참조를 갖지 않고 <strong>단방향(View -&gt; ViewModel -&gt; Model)의 의존성만을 갖게 된다.</strong></p>
<p><strong>정리</strong></p>
<ol>
<li>뷰, 뷰모델, 모델 이 셋은 서로의 존재를 몰라야 한다.<br>
-&gt; 서로 간의 의존성을 최대한 제거함으로써 유지보수가 쉽고 테스트 가능한 코드가 된다.</li>
<li>뷰에서 액션을 받으면 뷰모델에서 비즈니스 로직을 실행한다.</li>
<li>뷰 모델은 모델의 데이터를 수정한다.</li>
<li>뷰 모델은 데이터 바인딩과 노티피케이션을 통해 뷰를 수정한다.</li>
<li>뷰와 뷰 모델은 n:m의 관계이다.</li>
<li>오직 뷰모델만이 모델에 접근할 수 있고 뷰는 모델에 접근하지 못한다.</li>
</ol>
<h2 id="참고"># 참고</h2>
<ul>
<li><a href="https://black-jin0427.tistory.com/133" target="_blank" rel="noopener">[번역] MVVM 디자인 패턴의 기본 이해</a></li>
<li><a href="https://magi82.github.io/android-mvc-mvp-mvvm/" target="_blank" rel="noopener">MVC, MVP, MVVM 비교</a></li>
<li><a href="https://thdev.tech/androiddev/2017/03/12/Android-MVVM-Architecture-intro/" target="_blank" rel="noopener">Android MVVM 어떻게 구현하는게 좋을까?</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/09/What-is-MVVM/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/09/RxJava-Chap04-Combination/"
                            aria-label=": [RxJava] Chap04. 결합연산자"
                        >
                            [RxJava] Chap04. 결합연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-09T20:47:22+09:00">
	
		    Jun 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="결합-연산자">결합 연산자</h2>
<p>생성 연산자와 변환 연산자는 1개의 데이터 흐름(Observable)을 다뤘다. <strong>결합 연산자는 다수의 Observable을 하나로 합하는 방법을 제공한다.</strong> flatMap(), groupBy() 함수 등은 1개의 Observable을 확장해주는 반면, 결합 연산자들은 <strong>여러 개의 Observable을 내가 원하는 Observable로 결합해준다.</strong></p>
<p><strong>1. zip()</strong></p>
<ul>
<li>각각의 Observable을 모두 활용해 2개 혹은 그 이상의 Observable을 결합한다.</li>
<li>예를 들어, A, B 두 개의 Observable을 결합한다면 2개의 Observable에서 모두 데이터를 발행해야 결합할 수 있다. 그전까지는 발행을 기다린다.</li>
</ul>
<img src="/img/rx_zip.png" width="500" height="200">
<p>zip() 함수는 최대 9개의 Observable을 결합할 수 있지만 보통 2개 혹은 3개면 충분하다. 다음은 간단한 zip() 함수의 사용 예제이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    executeZipInteger();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executeZipInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Observable.zip(</span><br><span class="line">                Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>),</span><br><span class="line">                Observable.just(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>),</span><br><span class="line">                Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">                (a, b, c) -&gt; a + b + c</span><br><span class="line">        ).subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">111</span></span><br><span class="line">main | value = <span class="number">222</span></span><br><span class="line">main | value = <span class="number">333</span></span><br></pre></td></tr></table></figure>
<p><strong>2. zipWith()</strong></p>
<p>zipWith() 함수는 zip() 함수와 동일하지만 Observable을 다양한 함수와 조합하면서 틈틈이 호출할 수 있는 장점이 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipWithSample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Observable&lt;Integer&gt; source = Observable.zip(</span><br><span class="line">                Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>),</span><br><span class="line">                Observable.just(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>),</span><br><span class="line">                (a, b) -&gt; a + b)</span><br><span class="line">                .zipWith(Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (ab, c) -&gt; ab * c);</span><br><span class="line">        source.subscribe(Log::i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">110</span></span><br><span class="line">main | value = <span class="number">440</span></span><br><span class="line">main | value = <span class="number">990</span></span><br></pre></td></tr></table></figure>
<p>두 Observable을 zip() 함수로 묶고 세 번째 Observable을 다시 zipWith() 함수로 결합했다. zipWith() 함수를 호출할 때는 앞서 a와 b를 결합했기 때문에 ab로 명명했다.</p>
<p><strong>3. combinLatest()</strong></p>
<p>2개 이상의 Observable을 기반으로 Observable 각각의 값이 변경되었을 때 갱신해주는 함수이다. 마지막 인자로 combiner가 들어가는데 그것이 각 Observable을 결합하여 어떤 결과를 만들어주는 역할을 하는 함수이다. zip() 함수의 zipper 인자와 동일하다.</p>
<p>예를 들어, 첫 번째 Observable과 두 번째 Observable을 결합하는 기능을 만든다고 하면 첫 번째 Observable의 값 혹은 두 번째 Observable의 값이 <strong>변경되었을 때 그 값을 자동으로 갱신해준다.</strong></p>
<img src="/img/rx_combinelatest.png" width="500" height="200">
<p>첫 번째 Observable에서만 데이터를 발행하거나 두 번째 Observable의 데이터 흐름만 있으면 구독자에게 어떤 데이터도 발행하지 않는다. 하지만 두 Observable 모두 값을 발행하면 그때는 결과값이 나온다. 그 다음부터는 둘 중에 어떤 것이 갱신되던지 최신 결과값을 보여준다. -&gt; 이 부분이 zip() 함수와 다른 점이다.</p>
<p>zip() 함수처럼 결합하고자 하는 첫 번째와 두 번쨰 Observable을 넣고 마지막으로 그것을 결합하는 combiner() 함수를 넣어주면 된다. 입력할 수 있는 Observable 인자의 개수는 9개이다.</p>
<p><strong>4. merge()</strong></p>
<ul>
<li>zip() 함수나 combineLatest() 함수와 비교하면 가장 단순한 결합 함수이다.</li>
<li>입력 Observable의 순서와 모든 Observable이 데이터를 발행하는지 등에 관여하지 않고 어느 것이든 업스트림에서 먼저 입력되는 데이터를 그대로 발행한다.</li>
</ul>
<img src="/img/rx_merge.png" width="500" height="200">
<p><strong>5. concat()</strong></p>
<ul>
<li>2개 이상의 Observable을 이어 붙여주는 함수이다.</li>
<li>첫 번째 Observable에 onComplete 이벤트가 발생해야 두 번째 Observable을 구독한다. 스레드를 활용한 일반적이 코드로 이와 같은 내용을 구현하기는 복잡하다.</li>
<li>결합할 수 있는 Observable은 최대 4개이다.</li>
</ul>
<img src="/img/rx_concat.png" width="500" height="200">
<p>첫 번째 Observable에 onComplete 이벤트가 발생하지 않게 되면 두 번째 Observable은 영원히 대기한다. 이는 잠재적인 메모리 누수의 위험을 내포한다. 따라서 입력 Observable이 반드시 완료(onComplete 이벤트)될 수 있게 해야 한다.</p>
<blockquote>
<p>Observable의 중간 상태를 확인하는 방법</p>
</blockquote>
<p>리액티브 프로그래밍을 할 때는 중간에 로그를 출력하는 것이 낯설게 느껴진다. 특히 함수형 프로그래밍 패러다임을 배우면서 &quot;로그나 화면 출력하는 등을 부수 효과를 발생시킨다&quot;라는 내용을 접하면 부수 효과를 최소화하려고 하는 경향이 생긴다.</p>
<p>하지만 부수 효과를 감내하고서라도 적절한 로그는 유지 보수성을 확보하기 위해 꼭 필요하다. RxJava에서는 Observable의 중간 결과를 간편하게 확인할 수 있는 함수들을 제공한다. 확실하지 않은 코드나 예제 코드를 실행할 때 찜찜한 부분이 있다면 doOnNext(), doOnComplete(), doOnError() 함수를 추가해보자.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/09/RxJava-Chap04-Combination/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/08/RxJava-Chap04-Transform/"
                            aria-label=": [RxJava] Chap04.변환연산자"
                        >
                            [RxJava] Chap04.변환연산자
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-08T00:40:00+09:00">
	
		    Jun 08, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="변환-연산자">변환 연산자</h2>
<p>위에서 데이터 흐름(Observable)을 만들어내는 생성 연산자를 보았다면 이번에는 데이터 흐름을 원하는대로 변형할 수 있는 변환 연산자를 알아보자.</p>
<p><strong>1. concatMap()</strong></p>
<p>flatMap() 함수와 매우 비슷하다. 하지만, <code>concatMap()</code> 함수는 먼저 들어온 데이터 순서대로 처리해서 결과를 낼 수 있도록 보장한다. 즉, <strong>데이터의 순서를 보장한다.</strong> flatMap() 함수는 순서를 보장하지 않는다.</p>
<p>flatMap() 함수는 먼저 들어온 데이터를 처리하는 도중에 새로운 데이터가 들어오면 나중에 들어온 데이터의 처리 결과가 먼저 출력될 수도 있다. 이를 인터리빙(끼어들기)라고 한다.</p>
<img src="/img/rx_concatmap.png" width="500" height="200">
<p><strong>2.switchMap()</strong></p>
<p>concatMap() 함수가 인터리빙이 발생할 수 있는 상황에서 동작의 순서를 보장해준다면 <code>switchMap()</code> 함수는 순서를 보장하기 위해 기존에 진행중이던 작업을 바로 중단한다. 그리고 여러 개의 값이 발행되었을 때 마지막에 들어온 값만 처리하고 싶을 때 사용한다. 중간에 끊기더라도 마지막 데이터의 처리는 보장하기 때문이다.</p>
<img src="/img/rx_switchmap.png" width="500" height="200">
<p>마블 다이어그램이 조금 복잡하지만, 시간이 겹치지 않는다는 것을 유의하면 된다.<br>
빨간색 도형의 경우 정상적으로 처리했지만,<br>
<strong>초록색 도형을 처리하는 도중에 파란색 도형이 들어왔으므로 초록색 도형의 처리는 중단하고 파란색으로 도형을 처리한다.</strong></p>
<p>switchMap() 함수는 센서 등의 값을 얻어와서 동적으로 처리하는 경우에 매우 유용하다. 센서 값을 중간값보다는 최종적인 값으로 결과를 처리하는 경우가 많기 때문이다. 이럴 때는 flatMap() 함수로 매번 새로운 결과가 나왔는지 검사하지 말고 손쉽게 switchMap() 함수를 사용하자.</p>
<p><strong>3. groupBy()</strong></p>
<p>어떤 기준(KeySelector 인자)으로 단일 Observable을 여러 개로 이루어진 Observable 그룹(GroupedObservable)으로 만든다.</p>
<img src="/img/rx_groupby.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    	String[] objs = &#123;PUPPLE, SKY, triangle(YELLOW), YELLOW, triangle(PUPPLE), triangle(SKY)&#125;;</span><br><span class="line">		Observable&lt;GroupedObservable&lt;String, String&gt;&gt; source = </span><br><span class="line">				Observable.fromArray(objs)</span><br><span class="line">				.groupBy(Shape::getShape);</span><br><span class="line">		</span><br><span class="line">		source.subscribe(obj -&gt; &#123;</span><br><span class="line">			obj.subscribe(val -&gt; </span><br><span class="line">			System.out.println(<span class="string">"GROUP:"</span> + obj.getKey() + <span class="string">"\t Value:"</span> + val));</span><br><span class="line">		&#125;);</span><br><span class="line">		CommonUtils.exampleComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>원래 코틀린으로 해결하려고 했는데, 어떻게 짜야될지 몰라서 자바로 진행해본다.<br>
코드가 조금 복잡하다. GroupedObservable 클래스는 Observable과 동일하지만 getKey() 메소드를 제공하여 구분된 그룹을 알 수 있게 해준다. source는 objs[] 배열에서 입력 데이터를 가져온다. 그룹을 구별하기 위해서 Shape.getShape() 함수를 사용한다.</li>
</ul>
<p>getShape() 함수의 내용은 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getShape</span><span class="params">(String obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (obj == <span class="keyword">null</span> || obj.equals(<span class="string">""</span>)) <span class="keyword">return</span> NO_SHAPE;		</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-H"</span>)) <span class="keyword">return</span> HEXAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-O"</span>)) <span class="keyword">return</span> OCTAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-R"</span>)) <span class="keyword">return</span> RECTANGLE;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-T"</span>)) <span class="keyword">return</span> TRIANGLE;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"&lt;&gt;"</span>)) <span class="keyword">return</span> DIAMOND;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-P"</span>)) <span class="keyword">return</span> PENTAGON;</span><br><span class="line">	<span class="keyword">if</span> (obj.endsWith(<span class="string">"-S"</span>)) <span class="keyword">return</span> STAR;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"BALL"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>source.subscribe()에 전달하는 obj는 GroupedObservable 객체이다. 그룹별로 1개씩 생성되므로 생성된 obj 별로 다시 subscribe() 함수를 호출해야 한다. val은 그룹 안에서 각 Observable이 발행한 데이터를 의미한다.(즉, GroupedObservable이 발행한 데이터 ex. “BALL - 6”)</p>
<ul>
<li>만약, 모든 그룹을 처리하고 싶은게 아니라 특정 그룹만 처리하고 싶다면 filter() 함수를 이용해 조건을 추가해주면 된다.</li>
<li>getKey() : 메소드는 그룹의 구분자 값을 리턴한다.(즉, Key 값)</li>
</ul>
<blockquote>
<p>map(), flatMap(), groupBy() 비교</p>
</blockquote>
<ul>
<li>map() : 함수는 1개의 데이터를 다른 값이나 타입으로 변환해준다.</li>
<li>flatMap() : 함수는 1개의 값을 받아서 여러 개의 데이터(Observable)로 확장해준다.</li>
<li>groupBy() : 함수는 값들을 받아서 어떤 기준에 맞는 새로운 Observable 다수를 생성한다.</li>
</ul>
<p><strong>4. scan()</strong></p>
<ul>
<li>reduce() 함수와 비슷하다.</li>
<li>reduce() : Observable에서 모든 데이터가 입력된 후 그것을 종합하여 마지막 1개의 데이터만을 구독자에게 발행한다.</li>
</ul>
<p>반면, scan() 함수는 실행할 때마다 <strong>입력값에 맞는 중간 결과 및 최종 결과를 구독자에게 발행한다.</strong></p>
<img src="/img/rx_scan.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeScan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> source = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">            .scan &#123; ball1: String, ball2: String -&gt; <span class="string">"<span class="variable">$ball2</span> (<span class="variable">$ball1</span>)"</span> &#125;</span><br><span class="line"></span><br><span class="line">    source.subscribe(Log::i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">1</span></span><br><span class="line">main | value = <span class="number">3</span> (<span class="number">1</span>)</span><br><span class="line">main | value = <span class="number">5</span> (<span class="number">3</span> (<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>reduce()와 다른점이 있다. 첫 번째는 source의 타입이 Maybe<string>이 아니라 Observable<string>이라는 것이다. <strong>reduce()</strong> 함수의 경우 마지막 값이 입력되지 않거나 onComplete 이벤트가 발생하지 않으면 구독자에게 값을 발행하지 않는다. 최악의 경우에는 값을 전혀 발해아지 않고 종료할 수도 있기 때문에 Maybe 클래스 타입으로 정의했다.</string></string></p>
<p>반면, <code>scan()</code> 함수는 값이 <code>입력될 때마다 구독자에게 값을 발행</code>한다. 따라서 Maybe가 아니라 Observable이다. 그리고 출력된 결과를 확인하면 main 스레드에서 실행되며 값이 입력될 때마다 발행하는 것을 확인할 수 있다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/08/RxJava-Chap04-Transform/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/05/Android-Glide/"
                            aria-label=": [Android] Glide 삽질 과정"
                        >
                            [Android] Glide 삽질 과정
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-05T16:28:28+09:00">
	
		    Jun 05, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Android/">Android</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>안드로이드 앱에서 이미지를 보여주는 화면이 많다. 서버로부터 받은 url 이미지를 보여줘야 할 때도 있고, local에 저장해뒀다가 보여줘야 하는 경우도 있다. 오늘 이야기할 내용은 Glide를 사용해서 <strong>SVG</strong> 이미지를 화면에 보여주는 과정에서 내가 겪은 삽집을 풀도록 하겠다.</p>
                    
                        <a
                            href="/2019/06/05/Android-Glide/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [Android] Glide 삽질 과정"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/06/03/RxJava-Chap04/"
                            aria-label=": [RxJava] Chap04"
                        >
                            [RxJava] Chap04
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-06-03T17:59:09+09:00">
	
		    Jun 03, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>해당 글은 직접 책을 구매하여 공부의 목적으로 정리하는 글임을 알려드립니다.</p>
<p>이번에는 리액티브 연산자를 카테고리별로 알아보도록 하겠다. 이유는 연산자의 종류가 많기도 하고 카테고리로 쓰임새를 어느 정도 짐작할 수 있기 때문이다.</p>
<p><code>생성 연산자</code>는 Observable로 데이터 흐름을 만들고 <code>변환 연산자와 필터 연산자</code>는 데이터 흐름을 내가 원하는 방식으로 변형한다. 결합 연산자는 1개의 Observable이 아니라 여러 개의 Observable을 조합할 수 있도록 해준다.</p>
<h2 id="생성-연산자">생성 연산자</h2>
<ul>
<li>생성 연산자의 역할은 데이터 흐름을 만드는 것이다.</li>
<li>Observable(Observable, Single, Maybe 객체 등)을 만든다고 생각하면 된다.</li>
<li>앞선 챕터에서는 just(), fromXXX(), create() 함수 등을 봤고, 이번에는 다른 연산자들을 확인해보도록 하겠다.</li>
</ul>
<p><strong>1. interval()</strong></p>
<ul>
<li>일정 시간 간격으로 데이터 흐름을 생성한다.</li>
<li>주어진 시간 간격으로 0부터 1씩 증가하는 Long 객체를 발행한다.</li>
<li>두 가지의 함수 원형을 가지고 있으며, 최초 지연 시간을 조절하는 함수와 그렇지 않은 함수가 존재한다.</li>
<li>period(일정 시간)동안 쉬었다가 데이터를 발행한다.</li>
<li>기본적으로 영원히 지속되기 때문에 폴링 용도로 많이 사용한다.</li>
<li>함수의 동작이 현재 스레드가 아닌 계산을 위한 별도의 스케줄러(스레드)에서 동작한다.</li>
</ul>
<img src="/img/interval.png" width="500" height="200">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 원형</span></span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.COMPUTATION)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Long&gt; <span class="title">interval</span><span class="params">(<span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeInterval</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 시작 시간을 표시하는 유틸리티 메소드이다.</span></span><br><span class="line"><span class="comment">    * RxJava - 비동기 프로그래밍이기 때문에 시간에 대한 이해가 중요하다.</span></span><br><span class="line"><span class="comment">    * 시작 시간을 기준으로 RxJava 각 함수의 실행 시간을 측정하기 위함이다.</span></span><br><span class="line"><span class="comment">    * sleep()을 호출하는 이유는 다른 스레드에서 실행이 완료될 때까지 기다려야 하기 때문이다.</span></span><br><span class="line"><span class="comment">    * 해당 문장을 주석 처리하게 되면 기다리지 않고 바로 프로그램이 종료되는 것을 확인할 수 있다.</span></span><br><span class="line"><span class="comment">    * 이유는 메인 스레드에서 할 일이 없기 때문이다.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                (<span class="keyword">data</span> + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(TIME)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">247</span> | value = <span class="number">100</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">347</span> | value = <span class="number">200</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">445</span> | value = <span class="number">300</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">545</span> | value = <span class="number">400</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">645</span> | value = <span class="number">500</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>2. timer()</strong></p>
<ul>
<li>interval() 함수와 유사하지만 <code>time()</code> 함수는 <strong>한 번만 실행되는 함수</strong>이다.</li>
<li><strong>일정 시간이 지난 후 한 개의 데이터를 발행하고 onComplete() 이벤트가 발생한다.</strong></li>
<li>전반적으로 interval() 함수와 유사하다. 계산 스케줄러에서 실행되며 함수의 발행되는 데이터도 interval() 함수의 첫 번째 값인 0L이다.</li>
<li>보통 일정 시간이 지난 후 어떤 동작을 실행할 때 활용한다. 우리가 사용하는 타이머를 맞춘다고 생각하면 된다.</li>
</ul>
<img src="/img/timer.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> source = Observable.timer(<span class="number">500</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; notUsed -&gt;</span><br><span class="line">                SimpleDateFormat(<span class="string">"yyyy/MM/dd HH:mm:ss"</span>)</span><br><span class="line">                        .format(Date())</span><br><span class="line">            &#125;</span><br><span class="line">    source.subscribe(Log::it)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">    CommonUtils.exampleComplete()</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * timer() 함수도 메인 스케줄러가 아닌 계산 스케줄러에서 실행되기 때문에</span></span><br><span class="line"><span class="comment">    * 계산 스케줄러가 완료될 때까지 기다리기 위해서 sleep() 함수를 호출하여 준다.</span></span><br><span class="line"><span class="comment">    * 즉, 계산 스케줄러의 동작이 완료될 때까지 메인 스케줄러가 기다리는 것이다.</span></span><br><span class="line"><span class="comment">    * 그렇지 않으면 메인 스케줄러에서 할 일이 없기 때문에 프로그램이 바료 종료된다.</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | <span class="number">708</span> | value = <span class="number">2019</span>/<span class="number">06</span>/<span class="number">03</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">26</span></span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure>
<p><strong>3. range()</strong></p>
<ul>
<li>주어진 값(n)부터 m개의 Integer 객체를 발행한다.</li>
<li>interval(), timer() 함수는 Long 객체를 발행했지만, range() 함수는 Integer 객체를 발행한다.</li>
<li>특정한 스케줄러에서 실행되지 않는다. 즉, 현재 스레드에서 실행한다.</li>
<li>반복문(for, while문)을 대체할 수 있다.</li>
</ul>
<img src="/img/chapter4_range.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* range() 함수로 1부터 10까지 숫자를 생성한다.</span></span><br><span class="line"><span class="comment">* 그리고 filter() 함수를 이용해 짝수만 걸러낸다.</span></span><br><span class="line"><span class="comment">* 현재 쓰레드에서 실행된다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">            .filter &#123; num -&gt;</span><br><span class="line">                num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">main | value = <span class="number">2</span></span><br><span class="line">main | value = <span class="number">4</span></span><br><span class="line">main | value = <span class="number">6</span></span><br><span class="line">main | value = <span class="number">8</span></span><br><span class="line">main | value = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><strong>4. intervaleRange()</strong></p>
<ul>
<li>interval()과 range() 함수를 혼합해놓은 함수이다.</li>
<li>interval() 함수처럼 일정한 시간 간격으로 값을 출력하지만, range() 함수처럼 시작 숫자(n)로부터 m개만큼의 값만 생성하고 onComplete 이벤트가 발생한다.</li>
<li>interval() 함수처럼 무한히 데이터 흐름을 발행하지 않는다. 반환 타입은 Long 타입이다.</li>
<li>계산 스케줄러에서 실행된다.</li>
</ul>
<img src="/img/intervalRange.png" width="500" height="200">
<p>사실 intervalRange() 함수는 interval() 함수와 다른 함수를 조합해서 만들 수 있다. 이유는 intervalRange() 함수가 직관적이지 않기 때문이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* main 스레드에서 실행되는 것이 아니기 때문에 sleep() 함수를 호출한다.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.intervalRange(<span class="number">1</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            <span class="number">100</span>L,</span><br><span class="line">            TimeUnit.MILLISECONDS)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">1</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">2</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">3</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">4</span></span><br><span class="line">RxComputationThreadPool<span class="number">-1</span> | value = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>interval() 함수 -&gt; intervalRange() 함수 만들기</p>
<ul>
<li>interval() 함수 사용</li>
<li>map() 함수 사용</li>
<li>take() 함수 사용</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">executeIntervalRangeUsingIntervalAndMapAndTake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Observable.interval(<span class="number">100</span>L, TimeUnit.MILLISECONDS)</span><br><span class="line">            .map &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="keyword">data</span> + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            .take(<span class="number">5</span>)</span><br><span class="line">            .subscribe(Log::i)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5. defer()</strong></p>
<ul>
<li>데이터 흐름 생성을 구독자가 subscribe() 함수를 호출할 때까지 미룰 수 있다. 이때 새로운 Observable이 생성된다.</li>
<li>Observable의 생성이 구독할 때까지 미뤄지기 때문에 최신 데이터를 얻을 수 있다.</li>
<li>현재 스레드에서 실행되며, 인자로는 Callable&lt;Observable<t>&gt;를 받는다. Callable 객체이므로 구독자가 subscribe()를 호출할 때까지 call() 메소드의 호출을 미룰 수 있다.</t></li>
</ul>
<img src="/img/defer.png" width="500" height="200">
<p><code>defer()</code> 함수는 구독자가 구독할 때까지 Observable의 데이터 발행을 미루는 역할을 한다. 따라서 구독자가 subscribe()를 호출하는 시점에 최신의 데이터를 받을 수 있다. defer() 함수를 사용하지 않은 상황에서 구독자 두명이 그대로 구독을 하게 되면 같은 5에 대한 데이터를 발행하고 구독자가 받게 된다.</p>
<p><strong>개념이 조금 어렵다;; 천천히 다시 볼 필요가 있다.</strong></p>
<p>여기에서 다룬 Observable은 모두 차가운 Observable이다. Observable을 생성할 때 입력값이 결정되고 구독자가 subscribe() 함수를 호출하면 그때 해당 데이터 흐름을 그대로 발행한다. 즉, defer() 함수를 활용하면 subscribe() 함수를 호출할 때의 상황을 반영하여 데이터 흐름의 생성을 지연하는 효과를 보여준다. 내부적으로 구독자가 subscribe() 함수를 호출하면 그때 supplier의 call() 메소드를 호출한다.</p>
<p><strong>6. repeat()</strong></p>
<ul>
<li>단순히 반복 실행을 하는 함수이다.</li>
<li>서버와 통신을 할 때 해당 서버가 살아있는지 확인(이 확인 과정을 보통 ping 혹은 heart beat라고 한다.)하는 코드를 작성할 때 주로 사용한다.</li>
<li>인자를 입력하지 않으면 영원히 실행된다. 따라서 반복하길 원하는 숫자만큼 인자로 전달하는게 좋다.</li>
</ul>
<img src="/img/repeat.png" width="500" height="200">
<p><strong>예제로 heart beat를 간단하게 구현해보기</strong></p>
<p>서버와 연동하는 앱을 작성하다 보면 통신하는 서버가 동작하는지 확인하는 코드가 필요하다. 지속적인 통신을 해야 하는 서버의 경우 명세서에 동작 확인 코드를 작성할 것을 명시하기도 한다.</p>
<p>보통 일정 시간 안데 heart beat 패킷을 보내지 않으면 서버는 클라이언트와의 연결이 종료된 것으로 판단하고 연결을 해제한다. (보통 30초 간격으로 heart beat 신호를 보낸다.) 이럴 때 repeat() 함수를 활용하면 heart beat 패킷을 보내는 프로그램을 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    CommonUtils.exampleStart()</span><br><span class="line">    <span class="keyword">val</span> serverUrl: String = <span class="string">"https://api.github.com/zen"</span></span><br><span class="line"></span><br><span class="line">    Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS)</span><br><span class="line">            .map &#123; it -&gt;</span><br><span class="line">                serverUrl</span><br><span class="line">            &#125;</span><br><span class="line">            .map(OkHttpHelper::<span class="keyword">get</span>)</span><br><span class="line">            .repeat()</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result: <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                Log.it(<span class="string">"Ping result fail: <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">    CommonUtils.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 아래는 OkHttpHelper 클래스이다.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static OkHttpClient client = new OkHttpClient();</span><br><span class="line">    <span class="keyword">public</span> static String ERROR = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String <span class="keyword">get</span>(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.e(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getT(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Response res = client.newCall(request).execute();</span><br><span class="line">            <span class="keyword">return</span> res.body().string();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.et(e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static String getWithLog(String url) throws IOException &#123;</span><br><span class="line">        Log.d(<span class="string">"OkHttp call URL = "</span> + url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">get</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>timer() 함수를 사용해 2초마다 반복 실행되도록 했다. 약 2초 간격으로 실행된다. 원래 timer() 함수는 한 번 호출된 후에는 종료된다. 그런데 계속 반복해서 실행되는 것을 볼 수 있다.</p>
<p>이유는 repeat() 함수 때문이다. repeat() 함수는 동작이 한 번 끝난 다음에 다시 구독하는 방식으로 동작한다. 그리고 다시 구독할 때마다 동작하는 스레드의 번호가 달라진다.</p>
<p>만약 동작하는 스레드를 동일하게 맞추고 싶다면 timer()와 repeat() 함수를 빼고 interval() 함수를 대신 넣어 호출하면 된다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/06/03/RxJava-Chap04/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/kotlin-chap3/"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            [커니의 Kotlin] Chap3
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T21:52:08+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Book/">Book</a>, <a class="category-link" href="/categories/Book/커니의-Kotlin/">커니의 Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>해당 글은 <strong>커니의 코틀린</strong> 책을 구매하여 공부하고 작성한 글입니다.</p>
                    
                        <a
                            href="/2019/05/28/kotlin-chap3/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [커니의 Kotlin] Chap3"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/Two-Pointer-Algorithm/"
                            aria-label=": [알고리즘] 투포인터 알고리즘"
                        >
                            [알고리즘] 투포인터 알고리즘
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T12:39:06+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>, <a class="category-link" href="/categories/algorithm/BOJ/">BOJ</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>신입 개발자를 위한 <a href="https://github.com/WooVictory/Ready-For-Tech-Interview" target="_blank" rel="noopener">Repository</a>를 만들었습니다. 공부한 내용을 정리 중이니 도움이 되신다면 와서 Star를 눌러주시면 감사하겠습니다.</p>
<p>알고리즘 문제를 풀다가 완전 탐색으로 해결하면 시간 초과가 나서 어떻게 풀어야 하는가 하다가 검색해보니 <code>투 포인터 알고리즘</code>이라는 개념이 나와서 간단하게 정리하고 넘어가겠다.</p>
<p>1차원 배열이 있고 이 배열에서 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 원하는 것을 얻는 형태이다. 이 때문에 투 포인터 알고리즘이라고 부른다.</p>
<p><strong>대표적인 문제</strong></p>
<ul>
<li><a href="https://www.acmicpc.net/problem/2003" target="_blank" rel="noopener">2003</a></li>
</ul>
<p>문제는 N칸의 1차원 배열이 있을 때, 부분 배열 중 그 원소의 합이 M이 되는 경우의 수를 구하는 것이다. 모든 경우의 수를 다 테스트해보면, 구간 합을 구간합 배열로 O(1)만에 구한다고 해도 경우의 수가 (N^2)이 된다. 따라서 문제를 풀 수 없다.</p>
<p>이 문제에서 <strong>각 원소는 자연수이고 M 또한 자연수</strong>인데, 이 조건이 성립하면 사용할 수 있는 알고리즘은 다음과 같다.</p>
<ul>
<li>포인터 2개를 준비한다. 시작과 끝을 나타낼 수 있도록 start, end라고 하겠다.</li>
<li>맨 처음에는 start = end = 0이며, 항상 start&lt;=end 을 만족해야 한다.</li>
<li>이 두개의 포인터는 현재 부분 배열의 시작과 끝을 가리키는 역할을 한다.</li>
</ul>
<p>s = e일 경우 그건 크기가 0인 즉, 아무것도 포함하지 않는 부분 배열을 뜻한다. 이제 아래의 과정을 <strong>start&lt;N</strong> 인 동안 반복한다.</p>
<ol>
<li>현재 부분합이 M 이상이거나, 이미 end = N이면 start++</li>
<li>그렇지 않다면 end++</li>
<li>현재 부분합이 M과 같다면 count++</li>
</ol>
<p>쉽게 이해하자면, start와 end를 무조건 증가시키는 방향으로만 변화시켜가면서, 도중에 부분 배열의 합이 정확히 M이 되는 경우를 세는 것이다.</p>
<p>그림으로 보는게 편하다. 그림을 그리기에는 시간이 좀 걸려서 내가 보고 이해한 그림을 첨부하겠다. 아래 참고한 블로그를 보면 설명을 아주 잘해주셨다. 이것만 보면 이해가 될 것이다.</p>
<p>대표적인 문제를 풀어봤다. 백준 2003번으로 <strong>수들의 합2</strong> 문제이다. 풀이는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 투포인터 알고리즘</span></span><br><span class="line"><span class="comment"> * start : 시작</span></span><br><span class="line"><span class="comment"> * end : 끝</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String[] input = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> n = parse(input[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = parse(input[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        String[] num = br.readLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = parse(num[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 부분합이 m 보다 큰 경우 start 가 가리키는 원소를 빼고</span></span><br><span class="line">            <span class="comment">// start 의 값을 증가시킨다. 즉, start 뒤로 이동.</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= m) &#123;</span><br><span class="line">                sum = sum - arr[start++];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// end 가 n 에 도달하면 종료한다.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end == n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 위의 두 경우에 해당하지 않으면 end 는 뒤로 이동하면서 원소의 값을</span></span><br><span class="line">                <span class="comment">// sum 에 더한다.</span></span><br><span class="line">                sum = sum + arr[end++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 부분 합이 m 과 같다면 count 를 증가시켜준다.</span></span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="참고">참고</h2>
<ul>
<li><a href="https://m.blog.naver.com/kks227/220795165570" target="_blank" rel="noopener">투 포인터(Two Pointers Algorithm), 슬라이딩 윈도우(Sliding Window)</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/Two-Pointer-Algorithm/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/28/What-is-Kotlin-Object/"
                            aria-label=": [Kotlin] Object"
                        >
                            [Kotlin] Object
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-28T00:25:51+09:00">
	
		    May 28, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>코틀린에는 static 개념이 없다. 사실 개념이 없다기 보다는 static keyword가 없기 때문에 Java의 static 개념을 코틀린에서 표현할 수 없다. 그래서 이를 어떻게 표현하는지 중점적으로 살펴보겠다.</p>
<ul>
<li>싱글톤을 정의하는 방법</li>
<li>동반 객체 companion object를 이용한 팩토리 메소드 구현</li>
<li>익명 클래스 선언</li>
</ul>
<p>위의 3가지를 <strong>object</strong> keyword를 이용해 표현한다.</p>
<h2 id="싱글톤">싱글톤</h2>
<p>코틀린에서는 object를 이용하여 클래스를 정의함과 동시에 객체를 생성할 수 있다. 말 그대로 싱글톤을 쉽게 구현할 수 있다. 이해하기 쉽게 간단한 예제를 만들었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPreference</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SharedPreference INSTACNE=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedPreference</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTACNE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTACNE = SharedPreference();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 코드는 자바에서 사용할 수 있는 간단한 싱글톤 패턴 구현 코드이다. 그럼 이제 코틀린에서 object를 사용해 바꿔보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreference&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생략.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    SharedPreference.init(applicationContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 object로 선언하면 클래스 선언과 동시에 객체가 생성된다. 따라서 객체 이름을 통해 property나 메소드에 접근할 수 있다.</p>
<p>object 클래스는 가장 바깥 클래스로 선언될 수도 있고, 내부에 중첩된 클래스 형태로 선언될 수도 있다. 하지만, 어떤 방식으로 선언되었던 간에 존재하는 object는 단일 객체만 존재한다.</p>
<h2 id="companion-object">companion object</h2>
<p>코틀린에서는 static을 지원하지 않는 대신 <code>top-level function</code>을 통해 같은 효과를 낼 수 있다. 단, top-level function은 class 내부에 선언된 private property에는 접근할 수 없는 제한을 받는다.</p>
<p>이를 해결하기 위해서 <code>companion object</code>라는 개념이 존재한다. 클래스의 인스턴스 생성과 상관없이 호출해야 하지만 class의 내부 정보에 접근할 수 있는 함수가 필요할 때 companion obejct를 class 내부에 선언한다. <strong>Java로 따지면 class 내부에 static 함수를 넣는다고 생각하면 된다.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"Companion obejct call!!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    A.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이처럼 A 클래스 내부에서 선언된 companion object는 호출할 때 클래스 이름으로 바로 호출할 수 있다. (Java의 static 함수와 동일한 형태이다.)</p>
<p>또한, <code>companion object</code>는 외부 클래스의 private property에도 접근이 가능하기 때문에, factory method를 만들 때 적합하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">val</span> nickname: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newSubscribingUser</span><span class="params">(email: <span class="type">String</span>)</span></span> = User(email.substringBefore(<span class="string">'@'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">newFacebookUser</span><span class="params">(accountId: <span class="type">Int</span>)</span></span> = User(getFacebookName(accountId))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> subscribingUser = User.newSubscribingUser(<span class="string">"jhsw0375@gmail.com"</span>)</span><br><span class="line">    <span class="keyword">val</span> facebookUser = User.newFacebookUser(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    println(subscribingUser.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위에서 User 클래스는 <strong>private constructor</strong>를 가지기 때문에 외부에서 생성할 수 없다. 따라서 외부에서는 companion으로 제공되는 factory method를 이용해서만 객체를 생성할 수 있도록 제한할 수 있다.</p>
<h2 id="companion-object의-사용">companion object의 사용</h2>
<p>companion object는 클래스 내부에 정의된 일반 객체이다. 따라서 아래와 같은 작업이 가능하다.</p>
<ul>
<li>companion object에 이름 명명</li>
<li>companion object 내부에 확장 함수나 property 정의</li>
<li>인터페이스 상속</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Loader&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: Person = ... 생략.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    person = Person.Loader.fromJSON(<span class="string">"&#123;name: 'kim'&#125;"</span>)</span><br><span class="line">    person = Person.fromJSON(<span class="string">"&#123;name: 'lee'&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>companion object에 이름을 붙일 수 있으며, 이름을 통해서 호출할 수도 있고 그냥 호출할 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JSONFactory</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fromJSON</span><span class="params">(jsonText: <span class="type">String</span>)</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>: JSONFactory&#123;</span><br><span class="line">        <span class="keyword">override</span> fromJSON(jsonText: String): Person = ... 생략</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> loadFromText<span class="type">&lt;T&gt;</span><span class="params">(factory: <span class="type">JSONFactory</span>&lt;<span class="type">T</span>&gt;)</span></span>: T&#123;</span><br><span class="line">    ... 생략.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    loadFromText(Person)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드처럼 companion object가 특정 interface를 구현할 수도 있고, 이 interface를 넘겨줄 때는 외부 class 이름을 사용한다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClickListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    setClickAction(<span class="keyword">object</span>: ClickListener&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">            println(<span class="string">"clicked!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setClickAction</span><span class="params">(clickListener: <span class="type">ClickListener</span>)</span></span>&#123;</span><br><span class="line">    clickListener.onClick()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드에서 익명 클래스는 singleton이 아니다. 따라서 호출시 매번 객체가 생성된다는 점과 익명 클래스 내에서는 외부 클래스의 변수에 접근하여 값을 수정할 수도 있다.</p>
<h2 id="sharedpreferences-예제">SharedPreferences 예제</h2>
<p>Android에서는 간단한 값을 저장하기 위해서 <code>SharedPreferences</code>를 사용한다. 프로그램 어디서나 이 객체를 사용할 수 있어야 하기 때문에 일반적으로 <strong>Singleton</strong>을 이용해 구현하곤 한다. 자바에서는 싱글톤을 손쉽게 구현할 수 있다. 마찬가지로 코틀린에서도 object 개념을 사용해서 간단하게 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SharedPreferenceManager&#123;</span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> PREF_TOKEN = <span class="string">"token"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> NAME = <span class="string">"Test"</span></span><br><span class="line">    <span class="keyword">private</span> const <span class="keyword">val</span> MODE = Context.MODE_PRIVATE</span><br><span class="line">    <span class="keyword">private</span> latedinit <span class="keyword">var</span> preferences: SharedPreferences</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(context: <span class="type">Context</span>)</span></span>&#123;</span><br><span class="line">        preferences = context.getSharedPreferences(NAME, MODE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 확장 함수를 사용한다. 따라서 edit(), apply() 함수를 호출할 필요가 없다. 모든 작업을 이 함수 하나로 대체할 수 있다.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> SharedPreferences.<span class="title">edit</span><span class="params">(operation: (<span class="type">SharedPreferences</span>.<span class="type">Editor</span>)</span></span> -&gt; <span class="built_in">Unit</span>)&#123;</span><br><span class="line">        <span class="keyword">val</span> editor = edit()</span><br><span class="line">        operation(edit)</span><br><span class="line">        editor.apply()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> token: String</span><br><span class="line">        <span class="keyword">get</span>() = preferences.getString(PREF_TOKEN,<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">set</span>(value) = preferences.edit&#123;</span><br><span class="line">            it.putString(PREF_TOKEN, value)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>간단하게 토큰을 저장하는 예제이다. 저장해서 확인해보는 과정까지 거친 코드이므로 잘 동작한다. 확장 함수를 만들어서 이를 통해 edit(), apply() 함수를 직접 호출할 필요가 없다. 작성한 함수만 사용하면 되기 때문이다.</p>
<p>또한, 여러 개의 함수를 만들 필요 없이 하나의 함수만 사용하면 되고 저장할 값이 필요하다면 token 처럼 만들어서 사용자 지정 get,set을 사용하여 값을 가져오고 저장하는 과정을 거치면 된다.</p>
<p>이 클래스를 만들기 위해서 처음에 어떻게 잘 짤 수 있을까를 먼저 고민해보았다. 그런데 바보 같은 생각이라는 걸 깨달았다. 처음부터 잘 짤 수는 없는 것이다. 완벽한 코드는 없으면 코드를 짜면서 공부를 하면서 수정하면 되는 것이다.</p>
<p>그러니 처음부터 완벽한 코드를 짜려고 애쓰지 않도록 마음 먹었다. 리팩토링을 하면 나의 코드를 더 발전시켜 나갈 수 있으니 말이다. 오늘은 여기까지!</p>
<h2 id="참고">참고</h2>
<ul>
<li><a href="http://lomza.totem-soft.com/tutorial-how-to-use-sharedpreferences-in-kotlin/" target="_blank" rel="noopener">[Tutorial] How to use SharedPreferences in Kotlin</a></li>
<li><a href="https://tourspace.tistory.com/109" target="_blank" rel="noopener">[Kotlin] 코틀린 object</a></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/28/What-is-Kotlin-Object/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-right">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/24/Algorithm-Set/"
                            aria-label=": [알고리즘] 부분집합"
                        >
                            [알고리즘] 부분집합
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-24T16:24:20+09:00">
	
		    May 24, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/알고리즘/">알고리즘</a>


    
</div>

            </div>
            
                <div class="postShorten-excerpt">
                    <p>백준에 있는 문제 중 1182번을 풀면서 부분집합에 대한 내용이 나와서 간단하게 정리하려고 한다.</p>
<p>예를 들어 배열 [1,2,3]이 있다고 가정하자. 그러면 부분집합은 아래와 같다.</p>
                    
                        <a
                            href="/2019/05/24/Algorithm-Set/"
                            class="postShorten-excerpt_link link"
                            aria-label=": [알고리즘] 부분집합"
                        >
                            Continue reading
                        </a>
                        
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2019/05/22/RxJava-Chap03/"
                            aria-label=": [RxJava] Chap03"
                        >
                            [RxJava] Chap03
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2019-05-22T15:47:34+09:00">
	
		    May 22, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/RxJava/">RxJava</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h2 id="연산자">연산자</h2>
<p>ReactiveX의 연산자는 꽤 많다. 이 연산자들을 모두 안다고 하더라도 기억하기는 어렵다. 하지만, 이름을 보고 내용을 짐작할 수 있고 마블 다이어그램이 도움이 된다. 필요할 때 찾아보자.</p>
<p>대신, 여기서 소개하는 연산자는 자주 사용되니 꼭 알아두자!</p>
<h3 id="1map">1.map()</h3>
<ul>
<li>입력값을 어떤 함수에 넣어서 원하는 값으로 변환하는 함수이다.</li>
<li>입력 데이터가 있고 그것을 변환해줄 중개업자가 있다고 생각하면 좋다.</li>
<li>map() 함수는 반환값을 확인한다. 또한, 스케줄러를 지원하지 않으므로 현재 스레드에서 실행된다.</li>
<li><code>일대일 함수</code></li>
</ul>
<img src="/img/rx_map.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map을 통해 10을 곱해준 값을 반환.</span></span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">            .map &#123; item -&gt; item * <span class="number">10</span> &#125;</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(it.message)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메소드 참조도 가능.</span></span><br><span class="line">    Observable.just(<span class="string">"RED"</span>, <span class="string">"BLUE"</span>, <span class="string">"YELLOW"</span>,<span class="string">"BLACK"</span>)</span><br><span class="line">            .map(Test::ballToIndex) </span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(it.message)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Test &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ballToIndex</span><span class="params">(color: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">when</span> (color) &#123;</span><br><span class="line">        <span class="string">"RED"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"YELLOW"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"BLUE"</span> -&gt; &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2flatmap">2.flatMap()</h3>
<ul>
<li>map() 함수와 동일한 기능을 하지만 결과가 Observable로 나온다.</li>
<li>결과값이 Observable이므로 여러 개의 데이터를 발행할 수 있다.</li>
<li><code>일대다 함수</code> 혹은 <code>일대일 Observable</code> 함수이다.</li>
<li>1개를 발행할 수도 여러 개를 발행할 수도 있다.</li>
</ul>
<img src="/img/rx_flatmap.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function 인터페이스를 통해 제네릭 타입을 선언.</span></span><br><span class="line">    <span class="keyword">val</span> getDoubleDiamonds : (String) -&gt; Observable&lt;String&gt; = &#123; ball: String -&gt;</span><br><span class="line">        Observable.just&lt;String&gt;(<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>, <span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3개의 데이터를 넣었는데 6개를 발행한다.</span></span><br><span class="line">    <span class="comment">// 일대다이고, Observable 을 반환한다.</span></span><br><span class="line">    <span class="comment">// 위에서 정의한 Function 인터페이스 사용.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">            .flatMap(getDoubleDiamonds)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"성공 : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"실패 : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인라인을 사용.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>)</span><br><span class="line">            .map &#123; ball -&gt;</span><br><span class="line">                Observable.just(<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>,<span class="string">"<span class="variable">$ball</span>&lt;&gt;"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe&#123;</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Function&lt;T,R&gt; : T는 입력값을 의미하고 R은 결과 함수이다.</li>
<li>String을 넣으면 여러 개의 String을 발행하는 Observable이 나온다.</li>
<li><strong>여러 개의 데이터를 발행하는 방법은 Observable 뿐이다.</strong></li>
</ul>
<h3 id="3filter-함수">3.filter() 함수</h3>
<ul>
<li>Observable에서 <code>원하는 데이터만 걸러내는 역할</code>을 한다.</li>
<li>즉, 필요없는 데이터는 제거하고 관심있는 데이터만 filter() 함수를 통과한다.</li>
<li>간단한 수식을 적용하는 것과 원하는 조건을 작성할 수도 있다.</li>
</ul>
<img src="/img/rx_filter.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 짝수만 필터링.</span></span><br><span class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">            .filter &#123; number -&gt;</span><br><span class="line">                number % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">result : <span class="number">2</span></span><br><span class="line">result : <span class="number">4</span></span><br><span class="line">result : <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>이외에도 filter() 함수와 비슷한 함수들이 존재한다. 이름만 보고 어떤 기능을 할지 짐작이 가능하다.</p>
<ul>
<li><code>first(default)</code> : Observable의 첫 번째 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다.</li>
<li><code>last(default)</code> : Observable의 마지막 값을 필터한다. 만약 값 없이 완료되면 기본값을 반환한다.</li>
<li><code>take(N)</code> : 최초 N개 값만 가져온다.</li>
<li><code>takeLast(N)</code> : 마지막 N개 값만 필터한다.</li>
<li><code>skip(N)</code> : 최초 N개 값을 건너뛴다.</li>
<li><code>skipLast(N)</code> : 마지막 N개 값을 건너뛴다.</li>
</ul>
<p>사용 예제는 아래와 같다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source = Observable.just(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>, <span class="number">600</span>)</span><br><span class="line">    <span class="keyword">var</span> single: Single&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. first</span></span><br><span class="line">    single = source.first(<span class="number">-1</span>)</span><br><span class="line">    single.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"first result : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. last</span></span><br><span class="line">    single = source.last(<span class="number">-1</span>)</span><br><span class="line">    single.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"last result : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. take</span></span><br><span class="line">    source.take(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"take result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. takeLast</span></span><br><span class="line">    source.takeLast(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"takeLast result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. skip -&gt; 300,400,500,600</span></span><br><span class="line">    source.skip(<span class="number">2</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"skip result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. skipLast -&gt; 100,200,300</span></span><br><span class="line">    source.skipLast(<span class="number">3</span>)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"skipLast result : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">first result : <span class="number">100</span></span><br><span class="line">last result : <span class="number">600</span></span><br><span class="line">take result : <span class="number">100</span></span><br><span class="line">take result : <span class="number">200</span></span><br><span class="line">take result : <span class="number">300</span></span><br><span class="line">takeLast result : <span class="number">400</span></span><br><span class="line">takeLast result : <span class="number">500</span></span><br><span class="line">takeLast result : <span class="number">600</span></span><br><span class="line">skip result : <span class="number">300</span></span><br><span class="line">skip result : <span class="number">400</span></span><br><span class="line">skip result : <span class="number">500</span></span><br><span class="line">skip result : <span class="number">600</span></span><br><span class="line">skipLast result : <span class="number">100</span></span><br><span class="line">skipLast result : <span class="number">200</span></span><br><span class="line">skipLast result : <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h3 id="4reduce">4.reduce()</h3>
<ul>
<li>발행한 데이터를 모두 사용하여 어떤 최종 결과 데이터를 합성할 때 활용한다.</li>
<li>함수형 프로그래밍의 가장 기본 연산자인 map/filter/reduce 패턴을 이루는 마지막 필수 함수이다.</li>
<li>Observable을 이용해 들어오는 데이터를 1개씩 모아서 최종 결과를 만들어야 할 때 사용한다고 생각하면 된다. 주로 수치와 관련된 계산 문제에서 활용하면 좋다.</li>
</ul>
<p>보통 Observable에 입력된 데이터를 필요한 map() 함수로 매핑하고, 원하는 데이터만 추출할 때는 불필요한 데이터를 걸러내는 filter() 함수를 사용한다. 또한 상황에 따라 발행된 데이터를 취합하여 어떤 결과를 만들어낼 때는 reduce 계열의 함수를 사용한다.</p>
<img src="/img/rx_reduce.png" width="500" height="200">
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> source: Maybe&lt;String&gt; = Observable.just(<span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>)</span><br><span class="line">            .reduce &#123; ball1, ball2 -&gt;</span><br><span class="line">                <span class="string">"<span class="variable">$ball2</span>(<span class="variable">$ball1</span>)"</span></span><br><span class="line">            &#125;</span><br><span class="line">    source.subscribe(&#123;</span><br><span class="line">        println(<span class="string">"reduce 결과 : <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 람다 표현식을 별도 함수로 분리.</span></span><br><span class="line">    Observable.just(<span class="string">"1"</span>,<span class="string">"3"</span>,<span class="string">"5"</span>)</span><br><span class="line">            .reduce(mergeBalls)</span><br><span class="line">            .subscribe(&#123;</span><br><span class="line">                println(<span class="string">"reduce 함수로 분리한 결과 : <span class="variable">$it</span>"</span>)</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reduce() 함수를 호출하면 인자로 넘긴 람다 표현식에 의해 결과 없이 완료될 수도 있다. 따라서 Observable이 아니라 결과가 반환할 수도 아닐 수도 있는 <code>Maybe</code> 객체로 리턴된다.</p>
<h3 id="예제">예제</h3>
<p>다음과 같은 예제를 한번 작성해보자.</p>
<ol>
<li>전체 매출 데이터를 입력한다.</li>
<li>매출 데이터 중 TV 매출을 필터링한다.</li>
<li>TV 매출의 합을 구한다.</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 데이터 입력.</span></span><br><span class="line">    <span class="comment">// first : 상품 이름, second : 매출액.</span></span><br><span class="line">    <span class="keyword">var</span> sales = mutableListOf&lt;Pair&lt;String, <span class="built_in">Int</span>&gt;&gt;()</span><br><span class="line">    sales.add(<span class="string">"TV"</span> to <span class="number">2500</span>)</span><br><span class="line">    sales.add(<span class="string">"Camera"</span> to <span class="number">300</span>)</span><br><span class="line">    sales.add(<span class="string">"TV"</span> to <span class="number">1600</span>)</span><br><span class="line">    sales.add(<span class="string">"Phone"</span> to <span class="number">800</span>)</span><br><span class="line">    sales.add(<span class="string">"Sofa"</span> to <span class="number">10000</span>)</span><br><span class="line">    sales.add(Pair(<span class="string">"TV"</span>, <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> source: Maybe&lt;<span class="built_in">Int</span>&gt; = Observable.fromIterable(sales)</span><br><span class="line">            <span class="comment">// 2. 매출 데이터 중 TV 매출을 필터링한다.</span></span><br><span class="line">            .filter &#123; sale -&gt;</span><br><span class="line">                sale.first == <span class="string">"TV"</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// map 을 통해 sale 에서 매출액만 뽑는다.</span></span><br><span class="line">            .map &#123; sale -&gt;</span><br><span class="line">                sale.second</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. reduce 를 통해 매출의 합을 구한다.</span></span><br><span class="line">            .reduce &#123; sale1, sale2 -&gt;</span><br><span class="line">                sale1 + sale2</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">// reduce 를 호출하기 때문에 Observable 이 아니라 Maybe 를 사용한다.</span></span><br><span class="line"></span><br><span class="line">    source.subscribe(&#123; total -&gt;</span><br><span class="line">        println(<span class="string">"TV Sale: $ <span class="variable">$total</span>"</span>)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        println(<span class="string">"error : <span class="subst">$&#123;it.message&#125;</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">TV Sale: $ <span class="number">4100</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2019/05/22/RxJava-Chap03/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/8/"
                aria-label="NEWER POSTS"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>NEWER POSTS</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/10/"
                aria-label="OLDER POSTS"
            >
              <span>OLDER POSTS</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 9 of 26</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2020 VictoryWoo. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/Victory.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">VictoryWoo</h4>
        
            <div id="about-card-bio"><p>기록을 통해 사람들과 공유하는 것을 좋아합니다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Android Developer</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/color_blue.jpeg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->





    </body>
</html>
